{"pageProps":{"content":{"title":"OCaml Workshop 2020","pageDescription":"The OCaml Users and Developers Workshop 2020","introduction":"\n  The OCaml Users and Developers Workshop Jersey City, New Jersey, United States, August 28th, 2020.\n\n  The OCaml Users and Developers Workshop brings together the OCaml community, including users of OCaml in industry, academia, hobbyists, and the free software community.\n\n  The meeting is an informal community gathering of users of the language, library authors, and developers, using and extending OCaml in new ways. The meeting will be held online this year.\n  ","dates":[{"date":"March 30th","text":"Workshop announcement and submission website opens"},{"date":"May 7th","text":"Deadline extension"},{"date":"May 29th","text":"Abstract submission deadline"},{"date":"July 17th","text":"Author notification, talks are accepted"},{"date":"August 14th","text":"Camera-ready deadline"},{"date":"August 28th","text":"OCaml Workshop!"}],"presentations":[{"title":"A Declarative Syntax Definition for OCaml","slug":"a-declarative-syntax-definition-for-ocaml","description":"In this talk, we present our work on a syntax definition for the OCaml language in the syntax definition formalism SDF3. SDF3 supports the high-level definition of concrete and abstract syntax through declarative disambiguation and definition of constructors, enabling a direct mapping to abstract syntax. Based on the SDF3 syntax definition, the Spoofax language workbench produces a complete syntax aware editor with a parser, syntax checking, parse error recovery, syntax highlighting, formatting with correct parenthesis insertion, and syntactic completion. The syntax definition should provide a good basis for experiments with the design of OCaml and the development of further tooling. In the talk, we will highlight interesting aspects of the syntax definition, discuss issues we encountered in the syntax of OCaml, and demonstrate the editor.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":0},"paper":"A Declarative Syntax Definition for OCaml","link":"https://watch.ocaml.org/videos/watch/a5b86864-8e43-4138-b6d6-ed48d2d4b63d","embed":"https://watch.ocaml.org/videos/embed/a5b86864-8e43-4138-b6d6-ed48d2d4b63d","year":2020},{"title":"The Final Pieces of the OCaml Documentation Puzzle","slug":"the-final-pieces-of-the-ocaml-documentation-puzzle","description":"Rendering OCaml document is widely known as a very difficult task: The ever-evolving OCaml module system is extremely rich and can include complex set of inter-dependencies that are both difficult to compute and to render in a concise document. Its tasks are even harder than the typechecker as it also needs to keep track of documentation comments precisely and efficiently. As an example, signatures such as include F(X).T and destructive substitutions were never handled properly by any documentation generator.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":0},"paper":"The final pieces of the OCaml documentation puzzle","link":"https://watch.ocaml.org/videos/watch/2acebff9-25fa-4733-83cc-620a65b12251","embed":"https://watch.ocaml.org/videos/embed/2acebff9-25fa-4733-83cc-620a65b12251","year":2020},{"title":"OCaml-CI: A Zero-Configuration CI","slug":"ocaml-ci-a-zero-configuration-ci","description":"OCaml-CI is a CI service for OCaml projects. It uses metadata from the project’s opam and dune files to work out what to build, and uses caching to make builds fast. It automatically tests projects against multiple OCaml versions and OS platforms. The CI has been deployed on around 50 projects so far on GitHub, and many of them see response times an order of magnitude quicker than with less integrated CI solutions. This talk will introduce the CI service and then look at some of the technologies used to build it.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":0},"paper":"OCaml-CI: A Zero-Configuration CI","link":"https://watch.ocaml.org/videos/watch/0fee79e8-715a-400b-bfcc-34c3610f4890","embed":"https://watch.ocaml.org/videos/embed/0fee79e8-715a-400b-bfcc-34c3610f4890","year":2020},{"title":"State of the OCaml Platform 2020","slug":"state-of-the-ocaml-platform-2020","description":"This talk covers: integrated development environments, next steps for the OCaml Platform and plans for 2020-2021","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":{"hd":"ocaml-platform","tl":0}},"link":"https://watch.ocaml.org/videos/watch/0e2070fd-798b-47f7-8e69-ef75e967e516","embed":"https://watch.ocaml.org/videos/embed/0e2070fd-798b-47f7-8e69-ef75e967e516","year":2020},{"title":"Parallelising your OCaml Code with Multicore OCaml","slug":"parallelising-your-ocaml-code-with-multicore-ocaml","description":"This presentation will take the attendees through the following steps aimed at developing parallel programs with Multicore OCaml: installing the latest Multicore OCaml compiler, brief overview of the low-level API for parallel programming, a tour of domainslib – a high-level parallel programming library for Multicore OCaml, common pitfalls when parallelising and tools for diagnosing Multicore OCaml performance.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":{"hd":"multicore-ocaml","tl":0}},"paper":"Parallelising your OCaml Code with Multicore OCaml","link":"https://watch.ocaml.org/videos/watch/ce20839e-4bfc-4d74-925b-485a6b052ddf","embed":"https://watch.ocaml.org/videos/embed/ce20839e-4bfc-4d74-925b-485a6b052ddf","year":2020},{"title":"Types in Amber","slug":"types-in-amber","description":"Coda is a new cryptocurrency that uses zk-SNARKs to dramatically reduce the size of data needed by nodes running its protocol. Nodes communicate in a format automatically derived from type definitions in OCaml source files. As the Coda software evolves, these formats for sent data may change. We wish to allow nodes running older versions of the software to communicate with newer versions. To achieve that, we identify stable types that must not change over time, so that their serializations also do not change.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":0},"paper":"Types in Amber","link":"https://watch.ocaml.org/videos/watch/99b3dc75-9f93-4677-9f8b-076546725512","embed":"https://watch.ocaml.org/videos/embed/99b3dc75-9f93-4677-9f8b-076546725512","year":2020},{"title":"OCaml under the Hood: SmartPy","slug":"ocaml-under-the-hood-smartpy","description":"SmartPy is a complete system to develop smart-contracts for the Tezos blockchain. It is an embedded EDSL in python to write contracts and their test scenarios. It includes an online IDE, a chain explorer, and a command-line interface. Python is used to generate programs in an imperative, type-inferred, intermediate language called SmartML. SmartML is also the name of the OCaml library which provides an interpreter, a compiler to Michelson (the smart-contract language of Tezos), as well as a scenario “on-chain” interpreter. The IDE uses a mix of OCaml built with js_of_ocaml and pure Javascript. The command-line interface also builds with js_of_ocaml to run on Node.js.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":0},"paper":"OCaml Under the Hood: SmartPy","link":"https://watch.ocaml.org/videos/watch/7446ad4d-4ae2-4e1a-bc38-af8f71e8ebd8","embed":"https://watch.ocaml.org/videos/embed/7446ad4d-4ae2-4e1a-bc38-af8f71e8ebd8","year":2020},{"title":"LexiFi Runtime Types","slug":"lexifi-runtime-types","description":"OCaml programmers make deliberate use of abstract data types for composing safe and reliable software systems. The OCaml compiler relies on the invariants imposed by the type system to produce efficient and compact runtime data representations. Being no longer relevant, the type information is discarded after compilation. The resulting performance is a key feature of the OCaml language.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":0},"paper":"LexiFi Runtime Types","link":"https://watch.ocaml.org/videos/watch/cc7e3242-0bef-448a-aa13-8827bba933e3","embed":"https://watch.ocaml.org/videos/embed/cc7e3242-0bef-448a-aa13-8827bba933e3","year":2020},{"title":"The ImpFS Filesystem","slug":"the-impfs-filesystem","description":"This proposal describes a presentation to be given at the OCaml’20 workshop. The presentation will cover a new OCaml filesystem, ImpFS, and the related libraries. The filesystem makes use of a B-tree library presented at OCaml’17, and a key-value store presented at ML’19. In addition, there are a number of other support libraries that may be of interest to the community. ImpFS represents a single point in the filesystem design space, but we hope that the libraries we have developed will enable others to build further filesystems with novel features.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":0},"paper":"The ImpFS Filesystem","link":"https://watch.ocaml.org/videos/watch/28545b27-4637-47a5-8edd-6b904daef19c","embed":"https://watch.ocaml.org/videos/embed/28545b27-4637-47a5-8edd-6b904daef19c","year":2020},{"title":"Irmin v2","slug":"irmin-v2","description":"Irmin is an OCaml library for building distributed databases with the same design principles as Git. Existing Git users will find many familiar features: branching/merging, immutable causal history for all changes, and the ability to restore to any previous state. It has been extensively used by major software projects over the past few years such as Docker for Mac/Windows, and noticeably through DataKit, which powers hundreds of thousands monthly builds on the opam-repository CI contributors may be familiar with.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":{"hd":"irmin","tl":0}},"paper":"Irmin v2","link":"https://watch.ocaml.org/videos/watch/53e497b0-898f-4c85-8da9-39f65ef0e0b1","embed":"https://watch.ocaml.org/videos/embed/53e497b0-898f-4c85-8da9-39f65ef0e0b1","year":2020},{"title":"AD-OCaml: Algorithmic Differentiation for OCaml","slug":"ad-ocaml-algorithmic-differentiation-for-ocaml","description":"AD-OCaml is a library framework for calculating mathematically exact derivatives and deep power series approximations of almost arbitrary OCaml programs via algorithmic differentiation. Unlike similar frameworks, this includes programs with side effects, aliasing, and programs with nested derivative operators. The framework also offers implicit parallelization of both user programs and their transformations.\n\nThe presentation will provide a short introduction to the mathematical problem, the difficulties of implementing a solution, the design of the library, and a demonstration of its capabilities.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":0},"paper":"AD-OCaml: Algorithmic Differentiation for OCaml","link":"https://watch.ocaml.org/videos/watch/c9e85690-732f-4b03-836f-2ee0fd8f0658","embed":"https://watch.ocaml.org/videos/embed/c9e85690-732f-4b03-836f-2ee0fd8f0658","year":2020},{"title":"API migration: compare transformed","slug":"api-migration-compare-transformed","description":"In this talk we describe our experience in using an automatic API-migration strategy dedicated at changing the signatures of OCaml functions, using the Rotor refactoring tool for OCaml. We perform a case study on open source Jane Street libraries by using Rotor to refactor comparison functions so that they return a more precise variant type rather than an integer. We discuss the difficulties of refactoring the Jane Street code base, which makes extensive use of ppx macros, and ongoing work implementing new refactorings.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":0},"paper":"API migration: compare transformed","link":"https://watch.ocaml.org/videos/watch/c46b925b-bd77-404f-ac5d-5dab65047529","embed":"https://watch.ocaml.org/videos/embed/c46b925b-bd77-404f-ac5d-5dab65047529","year":2020},{"title":"A Simple State-Machine Framework for Property-Based Testing in OCaml","slug":"a-simple-state-machine-framework-for-property-based-testing-in-ocaml","description":"Since their inception, state-machine frameworks have proven their worth by finding defects in everything from the underlying AUTOSAR components of Volvo cars to digital invoicing systems. These case studies were carried out with Erlang’s commercial QuickCheck state-machine framework from Quviq, but such frameworks are now also available for Haskell, F#, Scala, Elixir, Java, etc. We present a typed state-machine framework for OCaml based on the QCheck library and illustrate a number of concepts common to all such frameworks: state modeling, commands, interpreting commands, preconditions, and agreement checking.","people":0,"kind":"Conference","tags":{"hd":"ocaml-workshop","tl":0},"paper":"A Simple State-Machine Framework for Property-Based Testing in OCaml","link":"https://watch.ocaml.org/videos/watch/08b429ea-2eb8-427d-a625-5495f4ee0fef","embed":"https://watch.ocaml.org/videos/embed/08b429ea-2eb8-427d-a625-5495f4ee0fef","year":2020}],"papers":[{"title":"A Declarative Syntax Definition for OCaml","slug":"a-declarative-syntax-definition-for-ocaml","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Luis Eduardo de Souza Amorim","tl":{"hd":"Eelco Visser","tl":0}},"abstract":"In this talk we present our work on a syntax definition for the OCaml language in the syntax definition formalism SDF3.  SDF3 supports high-level definition of concrete and abstract syntax through declarative disambiguation and definition of  constructors, enabling a direct mapping to abstract syntax. Based on the SDF3 syntax definition, the Spoofax language  workbench produces a complete syntax aware editor with a parser, syntax checking, parse error recovery, syntax highlighting,  formatting with correct parenthesis insertion, and syntactic completion. The syntax definition should provide a good  basis for experiments with the design of OCaml and the development of further tooling. In the talk we will highlight  interesting aspects the syntax definition, discuss issues we encountered in the syntax of OCaml, and demonstrate the editor.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://eelcovisser.org/talks/2020/08/28/ocaml/","tl":0}},{"title":"A Simple State-Machine Framework for Property-Based Testing in OCaml","slug":"a-simple-state-machine-framework-for-property-based-testing-in-ocaml","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Jan Midtgaard","tl":0},"abstract":"Since their inception state-machine frameworks have proven their worth by finding defects in everything  from the underlying AUTOSAR components of Volvo cars to digital invoicing sys- tems. These case studies were carried  out with Erlang’s commercial QuickCheck state-machine framework from Quviq, but such frameworks are now also available  for Haskell, F#, Scala, Elixir, Java, etc. We present a typed state-machine framework for OCaml based on the QCheck  library and illustrate a number concepts common to all such frameworks: state modeling, commands, interpreting commands, preconditions, and agreement checking.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://janmidtgaard.dk/papers/Midtgaard%3AOCaml20.pdf","tl":0}},{"title":"AD-OCaml: Algorithmic Differentiation for OCaml","slug":"ad-ocaml-algorithmic-differentiation-for-ocaml","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Markus Mottl","tl":0},"abstract":"AD-OCaml is a library framework for calculating mathematically exact derivatives and  deep power series approximations of almost arbitrary OCaml programs via algorithmic  differentiation. Unlike similar frameworks, this includes programs with side effects,  aliasing, and programs with nested derivative operators. The framework also offers implicit  parallelization of both user programs and their transformations. The presentation will provide  a short introduction to the mathematical problem, the difficulties of implementing a solution,  the design of the library, and a demonstration of its capabilities.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://icfp20.sigplan.org/details/ocaml-2020-papers/12/AD-OCaml-Algorithmic-Differentiation-for-OCaml","tl":0}},{"title":"API migration: compare transformed","slug":"api-migration-compare-transformed","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Joseph Harrison","tl":{"hd":"Steven Varoumas","tl":{"hd":"Simon Thompson","tl":{"hd":"Reuben Rowe","tl":0}}}},"abstract":"In this talk we describe our experience in using an automatic API-migration strategy dedicated at changing  the signatures of OCaml functions, using the Rotor refactoring tool for OCaml. We perform a case study on  open source Jane Street libraries by using Rotor to refactor comparison functions so that they return a  more precise variant type rather than an integer. We discuss the difficulties of refactoring the Jane Street  code base, which makes extensive use of ppx macros, and ongoing work implementing new refactorings.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://icfp20.sigplan.org/details/ocaml-2020-papers/7/API-migration-compare-transformed","tl":{"hd":"https://www.cs.kent.ac.uk/people/staff/sjt/Pubs/OCaml_workshop2020.pdf","tl":0}}},{"title":"Irmin v2","slug":"irmin-v2","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Clément Pascutto","tl":{"hd":"Ioana Cristescu","tl":{"hd":"Craig Ferguson","tl":{"hd":"Thomas Gazagnaire","tl":{"hd":"Romain Liautaud","tl":0}}}}},"abstract":"Irmin is an OCaml library for building distributed databases with the same design principles as Git.  Existing Git users will find many familiar features: branching/merging, immutable causal history for  all changes, and the ability to restore to any previous state. Irmin v2 adds new accessibility methods  to the store: we can now use Irmin from a CLI, or in a browser using irmin-graphql. It also has a new  backend, irmin-pack, which is optimised for space usage and is used by the Tezos blockchain.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://icfp20.sigplan.org/details/ocaml-2020-papers/10/Irmin-v2","tl":{"hd":"https://tarides.com/blog/2019-11-21-irmin-v2","tl":0}}},{"title":"LexiFi Runtime Types","slug":"lexifi-runtime-types","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Patrik Keller","tl":{"hd":"Marc Lasson","tl":0}},"abstract":"LexiFi maintains an OCaml compiler extension that enables introspection through runtime type representations.  Recently, we implemented a syntax extension (PPX) that enables the use of LexiFi runtime types on vanilla compilers.  We propose to present our publicly available runtime types and their features. Most notably, we want to present  a mechanism for pattern matching on runtime types with holes.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://icfp20.sigplan.org/details/ocaml-2020-papers/9/LexiFi-Runtime-Types","tl":{"hd":"https://informationsecurity.uibk.ac.at/pdfs/KL2020_LexiFi_Runtime_Types_OCAML.pdf","tl":{"hd":"https://www.lexifi.com/blog/ocaml/runtime-types/","tl":0}}}},{"title":"OCaml Under the Hood: SmartPy","slug":"ocaml-under-the-hood-smartpy","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Sebastien Mondet","tl":0},"abstract":"SmartPy is a complete system to develop smart-contracts for the Tezos blockchain. It is an embedded EDSL in python  to write contracts and their tests scenarios. It includes an online IDE, a chain explorer, and a command line interface.  Python is used to generate programs in an imperative, type inferred, intermediate language called SmartML. SmartML is  also the name of the OCaml library which provides an interpreter, a compiler to Michelson (the smart-contract language of Tezos),  as well as a scenario “on-chain” interpreter. The IDE uses a mix of OCaml built with js_of_ocaml and pure Javascript.  The command line interface also builds with js_of_ocaml to run on Node.js.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://icfp20.sigplan.org/details/ocaml-2020-papers/11/OCaml-Under-The-Hood-SmartPy","tl":{"hd":"https://wr.mondet.org/paper/smartpy-ocaml-2020.pdf","tl":0}}},{"title":"OCaml-CI: A Zero-Configuration CI","slug":"ocaml-ci-a-zero-configuration-ci","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Thomas Leonard","tl":{"hd":"Craig Ferguson","tl":{"hd":"Kate Deplaix","tl":{"hd":"Magnus Skjegstad","tl":{"hd":"Anil Madhavapeddy","tl":0}}}}},"abstract":"OCaml-CI is a CI service for OCaml projects. It uses metadata from the project’s opam and dune files to work out what to build,  and uses caching to make builds fast. It automatically tests projects against multiple OCaml versions and OS platforms. The CI has been deployed on around 50 projects so far on GitHub, and many of them see response times an order of magnitude quicker than  with less integrated CI solutions. This talk will introduce the CI service and then look at some of the technologies used to build it.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://icfp20.sigplan.org/details/ocaml-2020-papers/6/OCaml-CI-A-Zero-Configuration-CI","tl":0}},{"title":"Parallelising your OCaml Code with Multicore OCaml","slug":"parallelising-your-ocaml-code-with-multicore-ocaml","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Sadiq Jaffer","tl":{"hd":"Sudha Parimala","tl":{"hd":"KC Sivaramarkrishnan","tl":{"hd":"Tom Kelly","tl":{"hd":"Anil Madhavapeddy","tl":0}}}}},"abstract":"With the availability of multicore variants of the recent OCaml versions (4.10 and 4.11) that maintain  backwards compatibility with the existing OCaml C-API, there has been increasing interest in the wider  OCaml community for parallelising existing OCaml code.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://github.com/ocaml-multicore/multicore-talks/blob/master/ocaml2020-workshop-parallel/multicore-ocaml20.pdf","tl":{"hd":"https://icfp20.sigplan.org/details/ocaml-2020-papers/5/Parallelising-your-OCaml-Code-with-Multicore-OCaml","tl":0}}},{"title":"The ImpFS Filesystem","slug":"the-impfs-filesystem","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Tom Ridge","tl":0},"abstract":"This proposal describes a presentation to be given at the OCaml’20 workshop. The presentation will cover a new OCaml filesystem,  ImpFS, and the related libraries. The filesystem makes use of a B-tree library presented at OCaml’17, and a key-value store  presented at ML’19. In addition, there are a number of other support libraries that may be of interest to the community. ImpFS  represents a single point in the filesystem design space, but we hope that the libraries we have developed will enable others to  build further filesystems with novel features.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://icfp20.sigplan.org/details/ocaml-2020-papers/8/The-ImpFS-filesystem","tl":0}},{"title":"The final pieces of the OCaml documentation puzzle","slug":"the-final-pieces-of-the-ocaml-documentation-puzzle","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Jonathan Ludlam","tl":{"hd":"Gabriel Radanne","tl":{"hd":"Leo White","tl":0}}},"abstract":"Odoc is the latest attempt at creating a documentation tool which handles the full complexity of the OCaml language. It has been a long  time coming as tackling both the module system and rendering into rich documents makes for a difficult task. Nevertheless we believe  the two recent developments provides the final pieces of the OCaml documentation puzzle. This two improvements split odoc in two  layers: a model layer, with a deep understanding of the module system, and a document layer allowing for easy definition of new outputs.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://icfp20.sigplan.org/details/ocaml-2020-papers/4/The-final-pieces-of-the-OCaml-documentation-puzzle","tl":0}},{"title":"Types in Amber","slug":"types-in-amber","publication":"International Conference on Functional Programming (ICFP)","authors":{"hd":"Paul Steckler","tl":{"hd":"Matthew Ryan","tl":0}},"abstract":"Coda is a new cryptocurrency that uses zk-SNARKs to dramatically reduce the size of data needed by nodes running its protocol. Nodes communicate  in a format automatically derived from type definitions in OCaml source files. As the Coda software evolves, these formats for sent data may change. We wish to allow nodes running older versions of the software to communicate with newer versions. To achieve that, we identify stable types that  must not change over time, so that their serializations also do not change.\n","tags":{"hd":"ocaml-workshop","tl":0},"year":2020,"links":{"hd":"https://icfp20.sigplan.org/details/ocaml-2020-papers/3/Types-in-amber","tl":0}}]},"params":{"lang":"en"}},"__N_SSG":true}