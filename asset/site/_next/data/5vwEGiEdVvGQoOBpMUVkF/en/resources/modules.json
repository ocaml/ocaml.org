{"pageProps":{"content":{"source":"<h2 id=\"basic-usage\">Basic usage</h2>\n<p>In OCaml, every piece of code is wrapped into a module. Optionally, a module\nitself can be a submodule of another module, pretty much like directories in a\nfile system - but we don't do this very often.</p>\n<p>When you write a program let's say using two files <code>amodule.ml</code> and\n<code>bmodule.ml</code>, each of these files automatically defines a module named\n<code>Amodule</code> and a module named <code>Bmodule</code> that provide whatever you put into the\nfiles.</p>\n<p>Here is the code that we have in our file <code>amodule.ml</code>:</p>\n<!-- $MDX file=examples/amodule.ml -->\n<pre><code class=\"language-ocaml\">let hello () = print_endline &quot;Hello&quot;\n</code></pre>\n<p>And here is what we have in <code>bmodule.ml</code>:</p>\n<!-- $MDX file=examples/bmodule.ml -->\n<pre><code class=\"language-ocaml\">let () = Amodule.hello ()\n</code></pre>\n<p>We can compile the files in one command:</p>\n<!-- $MDX dir=examples -->\n<pre><code class=\"language-sh\">$ ocamlopt -o hello amodule.ml bmodule.ml\n</code></pre>\n<p>Or, as a build system might do, one by one:</p>\n<!-- $MDX dir=examples -->\n<pre><code class=\"language-sh\">$ ocamlopt -c amodule.ml\n$ ocamlopt -c bmodule.ml\n$ ocamlopt -o hello amodule.cmx bmodule.cmx\n</code></pre>\n<p>Now we have an executable that prints &quot;Hello&quot;. As you can see, if you want to\naccess anything from a given module, use the name of the module (always\nstarting with a capital) followed by a dot and the thing that you want to use.\nIt may be a value, a type constructor, or anything else that a given module can\nprovide.</p>\n<p>Libraries, starting with the standard library, provide collections of modules.\nfor example, <code>List.iter</code> designates the <code>iter</code> function from the <code>List</code> module.</p>\n<p>If you are using a given module heavily, you may want to make its contents\ndirectly accessible. For this, we use the <code>open</code> directive. In our example,\n<code>bmodule.ml</code> could have been written:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">open Amodule\nlet () = hello ()\n</code></pre>\n<p>Using <code>open</code> or not is a matter of personal taste. Some modules provide names\nthat are used in many other modules. This is the case of the <code>List</code> module for\ninstance. Usually, we don't do <code>open List</code>. Other modules like <code>Printf</code> provide\nnames that are normally not subject to conflicts, such as <code>printf</code>. In order to\navoid writing <code>Printf.printf</code> all over the place, it often makes sense to place\none <code>open Printf</code> at the beginning of the file:</p>\n<pre><code class=\"language-ocaml\">open Printf\nlet data = [&quot;a&quot;; &quot;beautiful&quot;; &quot;day&quot;]\nlet () = List.iter (printf &quot;%s\\n&quot;) data\n</code></pre>\n<p>There are also local <code>open</code>s:</p>\n<pre><code class=\"language-ocaml\"># let map_3d_matrix f m =\n  let open Array in\n    map (map (map f)) m\nval map_3d_matrix :\n  ('a -&gt; 'b) -&gt; 'a array array array -&gt; 'b array array array = &lt;fun&gt;\n# let map_3d_matrix' f =\n  Array.(map (map (map f)))\nval map_3d_matrix' :\n  ('a -&gt; 'b) -&gt; 'a array array array -&gt; 'b array array array = &lt;fun&gt;\n</code></pre>\n<h2 id=\"interfaces-and-signatures\">Interfaces and signatures</h2>\n<p>A module can provide a certain number of things (functions, types, submodules,\n...) to the rest of the program that is using it. If nothing special is done,\neverything which is defined in a module will be accessible from the outside. That's\noften fine in small personal programs, but there are many situations where it\nis better that a module only provides what it is meant to provide, not any of\nthe auxiliary functions and types that are used internally.</p>\n<p>For this, we have to define a module interface, which will act as a mask over\nthe module's implementation. Just like a module derives from a .ml file, the\ncorresponding module interface or signature derives from an .mli file. It\ncontains a list of values with their type. Let's rewrite our <code>amodule.ml</code> file\nto something called <code>amodule2.ml</code>:</p>\n<!-- $MDX file=examples/amodule2.ml -->\n<pre><code class=\"language-ocaml\">let hello () = print_endline &quot;Hello&quot;\n</code></pre>\n<p>As it is, <code>Amodule</code> has the following interface:</p>\n<pre><code class=\"language-ocaml\">val message : string\n\nval hello : unit -&gt; unit\n</code></pre>\n<pre><code class=\"language-mdx-error\">Line 1, characters 1-21:\nError: Value declarations are only allowed in signatures\n</code></pre>\n<p>Let's assume that accessing the <code>message</code> value directly is none of the others\nmodules' business. We want to hide it by defining a restricted interface. This\nis our <code>amodule2.mli</code> file:</p>\n<!-- $MDX file=examples/amodule2.mli -->\n<pre><code class=\"language-ocaml\">val hello : unit -&gt; unit\n(** Displays a greeting message. *)\n</code></pre>\n<p>(note the double asterisk at the beginning of the comment - it is a good habit\nto document .mli files using the format supported by\n[ocamldoc](/releases/{{! get LATEST_OCAML_VERSION_MAIN !}}/htmlman/ocamldoc.html))</p>\n<p>Such .mli files must be compiled just before the matching .ml files. They are\ncompiled using <code>ocamlc</code>, even if .ml files are compiled to native code using\n<code>ocamlopt</code>:</p>\n<!-- $MDX dir=examples -->\n<pre><code class=\"language-sh\">$ ocamlc -c amodule2.mli\n$ ocamlopt -c amodule2.ml\n</code></pre>\n<h2 id=\"abstract-types\">Abstract types</h2>\n<p>What about type definitions? We saw that values such as functions can be\nexported by placing their name and their type in a .mli file, e.g.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">val hello : unit -&gt; unit\n</code></pre>\n<p>But modules often define new types. Let's define a simple record type that\nwould represent a date:</p>\n<pre><code class=\"language-ocaml\">type date = {day : int; month : int; year : int}\n</code></pre>\n<p>There are four options when it comes to writing the .mli file:</p>\n<ol>\n<li>The type is completely omitted from the signature.\n</li>\n<li>The type definition is copy-pasted into the signature.\n</li>\n<li>The type is made abstract: only its name is given.\n</li>\n<li>The record fields are made read-only: <code>type date = private { ... }</code>\n</li>\n</ol>\n<p>Case 3 would look like this:</p>\n<pre><code class=\"language-ocaml\">type date\n</code></pre>\n<p>Now, users of the module can manipulate objects of type <code>date</code>, but they can't\naccess the record fields directly. They must use the functions that the module\nprovides. Let's assume the module provides three functions, one for creating a\ndate, one for computing the difference between two dates, and one that returns\nthe date in years:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">type date\n\nval create : ?days:int -&gt; ?months:int -&gt; ?years:int -&gt; unit -&gt; date\n\nval sub : date -&gt; date -&gt; date\n\nval years : date -&gt; float\n</code></pre>\n<p>The point is that only <code>create</code> and <code>sub</code> can be used to create <code>date</code> records.\nTherefore, it is not possible for the user of the module to create ill-formed\nrecords. Actually, our implementation uses a record, but we could change it and\nbe sure that it will not break any code that relies on this module! This makes\na lot of sense in a library since subsequent versions of the same library can\ncontinue to expose the same interface, while internally changing the\nimplementation, including data structures.</p>\n<h2 id=\"submodules\">Submodules</h2>\n<h3 id=\"submodule-implementation\">Submodule implementation</h3>\n<p>We saw that one <code>example.ml</code> file results automatically in one module\nimplementation named <code>Example</code>. Its module signature is automatically derived\nand is the broadest possible, or can be restricted by writing an <code>example.mli</code>\nfile.</p>\n<p>That said, a given module can also be defined explicitly from within a file.\nThat makes it a submodule of the current module. Let's consider this\n<code>example.ml</code> file:</p>\n<pre><code class=\"language-ocaml\">module Hello = struct\n  let message = &quot;Hello&quot;\n  let hello () = print_endline message\nend\n\nlet goodbye () = print_endline &quot;Goodbye&quot;\n\nlet hello_goodbye () =\n  Hello.hello ();\n  goodbye ()\n</code></pre>\n<p>From another file, it is clear that we now have two levels of modules.  We can\nwrite:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let () =\n  Example.Hello.hello ();\n  Example.goodbye ()\n</code></pre>\n<h3 id=\"submodule-interface\">Submodule interface</h3>\n<p>We can also restrict the interface of a given submodule. It is called a module\ntype. Let's do it in our <code>example.ml</code> file:</p>\n<pre><code class=\"language-ocaml\">module Hello : sig\n val hello : unit -&gt; unit\nend\n= \nstruct\n  let message = &quot;Hello&quot;\n  let hello () = print_endline message\nend\n  \n(* At this point, Hello.message is not accessible anymore. *)\n\nlet goodbye () = print_endline &quot;Goodbye&quot;\n\nlet hello_goodbye () =\n  Hello.hello ();\n  goodbye ()\n</code></pre>\n<p>The definition of the <code>Hello</code> module above is the equivalent of a\n<code>hello.mli</code>/<code>hello.ml</code> pair of files. Writing all of that in one block of code\nis not elegant so, in general, we prefer to define the module signature\nseparately:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">module type Hello_type = sig\n val hello : unit -&gt; unit\nend\n  \nmodule Hello : Hello_type = struct\n  ...\nend\n</code></pre>\n<p><code>Hello_type</code> is a named module type, and can be reused to define other module\ninterfaces.</p>\n<h2 id=\"practical-manipulation-of-modules\">Practical manipulation of modules</h2>\n<h3 id=\"displaying-the-interface-of-a-module\">Displaying the interface of a module</h3>\n<p>You can use the <code>ocaml</code> toplevel to visualize the contents of an existing\nmodule, such as <code>List</code>:</p>\n<pre><code class=\"language-ocaml\"># #show List;;\nmodule List = List\nmodule List :\n  sig\n    type 'a t = 'a list = [] | (::) of 'a * 'a list\n    val length : 'a t -&gt; int\n    val compare_lengths : 'a t -&gt; 'b t -&gt; int\n    val compare_length_with : 'a t -&gt; int -&gt; int\n    val cons : 'a -&gt; 'a t -&gt; 'a t\n    val hd : 'a t -&gt; 'a\n    val tl : 'a t -&gt; 'a t\n    val nth : 'a t -&gt; int -&gt; 'a\n    val nth_opt : 'a t -&gt; int -&gt; 'a option\n    val rev : 'a t -&gt; 'a t\n    val init : int -&gt; (int -&gt; 'a) -&gt; 'a t\n    val append : 'a t -&gt; 'a t -&gt; 'a t\n    val rev_append : 'a t -&gt; 'a t -&gt; 'a t\n    val concat : 'a t t -&gt; 'a t\n    val flatten : 'a t t -&gt; 'a t\n    val iter : ('a -&gt; unit) -&gt; 'a t -&gt; unit\n    val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit\n    val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val rev_map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val filter_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b t\n    val concat_map : ('a -&gt; 'b t) -&gt; 'a t -&gt; 'b t\n    val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'a\n    val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a t -&gt; 'b -&gt; 'b\n    val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a t -&gt; 'b t -&gt; unit\n    val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t\n    val rev_map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t\n    val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'c t -&gt; 'a\n    val fold_right2 : ('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c -&gt; 'c\n    val for_all : ('a -&gt; bool) -&gt; 'a t -&gt; bool\n    val exists : ('a -&gt; bool) -&gt; 'a t -&gt; bool\n    val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool\n    val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool\n    val mem : 'a -&gt; 'a t -&gt; bool\n    val memq : 'a -&gt; 'a t -&gt; bool\n    val find : ('a -&gt; bool) -&gt; 'a t -&gt; 'a\n    val find_opt : ('a -&gt; bool) -&gt; 'a t -&gt; 'a option\n    val find_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b option\n    val filter : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t\n    val find_all : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t\n    val partition : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t * 'a t\n    val assoc : 'a -&gt; ('a * 'b) t -&gt; 'b\n    val assoc_opt : 'a -&gt; ('a * 'b) t -&gt; 'b option\n    val assq : 'a -&gt; ('a * 'b) t -&gt; 'b\n    val assq_opt : 'a -&gt; ('a * 'b) t -&gt; 'b option\n    val mem_assoc : 'a -&gt; ('a * 'b) t -&gt; bool\n    val mem_assq : 'a -&gt; ('a * 'b) t -&gt; bool\n    val remove_assoc : 'a -&gt; ('a * 'b) t -&gt; ('a * 'b) t\n    val remove_assq : 'a -&gt; ('a * 'b) t -&gt; ('a * 'b) t\n    val split : ('a * 'b) t -&gt; 'a t * 'b t\n    val combine : 'a t -&gt; 'b t -&gt; ('a * 'b) t\n    val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val stable_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val fast_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val sort_uniq : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val merge : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t -&gt; 'a t\n    val to_seq : 'a t -&gt; 'a Seq.t\n    val of_seq : 'a Seq.t -&gt; 'a t\n  end\n</code></pre>\n<p>There is online documentation for each library.</p>\n<h3 id=\"module-inclusion\">Module inclusion</h3>\n<p>Let's say we feel that a function is missing from the standard <code>List</code> module,\nbut we really want it as if it were part of it. In an <code>extensions.ml</code> file, we\ncan achieve this effect by using the <code>include</code> directive:</p>\n<pre><code class=\"language-ocaml\"># module List = struct\n  include List\n  let rec optmap f = function\n    | [] -&gt; []\n    | hd :: tl -&gt;\n       match f hd with\n       | None -&gt; optmap f tl\n       | Some x -&gt; x :: optmap f tl\n  end\nmodule List :\n  sig\n    type 'a t = 'a list = [] | (::) of 'a * 'a list\n    val length : 'a t -&gt; int\n    val compare_lengths : 'a t -&gt; 'b t -&gt; int\n    val compare_length_with : 'a t -&gt; int -&gt; int\n    val cons : 'a -&gt; 'a t -&gt; 'a t\n    val hd : 'a t -&gt; 'a\n    val tl : 'a t -&gt; 'a t\n    val nth : 'a t -&gt; int -&gt; 'a\n    val nth_opt : 'a t -&gt; int -&gt; 'a option\n    val rev : 'a t -&gt; 'a t\n    val init : int -&gt; (int -&gt; 'a) -&gt; 'a t\n    val append : 'a t -&gt; 'a t -&gt; 'a t\n    val rev_append : 'a t -&gt; 'a t -&gt; 'a t\n    val concat : 'a t t -&gt; 'a t\n    val flatten : 'a t t -&gt; 'a t\n    val iter : ('a -&gt; unit) -&gt; 'a t -&gt; unit\n    val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit\n    val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val rev_map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val filter_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b t\n    val concat_map : ('a -&gt; 'b t) -&gt; 'a t -&gt; 'b t\n    val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'a\n    val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a t -&gt; 'b -&gt; 'b\n    val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a t -&gt; 'b t -&gt; unit\n    val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t\n    val rev_map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t\n    val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'c t -&gt; 'a\n    val fold_right2 : ('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c -&gt; 'c\n    val for_all : ('a -&gt; bool) -&gt; 'a t -&gt; bool\n    val exists : ('a -&gt; bool) -&gt; 'a t -&gt; bool\n    val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool\n    val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool\n    val mem : 'a -&gt; 'a t -&gt; bool\n    val memq : 'a -&gt; 'a t -&gt; bool\n    val find : ('a -&gt; bool) -&gt; 'a t -&gt; 'a\n    val find_opt : ('a -&gt; bool) -&gt; 'a t -&gt; 'a option\n    val find_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b option\n    val filter : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t\n    val find_all : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t\n    val partition : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t * 'a t\n    val assoc : 'a -&gt; ('a * 'b) t -&gt; 'b\n    val assoc_opt : 'a -&gt; ('a * 'b) t -&gt; 'b option\n    val assq : 'a -&gt; ('a * 'b) t -&gt; 'b\n    val assq_opt : 'a -&gt; ('a * 'b) t -&gt; 'b option\n    val mem_assoc : 'a -&gt; ('a * 'b) t -&gt; bool\n    val mem_assq : 'a -&gt; ('a * 'b) t -&gt; bool\n    val remove_assoc : 'a -&gt; ('a * 'b) t -&gt; ('a * 'b) t\n    val remove_assq : 'a -&gt; ('a * 'b) t -&gt; ('a * 'b) t\n    val split : ('a * 'b) t -&gt; 'a t * 'b t\n    val combine : 'a t -&gt; 'b t -&gt; ('a * 'b) t\n    val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val stable_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val fast_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val sort_uniq : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val merge : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t -&gt; 'a t\n    val to_seq : 'a t -&gt; 'a Seq.t\n    val of_seq : 'a Seq.t -&gt; 'a t\n    val optmap : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b t\n  end\n</code></pre>\n<p>It creates a module <code>Extensions.List</code> that has everything the standard <code>List</code>\nmodule has, plus a new <code>optmap</code> function. From another file, all we have to do\nto override the default <code>List</code> module is <code>open Extensions</code> at the beginning of\nthe .ml file:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">open Extensions\n\n...\n\nList.optmap ...\n</code></pre>\n","title":"Modules","pageDescription":"Learn about OCaml modules and how they can be used to cleanly separate distinct parts of your program\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#basic-usage\">Basic usage</a>\n</li>\n<li><a href=\"#interfaces-and-signatures\">Interfaces and signatures</a>\n</li>\n<li><a href=\"#abstract-types\">Abstract types</a>\n</li>\n<li><a href=\"#submodules\">Submodules</a>\n</li>\n<li><a href=\"#practical-manipulation-of-modules\">Practical manipulation of modules</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"modules"}},"__N_SSG":true}