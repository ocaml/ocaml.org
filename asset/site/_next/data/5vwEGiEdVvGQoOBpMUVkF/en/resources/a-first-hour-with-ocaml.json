{"pageProps":{"content":{"source":"<p>You may follow along with this tutorial with just a basic OCaml installation,\nas described in <a href=\"up_and_running.html\">Up and Running</a>.</p>\n<p>Alternatively, you may follow almost all of it by running OCaml in your browser\nusing <a href=\"https://try.ocamlpro.com\">TryOCaml</a>, with no installation required!!!</p>\n<h2 id=\"running-ocaml-code\">Running OCaml code</h2>\n<p>The easiest way to get started is to run an interactive session in\nyour browser thanks to <a href=\"https://try.ocamlpro.com\">TryOCaml</a>.</p>\n<p>To install OCaml on your computer, see the <a href=\"/docs/install.html\">Install</a> documentation.</p>\n<p>To quickly try small OCaml expressions, you can use an interactive\ntoplevel, or REPL (Read–Eval–Print Loop). The <code>ocaml</code> command provides\na very basic toplevel (you should install <code>rlwrap</code> through your system\npackage manager and run <code>rlwrap ocaml</code> to get history navigation).</p>\n<p>The recommended alternative REPL <a href=\"https://github.com/diml/utop\">utop</a> may be\ninstalled through <a href=\"/docs/install.html#OPAM\">OPAM</a> or your system package\nmanager. It has the same basic interface but is much more convenient to use\n(history navigation, auto-completion, etc.).</p>\n<p>Use <code>;;</code> to indicate that you've finished entering each expression and prompt OCaml to evaluate it. Here is what running <code>ocaml</code> looks like:</p>\n<pre><code class=\"language-console\">$ ocaml\n        OCaml version OCaml version 4.12.0\n\n# 1 + 1;;\n- : int = 2\n</code></pre>\n<p>This is how running the same code looks when using <code>utop</code>:</p>\n<pre><code class=\"language-console\">───────┬─────────────────────────────────────────────────────────────┬────\n       │ Welcome to utop version 2.7.0 (using OCaml version 4.12.0)! │     \n       └─────────────────────────────────────────────────────────────┘     \n\nType #utop_help for help about using utop.\n\n─( 10:12:16 )─&lt; command 0 &gt;───────────────────────────────────────────────\nutop # 1 + 1;;\n- : int = 2\n</code></pre>\n<h2 id=\"comments\">Comments</h2>\n<p>OCaml comments are delimited by <code>(*</code> and <code>*)</code>, like this:</p>\n<pre><code class=\"language-ocaml\">(* This is a single-line comment. *)\n\n(* This is a\n   multi-line\n   comment.\n*)\n</code></pre>\n<p>In other words, the commenting convention is very similar to original C\n(<code>/* ... */</code>). There is no single-line comment syntax (like\n<code># ...</code> in Python or <code>// ...</code> in C99/C++/Java).</p>\n<p>OCaml counts nested <code>(* ... *)</code> blocks, and this allows you to comment\nout regions of code very easily:</p>\n<pre><code class=\"language-ocaml\">(* This code is broken ...\n\n(* Primality test. *)\nlet is_prime n =\n  (* note to self: ask about this on the mailing lists *) XXX\n\n*)\n</code></pre>\n<h2 id=\"calling-functions\">Calling functions</h2>\n<p>Let's say you've written a function — we'll call it <code>repeated</code> — which\ntakes a string <code>s</code> and a number <code>n</code>, and returns a new string which\ncontains original <code>s</code> repeated <code>n</code> times.</p>\n<p>In most C-derived languages a call to this function will look like this:</p>\n<pre><code class=\"language-C\">repeated (&quot;hello&quot;, 3)  /* this is C code */\n</code></pre>\n<p>This means &quot;call the function <code>repeated</code> with two arguments, first\nargument the string hello and second argument the number 3&quot;.</p>\n<p>OCaml, in common with other functional languages, writes and brackets\nfunction calls differently, and this is the cause of many mistakes. Here\nis the same function call in OCaml:</p>\n<pre><code class=\"language-ocaml\">let repeated a b = a ^ (Int.to_string b);;\nrepeated &quot;hello&quot; 3  (* this is OCaml code *)\n</code></pre>\n<p>Note — <strong>no</strong> brackets, and <strong>no</strong> comma between the arguments.</p>\n<p>The syntax <code>repeated (&quot;hello&quot;, 3)</code> <strong>is</strong> meaningful in OCaml. It means\n&quot;call the function <code>repeated</code> with ONE argument, that argument being a\n'pair' structure of two elements&quot;. Of course that would be a mistake,\nbecause the <code>repeated</code> function is expecting two arguments, not one, and\nthe first argument should be a string, not a pair. But let's not worry\nabout pairs (&quot;tuples&quot;) just yet. Instead, just remember that it's a\nmistake to put the brackets and commas in around function call\narguments.</p>\n<p>Let's have another function — <code>prompt_string</code> — which takes a string to\nprompt and returns the string entered by the user. We want to pass this\nstring into <code>repeated</code>. Here are the C and OCaml versions:</p>\n<pre><code class=\"language-C\">/* C code: */\nrepeated (prompt_string (&quot;Name please: &quot;), 3)\n</code></pre>\n<pre><code class=\"language-ocaml\">let prompt_string p = &quot;&quot;;;\n(* OCaml code: *)\nrepeated (prompt_string &quot;Name please: &quot;) 3\n</code></pre>\n<p>Take a careful look at the bracketing and the missing comma. In the\nOCaml version, the brackets enclose the first argument of repeated\nbecause that argument is the result of another function call. In general\nthe rule is: &quot;bracket around the whole function call — don't put\nbrackets around the arguments to a function call&quot;. Here are some more\nexamples:</p>\n<pre><code class=\"language-ocaml\">let f a b c = &quot;&quot;;;\nlet g a = &quot;&quot;;;\nlet f2 a = &quot;&quot;;;\nlet g2 a b = &quot;&quot;;;\nf 5 (g &quot;hello&quot;) 3;;    (* f has three arguments, g has one argument *)\nf2 (g2 3 4)            (* f2 has one argument, g2 has two arguments *)\n</code></pre>\n<pre><code class=\"language-ocaml\"># repeated (&quot;hello&quot;, 3)     (* OCaml will spot the mistake *)\nLine 1, characters 10-22:\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n</code></pre>\n<h2 id=\"defining-a-function\">Defining a function</h2>\n<p>We all know how to define a function (or static method, in Java)\nin our existing languages. How do we do it in OCaml?</p>\n<p>The OCaml syntax is pleasantly concise. Here's a function which takes\ntwo floating point numbers and calculates the average:</p>\n<pre><code class=\"language-ocaml\">let average a b =\n  (a +. b) /. 2.0\n</code></pre>\n<p>Type this into the OCaml interactive toplevel (on Unix, type the command <code>ocaml</code>\nfrom the shell) and you'll see this:</p>\n<pre><code class=\"language-ocaml\"># let average a b =\n    (a +. b) /. 2.0;;\nval average : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>If you look at the function definition closely, and also at what OCaml\nprints back at you, you'll have a number of questions:</p>\n<ul>\n<li>What are those periods in <code>+.</code> and <code>/.</code> for?\n</li>\n<li>What does <code>float -&gt; float -&gt; float</code> mean?\n</li>\n</ul>\n<p>I'll answer those questions in the next sections, but first I want to go\nand define the same function in C (the Java definition would be fairly\nsimilar to C), and hopefully that should raise even more questions.\nHere's our C version of <code>average</code>:</p>\n<pre><code class=\"language-C\">double average (double a, double b)\n{\n  return (a + b) / 2;\n}\n</code></pre>\n<p>Now look at our much shorter OCaml definition above. Hopefully you'll be\nasking:</p>\n<ul>\n<li>Why don't we have to define the types of <code>a</code> and <code>b</code> in the OCaml\nversion? How does OCaml know what the types are (indeed, <em>does</em>\nOCaml know what the types are, or is OCaml completely dynamically\ntyped?).\n</li>\n<li>In C, the <code>2</code> is implicitly converted into a <code>double</code>, can't OCaml\ndo the same thing?\n</li>\n<li>What is the OCaml way to write <code>return</code>?\n</li>\n</ul>\n<p>OK, let's get some answers.</p>\n<ul>\n<li>OCaml is a strongly <em>statically typed</em> language (in other words,\nthere's nothing dynamic going on between int, float and string).\n</li>\n<li>OCaml uses <em>type inference</em> to work out the types, so you don't have\nto.  If you use the OCaml interactive toplevel as above, then OCaml\nwill tell you\nits inferred type for your function.\n</li>\n<li>OCaml doesn't do any implicit casting. If you want a float, you have\nto write <code>2.0</code> because <code>2</code> is an integer. OCaml does <strong>no automatic\nconversion</strong> between int, float, string or any other type.\n</li>\n<li>As a side-effect of type inference in OCaml, functions (including\noperators) can't have overloaded definitions. OCaml defines <code>+</code> as\nthe <em>integer</em> addition function. To add floats, use <code>+.</code> (note the\ntrailing period). Similarly, use <code>-.</code>, <code>*.</code>, <code>/.</code> for other float\noperations.\n</li>\n<li>OCaml doesn't have a <code>return</code> keyword — the last expression in a\nfunction becomes the result of the function automatically.\n</li>\n</ul>\n<p>We will present more details in the following sections and chapters.</p>\n<h2 id=\"basic-types\">Basic types</h2>\n<p>The basic types in OCaml are:</p>\n<pre><code class=\"language-text\">OCaml type  Range\n\nint         31-bit signed int (roughly +/- 1 billion) on 32-bit\n            processors, or 63-bit signed int on 64-bit processors\nfloat       IEEE double-precision floating point, equivalent to C's double\nbool        A boolean, written either 'true' or 'false'\nchar        An 8-bit character\nstring      A string\nunit        Written as ()\n</code></pre>\n<p>OCaml uses one of the bits in an <code>int</code> internally in order to be able to\nautomatically manage the memory use (garbage collection). This is why\nthe basic <code>int</code> is 31 bits, not 32 bits (63 bits if you're using a 64\nbit platform). In practice this isn't an issue except in a few\nspecialised cases. For example if you're counting things in a loop, then\nOCaml limits you to counting up to 1 billion instead of 2 billion. However if you need to do things\nsuch as processing 32 bit types (eg. you're writing crypto code or a\nnetwork stack), OCaml provides a <code>nativeint</code> type which matches the\nnative integer type for your platform.</p>\n<p>OCaml doesn't have a basic unsigned integer type, but you can get the\nsame effect using <code>nativeint</code>. OCaml doesn't have built-in single-precision\nfloating point numbers.</p>\n<p>OCaml provides a <code>char</code> type which is used for characters, written <code>'x'</code>\nfor example. Unfortunately the <code>char</code> type does not support Unicode or\nUTF-8, There are <a href=\"https://github.com/yoriyuki/Camomile\">comprehensive Unicode libraries</a>\nwhich provide this functionality.</p>\n<p>Strings are not just lists of characters. They have their own, more\nefficient internal representation. Strings are immutable.</p>\n<p>The <code>unit</code> type is sort of like <code>void</code> in C, but we'll talk about it\nmore below.</p>\n<h2 id=\"implicit-vs-explicit-casts\">Implicit vs. explicit casts</h2>\n<p>In C-derived languages ints get promoted to floats in certain\ncircumstances. For example if you write <code>1 + 2.5</code> then the first\nargument (which is an integer) is promoted to a floating point number,\nand the result is also a floating point number. It's as if you had\nwritten <code>((double) 1) + 2.5</code>, but all done implicitly.</p>\n<p>OCaml never does implicit casts like this. In OCaml, <code>1 + 2.5</code> is a type\nerror. The <code>+</code> operator in OCaml requires two ints as arguments, and\nhere we're giving it an int and a float, so it reports this error:</p>\n<pre><code class=\"language-ocaml\"># 1 + 2.5;;\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n</code></pre>\n<p>To add two floats together you need to use a different operator, <code>+.</code>\n(note the trailing period).</p>\n<p>OCaml doesn't promote ints to floats automatically so this is also an\nerror:</p>\n<pre><code class=\"language-ocaml\"># 1 +. 2.5\nLine 1, characters 1-2:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.'?\n</code></pre>\n<p>Here OCaml is now complaining about the first argument.</p>\n<p>What if you actually want to add an integer and a floating point number\ntogether? (Say they are stored as <code>i</code> and <code>f</code>). In OCaml you need to\nexplicitly cast:</p>\n<pre><code class=\"language-ocaml\">let i = 1;;\nlet f = 2.0;;\nfloat_of_int i +. f\n</code></pre>\n<p><code>float_of_int</code> is a function which takes an <code>int</code> and returns a <code>float</code>.\nThere are a whole load of these functions, called such things as\n<code>int_of_float</code>, <code>char_of_int</code>, <code>int_of_char</code>, <code>string_of_int</code> and so on,\nand they mostly do what you expect.</p>\n<p>Since converting an <code>int</code> to a <code>float</code> is a particularly common\noperation, the <code>float_of_int</code> function has a shorter alias: the above\nexample could simply have been written</p>\n<pre><code class=\"language-ocaml\">float i +. f\n</code></pre>\n<p>(Note that it is perfectly valid in OCaml for a type and a\nfunction to have the same name.)</p>\n<h3 id=\"is-implicit-or-explicit-casting-better\">Is implicit or explicit casting better?</h3>\n<p>You might think that these explicit casts are ugly, time-consuming even,\nand you have a point, but there are at least two arguments in their\nfavour. Firstly, OCaml needs this explicit casting to be able to do type\ninference (see below), and type inference is such a wonderful\ntime-saving feature that it easily offsets the extra keyboarding of\nexplicit casts. Secondly, if you've spent time debugging C programs\nyou'll know that (a) implicit casts cause errors which are hard to find,\nand (b) much of the time you're sitting there trying to work out where\nthe implicit casts happen. Making the casts explicit helps you in\ndebugging. Thirdly, some casts (particularly int &lt;-&gt; float) are\nactually very expensive operations. You do yourself no favours by hiding\nthem.</p>\n<h2 id=\"ordinary-functions-and-recursive-functions\">Ordinary functions and recursive functions</h2>\n<p>Unlike in C-derived languages, a function isn't recursive unless you\nexplicitly say so by using <code>let rec</code> instead of just <code>let</code>. Here's an\nexample of a recursive function:</p>\n<pre><code class=\"language-ocaml\"># let rec range a b =\n    if a &gt; b then []\n    else a :: range (a + 1) b\nval range : int -&gt; int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Notice that <code>range</code> calls itself.</p>\n<p>The only difference between <code>let</code> and <code>let rec</code> is in the scoping of the\nfunction name. If the above function had been defined with just <code>let</code>,\nthen the call to <code>range</code> would have tried to look for an existing\n(previously defined) function called <code>range</code>, not the\ncurrently-being-defined function. Using <code>let</code> (without <code>rec</code>) allows you\nto re-define a value in terms of the previous definition. For example:</p>\n<pre><code class=\"language-ocaml\"># let positive_sum a b = \n    let a = max a 0\n    and b = max b 0 in\n    a + b\nval positive_sum : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>This redefinition hides the previous &quot;bindings&quot; of <code>a</code> and <code>b</code> from the\nfunction definition. In some situations coders prefer this pattern to\nusing a new variable name (<code>let a_pos = max a 0</code>) as it makes the old\nbinding inaccessible, so that only the latest values of <code>a</code> and <code>b</code> are\naccessible.</p>\n<p>There is no performance difference between functions defined using <code>let</code>\nand functions defined using <code>let rec</code>, so if you prefer you could always\nuse the <code>let rec</code> form and get the same semantics as C-like languages.</p>\n<h2 id=\"types-of-functions\">Types of functions</h2>\n<p>Because of type inference you will rarely if ever need to explicitly\nwrite down the type of your functions. However, OCaml often prints out\nwhat it thinks are the types of your functions, so you need to know the\nsyntax for this. For a function <code>f</code> which takes arguments <code>arg1</code>,\n<code>arg2</code>, ... <code>argn</code>, and returns type <code>rettype</code>, the compiler will print:</p>\n<pre><code>f : arg1 -&gt; arg2 -&gt; ... -&gt; argn -&gt; rettype\n</code></pre>\n<p>The arrow syntax looks strange now, but when we come to so-called\n&quot;currying&quot; later you'll see why it was chosen. For now I'll just give\nyou some examples.</p>\n<p>Our function <code>repeated</code> which takes a string and an integer and returns\na string has type:</p>\n<pre><code class=\"language-ocaml\"># repeated\n- : string -&gt; int -&gt; string = &lt;fun&gt;\n</code></pre>\n<p>Our function <code>average</code> which takes two floats and returns a float has\ntype:</p>\n<pre><code class=\"language-ocaml\"># average\n- : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>The OCaml standard <code>int_of_char</code> casting function:</p>\n<pre><code class=\"language-ocaml\"># int_of_char\n- : char -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>If a function returns nothing (<code>void</code> for C and Java programmers), then\nwe write that it returns the <code>unit</code> type. Here, for instance, is the\nOCaml equivalent of C's <em><a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/fputc.html\">fputc(3)</a></em>:</p>\n<pre><code class=\"language-ocaml\"># output_char\n- : out_channel -&gt; char -&gt; unit = &lt;fun&gt;\n</code></pre>\n<h3 id=\"polymorphic-functions\">Polymorphic functions</h3>\n<p>Now for something a bit stranger. What about a function which takes\n<em>anything</em> as an argument? Here's an odd function which takes an\nargument, but just ignores it and always returns 3:</p>\n<pre><code class=\"language-ocaml\">let give_me_a_three x = 3\n</code></pre>\n<p>What is the type of this function? In OCaml we use a special placeholder\nto mean &quot;any type you fancy&quot;. It's a single quote character followed by\na letter. The type of the above function would normally be written:</p>\n<pre><code class=\"language-ocaml\"># give_me_a_three\n- : 'a -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>where <code>'a</code> (pronounced alpha) really does mean any type. You can, for example, call this\nfunction as <code>give_me_a_three &quot;foo&quot;</code> or <code>give_me_a_three 2.0</code> and both\nare quite valid expressions in OCaml.</p>\n<p>It won't be clear yet why polymorphic functions are useful, but they are\nvery useful and very common, and so we'll discuss them later on. (Hint:\npolymorphism is kind of like templates in C++ or generics in Java).</p>\n<h2 id=\"type-inference\">Type inference</h2>\n<p>So the theme of this tutorial is that functional languages have many\nreally cool features, and OCaml is a language which has all of these\nreally cool features stuffed into it at once, thus making it a very\npractical language for real programmers to use. But the odd thing is\nthat most of these cool features have nothing to do with &quot;functional\nprogramming&quot; at all. In fact, I've come to the first really cool\nfeature, and I still haven't talked about why functional programming is\ncalled &quot;functional&quot;. Anyway, here's the first really cool feature: type\ninference.</p>\n<p>Simply put: you don't need to declare the types of your functions and\nvariables, because OCaml will just figure them out for you!</p>\n<p>In addition OCaml goes on to check all your types match up (even across\ndifferent files).</p>\n<p>But OCaml is also a practical language, and for this reason it contains\nbackdoors into the type system allowing you to bypass this checking on\nthe rare occasions that it is sensible to do this. Only gurus will\nprobably need to bypass the type checking.</p>\n<p>Let's go back to the <code>average</code> function which we typed into the OCaml\ninteractive toplevel:</p>\n<pre><code class=\"language-ocaml\"># let average a b =\n    (a +. b) /. 2.0\nval average : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>OCaml worked out all on its own that the function takes\ntwo <code>float</code> arguments and returns a <code>float</code>!</p>\n<p>How did it do this? Firstly it looks at where <code>a</code> and <code>b</code> are used,\nnamely in the expression <code>(a +. b)</code>. Now, <code>+.</code> is itself a function\nwhich always takes two <code>float</code> arguments, so by simple deduction, <code>a</code>\nand <code>b</code> must both also have type <code>float</code>.</p>\n<p>Secondly, the <code>/.</code> function returns a <code>float</code>, and this is the same as\nthe return value of the <code>average</code> function, so <code>average</code> must return a\n<code>float</code>. The conclusion is that <code>average</code> has this type signature:</p>\n<pre><code class=\"language-ocaml\"># average\n- : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>Type inference is obviously easy for such a short program, but it works\neven for large programs, and it's a major time-saving feature because it\nremoves a whole class of errors which cause segfaults,\n<code>NullPointerException</code>s and <code>ClassCastException</code>s in other languages (or\nimportant but often ignored runtime warnings).</p>\n","title":"A First Hour with OCaml","pageDescription":"Discover the OCaml programming language in this longer tutorial that takes you from absolute beginner to someone who is able to write programs in OCaml.\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#running-ocaml-code\">Running OCaml code</a>\n</li>\n<li><a href=\"#comments\">Comments</a>\n</li>\n<li><a href=\"#calling-functions\">Calling functions</a>\n</li>\n<li><a href=\"#defining-a-function\">Defining a function</a>\n</li>\n<li><a href=\"#basic-types\">Basic types</a>\n</li>\n<li><a href=\"#implicit-vs-explicit-casts\">Implicit vs. explicit casts</a>\n</li>\n<li><a href=\"#ordinary-functions-and-recursive-functions\">Ordinary functions and recursive functions</a>\n</li>\n<li><a href=\"#types-of-functions\">Types of functions</a>\n</li>\n<li><a href=\"#type-inference\">Type inference</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"a-first-hour-with-ocaml"}},"__N_SSG":true}