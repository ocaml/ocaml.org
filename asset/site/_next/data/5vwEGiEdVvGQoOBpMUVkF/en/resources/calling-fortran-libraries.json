{"pageProps":{"content":{"source":"<p>Fortran isn't a language the many people write new code in but it still\nis in extensive use in the scientific communities. Many, many libraries\nexist for doing numerical calculation that will never be written in C or\nC++. It is quite possible though to call Fortran routines from OCaml as\nthey are normally compiled into the same object format, with minimal\nname mangling, as C programs.</p>\n<p>This tutorial will step by step through the process of compiling an\ninterface module for a fortran function. The steps that are involved\nhere are the same steps as for wrapping a C function with a few\nconsiderations that have to be taken into account for Fortran.</p>\n<p>The Fortran function is contained in a file called func.f and has the\nfollowing signature</p>\n<p><code>subroutine gtd6(integer iyd, real sec, real alt, real lat, real lon, real dens(8), real temp(2))</code></p>\n<p>The <code>iyd</code>, <code>sec</code>, <code>alt</code>, <code>lat</code>, and <code>lon</code> parameters are input\nparameters while <code>dens</code> and <code>temp</code> are output parameters.</p>\n<p>All of the examples below use the GNU Fortran 77 compiler (g77). None of\nthese have been tested with the GNU fortran 90 compiler (gfort) and will\nnot be until it has proven itself through some time.</p>\n<h3 id=\"step-1-compile-the-fortran-routine\">Step 1: Compile the Fortran routine</h3>\n<p>Where C/C++ have only one category of subroutine (the function), Fortran\nhas two: the function and the subroutine. The function is the equivalent\nto a non-void C function in that it takes parameters and always returns\na value. The subroutine is equivalent to a void C function.</p>\n<p>When g77 compiles a fortran function it creates a named function that\nhas an underscore appended. If the fortran name for the function\ncontains any underscores then the compiled function name will have two\nunderscores appended. The generated function can be called by this name.\nSubroutines will be converted into a C function that returns an int.</p>\n<p>To compile the funcs.f file into an object file, one can use the\nfollowing:</p>\n<p><code>prompt&gt; g77 -c funcs.f</code></p>\n<p>Which will generate the file 'funcs.o'. You can then see the names of\nthe compiled functions by executing</p>\n<p><code>prompt&gt; nm funcs.o</code></p>\n<p>In this output you will see a line that has the following</p>\n<p><code>T gtd6_</code></p>\n<p>This shows that the function gtd6_ has been created and is in the\nobject file.</p>\n<p>Fortran has support for both integer and real types and those are the\nnames that they go by. In our case we have only real and integer types.\nReals are equivalent to C doubles and integers are equivalent to C\nlongs. In addition, Fortran passes everything by reference so the\ncorresponding C prototype for our gtd6 function is</p>\n<p><code> int gtd6_(integer *iyd, real* sec, real* alt, real* glat, real* glong, real* dens, real* temp);</code></p>\n<p>Note that its up to the caller to know that <code>dens</code> and <code>temp</code> are\nactually arrays. Failure to pass an array will cause a segmentation\nviolation since the gtd6_ function is using them as arrays (yet another\nreason OCaml shines).</p>\n<h3 id=\"step-2-create-the-c-wrapper\">Step 2: Create the C wrapper</h3>\n<p>Because OCaml's foreign function interface is C based, it is necessary\nto create a C wrapper. To avoid difficulties in passing back arrays of\nvalues, we are going to simply create a function that will return the\nsecond element of the temperature array as computed by the function and\nignore the other return values (this is a very frequent use of the\nfunction). This function will be in the source file wrapper.c.</p>\n<pre><code class=\"language-C\">CAMLprim value gtd6_t (value iydV, value secVal, value altVal, value latVal, value lonVal) {\n   CAMLparam5( iydV, secVal, altVal, latVal, lonVal );\n   long iyd = Long_val( iydV );\n   float    sec = Double_val( secVal );\n   float    alt = Double_val( altVal );\n   float    lat = Double_val( latVal );\n   float    lon = Double_val( lonVal );\n\n   gtd6_(&amp;iyd, &amp;sec, &amp;alt, &amp;glat, &amp;glon, d, t);\n   CAMLreturn( caml_copy_double( t[1] ) );\n}\n</code></pre>\n<p>A few points of interest</p>\n<ol>\n<li>The file must include the OCaml header files <code>alloc.h</code>, <code>memory.h</code>,\nand <code>mlvalue.h</code>.\n</li>\n<li>The function first calls the CAMLparam5 macro. This is required at\nthe start of any function that uses the CAML types.\n</li>\n<li>The function uses the Double_val and Long_val macros to extract\nthe C types from the OCaml value object.\n</li>\n<li>All of the values are passed by reference to the gtd6_ routine as\nrequired by the prototype.\n</li>\n<li>The function uses the copy_caml_double function and the CAMLreturn\nmacro to create a new value containing the return value and to\nreturn it respectively.\n</li>\n</ol>\n<h3 id=\"step-3-compile-the-shared-library\">Step 3: Compile the shared library.</h3>\n<p>Now having the two source files funcs.f and wrapper.c we need to create\na shared library that can be loaded by OCaml. Its easier to do this as a\nmultistep process, so here are the commands:</p>\n<p><code>prompt&gt; g77 -c funcs.f</code></p>\n<p><code>prompt&gt; cc -I&lt;ocaml include path&gt; -c wrapper.c </code></p>\n<p><code>prompt&gt; cc -shared -o wrapper.so wrapper.o funcs.o -lg2c</code></p>\n<p>This will create a shared object library called wrapper.so containing\nthe fortran function and the wrapper function. The -lg2c option is\nrequired to provide the implementations of the built in fortran\nfunctions that are used.</p>\n<h3 id=\"step-4-now-to-ocaml\">Step 4: Now to OCaml</h3>\n<p>Now in an OCaml file (gtd6.ml) we have to define the external reference\nto the function and a function to call it.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">external temp : int -&gt; float -&gt; float -&gt; float -&gt; float -&gt; float = &quot;gtd6_t&quot;\n\nlet () =\n  print_double (temp 1 2.0 3.0 4.0 5.0);\n  print_newline ()\n</code></pre>\n<p>This tells OCaml that the temp function takes 5 parameters and returns a\nsingle floating point and calls the C function gtd6_t.</p>\n<p>At this point, the steps that are given are to compile this into\nbytecode. I don't yet have much experience compiling to native so I'll\nlet some else help out (or wait until I learn how to do it).</p>\n<pre><code>prompt&gt; ocamlc -c gtd6.ml prompt&gt; ocamlc -o test gtd6.cmo wrapper.so\n</code></pre>\n<p>And voila, we've called the fortran function from OCaml.</p>\n","title":"Calling Fortran Libraries","pageDescription":"Cross the divide and call Fortran code from your OCaml program\n","tableOfContents":""},"params":{"lang":"en","tutorial":"calling-fortran-libraries"}},"__N_SSG":true}