{"pageProps":{"content":{"title":"Language","pageDescription":"This is the home of learning and tutorials. Whether you're a beginner, a teacher, or a seasoned researcher, this is where you can find the resources you need to accomplish your goals in OCaml.","tutorials":{"title":"OCaml Tutorials","description":"There are plenty of tutorials available for you to get started with OCaml, written by dedicated members of the community. Take a look and see what you can discover.","tutorials":[{"title":"Up and Running with OCaml","slug":"up-and-running-with-ocaml","description":"Help you install OCaml, the Dune build system, and support for your favourite text editor or IDE.\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"getting-started","tl":0},"users":{"hd":"Beginner","tl":0},"body_md":"\nThis page will help you install OCaml, the Dune build system, and support for\nyour favourite text editor or IDE. These instructions work on Windows, Unix\nsystems like Linux, and macOS.\n\n## Installing OCaml\n\nThere are two procedures: one for Unix-like systems, and one for Windows.\n\n### For Linux and macOS\n\nWe will install OCaml using opam, the OCaml package manager.  We will also use\nopam when we wish to install third-party OCaml libraries.\n\n**For macOS**\n\n```\n# Homebrew\nbrew install opam\n\n# MacPort\nport install opam\n```\n\n**For Linux** the preferred way is to use your system's package manager on\nLinux (e.g `apt-get install opam` or similar). [Details of all installation\nmethods.](https://opam.ocaml.org/doc/Install.html)\n\nThen, we install an OCaml compiler:\n\n```\n# environment setup\nopam init\neval `opam env`\n\n# install given version of the compiler\nopam switch create 4.11.1\neval `opam env`\n```\n\nNow, OCaml is up and running:\n\n```\n$ which ocaml\n/Users/frank/.opam/4.11.1/bin/ocaml\n\n$ ocaml -version\nThe OCaml toplevel, version 4.11.1\n```\n\n**For either Linux or macOS** as an alternative, a binary distribution of opam is\navailable:\n\n```\nsh <(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)\n```\n\n### For Windows\n\nWe use the [OCaml for Windows](https://fdopen.github.io/opam-repository-mingw/)\ninstaller which comes in 32bit and 64bit versions. This installer gives you\nopam and OCaml installations all in one go. It is used from within a Cygwin\nenvironment, but the executables produced have no dependency on Cygwin at all.\n\n## The OCaml top level\n\nOCaml comes with two compilers: for native code, and for byte code. We shall\nuse one of those in a moment. But first, let's use OCaml's top level (sometimes\nknown as a REPL in other languages):\n\n```\n$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n\n```\n\nWe typed the phrase `1 + 2 * 3` and then signalled to OCaml that we had\nfinished by typing `;;` followed by the Enter key. OCaml calculated the\nresult, `7` and its type `int` and showed them to us. We exit by running the\nbuilt-in `exit` function with exit code 0:\n\n```\n$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n# exit 0;;\n$\n```\n\nThere are two ways to improve your experience with the OCaml top level: you can\ninstall the popular [`rlwrap`](https://github.com/hanslub42/rlwrap) on your\nsystem and invoke `rlwrap ocaml` instead of `ocaml` to get line-editing\nfacilities inside the OCaml top level, or you can install the alternative top\nlevel `utop` using opam:\n\n```\n$ opam install utop\n```\n\nWe run it by typing `utop` instead of `ocaml`. You can read more about\n[utop](https://github.com/ocaml-community/utop).\n\n## Installing the Dune build system\n\nDune is a build system for OCaml. It takes care of all the low level details of\nOCaml compilation. We install it with opam:\n\n```\n$ opam install dune\nThe following actions will be performed:\n  - install dune 2.7.1\n\n<><> Gathering sources ><><><><><><><><><><><><><><><><><><><><><><><><>\n[default] https://opam.ocaml.org/2.0.7/archives/dune.2.7.1+opam.tar.gz\ndownloaded\n\n<><> Processing actions <><><><><><><><><><><><><><><><><><><><><><><><>\n-> installed dune.2.7.1\nDone.\n```\n\n## A first project\n\nLet's begin the simplest project with Dune and OCaml. We create a new directory\nand ask `dune` to initialise a new project:\n\n```\n$ mkdir helloworld\n$ cd helloworld/\n$ dune init exe helloworld\nSuccess: initialized executable component named helloworld\n```\n\nBuilding our program is as simple as typing `dune build`:\n\n```\n$ dune build\nInfo: Creating file dune-project with this contents:\n| (lang dune 2.7)\nDone: 8/11 (jobs: 1)\n```\n\nWhen we change our program, we type `dune build` again to make a new\nexecutable. We can run the executable with `dune exec` (it's called\n`helloworld.exe` even when we're not using Windows):\n\n```\n$ dune exec ./helloworld.exe\nHello, World!        \n```\n\nLet's look at the contents of our new directory. Dune has added the\n`helloworld.ml` file, which is our OCaml program. It has also added our `dune`\nfile, which tells dune how to build the program, and a `_build` subdirectory,\nwhich is dune's working space.\n\n```\n$ ls\n_build\t\tdune\t\thelloworld.ml\n```\n\nThe `helloworld.exe` executable is stored inside the `_build/default` subdirectory, so\nit's easier to run with `dune exec`. To ship the executable, we can just copy\nit from inside `_build/default` to somewhere else.\n\nHere is the contents of the automatically-generated `dune` file. When we want\nto add components to your project, such as third-party libraries, we edit this\nfile.\n\n```\n(executable\n (name helloworld))\n```\n\n## Editor support for OCaml\n\nFor **Visual Studio Code**, and other editors support the Language Server\nProtocol, the OCaml language server can be installed with opam:\n\n```\n$ opam install ocaml-lsp-server\n```\n\nNow, we install the OCaml Platform Visual Studio Code extension from the Visual\nStudio Marketplace.\n\nUpon first loading an OCaml source file, you may be prompted to select the\ntoolchain in use: pick OCaml the version of OCaml you are using, e.g. 4.11.1\nfrom the list. Now, help is available by hovering over symbols in your program:\n\n![Visual Studio Code](/tutorials/vscode.png \"\")\n\n**On Windows**, we must launch Visual Studio Code from within the Cygwin window,\nrather than by clicking on its icon (otherwise, the language server will not be\nfound):\n\n```\n$ /cygdrive/c/Users/Frank\\ Smith/AppData/Local/Programs/Microsoft\\ VS\\ Code/Code.exe\n```\n\n**For Vim and Emacs**, install the [Merlin](https://github.com/ocaml/merlin)\nsystem using opam:\n\n```\n$ opam install merlin\n```\n\nThe installation procedure will print instructions on how to link Merlin with\nyour editor.\n\n**On Windows**, when using Vim, the default cygwin Vim will not work with\nMerlin. You will need install Vim separately. In addition to the usual\ninstructions printed when installing Merlin, you may need to set the PATH in\nVim:\n\n```\nlet $PATH .= \";\".substitute(system('opam config var bin'),'\\n$','','''')\n```\n","toc_html":"<ul>\n<li><ul>\n<li><a href=\"#installing-ocaml\">Installing OCaml</a>\n</li>\n<li><a href=\"#the-ocaml-top-level\">The OCaml top level</a>\n</li>\n<li><a href=\"#installing-the-dune-build-system\">Installing the Dune build system</a>\n</li>\n<li><a href=\"#a-first-project\">A first project</a>\n</li>\n<li><a href=\"#editor-support-for-ocaml\">Editor support for OCaml</a>\n</li>\n</ul>\n</li>\n</ul>\n","body_html":"<p>This page will help you install OCaml, the Dune build system, and support for\nyour favourite text editor or IDE. These instructions work on Windows, Unix\nsystems like Linux, and macOS.</p>\n<h2 id=\"installing-ocaml\">Installing OCaml</h2>\n<p>There are two procedures: one for Unix-like systems, and one for Windows.</p>\n<h3 id=\"for-linux-and-macos\">For Linux and macOS</h3>\n<p>We will install OCaml using opam, the OCaml package manager.  We will also use\nopam when we wish to install third-party OCaml libraries.</p>\n<p><strong>For macOS</strong></p>\n<pre><code># Homebrew\nbrew install opam\n\n# MacPort\nport install opam\n</code></pre>\n<p><strong>For Linux</strong> the preferred way is to use your system's package manager on\nLinux (e.g <code>apt-get install opam</code> or similar). <a href=\"https://opam.ocaml.org/doc/Install.html\">Details of all installation\nmethods.</a></p>\n<p>Then, we install an OCaml compiler:</p>\n<pre><code># environment setup\nopam init\neval `opam env`\n\n# install given version of the compiler\nopam switch create 4.11.1\neval `opam env`\n</code></pre>\n<p>Now, OCaml is up and running:</p>\n<pre><code>$ which ocaml\n/Users/frank/.opam/4.11.1/bin/ocaml\n\n$ ocaml -version\nThe OCaml toplevel, version 4.11.1\n</code></pre>\n<p><strong>For either Linux or macOS</strong> as an alternative, a binary distribution of opam is\navailable:</p>\n<pre><code>sh &lt;(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)\n</code></pre>\n<h3 id=\"for-windows\">For Windows</h3>\n<p>We use the <a href=\"https://fdopen.github.io/opam-repository-mingw/\">OCaml for Windows</a>\ninstaller which comes in 32bit and 64bit versions. This installer gives you\nopam and OCaml installations all in one go. It is used from within a Cygwin\nenvironment, but the executables produced have no dependency on Cygwin at all.</p>\n<h2 id=\"the-ocaml-top-level\">The OCaml top level</h2>\n<p>OCaml comes with two compilers: for native code, and for byte code. We shall\nuse one of those in a moment. But first, let's use OCaml's top level (sometimes\nknown as a REPL in other languages):</p>\n<pre><code>$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n\n</code></pre>\n<p>We typed the phrase <code>1 + 2 * 3</code> and then signalled to OCaml that we had\nfinished by typing <code>;;</code> followed by the Enter key. OCaml calculated the\nresult, <code>7</code> and its type <code>int</code> and showed them to us. We exit by running the\nbuilt-in <code>exit</code> function with exit code 0:</p>\n<pre><code>$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n# exit 0;;\n$\n</code></pre>\n<p>There are two ways to improve your experience with the OCaml top level: you can\ninstall the popular <a href=\"https://github.com/hanslub42/rlwrap\"><code>rlwrap</code></a> on your\nsystem and invoke <code>rlwrap ocaml</code> instead of <code>ocaml</code> to get line-editing\nfacilities inside the OCaml top level, or you can install the alternative top\nlevel <code>utop</code> using opam:</p>\n<pre><code>$ opam install utop\n</code></pre>\n<p>We run it by typing <code>utop</code> instead of <code>ocaml</code>. You can read more about\n<a href=\"https://github.com/ocaml-community/utop\">utop</a>.</p>\n<h2 id=\"installing-the-dune-build-system\">Installing the Dune build system</h2>\n<p>Dune is a build system for OCaml. It takes care of all the low level details of\nOCaml compilation. We install it with opam:</p>\n<pre><code>$ opam install dune\nThe following actions will be performed:\n  - install dune 2.7.1\n\n&lt;&gt;&lt;&gt; Gathering sources &gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;\n[default] https://opam.ocaml.org/2.0.7/archives/dune.2.7.1+opam.tar.gz\ndownloaded\n\n&lt;&gt;&lt;&gt; Processing actions &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;\n-&gt; installed dune.2.7.1\nDone.\n</code></pre>\n<h2 id=\"a-first-project\">A first project</h2>\n<p>Let's begin the simplest project with Dune and OCaml. We create a new directory\nand ask <code>dune</code> to initialise a new project:</p>\n<pre><code>$ mkdir helloworld\n$ cd helloworld/\n$ dune init exe helloworld\nSuccess: initialized executable component named helloworld\n</code></pre>\n<p>Building our program is as simple as typing <code>dune build</code>:</p>\n<pre><code>$ dune build\nInfo: Creating file dune-project with this contents:\n| (lang dune 2.7)\nDone: 8/11 (jobs: 1)\n</code></pre>\n<p>When we change our program, we type <code>dune build</code> again to make a new\nexecutable. We can run the executable with <code>dune exec</code> (it's called\n<code>helloworld.exe</code> even when we're not using Windows):</p>\n<pre><code>$ dune exec ./helloworld.exe\nHello, World!        \n</code></pre>\n<p>Let's look at the contents of our new directory. Dune has added the\n<code>helloworld.ml</code> file, which is our OCaml program. It has also added our <code>dune</code>\nfile, which tells dune how to build the program, and a <code>_build</code> subdirectory,\nwhich is dune's working space.</p>\n<pre><code>$ ls\n_build\t\tdune\t\thelloworld.ml\n</code></pre>\n<p>The <code>helloworld.exe</code> executable is stored inside the <code>_build/default</code> subdirectory, so\nit's easier to run with <code>dune exec</code>. To ship the executable, we can just copy\nit from inside <code>_build/default</code> to somewhere else.</p>\n<p>Here is the contents of the automatically-generated <code>dune</code> file. When we want\nto add components to your project, such as third-party libraries, we edit this\nfile.</p>\n<pre><code>(executable\n (name helloworld))\n</code></pre>\n<h2 id=\"editor-support-for-ocaml\">Editor support for OCaml</h2>\n<p>For <strong>Visual Studio Code</strong>, and other editors support the Language Server\nProtocol, the OCaml language server can be installed with opam:</p>\n<pre><code>$ opam install ocaml-lsp-server\n</code></pre>\n<p>Now, we install the OCaml Platform Visual Studio Code extension from the Visual\nStudio Marketplace.</p>\n<p>Upon first loading an OCaml source file, you may be prompted to select the\ntoolchain in use: pick OCaml the version of OCaml you are using, e.g. 4.11.1\nfrom the list. Now, help is available by hovering over symbols in your program:</p>\n<p><img src=\"/tutorials/vscode.png\" alt=\"Visual Studio Code\" title=\"\" /></p>\n<p><strong>On Windows</strong>, we must launch Visual Studio Code from within the Cygwin window,\nrather than by clicking on its icon (otherwise, the language server will not be\nfound):</p>\n<pre><code>$ /cygdrive/c/Users/Frank\\ Smith/AppData/Local/Programs/Microsoft\\ VS\\ Code/Code.exe\n</code></pre>\n<p><strong>For Vim and Emacs</strong>, install the <a href=\"https://github.com/ocaml/merlin\">Merlin</a>\nsystem using opam:</p>\n<pre><code>$ opam install merlin\n</code></pre>\n<p>The installation procedure will print instructions on how to link Merlin with\nyour editor.</p>\n<p><strong>On Windows</strong>, when using Vim, the default cygwin Vim will not work with\nMerlin. You will need install Vim separately. In addition to the usual\ninstructions printed when installing Merlin, you may need to set the PATH in\nVim:</p>\n<pre><code>let $PATH .= &quot;;&quot;.substitute(system('opam config var bin'),'\\n$','','''')\n</code></pre>\n"},{"title":"A First Hour with OCaml","slug":"a-first-hour-with-ocaml","description":"Discover the OCaml programming language in this longer tutorial that takes you from absolute beginner to someone who is able to write programs in OCaml.\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"getting-started","tl":0},"users":{"hd":"Beginner","tl":0},"body_md":"\nYou may follow along with this tutorial with just a basic OCaml installation,\nas described in [Up and Running](up_and_running.html).\n\nAlternatively, you may follow almost all of it by running OCaml in your browser\nusing [TryOCaml](https://try.ocamlpro.com), with no installation required!!!\n\n## Running OCaml code\n\nThe easiest way to get started is to run an interactive session in\nyour browser thanks to [TryOCaml](https://try.ocamlpro.com).\n\nTo install OCaml on your computer, see the [Install](/docs/install.html) documentation.\n\nTo quickly try small OCaml expressions, you can use an interactive\ntoplevel, or REPL (Read–Eval–Print Loop). The `ocaml` command provides\na very basic toplevel (you should install `rlwrap` through your system\npackage manager and run `rlwrap ocaml` to get history navigation).\n\nThe recommended alternative REPL [utop](https://github.com/diml/utop) may be\ninstalled through [OPAM](/docs/install.html#OPAM) or your system package\nmanager. It has the same basic interface but is much more convenient to use\n(history navigation, auto-completion, etc.).\n\nUse `;;` to indicate that you've finished entering each expression and prompt OCaml to evaluate it. Here is what running `ocaml` looks like:\n\n```console\n$ ocaml\n        OCaml version OCaml version 4.12.0\n\n# 1 + 1;;\n- : int = 2\n```\n\nThis is how running the same code looks when using `utop`:\n\n```console\n───────┬─────────────────────────────────────────────────────────────┬────\n       │ Welcome to utop version 2.7.0 (using OCaml version 4.12.0)! │     \n       └─────────────────────────────────────────────────────────────┘     \n\nType #utop_help for help about using utop.\n\n─( 10:12:16 )─< command 0 >───────────────────────────────────────────────\nutop # 1 + 1;;\n- : int = 2\n```\n\n## Comments\n\nOCaml comments are delimited by `(*` and `*)`, like this:\n\n```ocaml\n(* This is a single-line comment. *)\n\n(* This is a\n   multi-line\n   comment.\n*)\n```\n\nIn other words, the commenting convention is very similar to original C\n(`/* ... */`). There is no single-line comment syntax (like\n`# ...` in Python or `// ...` in C99/C++/Java).\n\nOCaml counts nested `(* ... *)` blocks, and this allows you to comment\nout regions of code very easily:\n\n```ocaml\n(* This code is broken ...\n\n(* Primality test. *)\nlet is_prime n =\n  (* note to self: ask about this on the mailing lists *) XXX\n\n*)\n```\n\n## Calling functions\n\nLet's say you've written a function — we'll call it `repeated` — which\ntakes a string `s` and a number `n`, and returns a new string which\ncontains original `s` repeated `n` times.\n\nIn most C-derived languages a call to this function will look like this:\n\n```C\nrepeated (\"hello\", 3)  /* this is C code */\n```\n\nThis means \"call the function `repeated` with two arguments, first\nargument the string hello and second argument the number 3\".\n\nOCaml, in common with other functional languages, writes and brackets\nfunction calls differently, and this is the cause of many mistakes. Here\nis the same function call in OCaml:\n\n```ocaml\nlet repeated a b = a ^ (Int.to_string b);;\nrepeated \"hello\" 3  (* this is OCaml code *)\n```\n\nNote — **no** brackets, and **no** comma between the arguments.\n\nThe syntax `repeated (\"hello\", 3)` **is** meaningful in OCaml. It means\n\"call the function `repeated` with ONE argument, that argument being a\n'pair' structure of two elements\". Of course that would be a mistake,\nbecause the `repeated` function is expecting two arguments, not one, and\nthe first argument should be a string, not a pair. But let's not worry\nabout pairs (\"tuples\") just yet. Instead, just remember that it's a\nmistake to put the brackets and commas in around function call\narguments.\n\nLet's have another function — `prompt_string` — which takes a string to\nprompt and returns the string entered by the user. We want to pass this\nstring into `repeated`. Here are the C and OCaml versions:\n\n```C\n/* C code: */\nrepeated (prompt_string (\"Name please: \"), 3)\n```\n\n```ocaml\nlet prompt_string p = \"\";;\n(* OCaml code: *)\nrepeated (prompt_string \"Name please: \") 3\n```\n\nTake a careful look at the bracketing and the missing comma. In the\nOCaml version, the brackets enclose the first argument of repeated\nbecause that argument is the result of another function call. In general\nthe rule is: \"bracket around the whole function call — don't put\nbrackets around the arguments to a function call\". Here are some more\nexamples:\n\n```ocaml\nlet f a b c = \"\";;\nlet g a = \"\";;\nlet f2 a = \"\";;\nlet g2 a b = \"\";;\nf 5 (g \"hello\") 3;;    (* f has three arguments, g has one argument *)\nf2 (g2 3 4)            (* f2 has one argument, g2 has two arguments *)\n```\n\n```ocaml\n# repeated (\"hello\", 3)     (* OCaml will spot the mistake *)\nLine 1, characters 10-22:\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n```\n\n## Defining a function\n\nWe all know how to define a function (or static method, in Java)\nin our existing languages. How do we do it in OCaml?\n\nThe OCaml syntax is pleasantly concise. Here's a function which takes\ntwo floating point numbers and calculates the average:\n\n```ocaml\nlet average a b =\n  (a +. b) /. 2.0\n```\n\nType this into the OCaml interactive toplevel (on Unix, type the command `ocaml`\nfrom the shell) and you'll see this:\n\n```ocaml\n# let average a b =\n    (a +. b) /. 2.0;;\nval average : float -> float -> float = <fun>\n```\n\nIf you look at the function definition closely, and also at what OCaml\nprints back at you, you'll have a number of questions:\n\n* What are those periods in `+.` and `/.` for?\n* What does `float -> float -> float` mean?\n\nI'll answer those questions in the next sections, but first I want to go\nand define the same function in C (the Java definition would be fairly\nsimilar to C), and hopefully that should raise even more questions.\nHere's our C version of `average`:\n\n```C\ndouble average (double a, double b)\n{\n  return (a + b) / 2;\n}\n```\n\nNow look at our much shorter OCaml definition above. Hopefully you'll be\nasking:\n\n* Why don't we have to define the types of `a` and `b` in the OCaml\n  version? How does OCaml know what the types are (indeed, *does*\n  OCaml know what the types are, or is OCaml completely dynamically\n  typed?).\n* In C, the `2` is implicitly converted into a `double`, can't OCaml\n  do the same thing?\n* What is the OCaml way to write `return`?\n\nOK, let's get some answers.\n\n* OCaml is a strongly *statically typed* language (in other words,\n  there's nothing dynamic going on between int, float and string).\n* OCaml uses *type inference* to work out the types, so you don't have\n  to.  If you use the OCaml interactive toplevel as above, then OCaml\n  will tell you\n  its inferred type for your function.\n* OCaml doesn't do any implicit casting. If you want a float, you have\n  to write `2.0` because `2` is an integer. OCaml does **no automatic\n  conversion** between int, float, string or any other type.\n* As a side-effect of type inference in OCaml, functions (including\n  operators) can't have overloaded definitions. OCaml defines `+` as\n  the *integer* addition function. To add floats, use `+.` (note the\n  trailing period). Similarly, use `-.`, `*.`, `/.` for other float\n  operations.\n* OCaml doesn't have a `return` keyword — the last expression in a\n  function becomes the result of the function automatically.\n\nWe will present more details in the following sections and chapters.\n\n## Basic types\n\nThe basic types in OCaml are:\n\n```text\nOCaml type  Range\n\nint         31-bit signed int (roughly +/- 1 billion) on 32-bit\n            processors, or 63-bit signed int on 64-bit processors\nfloat       IEEE double-precision floating point, equivalent to C's double\nbool        A boolean, written either 'true' or 'false'\nchar        An 8-bit character\nstring      A string\nunit        Written as ()\n```\n\nOCaml uses one of the bits in an `int` internally in order to be able to\nautomatically manage the memory use (garbage collection). This is why\nthe basic `int` is 31 bits, not 32 bits (63 bits if you're using a 64\nbit platform). In practice this isn't an issue except in a few\nspecialised cases. For example if you're counting things in a loop, then\nOCaml limits you to counting up to 1 billion instead of 2 billion. However if you need to do things\nsuch as processing 32 bit types (eg. you're writing crypto code or a\nnetwork stack), OCaml provides a `nativeint` type which matches the\nnative integer type for your platform.\n\nOCaml doesn't have a basic unsigned integer type, but you can get the\nsame effect using `nativeint`. OCaml doesn't have built-in single-precision \nfloating point numbers.\n\nOCaml provides a `char` type which is used for characters, written `'x'`\nfor example. Unfortunately the `char` type does not support Unicode or\nUTF-8, There are [comprehensive Unicode libraries](https://github.com/yoriyuki/Camomile)\nwhich provide this functionality.\n\nStrings are not just lists of characters. They have their own, more\nefficient internal representation. Strings are immutable.\n\nThe `unit` type is sort of like `void` in C, but we'll talk about it\nmore below.\n\n## Implicit vs. explicit casts\n\nIn C-derived languages ints get promoted to floats in certain\ncircumstances. For example if you write `1 + 2.5` then the first\nargument (which is an integer) is promoted to a floating point number,\nand the result is also a floating point number. It's as if you had\nwritten `((double) 1) + 2.5`, but all done implicitly.\n\nOCaml never does implicit casts like this. In OCaml, `1 + 2.5` is a type\nerror. The `+` operator in OCaml requires two ints as arguments, and\nhere we're giving it an int and a float, so it reports this error:\n\n```ocaml\n# 1 + 2.5;;\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n```\n\nTo add two floats together you need to use a different operator, `+.`\n(note the trailing period).\n\nOCaml doesn't promote ints to floats automatically so this is also an\nerror:\n\n```ocaml\n# 1 +. 2.5\nLine 1, characters 1-2:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.'?\n```\n\nHere OCaml is now complaining about the first argument.\n\nWhat if you actually want to add an integer and a floating point number\ntogether? (Say they are stored as `i` and `f`). In OCaml you need to\nexplicitly cast:\n\n```ocaml\nlet i = 1;;\nlet f = 2.0;;\nfloat_of_int i +. f\n```\n\n`float_of_int` is a function which takes an `int` and returns a `float`.\nThere are a whole load of these functions, called such things as\n`int_of_float`, `char_of_int`, `int_of_char`, `string_of_int` and so on,\nand they mostly do what you expect.\n\nSince converting an `int` to a `float` is a particularly common\noperation, the `float_of_int` function has a shorter alias: the above\nexample could simply have been written\n\n```ocaml\nfloat i +. f\n```\n\n(Note that it is perfectly valid in OCaml for a type and a\nfunction to have the same name.)\n\n### Is implicit or explicit casting better?\n\nYou might think that these explicit casts are ugly, time-consuming even,\nand you have a point, but there are at least two arguments in their\nfavour. Firstly, OCaml needs this explicit casting to be able to do type\ninference (see below), and type inference is such a wonderful\ntime-saving feature that it easily offsets the extra keyboarding of\nexplicit casts. Secondly, if you've spent time debugging C programs\nyou'll know that (a) implicit casts cause errors which are hard to find,\nand (b) much of the time you're sitting there trying to work out where\nthe implicit casts happen. Making the casts explicit helps you in\ndebugging. Thirdly, some casts (particularly int <-> float) are\nactually very expensive operations. You do yourself no favours by hiding\nthem.\n\n## Ordinary functions and recursive functions\n\nUnlike in C-derived languages, a function isn't recursive unless you\nexplicitly say so by using `let rec` instead of just `let`. Here's an\nexample of a recursive function:\n\n```ocaml\n# let rec range a b =\n    if a > b then []\n    else a :: range (a + 1) b\nval range : int -> int -> int list = <fun>\n```\n\nNotice that `range` calls itself.\n\nThe only difference between `let` and `let rec` is in the scoping of the\nfunction name. If the above function had been defined with just `let`,\nthen the call to `range` would have tried to look for an existing\n(previously defined) function called `range`, not the\ncurrently-being-defined function. Using `let` (without `rec`) allows you\nto re-define a value in terms of the previous definition. For example:\n\n```ocaml\n# let positive_sum a b = \n    let a = max a 0\n    and b = max b 0 in\n    a + b\nval positive_sum : int -> int -> int = <fun>\n```\n\nThis redefinition hides the previous \"bindings\" of `a` and `b` from the\nfunction definition. In some situations coders prefer this pattern to\nusing a new variable name (`let a_pos = max a 0`) as it makes the old\nbinding inaccessible, so that only the latest values of `a` and `b` are\naccessible.\n\nThere is no performance difference between functions defined using `let`\nand functions defined using `let rec`, so if you prefer you could always\nuse the `let rec` form and get the same semantics as C-like languages.\n\n## Types of functions\n\nBecause of type inference you will rarely if ever need to explicitly\nwrite down the type of your functions. However, OCaml often prints out\nwhat it thinks are the types of your functions, so you need to know the\nsyntax for this. For a function `f` which takes arguments `arg1`,\n`arg2`, ... `argn`, and returns type `rettype`, the compiler will print:\n\n```\nf : arg1 -> arg2 -> ... -> argn -> rettype\n```\n\nThe arrow syntax looks strange now, but when we come to so-called\n\"currying\" later you'll see why it was chosen. For now I'll just give\nyou some examples.\n\nOur function `repeated` which takes a string and an integer and returns\na string has type:\n\n```ocaml\n# repeated\n- : string -> int -> string = <fun>\n```\n\nOur function `average` which takes two floats and returns a float has\ntype:\n\n```ocaml\n# average\n- : float -> float -> float = <fun>\n```\n\nThe OCaml standard `int_of_char` casting function:\n\n```ocaml\n# int_of_char\n- : char -> int = <fun>\n```\n\nIf a function returns nothing (`void` for C and Java programmers), then\nwe write that it returns the `unit` type. Here, for instance, is the\nOCaml equivalent of C's *[fputc(3)](https://pubs.opengroup.org/onlinepubs/009695399/functions/fputc.html)*:\n\n```ocaml\n# output_char\n- : out_channel -> char -> unit = <fun>\n```\n\n### Polymorphic functions\n\nNow for something a bit stranger. What about a function which takes\n*anything* as an argument? Here's an odd function which takes an\nargument, but just ignores it and always returns 3:\n\n```ocaml\nlet give_me_a_three x = 3\n```\n\nWhat is the type of this function? In OCaml we use a special placeholder\nto mean \"any type you fancy\". It's a single quote character followed by\na letter. The type of the above function would normally be written:\n\n```ocaml\n# give_me_a_three\n- : 'a -> int = <fun>\n```\n\nwhere `'a` (pronounced alpha) really does mean any type. You can, for example, call this\nfunction as `give_me_a_three \"foo\"` or `give_me_a_three 2.0` and both\nare quite valid expressions in OCaml.\n\nIt won't be clear yet why polymorphic functions are useful, but they are\nvery useful and very common, and so we'll discuss them later on. (Hint:\npolymorphism is kind of like templates in C++ or generics in Java).\n\n## Type inference\n\nSo the theme of this tutorial is that functional languages have many\nreally cool features, and OCaml is a language which has all of these\nreally cool features stuffed into it at once, thus making it a very\npractical language for real programmers to use. But the odd thing is\nthat most of these cool features have nothing to do with \"functional\nprogramming\" at all. In fact, I've come to the first really cool\nfeature, and I still haven't talked about why functional programming is\ncalled \"functional\". Anyway, here's the first really cool feature: type\ninference.\n\nSimply put: you don't need to declare the types of your functions and\nvariables, because OCaml will just figure them out for you!\n\nIn addition OCaml goes on to check all your types match up (even across\ndifferent files).\n\nBut OCaml is also a practical language, and for this reason it contains\nbackdoors into the type system allowing you to bypass this checking on\nthe rare occasions that it is sensible to do this. Only gurus will\nprobably need to bypass the type checking.\n\nLet's go back to the `average` function which we typed into the OCaml\ninteractive toplevel:\n\n```ocaml\n# let average a b =\n    (a +. b) /. 2.0\nval average : float -> float -> float = <fun>\n```\n\nOCaml worked out all on its own that the function takes\ntwo `float` arguments and returns a `float`!\n\nHow did it do this? Firstly it looks at where `a` and `b` are used,\nnamely in the expression `(a +. b)`. Now, `+.` is itself a function\nwhich always takes two `float` arguments, so by simple deduction, `a`\nand `b` must both also have type `float`.\n\nSecondly, the `/.` function returns a `float`, and this is the same as\nthe return value of the `average` function, so `average` must return a\n`float`. The conclusion is that `average` has this type signature:\n\n```ocaml\n# average\n- : float -> float -> float = <fun>\n```\n\nType inference is obviously easy for such a short program, but it works\neven for large programs, and it's a major time-saving feature because it\nremoves a whole class of errors which cause segfaults,\n`NullPointerException`s and `ClassCastException`s in other languages (or\nimportant but often ignored runtime warnings).\n","toc_html":"<ul>\n<li><ul>\n<li><a href=\"#running-ocaml-code\">Running OCaml code</a>\n</li>\n<li><a href=\"#comments\">Comments</a>\n</li>\n<li><a href=\"#calling-functions\">Calling functions</a>\n</li>\n<li><a href=\"#defining-a-function\">Defining a function</a>\n</li>\n<li><a href=\"#basic-types\">Basic types</a>\n</li>\n<li><a href=\"#implicit-vs-explicit-casts\">Implicit vs. explicit casts</a>\n</li>\n<li><a href=\"#ordinary-functions-and-recursive-functions\">Ordinary functions and recursive functions</a>\n</li>\n<li><a href=\"#types-of-functions\">Types of functions</a>\n</li>\n<li><a href=\"#type-inference\">Type inference</a>\n</li>\n</ul>\n</li>\n</ul>\n","body_html":"<p>You may follow along with this tutorial with just a basic OCaml installation,\nas described in <a href=\"up_and_running.html\">Up and Running</a>.</p>\n<p>Alternatively, you may follow almost all of it by running OCaml in your browser\nusing <a href=\"https://try.ocamlpro.com\">TryOCaml</a>, with no installation required!!!</p>\n<h2 id=\"running-ocaml-code\">Running OCaml code</h2>\n<p>The easiest way to get started is to run an interactive session in\nyour browser thanks to <a href=\"https://try.ocamlpro.com\">TryOCaml</a>.</p>\n<p>To install OCaml on your computer, see the <a href=\"/docs/install.html\">Install</a> documentation.</p>\n<p>To quickly try small OCaml expressions, you can use an interactive\ntoplevel, or REPL (Read–Eval–Print Loop). The <code>ocaml</code> command provides\na very basic toplevel (you should install <code>rlwrap</code> through your system\npackage manager and run <code>rlwrap ocaml</code> to get history navigation).</p>\n<p>The recommended alternative REPL <a href=\"https://github.com/diml/utop\">utop</a> may be\ninstalled through <a href=\"/docs/install.html#OPAM\">OPAM</a> or your system package\nmanager. It has the same basic interface but is much more convenient to use\n(history navigation, auto-completion, etc.).</p>\n<p>Use <code>;;</code> to indicate that you've finished entering each expression and prompt OCaml to evaluate it. Here is what running <code>ocaml</code> looks like:</p>\n<pre><code class=\"language-console\">$ ocaml\n        OCaml version OCaml version 4.12.0\n\n# 1 + 1;;\n- : int = 2\n</code></pre>\n<p>This is how running the same code looks when using <code>utop</code>:</p>\n<pre><code class=\"language-console\">───────┬─────────────────────────────────────────────────────────────┬────\n       │ Welcome to utop version 2.7.0 (using OCaml version 4.12.0)! │     \n       └─────────────────────────────────────────────────────────────┘     \n\nType #utop_help for help about using utop.\n\n─( 10:12:16 )─&lt; command 0 &gt;───────────────────────────────────────────────\nutop # 1 + 1;;\n- : int = 2\n</code></pre>\n<h2 id=\"comments\">Comments</h2>\n<p>OCaml comments are delimited by <code>(*</code> and <code>*)</code>, like this:</p>\n<pre><code class=\"language-ocaml\">(* This is a single-line comment. *)\n\n(* This is a\n   multi-line\n   comment.\n*)\n</code></pre>\n<p>In other words, the commenting convention is very similar to original C\n(<code>/* ... */</code>). There is no single-line comment syntax (like\n<code># ...</code> in Python or <code>// ...</code> in C99/C++/Java).</p>\n<p>OCaml counts nested <code>(* ... *)</code> blocks, and this allows you to comment\nout regions of code very easily:</p>\n<pre><code class=\"language-ocaml\">(* This code is broken ...\n\n(* Primality test. *)\nlet is_prime n =\n  (* note to self: ask about this on the mailing lists *) XXX\n\n*)\n</code></pre>\n<h2 id=\"calling-functions\">Calling functions</h2>\n<p>Let's say you've written a function — we'll call it <code>repeated</code> — which\ntakes a string <code>s</code> and a number <code>n</code>, and returns a new string which\ncontains original <code>s</code> repeated <code>n</code> times.</p>\n<p>In most C-derived languages a call to this function will look like this:</p>\n<pre><code class=\"language-C\">repeated (&quot;hello&quot;, 3)  /* this is C code */\n</code></pre>\n<p>This means &quot;call the function <code>repeated</code> with two arguments, first\nargument the string hello and second argument the number 3&quot;.</p>\n<p>OCaml, in common with other functional languages, writes and brackets\nfunction calls differently, and this is the cause of many mistakes. Here\nis the same function call in OCaml:</p>\n<pre><code class=\"language-ocaml\">let repeated a b = a ^ (Int.to_string b);;\nrepeated &quot;hello&quot; 3  (* this is OCaml code *)\n</code></pre>\n<p>Note — <strong>no</strong> brackets, and <strong>no</strong> comma between the arguments.</p>\n<p>The syntax <code>repeated (&quot;hello&quot;, 3)</code> <strong>is</strong> meaningful in OCaml. It means\n&quot;call the function <code>repeated</code> with ONE argument, that argument being a\n'pair' structure of two elements&quot;. Of course that would be a mistake,\nbecause the <code>repeated</code> function is expecting two arguments, not one, and\nthe first argument should be a string, not a pair. But let's not worry\nabout pairs (&quot;tuples&quot;) just yet. Instead, just remember that it's a\nmistake to put the brackets and commas in around function call\narguments.</p>\n<p>Let's have another function — <code>prompt_string</code> — which takes a string to\nprompt and returns the string entered by the user. We want to pass this\nstring into <code>repeated</code>. Here are the C and OCaml versions:</p>\n<pre><code class=\"language-C\">/* C code: */\nrepeated (prompt_string (&quot;Name please: &quot;), 3)\n</code></pre>\n<pre><code class=\"language-ocaml\">let prompt_string p = &quot;&quot;;;\n(* OCaml code: *)\nrepeated (prompt_string &quot;Name please: &quot;) 3\n</code></pre>\n<p>Take a careful look at the bracketing and the missing comma. In the\nOCaml version, the brackets enclose the first argument of repeated\nbecause that argument is the result of another function call. In general\nthe rule is: &quot;bracket around the whole function call — don't put\nbrackets around the arguments to a function call&quot;. Here are some more\nexamples:</p>\n<pre><code class=\"language-ocaml\">let f a b c = &quot;&quot;;;\nlet g a = &quot;&quot;;;\nlet f2 a = &quot;&quot;;;\nlet g2 a b = &quot;&quot;;;\nf 5 (g &quot;hello&quot;) 3;;    (* f has three arguments, g has one argument *)\nf2 (g2 3 4)            (* f2 has one argument, g2 has two arguments *)\n</code></pre>\n<pre><code class=\"language-ocaml\"># repeated (&quot;hello&quot;, 3)     (* OCaml will spot the mistake *)\nLine 1, characters 10-22:\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n</code></pre>\n<h2 id=\"defining-a-function\">Defining a function</h2>\n<p>We all know how to define a function (or static method, in Java)\nin our existing languages. How do we do it in OCaml?</p>\n<p>The OCaml syntax is pleasantly concise. Here's a function which takes\ntwo floating point numbers and calculates the average:</p>\n<pre><code class=\"language-ocaml\">let average a b =\n  (a +. b) /. 2.0\n</code></pre>\n<p>Type this into the OCaml interactive toplevel (on Unix, type the command <code>ocaml</code>\nfrom the shell) and you'll see this:</p>\n<pre><code class=\"language-ocaml\"># let average a b =\n    (a +. b) /. 2.0;;\nval average : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>If you look at the function definition closely, and also at what OCaml\nprints back at you, you'll have a number of questions:</p>\n<ul>\n<li>What are those periods in <code>+.</code> and <code>/.</code> for?\n</li>\n<li>What does <code>float -&gt; float -&gt; float</code> mean?\n</li>\n</ul>\n<p>I'll answer those questions in the next sections, but first I want to go\nand define the same function in C (the Java definition would be fairly\nsimilar to C), and hopefully that should raise even more questions.\nHere's our C version of <code>average</code>:</p>\n<pre><code class=\"language-C\">double average (double a, double b)\n{\n  return (a + b) / 2;\n}\n</code></pre>\n<p>Now look at our much shorter OCaml definition above. Hopefully you'll be\nasking:</p>\n<ul>\n<li>Why don't we have to define the types of <code>a</code> and <code>b</code> in the OCaml\nversion? How does OCaml know what the types are (indeed, <em>does</em>\nOCaml know what the types are, or is OCaml completely dynamically\ntyped?).\n</li>\n<li>In C, the <code>2</code> is implicitly converted into a <code>double</code>, can't OCaml\ndo the same thing?\n</li>\n<li>What is the OCaml way to write <code>return</code>?\n</li>\n</ul>\n<p>OK, let's get some answers.</p>\n<ul>\n<li>OCaml is a strongly <em>statically typed</em> language (in other words,\nthere's nothing dynamic going on between int, float and string).\n</li>\n<li>OCaml uses <em>type inference</em> to work out the types, so you don't have\nto.  If you use the OCaml interactive toplevel as above, then OCaml\nwill tell you\nits inferred type for your function.\n</li>\n<li>OCaml doesn't do any implicit casting. If you want a float, you have\nto write <code>2.0</code> because <code>2</code> is an integer. OCaml does <strong>no automatic\nconversion</strong> between int, float, string or any other type.\n</li>\n<li>As a side-effect of type inference in OCaml, functions (including\noperators) can't have overloaded definitions. OCaml defines <code>+</code> as\nthe <em>integer</em> addition function. To add floats, use <code>+.</code> (note the\ntrailing period). Similarly, use <code>-.</code>, <code>*.</code>, <code>/.</code> for other float\noperations.\n</li>\n<li>OCaml doesn't have a <code>return</code> keyword — the last expression in a\nfunction becomes the result of the function automatically.\n</li>\n</ul>\n<p>We will present more details in the following sections and chapters.</p>\n<h2 id=\"basic-types\">Basic types</h2>\n<p>The basic types in OCaml are:</p>\n<pre><code class=\"language-text\">OCaml type  Range\n\nint         31-bit signed int (roughly +/- 1 billion) on 32-bit\n            processors, or 63-bit signed int on 64-bit processors\nfloat       IEEE double-precision floating point, equivalent to C's double\nbool        A boolean, written either 'true' or 'false'\nchar        An 8-bit character\nstring      A string\nunit        Written as ()\n</code></pre>\n<p>OCaml uses one of the bits in an <code>int</code> internally in order to be able to\nautomatically manage the memory use (garbage collection). This is why\nthe basic <code>int</code> is 31 bits, not 32 bits (63 bits if you're using a 64\nbit platform). In practice this isn't an issue except in a few\nspecialised cases. For example if you're counting things in a loop, then\nOCaml limits you to counting up to 1 billion instead of 2 billion. However if you need to do things\nsuch as processing 32 bit types (eg. you're writing crypto code or a\nnetwork stack), OCaml provides a <code>nativeint</code> type which matches the\nnative integer type for your platform.</p>\n<p>OCaml doesn't have a basic unsigned integer type, but you can get the\nsame effect using <code>nativeint</code>. OCaml doesn't have built-in single-precision\nfloating point numbers.</p>\n<p>OCaml provides a <code>char</code> type which is used for characters, written <code>'x'</code>\nfor example. Unfortunately the <code>char</code> type does not support Unicode or\nUTF-8, There are <a href=\"https://github.com/yoriyuki/Camomile\">comprehensive Unicode libraries</a>\nwhich provide this functionality.</p>\n<p>Strings are not just lists of characters. They have their own, more\nefficient internal representation. Strings are immutable.</p>\n<p>The <code>unit</code> type is sort of like <code>void</code> in C, but we'll talk about it\nmore below.</p>\n<h2 id=\"implicit-vs-explicit-casts\">Implicit vs. explicit casts</h2>\n<p>In C-derived languages ints get promoted to floats in certain\ncircumstances. For example if you write <code>1 + 2.5</code> then the first\nargument (which is an integer) is promoted to a floating point number,\nand the result is also a floating point number. It's as if you had\nwritten <code>((double) 1) + 2.5</code>, but all done implicitly.</p>\n<p>OCaml never does implicit casts like this. In OCaml, <code>1 + 2.5</code> is a type\nerror. The <code>+</code> operator in OCaml requires two ints as arguments, and\nhere we're giving it an int and a float, so it reports this error:</p>\n<pre><code class=\"language-ocaml\"># 1 + 2.5;;\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n</code></pre>\n<p>To add two floats together you need to use a different operator, <code>+.</code>\n(note the trailing period).</p>\n<p>OCaml doesn't promote ints to floats automatically so this is also an\nerror:</p>\n<pre><code class=\"language-ocaml\"># 1 +. 2.5\nLine 1, characters 1-2:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.'?\n</code></pre>\n<p>Here OCaml is now complaining about the first argument.</p>\n<p>What if you actually want to add an integer and a floating point number\ntogether? (Say they are stored as <code>i</code> and <code>f</code>). In OCaml you need to\nexplicitly cast:</p>\n<pre><code class=\"language-ocaml\">let i = 1;;\nlet f = 2.0;;\nfloat_of_int i +. f\n</code></pre>\n<p><code>float_of_int</code> is a function which takes an <code>int</code> and returns a <code>float</code>.\nThere are a whole load of these functions, called such things as\n<code>int_of_float</code>, <code>char_of_int</code>, <code>int_of_char</code>, <code>string_of_int</code> and so on,\nand they mostly do what you expect.</p>\n<p>Since converting an <code>int</code> to a <code>float</code> is a particularly common\noperation, the <code>float_of_int</code> function has a shorter alias: the above\nexample could simply have been written</p>\n<pre><code class=\"language-ocaml\">float i +. f\n</code></pre>\n<p>(Note that it is perfectly valid in OCaml for a type and a\nfunction to have the same name.)</p>\n<h3 id=\"is-implicit-or-explicit-casting-better\">Is implicit or explicit casting better?</h3>\n<p>You might think that these explicit casts are ugly, time-consuming even,\nand you have a point, but there are at least two arguments in their\nfavour. Firstly, OCaml needs this explicit casting to be able to do type\ninference (see below), and type inference is such a wonderful\ntime-saving feature that it easily offsets the extra keyboarding of\nexplicit casts. Secondly, if you've spent time debugging C programs\nyou'll know that (a) implicit casts cause errors which are hard to find,\nand (b) much of the time you're sitting there trying to work out where\nthe implicit casts happen. Making the casts explicit helps you in\ndebugging. Thirdly, some casts (particularly int &lt;-&gt; float) are\nactually very expensive operations. You do yourself no favours by hiding\nthem.</p>\n<h2 id=\"ordinary-functions-and-recursive-functions\">Ordinary functions and recursive functions</h2>\n<p>Unlike in C-derived languages, a function isn't recursive unless you\nexplicitly say so by using <code>let rec</code> instead of just <code>let</code>. Here's an\nexample of a recursive function:</p>\n<pre><code class=\"language-ocaml\"># let rec range a b =\n    if a &gt; b then []\n    else a :: range (a + 1) b\nval range : int -&gt; int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Notice that <code>range</code> calls itself.</p>\n<p>The only difference between <code>let</code> and <code>let rec</code> is in the scoping of the\nfunction name. If the above function had been defined with just <code>let</code>,\nthen the call to <code>range</code> would have tried to look for an existing\n(previously defined) function called <code>range</code>, not the\ncurrently-being-defined function. Using <code>let</code> (without <code>rec</code>) allows you\nto re-define a value in terms of the previous definition. For example:</p>\n<pre><code class=\"language-ocaml\"># let positive_sum a b = \n    let a = max a 0\n    and b = max b 0 in\n    a + b\nval positive_sum : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>This redefinition hides the previous &quot;bindings&quot; of <code>a</code> and <code>b</code> from the\nfunction definition. In some situations coders prefer this pattern to\nusing a new variable name (<code>let a_pos = max a 0</code>) as it makes the old\nbinding inaccessible, so that only the latest values of <code>a</code> and <code>b</code> are\naccessible.</p>\n<p>There is no performance difference between functions defined using <code>let</code>\nand functions defined using <code>let rec</code>, so if you prefer you could always\nuse the <code>let rec</code> form and get the same semantics as C-like languages.</p>\n<h2 id=\"types-of-functions\">Types of functions</h2>\n<p>Because of type inference you will rarely if ever need to explicitly\nwrite down the type of your functions. However, OCaml often prints out\nwhat it thinks are the types of your functions, so you need to know the\nsyntax for this. For a function <code>f</code> which takes arguments <code>arg1</code>,\n<code>arg2</code>, ... <code>argn</code>, and returns type <code>rettype</code>, the compiler will print:</p>\n<pre><code>f : arg1 -&gt; arg2 -&gt; ... -&gt; argn -&gt; rettype\n</code></pre>\n<p>The arrow syntax looks strange now, but when we come to so-called\n&quot;currying&quot; later you'll see why it was chosen. For now I'll just give\nyou some examples.</p>\n<p>Our function <code>repeated</code> which takes a string and an integer and returns\na string has type:</p>\n<pre><code class=\"language-ocaml\"># repeated\n- : string -&gt; int -&gt; string = &lt;fun&gt;\n</code></pre>\n<p>Our function <code>average</code> which takes two floats and returns a float has\ntype:</p>\n<pre><code class=\"language-ocaml\"># average\n- : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>The OCaml standard <code>int_of_char</code> casting function:</p>\n<pre><code class=\"language-ocaml\"># int_of_char\n- : char -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>If a function returns nothing (<code>void</code> for C and Java programmers), then\nwe write that it returns the <code>unit</code> type. Here, for instance, is the\nOCaml equivalent of C's <em><a href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/fputc.html\">fputc(3)</a></em>:</p>\n<pre><code class=\"language-ocaml\"># output_char\n- : out_channel -&gt; char -&gt; unit = &lt;fun&gt;\n</code></pre>\n<h3 id=\"polymorphic-functions\">Polymorphic functions</h3>\n<p>Now for something a bit stranger. What about a function which takes\n<em>anything</em> as an argument? Here's an odd function which takes an\nargument, but just ignores it and always returns 3:</p>\n<pre><code class=\"language-ocaml\">let give_me_a_three x = 3\n</code></pre>\n<p>What is the type of this function? In OCaml we use a special placeholder\nto mean &quot;any type you fancy&quot;. It's a single quote character followed by\na letter. The type of the above function would normally be written:</p>\n<pre><code class=\"language-ocaml\"># give_me_a_three\n- : 'a -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>where <code>'a</code> (pronounced alpha) really does mean any type. You can, for example, call this\nfunction as <code>give_me_a_three &quot;foo&quot;</code> or <code>give_me_a_three 2.0</code> and both\nare quite valid expressions in OCaml.</p>\n<p>It won't be clear yet why polymorphic functions are useful, but they are\nvery useful and very common, and so we'll discuss them later on. (Hint:\npolymorphism is kind of like templates in C++ or generics in Java).</p>\n<h2 id=\"type-inference\">Type inference</h2>\n<p>So the theme of this tutorial is that functional languages have many\nreally cool features, and OCaml is a language which has all of these\nreally cool features stuffed into it at once, thus making it a very\npractical language for real programmers to use. But the odd thing is\nthat most of these cool features have nothing to do with &quot;functional\nprogramming&quot; at all. In fact, I've come to the first really cool\nfeature, and I still haven't talked about why functional programming is\ncalled &quot;functional&quot;. Anyway, here's the first really cool feature: type\ninference.</p>\n<p>Simply put: you don't need to declare the types of your functions and\nvariables, because OCaml will just figure them out for you!</p>\n<p>In addition OCaml goes on to check all your types match up (even across\ndifferent files).</p>\n<p>But OCaml is also a practical language, and for this reason it contains\nbackdoors into the type system allowing you to bypass this checking on\nthe rare occasions that it is sensible to do this. Only gurus will\nprobably need to bypass the type checking.</p>\n<p>Let's go back to the <code>average</code> function which we typed into the OCaml\ninteractive toplevel:</p>\n<pre><code class=\"language-ocaml\"># let average a b =\n    (a +. b) /. 2.0\nval average : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>OCaml worked out all on its own that the function takes\ntwo <code>float</code> arguments and returns a <code>float</code>!</p>\n<p>How did it do this? Firstly it looks at where <code>a</code> and <code>b</code> are used,\nnamely in the expression <code>(a +. b)</code>. Now, <code>+.</code> is itself a function\nwhich always takes two <code>float</code> arguments, so by simple deduction, <code>a</code>\nand <code>b</code> must both also have type <code>float</code>.</p>\n<p>Secondly, the <code>/.</code> function returns a <code>float</code>, and this is the same as\nthe return value of the <code>average</code> function, so <code>average</code> must return a\n<code>float</code>. The conclusion is that <code>average</code> has this type signature:</p>\n<pre><code class=\"language-ocaml\"># average\n- : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>Type inference is obviously easy for such a short program, but it works\neven for large programs, and it's a major time-saving feature because it\nremoves a whole class of errors which cause segfaults,\n<code>NullPointerException</code>s and <code>ClassCastException</code>s in other languages (or\nimportant but often ignored runtime warnings).</p>\n"},{"title":"OCaml Programming Guidelines","slug":"ocaml-programming-guidelines","description":"Opinionated guidelines for writing OCaml code\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"getting-started","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":{"hd":"Advanced","tl":0}}},"body_md":"\nThis is a set of reasonable guidelines for formatting OCaml\nprograms—guidelines which reflect the consensus among veteran OCaml\nprogrammers. Nevertheless, all detailed notifications of possible errors\nor omissions will be noted with pleasure. To send your comments using\n[GitHub issues](https://github.com/ocaml/ocaml.org/issues?state=open).\n<br />\nOriginal translation from French: [Ruchira\nDatta](mailto:datta@math.berkeley.edu).\n\nThanks to all those who have already participated in the critique of\nthis page: Daniel de Rauglaudre, Luc Maranget, Jacques Garrigue, Damien\nDoligez, Xavier Leroy, Bruno Verlyck, Bruno Petazzoni, Francois Maltey,\nBasile Starynkevitch, Toby Moth, Pierre Lescanne.\n\n## General guidelines to write programs\n###  Be simple and readable\nThe time you spend typing the programs is negligible compared to the\ntime spent reading them. That's the reason why you save a lot of time if\nyou work hard to optimize readability.\n\nAll the time you are \"wasting\" to get a simpler program today, will\nreturn a hundred times in the future during the uncountably many\nmodifications and readings of the program (starting with the first\ndebugging).\n\n> \n> **Writing programs law**: A program is written once, modified ten\n> times, and read 100 times. So simplify its writing, always keep future\n> modifications in mind, and never jeopardize readability.\n> \n\n## Program formatting guidelines\n###  Lexical conventions\n> \n> **Pseudo spaces law**: never hesitate to separate words of your\n> programs with spaces; the space bar is the easiest key to find on the\n> keyboard, press it as often as necessary!\n> \n\n####  Delimiters\nA space should always follow a delimiter symbol, and spaces should\nsurround operator symbols. It has been a great step forward in\ntypography to separate words by spaces to make written texts easier to\nread. Do the same in your programs if you want them to be readable.\n\n####  How to write pairs\nA tuple is parenthesized and the commas therein (delimiters) are each\nfollowed by a space: `(1, 2)`, `let   triplet = (x, y, z)`...\n\n* **Commonly accepted exceptions**:\n    * **Definition of the components of a pair**: In place of\n `let (x, y) =       ...`, you can write `let x, y = ...`.\n\n> **Justification**: The point is to define several values\n> simultaneously, not to construct a tuple. Moreover, the\n> pattern is set off nicely between `let` and `=`.\n\n- **Matching several values simultaneously**: It's okay to omit\n  parentheses around n-tuples when matching several values\n  simultaneously.\n\n        match x, y with\n        | 1, _ -> ...\n        | x, 1 -> ...\n        | x, y -> ...\n\n  > **Justification**: The point is to match several values in\n  > parallel, not to construct a tuple. Moreover, the expressions\n  > being matched are set off by `match` and `with`, while the\n  > patterns are set off nicely by `|` and `->`.\n\n\n####  How to write lists\nWrite `x :: l` with spaces around the `::` (since `::` is an infix\noperator, hence surrounded by spaces) and `[1; 2; 3]` (since `;` is a\ndelimiter, hence followed by a space).\n\n####  How to write operator symbols\nBe careful to keep operator symbols well separated by spaces: not only\nwill your formulas be more readable, but you will avoid confusion with\nmulti-character operators. (Obvious exceptions to this rule: the symbols\n`!` and `.` are not separated from their arguments.)<br />\nExample: write `x + 1` or `x + !y`.\n\n \n> **Justification**: If you left out the spaces then `x+1` would be\n> understood, but `x+!y` would change its meaning since `+!` would\n> be interpreted as a multi-character operator.\n> \n> **Criticism**: The absence of spaces around an operator improves the\n> readability of formulas when you use it to reflect the relative\n> precedences of operators. For example `x*y + 2*z` makes it very\n> obvious that multiplication takes precedence over addition.\n> \n> **Response**: This is a bad idea, a chimera, because nothing in the\n> language ensures that the spaces properly reflect the meaning of the\n> formula. For example `x * z-1` means `(x * z) - 1`, and not\n> `x * (z - 1)` as the proposed interpretation of spaces would seem to\n> suggest. Besides, the problem of multi-character symbols would keep\n> you from using this convention in a uniform way: you couldn't leave\n> out the spaces around the multiplication to write `x*!y + 2*!z`.\n> Finally, this playing with the spaces is a subtle and flimsy\n> convention, a subliminal message which is difficult to grasp on\n> reading. If you want to make the precedences obvious, use the\n> expressive means brought to you by the language: write parentheses.\n> \n> **Additional justification**: Systematically surrounding operators\n> with spaces simplify the treatment of infix operators which are no\n> more a complex particular case; in effect, whereas you can write `(+)`\n> without spaces, you evidently cannot write `(*)` since `(*` is read as\n> the beginning of a comment. You must write at least one space as in\n> “`( *)`”, although an extra space after `*` is definitively preferable\n> if you want to avoid that `*)` could be read, in some contexts, as the\n> end of a comment. All those difficulties are easily avoided if you\n> adopt the simple rule proposed here: keep operator symbols well\n> separated by spaces.<br />\n> In fact you will quickly feel that this rule is not so difficult to\n> follow: the space bar is the greatest and best situated key of the\n> keyboard, it is the easiest to enter and you cannot miss it!\n\n\n####  How to write long character strings\nIndent long character strings with the convention in force at that line\nplus an indication of string continuation at the end of each line (a `\\`\ncharacter at the end of the line that omits white spaces on the\nbeginning of next line):\n<!-- $MDX skip -->\n```ocaml\nlet universal_declaration =\n  \"-1- Programs are born and remain free and equal under the law;\\n\\\n   distinctions can only be based on the common good.\" in\n  ...\n```\n\n## Indentation of programs\n> \n> **Landin's pseudo law**: Treat the indentation of your programs as if\n> it determines the meaning of your programs.\n> \n\nI would add to this law: carefully treat the indentation of programs\nbecause in some cases it really gives the meaning of the program!\n\nThe indentation of programs is an art which excites many strong\nopinions. Here several indentation styles are given which are drawn from\nexperience and which have not been severely criticized.\n\nWhen a justification for the adopted style has seemed obvious to me, I\nhave indicated it. On the other hand, criticisms are also noted.\n\nSo each time, you have to choose between the different styles\nsuggested.<br />\n The only absolute rule is the first below.\n\n###  Consistency of indentation\nChoose a generally accepted style of indentation, then use it\nsystematically throughout the whole application.\n\n###  Width of the page\nThe page is 80 columns wide.\n\n> **Justification**: This width makes it possible to read the code on\n> all displays and to print it in a legible font on a standard sheet.\n \n\n###  Height of the page\nA function should always fit within one screenful (of about 70 lines),\nor in exceptional cases two, at the very most three. To go beyond this\nis unreasonable.\n\n \n> **Justification**: When a function goes beyond one screenful, it's\n> time to divide it into subproblems and handle them independently.\n> Beyond a screenful, one gets lost in the code. The indentation is not\n> readable and is difficult to keep correct.\n\n\n###  How much to indent\nThe change in indentation between successive lines of the program is\ngenerally 1 or 2 spaces. Pick an amount to indent and stick with it\nthroughout the program.\n\n###  Using tab stops\nUsing the tab character (ASCII character 9) is absolutely *not*\nrecommended.\n\n\n> **Justification**: Between one display and another, the indentation of\n> the program changes completely; it can also become completely wrong,\n> if the programmer used both tabulations and spaces to indent the\n> program.\n> \n> **Criticism**: The purpose of using tabulations is just to allow the\n> readers of the program to indent more or less by changing the tabs\n> stops. The overall indentation remains correct and the reader is glad\n> to easily customize the indentation amount.\n> \n> **Answer**: It seems almost impossible to use this method since you\n> should always use tabulations to indent, which is hard and unnatural.\n \n\n###  How to indent global `let ... ;;` definitions\nThe body of a function defined globally in a module is generally\nindented normally. However, it's okay to treat this case specially to\nset off the definition better.\n\nWith a regular indentation of 1 or 2 spaces:\n\n<!-- $MDX skip -->\n```ocaml\nlet f x = function\n  | C ->\n  | D ->\n  ...\n\nlet g x =\n  let tmp =\n    match x with\n    | C -> 1\n    | x -> 0 in\n  tmp + 1\n```\n> \n> **Justification**: No exception to the amount of indentation.\n> \n\nOther conventions are acceptable, for example:\n\n* The body is left-justified in the case of pattern-matching.\n\n<!-- $MDX skip -->\n```ocaml\nlet f x = function\n| C ->\n| D ->\n...\n```\n> \n> **Justification**: The vertical bars separating the patterns stop\n> when the definition is done, so it's still easy to pass on to the\n> following definition.\n> \n> **Criticism**: An unpleasant exception to the normal indentation.\n> \n\n\n* The body is justified just under the name of the defined function.\n\n<!-- $MDX skip -->\n```ocaml\nlet f x =\n    let tmp = ... in\n    try g x with\n    | Not_found ->\n    ...\n```\n> \n> **Justification**: The first line of the definition is set off\n> nicely, so it's easier to pass from definition to definition.\n> \n> **Criticism**: You run into the right margin too quickly.\n> \n\n\n###  How to indent `let ... in` constructs\nThe expression following a definition introduced by `let` is indented to\nthe same level as the keyword `let`, and the keyword `in` which\nintroduces it is written at the end of the line:\n\n<!-- $MDX skip -->\n```ocaml\nlet expr1 = ... in\nexpr1 + expr1\n```\n\nIn the case of a series of `let` definitions, the preceding rule implies\nthat these definitions should be placed at the same indentation level:\n\n<!-- $MDX skip -->\n```ocaml\nlet expr1 = ... in\nlet n = ... in\n...\n```\n> \n> **Justification**: It is suggested that a series of “let ... in”\n> constructs is analogous to a set of assumptions in a mathematical\n> text, whence the same indentation level for all the assumptions.\n> \n\nVariation: some write the keyword `in` alone on one line to set apart\nthe final expression of the computation:\n\n<!-- $MDX skip -->\n```ocaml\nlet e1 = ... in\nlet e2 = ... in\nlet new_expr =\n  let e1' = derive_expression e1\n  and e2' = derive_expression e2 in\n  Add_expression e1' e2'\nin\nMult_expression (new_expr, new_expr)\n```\n> \n> **Criticism**: Lack of consistency.\n> \n\n###  How to indent `if ... then   ... else ... `\n####  Multiple branches\nWrite conditions with multiple branches at the same level of\nindentation:\n\n<!-- $MDX skip -->\n```ocaml\nif cond1 ...\nif cond2 ...\nif cond3 ...\n```\n> \n> **Justification**: Analogous treatment to pattern-matching clauses,\n> all aligned to the same tab stop.\n> \n\nIf the sizes of the conditions and the expressions allow, write for\nexample:\n\n<!-- $MDX skip -->\n```ocaml\nif cond1 then e1 else\nif cond2 then e2 else\nif cond3 then e3 else\ne4\n\n```\nIf expressions in the branches of multiple conditions have to be\nenclosed (when they include statements for instance), write:\n\n<!-- $MDX skip -->\n```ocaml\nif cond then begin\n    e1\n  end else\nif cond2 then begin\n    e2\n  end else\nif cond3 then ...\n```\nSome suggest another method for multiple conditionals, starting each\nline by the keyword `else`:\n\n<!-- $MDX skip -->\n```ocaml\nif cond1 ...\nelse if cond2 ...\nelse if cond3 ...\n```\n> \n> **Justification**: `elsif` is a keyword in many languages, so use\n> indentation and `else if` to bring it to mind. Moreover, you do not\n> have to look to the end of line to know whether the condition is\n> continued or another test is performed.\n> \n> **Criticism**: Lack of consistency in the treatment of all the\n> conditions. Why a special case for the first condition?\n> \n\nYet again, choose your style and use it systematically.\n\n####  Single branches\nSeveral styles are possible for single branches, according to the size\nof the expressions in question and especially the presence of `begin`\n`end` or `(` `)` delimiters for these expressions.\n\nIn the case of delimiting the branches of a conditional, several styles\nare used:\n\n> `(` at end of line:\n> \n> ```ocaml\n> if cond then (\n>   e1\n> ) else (\n>   e2\n> )\n> ```\n> Or alternatively first `begin` at beginning of line:\n> \n> ```ocaml\n> if cond then\n>   begin\n>     e1\n>   end else begin\n>     e2\n>   end\n> ```\n\nIn fact the indentation of conditionals depends on the sizes of the\nexpressions which make them up.\n\n> \n> If `cond`, `e1` and `e2` are small, simply write them on one line:\n> \n> ```ocaml\n> if cond then e1 else e2\n> ```\n> If the expressions making up a conditional are purely functional\n> (without side effects), we advocate binding them within the\n> conditional with `let e = ... in` when they're too big to fit on a\n> line.\n> \n> > \n> > **Justification**: This way you get back the simple indentation on\n> > one line which is the most readable. As a side benefit, the naming\n> > acts as an aid to comprehension.\n> > \n> \n> So now we consider the case in which the expressions in question do\n> have side effects, which keeps us from simply binding them with a\n> `let e = ... in`.\n> \n> > \n> > If `e1` and `cond` are small, but `e2` large:\n> > \n> > ```ocaml\n> > if cond then e1 else\n> >   e2\n> > ```\n> > \n> > If `e1` and `cond` are large and `e2` small:\n> > \n> > ```ocaml\n> > if cond then\n> >   e1\n> > else e2\n> > ```\n> > \n> > If all the expressions are large:\n> > \n> > ```ocaml\n> > if cond then\n> >   e1\n> > else\n> >   e2\n> > ```\n> > \n> > If there are `( )` delimiters:\n> > \n> > ```ocaml\n> > if cond then (\n> >   e1\n> > ) else (\n> >   e2\n> > )\n> > ```\n> > \n> > A mixture where `e1` requires `( )` but `e2` is small:\n> > \n> > ```ocaml\n> > if cond then (\n> >     e1\n> > ) else e2\n> > ```\n\n###  How to indent pattern-matching constructs\n####  General principles\nAll the pattern-matching clauses are introduced by a vertical bar,\n*including* the first one.\n\n> \n> **Criticism**: The first vertical bar is not mandatory: hence, there\n> is no need to write it.\n> \n> **Answer to criticism**: If you omit the first bar the indentation\n> seems unnatural : the first case gets an indentation that is greater\n> than a normal new line would necessitate. It is thus a useless\n> exception to the correct indentation rule. It also insists not to use\n> the same syntax for the whole set of clauses, writing the first clause\n> as an exception with a slightly different syntax. Last, aesthetic\n> value is doubtful (some people would say “awful” instead of\n> “doubtful”).\n> \n\nAlign all the pattern-matching clauses at the level of the vertical bar\nwhich begins each clause, *including* the first one.\n\nIf an expression in a clause is too large to fit on the line, you must\nbreak the line immediately after the arrow of the corresponding clause.\nThen indent normally, starting from the beginning of the pattern of the\nclause.\n\nArrows of pattern matching clauses should not be aligned.\n\n####  `match` or `try`\nFor a `match` or a `try` align the clauses with the beginning of the\nconstruct:\n\n<!-- $MDX skip -->\n```ocaml\nmatch lam with\n| Abs (x, body) -> 1 + size_lambda body\n| App (lam1, lam2) -> size_lambda lam1 + size_lambda lam2\n| Var v -> 1\n\ntry f x with\n| Not_found -> ...\n| Failure \"not yet implemented\" -> ...\n```\nPut the keyword `with` at the end of the line. If the preceding\nexpression extends beyond one line, put `with` on a line by itself:\n\n<!-- $MDX skip -->\n```ocaml\ntry\n  let y = f x in\n  if ...\nwith\n| Not_found -> ...\n| Failure \"not yet implemented\" -> ...\n```\n> \n> **Justification**: The keyword `with`, on a line by itself shows that\n> the program enters the pattern matching part of the construct.\n> \n\n####  Indenting expressions inside clauses\nIf the expression on the right of the pattern matching arrow is too\nlarge, cut the line after the arrow.\n\n<!-- $MDX skip -->\n```ocaml\nmatch lam with\n| Abs (x, body) ->\n   1 + size_lambda body\n| App (lam1, lam2) ->\n   size_lambda lam1 + size_lambda lam2\n| Var v ->\n```\nSome programmers generalize this rule to all clauses, as soon as one\nexpressions overflows. They will then indent the last clause like this:\n\n<!-- $MDX skip -->\n```ocaml\n| Var v ->\n   1\n```\nOther programmers go one step further and apply this rule systematically\nto any clause of any pattern matching.\n\n<!-- $MDX skip -->\n```ocaml\nlet rec fib = function\n  | 0 ->\n     1\n  | 1 ->\n     1\n  | n ->\n     fib (n - 1) + fib ( n - 2)\n```\n> \n> **Criticism**: May be not compact enough; for simple pattern matchings\n> (or simple clauses in complex matchings), the rule does not add any\n> good to readability.\n> \n> **Justification**: I don't see any good reason for this rule, unless\n> you are paid proportionally to the number of lines of code: in this\n> case use this rule to get more money without adding more bugs in your\n> OCaml programs!\n> \n\n####  Pattern matching in anonymous functions\nSimilarly to `match` or `try`, pattern matching of anonymous functions,\nstarting by `function`, are indented with respect to the `function`\nkeyword:\n\n<!-- $MDX skip -->\n```ocaml\nmap\n  (function\n   | Abs (x, body) -> 1 + size_lambda 0 body\n   | App (lam1, lam2) -> size_lambda (size_lambda 0 lam1) lam2\n   | Var v -> 1)\n  lambda_list\n```\n####  Pattern matching in named functions\nPattern-matching in functions defined by `let` or `let rec` gives rise\nto several reasonable styles which obey the preceding rules for pattern\nmatching (the one for anonymous functions being evidently excepted). See\nabove for recommended styles.\n\n<!-- $MDX skip -->\n```ocaml\nlet rec size_lambda accu = function\n  | Abs (x, body) -> size_lambda (succ accu) body\n  | App (lam1, lam2) -> size_lambda (size_lambda accu lam1) lam2\n  | Var v -> succ accu\n\nlet rec size_lambda accu = function\n| Abs (x, body) -> size_lambda (succ accu) body\n| App (lam1, lam2) -> size_lambda (size_lambda accu lam1) lam2\n| Var v -> succ accu\n```\n###  Bad indentation of pattern-matching constructs\n####  No *beastly* indentation of functions and case analyses.\nThis consists in indenting normally under the keyword `match` or\n`function` which has previously been pushed to the right. Don't write:\n\n<!-- $MDX skip -->\n```ocaml\nlet rec f x = function\n              | [] -> ...\n              ...\n```\nbut choose to indent the line under the `let` keyword:\n\n<!-- $MDX skip -->\n```ocaml\nlet rec f x = function\n  | [] -> ...\n  ...\n```\n> \n> **Justification**: You bump into the margin. The aesthetic value is\n> doubtful...\n> \n\n####  No *beastly* alignment of the `->` symbols in pattern-matching clauses.\nCareful alignment of the arrows of a pattern matching is considered bad\npractice, as exemplify in the following fragment:\n\n<!-- $MDX skip -->\n```ocaml\nlet f = function\n  | C1          -> 1\n  | Long_name _ -> 2\n  | _           -> 3\n```\n> \n> **Justification**: This makes it harder to maintain the program (the\n> addition of a supplementary case can lead the indentations of all the\n> lines to change and so ... we often give up alignment at that time,\n> then it is better not to align the arrows in the first place!).\n> \n\n###  How to indent function calls\n####  Indentation to the function's name:\nNo problem arises except for functions with many arguments&mdash;or very\ncomplicated arguments as well&mdash;which can't fit on the same line. You\nmust indent the expressions with respect to the name of the function (1\nor 2 spaces according to the chosen convention). Write small arguments\non the same line, and change lines at the start of an argument.\n\nAs far as possible, avoid arguments which consist of complex\nexpressions: in these cases define the “large” argument by a `let`\nconstruction.\n\n> \n> **Justification**: No indentation problem; if the name given to the\n> expressions is meaningful, the code is more readable as well.\n> \n> **Additional justification**: If the evaluation of the arguments\n> produces side effects, the `let` binding is in fact necessary to\n> explicitly define the order of evaluation.\n> \n\n####  Naming complex arguments:\nIn place of\n\n<!-- $MDX skip -->\n```ocaml\nlet temp =\n  f x y z\n    “large\n    expression”\n    “other large\n    expression” in\n...\n```\nwrite\n\n<!-- $MDX skip -->\n```ocaml\nlet t =\n  “large\n  expression”\nand u =\n  “other large\n  expression” in\nlet temp =\n  f x y z t u in\n...\n```\n####  Naming anonymous functions:\nIn the case of an iterator whose argument is a complex function, define\nthe function by a `let` binding as well. In place of\n\n<!-- $MDX skip -->\n```ocaml\nList.map\n  (function x ->\n    blabla\n    blabla\n    blabla)\n  l\n```\nwrite\n\n<!-- $MDX skip -->\n```ocaml\nlet f x =\n  blabla\n  blabla\n  blabla in\nList.map f l\n```\n> \n> **Justification**: Much clearer, in particular if the name given to\n> the function is meaningful.\n> \n\n###  How to indent operations\nWhen an operator takes complex arguments, or in the presence of multiple\ncalls to the same operator, start the next the line with the operator,\nand don't indent the rest of the operation. For example:\n\n<!-- $MDX skip -->\n```ocaml\nx + y + z\n+ t + u\n```\n> \n> **Justification**: When the operator starts the line, it is clear that\n> the operation continues on this line.\n> \n\nIn the case of a “large expression” in such an operation sequence,\nto define the “large expression” with the help of a `let in`\nconstruction is preferable to having to indent the line. In place of\n\n<!-- $MDX skip -->\n```ocaml\nx + y + z\n+ “large\n  expression”\n```\nwrite\n\n<!-- $MDX skip -->\n```ocaml\nlet t =\n  “large\n   expression” in\nx + y + z + t\n```\nYou most certainly must bind those expressions too large to be written\nin one operation in the case of a combination of operators. In place of\nthe unreadable expression\n\n<!-- $MDX skip -->\n```ocaml\n(x + y + z * t)\n/ (“large\n    expression”)\n```\nwrite\n\n<!-- $MDX skip -->\n```ocaml\nlet u =\n  “large\n  expression” in\n(x + y + z * t) / u\n```\nThese guidelines extend to all operators. For example:\n\n<!-- $MDX skip -->\n```ocaml\nlet u =\n  “large\n  expression” in\nx :: y\n:: z + 1 :: t :: u\n```\n## Programming guidelines\n###  How to program\n> \n> *Always put your handiwork back on the bench,<br />\n>  and then polish it and re-polish it.*\n> \n\n####  Write simple and clear programs\nWhen this is done, reread, simplify and clarify. At every stage of\ncreation, use your head!\n\n####  Subdivide your programs into little functions\nSmall functions are easier to master.\n\n####  Factor out snippets of repeated code by defining them in separate functions\nThe sharing of code obtained in this way facilitates maintenance since\nevery correction or improvement automatically spreads throughout the\nprogram. Besides, the simple act of isolating and naming a snippet of\ncode sometimes lets you identify an unsuspected feature.\n\n####  Never copy-paste code when programming\nPasting code almost surely indicates introducing a default of code\nsharing and neglecting to identify and write a useful auxiliary\nfunction; hence, it means that some code sharing is lost in the program.\nLosing code sharing implies that you will have more problems afterwards\nfor maintenance: a bug in the pasted code has to be corrected at each\noccurrence of the bug in each copy of the code!\n\nMoreover, it is difficult to identify that the same set of 10 lines of\ncode is repeated 20 times throughout the program. By contrast, if an\nauxiliary function defines those 10 lines, it is fairly easy to see and\nfind where those lines are used: that's simply where the function is\ncalled. If code is copy-pasted all over the place then the program is\nmore difficult to understand.\n\nIn conclusion, copy-pasting code leads to programs that are more\ndifficult to read and more difficult to maintain: it has to be banished.\n\n###  How to comment programs\n####  Don't hesitate to comment when there's a difficulty\n####  If there's no difficulty, there's no point in commenting\n####  Avoid comments in the bodies of functions\n####  Prefer one comment at the beginning of the function...\n...which explains how the algorithm that is used works. Once more, if\nthere is no difficulty, there is no point in commenting.\n\n####  Avoid nocuous comments\nA *nocuous* comment is a comment that does not add any value, i.e. no\nnon-trivial information. The nocuous comment is evidently not of\ninterest; it is a nuisance since it uselessly distracts the reader. It\nis often used to fulfill some strange criteria related to the so-called\n*software metrology*, for instance the ratio *number of comments* /\n*number of lines of code* that perfectly measures a ratio that I don't\nknow the theoretical or practical interpretation. Absolutely avoid\nnocuous comments.\n\nAn example of what to avoid: the following comment uses technical words\nand is thus masquerade into a real comment when it has no additional\ninformation of interest;\n\n<!-- $MDX skip -->\n```ocaml\n(*\n  Function print_lambda:\n  print a lambda-expression given as argument.\n\n  Arguments: lam, any lambda-expression.\n  Returns: nothing.\n\n  Remark: print_lambda can only be used for its side effect.\n*)\nlet rec print_lambda lam =\n  match lam with\n  | Var s -> printf \"%s\" s\n  | Abs l -> printf \"\\\\ %a\" print_lambda l\n  | App (l1, l2) ->\n     printf \"(%a %a)\" print_lambda l1 print_lambda l2\n```\n####  Usage in module interface\nThe function's usage must appear in the interface of the module which\nexports it, not in the program which implements it. Choose comments as\nin the OCaml system's interface modules, which will subsequently allow\nthe documentation of the interface module to be extracted automatically\nif need be.\n\n####  Use assertions\nUse assertions as much as possible: they let you avoid verbose comments,\nwhile allowing a useful verification upon execution.\n\nFor example, the conditions for the arguments of a function to be valid\nare usefully verified by assertions.\n\n<!-- $MDX skip -->\n```ocaml\nlet f x =\n  assert (x >= 0);\n  ...\n```\nNote as well that an assertion is often preferable to a comment because\nit's more trustworthy: an assertion is forced to be pertinent because it\nis verified upon each execution, while a comment can quickly become\nobsolete and then becomes actually detrimental to the comprehension of\nthe program.\n\n####  Comments line by line in imperative code\nWhen writing difficult code, and particularly in case of highly\nimperative code with a lot of memory modifications (physical mutations\nin data structures), it is sometime mandatory to comment inside the body\nof functions to explain the implementation of the algorithm encoded\nhere, or to follow successive modifications of invariants that the\nfunction must maintain. Once more, if there is some difficulty\ncommenting is mandatory, for each program line if necessary.\n\n###  How to choose identifiers\nIt's hard to choose identifiers whose name evokes the meaning of the\ncorresponding portion of the program. This is why you must devote\nparticular care to this, emphasizing clarity and regularity of\nnomenclature.\n\n####  Don't use abbreviations for global names\nGlobal identifiers (including especially the names of functions) can be\nlong, because it's important to understand what purpose they serve far\nfrom their definition.\n\n####  Separate words by underscores: (`int_of_string`, not `intOfString`)\nCase modifications are meaningful in OCaml: in effect capitalized words\nare reserved for constructors and module names in OCaml; in contrast\nregular variables (functions or identifiers) must start by a lowercase\nletter. Those rules prevent proper usage of case modification for words\nseparation in identifiers: the first word starts the identifier, hence\nit must be lower case and it is forbidden to choose `IntOfString` as the\nname of a function.\n\n####  Always give the same name to function arguments which have the same meaning\nIf necessary, make this nomenclature explicit in a comment at the top of\nthe file); if there are several arguments with the same meaning then\nattach numeral suffixes to them.\n\n####  Local identifiers can be brief, and should be reused from one function to another\nThis augments regularity of style. Avoid using identifiers whose\nappearance can lead to confusion such as `l` or `O`, easy to confuse\nwith `1` and `0`.\n\nExample:\n\n<!-- $MDX skip -->\n```ocaml\nlet add_expression expr1 expr2 = ...\nlet print_expression expr = ...\n```\nAn exception to the recommendation not to use capitalization to separate\nwords within identifiers is tolerated in the case of interfacing with\nexisting libraries which use this naming convention: this lets OCaml\nusers of the library to orient themselves in the original library\ndocumentation more easily.\n\n###  When to use parentheses within an expression\nParentheses are meaningful: they indicate the necessity of using an\nunusual precedence. So they should be used wisely and not sprinkled\nrandomly throughout programs. To this end, you should know the usual\nprecedences, that is, the combinations of operations which do not\nrequire parentheses. Quite fortunately this is not complicated if you\nknow a little mathematics or strive to follow the following rules:\n\n####  Arithmetic operators: the same rules as in mathematics\nFor example: `1 + 2 * x` means `1 + (2 * x)`.\n\n####  Function application: the same rules as those in mathematics for usage of *trigonometric functions*\nIn mathematics you write `sin x` to mean `sin (x)`. In the same way\n`sin x + cos x` means `(sin x) + (cos x)` not `sin (x + (cos x))`. Use\nthe same conventions in OCaml: write `f x + g x` to mean\n`(f x) + (g x)`.<br />\nThis convention generalizes **to all (infix) operators**: `f x :: g x`\nmeans `(f x) :: (g x)`, `f x @ g x` means `(f x) @ (g x)`, and\n`failwith s ^ s'` means `(failwith s) ^ s'`, *not* `failwith (s ^ s')`.\n\n####  Comparisons and boolean operators\nComparisons are infix operators, so the preceding rules apply. This is\nwhy `f x < g x` means `(f x) < (g x)`. For type reasons (no other\nsensible interpretation) the expression `f x < x + 2` means\n`(f x) < (x + 2)`. In the same way `f x < x + 2 && x > 3` means\n`((f x) < (x + 2)) && (x > 3)`.\n\n####  The relative precedences of the boolean operators are those of mathematics\nAlthough mathematicians have a tendency to overuse parens in this case,\nthe boolean “or” operator is analogous to addition and the “and”\nto multiplication. So, just as `1 + 2 * x` means `1 + (2 * x)`,\n`true || false && x` means `true || (false && x)`.\n\n###  How to delimit constructs in programs\nWhen it is necessary to delimit syntactic constructs in programs, use as\ndelimiters the keywords `begin` and `end` rather than parentheses.\nHowever using parentheses is acceptable if you do it in a consistent,\nthat is, systematic, way.\n\nThis explicit delimiting of constructs essentially concerns\npattern-matching constructs or sequences embedded within\n`if then     else` constructs.\n\n####  `match` construct in a `match` construct\nWhen a `match ... with` or `try ... with` construct appears in a\npattern-matching clause, it is absolutely necessary to delimit this\nembedded construct (otherwise subsequent clauses of the enclosing\npattern-matching construct will automatically be associated with the\nenclosed pattern-matching construct). For example:\n\n<!-- $MDX skip -->\n```ocaml\nmatch x with\n| 1 ->\n  begin match y with\n  | ...\n  end\n| 2 ->\n...\n```\n####  Sequences inside branches of `if`\nIn the same way, a sequence which appears in the `then` or `else` part\nof a conditional must be delimited:\n\n<!-- $MDX skip -->\n```ocaml\nif cond then begin\n  e1;\n  e2\nend else begin\n  e3;\n  e4\nend\n```\n###  How to use modules\n####  Subdividing into modules\nYou must subdivide your programs into coherent modules.\n\nFor each module, you must explicitly write an interface.\n\nFor each interface, you must document the things defined by the module:\nfunctions, types, exceptions, etc.\n\n####  Opening modules\nAvoid `open` directives, using instead the qualified identifier\nnotation. Thus you will prefer short but meaningful module names.\n\n> \n> **Justification**: The use of unqualified identifiers is ambiguous and\n> gives rise to difficult-to-detect semantic errors.\n> \n\n<!-- $MDX skip -->\n```ocaml\nlet lim = String.length name - 1 in\n...\nlet lim = Array.length v - 1 in\n...\n... List.map succ ...\n... Array.map succ ...\n```\n####  When to use open modules rather than leaving them closed\nYou can consider it normal to open a module which modifies the\nenvironment, and brings other versions of an important set of functions.\nFor example, the `Format` module provides automatically indented\nprinting. This module redefines the usual printing functions\n`print_string`, `print_int`, `print_float`, etc. So when you use\n`Format`, open it systematically at the top of the file.<br />\nIf you don't open `Format` you could miss the qualification of a\nprinting function, and this could be perfectly silent, since many of\n`Format`'s functions have a counterpart in the default environment\n(`Pervasives`). Mixing printing functions from `Format` and `Pervasives`\nleads to subtle bugs in the display, that are difficult to trace. For\ninstance:\n\n<!-- $MDX skip -->\n```ocaml\nlet f () =\n  Format.print_string \"Hello World!\"; print_newline ()\n```\nis bogus since it does not call `Format.print_newline` to flush the\npretty-printer queue and output `\"Hello World!\"`. Instead\n`\"Hello World!\"` is stuck into the pretty-printer queue, while\n`Pervasives.print_newline` outputs a carriage return on the standard\noutput ... If `Format` is printing on a file and standard output is the\nterminal, the user will have a bad time finding that a carriage return\nis missing in the file (and the display of material on the file is\nstrange, since boxes that should be closed by `Format.print_newline` are\nstill open), while a spurious carriage return appeared on the screen!\n\nFor the same reason, open large libraries such as the one with\narbitrary-precision integers so as not to burden the program which uses\nthem.\n\n<!-- $MDX skip -->\n```ocaml\nopen Num\n\nlet rec fib n =\n  if n <= 2 then Int 1 else fib (n - 1) +/ fib (n - 2)\n```\n> \n> **Justification**: The program would be less readable if you had to\n> qualify all the identifiers.\n> \n\nIn a program where type definitions are shared, it is good to gather\nthese definitions into one or more module(s) without implementations\n(containing only types). Then it's acceptable to systematically open the\nmodule which exports the shared type definitions.\n\n###  Pattern-matching\n####  Never be afraid of over-using pattern-matching!\n####  On the other hand, be careful to avoid non-exhaustive pattern-matching constructs\nComplete them with care, without using a “catch-all” clause such as\n`| _ -> ...` or `| x -> ...` when it's possible to do without it (for\nexample when matching a concrete type defined within the program). See\nalso the next section: compiler warnings.\n\n###  Compiler warnings\nCompiler warnings are meant to prevent potential errors; this is why you\nabsolutely must heed them and correct your programs if compiling them\nproduces such warnings. Besides, programs whose compilation produces\nwarnings have an odor of amateurism which certainly doesn't suit your\nown work!\n\n####  Pattern-matching warnings\nWarnings about pattern-matching must be treated with the upmost care:\n\n* Those concerning useless clauses should of course be eliminated.\n\n\n* For non-exhaustive pattern-matching you must complete the\n corresponding pattern-matching construct, without adding a default\n case “catch-all”, such as `| _ -> ... `, but with an explicit\n list of the constructors not examined by the rest of the construct,\n for example `| Cn _ | Cn1 _ -> ... `.\n\n> \n> **Justification**: It's not really any more complicated to write\n> it this way, and this allows the program to evolve more safely. In\n> effect the addition of a new constructor to the datatype being\n> matched will produce an alert anew, which will allow the\n> programmer to add a clause corresponding to the new constructor if\n> that is warranted. On the contrary, the “catch-all” clause\n> will make the function compile silently and it might be thought\n> that the function is correct as the new constructor will be\n> handled by the default case.\n> \n\n\n* Non-exhaustive pattern-matches induced by clauses with guards must\n also be corrected. A typical case consists in suppressing a\n redundant guard.\n\n####  De-structuring `let` bindings\n\\[Translator's note: a “de-structuring `let` binding” is one which\nbinds several names to several expressions simultaneously. You pack all\nthe names you want bound into a collection such as a tuple or a list,\nand you correspondingly pack all the expressions into a collective\nexpression. When the `let` binding is evaluated, it unpacks the\ncollections on both sides and binds each expression to its corresponding\nname. For example, `let x, y = 1, 2` is a de-structuring `let` binding\nwhich performs both the bindings `let x = 1` and `let y = 2`\nsimultaneously.\\]<br />\nThe `let` binding is not limited to simple identifier definitions: you\ncan use it with more complex or simpler patterns. For instance\n\n* `let` with complex patterns:<br />\n `let [x; y] as l = ...`<br />\n simultaneously defines a list `l` and its two elements `x` and `y`.\n* `let` with simple pattern:<br />\n `let _ = ...` does not define anything, it just evaluate the\n expression on the right hand side of the `=` symbol.\n\n####  The de-structuring `let` must be exhaustive\nOnly use de-structuring `let` bindings in the case where the\npattern-matching is exhaustive (the pattern can never fail to match).\nTypically, you will thus be limited to definitions of product types\n(tuples or records) or definitions of variant type with a single case.\nIn any other case, you should use an explicit `match   ... with`\nconstruct.\n\n* `let ... in`: de-structuring `let` that give a warning must be\n replaced by an explicit pattern matching. For instance, instead of\n `let [x; y] as l = List.map succ     (l1 @ l2) in expression` write:\n\n<!-- $MDX skip -->\n```ocaml\nmatch List.map succ (l1 @ l2) with\n| [x; y] as l -> expression\n| _ -> assert false\n```\n\n\n* Global definition with de-structuring lets should be rewritten with\n explicit pattern matching and tuples:\n\n<!-- $MDX skip -->\n```ocaml\nlet x, y, l =\n  match List.map succ (l1 @ l2) with\n  | [x; y] as l -> x, y, l\n  | _ -> assert false\n```\n\n\n> \n> **Justification**: There is no way to make the pattern-matching\n> exhaustive if you use general de-structuring `let` bindings.\n> \n\n####  Sequence warnings and `let _ = ...`\nWhen the compiler emits a warning about the type of an expression in a\nsequence, you have to explicitly indicate that you want to ignore the\nresult of this expression. To this end:\n\n* use a vacuous binding and suppress the sequence warning of\n\n<!-- $MDX skip -->\n```ocaml\nList.map f l;\nprint_newline ()\n```\nwrite\n<!-- $MDX skip -->\n```ocaml\nlet _ = List.map f l in\nprint_newline ()\n```\n\n\n* you can also use the predefined function `ignore : 'a     -> unit`\n that ignores its argument to return `unit`.\n\n<!-- $MDX skip -->\n```ocaml\nignore (List.map f l);\nprint_newline ()\n```\n\n\n* In any case, the best way to suppress this warning is to understand\n why it is emitted by the compiler: the compiler warns you because\n your code computes a result that is useless since this result is\n just deleted after computation. Hence, if useful at all, this\n computation is performed only for its side-effects; hence it should\n return unit.<br />\n Most of the time, the warning indicates the use of the wrong\n function, a probable confusion between the side-effect only version\n of a function (which is a procedure whose result is irrelevant) with\n its functional counterpart (whose result is meaningful).<br />\n In the example mentioned above, the first situation prevailed, and\n the programmer should have called `iter` instead of `map`, and\n simply write\n\n<!-- $MDX skip -->\n```ocaml\nList.iter f l;\nprint_newline ()\n```\nIn actual programs, the suitable (side-effect only) function may not\nexist and has to be written: very often, a careful separation of the\nprocedural part from the functional part of the function at hand\nelegantly solves the problem, and the resulting program just looks\nbetter afterwards! For instance, you would turn the problematic\ndefinition:\n<!-- $MDX skip -->\n```ocaml\nlet add x y =\n  if x > 1 then print_int x;\n  print_newline ();\n  x + y;;\n```\ninto the clearer separate definitions and change old calls to `add`\naccordingly.\n\n\n\nIn any case, use the `let _ = ...` construction exactly in those cases\nwhere you want to ignore a result. Don't systematically replace\nsequences with this construction.\n\n> \n> **Justification**: Sequences are much clearer! Compare `e1; e2; e3` to\n> \n> ```ocaml\n> let _ = e1 in\n> let _ = e2 in\n> e3\n> ```\n\n###  The `hd` and `tl` functions\nDon't use the `hd` and `tl` functions, but pattern-match the list\nargument explicitly.\n\n> \n> **Justification**: This is just as brief as and much clearer than\n> using `hd` and `tl` which must of necessity be protected by\n> `try... with...` to catch the exception which might be raised by these\n> functions.\n> \n\n###  Loops\n####  `for` loops\nTo simply traverse an array or a string, use a `for` loop.\n\n<!-- $MDX skip -->\n```ocaml\nfor i = 0 to Array.length v - 1 do\n  ...\ndone\n```\nIf the loop is complex or returns a result, use a recursive function.\n\n<!-- $MDX skip -->\n```ocaml\nlet find_index e v =\n  let rec loop i =\n    if i >= Array.length v then raise Not_found else\n    if v.(i) = e then i else loop (i + 1) in\n  loop 0;;\n```\n> \n> **Justification**: The recursive function lets you code any loop\n> whatsoever simply, even a complex one, for example with multiple exit\n> points or with strange index steps (steps depending on a data value\n> for example).\n> \n> Besides, the recursive loop avoids the use of mutables whose value can\n> be modified in any part of the body of the loop whatsoever (or even\n> outside): on the contrary the recursive loop explicitly takes as\n> arguments the values susceptible to change during the recursive calls.\n> \n\n####  `while` loops\n> \n> **While loops law**: Beware: usually a while loop is wrong, unless its\n> loop invariant has been explicitly written.\n> \n\nThe main use of the `while` loop is the infinite loop\n`while true do     ...`. You get out of it through an exception,\ngenerally on termination of the program.\n\nOther `while` loops are hard to use, unless they come from canned\nprograms from algorithms courses where they were proved.\n\n> \n> **Justification**: `while` loops require one or more mutables in order\n> that the loop condition change value and the loop finally terminate.\n> To prove their correctness, you must therefore discover the loop\n> invariants, an interesting but difficult sport.\n> \n\n###  Exceptions\nDon't be afraid to define your own exceptions in your programs, but on\nthe other hand use as much as possible the exceptions predefined by the\nsystem. For example, every search function which fails should raise the\npredefined exception `Not_found`. Be careful to handle the exceptions\nwhich may be raised by a function call with the help of a\n`try ... with`.\n\nHandling all exceptions by `try     ... with _ ->` is usually reserved\nfor the main function of the program. If you need to catch all\nexceptions to maintain an invariant of an algorithm, be careful to name\nthe exception and re-raise it, after having reset the invariant.\nTypically:\n<!-- $MDX skip -->\n```ocaml\nlet ic = open_in ...\nand oc = open_out ... in\ntry\n  treatment ic oc;\n  close_in ic; close_out oc\nwith x -> close_in ic; close_out oc; raise x\n```\n> \n> **Justification**: `try ... with _     ->` silently catches all\n> exceptions, even those which have nothing to do with the computation\n> at hand (for example an interruption will be captured and the\n> computation will continue anyway!).\n> \n\n###  Data structures\nOne of the great strengths of OCaml is the power of the data structures\nwhich can be defined and the simplicity of manipulating them. So you\nmust take advantage of this to the fullest extent; don't hesitate to\ndefine your own data structures. In particular, don't systematically\nrepresent enumerations by whole numbers, nor enumerations with two cases\nby booleans. Examples:\n\n```ocaml\ntype figure =\n   | Triangle | Square | Circle | Parallelogram\ntype convexity =\n   | Convex | Concave | Other\ntype type_of_definition =\n   | Recursive | Non_recursive\n```\n> \n> **Justification**: A boolean value often prevents intuitive\n> understanding of the corresponding code. For example, if\n> `type_of_definition` is coded by a boolean, what does `true` signify?\n> A “normal” definition (that is, non-recursive) or a recursive\n> definition?\n> \n> In the case of an enumerated type encode by an integer, it is very\n> difficult to limit the range of acceptable integers: one must define\n> construction functions that will ensure the mandatory invariants of\n> the program (and verify afterwards that no values has been built\n> directly), or add assertions in the program and guards in pattern\n> matchings. This is not good practice, when the definition of a sum\n> type elegantly solves this problem, with the additional benefit of\n> firing the full power of pattern matching and compiler's verifications\n> of exhaustiveness.\n> \n> **Criticism**: For binary enumerations, one can systematically define\n> predicates whose names carry the semantics of the boolean that\n> implements the type. For instance, we can adopt the convention that a\n> predicate ends by the letter `p`. Then, in place of defining a new sum\n> type for `type_of_definition`, we will use a predicate function\n> `recursivep` that returns true if the definition is recursive.\n> \n> **Answer**: This method is specific to binary enumeration and cannot\n> be easily extended; moreover it is not well suited to pattern\n> matching. For instance, for definitions encoded by\n> `| Let of bool * string * expression` a typical pattern matching would\n> look like:\n> \n> ```ocaml\n> | Let (_, v, e) as def ->\n>    if recursivep def then code_for_recursive_case\n>    else code_for_non_recursive_case\n> ```\n> \n> or, if `recursivep` can be applied to booleans:\n> \n> ```ocaml\n> | Let (b, v, e) ->\n>    if recursivep b then code_for_recursive_case\n>    else code_for_non_recursive_case\n> ```\n> \n> contrast with an explicit encoding:\n> \n> ```ocaml\n> | Let (Recursive, v, e) -> code_for_recursive_case\n> | Let (Non_recursive, v, e) -> code_for_non_recursive_case\n> ```\n> \n> The difference between the two programs is subtle and you may think\n> that this is just a matter of taste; however the explicit encoding is\n> definitively more robust to modifications and fits better with the\n> language.\n> \n\n*A contrario*, it is not necessary to systematically define new types\nfor boolean flags, when the interpretation of constructors `true` and\n`false` is clear. The usefulness of the definition of the following\ntypes is then questionable:\n<!-- $MDX skip -->\n```ocaml\ntype switch = On | Off\ntype bit = One | Zero\n```\nThe same objection is admissible for enumerated types represented as\nintegers, when those integers have an evident interpretation with\nrespect to the data to be represented.\n\n###  When to use mutables\nMutable values are useful and sometimes indispensable to simple and\nclear programming. Nevertheless, you must use them with discernment:\nOCaml's normal data structures are immutable. They are to be preferred\nfor the clarity and safety of programming which they allow.\n\n###  Iterators\nOCaml's iterators are a powerful and useful feature. However you should\nnot overuse them, nor *a contrario* neglect them: they are provided to\nyou by libraries and have every chance of being correct and\nwell-thought-out by the author of the library. So it's useless to\nreinvent them.\n\nSo write\n<!-- $MDX skip -->\n```ocaml\nlet square_elements elements = List.map square elements\n```\nrather than:\n<!-- $MDX skip -->\n```ocaml\nlet rec square_elements = function\n  | [] -> []\n  | elem :: elements -> square elem :: square_elements elements\n```\nOn the other hand avoid writing:\n<!-- $MDX skip -->\n```ocaml\nlet iterator f x l =\n  List.fold_right (List.fold_left f) [List.map x l] l\n```\neven though you get:\n<!-- $MDX skip -->\n```ocaml\n  let iterator f x l =\n    List.fold_right (List.fold_left f) [List.map x l] l;;\n  iterator (fun l x -> x :: l) (fun l -> List.rev l) [[1; 2; 3]]\n```\nIn case of express need, you must be careful to add an explanatory\ncomment: in my opinion it's absolutely necessary!\n\n###  How to optimize programs\n> \n> **Pseudo law of optimization**: No optimization *a priori*.<br />\n>  No optimization *a posteriori* either.\n> \n\nAbove all program simply and clearly. Don't start optimizing until the\nprogram bottleneck has been identified (in general a few routines). Then\noptimization consists above all of changing *the complexity* of the\nalgorithm used. This often happens through redefining the data\nstructures being manipulated and completely rewriting the part of the\nprogram which poses a problem.\n\n> \n> **Justification**: Clarity and correctness of programs take\n> precedence. Besides, in a substantial program, it is practically\n> impossible to identify *a priori* the parts of the program whose\n> efficiency is of prime importance.\n> \n\n###  How to choose between classes and modules\nYou should use OCaml classes when you need inheritance, that is,\nincremental refinement of data and their functionality.\n\nYou should use conventional data structures (in particular, variant\ntypes) when you need pattern-matching.\n\nYou should use modules when the data structures are fixed and their\nfunctionality is equally fixed or it's enough to add new functions in\nthe programs which use them.\n\n###  Clarity of OCaml code\nThe OCaml language includes powerful constructs which allow simple and\nclear programming. The main problem to obtain crystal clear programs it\nto use them appropriately.\n\nThe language features numerous programming styles (or programming\nparadigms): imperative programming (based on the notion of state and\nassignment), functional programming (based on the notion of function,\nfunction results, and calculus), object oriented programming (based of\nthe notion of objects encapsulating a state and some procedures or\nmethods that can modify the state). The first work of the programmer is\nto choose the programming paradigm that fits the best the problem at\nhand. When using one of those programming paradigms, the difficulty is\nto use the language construct that expresses in the most natural and\neasiest way the computation that implements the algorithm.\n\n####  Style dangers\nConcerning programming styles, one can usually observe the two\nsymmetrical problematic behaviors: on the one hand, the “all\nimperative” way (*systematic* usage of loops and assignment), and on\nthe other hand the “purely functional” way (*never* use loops nor\nassignments); the “100% object” style will certainly appear in the\nnext future, but (fortunately) it is too new to be discussed here.\n\n* **The “Too much imperative” danger**:\n    * It is a bad idea to use imperative style to code a function that\n is *naturally* recursive. For instance, to compute the length of\n a list, you should not write:\n<!-- $MDX skip -->\n```ocaml\nlet list_length l =\n  let l = ref l in\n  let res = ref 0 in\n  while !l <> [] do\n    incr res; l := List.tl !l\n  done;\n  !res;;\n```\nin place of the following recursive function, so simple and\nclear:\n<!-- $MDX skip -->\n```ocaml\nlet rec list_length = function\n  | [] -> 0\n  | _ :: l -> 1 + list_length l\n```\n(For those that would contest the equivalence of those two\nversions, see the [note below](#Imperativeandfunctionalversionsoflistlength)).\n\n\n* Another common “over imperative error” in the imperative world is\n  not to systematically choose the simple `for` loop to iter on the\n  element of a vector, but instead to use a complex `while` loop, with\n  one or two references (too many useless assignments, too many\n  opportunity for errors).\n\n* This category of programmer feels that the `mutable` keyword in\n  the record type definitions should be implicit.\n\n* **The “Too much functional” danger**:\n    * The programmer that adheres to this dogma avoids\n using arrays and assignment. In the most severe case, one\n observes a complete denial of writing any imperative\n construction, even in case it is evidently the most elegant way\n to solve the problem.\n    * Characteristic symptoms: systematic rewriting of `for` loops\n with recursive functions, usage of lists in contexts where\n imperative data structures seem to be mandatory to anyone,\n passing numerous global parameters of the problem to every\n functions, even if a global reference would be perfect to avoid\n these spurious parameters that are mainly invariants that must\n be passed all over the place.\n    * This programmer feels that the `mutable` keyword in the record\n type definitions should be suppressed from the language.\n\n####  OCaml code generally considered unreadable\nThe OCaml language includes powerful constructs which allow simple and\nclear programming. However the power of these constructs also lets you\nwrite uselessly complicated code, to the point where you get a perfectly\nunreadable program.\n\nHere are a number of known ways:\n\n* Use useless (hence novice for readability) `if then else`, as in\n<!-- $MDX skip -->\n```ocaml\nlet flush_ps () =\n  if not !psused then psused := true\n```\nor (more subtle)\n<!-- $MDX skip -->\n```ocaml\nlet sync b =\n  if !last_is_dvi <> b then last_is_dvi := b\n```\n\n\n* Code one construct with another. For example code a `let ... in` by\n the application of an anonymous function to an argument. You would\n write<br />\n<!-- $MDX skip -->\n```ocaml\n(fun x y -> x + y)\n   e1 e2\n```\ninstead of simply writing\n<!-- $MDX skip -->\n```ocaml\nlet x = e1\nand y = e2 in\nx + y\n```\n\n\n* Systematically code sequences with `let in` bindings.\n\n\n* Mix computations and side effects, particularly in function calls.\n Recall that the order of evaluation of arguments in a function call\n is unspecified, which implies that you must not mix side effects and\n computations in function calls. However, when there is only one\n argument you might take advantage of this to perform a side effect\n within the argument, which is extremely troublesome for the reader\n albeit without danger to the program semantics. To be absolutely\n forbidden.\n\n\n* Misuse of iterators and higher-order functions (i.e. over- or\n under-use). For example it's better to use `List.map` or\n `List.iter` than to write their equivalents in-line using specific\n recursive functions of your own. Even worse, you don't use\n `List.map` or `List.iter` but write their equivalents in terms of\n `List.fold_right` and `List.fold_left`.\n\n\n* Another efficient way to write unreadable code is to mix all or some\n of these methods. For example:\n<!-- $MDX skip -->\n```ocaml\n(fun u -> print_string \"world\"; print_string u)\n  (let temp = print_string \"Hello\"; \"!\" in\n   ((fun x -> print_string x; flush stdout) \" \";\n    temp));;\n```\n\n\nIf you naturally write the program `print_string \"Hello world!\"` in this\nway, you can without a doubt submit your work to the [Obfuscated OCaml\nContest](mailto:Pierre.Weis@inria.fr).\n\n## Managing program development\nWe give here tips from veteran OCaml programmers, which have served in\ndeveloping the compilers which are good examples of large complex\nprograms developed by small teams.\n\n###  How to edit programs\nMany developers nurture a kind of veneration towards the Emacs editor\n(gnu-emacs in general) which they use to write their programs. The\neditor interfaces well with the language since it is capable of syntax\ncoloring OCaml source code (rendering different categories of words in\ncolor, coloring keywords for example).\n\nThe following two commands are considered indispensable:\n\n* `CTRL-C-CTRL-C` or `Meta-X compile`: launches re-compilation from\n within the editor (using the `make` command).\n* `` CTRL-X-` ``: puts the cursor in the file and at the exact place\n where the OCaml compiler has signaled an error.\n\nDevelopers describe thus how to use these features: `CTRL-C-CTRL-C`\ncombination recompiles the whole application; in case of errors, a\nsuccession of `` CTRL-X-` `` commands permits correction of all the\nerrors signaled; the cycle begins again with a new re-compilation\nlaunched by `CTRL-C-CTRL-C`.\n\n####  Other emacs tricks\nThe `ESC-/` command (dynamic-abbrev-expand) automatically completes the\nword in front of the cursor with one of the words present in one of the\nfiles being edited. Thus this lets you always choose meaningful\nidentifiers without the tedium of having to type extended names in your\nprograms: the `ESC-/` easily completes the identifier after typing the\nfirst letters. In case it brings up the wrong completion, each\nsubsequent `ESC-/` proposes an alternate completion.\n\nUnder Unix, the `CTRL-C-CTRL-C` or `Meta-X     compile` combination,\nfollowed by `` CTRL-X-` `` is also used to find all occurrences of a\ncertain string in a OCaml program. Instead of launching `make` to\nrecompile, you launch the `grep` command; then all the “error\nmessages” from `grep` are compatible with the `` CTRL-X-` `` usage\nwhich automatically takes you to the file and the place where the string\nis found.\n\n###  How to edit with the interactive system\nUnder Unix: use the line editor `ledit` which offers great editing\ncapabilities “à la emacs” (including `ESC-/`!), as well as a history\nmechanism which lets you retrieve previously typed commands and even\nretrieve commands from one session in another. `ledit` is written in\nOCaml and can be freely down-loaded\n[here](ftp://ftp.inria.fr/INRIA/Projects/cristal/caml-light/bazar-ocaml/ledit.tar.gz).\n\n###  How to compile\nThe `make` utility is indispensable for managing the compilation and\nre-compilation of programs. Sample `make` files can be found on [The\nHump](https://caml.inria.fr//cgi-bin/hump.en.cgi). You can also consult\nthe `Makefiles` for the OCaml compilers.\n\n###  How to develop as a team: version control\nUsers of the [Git](https://git-scm.com/) software version control system\nnever run out of good things to say about the productivity gains it\nbrings. This system supports managing development by a team of\nprogrammers while imposing consistency among them, and also maintains a\nlog of changes made to the software.<br />\n Git also supports simultaneous development by several teams, possibly\ndispersed among several sites linked on the Net.\n\nAn anonymous Git read-only mirror [contains the working sources of the\nOCaml compilers](https://github.com/ocaml/ocaml), and the sources of\nother software related to OCaml.\n\n##  Notes\n###  Imperative and functional versions of `list_length`\nThe two versions of `list_length` are not completely equivalent in term\nof complexity, since the imperative version uses a constant amount of\nstack room to execute, whereas the functional version needs to store\nreturn addresses of suspended recursive calls (whose maximum number is\nequal to the length of the list argument). If you want to retrieve a\nconstant space requirement to run the functional program you just have\nto write a function that is recursive in its tail (or *tail-rec*), that\nis a function that just ends by a recursive call (which is not the case\nhere since a call to `+` has to be perform after the recursive call has\nreturned). Just use an accumulator for intermediate results, as in:\n<!-- $MDX skip -->\n```ocaml\nlet list_length l =\n  let rec loop accu = function\n    | [] -> accu\n    | _ :: l -> loop (accu + 1) l in\n  loop 0 l\n```\nThis way, you get a program that has the same computational properties\nas the imperative program with the additional clarity and natural\nlook of an algorithm that performs pattern matching and recursive\ncalls to handle an argument that belongs to a recursive sum data type.\n\n","toc_html":"<ul>\n<li><ul>\n<li><a href=\"#general-guidelines-to-write-programs\">General guidelines to write programs</a>\n</li>\n<li><a href=\"#program-formatting-guidelines\">Program formatting guidelines</a>\n</li>\n<li><a href=\"#indentation-of-programs\">Indentation of programs</a>\n</li>\n<li><a href=\"#programming-guidelines\">Programming guidelines</a>\n</li>\n<li><a href=\"#managing-program-development\">Managing program development</a>\n</li>\n<li><a href=\"#notes\">Notes</a>\n</li>\n</ul>\n</li>\n</ul>\n","body_html":"<p>This is a set of reasonable guidelines for formatting OCaml\nprograms—guidelines which reflect the consensus among veteran OCaml\nprogrammers. Nevertheless, all detailed notifications of possible errors\nor omissions will be noted with pleasure. To send your comments using\n<a href=\"https://github.com/ocaml/ocaml.org/issues?state=open\">GitHub issues</a>.\n<br />\nOriginal translation from French: <a href=\"mailto:datta@math.berkeley.edu\">Ruchira\nDatta</a>.</p>\n<p>Thanks to all those who have already participated in the critique of\nthis page: Daniel de Rauglaudre, Luc Maranget, Jacques Garrigue, Damien\nDoligez, Xavier Leroy, Bruno Verlyck, Bruno Petazzoni, Francois Maltey,\nBasile Starynkevitch, Toby Moth, Pierre Lescanne.</p>\n<h2 id=\"general-guidelines-to-write-programs\">General guidelines to write programs</h2>\n<h3 id=\"be-simple-and-readable\">Be simple and readable</h3>\n<p>The time you spend typing the programs is negligible compared to the\ntime spent reading them. That's the reason why you save a lot of time if\nyou work hard to optimize readability.</p>\n<p>All the time you are &quot;wasting&quot; to get a simpler program today, will\nreturn a hundred times in the future during the uncountably many\nmodifications and readings of the program (starting with the first\ndebugging).</p>\n<blockquote>\n<p><strong>Writing programs law</strong>: A program is written once, modified ten\ntimes, and read 100 times. So simplify its writing, always keep future\nmodifications in mind, and never jeopardize readability.</p>\n</blockquote>\n<h2 id=\"program-formatting-guidelines\">Program formatting guidelines</h2>\n<h3 id=\"lexical-conventions\">Lexical conventions</h3>\n<blockquote>\n<p><strong>Pseudo spaces law</strong>: never hesitate to separate words of your\nprograms with spaces; the space bar is the easiest key to find on the\nkeyboard, press it as often as necessary!</p>\n</blockquote>\n<h4 id=\"delimiters\">Delimiters</h4>\n<p>A space should always follow a delimiter symbol, and spaces should\nsurround operator symbols. It has been a great step forward in\ntypography to separate words by spaces to make written texts easier to\nread. Do the same in your programs if you want them to be readable.</p>\n<h4 id=\"how-to-write-pairs\">How to write pairs</h4>\n<p>A tuple is parenthesized and the commas therein (delimiters) are each\nfollowed by a space: <code>(1, 2)</code>, <code>let   triplet = (x, y, z)</code>...</p>\n<ul>\n<li><strong>Commonly accepted exceptions</strong>:\n<ul>\n<li><strong>Definition of the components of a pair</strong>: In place of\n<code>let (x, y) =       ...</code>, you can write <code>let x, y = ...</code>.\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Justification</strong>: The point is to define several values\nsimultaneously, not to construct a tuple. Moreover, the\npattern is set off nicely between <code>let</code> and <code>=</code>.</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>Matching several values simultaneously</strong>: It's okay to omit\nparentheses around n-tuples when matching several values\nsimultaneously.</p>\n<pre><code>  match x, y with\n  | 1, _ -&gt; ...\n  | x, 1 -&gt; ...\n  | x, y -&gt; ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The point is to match several values in\nparallel, not to construct a tuple. Moreover, the expressions\nbeing matched are set off by <code>match</code> and <code>with</code>, while the\npatterns are set off nicely by <code>|</code> and <code>-&gt;</code>.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"how-to-write-lists\">How to write lists</h4>\n<p>Write <code>x :: l</code> with spaces around the <code>::</code> (since <code>::</code> is an infix\noperator, hence surrounded by spaces) and <code>[1; 2; 3]</code> (since <code>;</code> is a\ndelimiter, hence followed by a space).</p>\n<h4 id=\"how-to-write-operator-symbols\">How to write operator symbols</h4>\n<p>Be careful to keep operator symbols well separated by spaces: not only\nwill your formulas be more readable, but you will avoid confusion with\nmulti-character operators. (Obvious exceptions to this rule: the symbols\n<code>!</code> and <code>.</code> are not separated from their arguments.)<br />\nExample: write <code>x + 1</code> or <code>x + !y</code>.</p>\n<blockquote>\n<p><strong>Justification</strong>: If you left out the spaces then <code>x+1</code> would be\nunderstood, but <code>x+!y</code> would change its meaning since <code>+!</code> would\nbe interpreted as a multi-character operator.</p>\n<p><strong>Criticism</strong>: The absence of spaces around an operator improves the\nreadability of formulas when you use it to reflect the relative\nprecedences of operators. For example <code>x*y + 2*z</code> makes it very\nobvious that multiplication takes precedence over addition.</p>\n<p><strong>Response</strong>: This is a bad idea, a chimera, because nothing in the\nlanguage ensures that the spaces properly reflect the meaning of the\nformula. For example <code>x * z-1</code> means <code>(x * z) - 1</code>, and not\n<code>x * (z - 1)</code> as the proposed interpretation of spaces would seem to\nsuggest. Besides, the problem of multi-character symbols would keep\nyou from using this convention in a uniform way: you couldn't leave\nout the spaces around the multiplication to write <code>x*!y + 2*!z</code>.\nFinally, this playing with the spaces is a subtle and flimsy\nconvention, a subliminal message which is difficult to grasp on\nreading. If you want to make the precedences obvious, use the\nexpressive means brought to you by the language: write parentheses.</p>\n<p><strong>Additional justification</strong>: Systematically surrounding operators\nwith spaces simplify the treatment of infix operators which are no\nmore a complex particular case; in effect, whereas you can write <code>(+)</code>\nwithout spaces, you evidently cannot write <code>(*)</code> since <code>(*</code> is read as\nthe beginning of a comment. You must write at least one space as in\n“<code>( *)</code>”, although an extra space after <code>*</code> is definitively preferable\nif you want to avoid that <code>*)</code> could be read, in some contexts, as the\nend of a comment. All those difficulties are easily avoided if you\nadopt the simple rule proposed here: keep operator symbols well\nseparated by spaces.<br />\nIn fact you will quickly feel that this rule is not so difficult to\nfollow: the space bar is the greatest and best situated key of the\nkeyboard, it is the easiest to enter and you cannot miss it!</p>\n</blockquote>\n<h4 id=\"how-to-write-long-character-strings\">How to write long character strings</h4>\n<p>Indent long character strings with the convention in force at that line\nplus an indication of string continuation at the end of each line (a <code>\\</code>\ncharacter at the end of the line that omits white spaces on the\nbeginning of next line):</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let universal_declaration =\n  &quot;-1- Programs are born and remain free and equal under the law;\\n\\\n   distinctions can only be based on the common good.&quot; in\n  ...\n</code></pre>\n<h2 id=\"indentation-of-programs\">Indentation of programs</h2>\n<blockquote>\n<p><strong>Landin's pseudo law</strong>: Treat the indentation of your programs as if\nit determines the meaning of your programs.</p>\n</blockquote>\n<p>I would add to this law: carefully treat the indentation of programs\nbecause in some cases it really gives the meaning of the program!</p>\n<p>The indentation of programs is an art which excites many strong\nopinions. Here several indentation styles are given which are drawn from\nexperience and which have not been severely criticized.</p>\n<p>When a justification for the adopted style has seemed obvious to me, I\nhave indicated it. On the other hand, criticisms are also noted.</p>\n<p>So each time, you have to choose between the different styles\nsuggested.<br />\nThe only absolute rule is the first below.</p>\n<h3 id=\"consistency-of-indentation\">Consistency of indentation</h3>\n<p>Choose a generally accepted style of indentation, then use it\nsystematically throughout the whole application.</p>\n<h3 id=\"width-of-the-page\">Width of the page</h3>\n<p>The page is 80 columns wide.</p>\n<blockquote>\n<p><strong>Justification</strong>: This width makes it possible to read the code on\nall displays and to print it in a legible font on a standard sheet.</p>\n</blockquote>\n<h3 id=\"height-of-the-page\">Height of the page</h3>\n<p>A function should always fit within one screenful (of about 70 lines),\nor in exceptional cases two, at the very most three. To go beyond this\nis unreasonable.</p>\n<blockquote>\n<p><strong>Justification</strong>: When a function goes beyond one screenful, it's\ntime to divide it into subproblems and handle them independently.\nBeyond a screenful, one gets lost in the code. The indentation is not\nreadable and is difficult to keep correct.</p>\n</blockquote>\n<h3 id=\"how-much-to-indent\">How much to indent</h3>\n<p>The change in indentation between successive lines of the program is\ngenerally 1 or 2 spaces. Pick an amount to indent and stick with it\nthroughout the program.</p>\n<h3 id=\"using-tab-stops\">Using tab stops</h3>\n<p>Using the tab character (ASCII character 9) is absolutely <em>not</em>\nrecommended.</p>\n<blockquote>\n<p><strong>Justification</strong>: Between one display and another, the indentation of\nthe program changes completely; it can also become completely wrong,\nif the programmer used both tabulations and spaces to indent the\nprogram.</p>\n<p><strong>Criticism</strong>: The purpose of using tabulations is just to allow the\nreaders of the program to indent more or less by changing the tabs\nstops. The overall indentation remains correct and the reader is glad\nto easily customize the indentation amount.</p>\n<p><strong>Answer</strong>: It seems almost impossible to use this method since you\nshould always use tabulations to indent, which is hard and unnatural.</p>\n</blockquote>\n<h3 id=\"how-to-indent-global-let---definitions\">How to indent global <code>let ... ;;</code> definitions</h3>\n<p>The body of a function defined globally in a module is generally\nindented normally. However, it's okay to treat this case specially to\nset off the definition better.</p>\n<p>With a regular indentation of 1 or 2 spaces:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f x = function\n  | C -&gt;\n  | D -&gt;\n  ...\n\nlet g x =\n  let tmp =\n    match x with\n    | C -&gt; 1\n    | x -&gt; 0 in\n  tmp + 1\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: No exception to the amount of indentation.</p>\n</blockquote>\n<p>Other conventions are acceptable, for example:</p>\n<ul>\n<li>The body is left-justified in the case of pattern-matching.\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f x = function\n| C -&gt;\n| D -&gt;\n...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The vertical bars separating the patterns stop\nwhen the definition is done, so it's still easy to pass on to the\nfollowing definition.</p>\n<p><strong>Criticism</strong>: An unpleasant exception to the normal indentation.</p>\n</blockquote>\n<ul>\n<li>The body is justified just under the name of the defined function.\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f x =\n    let tmp = ... in\n    try g x with\n    | Not_found -&gt;\n    ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The first line of the definition is set off\nnicely, so it's easier to pass from definition to definition.</p>\n<p><strong>Criticism</strong>: You run into the right margin too quickly.</p>\n</blockquote>\n<h3 id=\"how-to-indent-let--in-constructs\">How to indent <code>let ... in</code> constructs</h3>\n<p>The expression following a definition introduced by <code>let</code> is indented to\nthe same level as the keyword <code>let</code>, and the keyword <code>in</code> which\nintroduces it is written at the end of the line:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let expr1 = ... in\nexpr1 + expr1\n</code></pre>\n<p>In the case of a series of <code>let</code> definitions, the preceding rule implies\nthat these definitions should be placed at the same indentation level:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let expr1 = ... in\nlet n = ... in\n...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: It is suggested that a series of “let ... in”\nconstructs is analogous to a set of assumptions in a mathematical\ntext, whence the same indentation level for all the assumptions.</p>\n</blockquote>\n<p>Variation: some write the keyword <code>in</code> alone on one line to set apart\nthe final expression of the computation:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let e1 = ... in\nlet e2 = ... in\nlet new_expr =\n  let e1' = derive_expression e1\n  and e2' = derive_expression e2 in\n  Add_expression e1' e2'\nin\nMult_expression (new_expr, new_expr)\n</code></pre>\n<blockquote>\n<p><strong>Criticism</strong>: Lack of consistency.</p>\n</blockquote>\n<h3 id=\"how-to-indent-if--then----else--\">How to indent <code>if ... then   ... else ... </code></h3>\n<h4 id=\"multiple-branches\">Multiple branches</h4>\n<p>Write conditions with multiple branches at the same level of\nindentation:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">if cond1 ...\nif cond2 ...\nif cond3 ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: Analogous treatment to pattern-matching clauses,\nall aligned to the same tab stop.</p>\n</blockquote>\n<p>If the sizes of the conditions and the expressions allow, write for\nexample:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">if cond1 then e1 else\nif cond2 then e2 else\nif cond3 then e3 else\ne4\n\n</code></pre>\n<p>If expressions in the branches of multiple conditions have to be\nenclosed (when they include statements for instance), write:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">if cond then begin\n    e1\n  end else\nif cond2 then begin\n    e2\n  end else\nif cond3 then ...\n</code></pre>\n<p>Some suggest another method for multiple conditionals, starting each\nline by the keyword <code>else</code>:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">if cond1 ...\nelse if cond2 ...\nelse if cond3 ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: <code>elsif</code> is a keyword in many languages, so use\nindentation and <code>else if</code> to bring it to mind. Moreover, you do not\nhave to look to the end of line to know whether the condition is\ncontinued or another test is performed.</p>\n<p><strong>Criticism</strong>: Lack of consistency in the treatment of all the\nconditions. Why a special case for the first condition?</p>\n</blockquote>\n<p>Yet again, choose your style and use it systematically.</p>\n<h4 id=\"single-branches\">Single branches</h4>\n<p>Several styles are possible for single branches, according to the size\nof the expressions in question and especially the presence of <code>begin</code>\n<code>end</code> or <code>(</code> <code>)</code> delimiters for these expressions.</p>\n<p>In the case of delimiting the branches of a conditional, several styles\nare used:</p>\n<blockquote>\n<p><code>(</code> at end of line:</p>\n<pre><code class=\"language-ocaml\">if cond then (\n  e1\n) else (\n  e2\n)\n</code></pre>\n<p>Or alternatively first <code>begin</code> at beginning of line:</p>\n<pre><code class=\"language-ocaml\">if cond then\n  begin\n    e1\n  end else begin\n    e2\n  end\n</code></pre>\n</blockquote>\n<p>In fact the indentation of conditionals depends on the sizes of the\nexpressions which make them up.</p>\n<blockquote>\n<p>If <code>cond</code>, <code>e1</code> and <code>e2</code> are small, simply write them on one line:</p>\n<pre><code class=\"language-ocaml\">if cond then e1 else e2\n</code></pre>\n<p>If the expressions making up a conditional are purely functional\n(without side effects), we advocate binding them within the\nconditional with <code>let e = ... in</code> when they're too big to fit on a\nline.</p>\n<blockquote>\n<p><strong>Justification</strong>: This way you get back the simple indentation on\none line which is the most readable. As a side benefit, the naming\nacts as an aid to comprehension.</p>\n</blockquote>\n<p>So now we consider the case in which the expressions in question do\nhave side effects, which keeps us from simply binding them with a\n<code>let e = ... in</code>.</p>\n<blockquote>\n<p>If <code>e1</code> and <code>cond</code> are small, but <code>e2</code> large:</p>\n<pre><code class=\"language-ocaml\">if cond then e1 else\n  e2\n</code></pre>\n<p>If <code>e1</code> and <code>cond</code> are large and <code>e2</code> small:</p>\n<pre><code class=\"language-ocaml\">if cond then\n  e1\nelse e2\n</code></pre>\n<p>If all the expressions are large:</p>\n<pre><code class=\"language-ocaml\">if cond then\n  e1\nelse\n  e2\n</code></pre>\n<p>If there are <code>( )</code> delimiters:</p>\n<pre><code class=\"language-ocaml\">if cond then (\n  e1\n) else (\n  e2\n)\n</code></pre>\n<p>A mixture where <code>e1</code> requires <code>( )</code> but <code>e2</code> is small:</p>\n<pre><code class=\"language-ocaml\">if cond then (\n    e1\n) else e2\n</code></pre>\n</blockquote>\n</blockquote>\n<h3 id=\"how-to-indent-pattern-matching-constructs\">How to indent pattern-matching constructs</h3>\n<h4 id=\"general-principles\">General principles</h4>\n<p>All the pattern-matching clauses are introduced by a vertical bar,\n<em>including</em> the first one.</p>\n<blockquote>\n<p><strong>Criticism</strong>: The first vertical bar is not mandatory: hence, there\nis no need to write it.</p>\n<p><strong>Answer to criticism</strong>: If you omit the first bar the indentation\nseems unnatural : the first case gets an indentation that is greater\nthan a normal new line would necessitate. It is thus a useless\nexception to the correct indentation rule. It also insists not to use\nthe same syntax for the whole set of clauses, writing the first clause\nas an exception with a slightly different syntax. Last, aesthetic\nvalue is doubtful (some people would say “awful” instead of\n“doubtful”).</p>\n</blockquote>\n<p>Align all the pattern-matching clauses at the level of the vertical bar\nwhich begins each clause, <em>including</em> the first one.</p>\n<p>If an expression in a clause is too large to fit on the line, you must\nbreak the line immediately after the arrow of the corresponding clause.\nThen indent normally, starting from the beginning of the pattern of the\nclause.</p>\n<p>Arrows of pattern matching clauses should not be aligned.</p>\n<h4 id=\"match-or-try\"><code>match</code> or <code>try</code></h4>\n<p>For a <code>match</code> or a <code>try</code> align the clauses with the beginning of the\nconstruct:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">match lam with\n| Abs (x, body) -&gt; 1 + size_lambda body\n| App (lam1, lam2) -&gt; size_lambda lam1 + size_lambda lam2\n| Var v -&gt; 1\n\ntry f x with\n| Not_found -&gt; ...\n| Failure &quot;not yet implemented&quot; -&gt; ...\n</code></pre>\n<p>Put the keyword <code>with</code> at the end of the line. If the preceding\nexpression extends beyond one line, put <code>with</code> on a line by itself:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">try\n  let y = f x in\n  if ...\nwith\n| Not_found -&gt; ...\n| Failure &quot;not yet implemented&quot; -&gt; ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The keyword <code>with</code>, on a line by itself shows that\nthe program enters the pattern matching part of the construct.</p>\n</blockquote>\n<h4 id=\"indenting-expressions-inside-clauses\">Indenting expressions inside clauses</h4>\n<p>If the expression on the right of the pattern matching arrow is too\nlarge, cut the line after the arrow.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">match lam with\n| Abs (x, body) -&gt;\n   1 + size_lambda body\n| App (lam1, lam2) -&gt;\n   size_lambda lam1 + size_lambda lam2\n| Var v -&gt;\n</code></pre>\n<p>Some programmers generalize this rule to all clauses, as soon as one\nexpressions overflows. They will then indent the last clause like this:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">| Var v -&gt;\n   1\n</code></pre>\n<p>Other programmers go one step further and apply this rule systematically\nto any clause of any pattern matching.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec fib = function\n  | 0 -&gt;\n     1\n  | 1 -&gt;\n     1\n  | n -&gt;\n     fib (n - 1) + fib ( n - 2)\n</code></pre>\n<blockquote>\n<p><strong>Criticism</strong>: May be not compact enough; for simple pattern matchings\n(or simple clauses in complex matchings), the rule does not add any\ngood to readability.</p>\n<p><strong>Justification</strong>: I don't see any good reason for this rule, unless\nyou are paid proportionally to the number of lines of code: in this\ncase use this rule to get more money without adding more bugs in your\nOCaml programs!</p>\n</blockquote>\n<h4 id=\"pattern-matching-in-anonymous-functions\">Pattern matching in anonymous functions</h4>\n<p>Similarly to <code>match</code> or <code>try</code>, pattern matching of anonymous functions,\nstarting by <code>function</code>, are indented with respect to the <code>function</code>\nkeyword:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">map\n  (function\n   | Abs (x, body) -&gt; 1 + size_lambda 0 body\n   | App (lam1, lam2) -&gt; size_lambda (size_lambda 0 lam1) lam2\n   | Var v -&gt; 1)\n  lambda_list\n</code></pre>\n<h4 id=\"pattern-matching-in-named-functions\">Pattern matching in named functions</h4>\n<p>Pattern-matching in functions defined by <code>let</code> or <code>let rec</code> gives rise\nto several reasonable styles which obey the preceding rules for pattern\nmatching (the one for anonymous functions being evidently excepted). See\nabove for recommended styles.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec size_lambda accu = function\n  | Abs (x, body) -&gt; size_lambda (succ accu) body\n  | App (lam1, lam2) -&gt; size_lambda (size_lambda accu lam1) lam2\n  | Var v -&gt; succ accu\n\nlet rec size_lambda accu = function\n| Abs (x, body) -&gt; size_lambda (succ accu) body\n| App (lam1, lam2) -&gt; size_lambda (size_lambda accu lam1) lam2\n| Var v -&gt; succ accu\n</code></pre>\n<h3 id=\"bad-indentation-of-pattern-matching-constructs\">Bad indentation of pattern-matching constructs</h3>\n<h4 id=\"no-beastly-indentation-of-functions-and-case-analyses\">No <em>beastly</em> indentation of functions and case analyses.</h4>\n<p>This consists in indenting normally under the keyword <code>match</code> or\n<code>function</code> which has previously been pushed to the right. Don't write:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec f x = function\n              | [] -&gt; ...\n              ...\n</code></pre>\n<p>but choose to indent the line under the <code>let</code> keyword:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec f x = function\n  | [] -&gt; ...\n  ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: You bump into the margin. The aesthetic value is\ndoubtful...</p>\n</blockquote>\n<h4 id=\"no-beastly-alignment-of-the---symbols-in-pattern-matching-clauses\">No <em>beastly</em> alignment of the <code>-&gt;</code> symbols in pattern-matching clauses.</h4>\n<p>Careful alignment of the arrows of a pattern matching is considered bad\npractice, as exemplify in the following fragment:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f = function\n  | C1          -&gt; 1\n  | Long_name _ -&gt; 2\n  | _           -&gt; 3\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: This makes it harder to maintain the program (the\naddition of a supplementary case can lead the indentations of all the\nlines to change and so ... we often give up alignment at that time,\nthen it is better not to align the arrows in the first place!).</p>\n</blockquote>\n<h3 id=\"how-to-indent-function-calls\">How to indent function calls</h3>\n<h4 id=\"indentation-to-the-functions-name\">Indentation to the function's name:</h4>\n<p>No problem arises except for functions with many arguments—or very\ncomplicated arguments as well—which can't fit on the same line. You\nmust indent the expressions with respect to the name of the function (1\nor 2 spaces according to the chosen convention). Write small arguments\non the same line, and change lines at the start of an argument.</p>\n<p>As far as possible, avoid arguments which consist of complex\nexpressions: in these cases define the “large” argument by a <code>let</code>\nconstruction.</p>\n<blockquote>\n<p><strong>Justification</strong>: No indentation problem; if the name given to the\nexpressions is meaningful, the code is more readable as well.</p>\n<p><strong>Additional justification</strong>: If the evaluation of the arguments\nproduces side effects, the <code>let</code> binding is in fact necessary to\nexplicitly define the order of evaluation.</p>\n</blockquote>\n<h4 id=\"naming-complex-arguments\">Naming complex arguments:</h4>\n<p>In place of</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let temp =\n  f x y z\n    “large\n    expression”\n    “other large\n    expression” in\n...\n</code></pre>\n<p>write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let t =\n  “large\n  expression”\nand u =\n  “other large\n  expression” in\nlet temp =\n  f x y z t u in\n...\n</code></pre>\n<h4 id=\"naming-anonymous-functions\">Naming anonymous functions:</h4>\n<p>In the case of an iterator whose argument is a complex function, define\nthe function by a <code>let</code> binding as well. In place of</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">List.map\n  (function x -&gt;\n    blabla\n    blabla\n    blabla)\n  l\n</code></pre>\n<p>write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f x =\n  blabla\n  blabla\n  blabla in\nList.map f l\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: Much clearer, in particular if the name given to\nthe function is meaningful.</p>\n</blockquote>\n<h3 id=\"how-to-indent-operations\">How to indent operations</h3>\n<p>When an operator takes complex arguments, or in the presence of multiple\ncalls to the same operator, start the next the line with the operator,\nand don't indent the rest of the operation. For example:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">x + y + z\n+ t + u\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: When the operator starts the line, it is clear that\nthe operation continues on this line.</p>\n</blockquote>\n<p>In the case of a “large expression” in such an operation sequence,\nto define the “large expression” with the help of a <code>let in</code>\nconstruction is preferable to having to indent the line. In place of</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">x + y + z\n+ “large\n  expression”\n</code></pre>\n<p>write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let t =\n  “large\n   expression” in\nx + y + z + t\n</code></pre>\n<p>You most certainly must bind those expressions too large to be written\nin one operation in the case of a combination of operators. In place of\nthe unreadable expression</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">(x + y + z * t)\n/ (“large\n    expression”)\n</code></pre>\n<p>write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let u =\n  “large\n  expression” in\n(x + y + z * t) / u\n</code></pre>\n<p>These guidelines extend to all operators. For example:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let u =\n  “large\n  expression” in\nx :: y\n:: z + 1 :: t :: u\n</code></pre>\n<h2 id=\"programming-guidelines\">Programming guidelines</h2>\n<h3 id=\"how-to-program\">How to program</h3>\n<blockquote>\n<p><em>Always put your handiwork back on the bench,<br />\nand then polish it and re-polish it.</em></p>\n</blockquote>\n<h4 id=\"write-simple-and-clear-programs\">Write simple and clear programs</h4>\n<p>When this is done, reread, simplify and clarify. At every stage of\ncreation, use your head!</p>\n<h4 id=\"subdivide-your-programs-into-little-functions\">Subdivide your programs into little functions</h4>\n<p>Small functions are easier to master.</p>\n<h4 id=\"factor-out-snippets-of-repeated-code-by-defining-them-in-separate-functions\">Factor out snippets of repeated code by defining them in separate functions</h4>\n<p>The sharing of code obtained in this way facilitates maintenance since\nevery correction or improvement automatically spreads throughout the\nprogram. Besides, the simple act of isolating and naming a snippet of\ncode sometimes lets you identify an unsuspected feature.</p>\n<h4 id=\"never-copy-paste-code-when-programming\">Never copy-paste code when programming</h4>\n<p>Pasting code almost surely indicates introducing a default of code\nsharing and neglecting to identify and write a useful auxiliary\nfunction; hence, it means that some code sharing is lost in the program.\nLosing code sharing implies that you will have more problems afterwards\nfor maintenance: a bug in the pasted code has to be corrected at each\noccurrence of the bug in each copy of the code!</p>\n<p>Moreover, it is difficult to identify that the same set of 10 lines of\ncode is repeated 20 times throughout the program. By contrast, if an\nauxiliary function defines those 10 lines, it is fairly easy to see and\nfind where those lines are used: that's simply where the function is\ncalled. If code is copy-pasted all over the place then the program is\nmore difficult to understand.</p>\n<p>In conclusion, copy-pasting code leads to programs that are more\ndifficult to read and more difficult to maintain: it has to be banished.</p>\n<h3 id=\"how-to-comment-programs\">How to comment programs</h3>\n<h4 id=\"dont-hesitate-to-comment-when-theres-a-difficulty\">Don't hesitate to comment when there's a difficulty</h4>\n<h4 id=\"if-theres-no-difficulty-theres-no-point-in-commenting\">If there's no difficulty, there's no point in commenting</h4>\n<h4 id=\"avoid-comments-in-the-bodies-of-functions\">Avoid comments in the bodies of functions</h4>\n<h4 id=\"prefer-one-comment-at-the-beginning-of-the-function\">Prefer one comment at the beginning of the function...</h4>\n<p>...which explains how the algorithm that is used works. Once more, if\nthere is no difficulty, there is no point in commenting.</p>\n<h4 id=\"avoid-nocuous-comments\">Avoid nocuous comments</h4>\n<p>A <em>nocuous</em> comment is a comment that does not add any value, i.e. no\nnon-trivial information. The nocuous comment is evidently not of\ninterest; it is a nuisance since it uselessly distracts the reader. It\nis often used to fulfill some strange criteria related to the so-called\n<em>software metrology</em>, for instance the ratio <em>number of comments</em> /\n<em>number of lines of code</em> that perfectly measures a ratio that I don't\nknow the theoretical or practical interpretation. Absolutely avoid\nnocuous comments.</p>\n<p>An example of what to avoid: the following comment uses technical words\nand is thus masquerade into a real comment when it has no additional\ninformation of interest;</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">(*\n  Function print_lambda:\n  print a lambda-expression given as argument.\n\n  Arguments: lam, any lambda-expression.\n  Returns: nothing.\n\n  Remark: print_lambda can only be used for its side effect.\n*)\nlet rec print_lambda lam =\n  match lam with\n  | Var s -&gt; printf &quot;%s&quot; s\n  | Abs l -&gt; printf &quot;\\\\ %a&quot; print_lambda l\n  | App (l1, l2) -&gt;\n     printf &quot;(%a %a)&quot; print_lambda l1 print_lambda l2\n</code></pre>\n<h4 id=\"usage-in-module-interface\">Usage in module interface</h4>\n<p>The function's usage must appear in the interface of the module which\nexports it, not in the program which implements it. Choose comments as\nin the OCaml system's interface modules, which will subsequently allow\nthe documentation of the interface module to be extracted automatically\nif need be.</p>\n<h4 id=\"use-assertions\">Use assertions</h4>\n<p>Use assertions as much as possible: they let you avoid verbose comments,\nwhile allowing a useful verification upon execution.</p>\n<p>For example, the conditions for the arguments of a function to be valid\nare usefully verified by assertions.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f x =\n  assert (x &gt;= 0);\n  ...\n</code></pre>\n<p>Note as well that an assertion is often preferable to a comment because\nit's more trustworthy: an assertion is forced to be pertinent because it\nis verified upon each execution, while a comment can quickly become\nobsolete and then becomes actually detrimental to the comprehension of\nthe program.</p>\n<h4 id=\"comments-line-by-line-in-imperative-code\">Comments line by line in imperative code</h4>\n<p>When writing difficult code, and particularly in case of highly\nimperative code with a lot of memory modifications (physical mutations\nin data structures), it is sometime mandatory to comment inside the body\nof functions to explain the implementation of the algorithm encoded\nhere, or to follow successive modifications of invariants that the\nfunction must maintain. Once more, if there is some difficulty\ncommenting is mandatory, for each program line if necessary.</p>\n<h3 id=\"how-to-choose-identifiers\">How to choose identifiers</h3>\n<p>It's hard to choose identifiers whose name evokes the meaning of the\ncorresponding portion of the program. This is why you must devote\nparticular care to this, emphasizing clarity and regularity of\nnomenclature.</p>\n<h4 id=\"dont-use-abbreviations-for-global-names\">Don't use abbreviations for global names</h4>\n<p>Global identifiers (including especially the names of functions) can be\nlong, because it's important to understand what purpose they serve far\nfrom their definition.</p>\n<h4 id=\"separate-words-by-underscores-intofstring-not-intofstring\">Separate words by underscores: (<code>int_of_string</code>, not <code>intOfString</code>)</h4>\n<p>Case modifications are meaningful in OCaml: in effect capitalized words\nare reserved for constructors and module names in OCaml; in contrast\nregular variables (functions or identifiers) must start by a lowercase\nletter. Those rules prevent proper usage of case modification for words\nseparation in identifiers: the first word starts the identifier, hence\nit must be lower case and it is forbidden to choose <code>IntOfString</code> as the\nname of a function.</p>\n<h4 id=\"always-give-the-same-name-to-function-arguments-which-have-the-same-meaning\">Always give the same name to function arguments which have the same meaning</h4>\n<p>If necessary, make this nomenclature explicit in a comment at the top of\nthe file); if there are several arguments with the same meaning then\nattach numeral suffixes to them.</p>\n<h4 id=\"local-identifiers-can-be-brief-and-should-be-reused-from-one-function-to-another\">Local identifiers can be brief, and should be reused from one function to another</h4>\n<p>This augments regularity of style. Avoid using identifiers whose\nappearance can lead to confusion such as <code>l</code> or <code>O</code>, easy to confuse\nwith <code>1</code> and <code>0</code>.</p>\n<p>Example:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let add_expression expr1 expr2 = ...\nlet print_expression expr = ...\n</code></pre>\n<p>An exception to the recommendation not to use capitalization to separate\nwords within identifiers is tolerated in the case of interfacing with\nexisting libraries which use this naming convention: this lets OCaml\nusers of the library to orient themselves in the original library\ndocumentation more easily.</p>\n<h3 id=\"when-to-use-parentheses-within-an-expression\">When to use parentheses within an expression</h3>\n<p>Parentheses are meaningful: they indicate the necessity of using an\nunusual precedence. So they should be used wisely and not sprinkled\nrandomly throughout programs. To this end, you should know the usual\nprecedences, that is, the combinations of operations which do not\nrequire parentheses. Quite fortunately this is not complicated if you\nknow a little mathematics or strive to follow the following rules:</p>\n<h4 id=\"arithmetic-operators-the-same-rules-as-in-mathematics\">Arithmetic operators: the same rules as in mathematics</h4>\n<p>For example: <code>1 + 2 * x</code> means <code>1 + (2 * x)</code>.</p>\n<h4 id=\"function-application-the-same-rules-as-those-in-mathematics-for-usage-of-trigonometric-functions\">Function application: the same rules as those in mathematics for usage of <em>trigonometric functions</em></h4>\n<p>In mathematics you write <code>sin x</code> to mean <code>sin (x)</code>. In the same way\n<code>sin x + cos x</code> means <code>(sin x) + (cos x)</code> not <code>sin (x + (cos x))</code>. Use\nthe same conventions in OCaml: write <code>f x + g x</code> to mean\n<code>(f x) + (g x)</code>.<br />\nThis convention generalizes <strong>to all (infix) operators</strong>: <code>f x :: g x</code>\nmeans <code>(f x) :: (g x)</code>, <code>f x @ g x</code> means <code>(f x) @ (g x)</code>, and\n<code>failwith s ^ s'</code> means <code>(failwith s) ^ s'</code>, <em>not</em> <code>failwith (s ^ s')</code>.</p>\n<h4 id=\"comparisons-and-boolean-operators\">Comparisons and boolean operators</h4>\n<p>Comparisons are infix operators, so the preceding rules apply. This is\nwhy <code>f x &lt; g x</code> means <code>(f x) &lt; (g x)</code>. For type reasons (no other\nsensible interpretation) the expression <code>f x &lt; x + 2</code> means\n<code>(f x) &lt; (x + 2)</code>. In the same way <code>f x &lt; x + 2 &amp;&amp; x &gt; 3</code> means\n<code>((f x) &lt; (x + 2)) &amp;&amp; (x &gt; 3)</code>.</p>\n<h4 id=\"the-relative-precedences-of-the-boolean-operators-are-those-of-mathematics\">The relative precedences of the boolean operators are those of mathematics</h4>\n<p>Although mathematicians have a tendency to overuse parens in this case,\nthe boolean “or” operator is analogous to addition and the “and”\nto multiplication. So, just as <code>1 + 2 * x</code> means <code>1 + (2 * x)</code>,\n<code>true || false &amp;&amp; x</code> means <code>true || (false &amp;&amp; x)</code>.</p>\n<h3 id=\"how-to-delimit-constructs-in-programs\">How to delimit constructs in programs</h3>\n<p>When it is necessary to delimit syntactic constructs in programs, use as\ndelimiters the keywords <code>begin</code> and <code>end</code> rather than parentheses.\nHowever using parentheses is acceptable if you do it in a consistent,\nthat is, systematic, way.</p>\n<p>This explicit delimiting of constructs essentially concerns\npattern-matching constructs or sequences embedded within\n<code>if then     else</code> constructs.</p>\n<h4 id=\"match-construct-in-a-match-construct\"><code>match</code> construct in a <code>match</code> construct</h4>\n<p>When a <code>match ... with</code> or <code>try ... with</code> construct appears in a\npattern-matching clause, it is absolutely necessary to delimit this\nembedded construct (otherwise subsequent clauses of the enclosing\npattern-matching construct will automatically be associated with the\nenclosed pattern-matching construct). For example:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">match x with\n| 1 -&gt;\n  begin match y with\n  | ...\n  end\n| 2 -&gt;\n...\n</code></pre>\n<h4 id=\"sequences-inside-branches-of-if\">Sequences inside branches of <code>if</code></h4>\n<p>In the same way, a sequence which appears in the <code>then</code> or <code>else</code> part\nof a conditional must be delimited:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">if cond then begin\n  e1;\n  e2\nend else begin\n  e3;\n  e4\nend\n</code></pre>\n<h3 id=\"how-to-use-modules\">How to use modules</h3>\n<h4 id=\"subdividing-into-modules\">Subdividing into modules</h4>\n<p>You must subdivide your programs into coherent modules.</p>\n<p>For each module, you must explicitly write an interface.</p>\n<p>For each interface, you must document the things defined by the module:\nfunctions, types, exceptions, etc.</p>\n<h4 id=\"opening-modules\">Opening modules</h4>\n<p>Avoid <code>open</code> directives, using instead the qualified identifier\nnotation. Thus you will prefer short but meaningful module names.</p>\n<blockquote>\n<p><strong>Justification</strong>: The use of unqualified identifiers is ambiguous and\ngives rise to difficult-to-detect semantic errors.</p>\n</blockquote>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let lim = String.length name - 1 in\n...\nlet lim = Array.length v - 1 in\n...\n... List.map succ ...\n... Array.map succ ...\n</code></pre>\n<h4 id=\"when-to-use-open-modules-rather-than-leaving-them-closed\">When to use open modules rather than leaving them closed</h4>\n<p>You can consider it normal to open a module which modifies the\nenvironment, and brings other versions of an important set of functions.\nFor example, the <code>Format</code> module provides automatically indented\nprinting. This module redefines the usual printing functions\n<code>print_string</code>, <code>print_int</code>, <code>print_float</code>, etc. So when you use\n<code>Format</code>, open it systematically at the top of the file.<br />\nIf you don't open <code>Format</code> you could miss the qualification of a\nprinting function, and this could be perfectly silent, since many of\n<code>Format</code>'s functions have a counterpart in the default environment\n(<code>Pervasives</code>). Mixing printing functions from <code>Format</code> and <code>Pervasives</code>\nleads to subtle bugs in the display, that are difficult to trace. For\ninstance:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f () =\n  Format.print_string &quot;Hello World!&quot;; print_newline ()\n</code></pre>\n<p>is bogus since it does not call <code>Format.print_newline</code> to flush the\npretty-printer queue and output <code>&quot;Hello World!&quot;</code>. Instead\n<code>&quot;Hello World!&quot;</code> is stuck into the pretty-printer queue, while\n<code>Pervasives.print_newline</code> outputs a carriage return on the standard\noutput ... If <code>Format</code> is printing on a file and standard output is the\nterminal, the user will have a bad time finding that a carriage return\nis missing in the file (and the display of material on the file is\nstrange, since boxes that should be closed by <code>Format.print_newline</code> are\nstill open), while a spurious carriage return appeared on the screen!</p>\n<p>For the same reason, open large libraries such as the one with\narbitrary-precision integers so as not to burden the program which uses\nthem.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">open Num\n\nlet rec fib n =\n  if n &lt;= 2 then Int 1 else fib (n - 1) +/ fib (n - 2)\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The program would be less readable if you had to\nqualify all the identifiers.</p>\n</blockquote>\n<p>In a program where type definitions are shared, it is good to gather\nthese definitions into one or more module(s) without implementations\n(containing only types). Then it's acceptable to systematically open the\nmodule which exports the shared type definitions.</p>\n<h3 id=\"pattern-matching\">Pattern-matching</h3>\n<h4 id=\"never-be-afraid-of-over-using-pattern-matching\">Never be afraid of over-using pattern-matching!</h4>\n<h4 id=\"on-the-other-hand-be-careful-to-avoid-non-exhaustive-pattern-matching-constructs\">On the other hand, be careful to avoid non-exhaustive pattern-matching constructs</h4>\n<p>Complete them with care, without using a “catch-all” clause such as\n<code>| _ -&gt; ...</code> or <code>| x -&gt; ...</code> when it's possible to do without it (for\nexample when matching a concrete type defined within the program). See\nalso the next section: compiler warnings.</p>\n<h3 id=\"compiler-warnings\">Compiler warnings</h3>\n<p>Compiler warnings are meant to prevent potential errors; this is why you\nabsolutely must heed them and correct your programs if compiling them\nproduces such warnings. Besides, programs whose compilation produces\nwarnings have an odor of amateurism which certainly doesn't suit your\nown work!</p>\n<h4 id=\"pattern-matching-warnings\">Pattern-matching warnings</h4>\n<p>Warnings about pattern-matching must be treated with the upmost care:</p>\n<ul>\n<li>\n<p>Those concerning useless clauses should of course be eliminated.</p>\n</li>\n<li>\n<p>For non-exhaustive pattern-matching you must complete the\ncorresponding pattern-matching construct, without adding a default\ncase “catch-all”, such as <code>| _ -&gt; ... </code>, but with an explicit\nlist of the constructors not examined by the rest of the construct,\nfor example <code>| Cn _ | Cn1 _ -&gt; ... </code>.</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>Justification</strong>: It's not really any more complicated to write\nit this way, and this allows the program to evolve more safely. In\neffect the addition of a new constructor to the datatype being\nmatched will produce an alert anew, which will allow the\nprogrammer to add a clause corresponding to the new constructor if\nthat is warranted. On the contrary, the “catch-all” clause\nwill make the function compile silently and it might be thought\nthat the function is correct as the new constructor will be\nhandled by the default case.</p>\n</blockquote>\n<ul>\n<li>Non-exhaustive pattern-matches induced by clauses with guards must\nalso be corrected. A typical case consists in suppressing a\nredundant guard.\n</li>\n</ul>\n<h4 id=\"de-structuring-let-bindings\">De-structuring <code>let</code> bindings</h4>\n<p>[Translator's note: a “de-structuring <code>let</code> binding” is one which\nbinds several names to several expressions simultaneously. You pack all\nthe names you want bound into a collection such as a tuple or a list,\nand you correspondingly pack all the expressions into a collective\nexpression. When the <code>let</code> binding is evaluated, it unpacks the\ncollections on both sides and binds each expression to its corresponding\nname. For example, <code>let x, y = 1, 2</code> is a de-structuring <code>let</code> binding\nwhich performs both the bindings <code>let x = 1</code> and <code>let y = 2</code>\nsimultaneously.]<br />\nThe <code>let</code> binding is not limited to simple identifier definitions: you\ncan use it with more complex or simpler patterns. For instance</p>\n<ul>\n<li><code>let</code> with complex patterns:<br />\n<code>let [x; y] as l = ...</code><br />\nsimultaneously defines a list <code>l</code> and its two elements <code>x</code> and <code>y</code>.\n</li>\n<li><code>let</code> with simple pattern:<br />\n<code>let _ = ...</code> does not define anything, it just evaluate the\nexpression on the right hand side of the <code>=</code> symbol.\n</li>\n</ul>\n<h4 id=\"the-de-structuring-let-must-be-exhaustive\">The de-structuring <code>let</code> must be exhaustive</h4>\n<p>Only use de-structuring <code>let</code> bindings in the case where the\npattern-matching is exhaustive (the pattern can never fail to match).\nTypically, you will thus be limited to definitions of product types\n(tuples or records) or definitions of variant type with a single case.\nIn any other case, you should use an explicit <code>match   ... with</code>\nconstruct.</p>\n<ul>\n<li><code>let ... in</code>: de-structuring <code>let</code> that give a warning must be\nreplaced by an explicit pattern matching. For instance, instead of\n<code>let [x; y] as l = List.map succ     (l1 @ l2) in expression</code> write:\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">match List.map succ (l1 @ l2) with\n| [x; y] as l -&gt; expression\n| _ -&gt; assert false\n</code></pre>\n<ul>\n<li>Global definition with de-structuring lets should be rewritten with\nexplicit pattern matching and tuples:\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let x, y, l =\n  match List.map succ (l1 @ l2) with\n  | [x; y] as l -&gt; x, y, l\n  | _ -&gt; assert false\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: There is no way to make the pattern-matching\nexhaustive if you use general de-structuring <code>let</code> bindings.</p>\n</blockquote>\n<h4 id=\"sequence-warnings-and-let---\">Sequence warnings and <code>let _ = ...</code></h4>\n<p>When the compiler emits a warning about the type of an expression in a\nsequence, you have to explicitly indicate that you want to ignore the\nresult of this expression. To this end:</p>\n<ul>\n<li>use a vacuous binding and suppress the sequence warning of\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">List.map f l;\nprint_newline ()\n</code></pre>\n<p>write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let _ = List.map f l in\nprint_newline ()\n</code></pre>\n<ul>\n<li>you can also use the predefined function <code>ignore : 'a     -&gt; unit</code>\nthat ignores its argument to return <code>unit</code>.\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">ignore (List.map f l);\nprint_newline ()\n</code></pre>\n<ul>\n<li>In any case, the best way to suppress this warning is to understand\nwhy it is emitted by the compiler: the compiler warns you because\nyour code computes a result that is useless since this result is\njust deleted after computation. Hence, if useful at all, this\ncomputation is performed only for its side-effects; hence it should\nreturn unit.<br />\nMost of the time, the warning indicates the use of the wrong\nfunction, a probable confusion between the side-effect only version\nof a function (which is a procedure whose result is irrelevant) with\nits functional counterpart (whose result is meaningful).<br />\nIn the example mentioned above, the first situation prevailed, and\nthe programmer should have called <code>iter</code> instead of <code>map</code>, and\nsimply write\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">List.iter f l;\nprint_newline ()\n</code></pre>\n<p>In actual programs, the suitable (side-effect only) function may not\nexist and has to be written: very often, a careful separation of the\nprocedural part from the functional part of the function at hand\nelegantly solves the problem, and the resulting program just looks\nbetter afterwards! For instance, you would turn the problematic\ndefinition:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let add x y =\n  if x &gt; 1 then print_int x;\n  print_newline ();\n  x + y;;\n</code></pre>\n<p>into the clearer separate definitions and change old calls to <code>add</code>\naccordingly.</p>\n<p>In any case, use the <code>let _ = ...</code> construction exactly in those cases\nwhere you want to ignore a result. Don't systematically replace\nsequences with this construction.</p>\n<blockquote>\n<p><strong>Justification</strong>: Sequences are much clearer! Compare <code>e1; e2; e3</code> to</p>\n<pre><code class=\"language-ocaml\">let _ = e1 in\nlet _ = e2 in\ne3\n</code></pre>\n</blockquote>\n<h3 id=\"the-hd-and-tl-functions\">The <code>hd</code> and <code>tl</code> functions</h3>\n<p>Don't use the <code>hd</code> and <code>tl</code> functions, but pattern-match the list\nargument explicitly.</p>\n<blockquote>\n<p><strong>Justification</strong>: This is just as brief as and much clearer than\nusing <code>hd</code> and <code>tl</code> which must of necessity be protected by\n<code>try... with...</code> to catch the exception which might be raised by these\nfunctions.</p>\n</blockquote>\n<h3 id=\"loops\">Loops</h3>\n<h4 id=\"for-loops\"><code>for</code> loops</h4>\n<p>To simply traverse an array or a string, use a <code>for</code> loop.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">for i = 0 to Array.length v - 1 do\n  ...\ndone\n</code></pre>\n<p>If the loop is complex or returns a result, use a recursive function.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let find_index e v =\n  let rec loop i =\n    if i &gt;= Array.length v then raise Not_found else\n    if v.(i) = e then i else loop (i + 1) in\n  loop 0;;\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The recursive function lets you code any loop\nwhatsoever simply, even a complex one, for example with multiple exit\npoints or with strange index steps (steps depending on a data value\nfor example).</p>\n<p>Besides, the recursive loop avoids the use of mutables whose value can\nbe modified in any part of the body of the loop whatsoever (or even\noutside): on the contrary the recursive loop explicitly takes as\narguments the values susceptible to change during the recursive calls.</p>\n</blockquote>\n<h4 id=\"while-loops\"><code>while</code> loops</h4>\n<blockquote>\n<p><strong>While loops law</strong>: Beware: usually a while loop is wrong, unless its\nloop invariant has been explicitly written.</p>\n</blockquote>\n<p>The main use of the <code>while</code> loop is the infinite loop\n<code>while true do     ...</code>. You get out of it through an exception,\ngenerally on termination of the program.</p>\n<p>Other <code>while</code> loops are hard to use, unless they come from canned\nprograms from algorithms courses where they were proved.</p>\n<blockquote>\n<p><strong>Justification</strong>: <code>while</code> loops require one or more mutables in order\nthat the loop condition change value and the loop finally terminate.\nTo prove their correctness, you must therefore discover the loop\ninvariants, an interesting but difficult sport.</p>\n</blockquote>\n<h3 id=\"exceptions\">Exceptions</h3>\n<p>Don't be afraid to define your own exceptions in your programs, but on\nthe other hand use as much as possible the exceptions predefined by the\nsystem. For example, every search function which fails should raise the\npredefined exception <code>Not_found</code>. Be careful to handle the exceptions\nwhich may be raised by a function call with the help of a\n<code>try ... with</code>.</p>\n<p>Handling all exceptions by <code>try     ... with _ -&gt;</code> is usually reserved\nfor the main function of the program. If you need to catch all\nexceptions to maintain an invariant of an algorithm, be careful to name\nthe exception and re-raise it, after having reset the invariant.\nTypically:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let ic = open_in ...\nand oc = open_out ... in\ntry\n  treatment ic oc;\n  close_in ic; close_out oc\nwith x -&gt; close_in ic; close_out oc; raise x\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: <code>try ... with _     -&gt;</code> silently catches all\nexceptions, even those which have nothing to do with the computation\nat hand (for example an interruption will be captured and the\ncomputation will continue anyway!).</p>\n</blockquote>\n<h3 id=\"data-structures\">Data structures</h3>\n<p>One of the great strengths of OCaml is the power of the data structures\nwhich can be defined and the simplicity of manipulating them. So you\nmust take advantage of this to the fullest extent; don't hesitate to\ndefine your own data structures. In particular, don't systematically\nrepresent enumerations by whole numbers, nor enumerations with two cases\nby booleans. Examples:</p>\n<pre><code class=\"language-ocaml\">type figure =\n   | Triangle | Square | Circle | Parallelogram\ntype convexity =\n   | Convex | Concave | Other\ntype type_of_definition =\n   | Recursive | Non_recursive\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: A boolean value often prevents intuitive\nunderstanding of the corresponding code. For example, if\n<code>type_of_definition</code> is coded by a boolean, what does <code>true</code> signify?\nA “normal” definition (that is, non-recursive) or a recursive\ndefinition?</p>\n<p>In the case of an enumerated type encode by an integer, it is very\ndifficult to limit the range of acceptable integers: one must define\nconstruction functions that will ensure the mandatory invariants of\nthe program (and verify afterwards that no values has been built\ndirectly), or add assertions in the program and guards in pattern\nmatchings. This is not good practice, when the definition of a sum\ntype elegantly solves this problem, with the additional benefit of\nfiring the full power of pattern matching and compiler's verifications\nof exhaustiveness.</p>\n<p><strong>Criticism</strong>: For binary enumerations, one can systematically define\npredicates whose names carry the semantics of the boolean that\nimplements the type. For instance, we can adopt the convention that a\npredicate ends by the letter <code>p</code>. Then, in place of defining a new sum\ntype for <code>type_of_definition</code>, we will use a predicate function\n<code>recursivep</code> that returns true if the definition is recursive.</p>\n<p><strong>Answer</strong>: This method is specific to binary enumeration and cannot\nbe easily extended; moreover it is not well suited to pattern\nmatching. For instance, for definitions encoded by\n<code>| Let of bool * string * expression</code> a typical pattern matching would\nlook like:</p>\n<pre><code class=\"language-ocaml\">| Let (_, v, e) as def -&gt;\n   if recursivep def then code_for_recursive_case\n   else code_for_non_recursive_case\n</code></pre>\n<p>or, if <code>recursivep</code> can be applied to booleans:</p>\n<pre><code class=\"language-ocaml\">| Let (b, v, e) -&gt;\n   if recursivep b then code_for_recursive_case\n   else code_for_non_recursive_case\n</code></pre>\n<p>contrast with an explicit encoding:</p>\n<pre><code class=\"language-ocaml\">| Let (Recursive, v, e) -&gt; code_for_recursive_case\n| Let (Non_recursive, v, e) -&gt; code_for_non_recursive_case\n</code></pre>\n<p>The difference between the two programs is subtle and you may think\nthat this is just a matter of taste; however the explicit encoding is\ndefinitively more robust to modifications and fits better with the\nlanguage.</p>\n</blockquote>\n<p><em>A contrario</em>, it is not necessary to systematically define new types\nfor boolean flags, when the interpretation of constructors <code>true</code> and\n<code>false</code> is clear. The usefulness of the definition of the following\ntypes is then questionable:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">type switch = On | Off\ntype bit = One | Zero\n</code></pre>\n<p>The same objection is admissible for enumerated types represented as\nintegers, when those integers have an evident interpretation with\nrespect to the data to be represented.</p>\n<h3 id=\"when-to-use-mutables\">When to use mutables</h3>\n<p>Mutable values are useful and sometimes indispensable to simple and\nclear programming. Nevertheless, you must use them with discernment:\nOCaml's normal data structures are immutable. They are to be preferred\nfor the clarity and safety of programming which they allow.</p>\n<h3 id=\"iterators\">Iterators</h3>\n<p>OCaml's iterators are a powerful and useful feature. However you should\nnot overuse them, nor <em>a contrario</em> neglect them: they are provided to\nyou by libraries and have every chance of being correct and\nwell-thought-out by the author of the library. So it's useless to\nreinvent them.</p>\n<p>So write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let square_elements elements = List.map square elements\n</code></pre>\n<p>rather than:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec square_elements = function\n  | [] -&gt; []\n  | elem :: elements -&gt; square elem :: square_elements elements\n</code></pre>\n<p>On the other hand avoid writing:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let iterator f x l =\n  List.fold_right (List.fold_left f) [List.map x l] l\n</code></pre>\n<p>even though you get:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">  let iterator f x l =\n    List.fold_right (List.fold_left f) [List.map x l] l;;\n  iterator (fun l x -&gt; x :: l) (fun l -&gt; List.rev l) [[1; 2; 3]]\n</code></pre>\n<p>In case of express need, you must be careful to add an explanatory\ncomment: in my opinion it's absolutely necessary!</p>\n<h3 id=\"how-to-optimize-programs\">How to optimize programs</h3>\n<blockquote>\n<p><strong>Pseudo law of optimization</strong>: No optimization <em>a priori</em>.<br />\nNo optimization <em>a posteriori</em> either.</p>\n</blockquote>\n<p>Above all program simply and clearly. Don't start optimizing until the\nprogram bottleneck has been identified (in general a few routines). Then\noptimization consists above all of changing <em>the complexity</em> of the\nalgorithm used. This often happens through redefining the data\nstructures being manipulated and completely rewriting the part of the\nprogram which poses a problem.</p>\n<blockquote>\n<p><strong>Justification</strong>: Clarity and correctness of programs take\nprecedence. Besides, in a substantial program, it is practically\nimpossible to identify <em>a priori</em> the parts of the program whose\nefficiency is of prime importance.</p>\n</blockquote>\n<h3 id=\"how-to-choose-between-classes-and-modules\">How to choose between classes and modules</h3>\n<p>You should use OCaml classes when you need inheritance, that is,\nincremental refinement of data and their functionality.</p>\n<p>You should use conventional data structures (in particular, variant\ntypes) when you need pattern-matching.</p>\n<p>You should use modules when the data structures are fixed and their\nfunctionality is equally fixed or it's enough to add new functions in\nthe programs which use them.</p>\n<h3 id=\"clarity-of-ocaml-code\">Clarity of OCaml code</h3>\n<p>The OCaml language includes powerful constructs which allow simple and\nclear programming. The main problem to obtain crystal clear programs it\nto use them appropriately.</p>\n<p>The language features numerous programming styles (or programming\nparadigms): imperative programming (based on the notion of state and\nassignment), functional programming (based on the notion of function,\nfunction results, and calculus), object oriented programming (based of\nthe notion of objects encapsulating a state and some procedures or\nmethods that can modify the state). The first work of the programmer is\nto choose the programming paradigm that fits the best the problem at\nhand. When using one of those programming paradigms, the difficulty is\nto use the language construct that expresses in the most natural and\neasiest way the computation that implements the algorithm.</p>\n<h4 id=\"style-dangers\">Style dangers</h4>\n<p>Concerning programming styles, one can usually observe the two\nsymmetrical problematic behaviors: on the one hand, the “all\nimperative” way (<em>systematic</em> usage of loops and assignment), and on\nthe other hand the “purely functional” way (<em>never</em> use loops nor\nassignments); the “100% object” style will certainly appear in the\nnext future, but (fortunately) it is too new to be discussed here.</p>\n<ul>\n<li><strong>The “Too much imperative” danger</strong>:\n<ul>\n<li>It is a bad idea to use imperative style to code a function that\nis <em>naturally</em> recursive. For instance, to compute the length of\na list, you should not write:\n</li>\n</ul>\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let list_length l =\n  let l = ref l in\n  let res = ref 0 in\n  while !l &lt;&gt; [] do\n    incr res; l := List.tl !l\n  done;\n  !res;;\n</code></pre>\n<p>in place of the following recursive function, so simple and\nclear:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec list_length = function\n  | [] -&gt; 0\n  | _ :: l -&gt; 1 + list_length l\n</code></pre>\n<p>(For those that would contest the equivalence of those two\nversions, see the <a href=\"#Imperativeandfunctionalversionsoflistlength\">note below</a>).</p>\n<ul>\n<li>\n<p>Another common “over imperative error” in the imperative world is\nnot to systematically choose the simple <code>for</code> loop to iter on the\nelement of a vector, but instead to use a complex <code>while</code> loop, with\none or two references (too many useless assignments, too many\nopportunity for errors).</p>\n</li>\n<li>\n<p>This category of programmer feels that the <code>mutable</code> keyword in\nthe record type definitions should be implicit.</p>\n</li>\n<li>\n<p><strong>The “Too much functional” danger</strong>:</p>\n<ul>\n<li>The programmer that adheres to this dogma avoids\nusing arrays and assignment. In the most severe case, one\nobserves a complete denial of writing any imperative\nconstruction, even in case it is evidently the most elegant way\nto solve the problem.\n</li>\n<li>Characteristic symptoms: systematic rewriting of <code>for</code> loops\nwith recursive functions, usage of lists in contexts where\nimperative data structures seem to be mandatory to anyone,\npassing numerous global parameters of the problem to every\nfunctions, even if a global reference would be perfect to avoid\nthese spurious parameters that are mainly invariants that must\nbe passed all over the place.\n</li>\n<li>This programmer feels that the <code>mutable</code> keyword in the record\ntype definitions should be suppressed from the language.\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ocaml-code-generally-considered-unreadable\">OCaml code generally considered unreadable</h4>\n<p>The OCaml language includes powerful constructs which allow simple and\nclear programming. However the power of these constructs also lets you\nwrite uselessly complicated code, to the point where you get a perfectly\nunreadable program.</p>\n<p>Here are a number of known ways:</p>\n<ul>\n<li>Use useless (hence novice for readability) <code>if then else</code>, as in\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let flush_ps () =\n  if not !psused then psused := true\n</code></pre>\n<p>or (more subtle)</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let sync b =\n  if !last_is_dvi &lt;&gt; b then last_is_dvi := b\n</code></pre>\n<ul>\n<li>Code one construct with another. For example code a <code>let ... in</code> by\nthe application of an anonymous function to an argument. You would\nwrite<br />\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">(fun x y -&gt; x + y)\n   e1 e2\n</code></pre>\n<p>instead of simply writing</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let x = e1\nand y = e2 in\nx + y\n</code></pre>\n<ul>\n<li>\n<p>Systematically code sequences with <code>let in</code> bindings.</p>\n</li>\n<li>\n<p>Mix computations and side effects, particularly in function calls.\nRecall that the order of evaluation of arguments in a function call\nis unspecified, which implies that you must not mix side effects and\ncomputations in function calls. However, when there is only one\nargument you might take advantage of this to perform a side effect\nwithin the argument, which is extremely troublesome for the reader\nalbeit without danger to the program semantics. To be absolutely\nforbidden.</p>\n</li>\n<li>\n<p>Misuse of iterators and higher-order functions (i.e. over- or\nunder-use). For example it's better to use <code>List.map</code> or\n<code>List.iter</code> than to write their equivalents in-line using specific\nrecursive functions of your own. Even worse, you don't use\n<code>List.map</code> or <code>List.iter</code> but write their equivalents in terms of\n<code>List.fold_right</code> and <code>List.fold_left</code>.</p>\n</li>\n<li>\n<p>Another efficient way to write unreadable code is to mix all or some\nof these methods. For example:</p>\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">(fun u -&gt; print_string &quot;world&quot;; print_string u)\n  (let temp = print_string &quot;Hello&quot;; &quot;!&quot; in\n   ((fun x -&gt; print_string x; flush stdout) &quot; &quot;;\n    temp));;\n</code></pre>\n<p>If you naturally write the program <code>print_string &quot;Hello world!&quot;</code> in this\nway, you can without a doubt submit your work to the <a href=\"mailto:Pierre.Weis@inria.fr\">Obfuscated OCaml\nContest</a>.</p>\n<h2 id=\"managing-program-development\">Managing program development</h2>\n<p>We give here tips from veteran OCaml programmers, which have served in\ndeveloping the compilers which are good examples of large complex\nprograms developed by small teams.</p>\n<h3 id=\"how-to-edit-programs\">How to edit programs</h3>\n<p>Many developers nurture a kind of veneration towards the Emacs editor\n(gnu-emacs in general) which they use to write their programs. The\neditor interfaces well with the language since it is capable of syntax\ncoloring OCaml source code (rendering different categories of words in\ncolor, coloring keywords for example).</p>\n<p>The following two commands are considered indispensable:</p>\n<ul>\n<li><code>CTRL-C-CTRL-C</code> or <code>Meta-X compile</code>: launches re-compilation from\nwithin the editor (using the <code>make</code> command).\n</li>\n<li><code>CTRL-X-`</code>: puts the cursor in the file and at the exact place\nwhere the OCaml compiler has signaled an error.\n</li>\n</ul>\n<p>Developers describe thus how to use these features: <code>CTRL-C-CTRL-C</code>\ncombination recompiles the whole application; in case of errors, a\nsuccession of <code>CTRL-X-`</code> commands permits correction of all the\nerrors signaled; the cycle begins again with a new re-compilation\nlaunched by <code>CTRL-C-CTRL-C</code>.</p>\n<h4 id=\"other-emacs-tricks\">Other emacs tricks</h4>\n<p>The <code>ESC-/</code> command (dynamic-abbrev-expand) automatically completes the\nword in front of the cursor with one of the words present in one of the\nfiles being edited. Thus this lets you always choose meaningful\nidentifiers without the tedium of having to type extended names in your\nprograms: the <code>ESC-/</code> easily completes the identifier after typing the\nfirst letters. In case it brings up the wrong completion, each\nsubsequent <code>ESC-/</code> proposes an alternate completion.</p>\n<p>Under Unix, the <code>CTRL-C-CTRL-C</code> or <code>Meta-X     compile</code> combination,\nfollowed by <code>CTRL-X-`</code> is also used to find all occurrences of a\ncertain string in a OCaml program. Instead of launching <code>make</code> to\nrecompile, you launch the <code>grep</code> command; then all the “error\nmessages” from <code>grep</code> are compatible with the <code>CTRL-X-`</code> usage\nwhich automatically takes you to the file and the place where the string\nis found.</p>\n<h3 id=\"how-to-edit-with-the-interactive-system\">How to edit with the interactive system</h3>\n<p>Under Unix: use the line editor <code>ledit</code> which offers great editing\ncapabilities “à la emacs” (including <code>ESC-/</code>!), as well as a history\nmechanism which lets you retrieve previously typed commands and even\nretrieve commands from one session in another. <code>ledit</code> is written in\nOCaml and can be freely down-loaded\n<a href=\"ftp://ftp.inria.fr/INRIA/Projects/cristal/caml-light/bazar-ocaml/ledit.tar.gz\">here</a>.</p>\n<h3 id=\"how-to-compile\">How to compile</h3>\n<p>The <code>make</code> utility is indispensable for managing the compilation and\nre-compilation of programs. Sample <code>make</code> files can be found on <a href=\"https://caml.inria.fr//cgi-bin/hump.en.cgi\">The\nHump</a>. You can also consult\nthe <code>Makefiles</code> for the OCaml compilers.</p>\n<h3 id=\"how-to-develop-as-a-team-version-control\">How to develop as a team: version control</h3>\n<p>Users of the <a href=\"https://git-scm.com/\">Git</a> software version control system\nnever run out of good things to say about the productivity gains it\nbrings. This system supports managing development by a team of\nprogrammers while imposing consistency among them, and also maintains a\nlog of changes made to the software.<br />\nGit also supports simultaneous development by several teams, possibly\ndispersed among several sites linked on the Net.</p>\n<p>An anonymous Git read-only mirror <a href=\"https://github.com/ocaml/ocaml\">contains the working sources of the\nOCaml compilers</a>, and the sources of\nother software related to OCaml.</p>\n<h2 id=\"notes\">Notes</h2>\n<h3 id=\"imperative-and-functional-versions-of-listlength\">Imperative and functional versions of <code>list_length</code></h3>\n<p>The two versions of <code>list_length</code> are not completely equivalent in term\nof complexity, since the imperative version uses a constant amount of\nstack room to execute, whereas the functional version needs to store\nreturn addresses of suspended recursive calls (whose maximum number is\nequal to the length of the list argument). If you want to retrieve a\nconstant space requirement to run the functional program you just have\nto write a function that is recursive in its tail (or <em>tail-rec</em>), that\nis a function that just ends by a recursive call (which is not the case\nhere since a call to <code>+</code> has to be perform after the recursive call has\nreturned). Just use an accumulator for intermediate results, as in:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let list_length l =\n  let rec loop accu = function\n    | [] -&gt; accu\n    | _ :: l -&gt; loop (accu + 1) l in\n  loop 0 l\n</code></pre>\n<p>This way, you get a program that has the same computational properties\nas the imperative program with the additional clarity and natural\nlook of an algorithm that performs pattern matching and recursive\ncalls to handle an argument that belongs to a recursive sum data type.</p>\n"},{"title":"Compiling OCaml Projects","slug":"compiling-ocaml-projects","description":"An introduction to the OCaml compiler tools for building OCaml projects as well as the most common build tools\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"getting-started","tl":0},"users":{"hd":"Intermediate","tl":0},"body_md":"\nThis tutorial explains how to compile your OCaml programs into executable form.\nIt addresses, in turn:\n\n1. The compilation commands `ocamlc` and `ocamlopt` provided with OCaml. It is\n   useful to learn these commands to understand OCaml's compilation model.\n\n1. The `ocamlfind` front-end to the compiler, which saves you from worrying\n   about where libraries have been installed on your particular system. \n\n1. Automatic build systems for OCaml, such as `dune`, which release us from\n   details of compiler command invocation, so we never touch `ocamlc`,\n   `ocamlopt`, or even `ocamlfind`.\n\nIn our [up and running tutorial](up_and_running.html) we jumped straight to using\nthe automated build system `dune`. Now we shall look under the hood.\n\n## Compilation basics\n\nIn this section, we will first see how to compile a simple program using\nonly `ocamlc` or `ocamlopt`. Then we will see how to use libraries and how\nto take advantage of the\n[findlib](https://projects.camlcity.org/projects/findlib.html)\nsystem, which provides the `ocamlfind` command.\n\n### The ocamlc and ocamlopt compilers\n\nOCaml comes with two compilers: `ocamlc` is the bytecode compiler, and\n`ocamlopt` is the native code compiler. If you don't know which one to use, use\n`ocamlopt` since it provides executables that are faster than bytecode.\n\nLet's assume that our program `program` has two source files,\n`module1.ml` and `module2.ml`. We will compile them to native code,\nusing `ocamlopt`. For now, we also assume that they do not use any other\nlibrary than the standard library, which is automatically loaded. You\ncan compile the program in one single step:\n\n```shell\nocamlopt -o program module1.ml module2.ml\n```\n\nThe compiler produces an executable named `program` or `program.exe`. The order\nof the source files matters, and so `module1.ml` cannot depend upon things that\nare defined in `module2.ml`.\n\nThe OCaml distribution is shipped with the standard library, plus several other\nlibraries. There are also a large number of third-party libraries, for a wide\nrange of applications, from networking to graphics. You should understand the\nfollowing:\n\n1. The OCaml compilers know where the standard library is and use it\n   systematically (try: `ocamlc -where`). You don't have to worry much about\n   it.\n\n1. The other libraries that ship with the OCaml distribution (str, unix, etc.)\n   are installed in the same directory as the standard library.\n\n1. Third-party libraries may be installed in various places, and even a given\n   library can be installed in different places from one system to another.\n\nIf your program uses the unix library in addition to the standard library, for\nexample, the command line would be:\n\n```shell\nocamlopt -o program unix.cmxa module1.ml module2.ml\n```\n\nNote that `.cmxa` is the extension of native code libraries, while `.cma` is\nthe extension of bytecode libraries. The file `unix.cmxa` is found because it\nis always installed at the same place as the standard library, and this\ndirectory is in the library search path.\n\nIf your program depends upon third-party libraries, you must pass them on the\ncommand line. You must also indicate the libraries on which these libraries\ndepend. You must also pass the -I option to `ocamlopt` for each directory where\nthey may be found. This becomes complicated, and this information is\ninstallation dependent. So we will use `ocamlfind` instead, which does these\njobs for us.\n\n###  Using the ocamlfind front-end\n\nThe `ocamlfind` front-end is often used for compiling programs that use\nthird-party OCaml libraries. Library authors themselves make their library\ninstallable with `ocamlfind` as well. You can install `ocamlfind` using the\nopam package manager, by typing `opam install ocamlfind`.\n\nLet's assume that all the libraries you want to use have been installed\nproperly with ocamlfind. You can see which libraries are available in your\nsystem by typing:\n\n```shell\nocamlfind list\n```\n\nThis shows the list of package names, with their versions. Note that most\nopam packages install software using ocamlfind, so your list of ocamlfind\nlibraries will be somewhat similar to your list of installed opam packages\nobtained by `opam list`.\n\nThe command for compiling our program using package `pkg` will be:\n\n```shell\nocamlfind ocamlopt -o program -linkpkg -package pkg module1.ml module2.ml\n```\n\nMultiple packages may be specified using commas e.g `pkg1,pkg2`. Ocamlfind\nknows how to find any files `ocamlopt` may need from the package, for example\n`.cmxa` implementation files or `.cmi` interface files, because they have been\npackaged together and installed at a known location by ocamlfind. We need only\nthe name `pkg` to refer to them all - ocamlfind does the rest.\n\nNote that you can compile the files separately. This is useful if\nyou want to recompile only some parts of the programs. Here are the\nequivalent commands that perform a separate compilation of the source\nfiles and link them together in a final step:\n\n```shell\nocamlfind ocamlopt -c -package pkg module1.ml\nocamlfind ocamlopt -c -package pkg module2.ml\nocamlfind ocamlopt -o program -linkpkg -package pkg module1.cmx module2.cmx\n```\n\nSeparate compilation (one command for `module1.ml`, another for `module2.ml`\nand another to link the final output) is usually not performed manually but\nonly when using an automated build system that will take care of recompiling\nonly what it necessary.\n\n## Interlude: making a custom toplevel\n\nOCaml provides another tool `ocamlmktop` to make an interactive toplevel with\nlibraries accessible. For example:\n\n```shell\nocamlmktop -o toplevel unix.cma module1.ml module2.ml\n```\n\nWe run `toplevel` and get an OCaml toplevel with modules `Unix`, `Module1`, and\n`Module2` all available, allowing us to experiment interactively with our\nprogram.\n\nOCamlfind also supports `ocamlmktop`:\n\n```shell\nocamlfind ocamlmktop -o toplevel unix.cma -package pkg module1.ml module2.ml\n```\n\n## Dune: an automated build system\n\nThe most popular modern system for building OCaml projects is\n[dune](https://dune.readthedocs.io/en/stable/) which may be installed with\n`opam install dune`. It allows one to build OCaml projects from a simple\ndescription of their elements. For example, the dune file for our project might\nlook like this:\n\n```scheme\n;; our example project\n(executable\n  (name program)\n  (libraries unix pkg))\n```\n\nThe dune [quick-start\nguide](https://dune.readthedocs.io/en/latest/quick-start.html) shows you how to\nwrite such description files for more complicated situations, and how to\nstructure, build, and run dune projects. \n\n## Other build systems\n\n- [OMake](https://github.com/ocaml-omake/omake) Another OCaml build system.\n- [GNU make](https://www.gnu.org/software/make/) GNU make can build anything, including OCaml. May be used in conjunction with [OCamlmakefile](https://github.com/mmottl/ocaml-makefile)\n- [Oasis](https://github.com/ocaml/oasis) Generates a configure, build, and install system from a specification.\n","toc_html":"<ul>\n<li><ul>\n<li><a href=\"#compilation-basics\">Compilation basics</a>\n</li>\n<li><a href=\"#interlude-making-a-custom-toplevel\">Interlude: making a custom toplevel</a>\n</li>\n<li><a href=\"#dune-an-automated-build-system\">Dune: an automated build system</a>\n</li>\n<li><a href=\"#other-build-systems\">Other build systems</a>\n</li>\n</ul>\n</li>\n</ul>\n","body_html":"<p>This tutorial explains how to compile your OCaml programs into executable form.\nIt addresses, in turn:</p>\n<ol>\n<li>\n<p>The compilation commands <code>ocamlc</code> and <code>ocamlopt</code> provided with OCaml. It is\nuseful to learn these commands to understand OCaml's compilation model.</p>\n</li>\n<li>\n<p>The <code>ocamlfind</code> front-end to the compiler, which saves you from worrying\nabout where libraries have been installed on your particular system.</p>\n</li>\n<li>\n<p>Automatic build systems for OCaml, such as <code>dune</code>, which release us from\ndetails of compiler command invocation, so we never touch <code>ocamlc</code>,\n<code>ocamlopt</code>, or even <code>ocamlfind</code>.</p>\n</li>\n</ol>\n<p>In our <a href=\"up_and_running.html\">up and running tutorial</a> we jumped straight to using\nthe automated build system <code>dune</code>. Now we shall look under the hood.</p>\n<h2 id=\"compilation-basics\">Compilation basics</h2>\n<p>In this section, we will first see how to compile a simple program using\nonly <code>ocamlc</code> or <code>ocamlopt</code>. Then we will see how to use libraries and how\nto take advantage of the\n<a href=\"https://projects.camlcity.org/projects/findlib.html\">findlib</a>\nsystem, which provides the <code>ocamlfind</code> command.</p>\n<h3 id=\"the-ocamlc-and-ocamlopt-compilers\">The ocamlc and ocamlopt compilers</h3>\n<p>OCaml comes with two compilers: <code>ocamlc</code> is the bytecode compiler, and\n<code>ocamlopt</code> is the native code compiler. If you don't know which one to use, use\n<code>ocamlopt</code> since it provides executables that are faster than bytecode.</p>\n<p>Let's assume that our program <code>program</code> has two source files,\n<code>module1.ml</code> and <code>module2.ml</code>. We will compile them to native code,\nusing <code>ocamlopt</code>. For now, we also assume that they do not use any other\nlibrary than the standard library, which is automatically loaded. You\ncan compile the program in one single step:</p>\n<pre><code class=\"language-shell\">ocamlopt -o program module1.ml module2.ml\n</code></pre>\n<p>The compiler produces an executable named <code>program</code> or <code>program.exe</code>. The order\nof the source files matters, and so <code>module1.ml</code> cannot depend upon things that\nare defined in <code>module2.ml</code>.</p>\n<p>The OCaml distribution is shipped with the standard library, plus several other\nlibraries. There are also a large number of third-party libraries, for a wide\nrange of applications, from networking to graphics. You should understand the\nfollowing:</p>\n<ol>\n<li>\n<p>The OCaml compilers know where the standard library is and use it\nsystematically (try: <code>ocamlc -where</code>). You don't have to worry much about\nit.</p>\n</li>\n<li>\n<p>The other libraries that ship with the OCaml distribution (str, unix, etc.)\nare installed in the same directory as the standard library.</p>\n</li>\n<li>\n<p>Third-party libraries may be installed in various places, and even a given\nlibrary can be installed in different places from one system to another.</p>\n</li>\n</ol>\n<p>If your program uses the unix library in addition to the standard library, for\nexample, the command line would be:</p>\n<pre><code class=\"language-shell\">ocamlopt -o program unix.cmxa module1.ml module2.ml\n</code></pre>\n<p>Note that <code>.cmxa</code> is the extension of native code libraries, while <code>.cma</code> is\nthe extension of bytecode libraries. The file <code>unix.cmxa</code> is found because it\nis always installed at the same place as the standard library, and this\ndirectory is in the library search path.</p>\n<p>If your program depends upon third-party libraries, you must pass them on the\ncommand line. You must also indicate the libraries on which these libraries\ndepend. You must also pass the -I option to <code>ocamlopt</code> for each directory where\nthey may be found. This becomes complicated, and this information is\ninstallation dependent. So we will use <code>ocamlfind</code> instead, which does these\njobs for us.</p>\n<h3 id=\"using-the-ocamlfind-front-end\">Using the ocamlfind front-end</h3>\n<p>The <code>ocamlfind</code> front-end is often used for compiling programs that use\nthird-party OCaml libraries. Library authors themselves make their library\ninstallable with <code>ocamlfind</code> as well. You can install <code>ocamlfind</code> using the\nopam package manager, by typing <code>opam install ocamlfind</code>.</p>\n<p>Let's assume that all the libraries you want to use have been installed\nproperly with ocamlfind. You can see which libraries are available in your\nsystem by typing:</p>\n<pre><code class=\"language-shell\">ocamlfind list\n</code></pre>\n<p>This shows the list of package names, with their versions. Note that most\nopam packages install software using ocamlfind, so your list of ocamlfind\nlibraries will be somewhat similar to your list of installed opam packages\nobtained by <code>opam list</code>.</p>\n<p>The command for compiling our program using package <code>pkg</code> will be:</p>\n<pre><code class=\"language-shell\">ocamlfind ocamlopt -o program -linkpkg -package pkg module1.ml module2.ml\n</code></pre>\n<p>Multiple packages may be specified using commas e.g <code>pkg1,pkg2</code>. Ocamlfind\nknows how to find any files <code>ocamlopt</code> may need from the package, for example\n<code>.cmxa</code> implementation files or <code>.cmi</code> interface files, because they have been\npackaged together and installed at a known location by ocamlfind. We need only\nthe name <code>pkg</code> to refer to them all - ocamlfind does the rest.</p>\n<p>Note that you can compile the files separately. This is useful if\nyou want to recompile only some parts of the programs. Here are the\nequivalent commands that perform a separate compilation of the source\nfiles and link them together in a final step:</p>\n<pre><code class=\"language-shell\">ocamlfind ocamlopt -c -package pkg module1.ml\nocamlfind ocamlopt -c -package pkg module2.ml\nocamlfind ocamlopt -o program -linkpkg -package pkg module1.cmx module2.cmx\n</code></pre>\n<p>Separate compilation (one command for <code>module1.ml</code>, another for <code>module2.ml</code>\nand another to link the final output) is usually not performed manually but\nonly when using an automated build system that will take care of recompiling\nonly what it necessary.</p>\n<h2 id=\"interlude-making-a-custom-toplevel\">Interlude: making a custom toplevel</h2>\n<p>OCaml provides another tool <code>ocamlmktop</code> to make an interactive toplevel with\nlibraries accessible. For example:</p>\n<pre><code class=\"language-shell\">ocamlmktop -o toplevel unix.cma module1.ml module2.ml\n</code></pre>\n<p>We run <code>toplevel</code> and get an OCaml toplevel with modules <code>Unix</code>, <code>Module1</code>, and\n<code>Module2</code> all available, allowing us to experiment interactively with our\nprogram.</p>\n<p>OCamlfind also supports <code>ocamlmktop</code>:</p>\n<pre><code class=\"language-shell\">ocamlfind ocamlmktop -o toplevel unix.cma -package pkg module1.ml module2.ml\n</code></pre>\n<h2 id=\"dune-an-automated-build-system\">Dune: an automated build system</h2>\n<p>The most popular modern system for building OCaml projects is\n<a href=\"https://dune.readthedocs.io/en/stable/\">dune</a> which may be installed with\n<code>opam install dune</code>. It allows one to build OCaml projects from a simple\ndescription of their elements. For example, the dune file for our project might\nlook like this:</p>\n<pre><code class=\"language-scheme\">;; our example project\n(executable\n  (name program)\n  (libraries unix pkg))\n</code></pre>\n<p>The dune <a href=\"https://dune.readthedocs.io/en/latest/quick-start.html\">quick-start\nguide</a> shows you how to\nwrite such description files for more complicated situations, and how to\nstructure, build, and run dune projects.</p>\n<h2 id=\"other-build-systems\">Other build systems</h2>\n<ul>\n<li><a href=\"https://github.com/ocaml-omake/omake\">OMake</a> Another OCaml build system.\n</li>\n<li><a href=\"https://www.gnu.org/software/make/\">GNU make</a> GNU make can build anything, including OCaml. May be used in conjunction with <a href=\"https://github.com/mmottl/ocaml-makefile\">OCamlmakefile</a>\n</li>\n<li><a href=\"https://github.com/ocaml/oasis\">Oasis</a> Generates a configure, build, and install system from a specification.\n</li>\n</ul>\n"}]},"beginning":{"level":"Beginning","introduction":"Are you a beginner? Or just someone who wants to brush up on the fundamentals? In either case, the OFronds tutorial system has you covered!"},"growing":{"level":"Growing","introduction":"Familiar with the basics and looking to get a more robust understanding of OCaml? Or just curious? Check out the books available on OCaml:"},"booksContent":{"booksLabel":"Books","books":[{"title":"Algorithmen, Datenstrukturen, Funktionale Programmierung: Eine praktische Einführung mit Caml Light","slug":"algorithmen-datenstrukturen-funktionale-programmierung-eine-praktische-einfhrung-mit-caml-light","description":"In the first part of this book, algorithms are described in a concise and precise manner using Caml Light. The second part provides a tutorial introduction into the language Caml Light and in its last chapter a comprehensive description of the language kernel.\n","authors":{"hd":"Juergen Wolff von Gudenberg","tl":0},"language":"german","published":"1996","cover":"/books/wolff.gif","links":0,"body_md":"This book gives an introduction to programming where algorithms as well\nas data structures are considered functionally. It is intended as an\naccompanying book for basic courses in computer science, but it is also\nsuitable for self-studies. In the first part, algorithms are described\nin a concise and precise manner using Caml Light. The second part\nprovides a tutorial introduction into the language Caml Light and in its\nlast chapter a comprehensive description of the language kernel.","body_html":"<p>This book gives an introduction to programming where algorithms as well\nas data structures are considered functionally. It is intended as an\naccompanying book for basic courses in computer science, but it is also\nsuitable for self-studies. In the first part, algorithms are described\nin a concise and precise manner using Caml Light. The second part\nprovides a tutorial introduction into the language Caml Light and in its\nlast chapter a comprehensive description of the language kernel.</p>\n"},{"title":"Apprendre à programmer avec OCaml","slug":"apprendre--programmer-avec-ocaml","description":"This book is organized into three parts. The first one introduces OCaml and targets beginners, being they programming beginners or simply new to OCaml. Through small programs, the reader is introduced to fundamental concepts of programming and of OCaml. The second and third parts are dedicated to fundamental concepts of algorithmics and should allow the reader to write programs in a structured and efficient way.\n","authors":{"hd":"Jean-Christophe Filliâtre","tl":{"hd":"Sylvain Conchon","tl":0}},"language":"french","published":"2014","cover":"/books/apprendre_ocaml_cover.png","isbn":"2-21213-678-1","links":{"hd":{"description":"Online","uri":"https://programmer-avec-ocaml.lri.fr/"},"tl":{"hd":{"description":"Order at Amazon.fr","uri":"https://www.amazon.fr/Apprendre-programmer-avec-Ocaml-Algorithmes/dp/2212136781/"},"tl":0}},"body_md":"Computer programming is hard to learn. Being a skillful programmer\nrequires imagination, anticipation, knowledge in algorithmics, the\nmastery of a programming language, and above all experience, as\ndifficulties are often hidden in details.  This book synthesizes our\nexperience as teachers and programmers.\n\nThe programming style is essential. Given a programming language, the\nsame algorithm can be written in multiple ways, and some of them can\nbe both elegant and efficient. This is what the programmer must seek\nat all costs and the reason why we choose a programming language for\nthis book rather than pseudo-code. Our choice is OCaml.\n\nThis book is organized into three parts. The first one introduces\nOCaml and targets beginners, being they programming beginners or\nsimply new to OCaml. Through small programs, the reader is introduced\nto fundamental concepts of programming and of OCaml. The second and\nthird parts are dedicated to fundamental concepts of algorithmics and\nshould allow the reader to write programs in a structured and\nefficient way. Algorithmic concepts are directly presented in the\nsyntax of OCaml and any code snippet from the book is available\nonline.","body_html":"<p>Computer programming is hard to learn. Being a skillful programmer\nrequires imagination, anticipation, knowledge in algorithmics, the\nmastery of a programming language, and above all experience, as\ndifficulties are often hidden in details.  This book synthesizes our\nexperience as teachers and programmers.</p>\n<p>The programming style is essential. Given a programming language, the\nsame algorithm can be written in multiple ways, and some of them can\nbe both elegant and efficient. This is what the programmer must seek\nat all costs and the reason why we choose a programming language for\nthis book rather than pseudo-code. Our choice is OCaml.</p>\n<p>This book is organized into three parts. The first one introduces\nOCaml and targets beginners, being they programming beginners or\nsimply new to OCaml. Through small programs, the reader is introduced\nto fundamental concepts of programming and of OCaml. The second and\nthird parts are dedicated to fundamental concepts of algorithmics and\nshould allow the reader to write programs in a structured and\nefficient way. Algorithmic concepts are directly presented in the\nsyntax of OCaml and any code snippet from the book is available\nonline.</p>\n"},{"title":"Apprentissage de la programmation avec OCaml","slug":"apprentissage-de-la-programmation-avec-ocaml","description":"This book is targeted towards beginner programmers and provides teaching material for all programmers wishing to learn the functional programming style. The programming features introduced in this book are available in all dialects of the ML language, notably Caml-Light, OCaml and Standard ML.\n","authors":{"hd":"Catherine Dubois","tl":{"hd":"Valérie Ménissier Morain","tl":0}},"language":"french","published":"2004","cover":"/books/dubois-menissier.gif","isbn":"2-7462-0819-9","links":0,"body_md":"Programming is a discipline by which the strengths of computers can be\nharnessed: large amounts of reliable memory, the ability to execute\nrepetitive tasks relentlessly, and a high computation speed. In order to\nwrite correct programs that fulfill their specified needs, it is\nnecessary to understand the precise semantics of the programming\nlanguage. This book is targeted towards beginner programmers and\nprovides teaching material for all programmers wishing to learn the\nfunctional programming style. The programming features introduced in\nthis book are available in all dialects of the ML language, notably\nCaml-Light, OCaml and Standard ML. The concepts presented therein and\nillustrated in OCaml easily transpose to other programming languages.","body_html":"<p>Programming is a discipline by which the strengths of computers can be\nharnessed: large amounts of reliable memory, the ability to execute\nrepetitive tasks relentlessly, and a high computation speed. In order to\nwrite correct programs that fulfill their specified needs, it is\nnecessary to understand the precise semantics of the programming\nlanguage. This book is targeted towards beginner programmers and\nprovides teaching material for all programmers wishing to learn the\nfunctional programming style. The programming features introduced in\nthis book are available in all dialects of the ML language, notably\nCaml-Light, OCaml and Standard ML. The concepts presented therein and\nillustrated in OCaml easily transpose to other programming languages.</p>\n"},{"title":"Approche Fonctionnelle de la Programmation","slug":"approche-fonctionnelle-de-la-programmation","description":"This book uses OCaml as a tool to introduce several important programming concepts.","authors":{"hd":"Guy Cousineau","tl":{"hd":"Michel Mauny","tl":0}},"language":"french","published":"1995","cover":"/books/cousineau-mauny-fr.gif","isbn":"2-84074-114-8","links":{"hd":{"description":"Book Website","uri":"https://pauillac.inria.fr/cousineau-mauny/main-fr.html"},"tl":0},"body_md":"This book uses OCaml as a tool to introduce several important\nprogramming concepts. It is divided in three parts. The first part is an\nintroduction to OCaml, which presents the language itself, but also\nintroduces evaluation by rewriting, evaluation strategies and proofs of\nprograms by induction. The second part is dedicated to the description\nof application programs which belong to various fields and might\ninterest various types of readers or students. Finally, the third part\nis dedicated to implementation. It describes interpretation then\ncompilation, with brief descriptions of memory management and type\nsynthesis.","body_html":"<p>This book uses OCaml as a tool to introduce several important\nprogramming concepts. It is divided in three parts. The first part is an\nintroduction to OCaml, which presents the language itself, but also\nintroduces evaluation by rewriting, evaluation strategies and proofs of\nprograms by induction. The second part is dedicated to the description\nof application programs which belong to various fields and might\ninterest various types of readers or students. Finally, the third part\nis dedicated to implementation. It describes interpretation then\ncompilation, with brief descriptions of memory management and type\nsynthesis.</p>\n"},{"title":"Concepts et outils de programmation","slug":"concepts-et-outils-de-programmation","description":"The book begins with a functional approach, based on OCaml, and continues with a presentation of an imperative language, namely Ada. It also provides numerous exercises with solutions.\n","authors":{"hd":"Thérèse Accart Hardin","tl":{"hd":"Véronique Donzeau-Gouge Viguié","tl":0}},"language":"french","published":"1992","cover":"/books/hardin-donzeau-gouge.gif","isbn":"2-7296-0419-7","links":{"hd":{"description":"Order at Amazon.fr","uri":"https://www.amazon.fr/exec/obidos/ASIN/2729604197"},"tl":0},"body_md":"This book presents a new approach to teaching programming concepts to\nbeginners, based on language semantics. A simplified semantic model is\nused to describe in a precise manner the features found in most\nprogramming languages. This model is powerful enough to explain\ntypechecking, polymorphism, evaluation, side-effects, modularity,\nexceptions. Yet, it is simple enough to be manipulated by hand, so that\nstudents can actually use it to compute. The book begins with a\nfunctional approach, based on OCaml, and continues with a presentation\nof an imperative language, namely Ada. It also provides numerous\nexercises with solutions.","body_html":"<p>This book presents a new approach to teaching programming concepts to\nbeginners, based on language semantics. A simplified semantic model is\nused to describe in a precise manner the features found in most\nprogramming languages. This model is powerful enough to explain\ntypechecking, polymorphism, evaluation, side-effects, modularity,\nexceptions. Yet, it is simple enough to be manipulated by hand, so that\nstudents can actually use it to compute. The book begins with a\nfunctional approach, based on OCaml, and continues with a presentation\nof an imperative language, namely Ada. It also provides numerous\nexercises with solutions.</p>\n"},{"title":"Cours et exercices d'informatique","slug":"cours-et-exercices-dinformatique","description":"This book was written by teachers at university and in “classes préparatoires”. It is intended for “classes préparatoires” students who study computer science and for students engaged in a computer science cursus up to the masters level. It includes a tutorial of the OCaml language, a course on algorithms, data structures, automata theory, and formal logic, as well as 135 exercises with solutions.\n","authors":{"hd":"Luc Albert","tl":0},"language":"french","published":"1997","cover":"/books/albert.gif","isbn":"2-84180-106-3","links":0,"body_md":"This book was written by teachers at university and in “classes\npréparatoires”. It is intended for “classes préparatoires” students who\nstudy computer science and for students engaged in a computer science\ncursus up to the masters level. It includes a tutorial of the OCaml\nlanguage, a course on algorithms, data structures, automata theory, and\nformal logic, as well as 135 exercises with solutions.","body_html":"<p>This book was written by teachers at university and in “classes\npréparatoires”. It is intended for “classes préparatoires” students who\nstudy computer science and for students engaged in a computer science\ncursus up to the masters level. It includes a tutorial of the OCaml\nlanguage, a course on algorithms, data structures, automata theory, and\nformal logic, as well as 135 exercises with solutions.</p>\n"},{"title":"Developing Applications with OCaml","slug":"developing-applications-with-ocaml","description":"A comprehensive (742 page) guide to developing application in the OCaml programming language\n","authors":{"hd":"Emmanuel Chailloux","tl":{"hd":"Pascal Manoury","tl":{"hd":"Bruno Pagano","tl":0}}},"language":"english","published":"2002","cover":"/books/logocaml-oreilly.gif","links":{"hd":{"description":"Book Website","uri":"https://caml.inria.fr/pub/docs/oreilly-book/index.html"},"tl":{"hd":{"description":"Online","uri":"https://caml.inria.fr/pub/docs/oreilly-book/html/index.html"},"tl":{"hd":{"description":"PDF","uri":"https://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf"},"tl":0}}},"body_md":"A comprehensive (742 pages) book on OCaml, covering not only the core\nlanguage, but also modules, objects and classes, threads and systems\nprogramming, interoperability with C, and runtime tools. This book is a\ntranslation of a French book published by OReilly.","body_html":"<p>A comprehensive (742 pages) book on OCaml, covering not only the core\nlanguage, but also modules, objects and classes, threads and systems\nprogramming, interoperability with C, and runtime tools. This book is a\ntranslation of a French book published by OReilly.</p>\n"},{"title":"Développement d'applications avec Objective Caml","slug":"dveloppement-dapplications-avec-objective-caml","description":"\"Objective CAML est un langage de programmation : un de plus dira-t-on ! Ils sont en effet déjà nombreux et pourtant il en apparaît constamment de nouveaux. Au delà de leurs disparités, la conception et la genèse de chacun d'eux procèdent d'une motivation partagée : la volonté d'abstraire\"\n","authors":{"hd":"Emmanuel Chailloux","tl":{"hd":"Pascal Manoury","tl":{"hd":"Bruno Pagano","tl":0}}},"language":"french","published":"2000","cover":"/books/chailloux-manoury-pagano.jpg","isbn":"2-84177-121-0","links":{"hd":{"description":"Online","uri":"https://www.pps.jussieu.fr/Livres/ora/DA-OCAML/index.html"},"tl":{"hd":{"description":"Order at Amazon.fr","uri":"https://www.amazon.fr/exec/obidos/ASIN/2841771210"},"tl":0}},"body_md":"A comprehensive (742 pages) book on OCaml, covering not only the core\nlanguage, but also modules, objects and classes, threads and systems\nprogramming, and interoperability with C.\n\n\"Objective CAML est un langage de programmation : un de plus dira-t-on ! Ils sont en effet déjà nombreux et pourtant il en apparaît constamment de nouveaux. Au delà de leurs disparités, la conception et la genèse de chacun d'eux procèdent d'une motivation partagée : la volonté d'abstraire\"","body_html":"<p>A comprehensive (742 pages) book on OCaml, covering not only the core\nlanguage, but also modules, objects and classes, threads and systems\nprogramming, and interoperability with C.</p>\n<p>&quot;Objective CAML est un langage de programmation : un de plus dira-t-on ! Ils sont en effet déjà nombreux et pourtant il en apparaît constamment de nouveaux. Au delà de leurs disparités, la conception et la genèse de chacun d'eux procèdent d'une motivation partagée : la volonté d'abstraire&quot;</p>\n"},{"title":"Initiation à la programmation fonctionnelle en OCaml","slug":"initiation--la-programmation-fonctionnelle-en-ocaml","description":"Le but de ce livre est d’initier le lecteur au style fonctionnel de programmation en utilisant le langage OCaml.\n","authors":{"hd":"Mohammed-Said Habet","tl":0},"language":"french","published":"2015","cover":"/books/Initiation_a_la_programmation_fonctionnelle_en_OCaml.jpg","isbn":"9782332978400","links":{"hd":{"description":"Website","uri":"https://www.edilivre.com/initiation-a-la-programmation-fonctionnelle-en-ocaml-mohammed-said-habet.html"},"tl":0},"body_md":"La programmation fonctionnelle est un style de programmation qui\nconsiste à considérer les programmes informatiques comme des fonctions\nau sens mathématique du terme. Ce style est proposé dans de nombreux\nlangages de programmation anciens et récents comme OCaml.\n\nLe but de ce livre est d’initier le lecteur au style fonctionnel de\nprogrammation en utilisant le langage OCaml. Cet ouvrage s’adresse\ndonc principalement aux débutants en informatique. Il peut également\nêtre l’occasion pour les initiés de découvrir le langage de\nprogrammation OCaml.\n\nLe lecteur trouvera une présentation progressive des concepts de\nprogrammation fonctionnelle dans le langage OCaml, illustrée par des\nexemples, de nombreux exercices corrigés et d’autres laissés à\nl’initiative du lecteur.","body_html":"<p>La programmation fonctionnelle est un style de programmation qui\nconsiste à considérer les programmes informatiques comme des fonctions\nau sens mathématique du terme. Ce style est proposé dans de nombreux\nlangages de programmation anciens et récents comme OCaml.</p>\n<p>Le but de ce livre est d’initier le lecteur au style fonctionnel de\nprogrammation en utilisant le langage OCaml. Cet ouvrage s’adresse\ndonc principalement aux débutants en informatique. Il peut également\nêtre l’occasion pour les initiés de découvrir le langage de\nprogrammation OCaml.</p>\n<p>Le lecteur trouvera une présentation progressive des concepts de\nprogrammation fonctionnelle dans le langage OCaml, illustrée par des\nexemples, de nombreux exercices corrigés et d’autres laissés à\nl’initiative du lecteur.</p>\n"},{"title":"Introduction to OCaml","slug":"introduction-to-ocaml","description":"This book is an introduction to ML programming, specifically for the OCaml programming language from INRIA. OCaml is a dialect of the ML family of languages, which derive from the Classic ML language designed by Robin Milner in 1975 for the LCF (Logic of Computable Functions) theorem prover.\n","authors":{"hd":"Jason Hickey","tl":0},"language":"english","published":"2008","links":{"hd":{"description":"PDF","uri":"https://courses.cms.caltech.edu/cs134/cs134b/book.pdf"},"tl":0},"body_md":"This book is notoriously much more than just an introduction to OCaml,\nit describes most of the language, and is accessible.\n\nAbstract: *This book is an introduction to ML programming, specifically for the OCaml programming language from INRIA. OCaml is a dialect of the ML family of languages, which derive from the Classic ML language designed by Robin Milner in 1975 for the LCF (Logic of Computable Functions) theorem prover.*\n\n[PDF](https://courses.cms.caltech.edu/cs134/cs134b/book.pdf)","body_html":"<p>This book is notoriously much more than just an introduction to OCaml,\nit describes most of the language, and is accessible.</p>\n<p>Abstract: <em>This book is an introduction to ML programming, specifically for the OCaml programming language from INRIA. OCaml is a dialect of the ML family of languages, which derive from the Classic ML language designed by Robin Milner in 1975 for the LCF (Logic of Computable Functions) theorem prover.</em></p>\n<p><a href=\"https://courses.cms.caltech.edu/cs134/cs134b/book.pdf\">PDF</a></p>\n"},{"title":"Introduzione alla programmazione funzionale","slug":"introduzione-alla-programmazione-funzionale","description":"Functional programming introduction with OCaml\n","authors":{"hd":"Carla Limongelli","tl":{"hd":"Marta Cialdea","tl":0}},"language":"italian","published":"2002","cover":"/books/limongelli-cialdea.gif","isbn":"88-7488-031-6","links":0,"body_md":"","body_html":""},{"title":"Le Langage Caml","slug":"le-langage-caml","description":"This book is a comprehensive introduction to programming in OCaml. Usable as a programming course, it introduces progressively the language features and shows them at work on the fundamental programming problems. In addition to many introductory code samples, this book details the design and implementation of six complete, realistic programs in reputedly difficult application areas: compilation, type inference, automata, etc.\n","authors":{"hd":"Xavier Leroy","tl":{"hd":"Pierre Weis","tl":0}},"language":"french","published":"1993","cover":"/books/le-language-caml-cover.jpg","isbn":"2-10-004383-8","links":{"hd":{"description":"PDF","uri":"https://caml.inria.fr/pub/distrib/books/llc.pdf"},"tl":0},"body_md":"This book is a comprehensive introduction to programming in OCaml.\nUsable as a programming course, it introduces progressively the language\nfeatures and shows them at work on the fundamental programming problems.\nIn addition to many introductory code samples, this book details the\ndesign and implementation of six complete, realistic programs in\nreputedly difficult application areas: compilation, type inference,\nautomata, etc.","body_html":"<p>This book is a comprehensive introduction to programming in OCaml.\nUsable as a programming course, it introduces progressively the language\nfeatures and shows them at work on the fundamental programming problems.\nIn addition to many introductory code samples, this book details the\ndesign and implementation of six complete, realistic programs in\nreputedly difficult application areas: compilation, type inference,\nautomata, etc.</p>\n"},{"title":"Manuel de référence du langage Caml","slug":"manuel-de-rfrence-du-langage-caml","description":"\"Cet ouvrage contient le manuel de référence du langage Caml et la documentation complète du système Caml Light, un environnement de programmation en Caml distribuée gratuitement. Il s’adresse á des programmeurs Caml expérimentés, et non pas aux d'ébutants. Il vient en complément du livre Le langage Caml, des mêmes auteurs chez le même éditeur, qui fournit une introduction progressive au langage Caml et á l’écriture de programmes dans ce langage.\"\n","authors":{"hd":"Xavier Leroy","tl":{"hd":"Pierre Weis","tl":0}},"language":"french","published":"1993","cover":"/books/manuel-de-reference-du-langage-caml-cover.jpg","isbn":"2-7296-0492-8","links":{"hd":{"description":"PDF","uri":"https://caml.inria.fr/pub/distrib/books/manuel-cl.pdf"},"tl":0},"body_md":"Written by two of the implementors of the Caml Light compiler, this\ncomprehensive book describes all constructs of the programming language\nand provides a complete documentation for the Caml Light system.\n\nIntro:  \"Cet ouvrage contient le manuel de référence du langage Caml et la documentation complète du système Caml Light, un environnement de programmation en Caml distribuée gratuitement. Il s’adresse á des programmeurs Caml expérimentés, et non pas aux d'ébutants. Il vient en complément du livre Le langage Caml, des mêmes auteurs chez le même éditeur, qui fournit une introduction progressive au langage Caml et á l’écriture de programmes dans ce langage.\"","body_html":"<p>Written by two of the implementors of the Caml Light compiler, this\ncomprehensive book describes all constructs of the programming language\nand provides a complete documentation for the Caml Light system.</p>\n<p>Intro:  &quot;Cet ouvrage contient le manuel de référence du langage Caml et la documentation complète du système Caml Light, un environnement de programmation en Caml distribuée gratuitement. Il s’adresse á des programmeurs Caml expérimentés, et non pas aux d'ébutants. Il vient en complément du livre Le langage Caml, des mêmes auteurs chez le même éditeur, qui fournit une introduction progressive au langage Caml et á l’écriture de programmes dans ce langage.&quot;</p>\n"},{"title":"More OCaml: Algorithms, Methods & Diversions","slug":"more-ocaml-algorithms-methods--diversions","description":"In \"More OCaml\" John Whitington takes a meandering tour of functional programming with OCaml, introducing various language features and describing some classic algorithms.\n","authors":{"hd":"John Whitington","tl":0},"language":"english","published":"2014-08-26","cover":"/books/more-ocaml-300-376.png","links":{"hd":{"description":"Book Website","uri":"https://ocaml-book.com/more-ocaml-algorithms-methods-diversions/"},"tl":{"hd":{"description":"Amazon","uri":"https://www.amazon.com/gp/product/0957671113"},"tl":0}},"body_md":"In \"More OCaml\" John Whitington takes a meandering tour of functional\nprogramming with OCaml, introducing various language features and describing\nsome classic algorithms. The book ends with a large worked example dealing with\nthe production of PDF files. There are questions for each chapter together with\nworked answers and hints.\n\n\"More OCaml\" will appeal both to existing OCaml programmers who wish to brush up\ntheir skills, and to experienced programmers eager to explore functional\nlanguages such as OCaml. It is hoped that each reader will find something new,\nor see an old thing in a new light. For the more casual reader, or those who are\nused to a different functional language, a summary of basic OCaml is provided at\nthe front of the book.","body_html":"<p>In &quot;More OCaml&quot; John Whitington takes a meandering tour of functional\nprogramming with OCaml, introducing various language features and describing\nsome classic algorithms. The book ends with a large worked example dealing with\nthe production of PDF files. There are questions for each chapter together with\nworked answers and hints.</p>\n<p>&quot;More OCaml&quot; will appeal both to existing OCaml programmers who wish to brush up\ntheir skills, and to experienced programmers eager to explore functional\nlanguages such as OCaml. It is hoped that each reader will find something new,\nor see an old thing in a new light. For the more casual reader, or those who are\nused to a different functional language, a summary of basic OCaml is provided at\nthe front of the book.</p>\n"},{"title":"Nouveaux exercices d'algorithmique","slug":"nouveaux-exercices-dalgorithmique","description":"This book presents 103 exercises and 5 problems about algorithms, for masters students. It attempts to address both practical and theoretical questions. Programs are written in OCaml and expressed in a purely functional style.\n","authors":{"hd":"Michel Quercia","tl":0},"language":"french","published":"2000","cover":"/books/quercia.gif","isbn":"2-7117-8990","links":{"hd":{"description":"Order at Amazon.fr","uri":"https://www.amazon.fr/exec/obidos/ASIN/3540673873"},"tl":0},"body_md":"This book presents 103 exercises and 5 problems about algorithms, for\nmasters students. It attempts to address both practical and theoretical\nquestions. Programs are written in OCaml and expressed in a purely\nfunctional style. Problem areas include programming methodology, lists,\nformula evaluation, Boolean logic, algorithmic complexity, trees,\nlanguages, and automata.","body_html":"<p>This book presents 103 exercises and 5 problems about algorithms, for\nmasters students. It attempts to address both practical and theoretical\nquestions. Programs are written in OCaml and expressed in a purely\nfunctional style. Problem areas include programming methodology, lists,\nformula evaluation, Boolean logic, algorithmic complexity, trees,\nlanguages, and automata.</p>\n"},{"title":"OCaml Book","slug":"ocaml-book","description":"Introductory programming textbook based on the OCaml language\n","authors":{"hd":"Hongbo Zhang","tl":0},"language":"english","published":"2011","links":{"hd":{"description":"GitHub","uri":"https://github.com/bobzhang/ocaml-book"},"tl":0},"body_md":"This book is a work in progress. It currently includes sections on the\ncore OCaml language, Camlp4, parsing, various libraries, the OCaml\nruntime, interoperating with C, and pearls.","body_html":"<p>This book is a work in progress. It currently includes sections on the\ncore OCaml language, Camlp4, parsing, various libraries, the OCaml\nruntime, interoperating with C, and pearls.</p>\n"},{"title":"OCaml for Scientists","slug":"ocaml-for-scientists","description":"This book teaches OCaml programming with special emphasis on scientific applications.\n","authors":{"hd":"Jon D. Harrop","tl":0},"language":"english","published":"2005","cover":"/books/harrop-book.gif","links":{"hd":{"description":"Book Website","uri":"https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html"},"tl":{"hd":{"description":"Ordering Information","uri":"https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html"},"tl":0}},"body_md":"This book teaches OCaml programming with special emphasis on scientific\napplications. Many examples are given, covering everything from simple\nnumerical analysis to sophisticated real-time 3D visualisation using\nOpenGL. This book contains over 800 color syntax-highlighted source code\nexamples and dozens of diagrams that elucidate the power of functional\nprogramming to explain how lightning-fast and yet remarkably-simple\nprograms can be constructed in the OCaml programming language.","body_html":"<p>This book teaches OCaml programming with special emphasis on scientific\napplications. Many examples are given, covering everything from simple\nnumerical analysis to sophisticated real-time 3D visualisation using\nOpenGL. This book contains over 800 color syntax-highlighted source code\nexamples and dozens of diagrams that elucidate the power of functional\nprogramming to explain how lightning-fast and yet remarkably-simple\nprograms can be constructed in the OCaml programming language.</p>\n"},{"title":"OCaml from the very Beginning","slug":"ocaml-from-the-very-beginning","description":"In \"OCaml from the Very Beginning\" John Whitington takes a no-prerequisites approach to teaching a modern general-purpose programming language.\n","authors":{"hd":"John Whitington","tl":0},"language":"english","published":"2013-06-07","cover":"/books/OCaml_from_beginning.png","links":{"hd":{"description":"Book Website","uri":"https://ocaml-book.com/"},"tl":{"hd":{"description":"Amazon","uri":"https://www.amazon.com/gp/product/0957671105"},"tl":0}},"body_md":"In \"OCaml from the Very Beginning\" John Whitington takes a\nno-prerequisites approach to teaching a modern general-purpose\nprogramming language. Each small, self-contained chapter introduces a\nnew topic, building until the reader can write quite substantial\nprograms. There are plenty of questions and, crucially, worked answers\nand hints.\n\n\"OCaml from the Very Beginning\" will appeal both to new programmers, and experienced programmers eager to explore functional languages such as OCaml. It is suitable both for formal use within an undergraduate or graduate curriculum, and for the interested amateur.","body_html":"<p>In &quot;OCaml from the Very Beginning&quot; John Whitington takes a\nno-prerequisites approach to teaching a modern general-purpose\nprogramming language. Each small, self-contained chapter introduces a\nnew topic, building until the reader can write quite substantial\nprograms. There are plenty of questions and, crucially, worked answers\nand hints.</p>\n<p>&quot;OCaml from the Very Beginning&quot; will appeal both to new programmers, and experienced programmers eager to explore functional languages such as OCaml. It is suitable both for formal use within an undergraduate or graduate curriculum, and for the interested amateur.</p>\n"},{"title":"OCaml: Programação Funcional na Prática","slug":"ocaml-programao-funcional-na-prtica","description":"This book is an introduction to functional programming through OCaml, with a pragmatic focus. The goal is to enable the reader to write real programs in OCaml and understand most of the open source code written in the language.\n","authors":{"hd":"Andrei de Araújo Formiga","tl":0},"language":"portugese","published":"2015","cover":"/books/opfp.png","links":{"hd":{"description":"Book site","uri":"https://andreiformiga.com/livro/ocaml/"},"tl":{"hd":{"description":"Order online from Casa do Código","uri":"https://www.casadocodigo.com.br/products/livro-ocaml"},"tl":0}},"body_md":"This book is an introduction to functional programming through OCaml, with a pragmatic\nfocus. The goal is to enable the reader to write real programs in OCaml and understand\nmost of the open source code written in the language. It includes many code examples\nillustrating the topics and a few larger projects written in OCaml that showcase the\nintegration of many language features. These larger\nprograms include a set of interpreter, compiler and stack machine for a simple\nlanguage, and a decision tree learning program for data analysis.","body_html":"<p>This book is an introduction to functional programming through OCaml, with a pragmatic\nfocus. The goal is to enable the reader to write real programs in OCaml and understand\nmost of the open source code written in the language. It includes many code examples\nillustrating the topics and a few larger projects written in OCaml that showcase the\nintegration of many language features. These larger\nprograms include a set of interpreter, compiler and stack machine for a simple\nlanguage, and a decision tree learning program for data analysis.</p>\n"},{"title":"The OCaml System: Documentation and User's Manual","slug":"the-ocaml-system-documentation-and-users-manual","description":"The official User's Manual for OCaml serving as a complete reference guide","authors":{"hd":"Damien Doligez","tl":{"hd":"Alain Frisch","tl":{"hd":"Jacques Garrigue","tl":{"hd":"Didier Rémy","tl":{"hd":"Jérôme Vouillon","tl":0}}}}},"language":"english","cover":"/books/colour-icon-170x148.png","links":{"hd":{"description":"Online","uri":"https://ocaml.org/releases/latest/manual.html"},"tl":0},"body_md":"This the official User's Manual. It serves as a complete reference guide\nto OCaml. Updated for each version of OCaml, it contains the description\nof the language, of its extensions, and the documentation of the tools\nand libraries included in the official distribution.","body_html":"<p>This the official User's Manual. It serves as a complete reference guide\nto OCaml. Updated for each version of OCaml, it contains the description\nof the language, of its extensions, and the documentation of the tools\nand libraries included in the official distribution.</p>\n"},{"title":"Option Informatique MP/MP","slug":"option-informatique-mpmp","description":"This books is a follow-up to the previous one and is intended for second year students in “classes préparatoires”. It deals with trees, algebraic expressions, automata and languages, and OCaml streams. The book contains more than 200 OCaml programs.\n","authors":{"hd":"Denis Monasse","tl":0},"language":"french","published":"1997","cover":"/books/monasse-2.jpg","isbn":"2-7117-8839-3","links":{"hd":{"description":"Order at Amazon.fr","uri":"https://www.amazon.fr/exec/obidos/ASIN/2711788393"},"tl":0},"body_md":"This books is a follow-up to the previous one and is intended for second\nyear students in “classes préparatoires”. It deals with trees, algebraic\nexpressions, automata and languages, and OCaml streams. The book\ncontains more than 200 OCaml programs.","body_html":"<p>This books is a follow-up to the previous one and is intended for second\nyear students in “classes préparatoires”. It deals with trees, algebraic\nexpressions, automata and languages, and OCaml streams. The book\ncontains more than 200 OCaml programs.</p>\n"},{"title":"Option Informatique MPSI","slug":"option-informatique-mpsi","description":"This is a computer science course for the first year of “classes préparatoires”. The course begins with an introductory lesson on algorithms and a description of the OCaml language.\n","authors":{"hd":"Denis Monasse","tl":0},"language":"french","published":"1996","cover":"/books/monasse-1.gif","isbn":"2-7117-8831-8","links":0,"body_md":"This is a computer science course for the first year of “classes\npréparatoires”. The course begins with an introductory lesson on\nalgorithms and a description of the OCaml language. Then, several\nfundamental algorithms are described and illustrated using OCaml\nprograms. The book adopts a mathematical approach: descriptions of\nmathematical objects are related to data structures in the programming\nlanguage. This book is suitable for students with some mathematical\nbackground, and for everyone who wants to learn the bases of computer\nscience.","body_html":"<p>This is a computer science course for the first year of “classes\npréparatoires”. The course begins with an introductory lesson on\nalgorithms and a description of the OCaml language. Then, several\nfundamental algorithms are described and illustrated using OCaml\nprograms. The book adopts a mathematical approach: descriptions of\nmathematical objects are related to data structures in the programming\nlanguage. This book is suitable for students with some mathematical\nbackground, and for everyone who wants to learn the bases of computer\nscience.</p>\n"},{"title":"Programmation de droite à gauche et vice-versa","slug":"programmation-de-droite--gauche-et-vice-versa","description":"Programming with OCaml\n","authors":{"hd":"Pascal Manoury","tl":0},"language":"french","published":"2005","cover":"/books/manoury.png","isbn":"978-2-916466-05-7","links":{"hd":{"description":"Order Online from Paracamplus","uri":"https://paracamplus.com"},"tl":0},"body_md":"","body_html":""},{"title":"Programmation en Caml","slug":"programmation-en-caml","description":"This book is intended for beginners, who will learn basic programming notions. The first part of the book is a programming course that initiates the reader to the OCaml language.\n","authors":{"hd":"Jacques Rouablé","tl":0},"language":"french","published":"1997","cover":"/books/rouable.jpg","isbn":"2-212-08944-9","links":{"hd":{"description":"Order at Amazon.fr","uri":"https://www.amazon.fr/exec/obidos/ASIN/2212089449"},"tl":0},"body_md":"This book is intended for beginners, who will learn basic programming\nnotions. The first part of the book is a programming course that\ninitiates the reader to the OCaml language. Important notions are\npresented from a practical point of view, and the implementation of some\nof these is analyzed and sketched. The second part, the “OCaml\nworkshop”, is a practical application of these notions to other domains\nconnected to computer science, logic, automata and grammars.","body_html":"<p>This book is intended for beginners, who will learn basic programming\nnotions. The first part of the book is a programming course that\ninitiates the reader to the OCaml language. Important notions are\npresented from a practical point of view, and the implementation of some\nof these is analyzed and sketched. The second part, the “OCaml\nworkshop”, is a practical application of these notions to other domains\nconnected to computer science, logic, automata and grammars.</p>\n"},{"title":"Programmation fonctionnelle, générique et objet: une introduction avec le langage OCaml","slug":"programmation-fonctionnelle-gnrique-et-objet-une-introduction-avec-le-langage-ocaml","description":"Programming with OCaml\n","authors":{"hd":"Philippe Narbel","tl":0},"language":"french","published":"2005","cover":"/books/narbel.jpg","isbn":"2-7117-4843-X","links":0,"body_md":"","body_html":""},{"title":"Programmazione funzionale, una semplice introduzione","slug":"programmazione-funzionale-una-semplice-introduzione","description":"Functional programming introduction with OCaml\n","authors":{"hd":"Massimo Maria Ghisalberti","tl":0},"language":"italian","published":"2015","links":{"hd":{"description":"Emacs Org source","uri":"https://minimalprocedure.pragmas.org/writings/programmazione_funzionale/programmazione_funzionale.org"},"tl":{"hd":{"description":"HTML","uri":"https://minimalprocedure.pragmas.org/writings/programmazione_funzionale/programmazione_funzionale.html"},"tl":{"hd":{"description":"PDF","uri":"https://minimalprocedure.pragmas.org/writings/programmazione_funzionale/programmazione_funzionale.pdf"},"tl":0}}},"body_md":"","body_html":""},{"title":"Real World OCaml","slug":"real-world-ocaml","description":"Learn how to solve day-to-day problems in data processing, numerical computation, system scripting, and database-driven web applications with the OCaml multi-paradigm programming language.\n","authors":{"hd":"Jason Hickey","tl":{"hd":"Anil Madhavapeddy","tl":{"hd":"Yaron Minsky","tl":0}}},"language":"english","published":"2013-11-25","cover":"/books/real-world-ocaml.jpg","links":{"hd":{"description":"Book Website","uri":"https://dev.realworldocaml.org/"},"tl":{"hd":{"description":"O'Reilly","uri":"https://shop.oreilly.com/product/0636920024743.do"},"tl":{"hd":{"description":"Amazon","uri":"https://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X/ref=tmm_pap_title_0?ie=UTF8&qid=1385006524&sr=8-1"},"tl":0}}},"body_md":"Learn how to solve day-to-day problems in data processing, numerical\ncomputation, system scripting, and database-driven web applications with\nthe OCaml multi-paradigm programming language. This hands-on book shows\nyou how to take advantage of OCaml’s functional, imperative, and\nobject-oriented programming styles with recipes for many real-world\ntasks.\n\nYou’ll start with OCaml basics, including how to set up a development\nenvironment, and move toward more advanced topics such as the module\nsystem, foreign-function interface, macro language, and the OCaml tools.\nQuickly learn how to put OCaml to work for writing succinct and\nreadable code.","body_html":"<p>Learn how to solve day-to-day problems in data processing, numerical\ncomputation, system scripting, and database-driven web applications with\nthe OCaml multi-paradigm programming language. This hands-on book shows\nyou how to take advantage of OCaml’s functional, imperative, and\nobject-oriented programming styles with recipes for many real-world\ntasks.</p>\n<p>You’ll start with OCaml basics, including how to set up a development\nenvironment, and move toward more advanced topics such as the module\nsystem, foreign-function interface, macro language, and the OCaml tools.\nQuickly learn how to put OCaml to work for writing succinct and\nreadable code.</p>\n"},{"title":"Seize problèmes d'informatique","slug":"seize-problmes-dinformatique","description":"This book offers sixteen problems in computer science, with detailed answers to all questions and complete solutions to algorithmic problems given as OCaml programs.\n","authors":{"hd":"Bruno Petazzoni","tl":0},"language":"french","published":"2001","cover":"/books/petazzoni.jpg","isbn":"3-540-67387-3","links":{"hd":{"description":"Springer's Catalog Page","uri":"https://www.springeronline.com/sgw/cda/frontpage/0,10735,5-102-22-2042496-0,00.html"},"tl":0},"body_md":"This book offers sixteen problems in computer science, with detailed\nanswers to all questions and complete solutions to algorithmic problems\ngiven as OCaml programs. It deals mainly with automata, finite or\ninfinite words, formal language theory, and some classical algorithms\nsuch as bin-packing. It is intended for students who attend the optional\ncomputer science curriculum of the “classes préparatoires MPSI/MP”. It\nshould also be useful to all teachers and computer science students up\nto a masters degree.","body_html":"<p>This book offers sixteen problems in computer science, with detailed\nanswers to all questions and complete solutions to algorithmic problems\ngiven as OCaml programs. It deals mainly with automata, finite or\ninfinite words, formal language theory, and some classical algorithms\nsuch as bin-packing. It is intended for students who attend the optional\ncomputer science curriculum of the “classes préparatoires MPSI/MP”. It\nshould also be useful to all teachers and computer science students up\nto a masters degree.</p>\n"},{"title":"The Functional Approach to OCaml","slug":"the-functional-approach-to-ocaml","description":"Learning about functional programming using OCaml\n","authors":{"hd":"Guy Cousineau","tl":0},"language":"english","published":"1998","cover":"/books/cousineau-mauny-en.gif","isbn":"0-521-57681-4","links":{"hd":{"description":"Book Website","uri":"https://pauillac.inria.fr/cousineau-mauny/main.html"},"tl":{"hd":{"description":"Order at Amazon.com","uri":"https://www.amazon.com/exec/obidos/ASIN/0521571839/qid%3D911812711/sr%3D1-22/102-8668961-8838559"},"tl":0}},"body_md":"This book uses OCaml as a tool to introduce several important\nprogramming concepts. It is divided in three parts. The first part is an\nintroduction to OCaml, which presents the language itself, but also\nintroduces evaluation by rewriting, evaluation strategies and proofs of\nprograms by induction. The second part is dedicated to the description\nof application programs which belong to various fields and might\ninterest various types of readers or students. Finally, the third part\nis dedicated to implementation. It describes interpretation and\ncompilation, with brief descriptions of memory management and type\nsynthesis.","body_html":"<p>This book uses OCaml as a tool to introduce several important\nprogramming concepts. It is divided in three parts. The first part is an\nintroduction to OCaml, which presents the language itself, but also\nintroduces evaluation by rewriting, evaluation strategies and proofs of\nprograms by induction. The second part is dedicated to the description\nof application programs which belong to various fields and might\ninterest various types of readers or students. Finally, the third part\nis dedicated to implementation. It describes interpretation and\ncompilation, with brief descriptions of memory management and type\nsynthesis.</p>\n"},{"title":"Think OCaml: How to think like a Functional Programmer","slug":"think-ocaml-how-to-think-like-a-functional-programmer","description":"Introductory programming textbook based on the OCaml language\n","authors":{"hd":"Nicholas Monje","tl":{"hd":"Allen Downey","tl":0}},"language":"english","published":"2008","cover":"/books/thinkocaml_cover_web.png","links":{"hd":{"description":"Book Website","uri":"https://greenteapress.com/thinkocaml/index.html"},"tl":{"hd":{"description":"PDF","uri":"https://greenteapress.com/thinkocaml/thinkocaml.pdf"},"tl":0}},"body_md":"This book is a work in progress. It is an introductory programming\ntextbook based on the OCaml language. It is a modified version of\nThink Python by Allen Downey. It is intended for newcomers to\nprogramming and also those who know some programming but want to learn\nprogramming in the function-oriented paradigm, or those who simply\nwant to learn OCaml.","body_html":"<p>This book is a work in progress. It is an introductory programming\ntextbook based on the OCaml language. It is a modified version of\nThink Python by Allen Downey. It is intended for newcomers to\nprogramming and also those who know some programming but want to learn\nprogramming in the function-oriented paradigm, or those who simply\nwant to learn OCaml.</p>\n"},{"title":"Unix System Programming in OCaml","slug":"unix-system-programming-in-ocaml","description":"Learn Unix system programming in OCaml\n","authors":{"hd":"Xavier Leroy","tl":{"hd":"Didier Rémy","tl":0}},"language":"english","published":"2010-05-01","links":{"hd":{"description":"Online","uri":"https://ocaml.github.io/ocamlunix"},"tl":0},"body_md":"This is an excellent book on Unix system programming, with an emphasis\non communications between processes. The main novelty of this work is\nthe use of OCaml, instead of the C language that is customary in systems\nprogramming. This gives an unusual perspective on systems programming\nand on OCaml. It is assumed that the reader is familiar with OCaml and\nUnix shell commands.","body_html":"<p>This is an excellent book on Unix system programming, with an emphasis\non communications between processes. The main novelty of this work is\nthe use of OCaml, instead of the C language that is customary in systems\nprogramming. This gives an unusual perspective on systems programming\nand on OCaml. It is assumed that the reader is familiar with OCaml and\nUnix shell commands.</p>\n"},{"title":"Using, Understanding and Unraveling OCaml","slug":"using-understanding-and-unraveling-ocaml","description":"This book describes both the OCaml language and the theoretical grounds behind its powerful type system.\n","authors":{"hd":"Didier Rémy","tl":0},"language":"english","published":"2002-09-20","links":{"hd":{"description":"Online","uri":"https://caml.inria.fr/pub/docs/u3-ocaml/"},"tl":{"hd":{"description":"PDF","uri":"https://caml.inria.fr/pub/docs/u3-ocaml/ocaml.pdf"},"tl":0}},"body_md":"This book describes both the OCaml language and the theoretical grounds\nbehind its powerful type system. A good complement to other books on\nOCaml it is addressed to a wide audience of people interested in modern programming languages in general, ML-like languages in particular, or simply in OCaml, whether they are programmers or language designers, beginners or knowledgeable readers — little prerequisite is actually assumed.","body_html":"<p>This book describes both the OCaml language and the theoretical grounds\nbehind its powerful type system. A good complement to other books on\nOCaml it is addressed to a wide audience of people interested in modern programming languages in general, ML-like languages in particular, or simply in OCaml, whether they are programmers or language designers, beginners or knowledgeable readers — little prerequisite is actually assumed.</p>\n"}]},"expanding":{"level":"Expanding","introduction":"Have a strong foundation in OCaml? Time to get involved! Prepare by getting familiar with the OCaml Manual:"},"diversifying":{"level":"Diversifying","introduction":"Now that you're familiar with the building blocks of OCaml, you may want to diversify your portfolio and have a look at the many applications that operate using OCaml."},"researching":{"level":"Researching","introduction":"Aspiring towards greater understanding of the language? Want to push the limits and discover brand new things? Check out papers written by leading OCaml researchers:"}},"params":{"lang":"en"}},"__N_SSG":true}