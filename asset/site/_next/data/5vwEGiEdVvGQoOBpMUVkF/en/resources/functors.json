{"pageProps":{"content":{"source":"<p>Functors are probably one of the most complex features of OCaml, but you don't\nhave to use them extensively to be a successful OCaml programmer.  Actually,\nyou may never have to define a functor yourself, but you will surely encounter\nthem in the standard library. They are the only way of using the Set and Map\nmodules, but using them is not so difficult.</p>\n<h2 id=\"what-are-functors-and-why-do-we-need-them\">What are functors and why do we need them?</h2>\n<p>A functor is a module that is parametrized by another module, just like a\nfunction is a value which is parametrized by other values, the arguments.</p>\n<p>It allows one to parametrize a type by a value, which is not possible directly\nin OCaml without functors. For example, we can define a functor that takes an\nint n and returns a collection of array operations that work exclusively on\narrays of length n. If by mistake the programmer passes a regular array to one\nof those functions, it will result in a compilation error. If we were not using\nthis functor but the standard array type, the compiler would not be able to\ndetect the error, and we would get a runtime error at some undetermined date in\nthe future, which is much worse.</p>\n<h2 id=\"using-an-existing-functor\">Using an existing functor</h2>\n<p>The standard library defines a <code>Set</code> module, which provides a <code>Make</code> functor.\nThis functor takes one argument, which is a module that provides (at least) two\nthings: the type of elements, given as <code>t</code> and the comparison function given as\n<code>compare</code>. The point of the functor is to ensure that the same comparison\nfunction will always be used, even if the programmer makes a mistake.</p>\n<p>For example, if we want to use sets of ints, we would do this:</p>\n<pre><code class=\"language-ocaml\"># module Int_set =\n  Set.Make (struct\n              type t = int\n              let compare = compare\n            end)\nmodule Int_set :\n  sig\n    type elt = int\n    type t\n    val empty : t\n    val is_empty : t -&gt; bool\n    val mem : int -&gt; t -&gt; bool\n    val add : int -&gt; t -&gt; t\n    val singleton : int -&gt; t\n    val remove : int -&gt; t -&gt; t\n    val union : t -&gt; t -&gt; t\n    val inter : t -&gt; t -&gt; t\n    val disjoint : t -&gt; t -&gt; bool\n    val diff : t -&gt; t -&gt; t\n    val compare : t -&gt; t -&gt; int\n    val equal : t -&gt; t -&gt; bool\n    val subset : t -&gt; t -&gt; bool\n    val iter : (int -&gt; unit) -&gt; t -&gt; unit\n    val map : (int -&gt; int) -&gt; t -&gt; t\n    val fold : (int -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a\n    val for_all : (int -&gt; bool) -&gt; t -&gt; bool\n    val exists : (int -&gt; bool) -&gt; t -&gt; bool\n    val filter : (int -&gt; bool) -&gt; t -&gt; t\n    val partition : (int -&gt; bool) -&gt; t -&gt; t * t\n    val cardinal : t -&gt; int\n    val elements : t -&gt; int list\n    val min_elt : t -&gt; int\n    val min_elt_opt : t -&gt; int option\n    val max_elt : t -&gt; int\n    val max_elt_opt : t -&gt; int option\n    val choose : t -&gt; int\n    val choose_opt : t -&gt; int option\n    val split : int -&gt; t -&gt; t * bool * t\n    val find : int -&gt; t -&gt; int\n    val find_opt : int -&gt; t -&gt; int option\n    val find_first : (int -&gt; bool) -&gt; t -&gt; int\n    val find_first_opt : (int -&gt; bool) -&gt; t -&gt; int option\n    val find_last : (int -&gt; bool) -&gt; t -&gt; int\n    val find_last_opt : (int -&gt; bool) -&gt; t -&gt; int option\n    val of_list : int list -&gt; t\n    val to_seq_from : int -&gt; t -&gt; int Seq.t\n    val to_seq : t -&gt; int Seq.t\n    val add_seq : int Seq.t -&gt; t -&gt; t\n    val of_seq : int Seq.t -&gt; t\n  end\n</code></pre>\n<p>For sets of strings, it is even easier because the standard library provides a\n<code>String</code> module with a type <code>t</code> and a function <code>compare</code>. If you were following\ncarefully, by now you must have guessed how to create a module for the\nmanipulation of sets of strings:</p>\n<pre><code class=\"language-ocaml\"># module String_set = Set.Make (String)\nmodule String_set :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -&gt; bool\n    val mem : elt -&gt; t -&gt; bool\n    val add : elt -&gt; t -&gt; t\n    val singleton : elt -&gt; t\n    val remove : elt -&gt; t -&gt; t\n    val union : t -&gt; t -&gt; t\n    val inter : t -&gt; t -&gt; t\n    val disjoint : t -&gt; t -&gt; bool\n    val diff : t -&gt; t -&gt; t\n    val compare : t -&gt; t -&gt; int\n    val equal : t -&gt; t -&gt; bool\n    val subset : t -&gt; t -&gt; bool\n    val iter : (elt -&gt; unit) -&gt; t -&gt; unit\n    val map : (elt -&gt; elt) -&gt; t -&gt; t\n    val fold : (elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a\n    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool\n    val exists : (elt -&gt; bool) -&gt; t -&gt; bool\n    val filter : (elt -&gt; bool) -&gt; t -&gt; t\n    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t\n    val cardinal : t -&gt; int\n    val elements : t -&gt; elt list\n    val min_elt : t -&gt; elt\n    val min_elt_opt : t -&gt; elt option\n    val max_elt : t -&gt; elt\n    val max_elt_opt : t -&gt; elt option\n    val choose : t -&gt; elt\n    val choose_opt : t -&gt; elt option\n    val split : elt -&gt; t -&gt; t * bool * t\n    val find : elt -&gt; t -&gt; elt\n    val find_opt : elt -&gt; t -&gt; elt option\n    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt\n    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option\n    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt\n    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option\n    val of_list : elt list -&gt; t\n    val to_seq_from : elt -&gt; t -&gt; elt Seq.t\n    val to_seq : t -&gt; elt Seq.t\n    val add_seq : elt Seq.t -&gt; t -&gt; t\n    val of_seq : elt Seq.t -&gt; t\n  end\n</code></pre>\n<p>(the parentheses are necessary)</p>\n<h2 id=\"defining-functors\">Defining functors</h2>\n<p>A functor with one argument can be defined like this:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">module F (X : X_type) = struct\n  ...\nend\n</code></pre>\n<p>where <code>X</code> is the module that will be passed as argument, and <code>X_type</code> is its\nsignature, which is mandatory.</p>\n<p>The signature of the returned module itself can be constrained, using this\nsyntax:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">module F (X : X_type) : Y_type =\nstruct\n  ...\nend\n</code></pre>\n<p>or by specifying this in the .mli file:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">module F (X : X_type) : Y_type\n</code></pre>\n<p>Overall, the syntax of functors is hard to grasp. The best may be to look at\nthe source files\n<a href=\"https://github.com/ocaml/ocaml/blob/trunk/stdlib/set.ml\"><code>set.ml</code></a> or\n<a href=\"https://github.com/ocaml/ocaml/blob/trunk/stdlib/map.ml\"><code>map.ml</code></a> of the\nstandard library.</p>\n","title":"Functors","pageDescription":"Learn about functors, modules parameterised by other modules\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#what-are-functors-and-why-do-we-need-them\">What are functors and why do we need them?</a>\n</li>\n<li><a href=\"#using-an-existing-functor\">Using an existing functor</a>\n</li>\n<li><a href=\"#defining-functors\">Defining functors</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"functors"}},"__N_SSG":true}