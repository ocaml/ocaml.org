{"pageProps":{"content":{"source":"<h2 id=\"minigtk\">MiniGtk</h2>\n<p>While the structure of lablgtk outlined in <a href=\"introduction_to_gtk.html\" title=\"Introduction to Gtk\">Introduction to\nGtk</a> seems perhaps\nover-complex, it's worth considering exactly why the author chose two\nlayers. To appreciate this, you really need to get your hands dirty and\nlook at other ways that a Gtk wrapper might have been written.</p>\n<p>To this end I played around with something I call\n<dfn>MiniGtk</dfn>, intended as a simple Gtk wrapper. All MiniGtk is\ncapable of is opening a window with a label, but after writing MiniGtk I\nhad renewed respect for the author of lablgtk!</p>\n<p>MiniGtk is also a good tutorial for people who want to write OCaml\nbindings around their favorite C library. If you've ever tried to write\nbindings for Python or Java, you'll find doing the same for OCaml is\nsurprisingly easy, although you do have to worry a bit about the garbage\ncollector.</p>\n<p>Let's talk first about how MiniGtk is structured: rather than using a\ntwo layered approach as with lablgtk, I wanted to implement MiniGtk\nusing a single (object-oriented) layer. This means that MiniGtk consists\nof a bunch of class definitions. Methods in those classes pretty much\ndirectly translate into calls to the C <code>libgtk-1.2.so</code> library.</p>\n<p>I also wanted to rationalise the module naming scheme for Gtk. So there\nis exactly one top-level module called (surprise!) <code>Gtk</code> and all classes\nare inside this module. A test program looks like this:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let win = new Gtk.window ~title:&quot;My window&quot; ();;\nlet lbl = new Gtk.label ~text:&quot;Hello&quot; ();;\nwin#add lbl;;\n\nlet () =\n  Gtk.main ()\n</code></pre>\n<p>I defined a single abstract type to cover all <code>GtkObject</code>s (and\n&quot;subclasses&quot; of this C structure). In the <code>Gtk</code> module you'll find this\ntype definition:</p>\n<pre><code class=\"language-ocaml\">type obj\n</code></pre>\n<p>As discussed in the last chapter, this defines an abstract type of which\nit is impossible to create any instances. In OCaml, at least. Certain C\nfunctions are going to create instances of this type. For instance, the\nfunction which creates new labels (ie. <code>GtkLabel</code> structures) is defined\nthis way:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">external gtk_label_new : string -&gt; obj = &quot;gtk_label_new_c&quot;\n</code></pre>\n<p>This strange function definition defines an <dfn>external\nfunction</dfn>, one coming from C. The C function is called\n<code>gtk_label_new_c</code>, and it takes a string and returns one of our abstract\n<code>obj</code> types.</p>\n<p>OCaml doesn't quite let you call <em>any</em> C function yet. You need to write\na little C wrapper around the library's function to translate to and\nfrom OCaml's internal types and C types. <code>gtk_label_new_c</code> (note the\nadditional <code>_c</code>) is my wrapper around the real Gtk C function called\n<code>gtk_label_new</code>. Here it is. I'll explain more about it later.</p>\n<pre><code class=\"language-C\">CAMLprim value\ngtk_label_new_c (value str)\n{\n  CAMLparam1 (str);\n  CAMLreturn (wrap (GTK_OBJECT (\n    gtk_label_new (String_val (str)))));\n }\n</code></pre>\n<p>Before explaining this function further, I'm going to take a step back\nand look at the hierarchy of our Gtk classes. I've chosen to reflect the\nactual Gtk widget hierarchy as closely as possible. All Gtk widgets are\nderived from a virtual base class called <code>GtkObject</code>. In fact from this\nclass is derived <code>GtkWidget</code> and the whole variety of Gtk widgets are\nderived from this. So we define our own <code>GtkObject</code> equivalent class\nlike this (note that <code>object</code> is a reserved word in OCaml).</p>\n<pre><code class=\"language-ocaml\">type obj\n\nclass virtual gtk_object (obj : obj) =\nobject (self)\n  val obj = obj\n  method obj = obj\nend\n</code></pre>\n<p><code>type obj</code> defines our abstract object type, and <code>class gtk_object</code>\ntakes one of these &quot;things&quot; as a parameter to its constructor. Recall\nfrom above that this parameter is actually the C <code>GtkObject</code> structure\n(in fact it's a specially wrapped pointer to this structure).</p>\n<p>You can't create <code>gtk_object</code> instances directly because it's a virtual\nclass, but if you could you'd have to construct them like this:\n<code>new gtk_object obj</code>. What would you pass as that <code>obj</code> parameter? You'd\npass the return value of, for instance, <code>gtk_label_new</code> (go back and\nhave a look at how that <code>external</code> function was typed). This is shown\nbelow:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">(* Example code, not really part of MiniGtk! *)\nclass label text =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit gtk_object obj\n  end\n</code></pre>\n<p>Of course the real <code>label</code> class doesn't inherit directly from\n<code>gtk_object</code> as shown above, but in principle this is how it works.</p>\n<p>Following the Gtk class hierarchy the only class derived directly from\n<code>gtk_object</code> is our <code>widget</code> class, defined like this:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">external gtk_widget_show : obj -&gt; unit = &quot;gtk_widget_show_c&quot;\nexternal gtk_widget_show_all : obj -&gt; unit = &quot;gtk_widget_show_all_c&quot;\n\nclass virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    method show = gtk_widget_show obj\n    method show_all = gtk_widget_show_all obj\n    initializer if show &lt;&gt; Some false then self#show\n  end\n</code></pre>\n<p>This class is considerably more complex. Let's look at the\ninitialization code first:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">class virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    initializer\n      if show &lt;&gt; Some false then self#show\n  end\n</code></pre>\n<p>The <code>initializer</code> section may well be new to you. This is code which\nruns when an object is being created - the equivalent of a constructor\nin other languages. In this case we check the boolean optional <code>show</code>\nargument and unless the user specified it explicitly as <code>false</code> we\nautomatically call the <code>#show</code> method. (All Gtk widgets need to be\n&quot;shown&quot; after being created unless you want a widget to be created but\nhidden).</p>\n<p>The actual definition of the methods happens with the help of a couple\nof external functions. These are basically direct calls to the C library\n(well, in fact there's a tiny bit of wrapper code, but that's not\nfunctionally important).</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">method show = gtk_widget_show obj\nmethod show_all = gtk_widget_show_all obj\n</code></pre>\n<p>Notice that we pass the underlying <code>GtkObject</code> to both C library calls.\nThis makes sense because these functions are prototyped as\n<code>void gtk_widget_show (GtkWidget *);</code> in C (<code>GtkWidget</code> and <code>GtkObject</code>\nare safely used interchangeably in this context).</p>\n<p>I want to describe the <code>label</code> class (the real one this time!), but in\nbetween <code>widget</code> and <code>label</code> is <code>misc</code>, a generic class which describes\na large class of miscellaneous widgets. This class just adds padding and\nalignment around a widget such as a label. Here is its definition:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let may f x =\n  match x with\n  | None -&gt; ()\n  | Some x -&gt; f x\n\nexternal gtk_misc_set_alignment :\n  obj -&gt; float * float -&gt; unit = &quot;gtk_misc_set_alignment_c&quot;\nexternal gtk_misc_set_padding :\n  obj -&gt; int * int -&gt; unit = &quot;gtk_misc_set_padding_c&quot;\n\nclass virtual misc ?alignment ?padding ?show obj =\n  object (self)\n    inherit widget ?show obj\n    method set_alignment = gtk_misc_set_alignment obj\n    method set_padding = gtk_misc_set_padding obj\n    initializer\n      may (gtk_misc_set_alignment obj) alignment;\n      may (gtk_misc_set_padding obj) padding\n  end\n</code></pre>\n<p>We start with a helper function called\n<code>may : ('a -&gt; unit) -&gt; 'a option -&gt; unit</code> which invokes its first\nargument on the contents of its second unless the second argument is\n<code>None</code>. This trick (stolen from lablgtk of course) is very useful when\ndealing with optional arguments as we'll see.</p>\n<p>The methods in <code>misc</code> should be straightforward. What is tricky is the\ninitialization code. First notice that we take optional <code>alignment</code> and\n<code>padding</code> arguments to the constructor, and we pass the optional <code>show</code>\nand mandatory <code>obj</code> arguments directly up to <code>widget</code>. What do we do\nwith the optional <code>alignment</code> and <code>padding</code>? The initializer uses these:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">initializer\n  may (gtk_misc_set_alignment obj) alignment;\n  may (gtk_misc_set_padding obj) padding \n</code></pre>\n<p>It's that tricky <code>may</code> function in action. <em>If</em> the user gave an\n<code>alignment</code> argument, then this will set the alignment on the object by\ncalling <code>gtk_misc_set_alignment obj the_alignment</code>. But more commonly\nthe user will omit the <code>alignment</code> argument, in which case <code>alignment</code>\nis <code>None</code> and this does nothing. (In effect we get Gtk's default\nalignment, whatever that is). A similar thing happens with the\n<code>padding</code>. Note there is a certain simplicity and elegance in the way\nthis is done.</p>\n<p>Now we can finally get to the <code>label</code> class, which is derived directly\nfrom <code>misc</code>:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">external gtk_label_new :\n    string -&gt; obj  = &quot;gtk_label_new_c&quot;\nexternal gtk_label_set_text :\n    obj -&gt; string -&gt; unit = &quot;gtk_label_set_text_c&quot;\nexternal gtk_label_set_justify :\n    obj -&gt; Justification.t -&gt; unit = &quot;gtk_label_set_justify_c&quot;\nexternal gtk_label_set_pattern :\n    obj -&gt; string -&gt; unit = &quot;gtk_label_set_pattern_c&quot;\nexternal gtk_label_set_line_wrap :\n    obj -&gt; bool -&gt; unit = &quot;gtk_label_set_line_wrap_c&quot;\n\nclass label ~text\n  ?justify ?pattern ?line_wrap ?alignment\n  ?padding ?show () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ?alignment ?padding ?show obj\n    method set_text = gtk_label_set_text obj\n    method set_justify = gtk_label_set_justify obj\n    method set_pattern = gtk_label_set_pattern obj\n    method set_line_wrap = gtk_label_set_line_wrap obj\n    initializer\n      may (gtk_label_set_justify obj) justify;\n      may (gtk_label_set_pattern obj) pattern;\n      may (gtk_label_set_line_wrap obj) line_wrap\n  end\n</code></pre>\n<p>Although this class is bigger than the ones we've looked at up til now,\nit's really more of the same idea, <em>except</em> that this class isn't\nvirtual. You can create instances of this class which means it finally\nhas to call <code>gtk_..._new</code>. This is the initialization code (we discussed\nthis pattern above):</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">class label ~text ... () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ... obj\n  end\n</code></pre>\n<p>(Pop quiz: what happens if we need to define a class which is both a\nbase class from which other classes can be derived, and is also a\nnon-virtual class of which the user should be allowed to create\ninstances?)</p>\n<h4 id=\"wrapping-calls-to-c-libraries\">Wrapping calls to C libraries</h4>\n<p>Now we'll look in more detail at actually wrapping up calls to C library\nfunctions. Here's a simple example:</p>\n<pre><code class=\"language-C\">/* external gtk_label_set_text :\n     obj -&gt; string -&gt; unit\n       = &quot;gtk_label_set_text_c&quot; */\n\nCAMLprim value\ngtk_label_set_text_c (value obj, value str)\n{\n  CAMLparam2 (obj, str);\n  gtk_label_set_text (unwrap (GtkLabel, obj),\n    String_val (str));\n  CAMLreturn (Val_unit);\n}\n</code></pre>\n<p>Comparing the OCaml prototype for the external function call (in the\ncomment) with the definition of the function we can see two things:</p>\n<ul>\n<li>The C function that OCaml calls is named <code>&quot;gtk_label_set_text_c&quot;</code>.\n</li>\n<li>Two arguments are passed (<code>value obj</code> and <code>value str</code>) and a unit is\nreturned.\n</li>\n</ul>\n<p>Values are OCaml's internal representation of all sorts of things from\nsimple integers through to strings and even objects. I'm not going to go\ninto any great detail about the <code>value</code> type because it is more than\nadequately covered in the OCaml manual. To use <code>value</code> you need to just\nknow what macros are available to convert between a <code>value</code> and some C\ntype. The macros look like this:</p>\n<dl> <dt>`String_val (val)`</dt> <dd> Convert from a `value`\nwhich is known to be a string to a C string (ie. `char *`). </dd>\n<dt>`Val_unit`</dt> <dd> The OCaml unit `()` as a `value`. </dd>\n<dt>`Int_val (val)`</dt> <dd> Convert from a `value` which\nis known to be an integer to a C `int`. </dd>\n<dt>`Val_int (i)`</dt> <dd> Convert from a C integer `i` into an\ninteger `value`. </dd> <dt>`Bool_val (val)`</dt> <dd> Convert\nfrom a `value` which is known to be a boolean to a C boolean (ie. an\n`int`). </dd> <dt>`Val_bool (i)`</dt> <dd> Convert from a C\ninteger `i` into a boolean `value`. </dd> </dl>\n<p>You can guess the others or consult the manual. Note that there is no\nstraightforward conversion from C <code>char *</code> to a value. This involves\nallocating memory, which is somewhat more complicated.</p>\n<p>In <code>gtk_label_set_text_c</code> above, the <code>external</code> definition, plus strong\ntyping and type inference, has already ensured that the arguments are of\nthe correct type, so to convert <code>value str</code> to a C <code>char *</code> we called\n<code>String_val (str)</code>.</p>\n<p>The other parts of the function are a bit stranger. To ensure that the\ngarbage collector &quot;knows&quot; that your C function is still using <code>obj</code> and\n<code>str</code> while the C function is running (remember that the garbage\ncollector might be triggered within your C function by a number of\nevents - a callback to OCaml or using one of OCaml's allocation\nfunctions), you need to frame the function to add code to tell the\ngarbage collector about the &quot;roots&quot; that you're using. And tell the\ngarbage collector when you finish using those roots too, of course. This\nis done by framing the function within <code>CAMLparamN</code> ... <code>CAMLreturn</code>.\nHence:</p>\n<pre><code class=\"language-C\">CAMLparam2 (obj, str);\n...\nCAMLreturn (Val_unit); \n</code></pre>\n<p><code>CAMLparam2</code> is a macro saying that you're using two <code>value</code> parameters.\n(There is another macro for annotating local <code>value</code> variables too). You\nneed to use <code>CAMLreturn</code> instead of plain <code>return</code> which tells the GC\nyou've finished with those roots. It might be instructive to examine\nwhat code is inlined when you write <code>CAMLparam2 (obj, str)</code>. This is the\ngenerated code (with the author's version of OCaml, so it might vary\nbetween implementations slightly):</p>\n<pre><code class=\"language-C\">struct caml__roots_block *caml__frame\n    = local_roots;\nstruct caml__roots_block caml__roots_obj;\n\ncaml__roots_obj.next = local_roots;\nlocal_roots = &amp;caml__roots_obj;\ncaml__roots_obj.nitems = 1;\ncaml__roots_obj.ntables = 2;\ncaml__roots_obj.tables [0] = &amp;obj;\ncaml__roots_obj.tables [1] = &amp;str; \n</code></pre>\n<p>And for <code>CAMLreturn (foo)</code>:</p>\n<pre><code class=\"language-C\">local_roots = caml__frame;\nreturn (foo); \n</code></pre>\n<p>If you follow the code closely you'll see that <code>local_roots</code> is\nobviously a linked list of <code>caml__roots_block</code> structures. One (or more)\nof these structures is pushed onto the linked list when we enter the\nfunction, and all of these are popped back off when we leave, thus\nrestoring <code>local_roots</code> to its previous state when we leave the\nfunction. (<em>If</em> you remembered to call <code>CAMLreturn</code> instead of <code>return</code>\nof course - otherwise <code>local_roots</code> will end up pointing at\nuninitialised data on the stack with &quot;hilarious&quot; consequences).</p>\n<p>Each <code>caml__roots_block</code> structure has space for up to five <code>value</code>s\n(you can have multiple blocks, so this isn't a limitation). When the GC\nruns we can infer that it must walk through the linked list, starting at\n<code>local_roots</code>, and treat each <code>value</code> as a root for garbage collection\npurposes. The consequences of <em>not</em> declaring a <code>value</code> parameter or\nlocal <code>value</code> variable in this way would be that the garbage collector\nmight treat that variable as unreachable memory and thus reclaim it\nwhile your function is running!</p>\n<p>Finally there is the mysterious <code>unwrap</code> macro. This is one I wrote\nmyself, or rather, this is one I mostly copied from lablgtk. There are\ntwo related functions, called <code>wrap</code> and <code>unwrap</code> and as you might\npossibly have guessed, they wrap and unwrap <code>GtkObject</code>s in OCaml\n<code>value</code>s. These functions establish the somewhat magical relationship\nbetween <code>GtkObject</code> and our opaque, mysterious <code>obj</code> type which we\ndefined for OCaml (see the very first part of this chapter to remind\nyourself).</p>\n<p>The problem is how do we wrap up (and hide) the C <code>GtkObject</code> structure\nin a way that we can pass it around as an opaque &quot;thing&quot; (<code>obj</code>) through\nour OCaml code, and hopefully pass it back later to a C function which\ncan unwrap it and retrieve the same <code>GtkObject</code> back again?</p>\n<p>In order for it to get passed to OCaml code at all, we must somehow\nconvert it to a <code>value</code>. Luckily we can quite easily use the C API to\ncreate <code>value</code> blocks which the OCaml garbage collector <em>won't</em> examine\ntoo closely ......</p>\n","title":"Calling C Libraries","pageDescription":"Cross the divide and call C code from your OCaml program\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#minigtk\">MiniGtk</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"calling-c-libraries"}},"__N_SSG":true}