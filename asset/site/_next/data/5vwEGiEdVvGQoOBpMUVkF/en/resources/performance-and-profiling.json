{"pageProps":{"content":{"source":"<h2 id=\"speed\">Speed</h2>\n<p>Why is OCaml fast? Indeed, step back and ask <em>is OCaml fast?</em> How can we\nmake programs faster? In this chapter we'll look at what actually\nhappens when you compile your OCaml programs down to machine code. This\nwill help in understanding why OCaml is not just a great language for\nprogramming, but is also a very fast language indeed. And it'll help you\nto help the compiler write better machine code for you. It's also (I\nbelieve anyway) a good thing for programmers to have some idea of what\nhappens between you typing <code>ocamlopt</code> and getting a binary you can run.</p>\n<p>But you will need to know some assembler to get the most out of this\nsection. Don't be afraid! I'll help you out by translating the assembler\ninto a C-like pseudocode (after all C is just a portable assembly\nlanguage).</p>\n<h3 id=\"basics-of-assembly-language\">Basics of assembly language</h3>\n<p>The examples I give in this chapter are all compiled on an x86 Linux\nmachine. The x86 is, of course, a 32 bit machine, so an x86 &quot;word&quot; is 4\nbytes (= 32 bits) long. At this level OCaml deals mostly with word-sized\nobjects, so you'll need to remember to multiply by four to get the size\nin bytes.</p>\n<p>To refresh your memory, the x86 has only a small number of general\npurpose registers, each of which can store one word. The Linux assembler\nputs <code>%</code> in front of register names. The registers are: <code>%eax</code>, <code>%ebx</code>,\n<code>%ecx</code>, <code>%edx</code>, <code>%esi</code>, <code>%edi</code>, <code>%ebp</code> (special register used for stack\nframes), and <code>%esp</code> (the stack pointer).</p>\n<p>The Linux assembler (in common with other Unix assemblers, but opposite\nto MS-derived assemblers) writes moves to and from registers/memory as:</p>\n<pre><code class=\"language-assembly\">movl from, to\n</code></pre>\n<p>So <code>movl %ebx, %eax</code> means &quot;copy the contents of register <code>%ebx</code> into\nregister <code>%eax</code>&quot; (not the other way round).</p>\n<p>Almost all of the assembly language that we will look at is going to be\ndominated not by machine code instructions like <code>movl</code> but by what are\nknown as <strong>assembler directives</strong>. These directives begin\nwith a . (period) and they literally <em>direct</em> the assembler to do\nsomething. Here are the common ones for the Linux assembler:</p>\n<h4 id=\"text\">.text</h4>\n<p><strong>Text</strong> is the Unix way of saying &quot;program code&quot;. The <strong>text segment</strong>\nsimply means the part of the executable where program code is stored.\nThe <code>.text</code> directive switches the assembler so it starts writing into\nthe text segment.</p>\n<h4 id=\"data\">.data</h4>\n<p>Similarly, the <code>.data</code> directive switches the assembler so it starts\nwriting into the data segment (part) of the executable.</p>\n<pre><code class=\"language-assembly\">  .globl foo\nfoo:\n</code></pre>\n<p>This declares a global symbol called <code>foo</code>. It means the address of the\nnext thing to come can be named <code>foo</code>. Writing just <code>foo:</code> without the\npreceding <code>.globl</code> directive declares a local symbol (local to just the\ncurrent file).</p>\n<pre><code class=\"language-assembly\">.long 12345\n.byte 9\n.ascii &quot;hello&quot;\n.space 4\n</code></pre>\n<p><code>.long</code> writes a word (4 bytes) to the current segment. <code>.byte</code> writes a\nsingle byte. <code>.ascii</code> writes a string of bytes (NOT nul-terminated).\n<code>.space</code> writes the given number of zero bytes. Normally you use these\nin the data segment.</p>\n<h3 id=\"the-hello-world-program\">The &quot;hello, world&quot; program</h3>\n<p>Enough assembler. Put the following program into a file called\n<code>smallest.ml</code>:</p>\n<pre><code class=\"language-ocaml\">print_string &quot;hello, world\\n&quot;\n</code></pre>\n<p>And compile it to a native code executable using:</p>\n<pre><code class=\"language-shell\">ocamlopt -S smallest.ml -o smallest\n</code></pre>\n<p>The <code>-S</code> (capital S) tells the compiler to leave the assembly language\nfile (called <code>smallest.s</code> - lowercase s) instead of deleting it.</p>\n<p>Here are the edited highlights of the <code>smallest.s</code> file with my comments\nadded. First of all the data segment:</p>\n<pre><code class=\"language-assembly\">    .data\n    .long   4348                     ; header for string\n    .globl  Smallest__1\nlest__1:\n    .ascii  &quot;hello, world\\12&quot;        ; string\n    .space  2                        ; padding ..\n    .byte   2                        ;  .. after string\n</code></pre>\n<p>Next up the text (program code) segment:</p>\n<pre><code class=\"language-assembly\">    .text\n    .globl  Smallest__entry          ; entry point to the program\nlest__entry:\n\n    ; this is equivalent to the C pseudo-code:\n    ; Pervasives.output_string (stdout, &amp;Smallest__1)\n\n    movl    $Smallest__1, %ebx\n    movl    Pervasives + 92, %eax    ; Pervasives + 92 == stdout\n    call    Pervasives__output_string_212\n\n    ; return 1\n\n    movl    $1, %eax\n    ret\n</code></pre>\n<p>In C everything has to be inside a function. Think about how you can't\njust write <code>printf (&quot;hello, world\\n&quot;);</code> in C, but instead you have to\nput it inside <code>main () { ... }</code>. In OCaml you are allowed to have\ncommands at the top level, not inside a function. But when we translate\nthis into assembly language, where do we put those commands? There needs\nto be some way to call those commands from outside, so they need to be\nlabelled in some way. As you can see from the code snippet, OCaml solves\nthis by taking the filename (<code>smallest.ml</code>), capitalizing it and adding\n<code>__entry</code>, thus making up a symbol called <code>Smallest__entry</code> to refer to\nthe top level commands in this file.</p>\n<p>Now look at the code that OCaml has generated. The original code said\n<code>print_string &quot;hello, world\\n&quot;</code>, but OCaml has instead compiled the\nequivalent of <code>Pervasives.output_string stdout &quot;hello, world\\n&quot;</code>. Why?\nIf you look into <code>pervasives.ml</code> you'll see why:</p>\n<pre><code class=\"language-ocaml\">let print_string s = output_string stdout s\n</code></pre>\n<p>OCaml has <em>inlined</em> this function. <strong>Inlining</strong> - taking a function and\nexpanding it from its definition - is sometimes a performance win,\nbecause it avoids the overhead of an extra function call, and it can\nlead to more opportunities for the optimizer to do its thing. Sometimes\ninlining is not good, because it can lead to code bloating, and thus\ndestroys the good work done by the processor cache (and besides function\ncalls are actually not very expensive at all on modern processors).\nOCaml will inline simple calls like this, because they are essentially\nrisk free, almost always leading to a small performance gain.</p>\n<p>What else can we notice about this? The calling convention seems to be\nthat the first two arguments are passed in the <code>%eax</code> and <code>%ebx</code>\nregisters respectively. Other arguments are probably passed on the\nstack, but we'll see about that later.</p>\n<p>C programs have a simple convention for storing strings, known as\n<strong>ASCIIZ</strong>. This just means that the string is stored in ASCII, followed\nby a trailing NUL (<code>\\0</code>) character. OCaml stores strings in a different\nway, as we can see from the data segment above. This string is stored\nlike this:</p>\n<pre><code>4 byte header: 4348\nthe string:    h e l l o , SP w o r l d \\n\npadding:       \\0 \\0 \\002\n</code></pre>\n<p>Firstly the padding brings the total length of the string up to a whole\nnumber of words (4 words, 16 bytes in this example). The padding is\ncarefully designed so that you can work out the actual length of the\nstring in bytes, provided that you know the total number of <em>words</em>\nallocated to the string. The encoding for this is unambiguous (which you\ncan prove to yourself).</p>\n<p>One nice feature of having strings with an explicit length is that you\ncan represent strings containing ASCII NUL (<code>\\0</code>) characters in them,\nsomething which is difficult to do in C. However, the flip side is that\nyou need to be aware of this if you pass an OCaml string to some C\nnative code: if it contains ASCII NUL, then the C <code>str*</code> functions will\nfail on it.</p>\n<p>Secondly we have the header. Every boxed (allocated) object in OCaml has\na header which tells the garbage collector about how large the object is\nin words, and something about what the object contains. Writing the\nnumber 4348 in binary:</p>\n<pre><code>length of the object in words:  0000 0000 0000 0000 0001 00 (4 words)\ncolor (used by GC):             00\ntag:                            1111 1100 (String_tag)\n</code></pre>\n<p>See <code>/usr/include/caml/mlvalues.h</code> for more information about\nthe format of heap allocated objects in OCaml.</p>\n<p>One unusual thing is that the code passes a pointer to the start of the\nstring (ie. the word immediately after the header) to\n<code>Pervasives.output_string</code>. This means that <code>output_string</code> must\nsubtract 4 from the pointer to get at the header to determine the length\nof the string.</p>\n<p>What have I missed out from this simple example? Well, the text segment\nabove is not the whole story. It would be really nice if OCaml\ntranslated that simple hello world program into just the five lines of\nassembler shown above. But there is the question of what actually calls\n<code>Smallest__entry</code> in the real program. For this OCaml includes a whole\nload of bootstrapping code which does things like starting up the\ngarbage collector, allocating and initializing memory, calling\ninitializers in libraries and so on. OCaml links all of this code\nstatically to the final executable, which is why the program I end up\nwith (on Linux) weighs in at a portly 95,442 bytes. Nevertheless the\nstart-up time for the program is still unmeasurably small (under a\nmillisecond), compared to several seconds for starting up a reasonable\nJava program and a second or so for a Perl script.</p>\n<h3 id=\"tail-recursion\">Tail recursion</h3>\n<p>We mentioned in chapter 6 that OCaml can turn tail-recursive function\ncalls into simple loops. Is this actually true? Let's look at what\nsimple tail recursion compiles to:</p>\n<!-- do not execute this code!! -->\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec loop () =\n  print_string &quot;I go on forever ...&quot;;\n  loop ()\n  \nlet () = loop ()\n</code></pre>\n<p>The file is called <code>tail.ml</code>, so following OCaml's usual procedure for\nnaming functions, our function will be called <code>Tail__loop_nnn</code> (where\n<code>nnn</code> is some unique number which OCaml appends to distinguish\nidentically named functions from one another).</p>\n<p>Here is the assembler for just the <code>loop</code> function defined above:</p>\n<pre><code class=\"language-assembly\">        .text\n        .globl  Tail__loop_56\nTail__loop_56:\n.L100:\n        ; Print the string\n        movl    $Tail__2, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n.L101:\n        ; The following movl is in fact obsolete:\n        movl    $1, %eax\n        ; Jump back to the .L100 label above (ie. loop forever)\n        jmp     .L100\n</code></pre>\n<p>So that's pretty conclusive. Calling <code>Tail__loop_56</code> will first print\nthe string, and then jump back to the top, then print the string, and\njump back, and so on forever. It's a simple loop, <em>not</em> a recursive\nfunction call, so it doesn't use any stack space.</p>\n<h3 id=\"digression-where-are-the-types\">Digression: Where are the types?</h3>\n<p>OCaml is statically typed as we've said before on many occasions, so at\ncompile time, OCaml knows that the type of <code>loop</code> is <code>unit -&gt; unit</code>. It\nknows that the type of <code>&quot;hello, world\\n&quot;</code> is <code>string</code>. It doesn't make\nany attempt to communicate this fact to the <code>output_string</code> function.\n<code>output_string</code> is expecting a <code>channel</code> and a <code>string</code> as arguments,\nand indeed that's what it gets. What would happen if we passed, say, an\n<code>int</code> instead of a <code>string</code>?</p>\n<p>This is essentially an impossible condition. Because OCaml knows the\ntypes at compile time, it doesn't need to deal with types or check types\nat run time. There is no way, in pure OCaml, to &quot;trick&quot; the compiler\ninto generating a call to <code>Pervasives.output_string stdout 1</code>. Such an\nerror would be flagged at compile time, by type inference, and so could\nnever be compiled.</p>\n<p>The upshot is that by the time we have compiled OCaml code to assembler\ntype information mostly isn't required, certainly in the cases we've\nlooked at above where the type is fully known at compile time, and there\nis no polymorphism going on.</p>\n<p>Fully knowing all your types at compile time is a major performance win\nbecause it totally avoids any dynamic type checking at run time. Compare\nthis to a Java method invocation for example: <code>obj.method ()</code>. This is\nan expensive operation because you need to find the concrete class that\n<code>obj</code> is an instance of, and then look up the method, and you need to do\nall of this potentially <em>every</em> time you call any method. Casting\nobjects is another case where you need to do a considerable amount of\nwork at run time in Java. None of this is allowed with OCaml's static\ntypes.</p>\n<h3 id=\"polymorphic-types\">Polymorphic types</h3>\n<p>As you might have guessed from the discussion above, polymorphism, which\nis where the compiler <em>doesn't</em> have a fully known type for a function\nat compile time, might have an impact on performance. Suppose we require\na function to work out the maximum of two integers. Our first attempt\nis:</p>\n<pre><code class=\"language-ocaml\"># let max a b =\n  if a &gt; b then a else b\nval max : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;\n</code></pre>\n<p>Simple enough, but recall that the &gt; (greater than) operator in OCaml\nis polymorphic. It has type <code>'a -&gt; 'a -&gt; bool</code>, and this means that the\n<code>max</code> function we defined above is going to be polymorphic:</p>\n<pre><code class=\"language-ocaml\"># let max a b =\n  if a &gt; b then a else b\nval max : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;\n</code></pre>\n<p>This is indeed reflected in the code that OCaml generates for this\nfunction, which is pretty complex:</p>\n<pre><code class=\"language-assembly\">        .text\n        .globl  Max__max_56\nMax__max_56:\n\n        ; Reserve two words of stack space.\n\n        subl    $8, %esp\n\n        ; Save the first and second arguments (a and b) on the stack.\n\n        movl    %eax, 4(%esp)\n        movl    %ebx, 0(%esp)\n\n        ; Call the C &quot;greaterthan&quot; function (in the OCaml library).\n\n        pushl   %ebx\n        pushl   %eax\n        movl    $greaterthan, %eax\n        call    caml_c_call\n.L102:\n        addl    $8, %esp\n\n        ; If the C &quot;greaterthan&quot; function returned 1, jump to .L100\n\n        cmpl    $1, %eax\n        je      .L100\n\n        ; Returned 0, so get argument a which we previously saved on\n        ; the stack and return it.\n\n        movl    4(%esp), %eax\n        addl    $8, %esp\n        ret\n\n        ; Returned 1, so get argument b which we previously saved on\n        ; the stack and return it.\n\n.L100:\n        movl    0(%esp), %eax\n        addl    $8, %esp\n        ret\n</code></pre>\n<p>Basically the &gt; operation is done by calling a C function from the\nOCaml library. This is obviously not going to be very efficient, nothing\nlike as efficient as if we could generate some quick inline assembly\nlanguage for doing the &gt;.</p>\n<p>This is not a complete dead loss by any means. All we need to do is to\nhint to the OCaml compiler that the arguments are in fact integers. Then\nOCaml will generate a specialised version of <code>max</code> which only works on\n<code>int</code> arguments:</p>\n<pre><code class=\"language-ocaml\"># let max (a : int) (b : int) =\n  if a &gt; b then a else b\nval max : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>Here is the assembly code generated for this function:</p>\n<pre><code class=\"language-assembly\">        .text\n        .globl  Max_int__max_56\nMax_int__max_56:\n\n        ; Single assembly instruction &quot;cmpl&quot; for performing the &gt; op.\n        cmpl    %ebx, %eax\n\n        ; If %ebx &gt; %eax, jump to .L100\n        jle     .L100\n        ; Just return argument a.\n        ret\n        ; Return argument b.\n\n.L100:\n        movl    %ebx, %eax\n        ret\n</code></pre>\n<p>That's just 5 lines of assembler, and is about as simple as you can make\nit.</p>\n<p>What about this code:</p>\n<pre><code class=\"language-ocaml\"># let max a b =\n  if a &gt; b then a else b\nval max : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;\n# let () = print_int (max 2 3)\n3\n</code></pre>\n<p>Is OCaml going to be smart enough to inline the <code>max</code> function and\nspecialise it to work on integers? Disappointingly the answer is no.\nOCaml still has to generate the external <code>Max.max</code> symbol (because this\nis a module, and so that function might be called from outside the\nmodule), and it doesn't inline the function.</p>\n<p>Here's another variation:</p>\n<pre><code class=\"language-ocaml\"># let max a b =\n  if a &gt; b then a else b in\n  print_int (max 2 3)\n3\n- : unit = ()\n</code></pre>\n<p>Disappointingly although the definition of <code>max</code> in this code is local\n(it can't be called from outside the module), OCaml still doesn't\nspecialise the function.</p>\n<p>Lesson: if you have a function which is unintentionally polymorphic then\nyou can help the compiler by specifying types for one or more of the\narguments.</p>\n<h3 id=\"the-representation-of-integers-tag-bits-heap-allocated-values\">The representation of integers, tag bits, heap-allocated values</h3>\n<p>There are a number of peculiarities about integers in OCaml. One of\nthese is that integers are 31 bit entities, not 32 bit entities. What\nhappens to the &quot;missing&quot; bit?</p>\n<p>Write this to <code>int.ml</code>:</p>\n<pre><code class=\"language-ocaml\">print_int 3\n</code></pre>\n<p>and compile with <code>ocamlopt -S int.ml -o int</code> to generate assembly\nlanguage in <code>int.s</code>. Recall from the discussion above that we are\nexpecting OCaml to inline the <code>print_int</code> function as\n<code>output_string (string_of_int 3)</code>, and examining the assembly language\noutput we can see that this is exactly what OCaml does:</p>\n<pre><code class=\"language-assembly\">        .text\n        .globl  Int__entry\nInt__entry:\n\n        ; Call Pervasives.string_of_int (3)\n\n        movl    $7, %eax\n        call    Pervasives__string_of_int_152\n\n        ; Call Pervasives.output_string (stdout, result_of_previous)\n\n        movl    %eax, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n</code></pre>\n<p>The important code is shown in red. It shows two things: Firstly the\ninteger is unboxed (not allocated on the heap), but is instead passed\ndirectly to the function in the register <code>%eax</code>. This is fast. But\nsecondly we see that the number being passed is 7, not 3.</p>\n<p>This is a consequence of the representation of integers in OCaml. The\nbottom bit of the integer is used as a tag - we'll see what for next.\nThe top 31 bits are the actual integer. The binary representation of 7\nis 111, so the bottom tag bit is 1 and the top 31 bits form the number\n11 in binary = 3. To get from the OCaml representation to the integer,\ndivide by two and round down.</p>\n<p>Why the tag bit at all? This bit is used to distinguish between integers\nand pointers to structures on the heap, and the distinction is only\nnecessary if we are calling a polymorphic function. In the case above,\nwhere we are calling <code>string_of_int</code>, the argument can only ever be an\n<code>int</code> and so the tag bit would never be consulted. Nevertheless, to\navoid having two internal representations for integers, all integers in\nOCaml carry around the tag bit.</p>\n<p>A bit of background about pointers is required to understand why the tag\nbit is really necessary, and why it is where it is.</p>\n<p>In the world of RISC chips like the Sparc, MIPS and Alpha, pointers have\nto be word-aligned. So on the older 32 bit Sparc, for example, it's not\npossible to create and use a pointer which isn't aligned to a multiple\nof 4 (bytes). Trying to use one generates a processor exception, which\nmeans basically your program segfaults. The reason for this is just to\nsimplify memory access. It's just a lot simpler to design the memory\nsubsystem of a CPU if you only need to worry about word-aligned access.</p>\n<p>For historical reasons (because the x86 is derived from an 8 bit chip),\nthe x86 has supported unaligned memory access, although if you align all\nmemory accesses to multiples of 4, then things go faster.</p>\n<p>Nevertheless, all pointers in OCaml are aligned - ie. multiples of 4 for\n32 bit processors, and multiples of 8 for 64 bit processors. This means\nthat the bottom bit of any pointer in OCaml will always be zero.</p>\n<p>So you can see that by looking at the bottom bit of a register, you can\nimmediately tell if it stores a pointer (&quot;tag&quot; bit is zero), or an\ninteger (tag bit set to one).</p>\n<p>Remember our polymorphic &gt; function which caused us so much trouble in\nthe previous section? We looked at the assembler and found out that\nOCaml compiles a call to a C function called <code>greaterthan</code> whenever it\nsees the polymorphic form of &gt;. This function takes two arguments, in\nregisters <code>%eax</code> and <code>%ebx</code>. But <code>greaterthan</code> can be called with\nintegers, floats, strings, opaque objects ... How does it know what\n<code>%eax</code> and <code>%ebx</code> point to?</p>\n<p>It uses the following decision tree:</p>\n<ul>\n<li><strong>Tag bit is one:</strong> compare the two integers and return.\n</li>\n<li><strong>Tag bit is zero:</strong> <code>%eax</code> and <code>%ebx</code> must point at two\nheap-allocated memory blocks. Look at the header word of the memory\nblocks, specifically the bottom 8 bits of the header word, which tag\nthe content of the block.\n<ul>\n<li><strong>String_tag:</strong> Compare two strings.\n</li>\n<li><strong>Double_tag:</strong> Compare two floats.\n</li>\n<li>etc.\n</li>\n</ul>\n</li>\n</ul>\n<p>Note that because &gt; has type <code>'a -&gt; 'a -&gt; bool</code>, both arguments must\nhave the same type. The compiler should enforce this at compile time. I\nwould assume that <code>greaterthan</code> probably contains code to sanity-check\nthis at run time however.</p>\n<h3 id=\"floats\">Floats</h3>\n<p>Floats are, by default, boxed (allocated on the heap). Save this as\n<code>float.ml</code> and compile it with <code>ocamlopt -S float.ml -o float</code>:</p>\n<pre><code class=\"language-ocamltop\">print_float 3.0\n</code></pre>\n<p>The number is not passed directly to <code>string_of_float</code> in the <code>%eax</code>\nregister as happened above with ints. Instead, it is created statically\nin the data segment:</p>\n<pre><code class=\"language-assembly\">        .data\n        .long   2301\n        .globl  Float__1\nFloat__1:\n        .double 3.0\n</code></pre>\n<p>and a pointer to the float is passed in <code>%eax</code> instead:</p>\n<pre><code class=\"language-assembly\">        movl    $Float__1, %eax\n        call    Pervasives__string_of_float_157\n</code></pre>\n<p>Note the structure of the floating point number: it has a header (2301),\nfollowed by the 8 byte (2 word) representation of the number itself. The\nheader can be decoded by writing it as binary:</p>\n<pre><code>Length of the object in words:  0000 0000 0000 0000 0000 10 (8 bytes)\nColor:                          00\nTag:                            1111 1101 (Double_tag)\n</code></pre>\n<p><code>string_of_float</code> isn't polymorphic, but suppose we have a polymorphic\nfunction <code>foo : 'a -&gt; unit</code> taking one polymorphic argument. If we call\n<code>foo</code> with <code>%eax</code> containing 7, then this is equivalent to <code>foo 3</code>,\nwhereas if we call <code>foo</code> with <code>%eax</code> containing a pointer to <code>Float__1</code>\nabove, then this is equivalent to <code>foo 3.0</code>.</p>\n<h3 id=\"arrays\">Arrays</h3>\n<p>I mentioned earlier that one of OCaml's targets was numerical computing.\nNumerical computing does a lot of work on vectors and matrices, which\nare essentially arrays of floats. As a special hack to make this go\nfaster, OCaml implements <strong>arrays of unboxed floats</strong>. This\nmeans that in the special case where we have an object of type\n<code>float array</code> (array of floats), OCaml stores them the same way as in C:</p>\n<pre><code class=\"language-C\">double array[10];\n</code></pre>\n<p>... instead of having an array of pointers to ten separately allocated\nfloats on the heap.</p>\n<p>Let's see this in practice:</p>\n<pre><code class=\"language-ocaml\">let a = Array.create 10 0.0;;\nfor i = 0 to 9 do\n  a.(i) &lt;- float_of_int i\ndone\n</code></pre>\n<p>I'm going to compile this code with the <code>-unsafe</code> option to remove\nbounds checking (simplifying the code for our exposition here). The\nfirst line, which creates the array, is compiled to a simple C call:</p>\n<pre><code class=\"language-assembly\">        pushl   $Arrayfloats__1     ; Boxed float 0.0\n        pushl   $21                 ; The integer 10\n        movl    $make_vect, %eax    ; Address of the C function to call\n        call    caml_c_call\n    ; ...\n        movl    %eax, Arrayfloats   ; Store the resulting pointer to the\n                                    ; array at this place on the heap.\n</code></pre>\n<p>The loop is compiled to this relatively simple assembly language:</p>\n<pre><code class=\"language-assembly\">        movl    $1, %eax            ; Let %eax = 0. %eax is going to store i.\n        cmpl    $19, %eax           ; If %eax &gt; 9, then jump out of the\n        jg      .L100               ;   loop (to label .L100 at the end).\n\n.L101:                              ; This is the start of the loop body.\n        movl    Arrayfloats, %ecx   ; Address of the array to %ecx.\n\n        movl    %eax, %ebx          ; Copy i to %ebx.\n        sarl    $1, %ebx            ; Remove the tag bit from %ebx by\n                                    ;   shifting it right 1 place. So %ebx\n                                    ;   now contains the real integer i.\n\n        pushl   %ebx                ; Convert %ebx to a float.\n        fildl   (%esp)\n        addl    $4, %esp\n\n        fstpl   -4(%ecx, %eax, 4)   ; Store the float in the array at the ith\n                                ; position.\n\n        addl    $2, %eax            ; i := i + 1\n        cmpl    $19, %eax           ; If i &lt;= 9, loop around again.\n        jle     .L101\n.L100:\n</code></pre>\n<p>The important statement is the one which stores the float into the\narray. It is:</p>\n<pre><code class=\"language-assembly\">        fstpl   -4(%ecx, %eax, 4)\n</code></pre>\n<p>The assembler syntax is rather complex, but the bracketed expression\n<code>-4(%ecx, %eax, 4)</code> means &quot;at the address <code>%ecx + 4*%eax - 4</code>&quot;. Recall\nthat <code>%eax</code> is the OCaml representation of i, complete with tag bit, so\nit is essentially equal to <code>i*2+1</code>, so let's substitute that and\nmultiply it out:</p>\n<pre><code class=\"language-assembly\">  %ecx + 4*%eax - 4\n= %ecx + 4*(i*2+1) - 4\n= %ecx + 4*i*2 + 4 - 4\n= %ecx + 8*i\n</code></pre>\n<p>(Each float in the array is 8 bytes long.)</p>\n<p>So arrays of floats are unboxed, as expected.</p>\n<h3 id=\"partially-applied-functions-and-closures\">Partially applied functions and closures</h3>\n<p>How does OCaml compile functions which are only partially applied? Let's\ncompile this code:</p>\n<pre><code class=\"language-ocaml\">Array.map ((+) 2) [|1; 2; 3; 4; 5|]\n</code></pre>\n<p>If you recall the syntax, <code>[| ... |]</code> declares an array (in this case an\n<code>int array</code>), and <code>((+) 2)</code> is a closure - &quot;the function which adds 2 to\nthings&quot;.</p>\n<p>Compiling this code reveals some interesting new features. Firstly the\ncode which allocates the array:</p>\n<pre><code class=\"language-assembly\">        movl    $24, %eax           ; Allocate 5 * 4 + 4 = 24 bytes of memory.\n        call    caml_alloc\n\n        leal    4(%eax), %eax       ; Let %eax point to 4 bytes into the\n                                    ;   allocated memory.\n</code></pre>\n<p>All heap allocations have the same format: 4 byte header + data. In this\ncase the data is 5 integers, so we allocate 4 bytes for the header plus\n5 * 4 bytes for the data. We update the pointer to point at the first\ndata word, ie. 4 bytes into the allocated memory block.</p>\n<p>Next OCaml generates code to initialize the array:</p>\n<pre><code class=\"language-assembly\">        movl    $5120, -4(%eax)\n        movl    $3, (%eax)\n        movl    $5, 4(%eax)\n        movl    $7, 8(%eax)\n        movl    $9, 12(%eax)\n        movl    $11, 16(%eax)\n</code></pre>\n<p>The header word is 5120, which if you write it in binary means a block\ncontaining 5 words, with tag zero. The tag of zero means it's a\n&quot;structured block&quot; a.k.a. an array. We also copy the numbers 1, 2, 3, 4\nand 5 to the appropriate places in the array. Notice the OCaml\nrepresentation of integers is used. Because this is a structured block,\nthe garbage collector will scan each word in this block, and the GC\nneeds to be able to distinguish between integers and pointers to other\nheap-allocated blocks (the GC does not have access to type information\nabout this array).</p>\n<p>Next the closure <code>((+) 2)</code> is created. The closure is represented by\nthis block allocated in the data segment:</p>\n<pre><code class=\"language-assembly\">        .data\n        .long   3319\n        .globl  Closure__1\nClosure__1:\n        .long   caml_curry2\n        .long   5\n        .long   Closure__fun_58\n</code></pre>\n<p>The header is 3319, indicating a <code>Closure_tag</code> with length 3 words. The\n3 words in the block are the address of the function <code>caml_curry2</code>, the\ninteger number 2 and the address of this function:</p>\n<pre><code class=\"language-assembly\">        .text\n        .globl  Closure__fun_58\nClosure__fun_58:\n\n        ; The function takes two arguments, %eax and %ebx.\n        ; This line causes the function to return %eax + %ebx - 1.\n\n        lea     -1(%eax, %ebx), %eax\n        ret\n</code></pre>\n<p>What does this function do? On the face of it, it adds the two\narguments, and subtracts one. But remember that <code>%eax</code> and <code>%ebx</code> are in\nthe OCaml representation for integers. Let's represent them as:</p>\n<ul>\n<li><code>%eax = 2 * a + 1</code>\n</li>\n<li><code>%ebx = 2 * b + 1</code>\n</li>\n</ul>\n<p>where <code>a</code> and <code>b</code> are the actual integer arguments. So this function\nreturns:</p>\n<pre><code>%eax + %ebx - 1\n= 2 * a + 1 + 2 * b + 1 - 1\n= 2 * a + 2 * b + 1\n= 2 * (a + b) + 1\n</code></pre>\n<p>In other words, this function returns the OCaml integer representation\nof the sum <code>a + b</code>. This function is <code>(+)</code>!</p>\n<p>(It's actually more subtle than this - to perform the mathematics\nquickly, OCaml uses the x86 addressing hardware in a way that probably\nwasn't intended by the designers of the x86.)</p>\n<p>So back to our closure - we won't go into the details of the\n<code>caml_curry2</code> function, but just say that this closure is the argument\n<code>2</code> applied to the function <code>(+)</code>, waiting for a second argument. Just\nas expected.</p>\n<p>The actual call to the <code>Array.map</code> function is quite difficult to\nunderstand, but the main points for our examination of OCaml is that the\ncode:</p>\n<ul>\n<li>Does call <code>Array.map</code> with an explicit closure.\n</li>\n<li>Does not attempt to inline the call and turn it into a loop.\n</li>\n</ul>\n<p>Calling <code>Array.map</code> in this way is undoubtedly slower than writing a\nloop over the array by hand. The overhead is mainly in the fact that the\nclosure must be evaluated for each element of the array, and that isn't\nas fast as inlining the closure as a function (if this optimization were\neven possible). However, if you had a more substantial closure than just\n<code>((+) 2)</code>, the overhead would be reduced. The FP version also saves\nexpensive <em>programmer</em> time versus writing the imperative loop.</p>\n<h2 id=\"profiling\">Profiling</h2>\n<p>There are two types of profiling that you can do on OCaml programs:</p>\n<ol>\n<li>Get execution counts for bytecode.\n</li>\n<li>Get real profiling for native code.\n</li>\n</ol>\n<p>The <code>ocamlcp</code> and <code>ocamlprof</code> programs perform profiling on bytecode.\nHere is an example:</p>\n<!-- $MDX file=examples/gc.ml -->\n<pre><code class=\"language-ocaml\">let rec iterate r x_init i =\n  if i = 1 then x_init\n  else\n    let x = iterate r x_init (i - 1) in\n    r *. x *. (1.0 -. x)\n\nlet () =\n  Random.self_init ();\n  Graphics.open_graph &quot; 640x480&quot;;\n  for x = 0 to 640 do\n    let r = 4.0 *. float_of_int x /. 640.0 in\n    for i = 0 to 39 do\n      let x_init = Random.float 1.0 in\n      let x_final = iterate r x_init 500 in\n      let y = int_of_float (x_final *. 480.) in\n      Graphics.plot x y\n    done\n  done;\n  Gc.print_stat stdout\n</code></pre>\n<p>And can be run and compiled with</p>\n<!-- $MDX skip -->\n<pre><code>$ ocamlcp -p a graphics.cma graphtest.ml -o graphtest\n$ ./graphtest\n$ ocamlprof graphtest.ml\n</code></pre>\n<p>The comments <code>(* nnn *)</code> are added by <code>ocamlprof</code>, showing how many\ntimes each part of the code was called.</p>\n<p>Profiling native code is done using your operating system's native\nsupport for profiling. In the case of Linux, we use <code>gprof</code>. An alternative\nis <a href=\"https://en.wikipedia.org/wiki/Perf_(Linux)\">perf</a>, as explained below.</p>\n<p>We compile it using the <code>-p</code> option to <code>ocamlopt</code> which tells the\ncompiler to include profiling information for <code>gprof</code>:</p>\n<p>After running the program as normal, the profiling code dumps out a file\n<code>gmon.out</code> which we can interpret with <code>gprof</code>:</p>\n<pre><code>$ gprof ./a.out\nFlat profile:\n  \nEach sample counts as 0.01 seconds.\n  %   cumulative   self              self     total\n time   seconds   seconds    calls   s/call   s/call  name\n 10.86      0.57     0.57     2109     0.00     0.00  sweep_slice\n  9.71      1.08     0.51     1113     0.00     0.00  mark_slice\n  7.24      1.46     0.38  4569034     0.00     0.00  Sieve__code_begin\n  6.86      1.82     0.36  9171515     0.00     0.00  Stream__set_data_140\n  6.57      2.17     0.34 12741964     0.00     0.00  fl_merge_block\n  6.29      2.50     0.33  4575034     0.00     0.00  Stream__peek_154\n  5.81      2.80     0.30 12561656     0.00     0.00  alloc_shr\n  5.71      3.10     0.30     3222     0.00     0.00  oldify_mopup\n  4.57      3.34     0.24 12561656     0.00     0.00  allocate_block\n  4.57      3.58     0.24  9171515     0.00     0.00  modify\n  4.38      3.81     0.23  8387342     0.00     0.00  oldify_one\n  3.81      4.01     0.20 12561658     0.00     0.00  fl_allocate\n  3.81      4.21     0.20  4569034     0.00     0.00  Sieve__filter_56\n  3.62      4.40     0.19     6444     0.00     0.00  empty_minor_heap\n  3.24      4.57     0.17     3222     0.00     0.00  oldify_local_roots\n  2.29      4.69     0.12  4599482     0.00     0.00  Stream__slazy_221\n  2.10      4.80     0.11  4597215     0.00     0.00  darken\n  1.90      4.90     0.10  4596481     0.00     0.00  Stream__fun_345\n  1.52      4.98     0.08  4575034     0.00     0.00  Stream__icons_207\n  1.52      5.06     0.08  4575034     0.00     0.00  Stream__junk_165\n  1.14      5.12     0.06     1112     0.00     0.00  do_local_roots\n  \n[ etc. ]\n</code></pre>\n<h3 id=\"using-perf-on-linux\">Using perf on Linux</h3>\n<p>Assuming perf is installed and your program is compiled into\nnative code with <code>-g</code> (or ocamlbuild tag <code>debug</code>), you just need to type</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-sh\">perf record --call-graph=dwarf -- ./foo.native a b c d\nperf report\n</code></pre>\n<p>The first command launches <code>foo.native</code> with arguments <code>a b c d</code> and\nrecords profiling information in <code>perf.data</code>; the second command\nstarts an interactive program to explore the call graph. The option\n<code>--call-graph=dwarf</code> makes perf aware of the calling convention of\nOCaml (with old versions of <code>perf</code>, enabling frame pointers in OCaml\nmight help; opam provides suitable compiler switches, such as <code>4.02.1+fp</code>).</p>\n<h2 id=\"summary\">Summary</h2>\n<p>In summary here are some tips for getting the best performance out of\nyour programs:</p>\n<ol>\n<li>Write your program as simply as possible. If it takes too long to\nrun, profile it to find out where it's spending its time and\nconcentrate optimizations on just those areas.\n</li>\n<li>Check for unintentional polymorphism, and add type hints for the\ncompiler.\n</li>\n<li>Closures are slower than simple function calls, but add to\nmaintainability and readability.\n</li>\n<li>As a last resort, rewrite hotspots in your program in C (but first\ncheck the assembly language produced by the OCaml compiler to see if\nyou can do better than it).\n</li>\n<li>Performance might depend on external factors (speed of your database\nqueries? speed of the network?). If so then no amount of\noptimization will help you.\n</li>\n</ol>\n<h3 id=\"further-reading\">Further reading</h3>\n<p>You can find out more about how OCaml represents different types by\nreading the (&quot;Interfacing C with OCaml&quot;) chapter in the OCaml manual and also\nlooking at the <code>mlvalues.h</code> header file.</p>\n<!--###  Java dynamic dispatch\n**There are some serious mistakes in the last paragraph:**\n\n* Dynamic method dispatch itself is seldom a performance problem. In\n languages without multiple inheritance (e.g. Java) this is usually\n done via one step of pointer indirection. Objects in OCaml are also\n dynamically dispatched. Since this is the point with polymorphism in\n an OO setting.\n\n* Dynamic method dispatch often hinders a compiler to inline function\n and this hits the performance.\n\n* In Java is a dynamic type check (aka cast) much more expensive than\n a dynamic method dispatch. -->\n","title":"Performance and Profiling","pageDescription":"Understand how to profile your OCaml code to analyse its performance and produce faster programs\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#speed\">Speed</a>\n</li>\n<li><a href=\"#profiling\">Profiling</a>\n</li>\n<li><a href=\"#summary\">Summary</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"performance-and-profiling"}},"__N_SSG":true}