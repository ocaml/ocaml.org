{"pageProps":{"content":{"source":"<p>This tutorial presents two techniques for debugging OCaml programs:</p>\n<ul>\n<li><a href=\"#Tracingfunctionscallsinthetoplevel\">Tracing functions calls</a>,\nwhich works in the interactive toplevel.\n</li>\n<li>The <a href=\"#The-OCaml-debugger\">OCaml debugger</a>, which allows analysing programs\ncompiled with <code>ocamlc</code>.\n</li>\n</ul>\n<h2 id=\"tracing-functions-calls-in-the-toplevel\">Tracing functions calls in the toplevel</h2>\n<p>The simplest way to debug programs in the toplevel is to follow the function\ncalls, by “tracing” the faulty function:</p>\n<pre><code class=\"language-ocaml\"># let rec fib x = if x &lt;= 1 then 1 else fib (x - 1) + fib (x - 2)\nval fib : int -&gt; int = &lt;fun&gt;\n# #trace fib\nfib is now traced.\n# fib 3\nfib &lt;-- 3\nfib &lt;-- 1\nfib --&gt; 1\nfib &lt;-- 2\nfib &lt;-- 0\nfib --&gt; 1\nfib &lt;-- 1\nfib --&gt; 1\nfib --&gt; 2\nfib --&gt; 3\n- : int = 3\n# #untrace fib\nfib is no longer traced.\n</code></pre>\n<h3 id=\"polymorphic-functions\">Polymorphic functions</h3>\n<p>A difficulty with polymorphic functions is that the output of the trace system\nis not very informative in case of polymorphic arguments and/or results.\nConsider a sorting algorithm (say bubble sort):</p>\n<pre><code class=\"language-ocaml\"># let exchange i j v =\n  let aux = v.(i) in\n    v.(i) &lt;- v.(j);\n    v.(j) &lt;- aux\nval exchange : int -&gt; int -&gt; 'a array -&gt; unit = &lt;fun&gt;\n# let one_pass_vect fin v =\n  for j = 1 to fin do\n    if v.(j - 1) &gt; v.(j) then exchange (j - 1) j v\n  done\nval one_pass_vect : int -&gt; 'a array -&gt; unit = &lt;fun&gt;\n# let bubble_sort_vect v =\n  for i = Array.length v - 1 downto 0 do\n    one_pass_vect i v\n  done\nval bubble_sort_vect : 'a array -&gt; unit = &lt;fun&gt;\n# let q = [|18; 3; 1|]\nval q : int array = [|18; 3; 1|]\n# #trace one_pass_vect\none_pass_vect is now traced.\n# bubble_sort_vect q\none_pass_vect &lt;-- 2\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]\none_pass_vect* --&gt; ()\none_pass_vect &lt;-- 1\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]\none_pass_vect* --&gt; ()\none_pass_vect &lt;-- 0\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]\none_pass_vect* --&gt; ()\n- : unit = ()\n</code></pre>\n<p>The function <code>one_pass_vect</code> being polymorphic, its vector argument is printed\nas a vector containing polymorphic values, <code>[|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]</code>, and\nthus we cannot properly follow the computation.</p>\n<p>A simple way to overcome this problem is to define a monomorphic version of the\nfaulty function. This is fairly easy using a <em>type constraint</em>.  Generally\nspeaking, this allows a proper understanding of the error in the definition of\nthe polymorphic function. Once this has been corrected, you just have to\nsuppress the type constraint to revert to a polymorphic version of the\nfunction.</p>\n<p>For our sorting routine, a single type constraint on the argument of the\n<code>exchange</code> function warranties a monomorphic typing, that allows a proper trace\nof function calls:</p>\n<pre><code class=\"language-ocaml\"># let exchange i j (v : int array) =    (* notice the type constraint *)\n  let aux = v.(i) in\n    v.(i) &lt;- v.(j);\n    v.(j) &lt;- aux\nval exchange : int -&gt; int -&gt; int array -&gt; unit = &lt;fun&gt;\n# let one_pass_vect fin v =\n  for j = 1 to fin do\n    if v.(j - 1) &gt; v.(j) then exchange (j - 1) j v\n  done\nval one_pass_vect : int -&gt; int array -&gt; unit = &lt;fun&gt;\n# let bubble_sort_vect v =\n  for i = Array.length v - 1 downto 0 do\n    one_pass_vect i v\n  done\nval bubble_sort_vect : int array -&gt; unit = &lt;fun&gt;\n# let q = [| 18; 3; 1 |]\nval q : int array = [|18; 3; 1|]\n# #trace one_pass_vect\none_pass_vect is now traced.\n# bubble_sort_vect q\none_pass_vect &lt;-- 2\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|18; 3; 1|]\none_pass_vect* --&gt; ()\none_pass_vect &lt;-- 1\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|3; 1; 18|]\none_pass_vect* --&gt; ()\none_pass_vect &lt;-- 0\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|1; 3; 18|]\none_pass_vect* --&gt; ()\n- : unit = ()\n</code></pre>\n<h3 id=\"limitations\">Limitations</h3>\n<p>To keep track of assignments to data structures and mutable variables in a\nprogram, the trace facility is not powerful enough. You need an extra mechanism\nto stop the program in any place and ask for internal values: that is a\nsymbolic debugger with its stepping feature.</p>\n<p>Stepping a functional program has a meaning which is a bit weird to define and\nunderstand. Let me say that we use the notion of <em>runtime events</em> that happen\nfor instance when a parameter is passed to a function or when entering a\npattern matching, or selecting a clause in a pttern matching. Computation\nprogress is taken into account by these events, independently of the\ninstructions executed on the hardware.</p>\n<p>Although this is difficult to implement, there exists such a debugger for OCaml\nunder Unix: <code>ocamldebug</code>. Its use is illustrated in the next section.</p>\n<p>In fact, for complex programs, it is likely the case that the programmer will\nuse explicit printing to find the bugs, since this methodology allows the\nreduction of the trace material: only useful data are printed and special\npurpose formats are more suited to get the relevant information, than what can\nbe output automatically by the generic pretty-printer used by the trace\nmechanism.</p>\n<h2 id=\"the-ocaml-debugger\">The OCaml debugger</h2>\n<p>We now give a quick tutorial for the OCaml debugger (<code>ocamldebug</code>).  Before\nstarting, please note that <code>ocamldebug</code> does not work under native Windows\nports of OCaml (but it runs under the Cygwin port).</p>\n<h3 id=\"launching-the-debugger\">Launching the debugger</h3>\n<p>Consider the following obviously wrong program written in the file\n<code>uncaught.ml</code>:</p>\n<pre><code class=\"language-ocaml\">(* file uncaught.ml *)\nlet l = ref []\nlet find_address name = List.assoc name !l\nlet add_address name address = l := (name, address) :: ! l\n\nlet () =\n  add_address &quot;IRIA&quot; &quot;Rocquencourt&quot;;;\n  print_string (find_address &quot;INRIA&quot;); print_newline ();;\n</code></pre>\n<pre><code class=\"language-mdx-error\">val l : (string * string) list ref = {contents = [(&quot;IRIA&quot;, &quot;Rocquencourt&quot;)]}\nval find_address : string -&gt; string = &lt;fun&gt;\nval add_address : string -&gt; string -&gt; unit = &lt;fun&gt;\nException: Not_found.\n</code></pre>\n<p>At runtime, the program raises an uncaught exception <code>Not_found</code>.  Suppose we\nwant to find where and why this exception has been raised, we can proceed as\nfollows. First, we compile the program in debug mode:</p>\n<pre><code>ocamlc -g uncaught.ml\n</code></pre>\n<p>We launch the debugger:</p>\n<pre><code>ocamldebug a.out\n</code></pre>\n<p>Then the debugger answers with a banner and a prompt:</p>\n<pre><code>OCaml Debugger version 4.12.0\n\n(ocd)\n</code></pre>\n<h3 id=\"finding-the-cause-of-a-spurious-exception\">Finding the cause of a spurious exception</h3>\n<p>Type <code>r</code> (for <em>run</em>); you get</p>\n<pre><code>(ocd) r\nLoading program... done.\nTime : 12\nProgram end.\nUncaught exception: Not_found\n(ocd)\n</code></pre>\n<p>Self explanatory, isn't it? So, you want to step backward to set the program\ncounter before the time the exception is raised; hence type in <code>b</code> as\n<em>backstep</em>, and you get</p>\n<pre><code>(ocd) b\nTime : 11 - pc : 15500 - module List\n143     [] -&gt; &lt;|b|&gt;raise Not_found\n</code></pre>\n<p>The debugger tells you that you are in module <code>List</code>, inside a pattern matching\non a list that already chose the <code>[]</code> case and is about to execute <code>raise Not_found</code>, since the program is stopped just before this expression (as\nwitnessed by the <code>&lt;|b|&gt;</code> mark).</p>\n<p>But, as you know, you want the debugger to tell you which procedure calls the\none from <code>List</code>, and also who calls the procedure that calls the one from\n<code>List</code>; hence, you want a backtrace of the execution stack:</p>\n<pre><code>(ocd) bt\n#0  Pc : 15500  List char 3562\n#1  Pc : 19128  Uncaught char 221\n</code></pre>\n<p>So the last function called is from module <code>List</code> at character 3562, that is:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec assoc x = function\n  | [] -&gt; raise Not_found\n          ^\n  | (a,b)::l -&gt; if a = x then b else assoc x l\n</code></pre>\n<p>The function that calls it is in module <code>Uncaught</code>, file <code>uncaught.ml</code> char\n221:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">print_string (find_address &quot;INRIA&quot;); print_newline ();;\n                                  ^\n</code></pre>\n<p>To sum up: if you're developing a program you can compile it with the <code>-g</code>\noption, to be ready to debug the program if necessary. Hence, to find a\nspurious exception you just need to type <code>ocamldebug a.out</code>, then <code>r</code>, <code>b</code>, and\n<code>bt</code> gives you the backtrace.</p>\n<h3 id=\"getting-help-and-info-in-the-debugger\">Getting help and info in the debugger</h3>\n<p>To get more info about the current status of the debugger you can ask it\ndirectly at the toplevel prompt of the debugger; for instance:</p>\n<pre><code>(ocd) info breakpoints\nNo breakpoint.\n\n(ocd) help break\n  1      15396  in List, character 3539\nbreak : Set breakpoint at specified line or function.\nSyntax: break function-name\nbreak @ [module] linenum\nbreak @ [module] # characternum\n</code></pre>\n<h3 id=\"setting-break-points\">Setting break points</h3>\n<p>Let's set up a breakpoint and rerun the entire program from the\nbeginning (<code>(g)oto 0</code> then <code>(r)un</code>):</p>\n<pre><code>(ocd) break @Uncaught 9\nBreakpoint 3 at 19112 : file Uncaught, line 9 column 34\n\n(ocd) g 0\nTime : 0\nBeginning of program.\n\n(ocd) r\nTime : 6 - pc : 19112 - module Uncaught\nBreakpoint : 1\n9 add &quot;IRIA&quot; &quot;Rocquencourt&quot;&lt;|a|&gt;;;\n</code></pre>\n<p>Then, we can step and find what happens when <code>find_address</code> is about to be\ncalled</p>\n<pre><code>(ocd) s\nTime : 7 - pc : 19012 - module Uncaught\n5 let find_address name = &lt;|b|&gt;List.assoc name !l;;\n\n(ocd) p name\nname : string = &quot;INRIA&quot;\n\n(ocd) p !l\n$1 : (string * string) list = [&quot;IRIA&quot;, &quot;Rocquencourt&quot;]\n(ocd)\n</code></pre>\n<p>Now we can guess why <code>List.assoc</code> will fail to find &quot;INRIA&quot; in the list...</p>\n<h3 id=\"using-the-debugger-under-emacs\">Using the debugger under Emacs</h3>\n<p>Under Emacs you call the debugger using <code>ESC-x</code> <code>ocamldebug a.out</code>. Then Emacs\nwill send you directly to the file and character reported by the debugger, and\nyou can step back and forth using <code>ESC-b</code> and <code>ESC-s</code>, you can set up break\npoints using <code>CTRL-X space</code>, and so on...</p>\n","title":"Debug","pageDescription":"Learn to build custom types and write function to process this data\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#tracing-functions-calls-in-the-toplevel\">Tracing functions calls in the toplevel</a>\n</li>\n<li><a href=\"#the-ocaml-debugger\">The OCaml debugger</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"debug"}},"__N_SSG":true}