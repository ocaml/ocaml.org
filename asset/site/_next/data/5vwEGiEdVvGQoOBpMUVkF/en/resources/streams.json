{"pageProps":{"content":{"source":"<p>Suppose you need to process each line of a text file. One way to do this\nis to read the file in as a single large string and use something like\n<code>Str.split</code> to turn it into a list. This works when the file is small,\nbut because the entire file is loaded into memory, it does not scale\nwell when the file is large.</p>\n<p>More commonly, the <code>input_line</code> function can be used to read one line at\na time from a channel. This typically looks like:</p>\n<pre><code class=\"language-ocaml\">let in_channel = open_in &quot;lines.txt&quot; in\ntry\n  while true do\n    let line = input_line in_channel in\n    (* do something with line *)\n  done\nwith End_of_file -&gt;\n  close_in in_channel\n</code></pre>\n<pre><code class=\"language-mdx-error\">Line 6, characters 5-9:\nError: Syntax error\n</code></pre>\n<p>The above code is efficient with memory, but it can be inconvenient in\nother ways. Since <code>input_line</code> only works with the <code>in_channel</code> type, it\ncannot be reused in cases where the text is already in memory. The\n<code>End_of_file</code> exception can be raised at any point during iteration, and\nit is the programmer's responsibility to ensure that the file is closed\nappropriately. In fact, if there is any other exception in the above\nexample, the file will not be closed at all. Altogether, there is a lot\ngoing on: channels, I/O, exceptions, and files.</p>\n<p>Streams offer an abstraction over one part of this process: reading\nitems from a sequence. They don't assume anything about files or\nchannels, and they replace the <code>End_of_file</code> exception with a more\nstructured approach to dealing with the end of input. Here is a function\nthat builds a stream of lines from an input channel:</p>\n<pre><code class=\"language-ocaml\"># let line_stream_of_channel channel =\n  Stream.from\n    (fun _ -&gt;\n       try Some (input_line channel) with End_of_file -&gt; None)\nval line_stream_of_channel : in_channel -&gt; string Stream.t = &lt;fun&gt;\n</code></pre>\n<p>The &quot;Stream.from&quot; function builds a stream from a callback function.\nThis function is passed the current stream count (starting with 0) as an\nargument and is expected to return an <code>'a option</code>. If the option has a\nvalue (<code>Some x</code>), that value will be the next item in the stream. If it\nhas no value (<code>None</code>), this indicates that the stream is empty and no\nfurther reads will be attempted. Since the option is polymorphic,\n<code>Stream.from</code> can construct streams of any type. These streams have a\ntype of <code>'a Stream.t</code>.</p>\n<p>With this simple function, we can now easily construct line streams from\nany input channel:</p>\n<pre><code class=\"language-ocaml\"># let in_channel = open_in &quot;019_streams.md&quot;\nval in_channel : in_channel = &lt;abstr&gt;\n# let lines = line_stream_of_channel in_channel\nval lines : string Stream.t = &lt;abstr&gt;\n</code></pre>\n<p>This variable <code>lines</code> is a stream of strings, one string per line. We\ncan now begin reading lines from it by passing it to <code>Stream.next</code>:</p>\n<pre><code class=\"language-ocaml\"># Stream.next lines\n- : string = &quot;---&quot;\n# Stream.next lines\n- : string = &quot;title: Streams&quot;\n# Stream.next lines\n- : string = &quot;description: &gt;&quot;\n# Stream.next lines\n- : string =\n&quot;  Streams offer an abstraction over consuming items from sequences&quot;\n# while true do ignore(Stream.next lines) done\nException: Stdlib.Stream.Failure.\n</code></pre>\n<p>As you can see, <code>Stream.next</code> either returns the next item in the stream\nor raises a <code>Stream.Failure</code> exception indicating that the stream is\nempty. Likewise, with a little help from the <code>Stream.of_list</code>\nconstructor and the <code>Str</code> regular expression module, we could build a\nstream of lines from a string in memory:</p>\n<pre><code class=\"language-ocaml\"># #load &quot;str.cma&quot;\n# let line_stream_of_string string =\n  Stream.of_list (Str.split (Str.regexp &quot;\\n&quot;) string)\nval line_stream_of_string : string -&gt; string Stream.t = &lt;fun&gt;\n</code></pre>\n<p>and these streams could be used exactly the same way:</p>\n<pre><code class=\"language-ocaml\"># let lines = line_stream_of_string &quot;hello\\nstream\\nworld&quot;\nval lines : string Stream.t = &lt;abstr&gt;\n# Stream.next lines\n- : string = &quot;hello&quot;\n# Stream.next lines\n- : string = &quot;stream&quot;\n# Stream.next lines\n- : string = &quot;world&quot;\n# Stream.next lines\nException: Stdlib.Stream.Failure.\n</code></pre>\n<p>Since both cases raise <code>Stream.Failure</code> on an empty stream, there is no\nneed to worry about catching <code>End_of_file</code> in the case of file I/O. This\nunified interface makes it much easier to write functions that can\nreceive data from multiple sources.</p>\n<p>The <code>Stream.iter</code> function automates the common task of performing an\noperation for each item. With it, we can rewrite the original example as\nfollows:</p>\n<pre><code class=\"language-ocaml\">let in_channel = open_in &quot;019_streams.md&quot; in\ntry\n  Stream.iter\n    (fun line -&gt;\n       (* do something with line *)\n       print_endline line)\n    (line_stream_of_channel in_channel);\n  close_in in_channel\nwith e -&gt;\n  close_in in_channel;\n  raise e\n</code></pre>\n<p>Note how much easier it is to handle I/O exceptions properly, since we\ncan deal with them independently from the end-of-file condition. This\nseparation of concerns allows us to decompose this into simpler and more\nreusable functions:</p>\n<pre><code class=\"language-ocaml\"># let process_line line =\n  print_endline line\nval process_line : string -&gt; unit = &lt;fun&gt;\n\n# let process_lines lines =\n  Stream.iter process_line lines\nval process_lines : string Stream.t -&gt; unit = &lt;fun&gt;\n\n# let process_file filename =\n  let in_channel = open_in filename in\n  try\n    process_lines (line_stream_of_channel in_channel);\n    close_in in_channel\n  with e -&gt;\n    close_in in_channel;\n    raise e\nval process_file : string -&gt; unit = &lt;fun&gt;\n\n# let process_string string =\n  process_lines (line_stream_of_string string)\nval process_string : string -&gt; unit = &lt;fun&gt;\n</code></pre>\n<h2 id=\"constructing-streams\">Constructing streams</h2>\n<p>In the above examples, we saw two methods for constructing streams:</p>\n<ul>\n<li>Stream.from, which builds a stream from a callback function\n</li>\n<li>Stream.of_list, which builds a stream from a list in memory\n</li>\n</ul>\n<p>The <code>Stream</code> module provides a few other stream builders:</p>\n<ul>\n<li>Stream.of_string, which builds a character stream from a string\n</li>\n<li>Stream.of_channel, which builds a character stream from a channel\n</li>\n</ul>\n<p><code>Stream.from</code> is the most general, and it can be used to produce streams\nof any type. It is not limited to I/O and can even produce infinite\nsequences. Here are a few simple stream builders defined with\n<code>Stream.from</code>:</p>\n<pre><code class=\"language-ocaml\"># let empty_stream () = Stream.from (fun _ -&gt; None)\nval empty_stream : unit -&gt; 'a Stream.t = &lt;fun&gt;\n# let const_stream k = Stream.from (fun _ -&gt; Some k)\nval const_stream : 'a -&gt; 'a Stream.t = &lt;fun&gt;\n# let count_stream i = Stream.from (fun j -&gt; Some (i + j))\nval count_stream : int -&gt; int Stream.t = &lt;fun&gt;\n</code></pre>\n<h2 id=\"deconstructing-streams\">Deconstructing streams</h2>\n<p>We already saw the <code>Stream.next</code> function, which retrieves a single item\nfrom a stream. There is another way to work with streams that is often\npreferable: <code>Stream.peek</code> and <code>Stream.junk</code>. When used together, these\nfunctions allow you to see what the next item would be. This feature,\nknown as &quot;look ahead&quot;, is very useful when writing parsers. Even if you\ndon't need to look ahead, the peek/junk protocol may be nicer to work\nwith because it uses options instead of exceptions:</p>\n<pre><code class=\"language-ocaml\"># let lines = line_stream_of_string &quot;hello\\nworld&quot;\nval lines : string Stream.t = &lt;abstr&gt;\n# Stream.peek lines\n- : string option = Some &quot;hello&quot;\n# Stream.peek lines\n- : string option = Some &quot;hello&quot;\n# Stream.junk lines\n- : unit = ()\n# Stream.peek lines\n- : string option = Some &quot;world&quot;\n# Stream.junk lines\n- : unit = ()\n# Stream.peek lines\n- : string option = None\n</code></pre>\n<p>As you can see, it is necessary to call <code>Stream.junk</code> to advance to the\nnext item. <code>Stream.peek</code> will always give you either the next item or\n<code>None</code>, and it will never fail. Likewise, <code>Stream.junk</code> always succeeds\n(even if the stream is empty).</p>\n<h2 id=\"a-more-complex-streamfrom-example\">A more complex <code>Stream.from</code> example</h2>\n<p>Here is a function that converts a line stream into a paragraph stream.\nAs such, it is both a stream consumer and a stream producer.</p>\n<pre><code class=\"language-ocaml\"># let paragraphs lines =\n  let rec next para_lines i =\n    match Stream.peek lines, para_lines with\n    | None, [] -&gt; None\n    | Some &quot;&quot;, [] -&gt;\n        Stream.junk lines;\n        next para_lines i\n    | Some &quot;&quot;, _ | None, _ -&gt;\n        Some (String.concat &quot;\\n&quot; (List.rev para_lines))\n    | Some line, _ -&gt;\n        Stream.junk lines;\n        next (line :: para_lines) i in\n  Stream.from (next [])\nval paragraphs : string Stream.t -&gt; string Stream.t = &lt;fun&gt;\n</code></pre>\n<p>This function uses an extra parameter to <code>next</code> (the <code>Stream.from</code>\ncallback) called <code>para_lines</code> in order to collect the lines for each\nparagraph. Paragraphs are delimited by any number of blank lines.</p>\n<p>Each time <code>next</code> is called, a <code>match</code> expression tests two values: the\nnext line in the stream, and the contents of <code>para_lines</code>. Four cases\nare handled:</p>\n<ol>\n<li>If the end of the stream is reached and no lines have been\ncollected, the paragraph stream ends as well.\n</li>\n<li>If the next line is blank and no lines have been collected, the\nblank is ignored and <code>next</code> is called recursively to keep looking\nfor a non-blank line.\n</li>\n<li>If a blank line or end of stream is reached and lines <strong>have</strong> been\ncollected, the paragraph is returned by concatenating <code>para_lines</code>\nto a single string.\n</li>\n<li>Finally, if a non-blank line has been reached, the line is collected\nby recursively calling <code>para_lines</code>.\n</li>\n</ol>\n<p>Happily, we can rely on the OCaml compiler's exhaustiveness checking to\nensure that we are handling all possible cases.</p>\n<p>With this new tool, we can now work just as easily with paragraphs as we\ncould before with lines:</p>\n<pre><code class=\"language-ocaml\">(* Print each paragraph, followed by a separator. *)\nlet lines = line_stream_of_channel in_channel in\nStream.iter\n  (fun para -&gt;\n     print_endline para;\n     print_endline &quot;--&quot;)\n  (paragraphs lines)\n</code></pre>\n<p>Functions like <code>paragraphs</code> that produce and consume streams can be\ncomposed together in a manner very similar to UNIX pipes and filters.</p>\n<h2 id=\"stream-combinators\">Stream combinators</h2>\n<p>Just like lists and arrays, common iteration patterns such as <code>map</code>,\n<code>filter</code>, and <code>fold</code> can be very useful. The <code>Stream</code> module does not\nprovide such functions, but they can be built easily using\n<code>Stream.from</code>:</p>\n<pre><code class=\"language-ocaml\"># let stream_map f stream =\n  let rec next i =\n    try Some (f (Stream.next stream))\n    with Stream.Failure -&gt; None in\n  Stream.from next\nval stream_map : ('a -&gt; 'b) -&gt; 'a Stream.t -&gt; 'b Stream.t = &lt;fun&gt;\n\n# let stream_filter p stream =\n  let rec next i =\n    try\n      let value = Stream.next stream in\n      if p value then Some value else next i\n    with Stream.Failure -&gt; None in\n  Stream.from next\nval stream_filter : ('a -&gt; bool) -&gt; 'a Stream.t -&gt; 'a Stream.t = &lt;fun&gt;\n\n# let stream_fold f stream init =\n  let result = ref init in\n  Stream.iter\n    (fun x -&gt; result := f x !result)\n    stream;\n  !result\nval stream_fold : ('a -&gt; 'b -&gt; 'b) -&gt; 'a Stream.t -&gt; 'b -&gt; 'b = &lt;fun&gt;\n</code></pre>\n<p>For example, here is a stream of leap years starting with 2000:</p>\n<pre><code class=\"language-ocaml\"># let is_leap year =\n  year mod 4 = 0 &amp;&amp; (year mod 100 &lt;&gt; 0 || year mod 400 = 0)\nval is_leap : int -&gt; bool = &lt;fun&gt;\n# let leap_years = stream_filter is_leap (count_stream 2000)\nval leap_years : int Stream.t = &lt;abstr&gt;\n</code></pre>\n<p>We can use the <code>Stream.npeek</code> function to look ahead by more than one\nitem. In this case, we'll peek at the next 30 items to make sure that\nthe year 2100 is not a leap year (since it's divisible by 100 but not\n400!):</p>\n<pre><code class=\"language-ocaml\"># Stream.npeek 30 leap_years\n- : int list =\n[2000; 2004; 2008; 2012; 2016; 2020; 2024; 2028; 2032; 2036; 2040; 2044;\n 2048; 2052; 2056; 2060; 2064; 2068; 2072; 2076; 2080; 2084; 2088; 2092;\n 2096; 2104; 2108; 2112; 2116; 2120]\n</code></pre>\n<p>Note that we must be careful not to use <code>Stream.iter</code> on an infinite\nstream like <code>leap_years</code>. This applies to <code>stream_fold</code>, as well as any\nfunction that attempts to consume the entire stream.</p>\n<pre><code class=\"language-ocaml\"># stream_fold (+) (Stream.of_list [1; 2; 3]) 0\n- : int = 6\n</code></pre>\n<p><code>stream_fold (+) (count_stream 0) 0</code> runs forever.</p>\n<h2 id=\"other-useful-stream-builders\">Other useful stream builders</h2>\n<p>The previously defined <code>const_stream</code> function builds a stream that\nrepeats a single value. It is also useful to build a stream that repeats\na sequence of values. The following function does just that:</p>\n<pre><code class=\"language-ocaml\"># let cycle items =\n  let buf = ref [] in\n  let rec next i =\n    if !buf = [] then buf := items;\n    match !buf with\n      | h :: t -&gt; (buf := t; Some h)\n      | [] -&gt; None in\n  Stream.from next\nval cycle : 'a list -&gt; 'a Stream.t = &lt;fun&gt;\n</code></pre>\n<p>One common task that can benefit from this kind of stream is the\ngeneration of alternating background colors for HTML. By using <code>cycle</code>\nwith <code>stream_combine</code>, explained in the next section, an infinite stream\nof background colors can be combined with a finite stream of data to\nproduce a sequence of HTML blocks:</p>\n<pre><code class=\"language-ocaml\"># let stream_combine stream1 stream2 =\n  let rec next i =\n    try Some (Stream.next stream1, Stream.next stream2)\n    with Stream.Failure -&gt; None in\n  Stream.from next\nval stream_combine : 'a Stream.t -&gt; 'b Stream.t -&gt; ('a * 'b) Stream.t = &lt;fun&gt;\n# Stream.iter print_endline\n  (stream_map\n     (fun (bg, s) -&gt;\n        Printf.sprintf &quot;&lt;div style='background: %s'&gt;%s&lt;/div&gt;&quot; bg s)\n     (stream_combine\n        (cycle [&quot;#eee&quot;; &quot;#fff&quot;])\n        (Stream.of_list [&quot;hello&quot;; &quot;html&quot;; &quot;world&quot;])))\n&lt;div style='background: #eee'&gt;hello&lt;/div&gt;\n&lt;div style='background: #fff'&gt;html&lt;/div&gt;\n&lt;div style='background: #eee'&gt;world&lt;/div&gt;\n- : unit = ()\n</code></pre>\n<p>Here is a simple <code>range</code> function that produces a sequence of integers:</p>\n<pre><code class=\"language-ocaml\"># let range ?(start=0) ?(stop=0) ?(step=1) () =\n  let in_range = if step &lt; 0 then (&gt;) else (&lt;) in\n  let current = ref start in\n  let rec next i =\n    if in_range !current stop\n    then let result = !current in (current := !current + step;\n                                   Some result)\n    else None in\n  Stream.from next\nval range : ?start:int -&gt; ?stop:int -&gt; ?step:int -&gt; unit -&gt; int Stream.t =\n  &lt;fun&gt;\n</code></pre>\n<p>This works just like Python's <code>xrange</code> built-in function, providing an\neasy way to produce an assortment of lazy integer sequences by\nspecifying combinations of <code>start</code>, <code>stop</code>, or <code>step</code> values:</p>\n<pre><code class=\"language-ocaml\"># Stream.npeek 10 (range ~start:5 ~stop:10 ())\n- : int list = [5; 6; 7; 8; 9]\n# Stream.npeek 10 (range ~stop:10 ~step:2 ())\n- : int list = [0; 2; 4; 6; 8]\n# Stream.npeek 10 (range ~start:10 ~step:(-1) ())\n- : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]\n# Stream.npeek 10 (range ~start:10 ~stop:5 ~step:(-1) ())\n- : int list = [10; 9; 8; 7; 6]\n</code></pre>\n<h2 id=\"combining-streams\">Combining streams</h2>\n<p>There are several ways to combine streams. One is to produce a stream of\nstreams and then concatenate them into a single stream. The following\nfunction works just like <code>List.concat</code>, but instead of turning a list of\nlists into a list, it turns a stream of streams into a stream:</p>\n<pre><code class=\"language-ocaml\"># let stream_concat streams =\n  let current_stream = ref None in\n  let rec next i =\n    try\n      let stream =\n        match !current_stream with\n        | Some stream -&gt; stream\n        | None -&gt;\n           let stream = Stream.next streams in\n           current_stream := Some stream;\n           stream in\n      try Some (Stream.next stream)\n      with Stream.Failure -&gt; (current_stream := None; next i)\n    with Stream.Failure -&gt; None in\n  Stream.from next\nval stream_concat : 'a Stream.t Stream.t -&gt; 'a Stream.t = &lt;fun&gt;\n</code></pre>\n<p>Here is a sequence of ranges which are themselves derived from a range,\nconcatenated with <code>stream_concat</code> to produce a flattened <code>int Stream.t</code>.</p>\n<pre><code class=\"language-ocaml\"># Stream.npeek 10\n  (stream_concat\n     (stream_map\n        (fun i -&gt; range ~stop:i ())\n        (range ~stop:5 ())))\n- : int list = [0; 0; 1; 0; 1; 2; 0; 1; 2; 3]\n</code></pre>\n<p>Another way to combine streams is to iterate through them in a pairwise\nfashion:</p>\n<pre><code class=\"language-ocaml\"># let stream_combine stream1 stream2 =\n  let rec next i =\n    try Some (Stream.next stream1, Stream.next stream2)\n    with Stream.Failure -&gt; None in\n  Stream.from next\nval stream_combine : 'a Stream.t -&gt; 'b Stream.t -&gt; ('a * 'b) Stream.t = &lt;fun&gt;\n</code></pre>\n<p>This is useful, for instance, if you have a stream of keys and a stream\nof corresponding values. Iterating through key value pairs is then as\nsimple as:</p>\n<pre><code class=\"language-ocaml\">Stream.iter\n  (fun (key, value) -&gt;\n     (* do something with 'key' and 'value' *)\n     ())\n  (stream_combine key_stream value_stream)\n</code></pre>\n<pre><code class=\"language-mdx-error\">Line 5, characters 21-31:\nError: Unbound value key_stream\n</code></pre>\n<p>Since <code>stream_combine</code> stops as soon as either of its input streams runs\nout, it can be used to combine an infinite stream with a finite one.\nThis provides a neat way to add indexes to a sequence:</p>\n<pre><code class=\"language-ocaml\"># let items = [&quot;this&quot;; &quot;is&quot;; &quot;a&quot;; &quot;test&quot;]\nval items : string list = [&quot;this&quot;; &quot;is&quot;; &quot;a&quot;; &quot;test&quot;]\n# Stream.iter\n  (fun (index, value) -&gt;\n     Printf.printf &quot;%d. %s\\n%!&quot; index value)\n  (stream_combine (count_stream 1) (Stream.of_list items))\n1. this\n2. is\n3. a\n4. test\n- : unit = ()\n</code></pre>\n<h2 id=\"copying-streams\">Copying streams</h2>\n<p>Streams are destructive; once you discard an item in a stream, it is no\nlonger available unless you save a copy somewhere. What if you want to\nuse the same stream more than once? One way is to create a &quot;tee&quot;. The\nfollowing function creates two output streams from one input stream,\nintelligently queueing unseen values until they have been produced by\nboth streams:</p>\n<pre><code class=\"language-ocaml\"># let stream_tee stream =\n  let next self other i =\n    try\n      if Queue.is_empty self\n      then\n        let value = Stream.next stream in\n        Queue.add value other;\n        Some value\n      else\n        Some (Queue.take self)\n    with Stream.Failure -&gt; None in\n  let q1 = Queue.create () in\n  let q2 = Queue.create () in\n  (Stream.from (next q1 q2), Stream.from (next q2 q1))\nval stream_tee : 'a Stream.t -&gt; 'a Stream.t * 'a Stream.t = &lt;fun&gt;\n</code></pre>\n<p>Here is an example of a stream tee in action:</p>\n<pre><code class=\"language-ocaml\"># let letters = Stream.of_list ['a'; 'b'; 'c'; 'd'; 'e']\nval letters : char Stream.t = &lt;abstr&gt;\n# let s1, s2 = stream_tee letters\nval s1 : char Stream.t = &lt;abstr&gt;\nval s2 : char Stream.t = &lt;abstr&gt;\n# Stream.next s1\n- : char = 'a'\n# Stream.next s1\n- : char = 'b'\n# Stream.next s2\n- : char = 'a'\n# Stream.next s1\n- : char = 'c'\n# Stream.next s2\n- : char = 'b'\n# Stream.next s2\n- : char = 'c'\n</code></pre>\n<p>Again, since streams are destructive, you probably want to leave the\noriginal stream alone or you will lose items from the copied streams:</p>\n<pre><code class=\"language-ocaml\"># Stream.next letters\n- : char = 'd'\n# Stream.next s1\n- : char = 'e'\n# Stream.next s2\n- : char = 'e'\n</code></pre>\n<h2 id=\"converting-streams\">Converting streams</h2>\n<p>Here are a few functions for converting between streams and lists,\narrays, and hash tables. These probably belong in the standard library,\nbut they are simple to define anyhow. Again, beware of infinite streams,\nwhich will cause these functions to hang.</p>\n<pre><code class=\"language-ocaml\"># let stream_of_list = Stream.of_list\nval stream_of_list : 'a list -&gt; 'a Stream.t = &lt;fun&gt;\n# let list_of_stream stream =\n  let result = ref [] in\n  Stream.iter (fun value -&gt; result := value :: !result) stream;\n  List.rev !result\nval list_of_stream : 'a Stream.t -&gt; 'a list = &lt;fun&gt;\n# let stream_of_array array =\n  Stream.of_list (Array.to_list array)\nval stream_of_array : 'a array -&gt; 'a Stream.t = &lt;fun&gt;\n# let array_of_stream stream =\n  Array.of_list (list_of_stream stream)\nval array_of_stream : 'a Stream.t -&gt; 'a array = &lt;fun&gt;\n# let stream_of_hash hash =\n  let result = ref [] in\n  Hashtbl.iter\n    (fun key value -&gt; result := (key, value) :: !result)\n    hash;\n  Stream.of_list !result\nval stream_of_hash : ('a, 'b) Hashtbl.t -&gt; ('a * 'b) Stream.t = &lt;fun&gt;\n# let hash_of_stream stream =\n  let result = Hashtbl.create 0 in\n  Stream.iter\n    (fun (key, value) -&gt; Hashtbl.replace result key value)\n    stream;\n  result\nval hash_of_stream : ('a * 'b) Stream.t -&gt; ('a, 'b) Hashtbl.t = &lt;fun&gt;\n</code></pre>\n<p>What if you want to convert arbitrary data types to streams? Well, if the\ndata type defines an <code>iter</code> function, and you don't mind using threads,\nyou can use a producer-consumer arrangement to invert control:</p>\n<pre><code class=\"language-ocaml\"># #directory &quot;+threads&quot;;;\n# #load &quot;threads.cma&quot;;;\n# let elements iter coll =\n  let channel = Event.new_channel () in\n  let producer () =\n    let () =\n      iter (fun x -&gt; Event.sync (Event.send channel (Some x))) coll in\n    Event.sync (Event.send channel None) in\n  let consumer i =\n    Event.sync (Event.receive channel) in\n  ignore (Thread.create producer ());\n  Stream.from consumer\nval elements : (('a -&gt; unit) -&gt; 'b -&gt; unit) -&gt; 'b -&gt; 'a Stream.t = &lt;fun&gt;\n</code></pre>\n<p>Now it is possible to build a stream from an <code>iter</code> function and a\ncorresponding value:</p>\n<pre><code class=\"language-ocaml\"># module StringSet = Set.Make(String)\nmodule StringSet :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -&gt; bool\n    val mem : elt -&gt; t -&gt; bool\n    val add : elt -&gt; t -&gt; t\n    val singleton : elt -&gt; t\n    val remove : elt -&gt; t -&gt; t\n    val union : t -&gt; t -&gt; t\n    val inter : t -&gt; t -&gt; t\n    val disjoint : t -&gt; t -&gt; bool\n    val diff : t -&gt; t -&gt; t\n    val compare : t -&gt; t -&gt; int\n    val equal : t -&gt; t -&gt; bool\n    val subset : t -&gt; t -&gt; bool\n    val iter : (elt -&gt; unit) -&gt; t -&gt; unit\n    val map : (elt -&gt; elt) -&gt; t -&gt; t\n    val fold : (elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a\n    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool\n    val exists : (elt -&gt; bool) -&gt; t -&gt; bool\n    val filter : (elt -&gt; bool) -&gt; t -&gt; t\n    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t\n    val cardinal : t -&gt; int\n    val elements : t -&gt; elt list\n    val min_elt : t -&gt; elt\n    val min_elt_opt : t -&gt; elt option\n    val max_elt : t -&gt; elt\n    val max_elt_opt : t -&gt; elt option\n    val choose : t -&gt; elt\n    val choose_opt : t -&gt; elt option\n    val split : elt -&gt; t -&gt; t * bool * t\n    val find : elt -&gt; t -&gt; elt\n    val find_opt : elt -&gt; t -&gt; elt option\n    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt\n    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option\n    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt\n    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option\n    val of_list : elt list -&gt; t\n    val to_seq_from : elt -&gt; t -&gt; elt Seq.t\n    val to_seq : t -&gt; elt Seq.t\n    val add_seq : elt Seq.t -&gt; t -&gt; t\n    val of_seq : elt Seq.t -&gt; t\n  end\n# let set = StringSet.empty\nval set : StringSet.t = &lt;abstr&gt;\n# let set = StringSet.add &quot;here&quot; set\nval set : StringSet.t = &lt;abstr&gt;\n# let set = StringSet.add &quot;are&quot; set\nval set : StringSet.t = &lt;abstr&gt;\n# let set = StringSet.add &quot;some&quot; set\nval set : StringSet.t = &lt;abstr&gt;\n# let set = StringSet.add &quot;values&quot; set\nval set : StringSet.t = &lt;abstr&gt;\n# let stream = elements StringSet.iter set\nval stream : string Stream.t = &lt;abstr&gt;\n# Stream.iter print_endline stream\nare\nhere\nsome\nvalues\n- : unit = ()\n</code></pre>\n<p>Some data types, like Hashtbl and Map, provide an <code>iter</code> function that\niterates through key-value pairs. Here's a function for those, too:</p>\n<pre><code class=\"language-ocaml\"># let items iter coll =\n  let channel = Event.new_channel () in\n  let producer () =\n    let () =\n      iter (fun k v -&gt;\n              Event.sync (Event.send channel (Some (k, v)))) coll in\n    Event.sync (Event.send channel None) in\n  let consumer i =\n    Event.sync (Event.receive channel) in\n  ignore (Thread.create producer ());\n  Stream.from consumer\nval items : (('a -&gt; 'b -&gt; unit) -&gt; 'c -&gt; unit) -&gt; 'c -&gt; ('a * 'b) Stream.t =\n  &lt;fun&gt;\n</code></pre>\n<p>If we want just the keys, or just the values, it is simple to transform\nthe output of <code>items</code> using <code>stream_map</code>:</p>\n<pre><code class=\"language-ocaml\"># let keys iter coll = stream_map (fun (k, v) -&gt; k) (items iter coll)\nval keys : (('a -&gt; 'b -&gt; unit) -&gt; 'c -&gt; unit) -&gt; 'c -&gt; 'a Stream.t = &lt;fun&gt;\n# let values iter coll = stream_map (fun (k, v) -&gt; v) (items iter coll)\nval values : (('a -&gt; 'b -&gt; unit) -&gt; 'c -&gt; unit) -&gt; 'c -&gt; 'b Stream.t = &lt;fun&gt;\n</code></pre>\n<p>Keep in mind that these techniques spawn producer threads which carry a\nfew risks: they only terminate when they have finished iterating, and\nany change to the original data structure while iterating may produce\nunexpected results.</p>\n<h2 id=\"other-built-in-stream-functions\">Other built-in Stream functions</h2>\n<p>There are a few other documented methods in the <code>Stream</code> module:</p>\n<ul>\n<li>Stream.empty, which raises <code>Stream.Failure</code> unless a stream is empty\n</li>\n<li>Stream.count, which returns the stream count (number of discarded\nelements)\n</li>\n</ul>\n<p>In addition, there are a few undocumented functions: <code>iapp</code>, <code>icons</code>,\n<code>ising</code>, <code>lapp</code>, <code>lcons</code>, <code>lsing</code>, <code>sempty</code>, <code>slazy</code>, and <code>dump</code>. They\nare visible in the interface with the caveat: &quot;For system use only, not\nfor the casual user&quot;.</p>\n","title":"Streams","pageDescription":"Streams offer an abstraction over consuming items from sequences\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#constructing-streams\">Constructing streams</a>\n</li>\n<li><a href=\"#deconstructing-streams\">Deconstructing streams</a>\n</li>\n<li><a href=\"#a-more-complex-streamfrom-example\">A more complex <code>Stream.from</code> example</a>\n</li>\n<li><a href=\"#stream-combinators\">Stream combinators</a>\n</li>\n<li><a href=\"#other-useful-stream-builders\">Other useful stream builders</a>\n</li>\n<li><a href=\"#combining-streams\">Combining streams</a>\n</li>\n<li><a href=\"#copying-streams\">Copying streams</a>\n</li>\n<li><a href=\"#converting-streams\">Converting streams</a>\n</li>\n<li><a href=\"#other-built-in-stream-functions\">Other built-in Stream functions</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"streams"}},"__N_SSG":true}