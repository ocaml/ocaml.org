{"pageProps":{"content":{"source":"<p>This tutorial explains how to compile your OCaml programs into executable form.\nIt addresses, in turn:</p>\n<ol>\n<li>\n<p>The compilation commands <code>ocamlc</code> and <code>ocamlopt</code> provided with OCaml. It is\nuseful to learn these commands to understand OCaml's compilation model.</p>\n</li>\n<li>\n<p>The <code>ocamlfind</code> front-end to the compiler, which saves you from worrying\nabout where libraries have been installed on your particular system.</p>\n</li>\n<li>\n<p>Automatic build systems for OCaml, such as <code>dune</code>, which release us from\ndetails of compiler command invocation, so we never touch <code>ocamlc</code>,\n<code>ocamlopt</code>, or even <code>ocamlfind</code>.</p>\n</li>\n</ol>\n<p>In our <a href=\"up_and_running.html\">up and running tutorial</a> we jumped straight to using\nthe automated build system <code>dune</code>. Now we shall look under the hood.</p>\n<h2 id=\"compilation-basics\">Compilation basics</h2>\n<p>In this section, we will first see how to compile a simple program using\nonly <code>ocamlc</code> or <code>ocamlopt</code>. Then we will see how to use libraries and how\nto take advantage of the\n<a href=\"https://projects.camlcity.org/projects/findlib.html\">findlib</a>\nsystem, which provides the <code>ocamlfind</code> command.</p>\n<h3 id=\"the-ocamlc-and-ocamlopt-compilers\">The ocamlc and ocamlopt compilers</h3>\n<p>OCaml comes with two compilers: <code>ocamlc</code> is the bytecode compiler, and\n<code>ocamlopt</code> is the native code compiler. If you don't know which one to use, use\n<code>ocamlopt</code> since it provides executables that are faster than bytecode.</p>\n<p>Let's assume that our program <code>program</code> has two source files,\n<code>module1.ml</code> and <code>module2.ml</code>. We will compile them to native code,\nusing <code>ocamlopt</code>. For now, we also assume that they do not use any other\nlibrary than the standard library, which is automatically loaded. You\ncan compile the program in one single step:</p>\n<pre><code class=\"language-shell\">ocamlopt -o program module1.ml module2.ml\n</code></pre>\n<p>The compiler produces an executable named <code>program</code> or <code>program.exe</code>. The order\nof the source files matters, and so <code>module1.ml</code> cannot depend upon things that\nare defined in <code>module2.ml</code>.</p>\n<p>The OCaml distribution is shipped with the standard library, plus several other\nlibraries. There are also a large number of third-party libraries, for a wide\nrange of applications, from networking to graphics. You should understand the\nfollowing:</p>\n<ol>\n<li>\n<p>The OCaml compilers know where the standard library is and use it\nsystematically (try: <code>ocamlc -where</code>). You don't have to worry much about\nit.</p>\n</li>\n<li>\n<p>The other libraries that ship with the OCaml distribution (str, unix, etc.)\nare installed in the same directory as the standard library.</p>\n</li>\n<li>\n<p>Third-party libraries may be installed in various places, and even a given\nlibrary can be installed in different places from one system to another.</p>\n</li>\n</ol>\n<p>If your program uses the unix library in addition to the standard library, for\nexample, the command line would be:</p>\n<pre><code class=\"language-shell\">ocamlopt -o program unix.cmxa module1.ml module2.ml\n</code></pre>\n<p>Note that <code>.cmxa</code> is the extension of native code libraries, while <code>.cma</code> is\nthe extension of bytecode libraries. The file <code>unix.cmxa</code> is found because it\nis always installed at the same place as the standard library, and this\ndirectory is in the library search path.</p>\n<p>If your program depends upon third-party libraries, you must pass them on the\ncommand line. You must also indicate the libraries on which these libraries\ndepend. You must also pass the -I option to <code>ocamlopt</code> for each directory where\nthey may be found. This becomes complicated, and this information is\ninstallation dependent. So we will use <code>ocamlfind</code> instead, which does these\njobs for us.</p>\n<h3 id=\"using-the-ocamlfind-front-end\">Using the ocamlfind front-end</h3>\n<p>The <code>ocamlfind</code> front-end is often used for compiling programs that use\nthird-party OCaml libraries. Library authors themselves make their library\ninstallable with <code>ocamlfind</code> as well. You can install <code>ocamlfind</code> using the\nopam package manager, by typing <code>opam install ocamlfind</code>.</p>\n<p>Let's assume that all the libraries you want to use have been installed\nproperly with ocamlfind. You can see which libraries are available in your\nsystem by typing:</p>\n<pre><code class=\"language-shell\">ocamlfind list\n</code></pre>\n<p>This shows the list of package names, with their versions. Note that most\nopam packages install software using ocamlfind, so your list of ocamlfind\nlibraries will be somewhat similar to your list of installed opam packages\nobtained by <code>opam list</code>.</p>\n<p>The command for compiling our program using package <code>pkg</code> will be:</p>\n<pre><code class=\"language-shell\">ocamlfind ocamlopt -o program -linkpkg -package pkg module1.ml module2.ml\n</code></pre>\n<p>Multiple packages may be specified using commas e.g <code>pkg1,pkg2</code>. Ocamlfind\nknows how to find any files <code>ocamlopt</code> may need from the package, for example\n<code>.cmxa</code> implementation files or <code>.cmi</code> interface files, because they have been\npackaged together and installed at a known location by ocamlfind. We need only\nthe name <code>pkg</code> to refer to them all - ocamlfind does the rest.</p>\n<p>Note that you can compile the files separately. This is useful if\nyou want to recompile only some parts of the programs. Here are the\nequivalent commands that perform a separate compilation of the source\nfiles and link them together in a final step:</p>\n<pre><code class=\"language-shell\">ocamlfind ocamlopt -c -package pkg module1.ml\nocamlfind ocamlopt -c -package pkg module2.ml\nocamlfind ocamlopt -o program -linkpkg -package pkg module1.cmx module2.cmx\n</code></pre>\n<p>Separate compilation (one command for <code>module1.ml</code>, another for <code>module2.ml</code>\nand another to link the final output) is usually not performed manually but\nonly when using an automated build system that will take care of recompiling\nonly what it necessary.</p>\n<h2 id=\"interlude-making-a-custom-toplevel\">Interlude: making a custom toplevel</h2>\n<p>OCaml provides another tool <code>ocamlmktop</code> to make an interactive toplevel with\nlibraries accessible. For example:</p>\n<pre><code class=\"language-shell\">ocamlmktop -o toplevel unix.cma module1.ml module2.ml\n</code></pre>\n<p>We run <code>toplevel</code> and get an OCaml toplevel with modules <code>Unix</code>, <code>Module1</code>, and\n<code>Module2</code> all available, allowing us to experiment interactively with our\nprogram.</p>\n<p>OCamlfind also supports <code>ocamlmktop</code>:</p>\n<pre><code class=\"language-shell\">ocamlfind ocamlmktop -o toplevel unix.cma -package pkg module1.ml module2.ml\n</code></pre>\n<h2 id=\"dune-an-automated-build-system\">Dune: an automated build system</h2>\n<p>The most popular modern system for building OCaml projects is\n<a href=\"https://dune.readthedocs.io/en/stable/\">dune</a> which may be installed with\n<code>opam install dune</code>. It allows one to build OCaml projects from a simple\ndescription of their elements. For example, the dune file for our project might\nlook like this:</p>\n<pre><code class=\"language-scheme\">;; our example project\n(executable\n  (name program)\n  (libraries unix pkg))\n</code></pre>\n<p>The dune <a href=\"https://dune.readthedocs.io/en/latest/quick-start.html\">quick-start\nguide</a> shows you how to\nwrite such description files for more complicated situations, and how to\nstructure, build, and run dune projects.</p>\n<h2 id=\"other-build-systems\">Other build systems</h2>\n<ul>\n<li><a href=\"https://github.com/ocaml-omake/omake\">OMake</a> Another OCaml build system.\n</li>\n<li><a href=\"https://www.gnu.org/software/make/\">GNU make</a> GNU make can build anything, including OCaml. May be used in conjunction with <a href=\"https://github.com/mmottl/ocaml-makefile\">OCamlmakefile</a>\n</li>\n<li><a href=\"https://github.com/ocaml/oasis\">Oasis</a> Generates a configure, build, and install system from a specification.\n</li>\n</ul>\n","title":"Compiling OCaml Projects","pageDescription":"An introduction to the OCaml compiler tools for building OCaml projects as well as the most common build tools\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#compilation-basics\">Compilation basics</a>\n</li>\n<li><a href=\"#interlude-making-a-custom-toplevel\">Interlude: making a custom toplevel</a>\n</li>\n<li><a href=\"#dune-an-automated-build-system\">Dune: an automated build system</a>\n</li>\n<li><a href=\"#other-build-systems\">Other build systems</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"compiling-ocaml-projects"}},"__N_SSG":true}