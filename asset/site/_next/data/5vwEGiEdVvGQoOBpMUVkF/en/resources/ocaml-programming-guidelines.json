{"pageProps":{"content":{"source":"<p>This is a set of reasonable guidelines for formatting OCaml\nprograms—guidelines which reflect the consensus among veteran OCaml\nprogrammers. Nevertheless, all detailed notifications of possible errors\nor omissions will be noted with pleasure. To send your comments using\n<a href=\"https://github.com/ocaml/ocaml.org/issues?state=open\">GitHub issues</a>.\n<br />\nOriginal translation from French: <a href=\"mailto:datta@math.berkeley.edu\">Ruchira\nDatta</a>.</p>\n<p>Thanks to all those who have already participated in the critique of\nthis page: Daniel de Rauglaudre, Luc Maranget, Jacques Garrigue, Damien\nDoligez, Xavier Leroy, Bruno Verlyck, Bruno Petazzoni, Francois Maltey,\nBasile Starynkevitch, Toby Moth, Pierre Lescanne.</p>\n<h2 id=\"general-guidelines-to-write-programs\">General guidelines to write programs</h2>\n<h3 id=\"be-simple-and-readable\">Be simple and readable</h3>\n<p>The time you spend typing the programs is negligible compared to the\ntime spent reading them. That's the reason why you save a lot of time if\nyou work hard to optimize readability.</p>\n<p>All the time you are &quot;wasting&quot; to get a simpler program today, will\nreturn a hundred times in the future during the uncountably many\nmodifications and readings of the program (starting with the first\ndebugging).</p>\n<blockquote>\n<p><strong>Writing programs law</strong>: A program is written once, modified ten\ntimes, and read 100 times. So simplify its writing, always keep future\nmodifications in mind, and never jeopardize readability.</p>\n</blockquote>\n<h2 id=\"program-formatting-guidelines\">Program formatting guidelines</h2>\n<h3 id=\"lexical-conventions\">Lexical conventions</h3>\n<blockquote>\n<p><strong>Pseudo spaces law</strong>: never hesitate to separate words of your\nprograms with spaces; the space bar is the easiest key to find on the\nkeyboard, press it as often as necessary!</p>\n</blockquote>\n<h4 id=\"delimiters\">Delimiters</h4>\n<p>A space should always follow a delimiter symbol, and spaces should\nsurround operator symbols. It has been a great step forward in\ntypography to separate words by spaces to make written texts easier to\nread. Do the same in your programs if you want them to be readable.</p>\n<h4 id=\"how-to-write-pairs\">How to write pairs</h4>\n<p>A tuple is parenthesized and the commas therein (delimiters) are each\nfollowed by a space: <code>(1, 2)</code>, <code>let   triplet = (x, y, z)</code>...</p>\n<ul>\n<li><strong>Commonly accepted exceptions</strong>:\n<ul>\n<li><strong>Definition of the components of a pair</strong>: In place of\n<code>let (x, y) =       ...</code>, you can write <code>let x, y = ...</code>.\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Justification</strong>: The point is to define several values\nsimultaneously, not to construct a tuple. Moreover, the\npattern is set off nicely between <code>let</code> and <code>=</code>.</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>Matching several values simultaneously</strong>: It's okay to omit\nparentheses around n-tuples when matching several values\nsimultaneously.</p>\n<pre><code>  match x, y with\n  | 1, _ -&gt; ...\n  | x, 1 -&gt; ...\n  | x, y -&gt; ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The point is to match several values in\nparallel, not to construct a tuple. Moreover, the expressions\nbeing matched are set off by <code>match</code> and <code>with</code>, while the\npatterns are set off nicely by <code>|</code> and <code>-&gt;</code>.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"how-to-write-lists\">How to write lists</h4>\n<p>Write <code>x :: l</code> with spaces around the <code>::</code> (since <code>::</code> is an infix\noperator, hence surrounded by spaces) and <code>[1; 2; 3]</code> (since <code>;</code> is a\ndelimiter, hence followed by a space).</p>\n<h4 id=\"how-to-write-operator-symbols\">How to write operator symbols</h4>\n<p>Be careful to keep operator symbols well separated by spaces: not only\nwill your formulas be more readable, but you will avoid confusion with\nmulti-character operators. (Obvious exceptions to this rule: the symbols\n<code>!</code> and <code>.</code> are not separated from their arguments.)<br />\nExample: write <code>x + 1</code> or <code>x + !y</code>.</p>\n<blockquote>\n<p><strong>Justification</strong>: If you left out the spaces then <code>x+1</code> would be\nunderstood, but <code>x+!y</code> would change its meaning since <code>+!</code> would\nbe interpreted as a multi-character operator.</p>\n<p><strong>Criticism</strong>: The absence of spaces around an operator improves the\nreadability of formulas when you use it to reflect the relative\nprecedences of operators. For example <code>x*y + 2*z</code> makes it very\nobvious that multiplication takes precedence over addition.</p>\n<p><strong>Response</strong>: This is a bad idea, a chimera, because nothing in the\nlanguage ensures that the spaces properly reflect the meaning of the\nformula. For example <code>x * z-1</code> means <code>(x * z) - 1</code>, and not\n<code>x * (z - 1)</code> as the proposed interpretation of spaces would seem to\nsuggest. Besides, the problem of multi-character symbols would keep\nyou from using this convention in a uniform way: you couldn't leave\nout the spaces around the multiplication to write <code>x*!y + 2*!z</code>.\nFinally, this playing with the spaces is a subtle and flimsy\nconvention, a subliminal message which is difficult to grasp on\nreading. If you want to make the precedences obvious, use the\nexpressive means brought to you by the language: write parentheses.</p>\n<p><strong>Additional justification</strong>: Systematically surrounding operators\nwith spaces simplify the treatment of infix operators which are no\nmore a complex particular case; in effect, whereas you can write <code>(+)</code>\nwithout spaces, you evidently cannot write <code>(*)</code> since <code>(*</code> is read as\nthe beginning of a comment. You must write at least one space as in\n“<code>( *)</code>”, although an extra space after <code>*</code> is definitively preferable\nif you want to avoid that <code>*)</code> could be read, in some contexts, as the\nend of a comment. All those difficulties are easily avoided if you\nadopt the simple rule proposed here: keep operator symbols well\nseparated by spaces.<br />\nIn fact you will quickly feel that this rule is not so difficult to\nfollow: the space bar is the greatest and best situated key of the\nkeyboard, it is the easiest to enter and you cannot miss it!</p>\n</blockquote>\n<h4 id=\"how-to-write-long-character-strings\">How to write long character strings</h4>\n<p>Indent long character strings with the convention in force at that line\nplus an indication of string continuation at the end of each line (a <code>\\</code>\ncharacter at the end of the line that omits white spaces on the\nbeginning of next line):</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let universal_declaration =\n  &quot;-1- Programs are born and remain free and equal under the law;\\n\\\n   distinctions can only be based on the common good.&quot; in\n  ...\n</code></pre>\n<h2 id=\"indentation-of-programs\">Indentation of programs</h2>\n<blockquote>\n<p><strong>Landin's pseudo law</strong>: Treat the indentation of your programs as if\nit determines the meaning of your programs.</p>\n</blockquote>\n<p>I would add to this law: carefully treat the indentation of programs\nbecause in some cases it really gives the meaning of the program!</p>\n<p>The indentation of programs is an art which excites many strong\nopinions. Here several indentation styles are given which are drawn from\nexperience and which have not been severely criticized.</p>\n<p>When a justification for the adopted style has seemed obvious to me, I\nhave indicated it. On the other hand, criticisms are also noted.</p>\n<p>So each time, you have to choose between the different styles\nsuggested.<br />\nThe only absolute rule is the first below.</p>\n<h3 id=\"consistency-of-indentation\">Consistency of indentation</h3>\n<p>Choose a generally accepted style of indentation, then use it\nsystematically throughout the whole application.</p>\n<h3 id=\"width-of-the-page\">Width of the page</h3>\n<p>The page is 80 columns wide.</p>\n<blockquote>\n<p><strong>Justification</strong>: This width makes it possible to read the code on\nall displays and to print it in a legible font on a standard sheet.</p>\n</blockquote>\n<h3 id=\"height-of-the-page\">Height of the page</h3>\n<p>A function should always fit within one screenful (of about 70 lines),\nor in exceptional cases two, at the very most three. To go beyond this\nis unreasonable.</p>\n<blockquote>\n<p><strong>Justification</strong>: When a function goes beyond one screenful, it's\ntime to divide it into subproblems and handle them independently.\nBeyond a screenful, one gets lost in the code. The indentation is not\nreadable and is difficult to keep correct.</p>\n</blockquote>\n<h3 id=\"how-much-to-indent\">How much to indent</h3>\n<p>The change in indentation between successive lines of the program is\ngenerally 1 or 2 spaces. Pick an amount to indent and stick with it\nthroughout the program.</p>\n<h3 id=\"using-tab-stops\">Using tab stops</h3>\n<p>Using the tab character (ASCII character 9) is absolutely <em>not</em>\nrecommended.</p>\n<blockquote>\n<p><strong>Justification</strong>: Between one display and another, the indentation of\nthe program changes completely; it can also become completely wrong,\nif the programmer used both tabulations and spaces to indent the\nprogram.</p>\n<p><strong>Criticism</strong>: The purpose of using tabulations is just to allow the\nreaders of the program to indent more or less by changing the tabs\nstops. The overall indentation remains correct and the reader is glad\nto easily customize the indentation amount.</p>\n<p><strong>Answer</strong>: It seems almost impossible to use this method since you\nshould always use tabulations to indent, which is hard and unnatural.</p>\n</blockquote>\n<h3 id=\"how-to-indent-global-let---definitions\">How to indent global <code>let ... ;;</code> definitions</h3>\n<p>The body of a function defined globally in a module is generally\nindented normally. However, it's okay to treat this case specially to\nset off the definition better.</p>\n<p>With a regular indentation of 1 or 2 spaces:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f x = function\n  | C -&gt;\n  | D -&gt;\n  ...\n\nlet g x =\n  let tmp =\n    match x with\n    | C -&gt; 1\n    | x -&gt; 0 in\n  tmp + 1\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: No exception to the amount of indentation.</p>\n</blockquote>\n<p>Other conventions are acceptable, for example:</p>\n<ul>\n<li>The body is left-justified in the case of pattern-matching.\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f x = function\n| C -&gt;\n| D -&gt;\n...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The vertical bars separating the patterns stop\nwhen the definition is done, so it's still easy to pass on to the\nfollowing definition.</p>\n<p><strong>Criticism</strong>: An unpleasant exception to the normal indentation.</p>\n</blockquote>\n<ul>\n<li>The body is justified just under the name of the defined function.\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f x =\n    let tmp = ... in\n    try g x with\n    | Not_found -&gt;\n    ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The first line of the definition is set off\nnicely, so it's easier to pass from definition to definition.</p>\n<p><strong>Criticism</strong>: You run into the right margin too quickly.</p>\n</blockquote>\n<h3 id=\"how-to-indent-let--in-constructs\">How to indent <code>let ... in</code> constructs</h3>\n<p>The expression following a definition introduced by <code>let</code> is indented to\nthe same level as the keyword <code>let</code>, and the keyword <code>in</code> which\nintroduces it is written at the end of the line:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let expr1 = ... in\nexpr1 + expr1\n</code></pre>\n<p>In the case of a series of <code>let</code> definitions, the preceding rule implies\nthat these definitions should be placed at the same indentation level:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let expr1 = ... in\nlet n = ... in\n...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: It is suggested that a series of “let ... in”\nconstructs is analogous to a set of assumptions in a mathematical\ntext, whence the same indentation level for all the assumptions.</p>\n</blockquote>\n<p>Variation: some write the keyword <code>in</code> alone on one line to set apart\nthe final expression of the computation:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let e1 = ... in\nlet e2 = ... in\nlet new_expr =\n  let e1' = derive_expression e1\n  and e2' = derive_expression e2 in\n  Add_expression e1' e2'\nin\nMult_expression (new_expr, new_expr)\n</code></pre>\n<blockquote>\n<p><strong>Criticism</strong>: Lack of consistency.</p>\n</blockquote>\n<h3 id=\"how-to-indent-if--then----else--\">How to indent <code>if ... then   ... else ... </code></h3>\n<h4 id=\"multiple-branches\">Multiple branches</h4>\n<p>Write conditions with multiple branches at the same level of\nindentation:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">if cond1 ...\nif cond2 ...\nif cond3 ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: Analogous treatment to pattern-matching clauses,\nall aligned to the same tab stop.</p>\n</blockquote>\n<p>If the sizes of the conditions and the expressions allow, write for\nexample:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">if cond1 then e1 else\nif cond2 then e2 else\nif cond3 then e3 else\ne4\n\n</code></pre>\n<p>If expressions in the branches of multiple conditions have to be\nenclosed (when they include statements for instance), write:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">if cond then begin\n    e1\n  end else\nif cond2 then begin\n    e2\n  end else\nif cond3 then ...\n</code></pre>\n<p>Some suggest another method for multiple conditionals, starting each\nline by the keyword <code>else</code>:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">if cond1 ...\nelse if cond2 ...\nelse if cond3 ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: <code>elsif</code> is a keyword in many languages, so use\nindentation and <code>else if</code> to bring it to mind. Moreover, you do not\nhave to look to the end of line to know whether the condition is\ncontinued or another test is performed.</p>\n<p><strong>Criticism</strong>: Lack of consistency in the treatment of all the\nconditions. Why a special case for the first condition?</p>\n</blockquote>\n<p>Yet again, choose your style and use it systematically.</p>\n<h4 id=\"single-branches\">Single branches</h4>\n<p>Several styles are possible for single branches, according to the size\nof the expressions in question and especially the presence of <code>begin</code>\n<code>end</code> or <code>(</code> <code>)</code> delimiters for these expressions.</p>\n<p>In the case of delimiting the branches of a conditional, several styles\nare used:</p>\n<blockquote>\n<p><code>(</code> at end of line:</p>\n<pre><code class=\"language-ocaml\">if cond then (\n  e1\n) else (\n  e2\n)\n</code></pre>\n<p>Or alternatively first <code>begin</code> at beginning of line:</p>\n<pre><code class=\"language-ocaml\">if cond then\n  begin\n    e1\n  end else begin\n    e2\n  end\n</code></pre>\n</blockquote>\n<p>In fact the indentation of conditionals depends on the sizes of the\nexpressions which make them up.</p>\n<blockquote>\n<p>If <code>cond</code>, <code>e1</code> and <code>e2</code> are small, simply write them on one line:</p>\n<pre><code class=\"language-ocaml\">if cond then e1 else e2\n</code></pre>\n<p>If the expressions making up a conditional are purely functional\n(without side effects), we advocate binding them within the\nconditional with <code>let e = ... in</code> when they're too big to fit on a\nline.</p>\n<blockquote>\n<p><strong>Justification</strong>: This way you get back the simple indentation on\none line which is the most readable. As a side benefit, the naming\nacts as an aid to comprehension.</p>\n</blockquote>\n<p>So now we consider the case in which the expressions in question do\nhave side effects, which keeps us from simply binding them with a\n<code>let e = ... in</code>.</p>\n<blockquote>\n<p>If <code>e1</code> and <code>cond</code> are small, but <code>e2</code> large:</p>\n<pre><code class=\"language-ocaml\">if cond then e1 else\n  e2\n</code></pre>\n<p>If <code>e1</code> and <code>cond</code> are large and <code>e2</code> small:</p>\n<pre><code class=\"language-ocaml\">if cond then\n  e1\nelse e2\n</code></pre>\n<p>If all the expressions are large:</p>\n<pre><code class=\"language-ocaml\">if cond then\n  e1\nelse\n  e2\n</code></pre>\n<p>If there are <code>( )</code> delimiters:</p>\n<pre><code class=\"language-ocaml\">if cond then (\n  e1\n) else (\n  e2\n)\n</code></pre>\n<p>A mixture where <code>e1</code> requires <code>( )</code> but <code>e2</code> is small:</p>\n<pre><code class=\"language-ocaml\">if cond then (\n    e1\n) else e2\n</code></pre>\n</blockquote>\n</blockquote>\n<h3 id=\"how-to-indent-pattern-matching-constructs\">How to indent pattern-matching constructs</h3>\n<h4 id=\"general-principles\">General principles</h4>\n<p>All the pattern-matching clauses are introduced by a vertical bar,\n<em>including</em> the first one.</p>\n<blockquote>\n<p><strong>Criticism</strong>: The first vertical bar is not mandatory: hence, there\nis no need to write it.</p>\n<p><strong>Answer to criticism</strong>: If you omit the first bar the indentation\nseems unnatural : the first case gets an indentation that is greater\nthan a normal new line would necessitate. It is thus a useless\nexception to the correct indentation rule. It also insists not to use\nthe same syntax for the whole set of clauses, writing the first clause\nas an exception with a slightly different syntax. Last, aesthetic\nvalue is doubtful (some people would say “awful” instead of\n“doubtful”).</p>\n</blockquote>\n<p>Align all the pattern-matching clauses at the level of the vertical bar\nwhich begins each clause, <em>including</em> the first one.</p>\n<p>If an expression in a clause is too large to fit on the line, you must\nbreak the line immediately after the arrow of the corresponding clause.\nThen indent normally, starting from the beginning of the pattern of the\nclause.</p>\n<p>Arrows of pattern matching clauses should not be aligned.</p>\n<h4 id=\"match-or-try\"><code>match</code> or <code>try</code></h4>\n<p>For a <code>match</code> or a <code>try</code> align the clauses with the beginning of the\nconstruct:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">match lam with\n| Abs (x, body) -&gt; 1 + size_lambda body\n| App (lam1, lam2) -&gt; size_lambda lam1 + size_lambda lam2\n| Var v -&gt; 1\n\ntry f x with\n| Not_found -&gt; ...\n| Failure &quot;not yet implemented&quot; -&gt; ...\n</code></pre>\n<p>Put the keyword <code>with</code> at the end of the line. If the preceding\nexpression extends beyond one line, put <code>with</code> on a line by itself:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">try\n  let y = f x in\n  if ...\nwith\n| Not_found -&gt; ...\n| Failure &quot;not yet implemented&quot; -&gt; ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The keyword <code>with</code>, on a line by itself shows that\nthe program enters the pattern matching part of the construct.</p>\n</blockquote>\n<h4 id=\"indenting-expressions-inside-clauses\">Indenting expressions inside clauses</h4>\n<p>If the expression on the right of the pattern matching arrow is too\nlarge, cut the line after the arrow.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">match lam with\n| Abs (x, body) -&gt;\n   1 + size_lambda body\n| App (lam1, lam2) -&gt;\n   size_lambda lam1 + size_lambda lam2\n| Var v -&gt;\n</code></pre>\n<p>Some programmers generalize this rule to all clauses, as soon as one\nexpressions overflows. They will then indent the last clause like this:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">| Var v -&gt;\n   1\n</code></pre>\n<p>Other programmers go one step further and apply this rule systematically\nto any clause of any pattern matching.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec fib = function\n  | 0 -&gt;\n     1\n  | 1 -&gt;\n     1\n  | n -&gt;\n     fib (n - 1) + fib ( n - 2)\n</code></pre>\n<blockquote>\n<p><strong>Criticism</strong>: May be not compact enough; for simple pattern matchings\n(or simple clauses in complex matchings), the rule does not add any\ngood to readability.</p>\n<p><strong>Justification</strong>: I don't see any good reason for this rule, unless\nyou are paid proportionally to the number of lines of code: in this\ncase use this rule to get more money without adding more bugs in your\nOCaml programs!</p>\n</blockquote>\n<h4 id=\"pattern-matching-in-anonymous-functions\">Pattern matching in anonymous functions</h4>\n<p>Similarly to <code>match</code> or <code>try</code>, pattern matching of anonymous functions,\nstarting by <code>function</code>, are indented with respect to the <code>function</code>\nkeyword:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">map\n  (function\n   | Abs (x, body) -&gt; 1 + size_lambda 0 body\n   | App (lam1, lam2) -&gt; size_lambda (size_lambda 0 lam1) lam2\n   | Var v -&gt; 1)\n  lambda_list\n</code></pre>\n<h4 id=\"pattern-matching-in-named-functions\">Pattern matching in named functions</h4>\n<p>Pattern-matching in functions defined by <code>let</code> or <code>let rec</code> gives rise\nto several reasonable styles which obey the preceding rules for pattern\nmatching (the one for anonymous functions being evidently excepted). See\nabove for recommended styles.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec size_lambda accu = function\n  | Abs (x, body) -&gt; size_lambda (succ accu) body\n  | App (lam1, lam2) -&gt; size_lambda (size_lambda accu lam1) lam2\n  | Var v -&gt; succ accu\n\nlet rec size_lambda accu = function\n| Abs (x, body) -&gt; size_lambda (succ accu) body\n| App (lam1, lam2) -&gt; size_lambda (size_lambda accu lam1) lam2\n| Var v -&gt; succ accu\n</code></pre>\n<h3 id=\"bad-indentation-of-pattern-matching-constructs\">Bad indentation of pattern-matching constructs</h3>\n<h4 id=\"no-beastly-indentation-of-functions-and-case-analyses\">No <em>beastly</em> indentation of functions and case analyses.</h4>\n<p>This consists in indenting normally under the keyword <code>match</code> or\n<code>function</code> which has previously been pushed to the right. Don't write:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec f x = function\n              | [] -&gt; ...\n              ...\n</code></pre>\n<p>but choose to indent the line under the <code>let</code> keyword:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec f x = function\n  | [] -&gt; ...\n  ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: You bump into the margin. The aesthetic value is\ndoubtful...</p>\n</blockquote>\n<h4 id=\"no-beastly-alignment-of-the---symbols-in-pattern-matching-clauses\">No <em>beastly</em> alignment of the <code>-&gt;</code> symbols in pattern-matching clauses.</h4>\n<p>Careful alignment of the arrows of a pattern matching is considered bad\npractice, as exemplify in the following fragment:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f = function\n  | C1          -&gt; 1\n  | Long_name _ -&gt; 2\n  | _           -&gt; 3\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: This makes it harder to maintain the program (the\naddition of a supplementary case can lead the indentations of all the\nlines to change and so ... we often give up alignment at that time,\nthen it is better not to align the arrows in the first place!).</p>\n</blockquote>\n<h3 id=\"how-to-indent-function-calls\">How to indent function calls</h3>\n<h4 id=\"indentation-to-the-functions-name\">Indentation to the function's name:</h4>\n<p>No problem arises except for functions with many arguments—or very\ncomplicated arguments as well—which can't fit on the same line. You\nmust indent the expressions with respect to the name of the function (1\nor 2 spaces according to the chosen convention). Write small arguments\non the same line, and change lines at the start of an argument.</p>\n<p>As far as possible, avoid arguments which consist of complex\nexpressions: in these cases define the “large” argument by a <code>let</code>\nconstruction.</p>\n<blockquote>\n<p><strong>Justification</strong>: No indentation problem; if the name given to the\nexpressions is meaningful, the code is more readable as well.</p>\n<p><strong>Additional justification</strong>: If the evaluation of the arguments\nproduces side effects, the <code>let</code> binding is in fact necessary to\nexplicitly define the order of evaluation.</p>\n</blockquote>\n<h4 id=\"naming-complex-arguments\">Naming complex arguments:</h4>\n<p>In place of</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let temp =\n  f x y z\n    “large\n    expression”\n    “other large\n    expression” in\n...\n</code></pre>\n<p>write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let t =\n  “large\n  expression”\nand u =\n  “other large\n  expression” in\nlet temp =\n  f x y z t u in\n...\n</code></pre>\n<h4 id=\"naming-anonymous-functions\">Naming anonymous functions:</h4>\n<p>In the case of an iterator whose argument is a complex function, define\nthe function by a <code>let</code> binding as well. In place of</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">List.map\n  (function x -&gt;\n    blabla\n    blabla\n    blabla)\n  l\n</code></pre>\n<p>write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f x =\n  blabla\n  blabla\n  blabla in\nList.map f l\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: Much clearer, in particular if the name given to\nthe function is meaningful.</p>\n</blockquote>\n<h3 id=\"how-to-indent-operations\">How to indent operations</h3>\n<p>When an operator takes complex arguments, or in the presence of multiple\ncalls to the same operator, start the next the line with the operator,\nand don't indent the rest of the operation. For example:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">x + y + z\n+ t + u\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: When the operator starts the line, it is clear that\nthe operation continues on this line.</p>\n</blockquote>\n<p>In the case of a “large expression” in such an operation sequence,\nto define the “large expression” with the help of a <code>let in</code>\nconstruction is preferable to having to indent the line. In place of</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">x + y + z\n+ “large\n  expression”\n</code></pre>\n<p>write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let t =\n  “large\n   expression” in\nx + y + z + t\n</code></pre>\n<p>You most certainly must bind those expressions too large to be written\nin one operation in the case of a combination of operators. In place of\nthe unreadable expression</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">(x + y + z * t)\n/ (“large\n    expression”)\n</code></pre>\n<p>write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let u =\n  “large\n  expression” in\n(x + y + z * t) / u\n</code></pre>\n<p>These guidelines extend to all operators. For example:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let u =\n  “large\n  expression” in\nx :: y\n:: z + 1 :: t :: u\n</code></pre>\n<h2 id=\"programming-guidelines\">Programming guidelines</h2>\n<h3 id=\"how-to-program\">How to program</h3>\n<blockquote>\n<p><em>Always put your handiwork back on the bench,<br />\nand then polish it and re-polish it.</em></p>\n</blockquote>\n<h4 id=\"write-simple-and-clear-programs\">Write simple and clear programs</h4>\n<p>When this is done, reread, simplify and clarify. At every stage of\ncreation, use your head!</p>\n<h4 id=\"subdivide-your-programs-into-little-functions\">Subdivide your programs into little functions</h4>\n<p>Small functions are easier to master.</p>\n<h4 id=\"factor-out-snippets-of-repeated-code-by-defining-them-in-separate-functions\">Factor out snippets of repeated code by defining them in separate functions</h4>\n<p>The sharing of code obtained in this way facilitates maintenance since\nevery correction or improvement automatically spreads throughout the\nprogram. Besides, the simple act of isolating and naming a snippet of\ncode sometimes lets you identify an unsuspected feature.</p>\n<h4 id=\"never-copy-paste-code-when-programming\">Never copy-paste code when programming</h4>\n<p>Pasting code almost surely indicates introducing a default of code\nsharing and neglecting to identify and write a useful auxiliary\nfunction; hence, it means that some code sharing is lost in the program.\nLosing code sharing implies that you will have more problems afterwards\nfor maintenance: a bug in the pasted code has to be corrected at each\noccurrence of the bug in each copy of the code!</p>\n<p>Moreover, it is difficult to identify that the same set of 10 lines of\ncode is repeated 20 times throughout the program. By contrast, if an\nauxiliary function defines those 10 lines, it is fairly easy to see and\nfind where those lines are used: that's simply where the function is\ncalled. If code is copy-pasted all over the place then the program is\nmore difficult to understand.</p>\n<p>In conclusion, copy-pasting code leads to programs that are more\ndifficult to read and more difficult to maintain: it has to be banished.</p>\n<h3 id=\"how-to-comment-programs\">How to comment programs</h3>\n<h4 id=\"dont-hesitate-to-comment-when-theres-a-difficulty\">Don't hesitate to comment when there's a difficulty</h4>\n<h4 id=\"if-theres-no-difficulty-theres-no-point-in-commenting\">If there's no difficulty, there's no point in commenting</h4>\n<h4 id=\"avoid-comments-in-the-bodies-of-functions\">Avoid comments in the bodies of functions</h4>\n<h4 id=\"prefer-one-comment-at-the-beginning-of-the-function\">Prefer one comment at the beginning of the function...</h4>\n<p>...which explains how the algorithm that is used works. Once more, if\nthere is no difficulty, there is no point in commenting.</p>\n<h4 id=\"avoid-nocuous-comments\">Avoid nocuous comments</h4>\n<p>A <em>nocuous</em> comment is a comment that does not add any value, i.e. no\nnon-trivial information. The nocuous comment is evidently not of\ninterest; it is a nuisance since it uselessly distracts the reader. It\nis often used to fulfill some strange criteria related to the so-called\n<em>software metrology</em>, for instance the ratio <em>number of comments</em> /\n<em>number of lines of code</em> that perfectly measures a ratio that I don't\nknow the theoretical or practical interpretation. Absolutely avoid\nnocuous comments.</p>\n<p>An example of what to avoid: the following comment uses technical words\nand is thus masquerade into a real comment when it has no additional\ninformation of interest;</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">(*\n  Function print_lambda:\n  print a lambda-expression given as argument.\n\n  Arguments: lam, any lambda-expression.\n  Returns: nothing.\n\n  Remark: print_lambda can only be used for its side effect.\n*)\nlet rec print_lambda lam =\n  match lam with\n  | Var s -&gt; printf &quot;%s&quot; s\n  | Abs l -&gt; printf &quot;\\\\ %a&quot; print_lambda l\n  | App (l1, l2) -&gt;\n     printf &quot;(%a %a)&quot; print_lambda l1 print_lambda l2\n</code></pre>\n<h4 id=\"usage-in-module-interface\">Usage in module interface</h4>\n<p>The function's usage must appear in the interface of the module which\nexports it, not in the program which implements it. Choose comments as\nin the OCaml system's interface modules, which will subsequently allow\nthe documentation of the interface module to be extracted automatically\nif need be.</p>\n<h4 id=\"use-assertions\">Use assertions</h4>\n<p>Use assertions as much as possible: they let you avoid verbose comments,\nwhile allowing a useful verification upon execution.</p>\n<p>For example, the conditions for the arguments of a function to be valid\nare usefully verified by assertions.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f x =\n  assert (x &gt;= 0);\n  ...\n</code></pre>\n<p>Note as well that an assertion is often preferable to a comment because\nit's more trustworthy: an assertion is forced to be pertinent because it\nis verified upon each execution, while a comment can quickly become\nobsolete and then becomes actually detrimental to the comprehension of\nthe program.</p>\n<h4 id=\"comments-line-by-line-in-imperative-code\">Comments line by line in imperative code</h4>\n<p>When writing difficult code, and particularly in case of highly\nimperative code with a lot of memory modifications (physical mutations\nin data structures), it is sometime mandatory to comment inside the body\nof functions to explain the implementation of the algorithm encoded\nhere, or to follow successive modifications of invariants that the\nfunction must maintain. Once more, if there is some difficulty\ncommenting is mandatory, for each program line if necessary.</p>\n<h3 id=\"how-to-choose-identifiers\">How to choose identifiers</h3>\n<p>It's hard to choose identifiers whose name evokes the meaning of the\ncorresponding portion of the program. This is why you must devote\nparticular care to this, emphasizing clarity and regularity of\nnomenclature.</p>\n<h4 id=\"dont-use-abbreviations-for-global-names\">Don't use abbreviations for global names</h4>\n<p>Global identifiers (including especially the names of functions) can be\nlong, because it's important to understand what purpose they serve far\nfrom their definition.</p>\n<h4 id=\"separate-words-by-underscores-intofstring-not-intofstring\">Separate words by underscores: (<code>int_of_string</code>, not <code>intOfString</code>)</h4>\n<p>Case modifications are meaningful in OCaml: in effect capitalized words\nare reserved for constructors and module names in OCaml; in contrast\nregular variables (functions or identifiers) must start by a lowercase\nletter. Those rules prevent proper usage of case modification for words\nseparation in identifiers: the first word starts the identifier, hence\nit must be lower case and it is forbidden to choose <code>IntOfString</code> as the\nname of a function.</p>\n<h4 id=\"always-give-the-same-name-to-function-arguments-which-have-the-same-meaning\">Always give the same name to function arguments which have the same meaning</h4>\n<p>If necessary, make this nomenclature explicit in a comment at the top of\nthe file); if there are several arguments with the same meaning then\nattach numeral suffixes to them.</p>\n<h4 id=\"local-identifiers-can-be-brief-and-should-be-reused-from-one-function-to-another\">Local identifiers can be brief, and should be reused from one function to another</h4>\n<p>This augments regularity of style. Avoid using identifiers whose\nappearance can lead to confusion such as <code>l</code> or <code>O</code>, easy to confuse\nwith <code>1</code> and <code>0</code>.</p>\n<p>Example:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let add_expression expr1 expr2 = ...\nlet print_expression expr = ...\n</code></pre>\n<p>An exception to the recommendation not to use capitalization to separate\nwords within identifiers is tolerated in the case of interfacing with\nexisting libraries which use this naming convention: this lets OCaml\nusers of the library to orient themselves in the original library\ndocumentation more easily.</p>\n<h3 id=\"when-to-use-parentheses-within-an-expression\">When to use parentheses within an expression</h3>\n<p>Parentheses are meaningful: they indicate the necessity of using an\nunusual precedence. So they should be used wisely and not sprinkled\nrandomly throughout programs. To this end, you should know the usual\nprecedences, that is, the combinations of operations which do not\nrequire parentheses. Quite fortunately this is not complicated if you\nknow a little mathematics or strive to follow the following rules:</p>\n<h4 id=\"arithmetic-operators-the-same-rules-as-in-mathematics\">Arithmetic operators: the same rules as in mathematics</h4>\n<p>For example: <code>1 + 2 * x</code> means <code>1 + (2 * x)</code>.</p>\n<h4 id=\"function-application-the-same-rules-as-those-in-mathematics-for-usage-of-trigonometric-functions\">Function application: the same rules as those in mathematics for usage of <em>trigonometric functions</em></h4>\n<p>In mathematics you write <code>sin x</code> to mean <code>sin (x)</code>. In the same way\n<code>sin x + cos x</code> means <code>(sin x) + (cos x)</code> not <code>sin (x + (cos x))</code>. Use\nthe same conventions in OCaml: write <code>f x + g x</code> to mean\n<code>(f x) + (g x)</code>.<br />\nThis convention generalizes <strong>to all (infix) operators</strong>: <code>f x :: g x</code>\nmeans <code>(f x) :: (g x)</code>, <code>f x @ g x</code> means <code>(f x) @ (g x)</code>, and\n<code>failwith s ^ s'</code> means <code>(failwith s) ^ s'</code>, <em>not</em> <code>failwith (s ^ s')</code>.</p>\n<h4 id=\"comparisons-and-boolean-operators\">Comparisons and boolean operators</h4>\n<p>Comparisons are infix operators, so the preceding rules apply. This is\nwhy <code>f x &lt; g x</code> means <code>(f x) &lt; (g x)</code>. For type reasons (no other\nsensible interpretation) the expression <code>f x &lt; x + 2</code> means\n<code>(f x) &lt; (x + 2)</code>. In the same way <code>f x &lt; x + 2 &amp;&amp; x &gt; 3</code> means\n<code>((f x) &lt; (x + 2)) &amp;&amp; (x &gt; 3)</code>.</p>\n<h4 id=\"the-relative-precedences-of-the-boolean-operators-are-those-of-mathematics\">The relative precedences of the boolean operators are those of mathematics</h4>\n<p>Although mathematicians have a tendency to overuse parens in this case,\nthe boolean “or” operator is analogous to addition and the “and”\nto multiplication. So, just as <code>1 + 2 * x</code> means <code>1 + (2 * x)</code>,\n<code>true || false &amp;&amp; x</code> means <code>true || (false &amp;&amp; x)</code>.</p>\n<h3 id=\"how-to-delimit-constructs-in-programs\">How to delimit constructs in programs</h3>\n<p>When it is necessary to delimit syntactic constructs in programs, use as\ndelimiters the keywords <code>begin</code> and <code>end</code> rather than parentheses.\nHowever using parentheses is acceptable if you do it in a consistent,\nthat is, systematic, way.</p>\n<p>This explicit delimiting of constructs essentially concerns\npattern-matching constructs or sequences embedded within\n<code>if then     else</code> constructs.</p>\n<h4 id=\"match-construct-in-a-match-construct\"><code>match</code> construct in a <code>match</code> construct</h4>\n<p>When a <code>match ... with</code> or <code>try ... with</code> construct appears in a\npattern-matching clause, it is absolutely necessary to delimit this\nembedded construct (otherwise subsequent clauses of the enclosing\npattern-matching construct will automatically be associated with the\nenclosed pattern-matching construct). For example:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">match x with\n| 1 -&gt;\n  begin match y with\n  | ...\n  end\n| 2 -&gt;\n...\n</code></pre>\n<h4 id=\"sequences-inside-branches-of-if\">Sequences inside branches of <code>if</code></h4>\n<p>In the same way, a sequence which appears in the <code>then</code> or <code>else</code> part\nof a conditional must be delimited:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">if cond then begin\n  e1;\n  e2\nend else begin\n  e3;\n  e4\nend\n</code></pre>\n<h3 id=\"how-to-use-modules\">How to use modules</h3>\n<h4 id=\"subdividing-into-modules\">Subdividing into modules</h4>\n<p>You must subdivide your programs into coherent modules.</p>\n<p>For each module, you must explicitly write an interface.</p>\n<p>For each interface, you must document the things defined by the module:\nfunctions, types, exceptions, etc.</p>\n<h4 id=\"opening-modules\">Opening modules</h4>\n<p>Avoid <code>open</code> directives, using instead the qualified identifier\nnotation. Thus you will prefer short but meaningful module names.</p>\n<blockquote>\n<p><strong>Justification</strong>: The use of unqualified identifiers is ambiguous and\ngives rise to difficult-to-detect semantic errors.</p>\n</blockquote>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let lim = String.length name - 1 in\n...\nlet lim = Array.length v - 1 in\n...\n... List.map succ ...\n... Array.map succ ...\n</code></pre>\n<h4 id=\"when-to-use-open-modules-rather-than-leaving-them-closed\">When to use open modules rather than leaving them closed</h4>\n<p>You can consider it normal to open a module which modifies the\nenvironment, and brings other versions of an important set of functions.\nFor example, the <code>Format</code> module provides automatically indented\nprinting. This module redefines the usual printing functions\n<code>print_string</code>, <code>print_int</code>, <code>print_float</code>, etc. So when you use\n<code>Format</code>, open it systematically at the top of the file.<br />\nIf you don't open <code>Format</code> you could miss the qualification of a\nprinting function, and this could be perfectly silent, since many of\n<code>Format</code>'s functions have a counterpart in the default environment\n(<code>Pervasives</code>). Mixing printing functions from <code>Format</code> and <code>Pervasives</code>\nleads to subtle bugs in the display, that are difficult to trace. For\ninstance:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f () =\n  Format.print_string &quot;Hello World!&quot;; print_newline ()\n</code></pre>\n<p>is bogus since it does not call <code>Format.print_newline</code> to flush the\npretty-printer queue and output <code>&quot;Hello World!&quot;</code>. Instead\n<code>&quot;Hello World!&quot;</code> is stuck into the pretty-printer queue, while\n<code>Pervasives.print_newline</code> outputs a carriage return on the standard\noutput ... If <code>Format</code> is printing on a file and standard output is the\nterminal, the user will have a bad time finding that a carriage return\nis missing in the file (and the display of material on the file is\nstrange, since boxes that should be closed by <code>Format.print_newline</code> are\nstill open), while a spurious carriage return appeared on the screen!</p>\n<p>For the same reason, open large libraries such as the one with\narbitrary-precision integers so as not to burden the program which uses\nthem.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">open Num\n\nlet rec fib n =\n  if n &lt;= 2 then Int 1 else fib (n - 1) +/ fib (n - 2)\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The program would be less readable if you had to\nqualify all the identifiers.</p>\n</blockquote>\n<p>In a program where type definitions are shared, it is good to gather\nthese definitions into one or more module(s) without implementations\n(containing only types). Then it's acceptable to systematically open the\nmodule which exports the shared type definitions.</p>\n<h3 id=\"pattern-matching\">Pattern-matching</h3>\n<h4 id=\"never-be-afraid-of-over-using-pattern-matching\">Never be afraid of over-using pattern-matching!</h4>\n<h4 id=\"on-the-other-hand-be-careful-to-avoid-non-exhaustive-pattern-matching-constructs\">On the other hand, be careful to avoid non-exhaustive pattern-matching constructs</h4>\n<p>Complete them with care, without using a “catch-all” clause such as\n<code>| _ -&gt; ...</code> or <code>| x -&gt; ...</code> when it's possible to do without it (for\nexample when matching a concrete type defined within the program). See\nalso the next section: compiler warnings.</p>\n<h3 id=\"compiler-warnings\">Compiler warnings</h3>\n<p>Compiler warnings are meant to prevent potential errors; this is why you\nabsolutely must heed them and correct your programs if compiling them\nproduces such warnings. Besides, programs whose compilation produces\nwarnings have an odor of amateurism which certainly doesn't suit your\nown work!</p>\n<h4 id=\"pattern-matching-warnings\">Pattern-matching warnings</h4>\n<p>Warnings about pattern-matching must be treated with the upmost care:</p>\n<ul>\n<li>\n<p>Those concerning useless clauses should of course be eliminated.</p>\n</li>\n<li>\n<p>For non-exhaustive pattern-matching you must complete the\ncorresponding pattern-matching construct, without adding a default\ncase “catch-all”, such as <code>| _ -&gt; ... </code>, but with an explicit\nlist of the constructors not examined by the rest of the construct,\nfor example <code>| Cn _ | Cn1 _ -&gt; ... </code>.</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>Justification</strong>: It's not really any more complicated to write\nit this way, and this allows the program to evolve more safely. In\neffect the addition of a new constructor to the datatype being\nmatched will produce an alert anew, which will allow the\nprogrammer to add a clause corresponding to the new constructor if\nthat is warranted. On the contrary, the “catch-all” clause\nwill make the function compile silently and it might be thought\nthat the function is correct as the new constructor will be\nhandled by the default case.</p>\n</blockquote>\n<ul>\n<li>Non-exhaustive pattern-matches induced by clauses with guards must\nalso be corrected. A typical case consists in suppressing a\nredundant guard.\n</li>\n</ul>\n<h4 id=\"de-structuring-let-bindings\">De-structuring <code>let</code> bindings</h4>\n<p>[Translator's note: a “de-structuring <code>let</code> binding” is one which\nbinds several names to several expressions simultaneously. You pack all\nthe names you want bound into a collection such as a tuple or a list,\nand you correspondingly pack all the expressions into a collective\nexpression. When the <code>let</code> binding is evaluated, it unpacks the\ncollections on both sides and binds each expression to its corresponding\nname. For example, <code>let x, y = 1, 2</code> is a de-structuring <code>let</code> binding\nwhich performs both the bindings <code>let x = 1</code> and <code>let y = 2</code>\nsimultaneously.]<br />\nThe <code>let</code> binding is not limited to simple identifier definitions: you\ncan use it with more complex or simpler patterns. For instance</p>\n<ul>\n<li><code>let</code> with complex patterns:<br />\n<code>let [x; y] as l = ...</code><br />\nsimultaneously defines a list <code>l</code> and its two elements <code>x</code> and <code>y</code>.\n</li>\n<li><code>let</code> with simple pattern:<br />\n<code>let _ = ...</code> does not define anything, it just evaluate the\nexpression on the right hand side of the <code>=</code> symbol.\n</li>\n</ul>\n<h4 id=\"the-de-structuring-let-must-be-exhaustive\">The de-structuring <code>let</code> must be exhaustive</h4>\n<p>Only use de-structuring <code>let</code> bindings in the case where the\npattern-matching is exhaustive (the pattern can never fail to match).\nTypically, you will thus be limited to definitions of product types\n(tuples or records) or definitions of variant type with a single case.\nIn any other case, you should use an explicit <code>match   ... with</code>\nconstruct.</p>\n<ul>\n<li><code>let ... in</code>: de-structuring <code>let</code> that give a warning must be\nreplaced by an explicit pattern matching. For instance, instead of\n<code>let [x; y] as l = List.map succ     (l1 @ l2) in expression</code> write:\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">match List.map succ (l1 @ l2) with\n| [x; y] as l -&gt; expression\n| _ -&gt; assert false\n</code></pre>\n<ul>\n<li>Global definition with de-structuring lets should be rewritten with\nexplicit pattern matching and tuples:\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let x, y, l =\n  match List.map succ (l1 @ l2) with\n  | [x; y] as l -&gt; x, y, l\n  | _ -&gt; assert false\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: There is no way to make the pattern-matching\nexhaustive if you use general de-structuring <code>let</code> bindings.</p>\n</blockquote>\n<h4 id=\"sequence-warnings-and-let---\">Sequence warnings and <code>let _ = ...</code></h4>\n<p>When the compiler emits a warning about the type of an expression in a\nsequence, you have to explicitly indicate that you want to ignore the\nresult of this expression. To this end:</p>\n<ul>\n<li>use a vacuous binding and suppress the sequence warning of\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">List.map f l;\nprint_newline ()\n</code></pre>\n<p>write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let _ = List.map f l in\nprint_newline ()\n</code></pre>\n<ul>\n<li>you can also use the predefined function <code>ignore : 'a     -&gt; unit</code>\nthat ignores its argument to return <code>unit</code>.\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">ignore (List.map f l);\nprint_newline ()\n</code></pre>\n<ul>\n<li>In any case, the best way to suppress this warning is to understand\nwhy it is emitted by the compiler: the compiler warns you because\nyour code computes a result that is useless since this result is\njust deleted after computation. Hence, if useful at all, this\ncomputation is performed only for its side-effects; hence it should\nreturn unit.<br />\nMost of the time, the warning indicates the use of the wrong\nfunction, a probable confusion between the side-effect only version\nof a function (which is a procedure whose result is irrelevant) with\nits functional counterpart (whose result is meaningful).<br />\nIn the example mentioned above, the first situation prevailed, and\nthe programmer should have called <code>iter</code> instead of <code>map</code>, and\nsimply write\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">List.iter f l;\nprint_newline ()\n</code></pre>\n<p>In actual programs, the suitable (side-effect only) function may not\nexist and has to be written: very often, a careful separation of the\nprocedural part from the functional part of the function at hand\nelegantly solves the problem, and the resulting program just looks\nbetter afterwards! For instance, you would turn the problematic\ndefinition:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let add x y =\n  if x &gt; 1 then print_int x;\n  print_newline ();\n  x + y;;\n</code></pre>\n<p>into the clearer separate definitions and change old calls to <code>add</code>\naccordingly.</p>\n<p>In any case, use the <code>let _ = ...</code> construction exactly in those cases\nwhere you want to ignore a result. Don't systematically replace\nsequences with this construction.</p>\n<blockquote>\n<p><strong>Justification</strong>: Sequences are much clearer! Compare <code>e1; e2; e3</code> to</p>\n<pre><code class=\"language-ocaml\">let _ = e1 in\nlet _ = e2 in\ne3\n</code></pre>\n</blockquote>\n<h3 id=\"the-hd-and-tl-functions\">The <code>hd</code> and <code>tl</code> functions</h3>\n<p>Don't use the <code>hd</code> and <code>tl</code> functions, but pattern-match the list\nargument explicitly.</p>\n<blockquote>\n<p><strong>Justification</strong>: This is just as brief as and much clearer than\nusing <code>hd</code> and <code>tl</code> which must of necessity be protected by\n<code>try... with...</code> to catch the exception which might be raised by these\nfunctions.</p>\n</blockquote>\n<h3 id=\"loops\">Loops</h3>\n<h4 id=\"for-loops\"><code>for</code> loops</h4>\n<p>To simply traverse an array or a string, use a <code>for</code> loop.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">for i = 0 to Array.length v - 1 do\n  ...\ndone\n</code></pre>\n<p>If the loop is complex or returns a result, use a recursive function.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let find_index e v =\n  let rec loop i =\n    if i &gt;= Array.length v then raise Not_found else\n    if v.(i) = e then i else loop (i + 1) in\n  loop 0;;\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The recursive function lets you code any loop\nwhatsoever simply, even a complex one, for example with multiple exit\npoints or with strange index steps (steps depending on a data value\nfor example).</p>\n<p>Besides, the recursive loop avoids the use of mutables whose value can\nbe modified in any part of the body of the loop whatsoever (or even\noutside): on the contrary the recursive loop explicitly takes as\narguments the values susceptible to change during the recursive calls.</p>\n</blockquote>\n<h4 id=\"while-loops\"><code>while</code> loops</h4>\n<blockquote>\n<p><strong>While loops law</strong>: Beware: usually a while loop is wrong, unless its\nloop invariant has been explicitly written.</p>\n</blockquote>\n<p>The main use of the <code>while</code> loop is the infinite loop\n<code>while true do     ...</code>. You get out of it through an exception,\ngenerally on termination of the program.</p>\n<p>Other <code>while</code> loops are hard to use, unless they come from canned\nprograms from algorithms courses where they were proved.</p>\n<blockquote>\n<p><strong>Justification</strong>: <code>while</code> loops require one or more mutables in order\nthat the loop condition change value and the loop finally terminate.\nTo prove their correctness, you must therefore discover the loop\ninvariants, an interesting but difficult sport.</p>\n</blockquote>\n<h3 id=\"exceptions\">Exceptions</h3>\n<p>Don't be afraid to define your own exceptions in your programs, but on\nthe other hand use as much as possible the exceptions predefined by the\nsystem. For example, every search function which fails should raise the\npredefined exception <code>Not_found</code>. Be careful to handle the exceptions\nwhich may be raised by a function call with the help of a\n<code>try ... with</code>.</p>\n<p>Handling all exceptions by <code>try     ... with _ -&gt;</code> is usually reserved\nfor the main function of the program. If you need to catch all\nexceptions to maintain an invariant of an algorithm, be careful to name\nthe exception and re-raise it, after having reset the invariant.\nTypically:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let ic = open_in ...\nand oc = open_out ... in\ntry\n  treatment ic oc;\n  close_in ic; close_out oc\nwith x -&gt; close_in ic; close_out oc; raise x\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: <code>try ... with _     -&gt;</code> silently catches all\nexceptions, even those which have nothing to do with the computation\nat hand (for example an interruption will be captured and the\ncomputation will continue anyway!).</p>\n</blockquote>\n<h3 id=\"data-structures\">Data structures</h3>\n<p>One of the great strengths of OCaml is the power of the data structures\nwhich can be defined and the simplicity of manipulating them. So you\nmust take advantage of this to the fullest extent; don't hesitate to\ndefine your own data structures. In particular, don't systematically\nrepresent enumerations by whole numbers, nor enumerations with two cases\nby booleans. Examples:</p>\n<pre><code class=\"language-ocaml\">type figure =\n   | Triangle | Square | Circle | Parallelogram\ntype convexity =\n   | Convex | Concave | Other\ntype type_of_definition =\n   | Recursive | Non_recursive\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: A boolean value often prevents intuitive\nunderstanding of the corresponding code. For example, if\n<code>type_of_definition</code> is coded by a boolean, what does <code>true</code> signify?\nA “normal” definition (that is, non-recursive) or a recursive\ndefinition?</p>\n<p>In the case of an enumerated type encode by an integer, it is very\ndifficult to limit the range of acceptable integers: one must define\nconstruction functions that will ensure the mandatory invariants of\nthe program (and verify afterwards that no values has been built\ndirectly), or add assertions in the program and guards in pattern\nmatchings. This is not good practice, when the definition of a sum\ntype elegantly solves this problem, with the additional benefit of\nfiring the full power of pattern matching and compiler's verifications\nof exhaustiveness.</p>\n<p><strong>Criticism</strong>: For binary enumerations, one can systematically define\npredicates whose names carry the semantics of the boolean that\nimplements the type. For instance, we can adopt the convention that a\npredicate ends by the letter <code>p</code>. Then, in place of defining a new sum\ntype for <code>type_of_definition</code>, we will use a predicate function\n<code>recursivep</code> that returns true if the definition is recursive.</p>\n<p><strong>Answer</strong>: This method is specific to binary enumeration and cannot\nbe easily extended; moreover it is not well suited to pattern\nmatching. For instance, for definitions encoded by\n<code>| Let of bool * string * expression</code> a typical pattern matching would\nlook like:</p>\n<pre><code class=\"language-ocaml\">| Let (_, v, e) as def -&gt;\n   if recursivep def then code_for_recursive_case\n   else code_for_non_recursive_case\n</code></pre>\n<p>or, if <code>recursivep</code> can be applied to booleans:</p>\n<pre><code class=\"language-ocaml\">| Let (b, v, e) -&gt;\n   if recursivep b then code_for_recursive_case\n   else code_for_non_recursive_case\n</code></pre>\n<p>contrast with an explicit encoding:</p>\n<pre><code class=\"language-ocaml\">| Let (Recursive, v, e) -&gt; code_for_recursive_case\n| Let (Non_recursive, v, e) -&gt; code_for_non_recursive_case\n</code></pre>\n<p>The difference between the two programs is subtle and you may think\nthat this is just a matter of taste; however the explicit encoding is\ndefinitively more robust to modifications and fits better with the\nlanguage.</p>\n</blockquote>\n<p><em>A contrario</em>, it is not necessary to systematically define new types\nfor boolean flags, when the interpretation of constructors <code>true</code> and\n<code>false</code> is clear. The usefulness of the definition of the following\ntypes is then questionable:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">type switch = On | Off\ntype bit = One | Zero\n</code></pre>\n<p>The same objection is admissible for enumerated types represented as\nintegers, when those integers have an evident interpretation with\nrespect to the data to be represented.</p>\n<h3 id=\"when-to-use-mutables\">When to use mutables</h3>\n<p>Mutable values are useful and sometimes indispensable to simple and\nclear programming. Nevertheless, you must use them with discernment:\nOCaml's normal data structures are immutable. They are to be preferred\nfor the clarity and safety of programming which they allow.</p>\n<h3 id=\"iterators\">Iterators</h3>\n<p>OCaml's iterators are a powerful and useful feature. However you should\nnot overuse them, nor <em>a contrario</em> neglect them: they are provided to\nyou by libraries and have every chance of being correct and\nwell-thought-out by the author of the library. So it's useless to\nreinvent them.</p>\n<p>So write</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let square_elements elements = List.map square elements\n</code></pre>\n<p>rather than:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec square_elements = function\n  | [] -&gt; []\n  | elem :: elements -&gt; square elem :: square_elements elements\n</code></pre>\n<p>On the other hand avoid writing:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let iterator f x l =\n  List.fold_right (List.fold_left f) [List.map x l] l\n</code></pre>\n<p>even though you get:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">  let iterator f x l =\n    List.fold_right (List.fold_left f) [List.map x l] l;;\n  iterator (fun l x -&gt; x :: l) (fun l -&gt; List.rev l) [[1; 2; 3]]\n</code></pre>\n<p>In case of express need, you must be careful to add an explanatory\ncomment: in my opinion it's absolutely necessary!</p>\n<h3 id=\"how-to-optimize-programs\">How to optimize programs</h3>\n<blockquote>\n<p><strong>Pseudo law of optimization</strong>: No optimization <em>a priori</em>.<br />\nNo optimization <em>a posteriori</em> either.</p>\n</blockquote>\n<p>Above all program simply and clearly. Don't start optimizing until the\nprogram bottleneck has been identified (in general a few routines). Then\noptimization consists above all of changing <em>the complexity</em> of the\nalgorithm used. This often happens through redefining the data\nstructures being manipulated and completely rewriting the part of the\nprogram which poses a problem.</p>\n<blockquote>\n<p><strong>Justification</strong>: Clarity and correctness of programs take\nprecedence. Besides, in a substantial program, it is practically\nimpossible to identify <em>a priori</em> the parts of the program whose\nefficiency is of prime importance.</p>\n</blockquote>\n<h3 id=\"how-to-choose-between-classes-and-modules\">How to choose between classes and modules</h3>\n<p>You should use OCaml classes when you need inheritance, that is,\nincremental refinement of data and their functionality.</p>\n<p>You should use conventional data structures (in particular, variant\ntypes) when you need pattern-matching.</p>\n<p>You should use modules when the data structures are fixed and their\nfunctionality is equally fixed or it's enough to add new functions in\nthe programs which use them.</p>\n<h3 id=\"clarity-of-ocaml-code\">Clarity of OCaml code</h3>\n<p>The OCaml language includes powerful constructs which allow simple and\nclear programming. The main problem to obtain crystal clear programs it\nto use them appropriately.</p>\n<p>The language features numerous programming styles (or programming\nparadigms): imperative programming (based on the notion of state and\nassignment), functional programming (based on the notion of function,\nfunction results, and calculus), object oriented programming (based of\nthe notion of objects encapsulating a state and some procedures or\nmethods that can modify the state). The first work of the programmer is\nto choose the programming paradigm that fits the best the problem at\nhand. When using one of those programming paradigms, the difficulty is\nto use the language construct that expresses in the most natural and\neasiest way the computation that implements the algorithm.</p>\n<h4 id=\"style-dangers\">Style dangers</h4>\n<p>Concerning programming styles, one can usually observe the two\nsymmetrical problematic behaviors: on the one hand, the “all\nimperative” way (<em>systematic</em> usage of loops and assignment), and on\nthe other hand the “purely functional” way (<em>never</em> use loops nor\nassignments); the “100% object” style will certainly appear in the\nnext future, but (fortunately) it is too new to be discussed here.</p>\n<ul>\n<li><strong>The “Too much imperative” danger</strong>:\n<ul>\n<li>It is a bad idea to use imperative style to code a function that\nis <em>naturally</em> recursive. For instance, to compute the length of\na list, you should not write:\n</li>\n</ul>\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let list_length l =\n  let l = ref l in\n  let res = ref 0 in\n  while !l &lt;&gt; [] do\n    incr res; l := List.tl !l\n  done;\n  !res;;\n</code></pre>\n<p>in place of the following recursive function, so simple and\nclear:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let rec list_length = function\n  | [] -&gt; 0\n  | _ :: l -&gt; 1 + list_length l\n</code></pre>\n<p>(For those that would contest the equivalence of those two\nversions, see the <a href=\"#Imperativeandfunctionalversionsoflistlength\">note below</a>).</p>\n<ul>\n<li>\n<p>Another common “over imperative error” in the imperative world is\nnot to systematically choose the simple <code>for</code> loop to iter on the\nelement of a vector, but instead to use a complex <code>while</code> loop, with\none or two references (too many useless assignments, too many\nopportunity for errors).</p>\n</li>\n<li>\n<p>This category of programmer feels that the <code>mutable</code> keyword in\nthe record type definitions should be implicit.</p>\n</li>\n<li>\n<p><strong>The “Too much functional” danger</strong>:</p>\n<ul>\n<li>The programmer that adheres to this dogma avoids\nusing arrays and assignment. In the most severe case, one\nobserves a complete denial of writing any imperative\nconstruction, even in case it is evidently the most elegant way\nto solve the problem.\n</li>\n<li>Characteristic symptoms: systematic rewriting of <code>for</code> loops\nwith recursive functions, usage of lists in contexts where\nimperative data structures seem to be mandatory to anyone,\npassing numerous global parameters of the problem to every\nfunctions, even if a global reference would be perfect to avoid\nthese spurious parameters that are mainly invariants that must\nbe passed all over the place.\n</li>\n<li>This programmer feels that the <code>mutable</code> keyword in the record\ntype definitions should be suppressed from the language.\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ocaml-code-generally-considered-unreadable\">OCaml code generally considered unreadable</h4>\n<p>The OCaml language includes powerful constructs which allow simple and\nclear programming. However the power of these constructs also lets you\nwrite uselessly complicated code, to the point where you get a perfectly\nunreadable program.</p>\n<p>Here are a number of known ways:</p>\n<ul>\n<li>Use useless (hence novice for readability) <code>if then else</code>, as in\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let flush_ps () =\n  if not !psused then psused := true\n</code></pre>\n<p>or (more subtle)</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let sync b =\n  if !last_is_dvi &lt;&gt; b then last_is_dvi := b\n</code></pre>\n<ul>\n<li>Code one construct with another. For example code a <code>let ... in</code> by\nthe application of an anonymous function to an argument. You would\nwrite<br />\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">(fun x y -&gt; x + y)\n   e1 e2\n</code></pre>\n<p>instead of simply writing</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let x = e1\nand y = e2 in\nx + y\n</code></pre>\n<ul>\n<li>\n<p>Systematically code sequences with <code>let in</code> bindings.</p>\n</li>\n<li>\n<p>Mix computations and side effects, particularly in function calls.\nRecall that the order of evaluation of arguments in a function call\nis unspecified, which implies that you must not mix side effects and\ncomputations in function calls. However, when there is only one\nargument you might take advantage of this to perform a side effect\nwithin the argument, which is extremely troublesome for the reader\nalbeit without danger to the program semantics. To be absolutely\nforbidden.</p>\n</li>\n<li>\n<p>Misuse of iterators and higher-order functions (i.e. over- or\nunder-use). For example it's better to use <code>List.map</code> or\n<code>List.iter</code> than to write their equivalents in-line using specific\nrecursive functions of your own. Even worse, you don't use\n<code>List.map</code> or <code>List.iter</code> but write their equivalents in terms of\n<code>List.fold_right</code> and <code>List.fold_left</code>.</p>\n</li>\n<li>\n<p>Another efficient way to write unreadable code is to mix all or some\nof these methods. For example:</p>\n</li>\n</ul>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">(fun u -&gt; print_string &quot;world&quot;; print_string u)\n  (let temp = print_string &quot;Hello&quot;; &quot;!&quot; in\n   ((fun x -&gt; print_string x; flush stdout) &quot; &quot;;\n    temp));;\n</code></pre>\n<p>If you naturally write the program <code>print_string &quot;Hello world!&quot;</code> in this\nway, you can without a doubt submit your work to the <a href=\"mailto:Pierre.Weis@inria.fr\">Obfuscated OCaml\nContest</a>.</p>\n<h2 id=\"managing-program-development\">Managing program development</h2>\n<p>We give here tips from veteran OCaml programmers, which have served in\ndeveloping the compilers which are good examples of large complex\nprograms developed by small teams.</p>\n<h3 id=\"how-to-edit-programs\">How to edit programs</h3>\n<p>Many developers nurture a kind of veneration towards the Emacs editor\n(gnu-emacs in general) which they use to write their programs. The\neditor interfaces well with the language since it is capable of syntax\ncoloring OCaml source code (rendering different categories of words in\ncolor, coloring keywords for example).</p>\n<p>The following two commands are considered indispensable:</p>\n<ul>\n<li><code>CTRL-C-CTRL-C</code> or <code>Meta-X compile</code>: launches re-compilation from\nwithin the editor (using the <code>make</code> command).\n</li>\n<li><code>CTRL-X-`</code>: puts the cursor in the file and at the exact place\nwhere the OCaml compiler has signaled an error.\n</li>\n</ul>\n<p>Developers describe thus how to use these features: <code>CTRL-C-CTRL-C</code>\ncombination recompiles the whole application; in case of errors, a\nsuccession of <code>CTRL-X-`</code> commands permits correction of all the\nerrors signaled; the cycle begins again with a new re-compilation\nlaunched by <code>CTRL-C-CTRL-C</code>.</p>\n<h4 id=\"other-emacs-tricks\">Other emacs tricks</h4>\n<p>The <code>ESC-/</code> command (dynamic-abbrev-expand) automatically completes the\nword in front of the cursor with one of the words present in one of the\nfiles being edited. Thus this lets you always choose meaningful\nidentifiers without the tedium of having to type extended names in your\nprograms: the <code>ESC-/</code> easily completes the identifier after typing the\nfirst letters. In case it brings up the wrong completion, each\nsubsequent <code>ESC-/</code> proposes an alternate completion.</p>\n<p>Under Unix, the <code>CTRL-C-CTRL-C</code> or <code>Meta-X     compile</code> combination,\nfollowed by <code>CTRL-X-`</code> is also used to find all occurrences of a\ncertain string in a OCaml program. Instead of launching <code>make</code> to\nrecompile, you launch the <code>grep</code> command; then all the “error\nmessages” from <code>grep</code> are compatible with the <code>CTRL-X-`</code> usage\nwhich automatically takes you to the file and the place where the string\nis found.</p>\n<h3 id=\"how-to-edit-with-the-interactive-system\">How to edit with the interactive system</h3>\n<p>Under Unix: use the line editor <code>ledit</code> which offers great editing\ncapabilities “à la emacs” (including <code>ESC-/</code>!), as well as a history\nmechanism which lets you retrieve previously typed commands and even\nretrieve commands from one session in another. <code>ledit</code> is written in\nOCaml and can be freely down-loaded\n<a href=\"ftp://ftp.inria.fr/INRIA/Projects/cristal/caml-light/bazar-ocaml/ledit.tar.gz\">here</a>.</p>\n<h3 id=\"how-to-compile\">How to compile</h3>\n<p>The <code>make</code> utility is indispensable for managing the compilation and\nre-compilation of programs. Sample <code>make</code> files can be found on <a href=\"https://caml.inria.fr//cgi-bin/hump.en.cgi\">The\nHump</a>. You can also consult\nthe <code>Makefiles</code> for the OCaml compilers.</p>\n<h3 id=\"how-to-develop-as-a-team-version-control\">How to develop as a team: version control</h3>\n<p>Users of the <a href=\"https://git-scm.com/\">Git</a> software version control system\nnever run out of good things to say about the productivity gains it\nbrings. This system supports managing development by a team of\nprogrammers while imposing consistency among them, and also maintains a\nlog of changes made to the software.<br />\nGit also supports simultaneous development by several teams, possibly\ndispersed among several sites linked on the Net.</p>\n<p>An anonymous Git read-only mirror <a href=\"https://github.com/ocaml/ocaml\">contains the working sources of the\nOCaml compilers</a>, and the sources of\nother software related to OCaml.</p>\n<h2 id=\"notes\">Notes</h2>\n<h3 id=\"imperative-and-functional-versions-of-listlength\">Imperative and functional versions of <code>list_length</code></h3>\n<p>The two versions of <code>list_length</code> are not completely equivalent in term\nof complexity, since the imperative version uses a constant amount of\nstack room to execute, whereas the functional version needs to store\nreturn addresses of suspended recursive calls (whose maximum number is\nequal to the length of the list argument). If you want to retrieve a\nconstant space requirement to run the functional program you just have\nto write a function that is recursive in its tail (or <em>tail-rec</em>), that\nis a function that just ends by a recursive call (which is not the case\nhere since a call to <code>+</code> has to be perform after the recursive call has\nreturned). Just use an accumulator for intermediate results, as in:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let list_length l =\n  let rec loop accu = function\n    | [] -&gt; accu\n    | _ :: l -&gt; loop (accu + 1) l in\n  loop 0 l\n</code></pre>\n<p>This way, you get a program that has the same computational properties\nas the imperative program with the additional clarity and natural\nlook of an algorithm that performs pattern matching and recursive\ncalls to handle an argument that belongs to a recursive sum data type.</p>\n","title":"OCaml Programming Guidelines","pageDescription":"Opinionated guidelines for writing OCaml code\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#general-guidelines-to-write-programs\">General guidelines to write programs</a>\n</li>\n<li><a href=\"#program-formatting-guidelines\">Program formatting guidelines</a>\n</li>\n<li><a href=\"#indentation-of-programs\">Indentation of programs</a>\n</li>\n<li><a href=\"#programming-guidelines\">Programming guidelines</a>\n</li>\n<li><a href=\"#managing-program-development\">Managing program development</a>\n</li>\n<li><a href=\"#notes\">Notes</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"ocaml-programming-guidelines"}},"__N_SSG":true}