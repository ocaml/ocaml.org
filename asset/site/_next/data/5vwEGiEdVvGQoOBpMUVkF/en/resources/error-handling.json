{"pageProps":{"content":{"source":"<h2 id=\"exceptions\">Exceptions</h2>\n<p>One way of handling errors in OCaml is exceptions. The\nstandard library relies heavily upon them.</p>\n<p>Exceptions belong to the type <code>exn</code> (an extensible sum type):</p>\n<pre><code class=\"language-ocaml\">exception Foo of string\n\nlet i_will_fail () =\n  raise (Foo &quot;Oh no!&quot;)\n</code></pre>\n<p>Here, we add a variant <code>Foo</code> to the type <code>exn</code>, and create a function\nthat will raise this exception. Now, how do we handle exceptions?\nThe construct is <code>try ... with ...</code>:</p>\n<pre><code class=\"language-ocaml\">let safe_inverse n =\n  try Some (1 / n) with\n    Division_by_zero -&gt; None\n\nlet safe_list_find p l =\n  try Some (List.find p l) with\n    Not_found -&gt; None\n</code></pre>\n<p>We can try those functions:</p>\n<pre><code class=\"language-ocaml\"># 1 / 0;;\nException: Division_by_zero.\n# safe_inverse 2;;\n- : int option = Some 0\n# safe_inverse 0;;\n- : int option = None\n# List.find (fun x -&gt; x mod 2 = 0) [1; 3; 5]\nException: Not_found.\n# safe_list_find (fun x -&gt; x mod 2 = 0) [1; 3; 4; 5]\n- : int option = Some 4\n# safe_list_find (fun x -&gt; x mod 2 = 0) [1; 3; 5]\n- : int option = None\n</code></pre>\n<p>The biggest issue with exceptions is that they do not appear in types.\nOne has to read the documentation to see that, indeed, <code>Map.S.find</code>\nor <code>List.hd</code> are not total functions, and that they might fail.</p>\n<p>It is considered good practice nowadays, when a function can fail in\ncases that are not bugs (i.e., not <code>assert false</code>, but network failures,\nkeys not present, etc.)\nto return a more explicit type such as <code>'a option</code> or <code>('a, 'b) result</code>.\nA relatively common idiom is to have such a safe version of the function,\nsay, <code>val foo : a -&gt; b option</code>, and an exception raising\nversion <code>val foo_exn : a -&gt; b</code>.</p>\n<h3 id=\"documentation\">Documentation</h3>\n<p>Functions that can raise exceptions should be documented like this:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">val foo : a -&gt; b\n(** foo does this and that, here is how it works, etc.\n    @raise Invalid_argument if [a] doesn't satisfy ...\n    @raise Sys_error if filesystem is not happy *)\n</code></pre>\n<h3 id=\"stacktraces\">Stacktraces</h3>\n<p>To get a stacktrace when a unhandled exception makes your program crash, you\nneed to compile the program in &quot;debug&quot; mode (with <code>-g</code> when calling\n<code>ocamlc</code>, or <code>-tag 'debug'</code> when calling <code>ocamlbuild</code>).\nThen:</p>\n<pre><code>OCAMLRUNPARAM=b ./myprogram [args]\n</code></pre>\n<p>And you will get a stacktrace. Alternatively, you can call, from within the program,</p>\n<pre><code class=\"language-ocaml\">let () = Printexc.record_backtrace true\n</code></pre>\n<h3 id=\"printing\">Printing</h3>\n<p>To print an exception, the module <code>Printexc</code> comes in handy. For instance,\nthe following function <code>notify_user : (unit -&gt; 'a) -&gt; 'a</code> can be used\nto call a function and, if it fails, print the exception on <code>stderr</code>.\nIf stacktraces are enabled, this function will also display it.</p>\n<pre><code class=\"language-ocaml\">let notify_user f =\n  try f () with e -&gt;\n    let msg = Printexc.to_string e\n    and stack = Printexc.get_backtrace () in\n      Printf.eprintf &quot;there was an error: %s%s\\n&quot; msg stack;\n      raise e\n</code></pre>\n<p>OCaml knows how to print its built-in exception, but you can also tell it\nhow to print your own exceptions:</p>\n<pre><code class=\"language-ocaml\">exception Foo of int\n\nlet () =\n  Printexc.register_printer\n    (function\n      | Foo i -&gt; Some (Printf.sprintf &quot;Foo(%d)&quot; i)\n      | _ -&gt; None (* for other exceptions *)\n    )\n</code></pre>\n<p>Each printer should take care of the exceptions it knows about, returning\n<code>Some &lt;printed exception&gt;</code>, and return <code>None</code> otherwise (let the other printers\ndo the job!).</p>\n<h2 id=\"result-type\">Result type</h2>\n<p>The Stdlib module contains the following type:</p>\n<pre><code class=\"language-ocaml\">type ('a, 'b) result =\n  | Ok of 'a\n  | Error of 'b\n</code></pre>\n<p>A value <code>Ok x</code> means that the computation succeeded with <code>x</code>, and\na value <code>Error e</code> means that it failed.\nPattern matching can be used to deal with both cases, as with any\nother sum type. The advantage here is that a function <code>a -&gt; b</code> that\nfails can be modified so its type is <code>a -&gt; (b, error) result</code>,\nwhich makes the failure explicit.\nThe error case <code>e</code> in <code>Error e</code> can be of any type\n(the <code>'b</code> type variable), but a few possible choices\nare:</p>\n<ul>\n<li><code>exn</code>, in which case the result type just makes exceptions explicit.\n</li>\n<li><code>string</code>, where the error case is a message that indicates what failed.\n</li>\n<li><code>string lazy_t</code>, a more elaborate form of error message that is only evaluated\nif printing is required.\n</li>\n<li>some polymorphic variant, with one case per\npossible error. This is very accurate (each error can be dealt with\nexplicitly and occurs in the type) but the use of polymorphic variants\nsometimes make error messages hard to read.\n</li>\n</ul>\n<p>For easy combination of functions that can fail, many alternative standard\nlibraries provide useful combinators on the <code>result</code> type: <code>map</code>, <code>&gt;&gt;=</code>, etc.</p>\n","title":"Error Handling","pageDescription":"Discover the different ways you can manage errors in your OCaml programs\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#exceptions\">Exceptions</a>\n</li>\n<li><a href=\"#result-type\">Result type</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"error-handling"}},"__N_SSG":true}