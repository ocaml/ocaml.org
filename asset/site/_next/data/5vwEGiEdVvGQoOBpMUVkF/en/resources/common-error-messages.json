{"pageProps":{"content":{"source":"<p>This page gives a list of quick explanations for some error or warning\nmessages that are emitted by the OCaml compilers. Longer explanations\nare usually given in dedicated sections of this tutorial.</p>\n<h2 id=\"type-errors\">Type errors</h2>\n<h3 id=\"this-expression-has-type--but-is-here-used-with-type-\">This expression has type ... but is here used with type ...</h3>\n<p>When the type of an object is not compatible with the context in which\nit is used, it is frequent to obtain this kind of message:</p>\n<pre><code class=\"language-ocaml\"># 1 + 2.5\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n</code></pre>\n<p>&quot;This expression has type <em>X</em> but is here used with type <em>Y</em>&quot; means that\nif the contents of the expression is isolated (2.5), its type is\ninferred as <em>X</em> (float). But the context, i.e. everything which is\naround (1 + ...) tells that the gap expects an expression of type <em>Y</em>\n(int) which is not compatible with <em>X</em>.</p>\n<p>More disturbing is the following message:</p>\n<pre><code class=\"language-text\">This expression has type my_type but is here used with type my_type\n</code></pre>\n<p>This error happens often while testing some type definitions using the\ninteractive toplevel.  In OCaml, it is perfectly legal\nto define a type with a name\nthat is already taken by another type. Consider the following session:</p>\n<pre><code class=\"language-ocaml\"># type my_type = A | B\ntype my_type = A | B\n# let a = A\nval a : my_type = A\n# type my_type = A | B\ntype my_type = A | B\n# let b = B\nval b : my_type = B\n# a = b\nLine 1, characters 5-6:\nError: This expression has type my_type/1\n       but an expression was expected of type my_type/2\n       Hint: The type my_type has been defined multiple times in this\n         toplevel session. Some toplevel values still refer to old versions\n         of this type. Did you try to redefine them?\n</code></pre>\n<p>For the compiler, the second definition of my_type is totally\nindependent from the first definition. So we have defined two types\nwhich have the same name. Since &quot;a&quot; was defined earlier, it belongs to\nthe first type while &quot;b&quot; belongs to the second type. In this example,\nredefining &quot;a&quot; after the last definition of my_type solves the problem.\nThis kind of problem should not happen in real programs unless you use\nthe same name for the same type in the same module, which is highly\ndiscouraged.</p>\n<h3 id=\"warning-this-optional-argument-cannot-be-erased\">Warning: This optional argument cannot be erased</h3>\n<p>Functions with optional arguments must have at least one non-labelled\nargument. For instance, this is not OK:</p>\n<pre><code class=\"language-ocaml\"># let f ?(x = 0) ?(y = 0) = print_int (x + y)\nLine 1, characters 18-23:\nWarning 16: this optional argument cannot be erased.\nval f : ?x:int -&gt; ?y:int -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>The solution is simply to add one argument of type unit, like this:</p>\n<pre><code class=\"language-ocaml\"># let f ?(x = 0) ?(y = 0) () = print_int (x + y)\nval f : ?x:int -&gt; ?y:int -&gt; unit -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>See the <a href=\"labels.html\" title=\"Labels\">Labels</a> section for more details on\nfunctions with labelled arguments.</p>\n<h3 id=\"the-type-of-this-expression-contains-type-variables-that-cannot-be-generalized\">The type of this expression... contains type variables that cannot be generalized</h3>\n<p>This happens in some cases when the full type of an object is not known\nby the compiler when it reaches the end of the compilation unit (file)\nbut for some reason it cannot remain polymorphic. Example:</p>\n<pre><code class=\"language-ocaml\"># let x = ref None\nval x : '_weak1 option ref = {contents = None}\n</code></pre>\n<p>triggers the following message during the compilation:</p>\n<pre><code class=\"language-text\">The type of this expression, '_a option ref,\ncontains type variables that cannot be generalized\n</code></pre>\n<p>Solution: help the compiler with a type annotation, like for instance:</p>\n<pre><code class=\"language-ocaml\"># let x : string option ref = ref None\nval x : string option ref = {contents = None}\n</code></pre>\n<p>or:</p>\n<pre><code class=\"language-ocaml\"># let x = ref (None : string option)\nval x : string option ref = {contents = None}\n</code></pre>\n<p>Data of type <code>'_weak&lt;n&gt;</code> may be allowed temporarily, for instance during a\ntoplevel session. It means that the given object has an unknown type,\nbut it cannot be any type: it is not polymorphic data. In the toplevel,\nour example gives these results:</p>\n<pre><code class=\"language-ocaml\"># let x = ref None\nval x : '_weak2 option ref = {contents = None}\n</code></pre>\n<p>The compiler tells us that the type of x is not fully known yet. But by\nusing <code>x</code> later, the compiler can infer the type of <code>x</code>:</p>\n<pre><code class=\"language-ocaml\"># x := Some 0\n- : unit = ()\n</code></pre>\n<p>Now <code>x</code> has a known type:</p>\n<pre><code class=\"language-ocaml\"># x\n- : int option ref = {contents = Some 0}\n</code></pre>\n<h2 id=\"pattern-matching-warnings-and-errors\">Pattern matching warnings and errors</h2>\n<h3 id=\"this-pattern-is-unused\">This pattern is unused</h3>\n<p>This warning should be considered as an error, since there is no reason\nto intentionally keep such code. It may happen when the programmer\nintroduced a catch-all pattern unintentionally such as in the following\nsituation:</p>\n<pre><code class=\"language-ocaml\"># let test_member x tup =\n  match tup with\n  | (y, _) | (_, y) when y = x -&gt; true\n  | _ -&gt; false\nLine 3, characters 14-20:\nWarning 12: this sub-pattern is unused.\nLine 3, characters 5-20:\nWarning 57: Ambiguous or-pattern variables under guard;\nvariable y may match different arguments. (See manual section 9.5)\nval test_member : 'a -&gt; 'a * 'a -&gt; bool = &lt;fun&gt;\n</code></pre>\n<p>Obviously, the programmer had a misconception of what OCaml's pattern\nmatching is about. Remember the following:</p>\n<ul>\n<li>the tree of cases is traversed linearly, from left to right. There\nis <em>no backtracking</em> as in regexp matching.\n</li>\n<li>a guard (&quot;when&quot; clause) is not part of a pattern. It is simply a\ncondition which is evaluated at most once and is used as a last\nresort to jump to the next match case.\n</li>\n<li>lowercase identifiers (bindings such as &quot;y&quot; above) are just names,\nso they will always match.\n</li>\n</ul>\n<p>In our example, it is now clear that only the first item of the pair\nwill ever be tested. This leads to the following results:</p>\n<pre><code class=\"language-ocaml\"># test_member 1 (1, 0)\n- : bool = true\n# test_member 1 (0, 1)\n- : bool = false\n</code></pre>\n<h3 id=\"this-pattern-matching-is-not-exhaustive\">This pattern-matching is not exhaustive</h3>\n<p>OCaml's pattern matching can check whether a set of patterns is\nexhaustive or not, based on the <em>type</em> only. So in the following\nexample, the compiler doesn't know what range of ints the &quot;mod&quot; operator\nwould return:</p>\n<pre><code class=\"language-ocamltop\">let is_even x =\n  match x mod 2 with\n  | 0 -&gt; true\n  | 1 | -1 -&gt; false\n</code></pre>\n<p>A short solution without pattern matching would be:</p>\n<pre><code class=\"language-ocaml\"># let is_even x = x mod 2 = 0\nval is_even : int -&gt; bool = &lt;fun&gt;\n</code></pre>\n<p>In general, that kind of simplification is not possible and the best\nsolution is to add a catch-all case which should never be reached:</p>\n<pre><code class=\"language-ocaml\"># let is_even x =\n  match x mod 2 with\n  | 0 -&gt; true\n  | 1 | -1 -&gt; false\n  | _ -&gt; assert false\nval is_even : int -&gt; bool = &lt;fun&gt;\n</code></pre>\n<h2 id=\"problems-recompiling-valid-programs\">Problems recompiling valid programs</h2>\n<h3 id=\"xcmi-is-not-a-compiled-interface\">x.cmi is not a compiled interface</h3>\n<p>When recompiling some old program or compiling a program from an\nexternal source that was not cleaned properly, it is possible to get\nthis error message:</p>\n<pre><code class=\"language-text\">some_module.cmi is not a compiled interface\n</code></pre>\n<p>It means that some_module.cmi is not valid according to the <em>current\nversion</em> of the OCaml compiler. Most of the time, removing the old\ncompiled files (*.cmi, *.cmo, *.cmx, ...) and recompiling is\nsufficient to solve this problem.</p>\n<h3 id=\"warning-illegal-backslash-escape-in-string\">Warning: Illegal backslash escape in string</h3>\n<p>Recent versions of OCaml warn you against unprotected backslashes in\nstrings since they should be doubled. Such a message may be displayed\nwhen compiling an older program, and can be turned off with the <code>-w x</code>\noption.</p>\n<pre><code class=\"language-ocaml\"># &quot;\\e\\n&quot; (* bad practice *)\nFile &quot;_none_&quot;, line 1, characters 1-3:\nWarning 14: illegal backslash escape in string.\n- : string = &quot;\\\\e\\n&quot;\n# &quot;\\\\e\\n&quot; (* good practice *)\n- : string = &quot;\\\\e\\n&quot;\n</code></pre>\n","title":"Common Error Messages","pageDescription":"Understand the most common error messages the OCaml compiler can throw at you\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#type-errors\">Type errors</a>\n</li>\n<li><a href=\"#pattern-matching-warnings-and-errors\">Pattern matching warnings and errors</a>\n</li>\n<li><a href=\"#problems-recompiling-valid-programs\">Problems recompiling valid programs</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"common-error-messages"}},"__N_SSG":true}