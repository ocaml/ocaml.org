{"pageProps":{"content":{"source":"<h2 id=\"objects-and-classes\">Objects and classes</h2>\n<p>OCaml is an object-oriented, imperative, functional programming language\n:-) It mixes all these paradigms and lets you use the most appropriate\n(or most familiar) programming paradigm for the task at hand. In this\nchapter I'm going to look at object-oriented programming in OCaml, but\nI'm also going to talk about why you might or might not want to write\nobject-oriented programs.</p>\n<p>The classic noddy example used in text books to demonstrate\nobject-oriented programming is the stack class. This is a pretty\nterrible example in many ways, but I'm going to use it here to show the\nbasics of writing object-oriented OCaml.</p>\n<p>Here's some basic code to provide a stack of integers. The class is\nimplemented using a linked list.</p>\n<pre><code class=\"language-ocaml\"># class stack_of_ints =\n  object (self)\n    val mutable the_list = ([] : int list)     (* instance variable *)\n    method push x =                            (* push method *)\n      the_list &lt;- x :: the_list\n    method pop =                               (* pop method *)\n      let result = List.hd the_list in\n      the_list &lt;- List.tl the_list;\n      result\n    method peek =                              (* peek method *)\n      List.hd the_list\n    method size =                              (* size method *)\n      List.length the_list\n  end\nclass stack_of_ints :\n  object\n    val mutable the_list : int list\n    method peek : int\n    method pop : int\n    method push : int -&gt; unit\n    method size : int\n  end\n</code></pre>\n<p>The basic pattern <code>class name = object (self) ... end</code> defines a class\ncalled <code>name</code>.</p>\n<p>The class has one instance variable, which is mutable (not constant),\ncalled <code>the_list</code>. This is the underlying linked list. We initialize\nthis (each time a <code>stack_of_ints</code> object is created) using a bit of code\nthat you may not be familiar with. The expression <code>( [] : int list )</code>\nmeans &quot;an empty list, of type <code>int list</code>&quot;. Recall that the simple empty\nlist <code>[]</code> has type <code>'a list</code>, meaning a list of any type. However we\nwant a stack of <code>int</code>, not anything else, and so in this case we want to\ntell the type inference engine that this list isn't the general &quot;list of\nanything&quot; but is in fact the narrower &quot;list of <code>int</code>&quot;. The syntax\n<code>( expression : type )</code> means <code>expression</code> which is in fact of type\n<code>type</code>. This <em>isn't</em> a general type cast, because you can't use it to\noverrule the type inference engine, only to narrow a general type to\nmake it more specific. So you can't write, for example, <code>( 1 : float )</code>:</p>\n<pre><code class=\"language-ocaml\"># (1 : float)\nLine 1, characters 2-3:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.'?\n</code></pre>\n<p>Type safety is preserved. Back to the example ...</p>\n<p>This class has four simple methods. <code>push</code> pushes an integer onto the\nstack. <code>pop</code> pops the top integer off the stack and returns it. Notice\nthe <code>&lt;-</code> assignment operator used for updating our mutable instance\nvariable. It's the same <code>&lt;-</code> assignment operator which is used for\nupdating mutable fields in records.</p>\n<p><code>peek</code> returns the top of the stack (ie. head of the list) without\naffecting the stack, while <code>size</code> returns the number of elements in the\nstack (ie. the length of the list).</p>\n<p>Let's write some code to test stacks of ints. First let's create a new\nobject. We use the familiar <code>new</code> operator:</p>\n<pre><code class=\"language-ocaml\"># let s = new stack_of_ints\nval s : stack_of_ints = &lt;obj&gt;\n</code></pre>\n<p>Now we'll push and pop some elements off the stack:</p>\n<pre><code class=\"language-ocaml\"># for i = 1 to 10 do\n    s#push i\n  done\n- : unit = ()\n# while s#size &gt; 0 do\n    Printf.printf &quot;Popped %d off the stack.\\n&quot; s#pop\n  done\nPopped 10 off the stack.\nPopped 9 off the stack.\nPopped 8 off the stack.\nPopped 7 off the stack.\nPopped 6 off the stack.\nPopped 5 off the stack.\nPopped 4 off the stack.\nPopped 3 off the stack.\nPopped 2 off the stack.\nPopped 1 off the stack.\n- : unit = ()\n</code></pre>\n<p>Notice the syntax. <code>object#method</code> means call <code>method</code> on <code>object</code>. This\nis the same as <code>object.method</code> or <code>object-&gt;method</code> that you will be\nfamiliar with in imperative languages.</p>\n<p>In the OCaml toplevel we can examine the types of objects and methods in\nmore detail:</p>\n<pre><code class=\"language-ocaml\"># let s = new stack_of_ints\nval s : stack_of_ints = &lt;obj&gt;\n# s#push\n- : int -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p><code>s</code> is an opaque object. The implementation (ie. the list) is hidden\nfrom callers.</p>\n<h3 id=\"polymorphic-classes\">Polymorphic classes</h3>\n<p>A stack of integers is good, but what about a stack that can store any\ntype? (Not a single stack that can store a mixture of types, but\nmultiple stacks each storing objects of any single type). As with\n<code>'a list</code>, we can define <code>'a stack</code>:</p>\n<pre><code class=\"language-ocaml\"># class ['a] stack =\n  object (self)\n    val mutable list = ([] : 'a list)    (* instance variable *)\n    method push x =                      (* push method *)\n      list &lt;- x :: list\n    method pop =                         (* pop method *)\n      let result = List.hd list in\n      list &lt;- List.tl list;\n      result\n    method peek =                        (* peek method *)\n      List.hd list\n    method size =                        (* size method *)\n      List.length list\n  end\nclass ['a] stack :\n  object\n    val mutable list : 'a list\n    method peek : 'a\n    method pop : 'a\n    method push : 'a -&gt; unit\n    method size : int\n  end\n</code></pre>\n<p>The <code>class ['a] stack</code> doesn't really define just one class, but a whole\n&quot;class of classes&quot;, one for every possible type (ie. an infinitely large\nnumber of classes!) Let's try and use our <code>'a stack</code> class. In this\ninstance we create a stack and push a floating point number onto the\nstack. Notice the type of the stack:</p>\n<pre><code class=\"language-ocaml\"># let s = new stack\nval s : '_weak1 stack = &lt;obj&gt;\n# s#push 1.0\n- : unit = ()\n# s\n- : float stack = &lt;obj&gt;\n</code></pre>\n<p>This stack is now a <code>float stack</code>, and only floating point numbers may\nbe pushed and popped from this stack. Let's demonstrate the type-safety\nof our new <code>float stack</code>:</p>\n<pre><code class=\"language-ocaml\"># s#push 3.0\n- : unit = ()\n# s#pop\n- : float = 3.\n# s#pop\n- : float = 1.\n# s#push &quot;a string&quot;\nLine 1, characters 8-18:\nError: This expression has type string but an expression was expected of type\n         float\n</code></pre>\n<p>We can define polymorphic functions which can operate on any type of\nstack. Our first attempt is this one:</p>\n<pre><code class=\"language-ocaml\"># let drain_stack s =\n  while s#size &gt; 0 do\n    ignore (s#pop)\n  done\nval drain_stack : &lt; pop : 'a; size : int; .. &gt; -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>Notice the type of <code>drain_stack</code>. Cleverly - perhaps <em>too</em> cleverly -\nOCaml's type inference engine has worked out that <code>drain_stack</code> works on\n<em>any</em> object which has <code>pop</code> and <code>size</code> methods! So if we defined\nanother, entirely separate class which happened to contain <code>pop</code> and\n<code>size</code> methods with suitable type signatures, then we might accidentally\ncall <code>drain_stack</code> on objects of that other type.</p>\n<p>We can force OCaml to be more specific and only allow <code>drain_stack</code> to\nbe called on <code>'a stack</code>s by narrowing the type of the <code>s</code> argument, like\nthis:</p>\n<pre><code class=\"language-ocaml\"># let drain_stack (s : 'a stack) =\n  while s#size &gt; 0 do\n    ignore (s#pop)\n  done\nval drain_stack : 'a stack -&gt; unit = &lt;fun&gt;\n</code></pre>\n<h3 id=\"inheritance-virtual-classes-initializers\">Inheritance, virtual classes, initializers</h3>\n<p>I've noticed programmers in Java tend to overuse inheritance, possibly\nbecause it's the only reasonable way of extending code in that language.\nA much better and more general way to extend code is usually to use\nhooks (cf. Apache's module API). Nevertheless in certain narrow areas\ninheritance can be useful, and the most important of these is in writing\nGUI widget libraries.</p>\n<p>Let's consider an imaginary OCaml widget library similar to Java's\nSwing. We will define buttons and labels with the following class\nhierarchy:</p>\n<pre><code>widget  (superclass for all widgets)\n  |\n  +----&gt; container  (any widget that can contain other widgets)\n  |        |\n  |        +----&gt; button\n  |\n  +-------------&gt; label\n</code></pre>\n<p>(Notice that a <code>button</code> is a <code>container</code> because it can contain either a\nlabel or an image, depending on what is displayed on the button).</p>\n<p><code>widget</code> is the virtual superclass for all widgets. I want every widget\nto have a name (just a string) which is constant over the life of that\nwidget. This was my first attempt:</p>\n<pre><code class=\"language-ocaml\"># class virtual widget name =\n  object (self)\n    method get_name =\n      name\n    method virtual repaint : unit\n  end\nLines 1-6, characters 1-6:\nError: Some type variables are unbound in this type:\n         class virtual widget :\n           'a -&gt;\n           object method get_name : 'a method virtual repaint : unit end\n       The method get_name has type 'a where 'a is unbound\n</code></pre>\n<p>Oops! I forgot that OCaml cannot infer the type of <code>name</code> so will assume\nthat it is <code>'a</code>. But that defines a polymorphic class, and I didn't\ndeclare the class as polymorphic (<code>class ['a] widget</code>). I need to narrow\nthe type of <code>name</code> like this:</p>\n<pre><code class=\"language-ocaml\"># class virtual widget (name : string) =\n  object (self)\n    method get_name =\n      name\n    method virtual repaint : unit\n  end;;\nclass virtual widget :\n  string -&gt; object method get_name : string method virtual repaint : unit end\n</code></pre>\n<p>Now there are several new things going on in this code. Firstly the\nclass contains an <strong>initializer</strong>. This is an argument to the class\n(<code>name</code>) which you can think of as exactly the equivalent of an argument\nto a constructor in, eg., Java:</p>\n<pre><code class=\"language-java\">public class Widget\n{\n  public Widget (String name)\n  {\n    ...\n  }\n}\n</code></pre>\n<p>In OCaml a constructor constructs the whole class, it's not just a\nspecially named function, so we write the arguments as if they are\narguments to the class:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">class foo arg1 arg2 ... =\n</code></pre>\n<p>Secondly the class contains a virtual method, and thus the whole class\nis marked as virtual. The virtual method is our <code>repaint</code> method. We\nneed to tell OCaml it's virtual (<code>method virtual</code>), <em>and</em> we need to\ntell OCaml the type of the method. Because the method doesn't contain\nany code, OCaml can't use type inference to automatically work out the\ntype for you, so you need to tell it the type. In this case the method\njust returns <code>unit</code>. If your class contains any virtual methods (even\njust inherited ones) then you need to specify the whole class as virtual\nby using <code>class virtual ...</code>.</p>\n<p>As in C++ and Java, virtual classes cannot be directly instantiated\nusing <code>new</code>:</p>\n<pre><code class=\"language-ocaml\"># let w = new widget &quot;my widget&quot;\nLine 1, characters 9-19:\nError: Cannot instantiate the virtual class widget\n</code></pre>\n<p>Now my <code>container</code> class is more interesting. It must inherit from\n<code>widget</code> and have the mechanics for storing the list of contained\nwidgets. Here is my simple implementation for <code>container</code>:</p>\n<pre><code class=\"language-ocaml\"># class virtual container name =\n  object (self)\n    inherit widget name\n    val mutable widgets = ([] : widget list)\n    method add w =\n      widgets &lt;- w :: widgets\n    method get_widgets =\n      widgets\n    method repaint =\n      List.iter (fun w -&gt; w#repaint) widgets\n  end\nclass virtual container :\n  string -&gt;\n  object\n    val mutable widgets : widget list\n    method add : widget -&gt; unit\n    method get_name : string\n    method get_widgets : widget list\n    method repaint : unit\n  end\n</code></pre>\n<p>Notes:</p>\n<ol>\n<li>The <code>container</code> class is marked as virtual. It doesn't contain any\nvirtual methods, but in this case I just want to prevent people\ncreating containers directly.\n</li>\n<li>The <code>container</code> class has a <code>name</code> argument which is passed directly\nup when constructing the <code>widget</code>.\n</li>\n<li><code>inherit widget name</code> means that the <code>container</code> inherits from\n<code>widget</code>, and it passes the <code>name</code> argument to the constructor for\n<code>widget</code>.\n</li>\n<li>My <code>container</code> contains a mutable list of widgets and methods to\n<code>add</code> a widget to this list and <code>get_widgets</code> (return the list of\nwidgets).\n</li>\n<li>The list of widgets returned by <code>get_widgets</code> cannot be modified by\ncode outside the class. The reason for this is somewhat subtle, but\nbasically comes down to the fact that OCaml's linked lists are\nimmutable. Let's imagine that someone wrote this code:\n</li>\n</ol>\n<pre><code class=\"language-ocaml\"># let list = container#get_widgets in\n  x :: list\n</code></pre>\n<p>Would this modify the private internal representation of my <code>container</code>\nclass, by prepending <code>x</code> to the list of widgets? No it wouldn't. The\nprivate variable <code>widgets</code> would be unaffected by this or any other\nchange attempted by the outside code. This means, for example, that you\ncould change the internal representation to use an array at some later\ndate, and no code outside the class would need to be changed.</p>\n<p>Last, but not least, we have implemented the previously virtual\n<code>repaint</code> function so that <code>container#repaint</code> will repaint all of the\ncontained widgets. Notice I use <code>List.iter</code> to iterate over the list,\nand I also use a probably unfamiliar anonymous function expression:</p>\n<pre><code class=\"language-ocaml\"># (fun w -&gt; w#repaint)\n- : &lt; repaint : 'a; .. &gt; -&gt; 'a = &lt;fun&gt;\n</code></pre>\n<p>which defines an anonymous function with one argument <code>w</code> that just\ncalls <code>w#repaint</code> (the <code>repaint</code> method on widget <code>w</code>).</p>\n<p>In this instance our <code>button</code> class is simple (rather unrealistically\nsimple in fact, but nevermind that):</p>\n<pre><code class=\"language-ocaml\"># type button_state = Released | Pressed\ntype button_state = Released | Pressed\n# class button ?callback name =\n  object (self)\n    inherit container name as super\n    val mutable state = Released\n    method press =\n      state &lt;- Pressed;\n      match callback with\n      | None -&gt; ()\n      | Some f -&gt; f ()\n    method release =\n      state &lt;- Released\n    method repaint =\n      super#repaint;\n      print_endline (&quot;Button being repainted, state is &quot; ^\n                     (match state with\n                      | Pressed -&gt; &quot;Pressed&quot;\n                      | Released -&gt; &quot;Released&quot;))\n  end\nclass button :\n  ?callback:(unit -&gt; unit) -&gt;\n  string -&gt;\n  object\n    val mutable state : button_state\n    val mutable widgets : widget list\n    method add : widget -&gt; unit\n    method get_name : string\n    method get_widgets : widget list\n    method press : unit\n    method release : unit\n    method repaint : unit\n  end\n</code></pre>\n<p>Notes:</p>\n<ol>\n<li>This function has an optional argument (see the previous chapter)\nwhich is used to pass in the optional callback function. The\ncallback is called when the button is pressed.\n</li>\n<li>The expression <code>inherit container name as super</code> names the\nsuperclass <code>super</code>. I use this in the <code>repaint</code> method:\n<code>super#repaint</code>. This expressly calls the superclass method.\n</li>\n<li>Pressing the button (calling <code>button#press</code> in this rather\nsimplistic code) sets the state of the button to <code>Pressed</code> and calls\nthe callback function, if one was defined. Notice that the\n<code>callback</code> variable is either <code>None</code> or <code>Some f</code>, in other words it\nhas type <code>(unit -&gt; unit) option</code>. Reread the previous chapter if you\nare unsure about this.\n</li>\n<li>Notice a strange thing about the <code>callback</code> variable. It's defined\nas an argument to the class, but any method can see and use it. In\nother words, the variable is supplied when the object is\nconstructed, but persists over the lifetime of the object.\n</li>\n<li>The <code>repaint</code> method has been implemented. It calls the superclass\n(to repaint the container), then repaints the button, displaying the\ncurrent state of the button.\n</li>\n</ol>\n<p>Before defining our <code>label</code> class, let's play with the <code>button</code> class in\nthe OCaml toplevel:</p>\n<pre><code class=\"language-ocaml\"># let b = new button ~callback:(fun () -&gt; print_endline &quot;Ouch!&quot;) &quot;button&quot;\nval b : button = &lt;obj&gt;\n# b#repaint\nButton being repainted, state is Released\n- : unit = ()\n# b#press\nOuch!\n- : unit = ()\n# b#repaint\nButton being repainted, state is Pressed\n- : unit = ()\n# b#release\n- : unit = ()\n</code></pre>\n<p>Here's our comparatively trivial <code>label</code> class:</p>\n<pre><code class=\"language-ocaml\"># class label name text =\n  object (self)\n    inherit widget name\n    method repaint =\n      print_endline (&quot;Label: &quot; ^ text)\n  end\nclass label :\n  string -&gt;\n  string -&gt; object method get_name : string method repaint : unit end\n</code></pre>\n<p>Let's create a label which says &quot;Press me!&quot; and add it to the button:</p>\n<pre><code class=\"language-ocaml\"># let l = new label &quot;label&quot; &quot;Press me!&quot;\nval l : label = &lt;obj&gt;\n# b#add l\n- : unit = ()\n# b#repaint\nLabel: Press me!\nButton being repainted, state is Released\n- : unit = ()\n</code></pre>\n<h3 id=\"a-note-about-self\">A note about <code>self</code></h3>\n<p>In all the examples above we defined classes using the general pattern:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">class name =\n  object (self)\n    (* ... *)\n  end\n</code></pre>\n<p>I didn't explain the reference to <code>self</code>. In fact this names the object,\nallowing you to call methods in the same class or pass the object to\nfunctions outside the class. In other words, it's exactly the same as\n<code>this</code> in C++/Java. You may completely omit the\n<code>(self)</code> part if you don't need to refer to yourself - indeed in all the\nexamples above we could have done exactly that. However, I would advise\nyou to leave it in there because you never know when you might modify\nthe class and require the reference to <code>self</code>. There is no penalty for\nhaving it.</p>\n<h3 id=\"inheritance-and-coercions\">Inheritance and coercions</h3>\n<pre><code class=\"language-ocaml\"># let b = new button &quot;button&quot;\nval b : button = &lt;obj&gt;\n# let l = new label &quot;label&quot; &quot;Press me!&quot;\nval l : label = &lt;obj&gt;\n# [b; l]\nLine 1, characters 5-6:\nError: This expression has type label but an expression was expected of type\n         button\n       The first object type has no method add\n</code></pre>\n<p>I created a button <code>b</code> and a label <code>l</code> and I tried to create a list\ncontaining both, but I got an error. Yet <code>b</code> and <code>l</code> are both <code>widget</code>s,\nso why can't I put them into the same list? Perhaps OCaml can't guess\nthat I want a <code>widget list</code>? Let's try telling it:</p>\n<pre><code class=\"language-ocaml\"># let wl = ([] : widget list)\nval wl : widget list = []\n# let wl = b :: wl\nLine 1, characters 15-17:\nError: This expression has type widget list\n       but an expression was expected of type button list\n       Type widget = &lt; get_name : string; repaint : unit &gt;\n       is not compatible with type\n         button =\n           &lt; add : widget -&gt; unit; get_name : string;\n             get_widgets : widget list; press : unit; release : unit;\n             repaint : unit &gt;\n       The first object type has no method add\n</code></pre>\n<p>It turns out that OCaml doesn't coerce subclasses to the type of the\nsuperclass by default, but you can tell it to by using the <code>:&gt;</code>\n(coercion) operator:</p>\n<pre><code class=\"language-ocaml\"># let wl = (b :&gt; widget) :: wl\nval wl : widget list = [&lt;obj&gt;]\n# let wl = (l :&gt; widget) :: wl\nval wl : widget list = [&lt;obj&gt;; &lt;obj&gt;]\n</code></pre>\n<p>The expression <code>(b :&gt; widget)</code> means &quot;coerce the button <code>b</code> to have type\n<code>widget</code>&quot;. Type-safety is preserved because it is possible to tell\ncompletely at compile time whether the coercion will succeed.</p>\n<p>Actually, coercions are somewhat more subtle than described above, and\nso I urge you to read the manual to find out the full details.</p>\n<p>The <code>container#add</code> method defined above is actually incorrect, and\nfails if you try to add widgets of different types into a <code>container</code>. A\ncoercion would fix this.</p>\n<p>Is it possible to coerce from a superclass (eg. <code>widget</code>) to a subclass\n(eg. <code>button</code>)? The answer, perhaps surprisingly, is NO! Coercing in\nthis direction is <em>unsafe</em>. You might try to coerce a <code>widget</code> which is\nin fact a <code>label</code>, not a <code>button</code>.</p>\n<h3 id=\"the-oo-module-and-comparing-objects\">The <code>Oo</code> module and comparing objects</h3>\n<p>The <code>Oo</code> module contains a few useful functions for OO programming.</p>\n<p><code>Oo.copy</code> makes a shallow copy of an object. <code>Oo.id object</code> returns a\nunique identifying number for each object (a unique number across all\nclasses).</p>\n<p><code>=</code> and <code>&lt;&gt;</code> can be used to compare objects for <em>physical</em> equality (an\nobject and its copy are not physically identical). You can also use <code>&lt;</code>\netc. which provides an ordering of objects based apparently on their\nIDs.</p>\n<h2 id=\"objects-without-class\">Objects without class</h2>\n<p>Here we examine how to use objects pretty much like records, without\nnecessarily using classes.</p>\n<h3 id=\"immediate-objects-and-object-types\">Immediate objects and object types</h3>\n<p>Objects can be used instead of records, and have some nice properties\nthat can make them preferable to records in some cases. We saw that the\ncanonical way of creating objects is to first define a class, and use\nthis class to create individual objects. This can be cumbersome in some\nsituations since class definitions are more than a type definition and\ncannot be defined recursively with types. However, objects have a type\nthat is very analog to a record type, and it can be used in type\ndefinitions. In addition, objects can be created without a class. They\nare called <em>immediate objects</em>. Here is the definition of an immediate\nobject:</p>\n<pre><code class=\"language-ocaml\"># let o =\n  object\n    val mutable n = 0\n    method incr = n &lt;- n + 1\n    method get = n\n  end\nval o : &lt; get : int; incr : unit &gt; = &lt;obj&gt;\n</code></pre>\n<p>This object has a type, which is defined by its public methods only.\nValues are not visible and neither are private methods (not shown).\nUnlike records, such a type does not need to be predefined explicitly,\nbut doing so can make things clearer. We can do it like this:</p>\n<pre><code class=\"language-ocaml\"># type counter = &lt;get : int; incr : unit&gt;\ntype counter = &lt; get : int; incr : unit &gt;\n</code></pre>\n<p>Compare with an equivalent record type definition:</p>\n<pre><code class=\"language-ocaml\"># type counter_r =\n  {get : unit -&gt; int;\n   incr : unit -&gt; unit}\ntype counter_r = { get : unit -&gt; int; incr : unit -&gt; unit; }\n</code></pre>\n<p>The implementation of a record working like our object would be:</p>\n<pre><code class=\"language-ocaml\"># let r =\n  let n = ref 0 in\n    {get = (fun () -&gt; !n);\n     incr = (fun () -&gt; incr n)}\nval r : counter_r = {get = &lt;fun&gt;; incr = &lt;fun&gt;}\n</code></pre>\n<p>In terms of functionality, both the object and the record are similar,\nbut each solution has its own advantages:</p>\n<ul>\n<li><strong>speed</strong>: slightly faster field access in records\n</li>\n<li><strong>field names</strong>: it is inconvenient to manipulate records of\ndifferent types when some fields are named identically but it's not\na problem with objects\n</li>\n<li><strong>subtyping</strong>: it is impossible to coerce the type of a record to a\ntype with less fields. That is however possible with objects, so\nobjects of different kinds that share some methods can be mixed in a\ndata structure where only their common methods are visible (see next\nsection)\n</li>\n<li><strong>type definitions</strong>: there is no need to define an object type in\nadvance, so it lightens the dependency constraints between modules\n</li>\n</ul>\n<h3 id=\"class-types-vs-just-types\">Class types vs. just types</h3>\n<p>Beware of the confusion between <em>class types</em> and object <em>types</em>. A\n<em>class type</em> is not a data <em>type</em>, normally referred to as <em>type</em> in the\nOCaml jargon. An object <em>type</em> is a kind of data <em>type</em>, just like a\nrecord type or a tuple.</p>\n<p>When a class is defined, both a <em>class type</em> and an object <em>type</em> of the\nsame name are defined:</p>\n<pre><code class=\"language-ocaml\"># class t =\n  object\n    val x = 0\n    method get = x\n  end\nclass t : object val x : int method get : int end\n</code></pre>\n<p><code>object val x : int method get : int end</code> is a class type.</p>\n<p>In this example, <code>t</code> is also the type of objects that this class would\ncreate. Objects that derive from different classes or no class at all\n(immediate objects) can be mixed together as long as they have the same\ntype:</p>\n<pre><code class=\"language-ocaml\"># let x = object method get = 123 end\nval x : &lt; get : int &gt; = &lt;obj&gt;\n# let l = [new t; x]\nval l : t list = [&lt;obj&gt;; &lt;obj&gt;]\n</code></pre>\n<p>Mixing objects that share a common subtype can be done, but requires\nexplicit type coercion using the <code>:&gt;</code> operator:</p>\n<pre><code class=\"language-ocaml\"># let x = object method get = 123 end\nval x : &lt; get : int &gt; = &lt;obj&gt;\n# let y = object method get = 80 method special = &quot;hello&quot; end\nval y : &lt; get : int; special : string &gt; = &lt;obj&gt;\n# let l = [x; y]\nLine 1, characters 13-14:\nError: This expression has type &lt; get : int; special : string &gt;\n       but an expression was expected of type &lt; get : int &gt;\n       The second object type has no method special\n# let l = [x; (y :&gt; t)]\nval l : t list = [&lt;obj&gt;; &lt;obj&gt;]\n</code></pre>\n","title":"Objects","pageDescription":"OCaml is an object-oriented, imperative, functional programming language\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#objects-and-classes\">Objects and classes</a>\n</li>\n<li><a href=\"#objects-without-class\">Objects without class</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"objects"}},"__N_SSG":true}