{"pageProps":{"content":{"source":"<p>In this tutorial we learn how to read command line arguments directly, using\nOCaml's <code>Sys.argv</code> array, and then how to do so more easily using the standard\nlibrary's <code>Arg</code> module.</p>\n<h2 id=\"sysargv\">Sys.argv</h2>\n<p>Like in C and many other languages, the arguments that are passed to a given\nprogram on the command line are stored in an array. Following tradition, this\narray is named <code>argv</code>. It is found in the <code>Sys</code> module of the standard library,\ntherefore its full name is <code>Sys.argv</code>. The number of arguments including the\nname of the program itself is simply the length of the array. It is obtained\nusing the <code>Array.length</code> function.</p>\n<p>The following program displays the arguments with their position in <code>Sys.argv</code>:</p>\n<!-- $MDX file=examples/args.ml -->\n<pre><code class=\"language-ocaml\">let () =\n  for i = 0 to Array.length Sys.argv - 1 do\n    Printf.printf &quot;[%i] %s\\n&quot; i Sys.argv.(i)\n  done\n</code></pre>\n<p>If you save the program above as <code>args.ml</code>, and run <code>ocaml args.ml arg1 arg2 arg3</code>, here is what you get:</p>\n<!-- $MDX dir=examples -->\n<pre><code class=\"language-sh\">$ ocaml args.ml arg1 arg2 arg3\n[0] args.ml\n[1] arg1\n[2] arg2\n[3] arg3\n</code></pre>\n<p>Note that <code>ocaml</code> launched a subprocess that actually runs the program where\nargv is <code>args.ml arg1 arg2 arg3</code>. You can also compile your program using\n<code>ocamlopt -o args args.ml</code>, and then running <code>./args arg1 arg2 arg3</code> and you\nwill get:</p>\n<!-- $MDX dir=examples -->\n<pre><code class=\"language-sh\">$ ocamlopt -o args args.ml\n$ ./args arg1 arg2 arg3\n[0] ./args\n[1] arg1\n[2] arg2\n[3] arg3\n</code></pre>\n<h2 id=\"using-the-arg-module\">Using the Arg module</h2>\n<p>The OCaml standard library has a module for writing command line interfaces, so\nwe do not have to use <code>Sys.argv</code> directly. We shall consider the example from\nthe OCaml documentation, a program for appending files.</p>\n<p>First, we set up the usage message to be printed in the case of a malformed\ncommand line, or when help is requested:</p>\n<!-- $MDX file=examples/append.ml,part=0 -->\n<pre><code class=\"language-ocaml\">let usage_msg = &quot;append [-verbose] &lt;file1&gt; [&lt;file2&gt;] ... -o &lt;output&gt;&quot;\n</code></pre>\n<p>Now, we create some references to hold the information gathered from the\ncommand line. The <code>Arg</code> module will fill these in for us as the command line is\nread.</p>\n<!-- $MDX file=examples/append.ml,part=1 -->\n<pre><code class=\"language-ocaml\">let verbose = ref false\n\nlet input_files = ref []\n\nlet output_file = ref &quot;&quot;\n</code></pre>\n<p>We have a boolean reference for the <code>-verbose</code> flag with a default value of\n<code>false</code>. Then we have a reference to a list which will hold the names of all\nthe input files. Finally, we have a string reference into which the single\noutput file name specified by <code>-o</code> will be placed.</p>\n<p>We will need a function to handle the anonymous inputs, that is to say the ones\nwith no flag before them. In this case these are our input file names. Our\nfunction simply adds the file name to the reference defined earlier.</p>\n<!-- $MDX file=examples/append.ml,part=2 -->\n<pre><code class=\"language-ocaml\">let anon_fun filename = input_files := filename :: !input_files\n</code></pre>\n<p>Finally we build the list of command line flag specifcations. Each is a tuple\nof the flag name, the action to be taken when it is encountered, and the help\nstring.</p>\n<!-- $MDX file=examples/append.ml,part=3 -->\n<pre><code class=\"language-ocaml\">let speclist =\n  [\n    (&quot;-verbose&quot;, Arg.Set verbose, &quot;Output debug information&quot;);\n    (&quot;-o&quot;, Arg.Set_string output_file, &quot;Set output file name&quot;);\n  ]\n</code></pre>\n<p>We have two kinds of action here: the <code>Arg.Set</code> action which sets a boolean\nreference, and the <code>Arg.Set_string</code> action which sets a string reference. Our\n<code>input_files</code> reference will of course be updated by the <code>anon_fun</code> function\nalready defined.</p>\n<p>We can now call <code>Arg.parse</code>, giving it our specification list, anonymous\nfunction, and usage message. Once it returns, the references will be filled\nwith all the information required to append our files.</p>\n<!-- $MDX file=examples/append.ml,part=4 -->\n<pre><code class=\"language-ocaml\">let () = Arg.parse speclist anon_fun usage_msg\n\n(* Main functionality here *)\n</code></pre>\n<p>Let's save our program as <code>append.ml</code> and compile it with <code>ocamlopt -o append append.ml</code> and try it out:</p>\n<!-- $MDX dir=examples -->\n<pre><code class=\"language-sh\">$ ocamlopt -o append append.ml\n$ ./append -verbose one.txt two.txt -o three.txt\n$ ./append one.txt two.txt\n$ ./append -quiet\n./append: unknown option '-quiet'.\nappend [-verbose] &lt;file1&gt; [&lt;file2&gt;] ... -o &lt;output&gt;\n  -verbose Output debug information\n  -o Set output file name\n  -help  Display this list of options\n  --help  Display this list of options\n[2]\n$ ./append -help\nappend [-verbose] &lt;file1&gt; [&lt;file2&gt;] ... -o &lt;output&gt;\n  -verbose Output debug information\n  -o Set output file name\n  -help  Display this list of options\n  --help  Display this list of options\n</code></pre>\n<p>Here is the whole program:</p>\n<pre><code class=\"language-ocaml\">let usage_msg = &quot;append [-verbose] &lt;file1&gt; [&lt;file2&gt;] ... -o &lt;output&gt;&quot;\n\nlet verbose = ref false\n\nlet input_files = ref []\n\nlet output_file = ref &quot;&quot;\n\nlet anon_fun filename =\n  input_files := filename :: !input_files\n\nlet speclist =\n  [(&quot;-verbose&quot;, Arg.Set verbose, &quot;Output debug information&quot;);\n   (&quot;-o&quot;, Arg.Set_string output_file, &quot;Set output file name&quot;)]\n\nlet () =\n  Arg.parse speclist anon_fun usage_msg;\n  (* Main functionality here *)\n</code></pre>\n<p>The <code>Arg</code> module has many more actions than just <code>Set</code> and <code>Set_string</code>, and\nsome lower-level function for parsing more complicated command lines.</p>\n<h2 id=\"other-tools-for-parsing-command-line-options\">Other tools for parsing command-line options</h2>\n<p>There are libraries with facilities different from or more extensive than the\nbuilt-in <code>Arg</code> module:</p>\n<ul>\n<li>\n<p><a href=\"https://erratique.ch/software/cmdliner/doc/Cmdliner\">Cmdliner</a> is a modern\ninterface for command line processing, which also generates UNIX man pages\nautomatically.</p>\n</li>\n<li>\n<p><a href=\"https://opam.ocaml.org/packages/clap/\">Clap</a> is an imperative command line\nparser.</p>\n</li>\n<li>\n<p><a href=\"https://opam.ocaml.org/packages/minicli/\">Minicli</a> has good support for\nrejecting malformed command lines which others might sliently accept.</p>\n</li>\n<li>\n<p><a href=\"https://opam.ocaml.org/packages/getopt/\">Getopt</a> for OCaml is similar to\n<a href=\"https://www.gnu.org/software/libc/manual/html_node/Getopt.html\">GNU getopt</a>.</p>\n</li>\n</ul>\n","title":"Command-line Arguments","pageDescription":"The Arg module that comes with the compiler can help you write command line interfaces\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#sysargv\">Sys.argv</a>\n</li>\n<li><a href=\"#using-the-arg-module\">Using the Arg module</a>\n</li>\n<li><a href=\"#other-tools-for-parsing-command-line-options\">Other tools for parsing command-line options</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"command-line-arguments"}},"__N_SSG":true}