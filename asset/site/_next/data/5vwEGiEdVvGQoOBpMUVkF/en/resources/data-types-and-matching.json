{"pageProps":{"content":{"source":"<p>In this tutorial we learn how to build our own types in OCaml, and how to write\nfunctions which process this new data.</p>\n<h2 id=\"built-in-compound-types\">Built-in compound types</h2>\n<p>We have already seen simple data types such as <code>int</code>, <code>float</code>, <code>string</code>, and\n<code>bool</code>.  Let's recap the built-in compound data types we can use in OCaml to\ncombine such values. First, we have lists which are ordered collections of any\nnumber of elements of like type:</p>\n<pre><code class=\"language-ocaml\"># []\n- : 'a list = []\n# [1; 2; 3]\n- : int list = [1; 2; 3]\n# [[1; 2]; [3; 4]; [5; 6]]\n- : int list list = [[1; 2]; [3; 4]; [5; 6]]\n# [false; true; false]\n- : bool list = [false; true; false]\n</code></pre>\n<p>Next, we have tuples, which collect a fixed number of elements together:</p>\n<pre><code class=\"language-ocaml\"># (5.0, 6.5)\n- : float * float = (5., 6.5)\n# (true, 0.0, 0.45, 0.73, &quot;french blue&quot;)\n- : bool * float * float * float * string =\n(true, 0., 0.45, 0.73, &quot;french blue&quot;)\n</code></pre>\n<p>We have records, which are like labeled tuples. They are defined by writing a\ntype definition giving a name for the record, and names for each of its fields,\nand their types:</p>\n<pre><code class=\"language-ocaml\"># type point = {x : float; y : float}\ntype point = { x : float; y : float; }\n# let a = {x = 5.0; y = 6.5}\nval a : point = {x = 5.; y = 6.5}\n# type colour = {websafe : bool; r : float; g : float; b : float; name : string}\ntype colour = {\n  websafe : bool;\n  r : float;\n  g : float;\n  b : float;\n  name : string;\n}\n# let b = {websafe = true; r = 0.0; g = 0.45; b = 0.73; name = &quot;french blue&quot;}\nval b : colour =\n  {websafe = true; r = 0.; g = 0.45; b = 0.73; name = &quot;french blue&quot;}\n</code></pre>\n<p>A record must contain all fields:</p>\n<pre><code class=\"language-ocaml\"># let c = {name = &quot;puce&quot;}\nLine 1, characters 9-24:\nError: Some record fields are undefined: websafe r g b\n</code></pre>\n<p>Records may be mutable:</p>\n<pre><code class=\"language-ocaml\"># type person =\n  {first_name : string;\n   surname : string;\n   mutable age : int}\ntype person = { first_name : string; surname : string; mutable age : int; }\n# let birthday p =\n  p.age &lt;- p.age + 1\nval birthday : person -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>Another mutable compound data type is the fixed-length array which, just as a\nlist, must contain elements of like type. However, its elements may be accessed\nin constant time:</p>\n<pre><code class=\"language-ocaml\"># let arr = [|1; 2; 3|]\nval arr : int array = [|1; 2; 3|]\n# arr.(0)\n- : int = 1\n# arr.(0) &lt;- 0\n- : unit = ()\n# arr\n- : int array = [|0; 2; 3|]\n</code></pre>\n<p>In this tutorial, we will define our own compound data types, using the <code>type</code>\nkeyword, and some of these built-in structures as building blocks.</p>\n<h2 id=\"a-simple-custom-type\">A simple custom type</h2>\n<p>We can define a new data type <code>colour</code> which can take one of four values.</p>\n<pre><code class=\"language-ocaml\">type colour = Red | Green | Blue | Yellow\n</code></pre>\n<p>Our new type is called <code>colour</code>, and has four <em>constructors</em> <code>Red</code>, <code>Green</code>,\n<code>Blue</code> and <code>Yellow</code>. The name of the type must begin with a lower case letter,\nand the names of the constructors with upper case letters. We can use our new\ntype anywhere a built-in type could be used:</p>\n<pre><code class=\"language-ocaml\"># let additive_primaries = (Red, Green, Blue)\nval additive_primaries : colour * colour * colour = (Red, Green, Blue)\n# let pattern = [(1, Red); (3, Green); (1, Red); (2, Green)]\nval pattern : (int * colour) list =\n  [(1, Red); (3, Green); (1, Red); (2, Green)]\n</code></pre>\n<p>Notice the types inferred by OCaml for these expressions. We can pattern-match\non our new type, just as with any built-in type:</p>\n<pre><code class=\"language-ocaml\"># let example c =\n  match c with\n  | Red -&gt; &quot;rose&quot;\n  | Green -&gt; &quot;grass&quot;\n  | Blue -&gt; &quot;sky&quot;\n  | Yellow -&gt; &quot;banana&quot;\nval example : colour -&gt; string = &lt;fun&gt;\n</code></pre>\n<p>Notice the type of the function includes the name of our new type <code>colour</code>. We\ncan make the function shorter and elide its parameter <code>c</code> by using the\nalternative <code>function</code> keyword which allows direct matching:</p>\n<pre><code class=\"language-ocaml\"># let example = function\n  | Red -&gt; &quot;rose&quot;\n  | Green -&gt; &quot;grass&quot;\n  | Blue -&gt; &quot;sky&quot;\n  | Yellow -&gt; &quot;banana&quot;\nval example : colour -&gt; string = &lt;fun&gt;\n</code></pre>\n<p>We can match on more than one case at a time too:</p>\n<pre><code class=\"language-ocaml\"># let rec is_primary = function\n  | Red | Green | Blue -&gt; true\n  | _ -&gt; false\nval is_primary : colour -&gt; bool = &lt;fun&gt;\n</code></pre>\n<h2 id=\"constructors-with-data\">Constructors with data</h2>\n<p>Each constructor in a data type can carry additional information with it. Let's\nextend our <code>colour</code> type to allow arbitrary RGB triples, each element begin a\nnumber from 0 (no colour) to 1 (full colour):</p>\n<pre><code class=\"language-ocaml\"># type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\ntype colour = Red | Green | Blue | Yellow | RGB of float * float * float\n\n# [Red; Blue; RGB (0.5, 0.65, 0.12)]\n- : colour list = [Red; Blue; RGB (0.5, 0.65, 0.12)]\n</code></pre>\n<p>Types, just like functions, may be recursively-defined. We extend our data type\nto allow mixing of colours:</p>\n<pre><code class=\"language-ocaml\"># type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\n  | Mix of float * colour * colour\ntype colour =\n    Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\n  | Mix of float * colour * colour\n# Mix (0.5, Red, Mix (0.5, Blue, Green))\n- : colour = Mix (0.5, Red, Mix (0.5, Blue, Green))\n</code></pre>\n<p>Here is a function over our new <code>colour</code> data type:</p>\n<pre><code class=\"language-ocaml\"># let rec rgb_of_colour = function\n  | Red -&gt; (1.0, 0.0, 0.0)\n  | Green -&gt; (0.0, 1.0, 0.0)\n  | Blue -&gt; (0.0, 0.0, 1.0)\n  | Yellow -&gt; (1.0, 1.0, 0.0)\n  | RGB (r, g, b) -&gt; (r, g, b)\n  | Mix (p, a, b) -&gt;\n      let (r1, g1, b1) = rgb_of_colour a in\n      let (r2, g2, b2) = rgb_of_colour b in\n      let mix x y = x *. p +. y *. (1.0 -. p) in\n        (mix r1 r2, mix g1 g2, mix b1 b2)\nval rgb_of_colour : colour -&gt; float * float * float = &lt;fun&gt;\n</code></pre>\n<p>We can use records directly in the data type instead to label our components:</p>\n<pre><code class=\"language-ocaml\"># type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of {r : float; g : float; b : float}\n  | Mix of {proportion : float; c1 : colour; c2 : colour}\ntype colour =\n    Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of { r : float; g : float; b : float; }\n  | Mix of { proportion : float; c1 : colour; c2 : colour; }\n</code></pre>\n<h2 id=\"example-trees\">Example: trees</h2>\n<p>Data types may be polymorphic as well as recursive. Here is an OCaml data type\nfor a binary tree carrying any kind of data:</p>\n<pre><code class=\"language-ocaml\"># type 'a tree =\n  | Leaf\n  | Node of 'a tree * 'a * 'a tree\ntype 'a tree = Leaf | Node of 'a tree * 'a * 'a tree\n# let t =\n    Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Leaf))\nval t : int tree =\n  Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Leaf))\n</code></pre>\n<p>Notice that we give the type parameter <code>'a</code> before the type name (if there is\nmore than one, we write <code>('a, 'b)</code> etc).  A <code>Leaf</code> holds no information,\njust like an empty list. A <code>Node</code> holds a left tree, a value of type <code>'a</code>\nand a right tree. In our example, we built an integer tree, but any type can be\nused. Now we can write recursive and polymorphic functions over these trees, by\npattern matching on our new constructors:</p>\n<pre><code class=\"language-ocaml\"># let rec total = function\n  | Leaf -&gt; 0\n  | Node (l, x, r) -&gt; total l + x + total r\nval total : int tree -&gt; int = &lt;fun&gt;\n# let rec flip = function\n  | Leaf -&gt; Leaf\n  | Node (l, x, r) -&gt; Node (flip r, x, flip l)\nval flip : 'a tree -&gt; 'a tree = &lt;fun&gt;\n</code></pre>\n<p>Here, <code>flip</code> is polymorphic while <code>total</code> operates only on trees of type <code>int tree</code>. Let's try our new functions out:</p>\n<pre><code class=\"language-ocaml\"># let all = total t\nval all : int = 10\n# let flipped = flip t\nval flipped : int tree =\n  Node (Node (Leaf, 4, Node (Leaf, 3, Leaf)), 2, Node (Leaf, 1, Leaf))\n# t = flip flipped\n- : bool = true\n</code></pre>\n<p>Instead of integers, we could build a tree of key-value pairs. Then, if we\ninsist that the keys are unique and that a smaller key is always left of a\nlarger key, we have a data structure for dictionaries which performs better\nthan a simple list of pairs. It is known as a <em>binary search tree</em>:</p>\n<pre><code class=\"language-ocaml\"># let rec insert (k, v) = function\n  | Leaf -&gt; Node (Leaf, (k, v), Leaf)\n  | Node (l, (k', v'), r) -&gt;\n      if k &lt; k' then Node (insert (k, v) l, (k', v'), r) \n      else if k &gt; k' then Node (l, (k', v'), insert (k, v) r)\n      else Node (l, (k, v), r)\nval insert : 'a * 'b -&gt; ('a * 'b) tree -&gt; ('a * 'b) tree = &lt;fun&gt;\n</code></pre>\n<p>Similar functions can be written to look up values in a dictionary, to convert\na list of pairs to or from a tree dictionary and so on.</p>\n<h2 id=\"example-mathematical-expressions\">Example: mathematical expressions</h2>\n<p>We wish to represent simple mathematical expressions like <code>n * (x + y)</code> and\nmultiply them out symbolically to get <code>n * x + n * y</code>.</p>\n<p>Let's define a type for these expressions:</p>\n<pre><code class=\"language-ocaml\">type expr =\n  | Plus of expr * expr        (* a + b *)\n  | Minus of expr * expr       (* a - b *)\n  | Times of expr * expr       (* a * b *)\n  | Divide of expr * expr      (* a / b *)\n  | Var of string              (* &quot;x&quot;, &quot;y&quot;, etc. *)\n</code></pre>\n<p>The expression <code>n * (x + y)</code> would be written:</p>\n<pre><code class=\"language-ocaml\"># Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;))\n- : expr = Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;))\n</code></pre>\n<p>Let's write a function which prints out <code>Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;))</code> as something more like <code>n * (x + y)</code>.</p>\n<pre><code class=\"language-ocaml\"># let rec to_string e =\n  match e with\n  | Plus (left, right) -&gt;\n     &quot;(&quot; ^ to_string left ^ &quot; + &quot; ^ to_string right ^ &quot;)&quot;\n  | Minus (left, right) -&gt;\n     &quot;(&quot; ^ to_string left ^ &quot; - &quot; ^ to_string right ^ &quot;)&quot;\n  | Times (left, right) -&gt;\n   &quot;(&quot; ^ to_string left ^ &quot; * &quot; ^ to_string right ^ &quot;)&quot;\n  | Divide (left, right) -&gt;\n   &quot;(&quot; ^ to_string left ^ &quot; / &quot; ^ to_string right ^ &quot;)&quot;\n  | Var v -&gt; v\nval to_string : expr -&gt; string = &lt;fun&gt;\n# let print_expr e =\n  print_endline (to_string e)\nval print_expr : expr -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>(The <code>^</code> operator concatenates strings). We separate the function into two so\nthat our <code>to_string</code> function is usable in other contexts. Here's the\n<code>print_expr</code> function in action:</p>\n<pre><code class=\"language-ocaml\"># print_expr (Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;)))\n(n * (x + y))\n- : unit = ()\n</code></pre>\n<p>We can write a function to multiply out expressions of the form <code>n * (x + y)</code>\nor <code>(x + y) * n</code> and for this we will use a nested pattern:</p>\n<pre><code class=\"language-ocaml\"># let rec multiply_out e =\n  match e with\n  | Times (e1, Plus (e2, e3)) -&gt;\n     Plus (Times (multiply_out e1, multiply_out e2),\n           Times (multiply_out e1, multiply_out e3))\n  | Times (Plus (e1, e2), e3) -&gt;\n     Plus (Times (multiply_out e1, multiply_out e3),\n           Times (multiply_out e2, multiply_out e3))\n  | Plus (left, right) -&gt;\n     Plus (multiply_out left, multiply_out right)\n  | Minus (left, right) -&gt;\n     Minus (multiply_out left, multiply_out right)\n  | Times (left, right) -&gt;\n     Times (multiply_out left, multiply_out right)\n  | Divide (left, right) -&gt;\n     Divide (multiply_out left, multiply_out right)\n  | Var v -&gt; Var v\nval multiply_out : expr -&gt; expr = &lt;fun&gt;\n</code></pre>\n<p>Here it is in action:</p>\n<pre><code class=\"language-ocaml\"># print_expr (multiply_out (Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;))))\n((n * x) + (n * y))\n- : unit = ()\n</code></pre>\n<p>How does the <code>multiply_out</code> function work? The key is in the first two\npatterns. The first pattern is <code>Times (e1, Plus (e2, e3))</code> which matches\nexpressions of the form <code>e1 * (e2 + e3)</code>. Now look at the right hand side of\nthis first pattern match, and convince yourself that it is the equivalent of\n<code>(e1 * e2) + (e1 * e3)</code>. The second pattern does the same thing, except for\nexpressions of the form <code>(e1 + e2) * e3</code>.</p>\n<p>The remaining patterns don't change the form of the expression, but they\ncrucially <em>do</em> call the <code>multiply_out</code> function recursively on their\nsubexpressions. This ensures that all subexpressions within the expression get\nmultiplied out too (if you only wanted to multiply out the very top level of an\nexpression, then you could replace all the remaining patterns with a simple <code>e -&gt; e</code> rule).</p>\n<p>Can we do the reverse (i.e. factorizing out common subexpressions)? We can!\n(But it's a bit more complicated). The following version only works for the top\nlevel expression. You could certainly extend it to cope with all levels of an\nexpression and more complex cases:</p>\n<pre><code class=\"language-ocaml\"># let factorize e =\n  match e with\n  | Plus (Times (e1, e2), Times (e3, e4)) when e1 = e3 -&gt;\n     Times (e1, Plus (e2, e4))\n  | Plus (Times (e1, e2), Times (e3, e4)) when e2 = e4 -&gt;\n     Times (Plus (e1, e3), e4)\n  | e -&gt; e\nval factorize : expr -&gt; expr = &lt;fun&gt;\n# factorize (Plus (Times (Var &quot;n&quot;, Var &quot;x&quot;),\n                   Times (Var &quot;n&quot;, Var &quot;y&quot;)))\n- : expr = Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;))\n</code></pre>\n<p>The factorize function above introduces another couple of features. You can add\nwhat are known as <em>guards</em> to each pattern match. A guard is the conditional\nwhich follows the <code>when</code>, and it means that the pattern match only happens if\nthe pattern matches <em>and</em> the condition in the <code>when</code>-clause is satisfied.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">match value with\n| pattern [ when condition ] -&gt; result\n| pattern [ when condition ] -&gt; result\n  ...\n</code></pre>\n<p>The second feature is the <code>=</code> operator which tests for &quot;structural equality&quot;\nbetween two expressions. That means it goes recursively into each expression\nchecking they're exactly the same at all levels down.</p>\n<p>Another feature which is useful when we build more complicated nested patterns\nis the <code>as</code> keyword, which can be used to name part of an expression. For\nexample:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">Name (&quot;/DeviceGray&quot; | &quot;/DeviceRGB&quot; | &quot;/DeviceCMYK&quot;) as n -&gt; n\n\nNode (l, ((k, _) as pair), r) when k = k' -&gt; Some pair\n</code></pre>\n<h2 id=\"mutually-recursive-data-types\">Mutually recursive data types</h2>\n<p>Data types may be mutually-recursive when declared with <code>and</code>:</p>\n<pre><code class=\"language-ocaml\">type t = A | B of t' and t' = C | D of t\n</code></pre>\n<p>One common use for mutually-recursive data types is to <em>decorate</em> a tree, by\nadding information to each node using mutually-recursive types, one of which is\na tuple or record. For example:</p>\n<pre><code class=\"language-ocaml\">type t' = Int of int | Add of t * t\nand t = {annotation : string; data : t'}\n</code></pre>\n<p>Values of such mutually-recursive data type are manipulated by accompanying\nmutually-recursive functions:</p>\n<pre><code class=\"language-ocaml\"># let rec sum_t' = function\n  | Int i -&gt; i\n  | Add (i, i') -&gt; sum_t i + sum_t i'\n  and sum_t {annotation; data} =\n    if annotation &lt;&gt; &quot;&quot; then Printf.printf &quot;Touching %s\\n&quot; annotation;\n    sum_t' data\nval sum_t' : t' -&gt; int = &lt;fun&gt;\nval sum_t : t -&gt; int = &lt;fun&gt;\n</code></pre>\n<h2 id=\"a-note-on-tupled-constructors\">A note on tupled constructors</h2>\n<p>There is a difference between <code>RGB of float * float * float</code> and `RGB of (float</p>\n<ul>\n<li>float * float)`. The first is a constructor with three pieces of data\nassociated with it, the second is a constructor with one tuple associated with\nit. There are two ways this matters: the memory layout differs between the two\n(a tuple is an extra indirection), and the ability to create or match using a\ntuple:\n</li>\n</ul>\n<pre><code class=\"language-ocaml\"># type t = T of int * int\ntype t = T of int * int\n\n# type t2 = T2 of (int * int)\ntype t2 = T2 of (int * int)\n\n# let pair = (1, 2)\nval pair : int * int = (1, 2)\n\n# T2 pair\n- : t2 = T2 (1, 2)\n\n# T pair\nLine 1, characters 1-7:\nError: The constructor T expects 2 argument(s),\n       but is applied here to 1 argument(s)\n\n# match T2 (1, 2) with T2 x -&gt; fst x\n- : int = 1\n\n# match T (1, 2) with T x -&gt; fst x\nLine 1, characters 21-24:\nError: The constructor T expects 2 argument(s),\n       but is applied here to 1 argument(s)\n</code></pre>\n<p>Note, however, that OCaml allows us to use the always-matching <code>_</code> in either\nversion:</p>\n<pre><code class=\"language-ocaml\"># match T2 (1, 2) with T2 _ -&gt; 0\n- : int = 0\n\n# match T (1, 2) with T _ -&gt; 0\n- : int = 0\n</code></pre>\n<h2 id=\"types-and-modules\">Types and modules</h2>\n<p>Often, a module will provide a single type and operations on that type. For\nexample, a module for a file format like PNG might have the following <code>png.mli</code>\ninterface:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">type t\n\nval of_file : filename -&gt; t\n\nval to_file : t -&gt; filename -&gt; unit\n\nval flip_vertical : t -&gt; t\n\nval flip_horizontal : t -&gt; t\n\nval rotate : float -&gt; t -&gt; t\n</code></pre>\n<p>Traditionally, we name the type <code>t</code>. In the program using this library, it\nwould then be <code>Png.t</code> which is shorter, reads better than <code>Png.png</code>, and avoids\nconfusion if the library also defines other types.</p>\n","title":"Data Types and Matching","pageDescription":"Learn to build custom types and write function to process this data\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#built-in-compound-types\">Built-in compound types</a>\n</li>\n<li><a href=\"#a-simple-custom-type\">A simple custom type</a>\n</li>\n<li><a href=\"#constructors-with-data\">Constructors with data</a>\n</li>\n<li><a href=\"#example-trees\">Example: trees</a>\n</li>\n<li><a href=\"#example-mathematical-expressions\">Example: mathematical expressions</a>\n</li>\n<li><a href=\"#mutually-recursive-data-types\">Mutually recursive data types</a>\n</li>\n<li><a href=\"#a-note-on-tupled-constructors\">A note on tupled constructors</a>\n</li>\n<li><a href=\"#types-and-modules\">Types and modules</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"data-types-and-matching"}},"__N_SSG":true}