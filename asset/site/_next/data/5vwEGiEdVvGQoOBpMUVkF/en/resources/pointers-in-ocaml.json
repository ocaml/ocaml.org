{"pageProps":{"content":{"source":"<h2 id=\"status-of-pointers-in-ocaml\">Status of pointers in OCaml</h2>\n<p>Pointers exist in OCaml, and in fact they spread all over the place.\nThey are used either implicitly (in the most cases), or explicitly (in\nthe rare occasions where implicit pointers are not more handy). The vast\nmajority of pointers usages that are found in usual programming\nlanguages simply disappear in OCaml, or more exactly, those pointers are\ntotally automatically handled by the compiler. Thus, the OCaml programmer\ncan safely ignore the existence of pointers, focusing on the semantics of their\nprogram.</p>\n<p>For instance, lists or trees are defined without explicit pointers using\na concrete datatype definition. The underlying implementation uses\npointers, but this is hidden from the programmer since pointer\nhandling is done by the compiler.</p>\n<p>In the rare occasions where explicit pointers are needed (the most\ncommon case is when translating into OCaml an algorithm described in a\nclassic imperative language), OCaml provides references that are\nfull-fledged pointers, even first class citizen pointers (references can\nbe passed as argument, embedded into arbitrary data structures, and\nreturned as function results).</p>\n<h3 id=\"explicit-pointers-are-ocaml-values-of-type-ref\">Explicit pointers are OCaml values of type <code>ref</code></h3>\n<p>You can program directly with explicit references if you want to, but\nthis is normally a waste of time and effort.</p>\n<p>Let's examine the simple example of linked lists (integer lists to be\nsimple). This data type is defined in C (or in Pascal) using explicit\npointers, for instance:</p>\n<pre><code class=\"language-C\">/* Cells and lists type in C */\nstruct cell {\n  int hd;\n  struct cell *tl;\n};\n\ntypedef struct cell cell, *list;\n</code></pre>\n<pre><code class=\"language-Pascal\">{Cells and lists type in Pascal}\ntype\n list = ^cell;\n cell = record\n  hd: integer;\n  tl: cell;\n end;\n</code></pre>\n<p>We can translate this in OCaml, using a sum type definition, without\npointers:</p>\n<pre><code class=\"language-ocaml\"># type list = Nil | Cons of int * list\ntype list = Nil | Cons of int * list\n</code></pre>\n<p>Cell lists are thus represented as pairs, and the recursive structure of\nlists is evident, with the two alternatives, empty list (the\n<code>Nil</code>constructor) and non empty list (the <code>Cons</code> constructor).</p>\n<p>Automatic management of pointers and automatic memory allocation shine\nwhen allocating list values: one just writes <code>Cons (x, l)</code> to add <code>x</code> in\nfront of the list <code>l</code>. In C, you need to write this function, to\nallocate a new cell and then fill its fields. For instance:</p>\n<pre><code class=\"language-C\">/* The empty list */\n#define nil NULL\n\n/* The constructor of lists */\nlist cons (element x, list l)\n{\n  list result;\n  result = (list) malloc (sizeof (cell));\n  result -&gt; hd = x;\n  result -&gt; tl = l;\n  return (result);\n}\n</code></pre>\n<p>Similarly, in Pascal:</p>\n<pre><code class=\"language-Pascal\">{Creating a list cell}\nfunction cons (x: integer; l: list): list;\n  var p: list;\n  begin\n    new(p);\n    p^.hd := x;\n    p^.tl := l;\n    cons := p\n  end;\n</code></pre>\n<p>We thus see that fields of list cells in the C program have to be\nmutable, otherwise initialization is impossible. By contrast in OCaml,\nallocation and initialization are merged into a single basic operation:\nconstructor application. This way, immutable data structures are\ndefinable (those data types are often referred to as “pure” or\n“functional” data structures). If physical modifications are necessary\nfor other reasons than mere initialization, OCaml provides records with\nmutable fields. For instance, a list type defining lists whose elements\ncan be in place modified could be written:</p>\n<pre><code class=\"language-ocaml\"># type list = Nil | Cons of cell\n  and cell = { mutable hd : int; tl : list }\ntype list = Nil | Cons of cell\nand cell = { mutable hd : int; tl : list; }\n</code></pre>\n<p>If the structure of the list itself must also be modified (cells must be\nphysically removed from the list), the <code>tl</code> field would also be declared\nas mutable:</p>\n<pre><code class=\"language-ocaml\"># type list = Nil | Cons of cell\n  and cell = { mutable hd : int; mutable tl : list }\ntype list = Nil | Cons of cell\nand cell = { mutable hd : int; mutable tl : list; }\n</code></pre>\n<p>Physical assignments are still useless to allocate mutable data: you\nwrite <code>Cons {hd = 1; tl = l}</code> to add <code>1</code> to the list <code>l</code>. Physical\nassignments that remain in OCaml programs should be just those\nassignments that are mandatory to implement the algorithm at hand.</p>\n<p>Very often, pointers are used to implement physical modification of data\nstructures. In OCaml programs this means using vectors or mutable fields\nin records.</p>\n<p><strong>In conclusion:</strong> You can use explicit pointers in OCaml, exactly as in C, but\nthis is not natural, since you get back the usual drawbacks and difficulties of\nexplicit pointers manipulation of classical algorithmic languages. See a more\ncomplete example below.</p>\n<h2 id=\"defining-pointers-in-ocaml\">Defining pointers in OCaml</h2>\n<p>The general pointer type can be defined using the definition of a\npointer: a pointer is either null, or a pointer to an assignable memory\nlocation:</p>\n<pre><code class=\"language-ocaml\"># type 'a pointer = Null | Pointer of 'a ref\ntype 'a pointer = Null | Pointer of 'a ref\n</code></pre>\n<p>Explicit dereferencing (or reading the pointer's designated value) and\npointer assignment (or writing to the pointer's designated memory\nlocation) are easily defined. We define dereferencing as a prefix\noperator named <code>!^</code>, and assignment as the infix <code>^:=</code>.</p>\n<pre><code class=\"language-ocaml\"># let ( !^ ) = function\n    | Null -&gt; invalid_arg &quot;Attempt to dereference the null pointer&quot;\n    | Pointer r -&gt; !r\nval ( !^ ) : 'a pointer -&gt; 'a = &lt;fun&gt;\n\n# let ( ^:= ) p v =\n    match p with\n     | Null -&gt; invalid_arg &quot;Attempt to assign the null pointer&quot;\n     | Pointer r -&gt; r := v\nval ( ^:= ) : 'a pointer -&gt; 'a -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>Now we define the allocation of a new pointer initialized to point to a\ngiven value:</p>\n<pre><code class=\"language-ocaml\"># let new_pointer x = Pointer (ref x)\nval new_pointer : 'a -&gt; 'a pointer = &lt;fun&gt;\n</code></pre>\n<p>For instance, let's define and then assign a pointer to an integer:</p>\n<pre><code class=\"language-ocaml\"># let p = new_pointer 0\nval p : int pointer = Pointer {contents = 0}\n# p ^:= 1\n- : unit = ()\n# !^p\n- : int = 1\n</code></pre>\n<h2 id=\"integer-lists\">Integer Lists</h2>\n<p>Now we can define lists using explicit pointers as in usual imperative\nlanguages:</p>\n<pre><code class=\"language-ocaml\"># type ilist = cell pointer\n  and cell = { mutable hd : int; mutable tl : ilist }\ntype ilist = cell pointer\nand cell = { mutable hd : int; mutable tl : ilist; }\n</code></pre>\n<p>We then define allocation of a new cell, the list constructor and its\nassociated destructors.</p>\n<pre><code class=\"language-ocaml\"># let new_cell () = {hd = 0; tl = Null}\nval new_cell : unit -&gt; cell = &lt;fun&gt;\n# let cons x l =\n    let c = new_cell () in\n    c.hd &lt;- x;\n    c.tl &lt;- l;\n    (new_pointer c : ilist)\nval cons : int -&gt; ilist -&gt; ilist = &lt;fun&gt;\n# let hd (l : ilist) = !^l.hd\nval hd : ilist -&gt; int = &lt;fun&gt;\n# let tl (l : ilist) = !^l.tl\nval tl : ilist -&gt; ilist = &lt;fun&gt;\n</code></pre>\n<p>We can now write all kind of classical algorithms, based on pointers\nmanipulation, with their associated loops, their unwanted sharing\nproblems and their null pointer errors. For instance, list\nconcatenation, as often described in literature, physically modifies\nits first list argument, hooking the second list to the end of the\nfirst:</p>\n<pre><code class=\"language-ocaml\"># let append (l1 : ilist) (l2 : ilist) =\n  let temp = ref l1 in\n  while tl !temp &lt;&gt; Null do\n    temp := tl !temp\n  done;\n  !^ !temp.tl &lt;- l2\nval append : ilist -&gt; ilist -&gt; unit = &lt;fun&gt;\n\n# let l1 = cons 1 (cons 2 Null)\nval l1 : ilist =\n  Pointer\n   {contents = {hd = 1; tl = Pointer {contents = {hd = 2; tl = Null}}}}\n\n# let l2 = cons 3 Null\nval l2 : ilist = Pointer {contents = {hd = 3; tl = Null}}\n\n# append l1 l2\n- : unit = ()\n</code></pre>\n<p>The lists <code>l1</code> and <code>l2</code> are effectively catenated:</p>\n<pre><code class=\"language-ocaml\"># l1\n- : ilist =\nPointer\n {contents =\n   {hd = 1;\n    tl =\n     Pointer\n      {contents = {hd = 2; tl = Pointer {contents = {hd = 3; tl = Null}}}}}}\n</code></pre>\n<p>Just a nasty side effect of physical list concatenation: <code>l1</code> now\ncontains the concatenation of the two lists <code>l1</code> and <code>l2</code>, thus the list\n<code>l1</code> no longer exists: in some sense <code>append</code> <em>consumes</em> its first\nargument. In other words, the value of a list data now depends on its\nhistory, that is on the sequence of function calls that use the value.\nThis strange behaviour leads to a lot of difficulties when explicitly\nmanipulating pointers. Try for instance, the seemingly harmless:</p>\n<pre><code class=\"language-ocaml\"># append l1 l1\n- : unit = ()\n</code></pre>\n<p>Then evaluate <code>l1</code>:</p>\n<pre><code class=\"language-ocaml\"># l1\n- : ilist =\nPointer\n {contents =\n   {hd = 1;\n    tl =\n     Pointer\n      {contents = {hd = 2; tl = Pointer {contents = {hd = 3; tl = &lt;cycle&gt;}}}}}}\n</code></pre>\n<h2 id=\"polymorphic-lists\">Polymorphic lists</h2>\n<p>We can define polymorphic lists using pointers; here is a simple implementation\nof those polymorphic mutable lists:</p>\n<pre><code class=\"language-ocaml\"># type 'a lists = 'a cell pointer\n  and 'a cell = { mutable hd : 'a pointer; mutable tl : 'a lists }\ntype 'a lists = 'a cell pointer\nand 'a cell = { mutable hd : 'a pointer; mutable tl : 'a lists; }\n# let new_cell () = {hd = Null; tl = Null}\nval new_cell : unit -&gt; 'a cell = &lt;fun&gt;\n# let cons x l =\n    let c = new_cell () in\n    c.hd &lt;- new_pointer x;\n    c.tl &lt;- l;\n    (new_pointer c : 'a lists)\nval cons : 'a -&gt; 'a lists -&gt; 'a lists = &lt;fun&gt;\n# let hd (l : 'a lists) = !^l.hd\nval hd : 'a lists -&gt; 'a pointer = &lt;fun&gt;\n# let tl (l : 'a lists) = !^l.tl\nval tl : 'a lists -&gt; 'a lists = &lt;fun&gt;\n# let append (l1 : 'a lists) (l2 : 'a lists) =\n  let temp = ref l1 in\n  while tl !temp &lt;&gt; Null do\n    temp := tl !temp\n  done;\n  !^ !temp.tl &lt;- l2\nval append : 'a lists -&gt; 'a lists -&gt; unit = &lt;fun&gt;\n</code></pre>\n","title":"Pointers in OCaml","pageDescription":"Use OCaml's explicit pointers with references\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#status-of-pointers-in-ocaml\">Status of pointers in OCaml</a>\n</li>\n<li><a href=\"#defining-pointers-in-ocaml\">Defining pointers in OCaml</a>\n</li>\n<li><a href=\"#integer-lists\">Integer Lists</a>\n</li>\n<li><a href=\"#polymorphic-lists\">Polymorphic lists</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"pointers-in-ocaml"}},"__N_SSG":true}