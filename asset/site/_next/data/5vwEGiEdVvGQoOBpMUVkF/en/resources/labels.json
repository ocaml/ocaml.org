{"pageProps":{"content":{"source":"<h2 id=\"labelled-and-optional-arguments-to-functions\">Labelled and optional arguments to functions</h2>\n<p>Python has a nice syntax for writing arguments to functions. Here's\nan example (from the Python tutorial, since I'm not a Python\nprogrammer):</p>\n<pre><code class=\"language-python\">def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):\n  # function definition omitted\n</code></pre>\n<p>Here are the ways we can call this Python function:</p>\n<pre><code class=\"language-python\">ask_ok ('Do you really want to quit?')\nask_ok ('Overwrite the file?', 2)\nask_ok (prompt='Are you sure?')\nask_ok (complaint='Please answer yes or no!', prompt='Are you sure?')\n</code></pre>\n<p>Notice that in Python we are allowed to name arguments when we call\nthem, or use the usual function call syntax, and we can have optional\narguments with default values.</p>\n<p>OCaml also has a way to label arguments and have optional arguments with\ndefault values.</p>\n<p>The basic syntax is:</p>\n<pre><code class=\"language-ocaml\"># let rec range ~first:a ~last:b =\n  if a &gt; b then []\n  else a :: range ~first:(a + 1) ~last:b\nval range : first:int -&gt; last:int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>(Notice that both <code>to</code> and <code>end</code> are reserved words in OCaml, so they\ncannot be used as labels. So you cannot have <code>~from/~to</code> or\n<code>~start/~end</code>.)</p>\n<p>The type of our previous <code>range</code> function was:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">range : int -&gt; int -&gt; int list\n</code></pre>\n<p>And the type of our new <code>range</code> function with labelled arguments is:</p>\n<pre><code class=\"language-ocaml\"># range\n- : first:int -&gt; last:int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Confusingly, the <code>~</code> (tilde) is <em>not</em> shown in the type definition, but\nyou need to use it everywhere else.</p>\n<p>With labelled arguments, it doesn't matter which order you give the\narguments anymore:</p>\n<pre><code class=\"language-ocaml\"># range ~first:1 ~last:10\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range ~last:10 ~first:1\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n</code></pre>\n<p>There is also a shorthand way to name the arguments, so that the label\nis the same as the variable in the function definition:</p>\n<pre><code class=\"language-ocaml\"># let may ~f x =\n  match x with\n  | None -&gt; ()\n  | Some x -&gt; ignore (f x)\nval may : f:('a -&gt; 'b) -&gt; 'a option -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>It's worth spending some time working out exactly what this function\ndoes, and also working out by hand its type signature. There's a lot\ngoing on. First of all, the parameter <code>~f</code> is just shorthand for <code>~f:f</code>\n(ie. the label is <code>~f</code> and the variable used in the function is <code>f</code>).\nSecondly notice that the function takes two parameters. The second\nparameter (<code>x</code>) is unlabelled - it is permitted for a function to take a\nmixture of labelled and unlabelled arguments if you want.</p>\n<p>What is the type of the labelled <code>f</code> parameter? Obviously it's a\nfunction of some sort.</p>\n<p>What is the type of the unlabelled <code>x</code> parameter? The <code>match</code> clause\ngives us a clue. It's an <code>'a option</code>.</p>\n<p>This tells us that <code>f</code> takes an <code>'a</code> parameter, and the return value of\n<code>f</code> is ignored, so it could be anything. The type of <code>f</code> is therefore\n<code>'a -&gt; 'b</code>.</p>\n<p>The <code>may</code> function as a whole returns <code>unit</code>. Notice in each case of the\n<code>match</code> the result is <code>()</code>.</p>\n<p>Thus the type of the <code>may</code> function is (and you can verify this in the\nOCaml interactive toplevel if you want):</p>\n<pre><code class=\"language-ocaml\"># may\n- : f:('a -&gt; 'b) -&gt; 'a option -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>What does this function do? Running the function in the OCaml toplevel\ngives us some clues:</p>\n<pre><code class=\"language-ocaml\"># may ~f:print_endline None\n- : unit = ()\n# may ~f:print_endline (Some &quot;hello&quot;)\nhello\n- : unit = ()\n</code></pre>\n<p>If the unlabelled argument is a “null pointer” then <code>may</code> does nothing.\nOtherwise <code>may</code> calls the <code>f</code> function on the argument. Why is this\nuseful? We're just about to find out ...</p>\n<h3 id=\"optional-arguments\">Optional arguments</h3>\n<p>Optional arguments are like labelled arguments, but we use <code>?</code> instead\nof <code>~</code> in front of them. Here is an example:</p>\n<pre><code class=\"language-ocaml\"># let rec range ?(step=1) a b =\n  if a &gt; b then []\n  else a :: range ~step (a + step) b\nval range : ?step:int -&gt; int -&gt; int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Note the somewhat confusing syntax, switching between <code>?</code> and <code>~</code>. We'll\ntalk about that in the next section. Here is how you call this function:</p>\n<pre><code class=\"language-ocaml\"># range 1 10\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range 1 10 ~step:2\n- : int list = [1; 3; 5; 7; 9]\n</code></pre>\n<p>In this case, <code>?(step=1)</code> fairly obviously means that <code>~step</code> is an\noptional argument which defaults to 1. We can also omit the default\nvalue and just have an optional argument. This example is modified from\nlablgtk:</p>\n<pre><code class=\"language-ocaml\"># type window =\n  {mutable title: string;\n   mutable width: int;\n   mutable height: int}\ntype window = {\n  mutable title : string;\n  mutable width : int;\n  mutable height : int;\n}\n# let create_window () =\n  {title = &quot;none&quot;; width = 640; height = 480;}\nval create_window : unit -&gt; window = &lt;fun&gt;\n# let set_title window title =\n  window.title &lt;- title\nval set_title : window -&gt; string -&gt; unit = &lt;fun&gt;\n# let set_width window width =\n  window.width &lt;- width\nval set_width : window -&gt; int -&gt; unit = &lt;fun&gt;\n# let set_height window height =\n  window.height &lt;- height\nval set_height : window -&gt; int -&gt; unit = &lt;fun&gt;\n# let open_window ?title ?width ?height () =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nval open_window :\n  ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; unit -&gt; window = &lt;fun&gt;\n</code></pre>\n<p>This example is significantly complex and quite subtle, but the pattern\nused is very common in the lablgtk source code. Let's concentrate on the\nsimple <code>create_window</code> function first. This function takes a <code>unit</code> and\nreturns a <code>window</code>, initialized with default settings for title, width\nand height:</p>\n<pre><code class=\"language-ocaml\"># create_window ()\n- : window = {title = &quot;none&quot;; width = 640; height = 480}\n</code></pre>\n<p>The <code>set_title</code>, <code>set_width</code> and <code>set_height</code> functions are impure\nfunctions which modify the <code>window</code> structure, in the obvious way. For\nexample:</p>\n<pre><code class=\"language-ocaml\"># let w = create_window () in\n  set_title w &quot;My Application&quot;;\n  w\n- : window = {title = &quot;My Application&quot;; width = 640; height = 480}\n</code></pre>\n<p>So far this is just the imperative &quot;mutable records&quot; which we talked\nabout in the previous chapter. Now the complex part is the <code>open_window</code>\nfunction. This function takes <em>4</em> arguments, three of them optional,\nfollowed by a required, unlabelled <code>unit</code>. Let's first see this function\nin action:</p>\n<pre><code class=\"language-ocaml\"># open_window ~title:&quot;My Application&quot; ()\n- : window = {title = &quot;My Application&quot;; width = 640; height = 480}\n# open_window ~title:&quot;Clock&quot; ~width:128 ~height:128 ()\n- : window = {title = &quot;Clock&quot;; width = 128; height = 128}\n</code></pre>\n<p>It does what you expect, but how?! The secret is in the <code>may</code> function\n(see above) and the fact that the optional parameters <em>don't</em> have\ndefaults.</p>\n<p>When an optional parameter doesn't have a default, then it has type\n<code>'a option</code>. The <code>'a</code> would normally be inferred by type inference, so\nin the case of <code>?title</code> above, this has type <code>string option</code>.</p>\n<p>Remember the <code>may</code> function? It takes a function and an argument, and\ncalls the function on the argument provided the argument isn't <code>None</code>.\nSo:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\"># may ~f:(set_title window) title\n</code></pre>\n<p>If the optional title argument is not specified by the caller, then\n<code>title</code> = <code>None</code>, so <code>may</code> does nothing. But if we call the function\nwith, for example,</p>\n<pre><code class=\"language-ocaml\"># open_window ~title:&quot;My Application&quot; ()\n- : window = {title = &quot;My Application&quot;; width = 640; height = 480}\n</code></pre>\n<p>then <code>title</code> = <code>Some &quot;My Application&quot;</code>, and <code>may</code> therefore calls\n<code>set_title window &quot;My Application&quot;</code>.</p>\n<p>You should make sure you fully understand this example before proceeding\nto the next section.</p>\n<h3 id=\"warning-this-optional-argument-cannot-be-erased\">&quot;Warning: This optional argument cannot be erased&quot;</h3>\n<p>We've just touched upon labels and optional arguments, but even this\nbrief explanation should have raised several questions. The first may be\nwhy the extra <code>unit</code> argument to <code>open_window</code>? Let's try defining this\nfunction without the extra <code>unit</code>:</p>\n<pre><code class=\"language-ocaml\"># let open_window ?title ?width ?height =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nLine 1, characters 32-38:\nWarning 16: this optional argument cannot be erased.\nval open_window : ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; window =\n  &lt;fun&gt;\n</code></pre>\n<p>Although OCaml has compiled the function, it has generated a somewhat\ninfamous warning: &quot;This optional argument cannot be erased&quot;, referring\nto the final <code>?height</code> argument. To try to show what's going on here,\nlet's call our modified <code>open_window</code> function:</p>\n<pre><code class=\"language-ocaml\"># open_window\n- : ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; window = &lt;fun&gt;\n# open_window ~title:&quot;My Application&quot;\n- : ?width:int -&gt; ?height:int -&gt; window = &lt;fun&gt;\n</code></pre>\n<p>Did that work or not? No it didn't. In fact it didn't even run the\n<code>open_window</code> function at all. Instead it printed some strange type\ninformation. What's going on?</p>\n<p>Recall currying and uncurrying, and partial application of functions. If\nwe have a function <code>plus</code> defined as:</p>\n<pre><code class=\"language-ocaml\"># let plus x y =\n  x + y\nval plus : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>We can partially apply this, for example as <code>plus 2</code> which is &quot;the\nfunction that adds 2 to things&quot;:</p>\n<pre><code class=\"language-ocaml\"># let f = plus 2\nval f : int -&gt; int = &lt;fun&gt;\n# f 5\n- : int = 7\n# f 100\n- : int = 102\n</code></pre>\n<p>In the <code>plus</code> example, the OCaml compiler can easily work out that\n<code>plus 2</code> doesn't have enough arguments supplied yet. It needs another\nargument before the <code>plus</code> function itself can be executed. Therefore\n<code>plus 2</code> is a function which is waiting for its extra argument to come\nalong.</p>\n<p>Things are not so clear when we add optional arguments into the mix. The\ncall to <code>open_window;;</code> above is a case in point. Does the user mean\n&quot;execute <code>open_window</code> now&quot;? Or does the user mean to supply some or all\nof the optional arguments later? Is <code>open_window;;</code> waiting for extra\narguments to come along like <code>plus 2</code>?</p>\n<p>OCaml plays it safe and doesn't execute <code>open_window</code>. Instead it treats\nit as a partial function application. The expression <code>open_window</code>\nliterally evaluates to a function value.</p>\n<p>Let's go back to the original and working definition of <code>open_window</code>\nwhere we had the extra unlabelled <code>unit</code> argument at the end:</p>\n<pre><code class=\"language-ocaml\"># let open_window ?title ?width ?height () =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nval open_window :\n  ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; unit -&gt; window = &lt;fun&gt;\n</code></pre>\n<p>If you want to pass optional arguments to <code>open_window</code> you must do so\nbefore the final <code>unit</code>, so if you type:</p>\n<pre><code class=\"language-ocaml\"># open_window ()\n- : window = {title = &quot;none&quot;; width = 640; height = 480}\n</code></pre>\n<p>you must mean &quot;execute <code>open_window</code> now with all optional arguments\nunspecified&quot;. Whereas if you type:</p>\n<pre><code class=\"language-ocaml\"># open_window\n- : ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; unit -&gt; window = &lt;fun&gt;\n</code></pre>\n<p>you mean &quot;give me the functional value&quot; or (more usually in the\ntoplevel) &quot;print out the type of <code>open_window</code>&quot;.</p>\n<h3 id=\"more-shorthand\">More <code>~</code>shorthand</h3>\n<p>Let's rewrite the <code>range</code> function yet again, this time using as much\nshorthand as possible for the labels:</p>\n<pre><code class=\"language-ocaml\"># let rec range ~first ~last =\n  if first &gt; last then []\n  else first :: range ~first:(first + 1) ~last\nval range : first:int -&gt; last:int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Recall that <code>~foo</code> on its own is short for <code>~foo:foo</code>. This applies also\nwhen calling functions as well as declaring the arguments to functions,\nhence in the above the highlighted red <code>~last</code> is short for\n<code>~last:last</code>.</p>\n<h3 id=\"using-foo-in-a-function-call\">Using <code>?foo</code> in a function call</h3>\n<p>There's another little wrinkle concerning optional arguments. Suppose we\nwrite a function around <code>open_window</code> to open up an application:</p>\n<pre><code class=\"language-ocaml\"># let open_application ?width ?height () =\n  open_window ~title:&quot;My Application&quot; ~width ~height\nLine 2, characters 40-45:\nError: This expression has type 'a option\n       but an expression was expected of type int\n</code></pre>\n<p>Recall that <code>~width</code> is shorthand for <code>~width:width</code>. The type of\n<code>width</code> is <code>'a option</code>, but <code>open_window ~width:</code> expects an <code>int</code>.</p>\n<p>OCaml provides more syntactic sugar. Writing <code>?width</code> in the function\ncall is shorthand for writing <code>~width:(unwrap width)</code> where <code>unwrap</code>\nwould be a function which would remove the &quot;<code>option</code> wrapper&quot; around\n<code>width</code> (it's not actually possible to write an <code>unwrap</code> function like\nthis, but conceptually that's the idea). So the correct way to write\nthis function is:</p>\n<pre><code class=\"language-ocaml\"># let open_application ?width ?height () =\n  open_window ~title:&quot;My Application&quot; ?width ?height\nval open_application : ?width:int -&gt; ?height:int -&gt; unit -&gt; unit -&gt; window =\n  &lt;fun&gt;\n</code></pre>\n<h3 id=\"when-and-when-not-to-use--and-\">When and when not to use <code>~</code> and <code>?</code></h3>\n<p>The syntax for labels and optional arguments is confusing, and you may\noften wonder when to use <code>~foo</code>, when to use <code>?foo</code> and when to use\nplain <code>foo</code>. It's something of a black art which takes practice to get\nright.</p>\n<p><code>?foo</code> is only used when declaring the arguments of a function, ie:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f ?arg1 ... =\n</code></pre>\n<p>or when using the specialised &quot;unwrap <code>option</code> wrapper&quot; form for\nfunction calls:</p>\n<pre><code class=\"language-ocaml\"># let open_application ?width ?height () =\n  open_window ~title:&quot;My Application&quot; ?width ?height\nval open_application : ?width:int -&gt; ?height:int -&gt; unit -&gt; unit -&gt; window =\n  &lt;fun&gt;\n</code></pre>\n<p>The declaration <code>?foo</code> creates a variable called <code>foo</code>, so if you need\nthe value of <code>?foo</code>, use just <code>foo</code>.</p>\n<p>The same applies to labels. Only use the <code>~foo</code> form when declaring\narguments of a function, ie:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let f ~foo:foo ... =\n</code></pre>\n<p>The declaration <code>~foo:foo</code> creates a variable called simply <code>foo</code>, so if\nyou need the value just use plain <code>foo</code>.</p>\n<p>Things, however, get complicated for two reasons: first, the shorthand\nform <code>~foo</code> (equivalent to <code>~foo:foo</code>), and second, when you call a\nfunction which takes a labelled or optional argument and you use the\nshorthand form.</p>\n<p>Here is some apparently obscure code from lablgtk to demonstrate all of\nthis:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\"># let html ?border_width ?width ?height ?packing ?show () =  (* line 1 *)\n  let w = create () in\n  load_empty w;\n  Container.set w ?border_width ?width ?height;            (* line 4 *)\n  pack_return (new html w) ~packing ~show                  (* line 5 *)\n</code></pre>\n<p>On line 1 we have the function definition. Notice there are 5 optional\narguments, and the mandatory <code>unit</code> 6<sup>th</sup> argument. Each of the\noptional arguments is going to define a variable, eg. <code>border_width</code>, of\ntype <code>'a option</code>.</p>\n<p>On line 4 we use the special <code>?foo</code> form for passing optional arguments\nto functions which take optional arguments. <code>Container.set</code> has the\nfollowing type:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">module Container = struct\n  let set ?border_width ?(width = -2) ?(height = -2) w =\n    (* ... *)\n</code></pre>\n<p>Line 5 uses the <code>~</code>shorthand. Writing this in long form:</p>\n<pre><code class=\"language-ocaml\"># pack_return (new html w) ~packing:packing ~show:show\nLine 1, characters 1-12:\nError: Unbound value pack_return\n</code></pre>\n<p>The <code>pack_return</code> function actually takes mandatory labelled arguments\ncalled <code>~packing</code> and <code>~show</code>, each of type <code>'a option</code>. In other words,\n<code>pack_return</code> explicitly unwraps the <code>option</code> wrapper.</p>\n<h2 id=\"more-variants-polymorphic-variants\">More variants (“polymorphic variants”)</h2>\n<p>Try compiling the following C code:</p>\n<pre><code class=\"language-C\">#include &lt;stdio.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\nenum lock { open, close };\n\nmain ()\n{\n  int fd, n;\n  char buffer[256];\n\n  fd = open (&quot;/etc/motd&quot;, O_RDONLY);                     // line 12\n  while ((n = read (fd, buffer, sizeof buffer)) &gt; 0)\n    write (1, buffer, n);\n  close (fd);                                            // line 15\n}\n</code></pre>\n<p>When I compile the code I get a whole bunch of errors including:</p>\n<pre><code class=\"language-text\">test.c: In function `main':\ntest.c:12: error: called object is not a function\ntest.c:15: error: called object is not a function\n</code></pre>\n<p>This illustrates one problem with enumerated types (enums) in C. In the\nexample above, one enum statement reserves <em>three</em> symbols, namely\n<code>lock</code>, <code>open</code> and <code>close</code>. Here's another example:</p>\n<pre><code class=\"language-C\">enum lock { open, close };\nenum door { open, close };\n</code></pre>\n<p>Compiling gives:</p>\n<pre><code class=\"language-text\">test.c:2: error: conflicting types for `open'\ntest.c:1: error: previous declaration of `open'\ntest.c:2: error: conflicting types for `close'\ntest.c:1: error: previous declaration of `close'\n</code></pre>\n<p>The first enum defines the symbol <code>open</code> as something of type\n<code>enum lock</code>. You cannot reuse that symbol in another enum.</p>\n<p>This will be familiar to most C/C++ programmers, and they won't write\nnaive code like that above. However the same issue happens with OCaml\nvariants, but OCaml provides a way to work around it.</p>\n<p>Here is some OCaml code, which actually <em>does</em> compile:</p>\n<pre><code class=\"language-ocaml\"># type lock = Open | Close\ntype lock = Open | Close\n# type door = Open | Close\ntype door = Open | Close\n</code></pre>\n<p>After running those two statements, what is the type of <code>Open</code>? We can\nfind out easily enough in the toplevel:</p>\n<pre><code class=\"language-ocaml\"># type lock = Open | Close\ntype lock = Open | Close\n# type door = Open | Close\ntype door = Open | Close\n# Open\n- : door = Open\n</code></pre>\n<p>OCaml uses the most recent definition for <code>Open</code>, giving it the type\n<code>door</code>. This is actually not such a serious problem because if you\naccidentally tried to use <code>Open</code> in the type context of a <code>lock</code>, then\nOCaml's wonderful type inference would immediately spot the error and\nyou wouldn't be able to compile the code.</p>\n<p>So far, so much like C. Now I said that OCaml provides a way to work\naround the constraint that <code>Open</code> can only have one type. In other\nwords, suppose I want to use <code>Open</code> to mean either &quot;the <code>Open</code> of type\n<code>lock</code>&quot; or &quot;the <code>Open</code> of type <code>door</code>&quot; and I want OCaml to work out\nwhich one I mean.</p>\n<p>The syntax is slightly different, but here is how we do it:</p>\n<pre><code class=\"language-ocaml\"># type lock = [ `Open | `Close ]\ntype lock = [ `Close | `Open ]\n# type door = [ `Open | `Close ]\ntype door = [ `Close | `Open ]\n</code></pre>\n<p>Notice the syntactic differences:</p>\n<ol>\n<li>Each variant name is prefixed with <code>`</code> (a back tick).\n</li>\n<li>You have to put square brackets (<code>[]</code>) around the alternatives.\n</li>\n</ol>\n<p>The question naturally arises: What is the type of <code> `Open</code>?</p>\n<pre><code class=\"language-ocaml\"># `Open\n- : [&gt; `Open ] = `Open\n</code></pre>\n<p><code>[&gt; `Open]</code> can be read as\n<code>[ `Open | and some other possibilities which we don't know about ]</code>.</p>\n<p>The “&gt;” (greater than) sign indicates that the set of possibilities is\nbigger than those listed (open-ended).</p>\n<p>There's nothing special about <code>`Open</code>. <em>Any</em> back-ticked word can be\nused as a type, even one which we haven't mentioned before:</p>\n<pre><code class=\"language-ocaml\"># `Foo\n- : [&gt; `Foo ] = `Foo\n# `Foo 42\n- : [&gt; `Foo of int ] = `Foo 42\n</code></pre>\n<p>Let's write a function to print the state of a <code>lock</code>:</p>\n<pre><code class=\"language-ocaml\"># let print_lock st =\n  match st with\n  | `Open -&gt; print_endline &quot;The lock is open&quot;\n  | `Close -&gt; print_endline &quot;The lock is closed&quot;\nval print_lock : [&lt; `Close | `Open ] -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>Take a careful look at the type of that function. Type inference has\nworked out that the <code>st</code> argument has type <code>[&lt; `Close | `Open]</code>. The\n<code>&lt;</code> (less than) sign means that this is a <strong>closed class</strong>. In\nother words, this function will only work on <code> `Close</code> or <code> `Open</code>\nand not on anything else.</p>\n<pre><code class=\"language-ocaml\"># print_lock `Open\nThe lock is open\n- : unit = ()\n</code></pre>\n<p>Notice that <code>print_lock</code> works just as well with a <code>door</code> as with a\n<code>lock</code>! We've deliberately given up some type safety, and type inference\nis now being used to help guess what we mean, rather than enforce\ncorrect coding.</p>\n<p>This is only an introduction to polymorphic variants. Because of the\nreduction in type safety, it is recommended that you don't use these in\nyour code. You will, however, see them in advanced OCaml code quite a\nlot precisely because advanced programmers will sometimes want to weaken\nthe type system to write advanced idioms.</p>\n","title":"Labels","pageDescription":"Provide labels to your functions arguments\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#labelled-and-optional-arguments-to-functions\">Labelled and optional arguments to functions</a>\n</li>\n<li><a href=\"#more-variants-polymorphic-variants\">More variants (“polymorphic variants”)</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"labels"}},"__N_SSG":true}