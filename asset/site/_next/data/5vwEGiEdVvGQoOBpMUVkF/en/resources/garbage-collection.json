{"pageProps":{"content":{"source":"<h2 id=\"garbage-collection-reference-counting-explicit-allocation\">Garbage collection, reference counting, explicit allocation</h2>\n<p>As with all modern languages, OCaml provides a garbage collector so that\nyou don't need to explicitly allocate and free memory as in C/C++.</p>\n<p>The OCaml garbage collector is a modern hybrid generational/incremental\ncollector which outperforms hand-allocation in most cases.</p>\n<p>Why would garbage collection be faster than explicit memory allocation\nas in C? It's often assumed that calling <code>free</code> costs nothing. In fact\n<code>free</code> is an expensive operation which involves navigating over the\ncomplex data structures used by the memory allocator. If your program\ncalls <code>free</code> intermittently, then all of that code and data needs to be\nloaded into the cache, displacing your program code and data, each time\nyou <code>free</code> a single memory allocation. A collection strategy which frees\nmultiple memory areas in one go (such as either a pool allocator or a\nGC) pays this penalty only once for multiple allocations (thus the cost\nper allocation is much reduced).</p>\n<p>GCs also move memory areas around and compact the heap. This makes\nallocation easier, hence faster, and a smart GC can be written to\ninteract well with the L1 and L2 caches.</p>\n<p>Of course none of this precludes writing a very fast hand-allocator, but\nit's considerably harder work than most programmers realise.</p>\n<p>OCaml's garbage collector has two heaps, the <strong>minor heap</strong> and the\n<strong>major heap</strong>. This recognises a general principle: Most objects are\nsmall and allocated frequently and then immediately freed. These objects\ngo into the minor heap first, which is GCed frequently. Only some\nobjects are long lasting. These objects get promoted from the minor heap\nto the major heap after some time, and the major heap is only collected\ninfrequently.</p>\n<p>The OCaml GC is synchronous. It doesn't run in a separate thread, and it\ncan only get called during an allocation request.</p>\n<h3 id=\"gc-vs-reference-counting\">GC vs. reference counting</h3>\n<p>Python has a form of garbage collection, but it uses a simple scheme\ncalled <strong>reference counting</strong>. Simply put, each Python object keeps a\ncount of the number of other objects pointing (referencing) itself. When\nthe count falls to zero, nothing is pointing at this object, and so the\nobject can be freed.</p>\n<p>Reference counting is not considered as serious garbage collection by\ncomputer scientists, yet it has one big practical advantage over full\ngarbage collectors. With reference counting, you can avoid many explicit\ncalls to <code>close</code>/<code>closedir</code> in code. Whereas in OCaml</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let read_file filename =\n  let chan = open_in filename in\n  (* read from chan *) in\nList.iter read_file files\n</code></pre>\n<p>Calls to <code>read_file</code> open the file but don't close it. Because OCaml\nuses a full garbage collector <code>chan</code> isn't collected until some time\nlater when the minor heap becomes full. In addition, <strong>OCaml will not\nclose the channel when it collects the handle's memory</strong>. So this\nprogram would eventually run out of file descriptors.</p>\n<p>You need to be aware of this when writing OCaml code which uses files or\ndirectories or any other heavyweight object with complex finalisation.</p>\n<p>To be fair to full garbage collection, I should mention the\ndisadvantages of reference counting schemes:</p>\n<ul>\n<li>Each object needs to store a reference count. In other words there's\na word overhead for every object. Programs use more memory, and are\nconsequently slower because they are more likely to fill up the\ncache or spill into swap.\n</li>\n<li>Reference counting is expensive - every time you manipulate pointers\nto an object you need to update and check the reference count.\nPointer manipulation is frequent, so this slows your program and\nbloats the code size of compiled code.\n</li>\n<li>They cannot collect so-called circular, or self-referential\nstructures. I've programmed in many languages in many years and\ncan't recall ever having created one of these.\n</li>\n<li>Graph algorithms, of course, violate the previous assumption.\n</li>\n</ul>\n<h2 id=\"the-gc-module\">The Gc module</h2>\n<p>The <code>Gc</code> module contains some useful functions for querying and calling\nthe garbage collector from OCaml programs.</p>\n<p>Here is a program which runs and then prints out GC statistics just\nbefore quitting:</p>\n<!-- TODO: Probably write a GC example without dependencies -->\n<!-- $MDX file=examples/gc.ml -->\n<pre><code class=\"language-ocaml\">let rec iterate r x_init i =\n  if i = 1 then x_init\n  else\n    let x = iterate r x_init (i - 1) in\n    r *. x *. (1.0 -. x)\n\nlet () =\n  Random.self_init ();\n  Graphics.open_graph &quot; 640x480&quot;;\n  for x = 0 to 640 do\n    let r = 4.0 *. float_of_int x /. 640.0 in\n    for i = 0 to 39 do\n      let x_init = Random.float 1.0 in\n      let x_final = iterate r x_init 500 in\n      let y = int_of_float (x_final *. 480.) in\n      Graphics.plot x y\n    done\n  done;\n  Gc.print_stat stdout\n</code></pre>\n<p>Here is what it printed out for me:</p>\n<pre><code>minor_words: 115926165     # Total number of words allocated\npromoted_words: 31217      # Promoted from minor -&gt; major\nmajor_words: 31902         # Large objects allocated in major directly\nminor_collections: 3538    # Number of minor heap collections\nmajor_collections: 39      # Number of major heap collections\nheap_words: 63488          # Size of the heap, in words = approx. 256K\nheap_chunks: 1\ntop_heap_words: 63488\nlive_words: 2694\nlive_blocks: 733\nfree_words: 60794\nfree_blocks: 4\nlargest_free: 31586\nfragments: 0\ncompactions: 0\n</code></pre>\n<p>We can see that minor heap collections are approximately 100 times more\nfrequent than major heap collections (in this example, not necessarily\nin general). Over the lifetime of the program, an astonishing 440 MB of\nmemory was allocated, although of course most of that would have been\nimmediately freed in a minor collection. Only about 128K was promoted to\nlong-term storage on the major heap, and about another 128K consisted of\nlarge objects which would have been allocated directly onto the major\nheap.</p>\n<p>We can instruct the GC to print out debugging messages when one of\nseveral events happen (eg. on every major collection). Try adding the\nfollowing code to the example above near the beginning:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\"># Gc.set {(Gc.get ()) with Gc.verbose = 0x01}\n</code></pre>\n<p>(We haven't seen the <code>{ expression with field = value }</code> form before,\nbut it should be mostly obvious what it does). The above code anyway\ncauses the GC to print a message at the start of every major collection.</p>\n<h2 id=\"finalisation-and-the-weak-module\">Finalisation and the Weak module</h2>\n<p>We can write a function called a <strong>finaliser</strong> which is called when an\nobject is about to be freed by the GC.</p>\n<p>The <code>Weak</code> module lets us create so-called weak pointers. A <strong>weak\npointer</strong> is best defined by comparing it to a &quot;normal pointer&quot;. When we\nhave an ordinary OCaml object, we reference that object through a name\n(eg. <code>let name = ... in</code>) or through another object. The garbage\ncollector sees that we have a reference to that object and won't collect\nit. That's what you might call a &quot;normal pointer&quot;. If, however, you hold\na weak pointer or weak reference to an object, then you hint to the\ngarbage collector that it may collect the object at any time. (Not\nnecessarily that it <em>will</em> collect the object). Some time later, when\nyou come to examine the object, you can either turn your weak pointer\ninto a normal pointer, or else you can be informed that the GC did\nactually collect the object.</p>\n<p>Finalisation and weak pointers can be used together to implement an\nin-memory object database cache. Let's imagine that we have a very large\nnumber of large user records in a file on disk. This is far too much\ndata to be loaded into memory all at once, and anyway other programs\nmight access the data on the disk, so we need to lock individual records\nwhen we hold copies of them in memory.</p>\n<p>The <em>public</em> interface to our &quot;in-memory object database cache&quot; is going\nto be just two functions:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">type record = {mutable name : string; mutable address : string}\nval get_record : int -&gt; record\nval sync_records : unit -&gt; unit\n</code></pre>\n<p>The <code>get_record</code> call is the only call that most programs will need to\nmake. It gets the n<sup>th</sup> record either out of the cache or from\ndisk and returns it. The program can then read and/or update the\n<code>record.name</code> and <code>record.address</code> fields. The program then just\nliterally forgets about the record! Behind the scenes, finalisation is\ngoing to write the record back out to disk at some later point in time.</p>\n<p>The <code>sync_records</code> function can also be called by user programs. This\nfunction synchronises the disk copy and in-memory copies of all records.</p>\n<p>OCaml doesn't currently run finalisers at exit. However you can easily\nforce it to by adding the following command to your code. This command\ncauses a full major GC cycle on exit:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">at_exit Gc.full_major\n</code></pre>\n<p>Our code is also going to implement a cache of recently accessed records\nusing the <code>Weak</code> module. The advantage of using the <code>Weak</code> module rather\nthan hand-rolling our own code is two-fold: Firstly the garbage\ncollector has a global view of memory requirements for the whole\nprogram, and so is in a better position to decide when to shrink the\ncache. Secondly our code will be much simpler.</p>\n<p>For our example, we're going to use a very simple format for the file of\nusers' records. The file is just a list of user records, each user\nrecord having a fixed size of 256 bytes. Each user record has just two\nfields (padded with spaces if necessary), the name field (64 bytes) and\nthe address field (192 bytes). Before a record can be loaded into\nmemory, the program must acquire an exclusive lock on the record. After\nthe in-memory copy is written back out to the file, the program must\nrelease the lock. Here is some code to define the on-disk format and\nsome low-level functions to read, write, lock and unlock records:</p>\n<!-- $MDX file=examples/objcache.ml,part=0 -->\n<pre><code class=\"language-ocaml\">(* In-memory format. *)\ntype record = { mutable name : string; mutable address : string }\n\n(* On-disk format. *)\nlet record_size = 256\n\nlet name_size = 64\n\nlet addr_size = 192\n\n(* Low-level load/save records to file. *)\nlet seek_record n fd = ignore (Unix.lseek fd (n * record_size) Unix.SEEK_SET)\n\nlet write_record record n fd =\n  seek_record n fd;\n  ignore (Unix.write fd (Bytes.of_string record.name) 0 name_size);\n  ignore (Unix.write fd (Bytes.of_string record.address) 0 addr_size)\n\nlet read_record record n fd =\n  seek_record n fd;\n  ignore (Unix.read fd (Bytes.of_string record.name) 0 name_size);\n  ignore (Unix.read fd (Bytes.of_string record.address) 0 addr_size)\n\n(* Lock/unlock the nth record in a file. *)\nlet lock_record n fd =\n  seek_record n fd;\n  Unix.lockf fd Unix.F_LOCK record_size\n\nlet unlock_record n fd =\n  seek_record n fd;\n  Unix.lockf fd Unix.F_ULOCK record_size\n</code></pre>\n<p>We also need a function to create new, empty in-memory <code>record</code> objects:</p>\n<!-- $MDX file=examples/objcache.ml,part=1 -->\n<pre><code class=\"language-ocaml\">(* Create a new, empty record. *)\nlet new_record () =\n  { name = String.make name_size ' '; address = String.make addr_size ' ' }\n</code></pre>\n<p>Because this is a really simple program, we're going to fix the number\nof records in advance:</p>\n<!-- $MDX file=examples/objcache.ml,part=2 -->\n<pre><code class=\"language-ocaml\">(* Total number of records. *)\nlet nr_records = 10000\n\n(* On-disk file. *)\nlet diskfile = Unix.openfile &quot;users.bin&quot; [ Unix.O_RDWR; Unix.O_CREAT ] 0o666\n</code></pre>\n<p>Download <a href=\"users.bin.gz\">users.bin.gz</a> and decompress it before\nrunning the program.</p>\n<p>Our cache of records is very simple:</p>\n<!-- $MDX file=examples/objcache.ml,part=3 -->\n<pre><code class=\"language-ocaml\">(* Cache of records. *)\nlet cache = Weak.create nr_records\n</code></pre>\n<p>The <code>get_record</code> function is very short and basically composed of two\nhalves. We grab the record from the cache. If the cache gives us <code>None</code>,\nthen that either means that we haven't loaded this record from the cache\nyet, or else it has been written out to disk (finalised) and dropped\nfrom the cache. If the cache gives us <code>Some record</code> then we just return\n<code>record</code> (this promotes the weak pointer to the record to a normal\npointer).</p>\n<!-- $MDX file=examples/objcache.ml,part=4 -->\n<pre><code class=\"language-ocaml\">(* The finaliser function. *)\nlet finaliser n record =\n  printf &quot;*** objcache: finalising record %d\\n%!&quot; n;\n  write_record record n diskfile;\n  unlock_record n diskfile\n\n(* Get a record from the cache or off disk. *)\nlet get_record n =\n  match Weak.get cache n with\n  | Some record -&gt;\n      printf &quot;*** objcache: fetching record %d from memory cache\\n%!&quot; n;\n      record\n  | None -&gt;\n      printf &quot;*** objcache: loading record %d from disk\\n%!&quot; n;\n      let record = new_record () in\n      Gc.finalise (finaliser n) record;\n      lock_record n diskfile;\n      read_record record n diskfile;\n      Weak.set cache n (Some record);\n      record\n</code></pre>\n<p>The <code>sync_records</code> function is even easier. First of all it empties the\ncache by replacing all the weak pointers with <code>None</code>. This now means\nthat the garbage collector <em>can</em> collect and finalise all of those\nrecords. But it doesn't necessarily mean that the GC <em>will</em> collect the\nrecords straightaway (in fact it's not likely that it will), so to force\nthe GC to collect the records immediately, we also invoke a major cycle:</p>\n<p>Finally we have some test code. I won't reproduce the test code, but you\ncan download the complete program and test code\n<a href=\"objcache.ml\">objcache.ml</a>, and compile it with:</p>\n<!-- $MDX dir=examples -->\n<pre><code class=\"language-sh\">$ ocamlc unix.cma objcache.ml -o objcache\n</code></pre>\n<h2 id=\"exercises\">Exercises</h2>\n<p>Here are some ways to extend the example above, in approximately\nincreasing order of difficulty:</p>\n<ol>\n<li>Implement the record as an <strong>object</strong>, and allow it to transparently\npad/unpad strings. You will need to provide methods to set and get\nthe name and address fields (four public methods in all). Hide as\nmuch of the implementation (file access, locking) code in the class\nas possible.\n</li>\n<li>Extend the program so that it acquires a <strong>read lock</strong> on getting\nthe record, but upgrades this to a <strong>write lock</strong> just before the\nuser updates any field.\n</li>\n<li>Support a <strong>variable number of records</strong> and add a function to\ncreate a new record (in the file). [Tip: OCaml has support for weak\nhashtables.]\n</li>\n<li>Add support for <strong>variable-length records</strong>.\n</li>\n<li>Make the underlying file representation a <strong>DBM-style hash</strong>.\n</li>\n<li>Provide a general-purpose cache fronting a &quot;users&quot; table in your\nchoice of <strong>relational database</strong> (with locking).\n</li>\n</ol>\n","title":"Garbage Collection","pageDescription":"OCaml is a garbage collected language meaning you don't have to worry about allocating and freeing memory\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#garbage-collection-reference-counting-explicit-allocation\">Garbage collection, reference counting, explicit allocation</a>\n</li>\n<li><a href=\"#the-gc-module\">The Gc module</a>\n</li>\n<li><a href=\"#finalisation-and-the-weak-module\">Finalisation and the Weak module</a>\n</li>\n<li><a href=\"#exercises\">Exercises</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"garbage-collection"}},"__N_SSG":true}