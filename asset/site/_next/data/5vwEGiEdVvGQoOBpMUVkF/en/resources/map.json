{"pageProps":{"content":{"source":"<h2 id=\"module-map\">Module Map</h2>\n<p>Map creates a &quot;mapping&quot;. For instance, let's say I have some data that is\nusers and their associated passwords. I could with the Map module create\na mapping from user names to their passwords. The mapping module not\nonly does this but it does it fairly efficiently. It also does this in a\nfunctional way. In the example below I am going to do a mapping from\nstrings to strings. However, it is possible to do mappings with all\ndifferent types of data.</p>\n<p>To create a Map I can do:</p>\n<pre><code class=\"language-ocaml\"># module MyUsers = Map.Make(String)\nmodule MyUsers :\n  sig\n    type key = string\n    type 'a t = 'a Map.Make(String).t\n    val empty : 'a t\n    val is_empty : 'a t -&gt; bool\n    val mem : key -&gt; 'a t -&gt; bool\n    val add : key -&gt; 'a -&gt; 'a t -&gt; 'a t\n    val update : key -&gt; ('a option -&gt; 'a option) -&gt; 'a t -&gt; 'a t\n    val singleton : key -&gt; 'a -&gt; 'a t\n    val remove : key -&gt; 'a t -&gt; 'a t\n    val merge :\n      (key -&gt; 'a option -&gt; 'b option -&gt; 'c option) -&gt; 'a t -&gt; 'b t -&gt; 'c t\n    val union : (key -&gt; 'a -&gt; 'a -&gt; 'a option) -&gt; 'a t -&gt; 'a t -&gt; 'a t\n    val compare : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t -&gt; int\n    val equal : ('a -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t -&gt; bool\n    val iter : (key -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit\n    val fold : (key -&gt; 'a -&gt; 'b -&gt; 'b) -&gt; 'a t -&gt; 'b -&gt; 'b\n    val for_all : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; bool\n    val exists : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; bool\n    val filter : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t\n    val partition : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t * 'a t\n    val cardinal : 'a t -&gt; int\n    val bindings : 'a t -&gt; (key * 'a) list\n    val min_binding : 'a t -&gt; key * 'a\n    val min_binding_opt : 'a t -&gt; (key * 'a) option\n    val max_binding : 'a t -&gt; key * 'a\n    val max_binding_opt : 'a t -&gt; (key * 'a) option\n    val choose : 'a t -&gt; key * 'a\n    val choose_opt : 'a t -&gt; (key * 'a) option\n    val split : key -&gt; 'a t -&gt; 'a t * 'a option * 'a t\n    val find : key -&gt; 'a t -&gt; 'a\n    val find_opt : key -&gt; 'a t -&gt; 'a option\n    val find_first : (key -&gt; bool) -&gt; 'a t -&gt; key * 'a\n    val find_first_opt : (key -&gt; bool) -&gt; 'a t -&gt; (key * 'a) option\n    val find_last : (key -&gt; bool) -&gt; 'a t -&gt; key * 'a\n    val find_last_opt : (key -&gt; bool) -&gt; 'a t -&gt; (key * 'a) option\n    val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val mapi : (key -&gt; 'a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val to_seq : 'a t -&gt; (key * 'a) Seq.t\n    val to_seq_from : key -&gt; 'a t -&gt; (key * 'a) Seq.t\n    val add_seq : (key * 'a) Seq.t -&gt; 'a t -&gt; 'a t\n    val of_seq : (key * 'a) Seq.t -&gt; 'a t\n  end\n</code></pre>\n<p>OK, we have created the module <code>MyUsers</code>.  Now, let's start putting\nsomething into it.  Where do we start?  Well, let's create an empty\nmap to begin with:</p>\n<pre><code class=\"language-ocaml\"># let m = MyUsers.empty\nval m : 'a MyUsers.t = &lt;abstr&gt;\n</code></pre>\n<p>Hummm. An empty map is kind of boring, so let's add some data.</p>\n<pre><code class=\"language-ocaml\"># let m = MyUsers.add &quot;fred&quot; &quot;sugarplums&quot; m\nval m : string MyUsers.t = &lt;abstr&gt;\n</code></pre>\n<p>We have now created a new map—again called <code>m</code>, thus masking the previous\none—by adding\n&quot;fred&quot; and his password &quot;sugarplums&quot; to our previous empty map.\nThere is a fairly important point to make here. Once we have added the\nstring &quot;sugarplums&quot; we have fixed the types of mappings that we can do.\nThis means our mapping in our module <code>MyUsers</code> is from strings <em>to strings</em>.\nIf we want a mapping from strings to integers or a mapping from integers\nto whatever we will have to create a different mapping.</p>\n<p>Let's add in some additional data just for kicks.</p>\n<pre><code class=\"language-ocaml\"># let m = MyUsers.add &quot;tom&quot; &quot;ilovelucy&quot; m\nval m : string MyUsers.t = &lt;abstr&gt;\n# let m = MyUsers.add &quot;mark&quot; &quot;ocamlrules&quot; m\nval m : string MyUsers.t = &lt;abstr&gt;\n# let m = MyUsers.add &quot;pete&quot; &quot;linux&quot; m\nval m : string MyUsers.t = &lt;abstr&gt;\n</code></pre>\n<p>Now that we have some data inside of our map, wouldn't it be nice\nto be able to view that data at some point? Let's begin by creating a\nsimple print function.</p>\n<pre><code class=\"language-ocaml\"># let print_user key password =\n  print_string(key ^ &quot; &quot; ^ password ^ &quot;\\n&quot;)\nval print_user : string -&gt; string -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>We have here a function that will take two strings, a key, and a password,\nand print them out nicely, including a new line character at the end.\nAll we need to do is to have this function applied to our mapping. Here\nis what that would look like.</p>\n<pre><code class=\"language-ocaml\"># MyUsers.iter print_user m\nfred sugarplums\nmark ocamlrules\npete linux\ntom ilovelucy\n- : unit = ()\n</code></pre>\n<p>The reason we put our data into a mapping however is probably so we can\nquickly find the data. Let's actually show how to do a find.</p>\n<pre><code class=\"language-ocaml\"># MyUsers.find &quot;fred&quot; m\n- : string = &quot;sugarplums&quot;\n</code></pre>\n<p>This should quickly and efficiently return Fred's password: &quot;sugarplums&quot;.</p>\n","title":"Map","pageDescription":"Create a mapping using the standard library's Map module\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#module-map\">Module Map</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"map"}},"__N_SSG":true}