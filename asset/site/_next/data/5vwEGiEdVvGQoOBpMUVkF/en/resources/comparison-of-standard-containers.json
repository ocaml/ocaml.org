{"pageProps":{"content":{"source":"<p>This is a rough comparison of the different container types that are\nprovided by the OCaml language or by the OCaml standard library. In each\ncase, n is the number of valid elements in the container.</p>\n<p>Note that the big-O cost given for some operations reflects the current\nimplementation but is not guaranteed by the official documentation.\nHopefully it will not become worse. Anyway, if you want more details,\nyou should read the documentation about each of the modules. Often, it\nis also instructive to read the corresponding implementation.</p>\n<h2 id=\"lists-immutable-singly-linked-lists\">Lists: immutable singly-linked lists</h2>\n<p>Adding an element always creates a new list l from an element x and list\ntl. tl remains unchanged, but it is not copied either.</p>\n<ul>\n<li>&quot;adding&quot; an element: O(1), cons operator <code>::</code>\n</li>\n<li>length: O(n), function <code>List.length</code>\n</li>\n<li>accessing cell <code>i</code>: O(i)\n</li>\n<li>finding an element: O(n)\n</li>\n</ul>\n<p>Well-suited for: IO, pattern-matching</p>\n<p>Not very efficient for: random access, indexed elements</p>\n<h2 id=\"arrays-mutable-vectors\">Arrays: mutable vectors</h2>\n<p>Arrays are mutable data structures with a fixed length and random access.</p>\n<ul>\n<li>&quot;adding&quot; an element (by creating a new array): O(n)\n</li>\n<li>length: O(1), function <code>Array.length</code>\n</li>\n<li>accessing cell <code>i</code>: O(1)\n</li>\n<li>finding an element: O(n)\n</li>\n</ul>\n<p>Well-suited for sets of elements of known size, access by numeric index,\nin-place modification. Basic arrays have a fixed length.</p>\n<h2 id=\"strings-immutable-vectors\">Strings: immutable vectors</h2>\n<p>Strings are very similar to arrays but are immutable. Strings are\nspecialized for storing chars (bytes) and have some convenient syntax.\nStrings have a fixed length. For extensible strings, the standard Buffer\nmodule can be used (see below).</p>\n<ul>\n<li>&quot;adding&quot; an element (by creating a new string): O(n)\n</li>\n<li>length: O(1)\n</li>\n<li>accessing character <code>i</code>: O(1)\n</li>\n<li>finding an element: O(n)\n</li>\n</ul>\n<h2 id=\"set-and-map-immutable-trees\">Set and Map: immutable trees</h2>\n<p>Like lists, these are immutable and they may share some subtrees. They\nare a good solution for keeping older versions of sets of items.</p>\n<ul>\n<li>&quot;adding&quot; an element: O(log n)\n</li>\n<li>returning the number of elements: O(n)\n</li>\n<li>finding an element: O(log n)\n</li>\n</ul>\n<p>Sets and maps are very useful in compilation and meta-programming, but\nin other situations hash tables are often more appropriate (see below).</p>\n<h2 id=\"hashtbl-automatically-growing-hash-tables\">Hashtbl: automatically growing hash tables</h2>\n<p>Ocaml hash tables are mutable data structures, which are a good solution\nfor storing (key, data) pairs in one single place.</p>\n<ul>\n<li>adding an element: O(1) if the initial size of the table is larger\nthan the number of elements it contains; O(log n) on average if n\nelements have been added in a table which is initially much smaller\nthan n.\n</li>\n<li>returning the number of elements: O(1)\n</li>\n<li>finding an element: O(1)\n</li>\n</ul>\n<h2 id=\"buffer-extensible-strings\">Buffer: extensible strings</h2>\n<p>Buffers provide an efficient way to accumulate a sequence of bytes in a\nsingle place. They are mutable.</p>\n<ul>\n<li>adding a char: O(1) if the buffer is big enough, or O(log n) on\naverage if the initial size of the buffer was much smaller than the\nnumber of bytes n.\n</li>\n<li>adding a string of k chars: O(k * &quot;adding a char&quot;)\n</li>\n<li>length: O(1)\n</li>\n<li>accessing cell <code>i</code>: O(1)\n</li>\n</ul>\n<h2 id=\"queue\">Queue</h2>\n<p>OCaml queues are mutable first-in-first-out (FIFO) data structures.</p>\n<ul>\n<li>adding an element: O(1)\n</li>\n<li>taking an element: O(1)\n</li>\n<li>length: O(1)\n</li>\n</ul>\n<h2 id=\"stack\">Stack</h2>\n<p>OCaml stacks are mutable last-in-first-out (LIFO) data structures. They\nare just like lists, except that they are mutable, i.e. adding an\nelement doesn't create a new stack but simply adds it to the stack.</p>\n<ul>\n<li>adding an element: O(1)\n</li>\n<li>taking an element: O(1)\n</li>\n<li>length: O(1)\n</li>\n</ul>\n","title":"Comparison of Standard Containers","pageDescription":"A comparison of some core data-structures including lists, queues and arrays\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#lists-immutable-singly-linked-lists\">Lists: immutable singly-linked lists</a>\n</li>\n<li><a href=\"#arrays-mutable-vectors\">Arrays: mutable vectors</a>\n</li>\n<li><a href=\"#strings-immutable-vectors\">Strings: immutable vectors</a>\n</li>\n<li><a href=\"#set-and-map-immutable-trees\">Set and Map: immutable trees</a>\n</li>\n<li><a href=\"#hashtbl-automatically-growing-hash-tables\">Hashtbl: automatically growing hash tables</a>\n</li>\n<li><a href=\"#buffer-extensible-strings\">Buffer: extensible strings</a>\n</li>\n<li><a href=\"#queue\">Queue</a>\n</li>\n<li><a href=\"#stack\">Stack</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"comparison-of-standard-containers"}},"__N_SSG":true}