{"pageProps":{"content":{"source":"<h2 id=\"what-is-functional-programming\">What is functional programming?</h2>\n<p>We've got quite far into the tutorial, yet we haven't really considered\n<strong>functional programming</strong>. All of the features given so far - rich data\ntypes, pattern matching, type inference, nested functions - you could\nimagine could exist in a kind of &quot;super C&quot; language. These are Cool\nFeatures certainly, and make your code concise, easy to read, and have\nfewer bugs, but they actually have very little to do with functional\nprogramming. In fact my argument is going to be that the reason that\nfunctional languages are so great is <em>not</em> because of functional\nprogramming, but because we've been stuck with C-like languages for\nyears and in the meantime the cutting edge of programming has moved on\nconsiderably. So while we were writing\n<code>struct { int type; union { ... } }</code> for the umpteenth time, ML and\nHaskell programmers had safe variants and pattern matching on datatypes.\nWhile we were being careful to <code>free</code> all our <code>malloc</code>s, there have been\nlanguages with garbage collectors able to outperform hand-coding since\nthe 80s.</p>\n<p>Well, after that I'd better tell you what functional programming is\nanyhow.</p>\n<p>The basic, and not very enlightening definition is this: in a\n<strong>functional language</strong>, <strong>functions</strong> are first-class citizens.</p>\n<p>Lot of words there that don't really make much sense. So let's have an\nexample:</p>\n<pre><code class=\"language-ocaml\"># let double x = x * 2 in\n    List.map double [1; 2; 3]\n- : int list = [2; 4; 6]\n</code></pre>\n<p>In this example, I've first defined a nested function called <code>double</code>\nwhich takes an argument <code>x</code> and returns <code>x * 2</code>. Then <code>map</code> calls\n<code>double</code> on each element of the given list (<code>[1; 2; 3]</code>) to produce the\nresult: a list with each number doubled.</p>\n<p><code>map</code> is known as a <strong>higher-order function</strong> (HOF). Higher-order\nfunctions are just a fancy way of saying that the function takes a\nfunction as one of its arguments. So far so simple. If you're familiar\nwith C/C++ then this looks like passing a function pointer around.</p>\n<p><strong>Closures</strong> are functions which carry around some of the &quot;environment&quot;\nin which they were defined. In particular, a closure can reference\nvariables which were available at the point of its definition. Let's\ngeneralise the function above so that now we can take any list of\nintegers and multiply each element by an arbitrary value <code>n</code>:</p>\n<pre><code class=\"language-ocaml\"># let multiply n list =\n    let f x = n * x in\n      List.map f list\nval multiply : int -&gt; int list -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Hence:</p>\n<pre><code class=\"language-ocaml\"># multiply 2 [1; 2; 3]\n- : int list = [2; 4; 6]\n# multiply 5 [1; 2; 3]\n- : int list = [5; 10; 15]\n</code></pre>\n<p>The important point to note about the <code>multiply</code> function is the nested\nfunction <code>f</code>. This is a closure. Look at how <code>f</code> uses the value of <code>n</code>\nwhich isn't actually passed as an explicit argument to <code>f</code>. Instead <code>f</code>\npicks it up from its environment - it's an argument to the <code>multiply</code>\nfunction and hence available within this function.</p>\n<p>This might sound straightforward, but let's look a bit closer at that\ncall to map: <code>List.map f list</code>.</p>\n<p><code>map</code> is defined in the <code>List</code> module, far away from the current code.\nIn other words, we're passing <code>f</code> into a module defined &quot;a long time\nago, in a galaxy far far away&quot;. For all we know that code might pass <code>f</code>\nto other modules, or save a reference to <code>f</code> somewhere and call it\nlater. Whether it does this or not, the closure will ensure that <code>f</code>\nalways has access back to its parental environment, and to <code>n</code>.</p>\n<p>Here's a real example from lablgtk. This is actually a method on a class\n(we haven't talked about classes and objects yet, but just think of it\nas a function definition for now).</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">class html_skel obj = object (self)\n  ...\n  ...\n  method save_to_channel chan =\n    let receiver_fn content =\n      output_string chan content;\n      true\n    in\n      save obj receiver_fn\n  ...\nend\n</code></pre>\n<p>First of all you need to know that the <code>save</code> function called at the end\nof the method takes as its second argument a function (<code>receiver_fn</code>).\nIt repeatedly calls <code>receiver_fn</code> with snippets of text from the widget\nthat it's trying to save.</p>\n<p>Now look at the definition of <code>receiver_fn</code>. This function is a closure\nalright because it keeps a reference to <code>chan</code> from its environment.</p>\n<h2 id=\"partial-function-applications-and-currying\">Partial function applications and currying</h2>\n<p>Let's define a plus function which just adds two integers:</p>\n<pre><code class=\"language-ocaml\"># let plus a b =\n    a + b\nval plus : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>Some questions for people asleep at the back of the class.</p>\n<ol>\n<li>What is <code>plus</code>?\n</li>\n<li>What is <code>plus 2 3</code>?\n</li>\n<li>What is <code>plus 2</code>?\n</li>\n</ol>\n<p>Question 1 is easy. <code>plus</code> is a function, it takes two arguments which\nare integers and it returns an integer. We write its type like this:</p>\n<pre><code class=\"language-ocaml\"># plus\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>Question 2 is even easier. <code>plus 2 3</code> is a number, the integer <code>5</code>. We\nwrite its value and type like this:</p>\n<pre><code class=\"language-ocaml\"># 5\n- : int = 5\n</code></pre>\n<p>But what about question 3? It looks like <code>plus 2</code> is a mistake, a bug.\nIn fact, however, it isn't. If we type this into the OCaml toplevel, it\ntells us:</p>\n<pre><code class=\"language-ocaml\"># plus 2\n- : int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>This isn't an error. It's telling us that <code>plus 2</code> is in fact a\n<em>function</em>, which takes an <code>int</code> and returns an <code>int</code>. What sort of\nfunction is this? We experiment by first of all giving this mysterious\nfunction a name (<code>f</code>), and then trying it out on a few integers to see\nwhat it does:</p>\n<pre><code class=\"language-ocaml\"># let f = plus 2\nval f : int -&gt; int = &lt;fun&gt;\n# f 10\n- : int = 12\n# f 15\n- : int = 17\n# f 99\n- : int = 101\n</code></pre>\n<p>In engineering this is sufficient <a href=\"humor_proof.html\">proof by example</a>\nfor us to state that <code>plus 2</code> is the function which adds 2 to things.</p>\n<p>Going back to the original definition, let's &quot;fill in&quot; the first\nargument (<code>a</code>) setting it to 2 to get:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let plus 2 b =       (* This is not real OCaml code! *)\n  2 + b\n</code></pre>\n<p>You can kind of see, I hope, why <code>plus 2</code> is the function which adds 2\nto things.</p>\n<p>Looking at the types of these expressions we may be able to see some\nrationale for the strange <code>-&gt;</code> arrow notation used for function types:</p>\n<pre><code class=\"language-ocaml\"># plus\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n# plus 2\n- : int -&gt; int = &lt;fun&gt;\n# plus 2 3\n- : int = 5\n</code></pre>\n<p>This process is called <strong>currying</strong> (or perhaps it's called\n<strong>uncurrying</strong>, I never was really sure which was which). It is called\nthis after Haskell Curry who did some important stuff related to the\nlambda calculus. Since I'm trying to avoid entering into the mathematics\nbehind OCaml because that makes for a very boring and irrelevant\ntutorial, I won't go any further on the subject. You can find much more\ninformation about currying if it interests you by <a href=\"https://www.google.com/search?q=currying\" title=\"https://www.google.com/search?q=currying\">doing a search on\nGoogle</a>.</p>\n<p>Remember our <code>double</code> and <code>multiply</code> functions from earlier on?\n<code>multiply</code> was defined as this:</p>\n<pre><code class=\"language-ocaml\"># let multiply n list =\n  let f x = n * x in\n    List.map f list\nval multiply : int -&gt; int list -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>We can now define <code>double</code>, <code>triple</code> &amp;c functions very easily just like\nthis:</p>\n<pre><code class=\"language-ocaml\"># let double = multiply 2\nval double : int list -&gt; int list = &lt;fun&gt;\n# let triple = multiply 3\nval triple : int list -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>They really are functions, look:</p>\n<pre><code class=\"language-ocaml\"># double [1; 2; 3]\n- : int list = [2; 4; 6]\n# triple [1; 2; 3]\n- : int list = [3; 6; 9]\n</code></pre>\n<p>You can also use partial application directly (without the intermediate\n<code>f</code> function) like this:</p>\n<pre><code class=\"language-ocaml\"># let multiply n = List.map (( * ) n)\nval multiply : int -&gt; int list -&gt; int list = &lt;fun&gt;\n# let double = multiply 2\nval double : int list -&gt; int list = &lt;fun&gt;\n# let triple = multiply 3\nval triple : int list -&gt; int list = &lt;fun&gt;\n# double [1; 2; 3]\n- : int list = [2; 4; 6]\n# triple [1; 2; 3]\n- : int list = [3; 6; 9]\n</code></pre>\n<p>In the example above, <code>(( * ) n)</code> is the partial application of the <code>( * )</code>\n(times) function. Note the extra spaces needed so that OCaml doesn't\nthink <code>(*</code> starts a comment.</p>\n<p>You can put infix operators into brackets to make functions. Here's an\nidentical definition of the <code>plus</code> function as before:</p>\n<pre><code class=\"language-ocaml\"># let plus = ( + )\nval plus : int -&gt; int -&gt; int = &lt;fun&gt;\n# plus 2 3\n- : int = 5\n</code></pre>\n<p>Here's some more currying fun:</p>\n<pre><code class=\"language-ocaml\"># List.map (plus 2) [1; 2; 3]\n- : int list = [3; 4; 5]\n# let list_of_functions = List.map plus [1; 2; 3]\nval list_of_functions : (int -&gt; int) list = [&lt;fun&gt;; &lt;fun&gt;; &lt;fun&gt;]\n</code></pre>\n<h2 id=\"what-is-functional-programming-good-for\">What is functional programming good for?</h2>\n<p>Functional programming, like any good programming technique, is a useful\ntool in your armoury for solving some classes of problems. It's very\ngood for callbacks, which have multiple uses from GUIs through to\nevent-driven loops. It's great for expressing generic algorithms.\n<code>List.map</code> is really a generic algorithm for applying functions over any\ntype of list. Similarly you can define generic functions over trees.\nCertain types of numerical problems can be solved more quickly with\nfunctional programming (for example, numerically calculating the\nderivative of a mathematical function).</p>\n<h2 id=\"pure-and-impure-functional-programming\">Pure and impure functional programming</h2>\n<p>A <strong>pure function</strong> is one without any <strong>side-effects</strong>. A side-effect\nreally means that the function keeps some sort of hidden state inside\nit. <code>strlen</code> is a good example of a pure function in C. If you call\n<code>strlen</code> with the same string, it always returns the same length. The\noutput of <code>strlen</code> (the length) only depends on the inputs (the string)\nand nothing else. Many functions in C are, unfortunately, impure. For\nexample, <code>malloc</code> - if you call it with the same number, it certainly\nwon't return the same pointer to you. <code>malloc</code>, of course, relies on a\nhuge amount of hidden internal state (objects allocated on the heap, the\nallocation method in use, grabbing pages from the operating system,\netc.).</p>\n<p>ML-derived languages like OCaml are &quot;mostly pure&quot;. They allow\nside-effects through things like references and arrays, but by and large\nmost of the code you'll write will be pure functional because they\nencourage this thinking. Haskell, another functional language, is pure\nfunctional. OCaml is therefore more practical because writing impure\nfunctions is sometimes useful.</p>\n<p>There are various theoretical advantages of having pure functions. One\nadvantage is that if a function is pure, then if it is called several\ntimes with the same arguments, the compiler only needs to actually call\nthe function once. A good example in C is:</p>\n<pre><code class=\"language-C\">for (i = 0; i &lt; strlen (s); ++i)\n  {\n    // Do something which doesn't affect s.\n  }\n</code></pre>\n<p>If naively compiled, this loop is O(n<sup>2</sup>) because <code>strlen (s)</code>\nis called each time and <code>strlen</code> needs to iterate over the whole of <code>s</code>.\nIf the compiler is smart enough to work out that <code>strlen</code> is pure\nfunctional <em>and</em> that <code>s</code> is not updated in the loop, then it can remove\nthe redundant extra calls to <code>strlen</code> and make the loop O(n). Do\ncompilers really do this? In the case of <code>strlen</code> yes, in other cases,\nprobably not.</p>\n<p>Concentrating on writing small pure functions allows you to construct\nreusable code using a bottom-up approach, testing each small function as\nyou go along. The current fashion is for carefully planning your\nprograms using a top-down approach, but in the author's opinion this\noften results in projects failing.</p>\n<h2 id=\"strictness-vs-laziness\">Strictness vs laziness</h2>\n<p>C-derived and ML-derived languages are strict. Haskell and Miranda are\nnon-strict, or lazy, languages. OCaml is strict by default but allows a\nlazy style of programming where it is needed.</p>\n<p>In a strict language, arguments to functions are always evaluated first,\nand the results are then passed to the function. For example in a strict\nlanguage, the call <code>give_me_a_three (1/0)</code> is always going to result in\na divide-by-zero error:</p>\n<pre><code class=\"language-ocaml\"># let give_me_a_three _ = 3\nval give_me_a_three : 'a -&gt; int = &lt;fun&gt;\n# give_me_a_three (1/0)\nException: Division_by_zero.\n</code></pre>\n<p>If you've programmed in any conventional language, this is just how\nthings work, and you'd be surprised that things could work any other\nway.</p>\n<p>In a lazy language, something stranger happens. Arguments to functions\nare only evaluated if the function actually uses them. Remember that the\n<code>give_me_a_three</code> function throws away its argument and always returns a\n3? Well in a lazy language, the above call would <em>not</em> fail because\n<code>give_me_a_three</code> never looks at its first argument, so the first\nargument is never evaluated, so the division by zero doesn't happen.</p>\n<p>Lazy languages also let you do really odd things like defining an\ninfinitely long list. Provided you don't actually try to iterate over\nthe whole list this works (say, instead, that you just try to fetch the\nfirst 10 elements).</p>\n<p>OCaml is a strict language, but has a <code>Lazy</code> module that lets you write\nlazy expressions. Here's an example. First we create a lazy expression\nfor <code>1/0</code>:</p>\n<pre><code class=\"language-ocaml\"># let lazy_expr = lazy (1 / 0)\nval lazy_expr : int lazy_t = &lt;lazy&gt;\n</code></pre>\n<p>Notice the type of this lazy expression is <code>int lazy_t</code>.</p>\n<p>Because <code>give_me_a_three</code> takes <code>'a</code> (any type) we can pass this lazy\nexpression into the function:</p>\n<pre><code class=\"language-ocaml\"># give_me_a_three lazy_expr\n- : int = 3\n</code></pre>\n<p>To evaluate a lazy expression, you must use the <code>Lazy.force</code> function:</p>\n<pre><code class=\"language-ocaml\"># Lazy.force lazy_expr\nException: Division_by_zero.\n</code></pre>\n<h2 id=\"boxed-vs-unboxed-types\">Boxed vs. unboxed types</h2>\n<p>One term which you'll hear a lot when discussing functional languages is\n&quot;boxed&quot;. I was very confused when I first heard this term, but in fact\nthe distinction between boxed and unboxed types is quite simple if\nyou've used C, C++ or Java before (in Perl, everything is boxed).</p>\n<p>The way to think of a boxed object is to think of an object which has\nbeen allocated on the heap using <code>malloc</code> in C (or equivalently <code>new</code> in\nC++), and/or is referred to through a pointer. Take a look at this\nexample C program:</p>\n<pre><code class=\"language-C\">#include &lt;stdio.h&gt;\n\nvoid\nprintit (int *ptr)\n{\n  printf (&quot;the number is %d\\n&quot;, *ptr);\n}\n\nvoid\nmain ()\n{\n  int a = 3;\n  int *p = &amp;a;\n\n  printit (p);\n}\n</code></pre>\n<p>The variable <code>a</code> is allocated on the stack, and is quite definitely\nunboxed.</p>\n<p>The function <code>printit</code> takes a boxed integer and prints it.</p>\n<p>The diagram below shows an array of unboxed (top) vs. boxed (below)\nintegers:</p>\n<p><img src=\"/tutorials/boxedarray.png\" alt=\"Boxed Array\" title=\"\" /></p>\n<p>No prizes for guessing that the array of unboxed integers is much faster\nthan the array of boxed integers. In addition, because there are fewer\nseparate allocations, garbage collection is much faster and simpler on\nthe array of unboxed objects.</p>\n<p>In C or C++ you should have no problems constructing either of the two\ntypes of arrays above. In Java, you have two types, <code>int</code> which is\nunboxed and <code>Integer</code> which is boxed, and hence considerably less\nefficient. In OCaml, the basic types are all unboxed.</p>\n<h2 id=\"aliases-for-function-names-and-arguments\">Aliases for function names and arguments</h2>\n<p>It's possible to use this as a neat trick to save typing: aliasing function\nnames, and function arguments.</p>\n<p>Although we haven't looked at object-oriented programming (that's the\nsubject for the <a href=\"objects.html\">&quot;Objects&quot; section</a>),\nhere's an example from OCamlNet of an\naliased function call. All you need to know is that\n<code>cgi # output # output_string &quot;string&quot;</code> is a method call, similar to\n<code>cgi.output().output_string (&quot;string&quot;)</code> in Java.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let begin_page cgi title =\n  let out = cgi # output # output_string in\n  out &quot;&lt;html&gt;\\n&quot;;\n  out &quot;&lt;head&gt;\\n&quot;;\n  out (&quot;&lt;title&gt;&quot; ^ text title ^ &quot;&lt;/title&gt;\\n&quot;);\n  out (&quot;&lt;style type=\\&quot;text/css\\&quot;&gt;\\n&quot;);\n  out &quot;body { background: white; color: black; }\\n&quot;;\n  out &quot;&lt;/style&gt;\\n&quot;;\n  out &quot;&lt;/head&gt;\\n&quot;;\n  out &quot;&lt;body&gt;\\n&quot;;\n  out (&quot;&lt;h1&gt;&quot; ^ text title ^ &quot;&lt;/h1&gt;\\n&quot;)\n</code></pre>\n<p>The <code>let out = ... </code> is a partial function application for that method\ncall (partial, because the string parameter hasn't been applied). <code>out</code>\nis therefore a function, which takes a string parameter.</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">out &quot;&lt;html&gt;\\n&quot;;\n</code></pre>\n<p>is equivalent to:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">cgi # output # output_string &quot;&lt;html&gt;\\n&quot;;\n</code></pre>\n<p>We saved ourselves a lot of typing there.</p>\n<p>We can also add arguments. This alternative definition of <code>print_string</code>\ncan be thought of as a kind of alias for a function name plus arguments:</p>\n<!-- $MDX skip -->\n<pre><code class=\"language-ocaml\">let print_string = output_string stdout\n</code></pre>\n<p><code>output_string</code> takes two arguments (a channel and a string), but since\nwe have only supplied one, it is partially applied. So <code>print_string</code> is\na function, expecting one string argument.</p>\n","title":"Functional Programming","pageDescription":"A guide to functional programming in OCaml\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#what-is-functional-programming\">What is functional programming?</a>\n</li>\n<li><a href=\"#partial-function-applications-and-currying\">Partial function applications and currying</a>\n</li>\n<li><a href=\"#what-is-functional-programming-good-for\">What is functional programming good for?</a>\n</li>\n<li><a href=\"#pure-and-impure-functional-programming\">Pure and impure functional programming</a>\n</li>\n<li><a href=\"#strictness-vs-laziness\">Strictness vs laziness</a>\n</li>\n<li><a href=\"#boxed-vs-unboxed-types\">Boxed vs. unboxed types</a>\n</li>\n<li><a href=\"#aliases-for-function-names-and-arguments\">Aliases for function names and arguments</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"functional-programming"}},"__N_SSG":true}