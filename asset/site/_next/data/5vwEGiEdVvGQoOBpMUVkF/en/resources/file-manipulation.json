{"pageProps":{"content":{"source":"<p>This is a guide to basic file manipulation in OCaml using only the\nstandard library.</p>\n<!-- TODO: links to new API locations -->\n<p>Official documentation for the modules of interest:\nthe core library including the initially opened module Stdlib and Printf.</p>\n<h2 id=\"buffered-channels\">Buffered channels</h2>\n<p>The normal way of opening a file in OCaml returns a <strong>channel</strong>. There\nare two kinds of channels:</p>\n<ul>\n<li>channels that write to a file: type <code>out_channel</code>\n</li>\n<li>channels that read from a file: type <code>in_channel</code>\n</li>\n</ul>\n<h3 id=\"writing\">Writing</h3>\n<p>For writing into a file, you would do this:</p>\n<ol>\n<li>Open the file to obtain an <code>out_channel</code>\n</li>\n<li>Write to the channel\n</li>\n<li>If you want to force writing to the physical device, you must flush\nthe channel, otherwise writing will not take place immediately.\n</li>\n<li>When you are done, you can close the channel. This flushes the\nchannel automatically.\n</li>\n</ol>\n<p>Commonly used functions: <code>open_out</code>, <code>open_out_bin</code>, <code>flush</code>,\n<code>close_out</code>, <code>close_out_noerr</code></p>\n<p>Standard <code>out_channel</code>s: <code>stdout</code>, <code>stderr</code></p>\n<h3 id=\"reading\">Reading</h3>\n<p>For reading data from a file you would do this:</p>\n<ol>\n<li>Open the file to obtain an <code>in_channel</code>\n</li>\n<li>Read characters from the channel. Reading consumes the channel, so\nif you read a character, the channel will point to the next\ncharacter in the file.\n</li>\n<li>When there are no more characters to read, the <code>End_of_file</code>\nexception is raised. Often, this is where you want to close the\nchannel.\n</li>\n</ol>\n<p>Commonly used functions: <code>open_in</code>, <code>open_in_bin</code>, <code>close_in</code>,\n<code>close_in_noerr</code></p>\n<p>Standard <code>in_channel</code>: <code>stdin</code></p>\n<h3 id=\"seeking\">Seeking</h3>\n<p>Whenever you write or read something to or from a channel, the current\nposition changes to the next character after what you just wrote or\nread. Occasionally, you may want to skip to a particular position in the\nfile, or restart reading from the beginning. This is possible for\nchannels that point to regular files, use <code>seek_in</code> or <code>seek_out</code>.</p>\n<h3 id=\"gotchas\">Gotchas</h3>\n<ul>\n<li>Don't forget to flush your <code>out_channel</code>s if you want to actually\nwrite something. This is particularly important if you are writing\nto non-files such as the standard output (<code>stdout</code>) or a socket.\n</li>\n<li>Don't forget to close any unused channel, because operating systems\nhave a limit on the number of files that can be opened\nsimultaneously. You must catch any exception that would occur during\nthe file manipulation, close the corresponding channel, and re-raise\nthe exception.\n</li>\n<li>The <code>Unix</code> module provides access to non-buffered file descriptors\namong other things. It provides standard file descriptors that have\nthe same name as the corresponding standard channels: <code>stdin</code>,\n<code>stdout</code> and <code>stderr</code>. Therefore if you do <code>open Unix</code>, you may get\ntype errors. If you want to be sure that you are using the <code>stdout</code>\nchannel and not the <code>stdout</code> file descriptor, you can prepend it\nwith the module name where it comes from: <code>Stdlib.stdout</code>. <em>Note\nthat most things that don't seem to belong to any module actually\nbelong to the <code>Stdlib</code> module, which is automatically opened.</em>\n</li>\n<li><code>open_out</code> and <code>open_out_bin</code> truncate the given file if it already\nexists! Use <code>open_out_gen</code> if you want an alternate behavior.\n</li>\n</ul>\n<h3 id=\"example\">Example</h3>\n<!-- $MDX file=examples/file_manip.ml -->\n<pre><code class=\"language-ocaml\">let file = &quot;example.dat&quot;\n\nlet message = &quot;Hello!&quot;\n\nlet () =\n  (* Write message to file *)\n  let oc = open_out file in\n  (* create or truncate file, return channel *)\n  Printf.fprintf oc &quot;%s\\n&quot; message;\n  (* write something *)\n  close_out oc;\n\n  (* flush and close the channel *)\n\n  (* Read file and display the first line *)\n  let ic = open_in file in\n  try\n    let line = input_line ic in\n    (* read line, discard \\n *)\n    print_endline line;\n    (* write the result to stdout *)\n    flush stdout;\n    (* write on the underlying device now *)\n    close_in ic\n    (* close the input channel *)\n  with e -&gt;\n    (* some unexpected exception occurs *)\n    close_in_noerr ic;\n    (* emergency closing *)\n    raise e\n\n(* exit with error: files are closed but channels are not flushed *)\n\n(* normal exit: all channels are flushed and closed *)\n</code></pre>\n<p>We can compile and run this example:</p>\n<!-- $MDX dir=examples -->\n<pre><code class=\"language-sh\">$ ocamlopt -o file_manip file_manip.ml\n$ ./file_manip\nHello!\n</code></pre>\n","title":"File Manipulation","pageDescription":"A guide to basic file manipulation in OCaml with the standard library\n","tableOfContents":"<ul>\n<li><ul>\n<li><a href=\"#buffered-channels\">Buffered channels</a>\n</li>\n</ul>\n</li>\n</ul>\n"},"params":{"lang":"en","tutorial":"file-manipulation"}},"__N_SSG":true}