(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[891],{7891:function(e,n,t){"use strict";t.d(n,{tG:function(){return f},Cs:function(){return m},fy:function(){return g},v7:function(){return b},Sq:function(){return v},Xk:function(){return y},Cg:function(){return w},nk:function(){return k}});var a=t(6156),o=t(8750),s=t(1442),i={hd:{title:"Algorithmen, Datenstrukturen, Funktionale Programmierung: Eine praktische Einf\xfchrung mit Caml Light",slug:"algorithmen-datenstrukturen-funktionale-programmierung-eine-praktische-einfhrung-mit-caml-light",description:"In the first part of this book, algorithms are described in a concise and precise manner using Caml Light. The second part provides a tutorial introduction into the language Caml Light and in its last chapter a comprehensive description of the language kernel.\n",authors:{hd:"Juergen Wolff von Gudenberg",tl:0},language:"german",published:"1996",cover:"/books/wolff.gif",isbn:void 0,links:0,body_md:"This book gives an introduction to programming where algorithms as well\nas data structures are considered functionally. It is intended as an\naccompanying book for basic courses in computer science, but it is also\nsuitable for self-studies. In the first part, algorithms are described\nin a concise and precise manner using Caml Light. The second part\nprovides a tutorial introduction into the language Caml Light and in its\nlast chapter a comprehensive description of the language kernel.",body_html:"<p>This book gives an introduction to programming where algorithms as well\nas data structures are considered functionally. It is intended as an\naccompanying book for basic courses in computer science, but it is also\nsuitable for self-studies. In the first part, algorithms are described\nin a concise and precise manner using Caml Light. The second part\nprovides a tutorial introduction into the language Caml Light and in its\nlast chapter a comprehensive description of the language kernel.</p>\n"},tl:{hd:{title:"Apprendre \xe0 programmer avec OCaml",slug:"apprendre--programmer-avec-ocaml",description:"This book is organized into three parts. The first one introduces OCaml and targets beginners, being they programming beginners or simply new to OCaml. Through small programs, the reader is introduced to fundamental concepts of programming and of OCaml. The second and third parts are dedicated to fundamental concepts of algorithmics and should allow the reader to write programs in a structured and efficient way.\n",authors:{hd:"Jean-Christophe Filli\xe2tre",tl:{hd:"Sylvain Conchon",tl:0}},language:"french",published:"2014",cover:"/books/apprendre_ocaml_cover.png",isbn:"2-21213-678-1",links:{hd:{description:"Online",uri:"https://programmer-avec-ocaml.lri.fr/"},tl:{hd:{description:"Order at Amazon.fr",uri:"https://www.amazon.fr/Apprendre-programmer-avec-Ocaml-Algorithmes/dp/2212136781/"},tl:0}},body_md:"Computer programming is hard to learn. Being a skillful programmer\nrequires imagination, anticipation, knowledge in algorithmics, the\nmastery of a programming language, and above all experience, as\ndifficulties are often hidden in details.  This book synthesizes our\nexperience as teachers and programmers.\n\nThe programming style is essential. Given a programming language, the\nsame algorithm can be written in multiple ways, and some of them can\nbe both elegant and efficient. This is what the programmer must seek\nat all costs and the reason why we choose a programming language for\nthis book rather than pseudo-code. Our choice is OCaml.\n\nThis book is organized into three parts. The first one introduces\nOCaml and targets beginners, being they programming beginners or\nsimply new to OCaml. Through small programs, the reader is introduced\nto fundamental concepts of programming and of OCaml. The second and\nthird parts are dedicated to fundamental concepts of algorithmics and\nshould allow the reader to write programs in a structured and\nefficient way. Algorithmic concepts are directly presented in the\nsyntax of OCaml and any code snippet from the book is available\nonline.",body_html:"<p>Computer programming is hard to learn. Being a skillful programmer\nrequires imagination, anticipation, knowledge in algorithmics, the\nmastery of a programming language, and above all experience, as\ndifficulties are often hidden in details.  This book synthesizes our\nexperience as teachers and programmers.</p>\n<p>The programming style is essential. Given a programming language, the\nsame algorithm can be written in multiple ways, and some of them can\nbe both elegant and efficient. This is what the programmer must seek\nat all costs and the reason why we choose a programming language for\nthis book rather than pseudo-code. Our choice is OCaml.</p>\n<p>This book is organized into three parts. The first one introduces\nOCaml and targets beginners, being they programming beginners or\nsimply new to OCaml. Through small programs, the reader is introduced\nto fundamental concepts of programming and of OCaml. The second and\nthird parts are dedicated to fundamental concepts of algorithmics and\nshould allow the reader to write programs in a structured and\nefficient way. Algorithmic concepts are directly presented in the\nsyntax of OCaml and any code snippet from the book is available\nonline.</p>\n"},tl:{hd:{title:"Apprentissage de la programmation avec OCaml",slug:"apprentissage-de-la-programmation-avec-ocaml",description:"This book is targeted towards beginner programmers and provides teaching material for all programmers wishing to learn the functional programming style. The programming features introduced in this book are available in all dialects of the ML language, notably Caml-Light, OCaml and Standard ML.\n",authors:{hd:"Catherine Dubois",tl:{hd:"Val\xe9rie M\xe9nissier Morain",tl:0}},language:"french",published:"2004",cover:"/books/dubois-menissier.gif",isbn:"2-7462-0819-9",links:0,body_md:"Programming is a discipline by which the strengths of computers can be\nharnessed: large amounts of reliable memory, the ability to execute\nrepetitive tasks relentlessly, and a high computation speed. In order to\nwrite correct programs that fulfill their specified needs, it is\nnecessary to understand the precise semantics of the programming\nlanguage. This book is targeted towards beginner programmers and\nprovides teaching material for all programmers wishing to learn the\nfunctional programming style. The programming features introduced in\nthis book are available in all dialects of the ML language, notably\nCaml-Light, OCaml and Standard ML. The concepts presented therein and\nillustrated in OCaml easily transpose to other programming languages.",body_html:"<p>Programming is a discipline by which the strengths of computers can be\nharnessed: large amounts of reliable memory, the ability to execute\nrepetitive tasks relentlessly, and a high computation speed. In order to\nwrite correct programs that fulfill their specified needs, it is\nnecessary to understand the precise semantics of the programming\nlanguage. This book is targeted towards beginner programmers and\nprovides teaching material for all programmers wishing to learn the\nfunctional programming style. The programming features introduced in\nthis book are available in all dialects of the ML language, notably\nCaml-Light, OCaml and Standard ML. The concepts presented therein and\nillustrated in OCaml easily transpose to other programming languages.</p>\n"},tl:{hd:{title:"Approche Fonctionnelle de la Programmation",slug:"approche-fonctionnelle-de-la-programmation",description:"This book uses OCaml as a tool to introduce several important programming concepts.",authors:{hd:"Guy Cousineau",tl:{hd:"Michel Mauny",tl:0}},language:"french",published:"1995",cover:"/books/cousineau-mauny-fr.gif",isbn:"2-84074-114-8",links:{hd:{description:"Book Website",uri:"https://pauillac.inria.fr/cousineau-mauny/main-fr.html"},tl:0},body_md:"This book uses OCaml as a tool to introduce several important\nprogramming concepts. It is divided in three parts. The first part is an\nintroduction to OCaml, which presents the language itself, but also\nintroduces evaluation by rewriting, evaluation strategies and proofs of\nprograms by induction. The second part is dedicated to the description\nof application programs which belong to various fields and might\ninterest various types of readers or students. Finally, the third part\nis dedicated to implementation. It describes interpretation then\ncompilation, with brief descriptions of memory management and type\nsynthesis.",body_html:"<p>This book uses OCaml as a tool to introduce several important\nprogramming concepts. It is divided in three parts. The first part is an\nintroduction to OCaml, which presents the language itself, but also\nintroduces evaluation by rewriting, evaluation strategies and proofs of\nprograms by induction. The second part is dedicated to the description\nof application programs which belong to various fields and might\ninterest various types of readers or students. Finally, the third part\nis dedicated to implementation. It describes interpretation then\ncompilation, with brief descriptions of memory management and type\nsynthesis.</p>\n"},tl:{hd:{title:"Concepts et outils de programmation",slug:"concepts-et-outils-de-programmation",description:"The book begins with a functional approach, based on OCaml, and continues with a presentation of an imperative language, namely Ada. It also provides numerous exercises with solutions.\n",authors:{hd:"Th\xe9r\xe8se Accart Hardin",tl:{hd:"V\xe9ronique Donzeau-Gouge Vigui\xe9",tl:0}},language:"french",published:"1992",cover:"/books/hardin-donzeau-gouge.gif",isbn:"2-7296-0419-7",links:{hd:{description:"Order at Amazon.fr",uri:"https://www.amazon.fr/exec/obidos/ASIN/2729604197"},tl:0},body_md:"This book presents a new approach to teaching programming concepts to\nbeginners, based on language semantics. A simplified semantic model is\nused to describe in a precise manner the features found in most\nprogramming languages. This model is powerful enough to explain\ntypechecking, polymorphism, evaluation, side-effects, modularity,\nexceptions. Yet, it is simple enough to be manipulated by hand, so that\nstudents can actually use it to compute. The book begins with a\nfunctional approach, based on OCaml, and continues with a presentation\nof an imperative language, namely Ada. It also provides numerous\nexercises with solutions.",body_html:"<p>This book presents a new approach to teaching programming concepts to\nbeginners, based on language semantics. A simplified semantic model is\nused to describe in a precise manner the features found in most\nprogramming languages. This model is powerful enough to explain\ntypechecking, polymorphism, evaluation, side-effects, modularity,\nexceptions. Yet, it is simple enough to be manipulated by hand, so that\nstudents can actually use it to compute. The book begins with a\nfunctional approach, based on OCaml, and continues with a presentation\nof an imperative language, namely Ada. It also provides numerous\nexercises with solutions.</p>\n"},tl:{hd:{title:"Cours et exercices d'informatique",slug:"cours-et-exercices-dinformatique",description:"This book was written by teachers at university and in \u201cclasses pr\xe9paratoires\u201d. It is intended for \u201cclasses pr\xe9paratoires\u201d students who study computer science and for students engaged in a computer science cursus up to the masters level. It includes a tutorial of the OCaml language, a course on algorithms, data structures, automata theory, and formal logic, as well as 135 exercises with solutions.\n",authors:{hd:"Luc Albert",tl:0},language:"french",published:"1997",cover:"/books/albert.gif",isbn:"2-84180-106-3",links:0,body_md:"This book was written by teachers at university and in \u201cclasses\npr\xe9paratoires\u201d. It is intended for \u201cclasses pr\xe9paratoires\u201d students who\nstudy computer science and for students engaged in a computer science\ncursus up to the masters level. It includes a tutorial of the OCaml\nlanguage, a course on algorithms, data structures, automata theory, and\nformal logic, as well as 135 exercises with solutions.",body_html:"<p>This book was written by teachers at university and in \u201cclasses\npr\xe9paratoires\u201d. It is intended for \u201cclasses pr\xe9paratoires\u201d students who\nstudy computer science and for students engaged in a computer science\ncursus up to the masters level. It includes a tutorial of the OCaml\nlanguage, a course on algorithms, data structures, automata theory, and\nformal logic, as well as 135 exercises with solutions.</p>\n"},tl:{hd:{title:"Developing Applications with OCaml",slug:"developing-applications-with-ocaml",description:"A comprehensive (742 page) guide to developing application in the OCaml programming language\n",authors:{hd:"Emmanuel Chailloux",tl:{hd:"Pascal Manoury",tl:{hd:"Bruno Pagano",tl:0}}},language:"english",published:"2002",cover:"/books/logocaml-oreilly.gif",isbn:void 0,links:{hd:{description:"Book Website",uri:"https://caml.inria.fr/pub/docs/oreilly-book/index.html"},tl:{hd:{description:"Online",uri:"https://caml.inria.fr/pub/docs/oreilly-book/html/index.html"},tl:{hd:{description:"PDF",uri:"https://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf"},tl:0}}},body_md:"A comprehensive (742 pages) book on OCaml, covering not only the core\nlanguage, but also modules, objects and classes, threads and systems\nprogramming, interoperability with C, and runtime tools. This book is a\ntranslation of a French book published by OReilly.",body_html:"<p>A comprehensive (742 pages) book on OCaml, covering not only the core\nlanguage, but also modules, objects and classes, threads and systems\nprogramming, interoperability with C, and runtime tools. This book is a\ntranslation of a French book published by OReilly.</p>\n"},tl:{hd:{title:"D\xe9veloppement d'applications avec Objective Caml",slug:"dveloppement-dapplications-avec-objective-caml",description:"\"Objective CAML est un langage de programmation : un de plus dira-t-on ! Ils sont en effet d\xe9j\xe0 nombreux et pourtant il en appara\xeet constamment de nouveaux. Au del\xe0 de leurs disparit\xe9s, la conception et la gen\xe8se de chacun d'eux proc\xe8dent d'une motivation partag\xe9e : la volont\xe9 d'abstraire\"\n",authors:{hd:"Emmanuel Chailloux",tl:{hd:"Pascal Manoury",tl:{hd:"Bruno Pagano",tl:0}}},language:"french",published:"2000",cover:"/books/chailloux-manoury-pagano.jpg",isbn:"2-84177-121-0",links:{hd:{description:"Online",uri:"https://www.pps.jussieu.fr/Livres/ora/DA-OCAML/index.html"},tl:{hd:{description:"Order at Amazon.fr",uri:"https://www.amazon.fr/exec/obidos/ASIN/2841771210"},tl:0}},body_md:"A comprehensive (742 pages) book on OCaml, covering not only the core\nlanguage, but also modules, objects and classes, threads and systems\nprogramming, and interoperability with C.\n\n\"Objective CAML est un langage de programmation : un de plus dira-t-on ! Ils sont en effet d\xe9j\xe0 nombreux et pourtant il en appara\xeet constamment de nouveaux. Au del\xe0 de leurs disparit\xe9s, la conception et la gen\xe8se de chacun d'eux proc\xe8dent d'une motivation partag\xe9e : la volont\xe9 d'abstraire\"",body_html:"<p>A comprehensive (742 pages) book on OCaml, covering not only the core\nlanguage, but also modules, objects and classes, threads and systems\nprogramming, and interoperability with C.</p>\n<p>&quot;Objective CAML est un langage de programmation : un de plus dira-t-on ! Ils sont en effet d\xe9j\xe0 nombreux et pourtant il en appara\xeet constamment de nouveaux. Au del\xe0 de leurs disparit\xe9s, la conception et la gen\xe8se de chacun d'eux proc\xe8dent d'une motivation partag\xe9e : la volont\xe9 d'abstraire&quot;</p>\n"},tl:{hd:{title:"Initiation \xe0 la programmation fonctionnelle en OCaml",slug:"initiation--la-programmation-fonctionnelle-en-ocaml",description:"Le but de ce livre est d\u2019initier le lecteur au style fonctionnel de programmation en utilisant le langage OCaml.\n",authors:{hd:"Mohammed-Said Habet",tl:0},language:"french",published:"2015",cover:"/books/Initiation_a_la_programmation_fonctionnelle_en_OCaml.jpg",isbn:"9782332978400",links:{hd:{description:"Website",uri:"https://www.edilivre.com/initiation-a-la-programmation-fonctionnelle-en-ocaml-mohammed-said-habet.html"},tl:0},body_md:"La programmation fonctionnelle est un style de programmation qui\nconsiste \xe0 consid\xe9rer les programmes informatiques comme des fonctions\nau sens math\xe9matique du terme. Ce style est propos\xe9 dans de nombreux\nlangages de programmation anciens et r\xe9cents comme OCaml.\n\nLe but de ce livre est d\u2019initier le lecteur au style fonctionnel de\nprogrammation en utilisant le langage OCaml. Cet ouvrage s\u2019adresse\ndonc principalement aux d\xe9butants en informatique. Il peut \xe9galement\n\xeatre l\u2019occasion pour les initi\xe9s de d\xe9couvrir le langage de\nprogrammation OCaml.\n\nLe lecteur trouvera une pr\xe9sentation progressive des concepts de\nprogrammation fonctionnelle dans le langage OCaml, illustr\xe9e par des\nexemples, de nombreux exercices corrig\xe9s et d\u2019autres laiss\xe9s \xe0\nl\u2019initiative du lecteur.",body_html:"<p>La programmation fonctionnelle est un style de programmation qui\nconsiste \xe0 consid\xe9rer les programmes informatiques comme des fonctions\nau sens math\xe9matique du terme. Ce style est propos\xe9 dans de nombreux\nlangages de programmation anciens et r\xe9cents comme OCaml.</p>\n<p>Le but de ce livre est d\u2019initier le lecteur au style fonctionnel de\nprogrammation en utilisant le langage OCaml. Cet ouvrage s\u2019adresse\ndonc principalement aux d\xe9butants en informatique. Il peut \xe9galement\n\xeatre l\u2019occasion pour les initi\xe9s de d\xe9couvrir le langage de\nprogrammation OCaml.</p>\n<p>Le lecteur trouvera une pr\xe9sentation progressive des concepts de\nprogrammation fonctionnelle dans le langage OCaml, illustr\xe9e par des\nexemples, de nombreux exercices corrig\xe9s et d\u2019autres laiss\xe9s \xe0\nl\u2019initiative du lecteur.</p>\n"},tl:{hd:{title:"Introduction to OCaml",slug:"introduction-to-ocaml",description:"This book is an introduction to ML programming, specifically for the OCaml programming language from INRIA. OCaml is a dialect of the ML family of languages, which derive from the Classic ML language designed by Robin Milner in 1975 for the LCF (Logic of Computable Functions) theorem prover.\n",authors:{hd:"Jason Hickey",tl:0},language:"english",published:"2008",cover:void 0,isbn:void 0,links:{hd:{description:"PDF",uri:"https://courses.cms.caltech.edu/cs134/cs134b/book.pdf"},tl:0},body_md:"This book is notoriously much more than just an introduction to OCaml,\nit describes most of the language, and is accessible.\n\nAbstract: *This book is an introduction to ML programming, specifically for the OCaml programming language from INRIA. OCaml is a dialect of the ML family of languages, which derive from the Classic ML language designed by Robin Milner in 1975 for the LCF (Logic of Computable Functions) theorem prover.*\n\n[PDF](https://courses.cms.caltech.edu/cs134/cs134b/book.pdf)",body_html:'<p>This book is notoriously much more than just an introduction to OCaml,\nit describes most of the language, and is accessible.</p>\n<p>Abstract: <em>This book is an introduction to ML programming, specifically for the OCaml programming language from INRIA. OCaml is a dialect of the ML family of languages, which derive from the Classic ML language designed by Robin Milner in 1975 for the LCF (Logic of Computable Functions) theorem prover.</em></p>\n<p><a href="https://courses.cms.caltech.edu/cs134/cs134b/book.pdf">PDF</a></p>\n'},tl:{hd:{title:"Introduzione alla programmazione funzionale",slug:"introduzione-alla-programmazione-funzionale",description:"Functional programming introduction with OCaml\n",authors:{hd:"Carla Limongelli",tl:{hd:"Marta Cialdea",tl:0}},language:"italian",published:"2002",cover:"/books/limongelli-cialdea.gif",isbn:"88-7488-031-6",links:0,body_md:"",body_html:""},tl:{hd:{title:"Le Langage Caml",slug:"le-langage-caml",description:"This book is a comprehensive introduction to programming in OCaml. Usable as a programming course, it introduces progressively the language features and shows them at work on the fundamental programming problems. In addition to many introductory code samples, this book details the design and implementation of six complete, realistic programs in reputedly difficult application areas: compilation, type inference, automata, etc.\n",authors:{hd:"Xavier Leroy",tl:{hd:"Pierre Weis",tl:0}},language:"french",published:"1993",cover:"/books/le-language-caml-cover.jpg",isbn:"2-10-004383-8",links:{hd:{description:"PDF",uri:"https://caml.inria.fr/pub/distrib/books/llc.pdf"},tl:0},body_md:"This book is a comprehensive introduction to programming in OCaml.\nUsable as a programming course, it introduces progressively the language\nfeatures and shows them at work on the fundamental programming problems.\nIn addition to many introductory code samples, this book details the\ndesign and implementation of six complete, realistic programs in\nreputedly difficult application areas: compilation, type inference,\nautomata, etc.",body_html:"<p>This book is a comprehensive introduction to programming in OCaml.\nUsable as a programming course, it introduces progressively the language\nfeatures and shows them at work on the fundamental programming problems.\nIn addition to many introductory code samples, this book details the\ndesign and implementation of six complete, realistic programs in\nreputedly difficult application areas: compilation, type inference,\nautomata, etc.</p>\n"},tl:{hd:{title:"Manuel de r\xe9f\xe9rence du langage Caml",slug:"manuel-de-rfrence-du-langage-caml",description:'"Cet ouvrage contient le manuel de r\xe9f\xe9rence du langage Caml et la documentation compl\xe8te du syst\xe8me Caml Light, un environnement de programmation en Caml distribu\xe9e gratuitement. Il s\u2019adresse \xe1 des programmeurs Caml exp\xe9riment\xe9s, et non pas aux d\'\xe9butants. Il vient en compl\xe9ment du livre Le langage Caml, des m\xeames auteurs chez le m\xeame \xe9diteur, qui fournit une introduction progressive au langage Caml et \xe1 l\u2019\xe9criture de programmes dans ce langage."\n',authors:{hd:"Xavier Leroy",tl:{hd:"Pierre Weis",tl:0}},language:"french",published:"1993",cover:"/books/manuel-de-reference-du-langage-caml-cover.jpg",isbn:"2-7296-0492-8",links:{hd:{description:"PDF",uri:"https://caml.inria.fr/pub/distrib/books/manuel-cl.pdf"},tl:0},body_md:'Written by two of the implementors of the Caml Light compiler, this\ncomprehensive book describes all constructs of the programming language\nand provides a complete documentation for the Caml Light system.\n\nIntro:  "Cet ouvrage contient le manuel de r\xe9f\xe9rence du langage Caml et la documentation compl\xe8te du syst\xe8me Caml Light, un environnement de programmation en Caml distribu\xe9e gratuitement. Il s\u2019adresse \xe1 des programmeurs Caml exp\xe9riment\xe9s, et non pas aux d\'\xe9butants. Il vient en compl\xe9ment du livre Le langage Caml, des m\xeames auteurs chez le m\xeame \xe9diteur, qui fournit une introduction progressive au langage Caml et \xe1 l\u2019\xe9criture de programmes dans ce langage."',body_html:"<p>Written by two of the implementors of the Caml Light compiler, this\ncomprehensive book describes all constructs of the programming language\nand provides a complete documentation for the Caml Light system.</p>\n<p>Intro:  &quot;Cet ouvrage contient le manuel de r\xe9f\xe9rence du langage Caml et la documentation compl\xe8te du syst\xe8me Caml Light, un environnement de programmation en Caml distribu\xe9e gratuitement. Il s\u2019adresse \xe1 des programmeurs Caml exp\xe9riment\xe9s, et non pas aux d'\xe9butants. Il vient en compl\xe9ment du livre Le langage Caml, des m\xeames auteurs chez le m\xeame \xe9diteur, qui fournit une introduction progressive au langage Caml et \xe1 l\u2019\xe9criture de programmes dans ce langage.&quot;</p>\n"},tl:{hd:{title:"More OCaml: Algorithms, Methods & Diversions",slug:"more-ocaml-algorithms-methods--diversions",description:'In "More OCaml" John Whitington takes a meandering tour of functional programming with OCaml, introducing various language features and describing some classic algorithms.\n',authors:{hd:"John Whitington",tl:0},language:"english",published:"2014-08-26",cover:"/books/more-ocaml-300-376.png",isbn:void 0,links:{hd:{description:"Book Website",uri:"https://ocaml-book.com/more-ocaml-algorithms-methods-diversions/"},tl:{hd:{description:"Amazon",uri:"https://www.amazon.com/gp/product/0957671113"},tl:0}},body_md:'In "More OCaml" John Whitington takes a meandering tour of functional\nprogramming with OCaml, introducing various language features and describing\nsome classic algorithms. The book ends with a large worked example dealing with\nthe production of PDF files. There are questions for each chapter together with\nworked answers and hints.\n\n"More OCaml" will appeal both to existing OCaml programmers who wish to brush up\ntheir skills, and to experienced programmers eager to explore functional\nlanguages such as OCaml. It is hoped that each reader will find something new,\nor see an old thing in a new light. For the more casual reader, or those who are\nused to a different functional language, a summary of basic OCaml is provided at\nthe front of the book.',body_html:"<p>In &quot;More OCaml&quot; John Whitington takes a meandering tour of functional\nprogramming with OCaml, introducing various language features and describing\nsome classic algorithms. The book ends with a large worked example dealing with\nthe production of PDF files. There are questions for each chapter together with\nworked answers and hints.</p>\n<p>&quot;More OCaml&quot; will appeal both to existing OCaml programmers who wish to brush up\ntheir skills, and to experienced programmers eager to explore functional\nlanguages such as OCaml. It is hoped that each reader will find something new,\nor see an old thing in a new light. For the more casual reader, or those who are\nused to a different functional language, a summary of basic OCaml is provided at\nthe front of the book.</p>\n"},tl:{hd:{title:"Nouveaux exercices d'algorithmique",slug:"nouveaux-exercices-dalgorithmique",description:"This book presents 103 exercises and 5 problems about algorithms, for masters students. It attempts to address both practical and theoretical questions. Programs are written in OCaml and expressed in a purely functional style.\n",authors:{hd:"Michel Quercia",tl:0},language:"french",published:"2000",cover:"/books/quercia.gif",isbn:"2-7117-8990",links:{hd:{description:"Order at Amazon.fr",uri:"https://www.amazon.fr/exec/obidos/ASIN/3540673873"},tl:0},body_md:"This book presents 103 exercises and 5 problems about algorithms, for\nmasters students. It attempts to address both practical and theoretical\nquestions. Programs are written in OCaml and expressed in a purely\nfunctional style. Problem areas include programming methodology, lists,\nformula evaluation, Boolean logic, algorithmic complexity, trees,\nlanguages, and automata.",body_html:"<p>This book presents 103 exercises and 5 problems about algorithms, for\nmasters students. It attempts to address both practical and theoretical\nquestions. Programs are written in OCaml and expressed in a purely\nfunctional style. Problem areas include programming methodology, lists,\nformula evaluation, Boolean logic, algorithmic complexity, trees,\nlanguages, and automata.</p>\n"},tl:{hd:{title:"OCaml Book",slug:"ocaml-book",description:"Introductory programming textbook based on the OCaml language\n",authors:{hd:"Hongbo Zhang",tl:0},language:"english",published:"2011",cover:void 0,isbn:void 0,links:{hd:{description:"GitHub",uri:"https://github.com/bobzhang/ocaml-book"},tl:0},body_md:"This book is a work in progress. It currently includes sections on the\ncore OCaml language, Camlp4, parsing, various libraries, the OCaml\nruntime, interoperating with C, and pearls.",body_html:"<p>This book is a work in progress. It currently includes sections on the\ncore OCaml language, Camlp4, parsing, various libraries, the OCaml\nruntime, interoperating with C, and pearls.</p>\n"},tl:{hd:{title:"OCaml for Scientists",slug:"ocaml-for-scientists",description:"This book teaches OCaml programming with special emphasis on scientific applications.\n",authors:{hd:"Jon D. Harrop",tl:0},language:"english",published:"2005",cover:"/books/harrop-book.gif",isbn:void 0,links:{hd:{description:"Book Website",uri:"https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html"},tl:{hd:{description:"Ordering Information",uri:"https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html"},tl:0}},body_md:"This book teaches OCaml programming with special emphasis on scientific\napplications. Many examples are given, covering everything from simple\nnumerical analysis to sophisticated real-time 3D visualisation using\nOpenGL. This book contains over 800 color syntax-highlighted source code\nexamples and dozens of diagrams that elucidate the power of functional\nprogramming to explain how lightning-fast and yet remarkably-simple\nprograms can be constructed in the OCaml programming language.",body_html:"<p>This book teaches OCaml programming with special emphasis on scientific\napplications. Many examples are given, covering everything from simple\nnumerical analysis to sophisticated real-time 3D visualisation using\nOpenGL. This book contains over 800 color syntax-highlighted source code\nexamples and dozens of diagrams that elucidate the power of functional\nprogramming to explain how lightning-fast and yet remarkably-simple\nprograms can be constructed in the OCaml programming language.</p>\n"},tl:{hd:{title:"OCaml from the very Beginning",slug:"ocaml-from-the-very-beginning",description:'In "OCaml from the Very Beginning" John Whitington takes a no-prerequisites approach to teaching a modern general-purpose programming language.\n',authors:{hd:"John Whitington",tl:0},language:"english",published:"2013-06-07",cover:"/books/OCaml_from_beginning.png",isbn:void 0,links:{hd:{description:"Book Website",uri:"https://ocaml-book.com/"},tl:{hd:{description:"Amazon",uri:"https://www.amazon.com/gp/product/0957671105"},tl:0}},body_md:'In "OCaml from the Very Beginning" John Whitington takes a\nno-prerequisites approach to teaching a modern general-purpose\nprogramming language. Each small, self-contained chapter introduces a\nnew topic, building until the reader can write quite substantial\nprograms. There are plenty of questions and, crucially, worked answers\nand hints.\n\n"OCaml from the Very Beginning" will appeal both to new programmers, and experienced programmers eager to explore functional languages such as OCaml. It is suitable both for formal use within an undergraduate or graduate curriculum, and for the interested amateur.',body_html:"<p>In &quot;OCaml from the Very Beginning&quot; John Whitington takes a\nno-prerequisites approach to teaching a modern general-purpose\nprogramming language. Each small, self-contained chapter introduces a\nnew topic, building until the reader can write quite substantial\nprograms. There are plenty of questions and, crucially, worked answers\nand hints.</p>\n<p>&quot;OCaml from the Very Beginning&quot; will appeal both to new programmers, and experienced programmers eager to explore functional languages such as OCaml. It is suitable both for formal use within an undergraduate or graduate curriculum, and for the interested amateur.</p>\n"},tl:{hd:{title:"OCaml: Programa\xe7\xe3o Funcional na Pr\xe1tica",slug:"ocaml-programao-funcional-na-prtica",description:"This book is an introduction to functional programming through OCaml, with a pragmatic focus. The goal is to enable the reader to write real programs in OCaml and understand most of the open source code written in the language.\n",authors:{hd:"Andrei de Ara\xfajo Formiga",tl:0},language:"portugese",published:"2015",cover:"/books/opfp.png",isbn:void 0,links:{hd:{description:"Book site",uri:"https://andreiformiga.com/livro/ocaml/"},tl:{hd:{description:"Order online from Casa do C\xf3digo",uri:"https://www.casadocodigo.com.br/products/livro-ocaml"},tl:0}},body_md:"This book is an introduction to functional programming through OCaml, with a pragmatic\nfocus. The goal is to enable the reader to write real programs in OCaml and understand\nmost of the open source code written in the language. It includes many code examples\nillustrating the topics and a few larger projects written in OCaml that showcase the\nintegration of many language features. These larger\nprograms include a set of interpreter, compiler and stack machine for a simple\nlanguage, and a decision tree learning program for data analysis.",body_html:"<p>This book is an introduction to functional programming through OCaml, with a pragmatic\nfocus. The goal is to enable the reader to write real programs in OCaml and understand\nmost of the open source code written in the language. It includes many code examples\nillustrating the topics and a few larger projects written in OCaml that showcase the\nintegration of many language features. These larger\nprograms include a set of interpreter, compiler and stack machine for a simple\nlanguage, and a decision tree learning program for data analysis.</p>\n"},tl:{hd:{title:"The OCaml System: Documentation and User's Manual",slug:"the-ocaml-system-documentation-and-users-manual",description:"The official User's Manual for OCaml serving as a complete reference guide",authors:{hd:"Damien Doligez",tl:{hd:"Alain Frisch",tl:{hd:"Jacques Garrigue",tl:{hd:"Didier R\xe9my",tl:{hd:"J\xe9r\xf4me Vouillon",tl:0}}}}},language:"english",published:void 0,cover:"/books/colour-icon-170x148.png",isbn:void 0,links:{hd:{description:"Online",uri:"https://ocaml.org/releases/latest/manual.html"},tl:0},body_md:"This the official User's Manual. It serves as a complete reference guide\nto OCaml. Updated for each version of OCaml, it contains the description\nof the language, of its extensions, and the documentation of the tools\nand libraries included in the official distribution.",body_html:"<p>This the official User's Manual. It serves as a complete reference guide\nto OCaml. Updated for each version of OCaml, it contains the description\nof the language, of its extensions, and the documentation of the tools\nand libraries included in the official distribution.</p>\n"},tl:{hd:{title:"Option Informatique MP/MP",slug:"option-informatique-mpmp",description:"This books is a follow-up to the previous one and is intended for second year students in \u201cclasses pr\xe9paratoires\u201d. It deals with trees, algebraic expressions, automata and languages, and OCaml streams. The book contains more than 200 OCaml programs.\n",authors:{hd:"Denis Monasse",tl:0},language:"french",published:"1997",cover:"/books/monasse-2.jpg",isbn:"2-7117-8839-3",links:{hd:{description:"Order at Amazon.fr",uri:"https://www.amazon.fr/exec/obidos/ASIN/2711788393"},tl:0},body_md:"This books is a follow-up to the previous one and is intended for second\nyear students in \u201cclasses pr\xe9paratoires\u201d. It deals with trees, algebraic\nexpressions, automata and languages, and OCaml streams. The book\ncontains more than 200 OCaml programs.",body_html:"<p>This books is a follow-up to the previous one and is intended for second\nyear students in \u201cclasses pr\xe9paratoires\u201d. It deals with trees, algebraic\nexpressions, automata and languages, and OCaml streams. The book\ncontains more than 200 OCaml programs.</p>\n"},tl:{hd:{title:"Option Informatique MPSI",slug:"option-informatique-mpsi",description:"This is a computer science course for the first year of \u201cclasses pr\xe9paratoires\u201d. The course begins with an introductory lesson on algorithms and a description of the OCaml language.\n",authors:{hd:"Denis Monasse",tl:0},language:"french",published:"1996",cover:"/books/monasse-1.gif",isbn:"2-7117-8831-8",links:0,body_md:"This is a computer science course for the first year of \u201cclasses\npr\xe9paratoires\u201d. The course begins with an introductory lesson on\nalgorithms and a description of the OCaml language. Then, several\nfundamental algorithms are described and illustrated using OCaml\nprograms. The book adopts a mathematical approach: descriptions of\nmathematical objects are related to data structures in the programming\nlanguage. This book is suitable for students with some mathematical\nbackground, and for everyone who wants to learn the bases of computer\nscience.",body_html:"<p>This is a computer science course for the first year of \u201cclasses\npr\xe9paratoires\u201d. The course begins with an introductory lesson on\nalgorithms and a description of the OCaml language. Then, several\nfundamental algorithms are described and illustrated using OCaml\nprograms. The book adopts a mathematical approach: descriptions of\nmathematical objects are related to data structures in the programming\nlanguage. This book is suitable for students with some mathematical\nbackground, and for everyone who wants to learn the bases of computer\nscience.</p>\n"},tl:{hd:{title:"Programmation de droite \xe0 gauche et vice-versa",slug:"programmation-de-droite--gauche-et-vice-versa",description:"Programming with OCaml\n",authors:{hd:"Pascal Manoury",tl:0},language:"french",published:"2005",cover:"/books/manoury.png",isbn:"978-2-916466-05-7",links:{hd:{description:"Order Online from Paracamplus",uri:"https://paracamplus.com"},tl:0},body_md:"",body_html:""},tl:{hd:{title:"Programmation en Caml",slug:"programmation-en-caml",description:"This book is intended for beginners, who will learn basic programming notions. The first part of the book is a programming course that initiates the reader to the OCaml language.\n",authors:{hd:"Jacques Rouabl\xe9",tl:0},language:"french",published:"1997",cover:"/books/rouable.jpg",isbn:"2-212-08944-9",links:{hd:{description:"Order at Amazon.fr",uri:"https://www.amazon.fr/exec/obidos/ASIN/2212089449"},tl:0},body_md:"This book is intended for beginners, who will learn basic programming\nnotions. The first part of the book is a programming course that\ninitiates the reader to the OCaml language. Important notions are\npresented from a practical point of view, and the implementation of some\nof these is analyzed and sketched. The second part, the \u201cOCaml\nworkshop\u201d, is a practical application of these notions to other domains\nconnected to computer science, logic, automata and grammars.",body_html:"<p>This book is intended for beginners, who will learn basic programming\nnotions. The first part of the book is a programming course that\ninitiates the reader to the OCaml language. Important notions are\npresented from a practical point of view, and the implementation of some\nof these is analyzed and sketched. The second part, the \u201cOCaml\nworkshop\u201d, is a practical application of these notions to other domains\nconnected to computer science, logic, automata and grammars.</p>\n"},tl:{hd:{title:"Programmation fonctionnelle, g\xe9n\xe9rique et objet: une introduction avec le langage OCaml",slug:"programmation-fonctionnelle-gnrique-et-objet-une-introduction-avec-le-langage-ocaml",description:"Programming with OCaml\n",authors:{hd:"Philippe Narbel",tl:0},language:"french",published:"2005",cover:"/books/narbel.jpg",isbn:"2-7117-4843-X",links:0,body_md:"",body_html:""},tl:{hd:{title:"Programmazione funzionale, una semplice introduzione",slug:"programmazione-funzionale-una-semplice-introduzione",description:"Functional programming introduction with OCaml\n",authors:{hd:"Massimo Maria Ghisalberti",tl:0},language:"italian",published:"2015",cover:void 0,isbn:void 0,links:{hd:{description:"Emacs Org source",uri:"https://minimalprocedure.pragmas.org/writings/programmazione_funzionale/programmazione_funzionale.org"},tl:{hd:{description:"HTML",uri:"https://minimalprocedure.pragmas.org/writings/programmazione_funzionale/programmazione_funzionale.html"},tl:{hd:{description:"PDF",uri:"https://minimalprocedure.pragmas.org/writings/programmazione_funzionale/programmazione_funzionale.pdf"},tl:0}}},body_md:"",body_html:""},tl:{hd:{title:"Real World OCaml",slug:"real-world-ocaml",description:"Learn how to solve day-to-day problems in data processing, numerical computation, system scripting, and database-driven web applications with the OCaml multi-paradigm programming language.\n",authors:{hd:"Jason Hickey",tl:{hd:"Anil Madhavapeddy",tl:{hd:"Yaron Minsky",tl:0}}},language:"english",published:"2013-11-25",cover:"/books/real-world-ocaml.jpg",isbn:void 0,links:{hd:{description:"Book Website",uri:"https://dev.realworldocaml.org/"},tl:{hd:{description:"O'Reilly",uri:"https://shop.oreilly.com/product/0636920024743.do"},tl:{hd:{description:"Amazon",uri:"https://www.amazon.com/Real-World-OCaml-Functional-programming/dp/144932391X/ref=tmm_pap_title_0?ie=UTF8&qid=1385006524&sr=8-1"},tl:0}}},body_md:"Learn how to solve day-to-day problems in data processing, numerical\ncomputation, system scripting, and database-driven web applications with\nthe OCaml multi-paradigm programming language. This hands-on book shows\nyou how to take advantage of OCaml\u2019s functional, imperative, and\nobject-oriented programming styles with recipes for many real-world\ntasks.\n\nYou\u2019ll start with OCaml basics, including how to set up a development\nenvironment, and move toward more advanced topics such as the module\nsystem, foreign-function interface, macro language, and the OCaml tools.\nQuickly learn how to put OCaml to work for writing succinct and\nreadable code.",body_html:"<p>Learn how to solve day-to-day problems in data processing, numerical\ncomputation, system scripting, and database-driven web applications with\nthe OCaml multi-paradigm programming language. This hands-on book shows\nyou how to take advantage of OCaml\u2019s functional, imperative, and\nobject-oriented programming styles with recipes for many real-world\ntasks.</p>\n<p>You\u2019ll start with OCaml basics, including how to set up a development\nenvironment, and move toward more advanced topics such as the module\nsystem, foreign-function interface, macro language, and the OCaml tools.\nQuickly learn how to put OCaml to work for writing succinct and\nreadable code.</p>\n"},tl:{hd:{title:"Seize probl\xe8mes d'informatique",slug:"seize-problmes-dinformatique",description:"This book offers sixteen problems in computer science, with detailed answers to all questions and complete solutions to algorithmic problems given as OCaml programs.\n",authors:{hd:"Bruno Petazzoni",tl:0},language:"french",published:"2001",cover:"/books/petazzoni.jpg",isbn:"3-540-67387-3",links:{hd:{description:"Springer's Catalog Page",uri:"https://www.springeronline.com/sgw/cda/frontpage/0,10735,5-102-22-2042496-0,00.html"},tl:0},body_md:"This book offers sixteen problems in computer science, with detailed\nanswers to all questions and complete solutions to algorithmic problems\ngiven as OCaml programs. It deals mainly with automata, finite or\ninfinite words, formal language theory, and some classical algorithms\nsuch as bin-packing. It is intended for students who attend the optional\ncomputer science curriculum of the \u201cclasses pr\xe9paratoires MPSI/MP\u201d. It\nshould also be useful to all teachers and computer science students up\nto a masters degree.",body_html:"<p>This book offers sixteen problems in computer science, with detailed\nanswers to all questions and complete solutions to algorithmic problems\ngiven as OCaml programs. It deals mainly with automata, finite or\ninfinite words, formal language theory, and some classical algorithms\nsuch as bin-packing. It is intended for students who attend the optional\ncomputer science curriculum of the \u201cclasses pr\xe9paratoires MPSI/MP\u201d. It\nshould also be useful to all teachers and computer science students up\nto a masters degree.</p>\n"},tl:{hd:{title:"The Functional Approach to OCaml",slug:"the-functional-approach-to-ocaml",description:"Learning about functional programming using OCaml\n",authors:{hd:"Guy Cousineau",tl:0},language:"english",published:"1998",cover:"/books/cousineau-mauny-en.gif",isbn:"0-521-57681-4",links:{hd:{description:"Book Website",uri:"https://pauillac.inria.fr/cousineau-mauny/main.html"},tl:{hd:{description:"Order at Amazon.com",uri:"https://www.amazon.com/exec/obidos/ASIN/0521571839/qid%3D911812711/sr%3D1-22/102-8668961-8838559"},tl:0}},body_md:"This book uses OCaml as a tool to introduce several important\nprogramming concepts. It is divided in three parts. The first part is an\nintroduction to OCaml, which presents the language itself, but also\nintroduces evaluation by rewriting, evaluation strategies and proofs of\nprograms by induction. The second part is dedicated to the description\nof application programs which belong to various fields and might\ninterest various types of readers or students. Finally, the third part\nis dedicated to implementation. It describes interpretation and\ncompilation, with brief descriptions of memory management and type\nsynthesis.",body_html:"<p>This book uses OCaml as a tool to introduce several important\nprogramming concepts. It is divided in three parts. The first part is an\nintroduction to OCaml, which presents the language itself, but also\nintroduces evaluation by rewriting, evaluation strategies and proofs of\nprograms by induction. The second part is dedicated to the description\nof application programs which belong to various fields and might\ninterest various types of readers or students. Finally, the third part\nis dedicated to implementation. It describes interpretation and\ncompilation, with brief descriptions of memory management and type\nsynthesis.</p>\n"},tl:{hd:{title:"Think OCaml: How to think like a Functional Programmer",slug:"think-ocaml-how-to-think-like-a-functional-programmer",description:"Introductory programming textbook based on the OCaml language\n",authors:{hd:"Nicholas Monje",tl:{hd:"Allen Downey",tl:0}},language:"english",published:"2008",cover:"/books/thinkocaml_cover_web.png",isbn:void 0,links:{hd:{description:"Book Website",uri:"https://greenteapress.com/thinkocaml/index.html"},tl:{hd:{description:"PDF",uri:"https://greenteapress.com/thinkocaml/thinkocaml.pdf"},tl:0}},body_md:"This book is a work in progress. It is an introductory programming\ntextbook based on the OCaml language. It is a modified version of\nThink Python by Allen Downey. It is intended for newcomers to\nprogramming and also those who know some programming but want to learn\nprogramming in the function-oriented paradigm, or those who simply\nwant to learn OCaml.",body_html:"<p>This book is a work in progress. It is an introductory programming\ntextbook based on the OCaml language. It is a modified version of\nThink Python by Allen Downey. It is intended for newcomers to\nprogramming and also those who know some programming but want to learn\nprogramming in the function-oriented paradigm, or those who simply\nwant to learn OCaml.</p>\n"},tl:{hd:{title:"Unix System Programming in OCaml",slug:"unix-system-programming-in-ocaml",description:"Learn Unix system programming in OCaml\n",authors:{hd:"Xavier Leroy",tl:{hd:"Didier R\xe9my",tl:0}},language:"english",published:"2010-05-01",cover:void 0,isbn:void 0,links:{hd:{description:"Online",uri:"https://ocaml.github.io/ocamlunix"},tl:0},body_md:"This is an excellent book on Unix system programming, with an emphasis\non communications between processes. The main novelty of this work is\nthe use of OCaml, instead of the C language that is customary in systems\nprogramming. This gives an unusual perspective on systems programming\nand on OCaml. It is assumed that the reader is familiar with OCaml and\nUnix shell commands.",body_html:"<p>This is an excellent book on Unix system programming, with an emphasis\non communications between processes. The main novelty of this work is\nthe use of OCaml, instead of the C language that is customary in systems\nprogramming. This gives an unusual perspective on systems programming\nand on OCaml. It is assumed that the reader is familiar with OCaml and\nUnix shell commands.</p>\n"},tl:{hd:{title:"Using, Understanding and Unraveling OCaml",slug:"using-understanding-and-unraveling-ocaml",description:"This book describes both the OCaml language and the theoretical grounds behind its powerful type system.\n",authors:{hd:"Didier R\xe9my",tl:0},language:"english",published:"2002-09-20",cover:void 0,isbn:void 0,links:{hd:{description:"Online",uri:"https://caml.inria.fr/pub/docs/u3-ocaml/"},tl:{hd:{description:"PDF",uri:"https://caml.inria.fr/pub/docs/u3-ocaml/ocaml.pdf"},tl:0}},body_md:"This book describes both the OCaml language and the theoretical grounds\nbehind its powerful type system. A good complement to other books on\nOCaml it is addressed to a wide audience of people interested in modern programming languages in general, ML-like languages in particular, or simply in OCaml, whether they are programmers or language designers, beginners or knowledgeable readers \u2014 little prerequisite is actually assumed.",body_html:"<p>This book describes both the OCaml language and the theoretical grounds\nbehind its powerful type system. A good complement to other books on\nOCaml it is addressed to a wide audience of people interested in modern programming languages in general, ML-like languages in particular, or simply in OCaml, whether they are programmers or language designers, beginners or knowledgeable readers \u2014 little prerequisite is actually assumed.</p>\n"},tl:0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},r={hd:{title:"Building Ahrefs codebase with Melange",slug:"building-ahrefs-codebase-with-melange",description:"What we learnt after experimenting with Melange, a fork of ReScript with a strong focus on keeping compatibility with OCaml.",url:"https://tech.ahrefs.com/building-ahrefs-codebase-with-melange-9f881f6d022b?source=rss----303662d88bae--ocaml",date:"2021-05-18T15:24:20-00:00",preview_image:"https://miro.medium.com/max/1200/1*tYLUO4FDmJ6bzlsPp14LdQ.jpeg",body_html:'<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*tYLUO4FDmJ6bzlsPp14LdQ.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@madebyjens?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Jens Lelie</a> on\xa0<a href="https://unsplash.com/s/photos/fork-road?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>At Ahrefs, we have been using BuckleScript and ReasonML in production <a href="https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b">for more than two years</a>. We already have a codebase of tens of thousands of lines of code, with several web applications that are data intensive and communicate with backend services written in <a href="http://ocaml.org/">OCaml</a>, using tools like\xa0<a href="https://github.com/ahrefs/atd">atd</a>.</p><p>Given our investment in these technologies, we have been following closely the recent changes in <a href="https://rescript-lang.org/">ReScript</a>, with its rebrand and renaming, and the split with the ReasonML project, explained in the project <a href="https://rescript-lang.org/blog/bucklescript-is-rebranding">blog\xa0post</a>.</p><h3>ReScript: becoming its own\xa0language</h3><p>We are excited about the way ReScript is unifying the experience and making it easier for developers who are getting started to find documentation in a single place, as well as continuing its strong focus on performance and readable JavaScript output.</p><p>On the other hand, we are trying to figure out the implications of this change in the mid- and long-term, especially regarding the integration with the OCaml ecosystem. And more importantly, what this evolution will mean for production users like us who rely on this integration.</p><p>ReScript integration with OCaml has historically been seamless, as BuckleScript started originally as a <a href="https://www.reddit.com/r/ocaml/comments/4enok3/bloombergbucklescript_a_back_end_for_the_ocaml/">new backend for the OCaml compiler</a>. However, in recent months, there have been several hints that ReScript wants to evolve towards becoming its own language:</p><ul><li>It has now <a href="https://github.com/rescript-lang/syntax">its own parser</a>, incompatible with OCaml native applications</li><li>Official repository guidelines for technical writing mentions explicitly that <a href="https://github.com/rescript-association/rescript-lang.org/blob/master/CONTRIBUTING.md#technical-writing-documentation">no reference to OCaml</a> should appear in\xa0docs</li><li>Upgrades to the latest version of OCaml compiler, which <a href="https://web.archive.org/web/20210208054855if_/https://github.com/rescript-lang/rescript-compiler/wiki">used to be part of the roadmap</a>, have been <a href="https://forum.rescript-lang.org/t/some-thoughts-on-community-building/1474">deprioritized</a> recently.</li></ul><p>So, even if officially ReScript has not announced that they will break backwards compatibility with OCaml, just the fact that it is sticking with an old version of the OCaml compiler poses some challenges for us in terms of tooling. The uncertainty about the future and the pace of changes add some risk to the high-level goals we have for our teams and codebase: we would like to share <em>more</em> code between frontend and backend, not\xa0less.</p><h3>Melange: a fork of ReScript, focused on OCaml compatibility</h3><p>When Ant\xf3nio Monteiro <a href="https://anmonteiro.com/2021/03/on-ocaml-and-the-js-platform/">announced Melange</a>, a fork of ReScript but with a strong focus on keeping compatibility with OCaml, we decided to try it out and see how it could work for\xa0us.</p><p>Ultimately, the experiment was successful. We managed to build all our frontend applications with Melange, while keeping the existing bundling setup, which currently uses\xa0Webpack.</p><p>Throughout this process, we had to modify some parts of the code. We will now go through the most relevant parts of the\xa0process:</p><ul><li>Upgrade to OCaml 4.12: the most relevant part was the deprecation of Pervasives module to use\xa0Stdlib.</li><li>Use ppxlib in our ppxs: we had to upgrade the two ppxs that we use in the frontend codebase to the latest compiler version, <a href="https://github.com/ahrefs/bs-emotion/compare/master...jchavarri:ocaml4.12-ppxlib">bs-emotion-ppx</a> and an in-house <a href="https://github.com/ahrefs/bs-react-intl-ppx">ppx for internationalization</a>.</li><li>Configure esy: we were already using esy to bring the editor tooling into scope of the developer environment, so we just had to make sure melange would also be included in the json configuration.</li><li>Upgrade to Reason 3.7.0: a quite simple change too, as the whole process is automated by using refmt. As a side note, we ran into <a href="https://github.com/reasonml/reason/issues/2636">a small bug</a> with some type annotations, that we were able to work\xa0around.</li><li>\u201cLift\u201d dune workspace to the root of our monorepo: this is probably the most intrusive change. Because we have shared code between backend and frontend, and Dune needs to have access to all sources under its workspace, we had to \u201clift\u201d the Dune workspace from the backend directory to the root of monorepo.</li></ul><h3>The good</h3><p>This experiment allowed us to experience what a project like Melange could offer for our use case. Here are some of the things we might be able to leverage in a codebase built with\xa0Melange:</p><ul><li>Recent version of the OCaml compiler: at some point, we could pin compiler version between backend and frontend teams, making upgrades more straightforward as they would happen atomically.</li><li>Shared editor tooling: the official OCaml <a href="https://github.com/ocamllabs/vscode-ocaml-platform">vscode extension</a> works great with Melange, as well as any other OCaml editor integration. Having backend and frontend teams use similar editor setup removes a lot of maintenance work for\xa0us.</li><li>Consuming ppxs from source: Melange allows to consume ppxs from source, which also removes issues with pre-compiled ppxs (like this issue with the recent <a href="https://github.com/ahrefs/bs-emotion/issues/53">M1\xa0Macs</a>).</li><li>Melange allows to run all ppxs <a href="https://github.com/melange-re/melange/pull/171">from a single executable file</a>, which has some nice performance benefits.</li><li>Use Dune for atd files generators: ReScript \u201cgenerators\u201d are unfortunately <a href="https://web.archive.org/web/20200710044513if_/https://reasonml.org/docs/reason-compiler/latest/build-advanced">not documented anymore</a>, but we use them extensively for atd file generation. Being able to share Dune rules in backend and frontend would make our build setup\xa0easier.</li><li>Access to OCaml documentation tooling: Melange allows to leverage existing tooling for generating documentation, like\xa0<a href="https://github.com/ocaml/odoc/">odoc</a>.</li><li>Async syntax: the latest Reason version <a href="https://github.com/reasonml/reason/pull/2487">supports \u201clet op\u201d syntax</a>, which is handy for client-side code.</li></ul><h3>The bad</h3><p>While there are many things that are exciting about Melange, there are some other parts that can be improved.</p><ul><li>Build performance: We already knew that performance would be far worse than ReScript, as Melange uses Dune in a way that it was not designed for. In our tests, builds with Melange are roughly 1 order of magnitude slower than ReScript\xa0ones.</li><li>First-class Dune support: if there was a deeper integration between Dune and Melange, we could explore features like shared libraries or shared rules between backend and frontend. As of today, Dune has no knowledge about Melange environment, so it can perform basic rules execution, but there is no access to high level stanzas like library in\xa0Melange.</li><li>Two-headed goal: finally, we see a more strategic risk in Melange proposition. Right now it has two goals: keep compatibility with both ReScript and OCaml. But we don\u2019t know how long these goals will be feasible. If at some point ReScript decides to move away from the OCaml compiler fully, then Melange users would not be able to consume any updates to the ReScript ecosystem anymore.</li></ul><h3>Alright, but are you migrating to Melange or ReScript?</h3><p>With all the information available, the answer is: we don\u2019t know yet. \ud83d\ude04 We want to keep exploring all the available options and have as much information as possible before committing further. So for now, we are upgrading the codebase to recent versions of ReScript, but we are holding up on features that only work one way. For example, we have not migrated our codebase to the ReScript syntax yet, as <a href="https://github.com/rescript-lang/syntax/issues/405">there is no way to translate back to Reason\xa0syntax</a>.</p><p>In the meantime, we will keep exploring how far the limitations of Melange can be mitigated. To be continued! \ud83d\ude80</p><p><em>Thanks to Igor and Feihong for reviewing and improving earlier versions of this\xa0post.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9f881f6d022b" width="1" height="1" alt=""><hr><p><a href="https://tech.ahrefs.com/building-ahrefs-codebase-with-melange-9f881f6d022b">Building Ahrefs codebase with Melange</a> was originally published in <a href="https://tech.ahrefs.com">ahrefs</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>'},tl:{hd:{title:"Getting started with atdgen and bucklescript",slug:"getting-started-with-atdgen-and-bucklescript",description:"atdgen is a project to create types and data structures that can be serialized to JSON. It is very convenient when communicating between\u2026",url:"https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081?source=rss----303662d88bae--ocaml",date:"2018-09-12T02:53:58-00:00",preview_image:void 0,body_html:'<p><a href="https://github.com/mjambon/atd">atdgen</a> is a project to create types and data structures that can be serialized to JSON. It is very convenient when communicating between multiple processes, creating a REST API or consuming JSON objects from other tools. It can be compared to <a href="https://json-schema.org/">JSON schema</a> or <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a>, but with richer types and more features.</p><p>The idea is to write a list of types in a specification file, an\xa0.atd file. Then running atdgen, it is possible to generate OCaml or Java code to serialize/deserialize values of those types to/from corresponding json.</p><p>Until very recently, atdgen could generate code only for native OCaml. But <a href="https://github.com/mjambon/atd/pull/44">the support of bucklescript has been merged</a>! atdgen the cli tool is still a native OCaml binary. But it can output some OCaml code that can be compiled using <a href="https://bucklescript.github.io/">bucklescript</a>.</p><p>The work to implement this new feature of atdgen has been funded by <a href="https://ahrefs.com/">Ahrefs</a>. We highly appreciate open source tools. And as much as possible, we prefer to contribute to existing open source projects rather than to re-invent the wheel internally.</p><h3>Installation</h3><p>To install atdgen we first need to install <a href="https://opam.ocaml.org">opam</a> (OCaml package manager), as atdgen doesn\u2019t provide ready to use binaries and is only distributed as source package via opam. The procedure is simple and documented here: <a href="https://opam.ocaml.org/doc/2.0/Install.html">https://opam.ocaml.org/doc/2.0/Install.html</a></p><p>Then we need to initialize opam and create a switch. Any version of ocaml greater or equal to 4.03.0 should be\xa0fine.</p><pre>opam init -a<br>opam switch create . 4.07.1 -y</pre><p>Once it is done, we have to install the development version of atdgen. The support of bucklescript is not officially released.</p><pre>opam pin add atd --dev-repo   <br>opam pin add atdgen --dev-repo</pre><p>Make sure that atdgen is available.</p><pre>$ which atdgen                 <br>(current $PWD)/_opam/bin/atdgen</pre><p>Of course, we need bucklescript.</p><pre>yarn init                 <br>yarn add bs-platform --dev</pre><p>We also need the bucklescript runtime for atdgen, as it is not currently provided by atdgen itself. So we have written and open-sourced our version of the runtime\xa0: <a href="https://github.com/ahrefs/bs-atdgen-codec-runtime">https://github.com/ahrefs/bs-atdgen-codec-runtime</a>.</p><p>This runtime is responsible for the conversion between JSON values and OCaml values. The JSON values are based on the standard <a href="https://bucklescript.github.io/bucklescript/api/Js.Json.html#TYPEt">Js.Json.t type</a> provided by bucklescript to be sure that it is easy to interoperate with the rest of the ecosystem.</p><p>It is published on npm for easy integration in bucklescript projects.</p><pre>yarn add @ahrefs/bs-atdgen-codec-runtime</pre><h3>Project configuration</h3><p>After the previous section, package.json should be almost ready. We can add a few scripts to make it more convenient to compile the project. Here is how it should look once completed.</p><pre>{<br>  &quot;name&quot;: &quot;demo-bs-atdgen&quot;,<br>  &quot;version&quot;: &quot;0.0.1&quot;,<br>  &quot;description&quot;: &quot;demo of atdgen with bucklescript&quot;,<br>  &quot;scripts&quot;: {<br>    &quot;clean&quot;: &quot;bsb -clean-world&quot;,<br>    &quot;build&quot;: &quot;bsb -make-world&quot;,<br>    &quot;watch&quot;: &quot;bsb -make-world -w&quot;,<br>    &quot;atdgen&quot;: &quot;atdgen -t meetup.atd &amp;&amp; atdgen -bs meetup.atd&quot;<br>  },<br>  &quot;devDependencies&quot;: {<br>    &quot;bs-platform&quot;: &quot;^4.0.5&quot;<br>  },<br>  &quot;peerDependencies&quot;: {<br>    &quot;bs-platform&quot;: &quot;^4.0.5&quot;<br>  },<br>  &quot;dependencies&quot;: {<br>    &quot;<a href="http://twitter.com/ahrefs/bs-atdgen-codec-runtime">@ahrefs/bs-atdgen-codec-runtime</a>&quot;: &quot;^1.0.4&quot;<br>  }<br>}</pre><p>The bucklescript configuration is very simple. We use the basic configuration that can be found in any bucklescript project. Except that we need to add one dependency to bsconfig.json:</p><pre>{<br>  &quot;name&quot;: &quot;demo-bs-atdgen&quot;,<br>  &quot;version&quot;: &quot;0.0.1&quot;,<br>  &quot;sources&quot;: {<br>    &quot;dir&quot;: &quot;src&quot;,<br>    &quot;subdirs&quot;: true<br>  },<br>  &quot;package-specs&quot;: {<br>    &quot;module&quot;: &quot;commonjs&quot;,<br>    &quot;in-source&quot;: true<br>  },<br>  &quot;suffix&quot;: &quot;.bs.js&quot;,<br>  &quot;bs-dependencies&quot;: [<br>    &quot;<a href="http://twitter.com/ahrefs/bs-atdgen-codec-runtime">@ahrefs/bs-atdgen-codec-runtime</a>&quot;<br>  ],<br>  &quot;warnings&quot;: {<br>    &quot;error&quot;: &quot;+101&quot;<br>  },<br>  &quot;generate-merlin&quot;: true,<br>  &quot;namespace&quot;: true,<br>  &quot;refmt&quot;: 3<br>}</pre><h3>First ATD definitions</h3><p>It is time to create a first\xa0.atd file, containing our types. This part is also documented on <a href="https://atd.readthedocs.io/en/latest/tutorial.html#getting-started">https://atd.readthedocs.io/en/latest/tutorial.html#getting-started</a></p><p>For this example, I decided to go with a meetup event. Put the type definitions in src/meetup.atd.</p><pre>(* This is a comment. Same syntax as in ocaml. *)</pre><pre>type access = [ Private | Public ]</pre><pre>(* the date will be a float in the json and a Js.Date.t in ocaml *)<br>type date = float wrap &lt;ocaml module=&quot;Js.Date&quot; wrap=&quot;Js.Date.fromFloat&quot; unwrap=&quot;Js.Date.valueOf&quot;&gt;</pre><pre>(* Some people don&#39;t want to provide a phone number, make it optional *)<br>type person = {<br>  name: string;<br>  email: string;<br>  ?phone: string nullable;<br>}</pre><pre>type event = {<br>  access: access;<br>  name: string;<br>  host: person;<br>  date: date;<br>  guests: person list;<br>}</pre><pre>type events = event list</pre><p>We use the atdgen binary (compiled previously) to generate the ocaml types and the code to serialize/deserialize those\xa0types.</p><pre>atdgen -t meetup.atd # generates an ocaml file containing the types<br>atdgen -bs meetup.atd # generates the code to (de)serialize</pre><p>The generated files\xa0are:</p><ul><li>meetup_t.ml(i) which contain the ocaml types corresponding to our ATD definitions.</li><li>meetup_bs.ml(i) which contain the ocaml code to transform from and to json\xa0values.</li></ul><p>At this point we can compile our\xa0project.</p><pre>yarn build</pre><p>If everything worked properly, we now have two\xa0.bs.js files in the src directory.</p><pre>$ tree src<br>src<br>\u251c\u2500\u2500 meetup.atd<br>\u251c\u2500\u2500 meetup_bs.bs.js<br>\u251c\u2500\u2500 meetup_bs.ml<br>\u251c\u2500\u2500 meetup_bs.mli<br>\u251c\u2500\u2500 meetup_t.bs.js<br>\u251c\u2500\u2500 meetup_t.ml<br>\u2514\u2500\u2500 meetup_t.mli</pre><pre>0 directories, 7 files</pre><p>At this point, we can create new OCaml/Reason files in the src directory and use all the code atdgen generated for us. Two examples to illustrate that.</p><h3>Query a REST\xa0API</h3><p>A common usage of atdgen is to decode the JSON returned by a REST API. Here is a short example, using the reason syntax and bs-fetch.</p><pre>let get = (url, decode) =&gt;<br>  Js.Promise.(<br>    Fetch.fetchWithInit(<br>      url,<br>      Fetch.RequestInit.make(~method_=Get, ()),<br>    )<br>    |&gt; then_(Fetch.Response.json)<br>    |&gt; then_(json =&gt; json |&gt; decode |&gt; resolve)<br>  );</pre><pre>let v: Meetup_t.events =<br>  get(<br>    &quot;<a href="http://localhost:8000/events">http://localhost:8000/events</a>&quot;,<br>    Atdgen_codec_runtime.Decode.decode(Meetup_bs.read_events),<br>  );</pre><h3>Read and write a JSON\xa0file</h3><p>Atdgen for bucklescript doesn\u2019t take care of converting a string to a JSON object. Which allows us to use the performant json parser included in nodejs or the\xa0browser.</p><pre>let read_events filename =<br>  (* Read and parse the json file from disk, this doesn&#39;t involve atdgen. *)<br>  let json =<br>    Node_fs.readFileAsUtf8Sync filename<br>    |&gt; Js.Json.parseExn<br>  in<br>  (* Turn it into a proper record. The annotation is of course optional. *)<br>  let events: Meetup_t.events =<br>    Atdgen_codec_runtime.Decode.decode Meetup_bs.read_events json<br>  in<br>  events</pre><p>The reverse operation, converting a record to a JSON object and writing it in a file is also straightforward.</p><pre>let write_events filename events =<br>  Atdgen_codec_runtime.Encode.encode Meetup_bs.write_events events (* turn a list of records into json *)<br>  |. Js.Json.stringifyWithSpace 2   (* convert the json to a pretty string *)<br>  |&gt; Node_fs.writeFileAsUtf8Sync filename  (* write the json in our file *)</pre><h3>Full example</h3><p>Now that we have our functions to read and write events, we can build a small cli to pretty print the list of events and add new\xa0events.</p><p>The source code of the full example is available <a href="https://github.com/ahrefs/bs-atdgen-codec-runtime/tree/master/example">on\xa0github</a>.</p><p>You can run it like\xa0this:</p><pre>$ echo &quot;[]&quot; &gt; events.json<br>$ nodejs src/cli.bs.js add louis <a href="mailto:louis@nospam.com">louis@nospam.com</a><br>$ nodejs src/cli.bs.js add bob <a href="mailto:bob@nospam.com">bob@nospam.com</a><br>$ nodejs src/cli.bs.js print<br>=== OCaml/Reason Meetup! summary ===<br>date: Tue, 11 Sep 2018 15:04:16 GMT<br>access: public<br>host: bob &lt;<a href="mailto:bob@nospam.com">bob@nospam.com</a>&gt;<br>guests: 1<br>=== OCaml/Reason Meetup! summary ===<br>date: Tue, 11 Sep 2018 15:04:13 GMT<br>access: public<br>host: louis &lt;<a href="mailto:louis@nospam.com">louis@nospam.com</a>&gt;<br>guests: 1<br>$ cat events.json<br>[<br>  {<br>    &quot;guests&quot;: [<br>      {<br>        &quot;email&quot;: &quot;<a href="mailto:bob@nospam.com">bob@nospam.com</a>&quot;,<br>        &quot;name&quot;: &quot;bob&quot;<br>      }<br>    ],<br>    &quot;date&quot;: 1536678256177,<br>    &quot;host&quot;: {<br>      &quot;email&quot;: &quot;<a href="mailto:bob@nospam.com">bob@nospam.com</a>&quot;,<br>      &quot;name&quot;: &quot;bob&quot;<br>    },<br>    &quot;name&quot;: &quot;OCaml/Reason Meetup!&quot;,<br>    &quot;access&quot;: &quot;Public&quot;<br>  },<br>  {<br>    &quot;guests&quot;: [<br>      {<br>        &quot;email&quot;: &quot;<a href="mailto:louis@nospam.com">louis@nospam.com</a>&quot;,<br>        &quot;name&quot;: &quot;louis&quot;<br>      }<br>    ],<br>    &quot;date&quot;: 1536678253790,<br>    &quot;host&quot;: {<br>      &quot;email&quot;: &quot;<a href="mailto:louis@nospam.com">louis@nospam.com</a>&quot;,<br>      &quot;name&quot;: &quot;louis&quot;<br>    },<br>    &quot;name&quot;: &quot;OCaml/Reason Meetup!&quot;,<br>    &quot;access&quot;: &quot;Public&quot;<br>  }<br>]</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1f3a14004081" width="1" height="1" alt=""><hr><p><a href="https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081">Getting started with atdgen and bucklescript</a> was originally published in <a href="https://tech.ahrefs.com">ahrefs</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>'},tl:{hd:{title:"How to write a library for BuckleScript and Native",slug:"how-to-write-a-library-for-bucklescript-and-native",description:"This blog post is an introduction on how to setup a library available for both BuckleScript and OCaml, sharing as much code as possible.",url:"https://tech.ahrefs.com/how-to-write-a-library-for-bucklescript-and-native-22f45e5e946d?source=rss----303662d88bae--ocaml",date:"2019-10-22T10:09:09-00:00",preview_image:void 0,body_html:'<p><em>Written with </em><a href="https://twitter.com/javierwchavarri"><em>Javier Ch\xe1varri</em></a><em> and </em><a href="https://github.com/feihong/"><em>Feihong\xa0Hsu</em></a><em>.</em></p><p>The first <a href="https://www.reason-conf.us/">Reason Conf US</a> just ended. Many talks mentioned native compilation. Sharing code between BuckleScript and native artifacts is a use case which is more and more common. This blog post is an introduction on how to set up a library available for both worlds, sharing as much code as possible.</p><h3>The goal</h3><p>What we try to produce is a library with an identical interface for BuckleScript and native. But without duplicating code. It should also be possible to have some parts of the library that are a different implementation depending on the target, as we want to be able to leverage existing libraries that are working only in one of the\xa0worlds.</p><h3>The build\xa0systems</h3><p>For BuckleScript, there is only one build system: bsb. It is driven by a bsconfig.json file. And is installed as part of the bs-platform.</p><p>On the native side, there are a lot of different build systems that are available. But recently one of them became a de facto standard: dune. It works with a very minimal amount of configuration. And it supports the reason syntax by\xa0default.</p><p>These two tools are working in a way which is pretty similar. They share a lot of concepts. And it is easy to set them up so that both are working in the same codebase.</p><p>The main similarities that interest us\xa0are:</p><ul><li>The ability to work on specific source directories</li><li>Namespacing in bsb and wrapping in dune are both putting all the<br>files of the library under a single module\xa0name</li></ul><h3>The source code file\xa0tree</h3><p>The code of the library is split into 3 directories.</p><pre>\u251c\u2500\u2500 js/<br>\u251c\u2500\u2500 native/<br>\u2514\u2500\u2500 shared/</pre><ul><li>shared is meant to host most of the code and all the code in this directory will be compiled in both\xa0modes.</li><li>js contains the parts that are specific to BuckleScript.</li><li>native contains the parts that are specific to native\xa0OCaml.</li></ul><h3>Set up the build\xa0systems</h3><p>Once we have our basic skeleton for the library, it is time to set up the build systems. We want to have two configurations as similar as possible to make them easier to understand. Once we are done, the tree will look like\xa0this:</p><pre>\u251c\u2500\u2500 bsconfig.json<br>\u251c\u2500\u2500 dune<br>\u251c\u2500\u2500 dune-project<br>\u251c\u2500\u2500 js/<br>\u251c\u2500\u2500 native/<br>\u2514\u2500\u2500 shared/</pre><h4>BuckleScript</h4><p>At the root of the library we need a bsconfig.json file to drive<br>bsb. The documentation is available at <a href="https://bucklescript.github.io/docs/en/build-configuration](https://bucklescript.github.io/docs/en/build-configuration).">https://bucklescript.github.io/docs/en/build-configuration</a>.</p><p>The main part for us is sources. We will use it to tell bsb to look at the js and shared folders. We also want to set namespace to true, which will wrap all your project\u2019s files under a common module\xa0name.</p><pre>  &quot;namespace&quot;: true,<br>  &quot;sources&quot;: [<br>    {<br>      &quot;dir&quot;: &quot;js&quot;,<br>      &quot;subdirs&quot;: true<br>    }, {<br>      &quot;dir&quot;: &quot;shared&quot;,<br>      &quot;subdirs&quot;: true<br>    }<br>  ],</pre><p>The rest of the file is as\xa0usual.</p><pre>{<br>  &quot;name&quot;: &quot;sharedlib&quot;,<br>  &quot;namespace&quot;: true,<br>  &quot;sources&quot;: [<br>    {<br>      &quot;dir&quot;: &quot;js&quot;,<br>      &quot;subdirs&quot;: true<br>    }, {<br>      &quot;dir&quot;: &quot;shared&quot;,<br>      &quot;subdirs&quot;: true<br>    }<br>  ],<br>  &quot;package-specs&quot;: {<br>    &quot;module&quot;: &quot;es6&quot;,<br>    &quot;in-source&quot;: true<br>  },<br>  &quot;refmt&quot;: 3,<br>  &quot;suffix&quot;: &quot;.bs.js&quot;,<br>  &quot;generate-merlin&quot;: true,<br>}</pre><h4>Dune</h4><p>We must also add a dune file to the root of the library. For dune, we have different options\u200a\u2014\u200ait is possible to ignore the js directory but read everything else. Or to check only shared and native. To make the configuration similar to BuckleScript, we will go with the second solution.</p><p>The dune directive to do that is dirs. By defaults it tells dune to explore every directory except the ones hidden (starting with a dot) or starting with an underscore. <a href="https://dune.readthedocs.io/en/stable/dune-files.html#dirs-since-1-6">More details in dune\u2019s documentation</a>. To make it do what we want, the configuration should\xa0be:</p><pre>(dirs shared native)</pre><p>We also use another option of dune to tell it to include the content of those two directories as if it was at the root of the project. Without this stanza, dune would only use the source files at the root of the project and ignore everything in the sub directories.</p><pre>(include_subdirs unqualified)</pre><p>Then we need the usual library stanza to give a name to our library, state the dependencies, compilation flags, etc. In our simple case, the only information needed is the name. We can explicitly set wrapped to true, but this is already the default behavior. The <a href="https://dune.readthedocs.io/en/stable/dune-files.html#library">documentation for the whole library stanza</a> describes how to specify more\xa0details.</p><p>The final dune file looks like\xa0this:</p><pre>(dirs shared native)<br> (include_subdirs unqualified)<br> (library<br>  (name sharedlib))</pre><p>We also want a basic dune-project. If we don\u2019t write it by hand, dune will generate it for us. I am using version 1.10 as an example. But it can be changed to whatever version suits your\xa0project.</p><pre>(lang dune 1.10)</pre><h3>Compilation</h3><p>With the setup described above, the compilation for BuckleScript and native is the same as in a setup with only one or the\xa0other.</p><ul><li>bsb -make-world for BuckleScript</li><li>dune build @all for\xa0dune</li></ul><p>The call to bsb is usally put in package.json in the scripts part, so that the usual yarn build can be used. For native, it depends if you rely on esy or\xa0opam.</p><h3>How to consume the\xa0library</h3><p>This is exactly the same setup that would be used in a pure BuckleScript or pure native\xa0library.</p><p>To use your library in BuckleScript:</p><ul><li>Add the name and version to package.json</li><li>Add the name to bsbconfig.json of consuming library/app</li></ul><p>To use your library in native OCaml, add the name of your library to the libraries part an executable or library stanza,\xa0e.g.</p><pre>(executable<br> (name main)<br> (libraries sharedlib))</pre><h3>Module naming</h3><p>If you want your module name to contain capital letters in the middle (e.g. TeenageMutantNinjaTurtles), then be aware that <a href="https://bucklescript.github.io/docs/en/build-configuration.html#name-namespace">name munging</a> works differently between bsbconfig.json and dune. For example, if you want to refer to your module as CoolSharedLib in your code, then the name in bsbconfig.json must be cool-shared-lib, and in dune it must be coolSharedLib.</p><h3>Platform specific\xa0code</h3><p>The whole library does not have to be exactly the same in the two platform. It is possible to add modules that are available only in one mode. Or to have modules with a different interface.</p><p>For example, by adding a file Foo.re in js but not in native, the library now has a module Foo available when compiled to javascript. But only when compiled to javascript.</p><h3>Downsides</h3><ul><li>Both bsb and dune generate\xa0.merlin files when they compile our library. They override each other. It might be troublesome if the version of ocaml used for native code is not 4.02.3. Simply recompile the library for your platform to solve the\xa0problem.</li><li>Out of the box, this approach doesn\u2019t really allow us to share interface files between both platforms: native and BuckleScript. One workaround for that, if we wanted to share some module Foo, is to:<br>1. add Foo.mli or Foo.rei file in shared<br>2. add include FooImplementation in Foo.ml<br>3. add FooImplementation in both native and js\xa0folder</li><li>It\u2019s not possible to be platform specific for just a few lines of code (e.g. if IS_NATIVE foo else bar), the minimal per-platform unit is a file/module.</li></ul><h3>Example project</h3><p>We have set up a simple library to showcase what a repository looks like once the whole configuration is in place. It is <a href="https://github.com/ahrefs/hello-native-bucklescript">available on\xa0github</a>.</p><p>For now the repository contains only a library. But with this setup, it is actually possible to build an executable too. It is also possible to enrich it, for example by adding <a href="https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081">atdgen to communicate between both sides of the\xa0library</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=22f45e5e946d" width="1" height="1" alt=""><hr><p><a href="https://tech.ahrefs.com/how-to-write-a-library-for-bucklescript-and-native-22f45e5e946d">How to write a library for BuckleScript and Native</a> was originally published in <a href="https://tech.ahrefs.com">ahrefs</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>'},tl:{hd:{title:"One and a half years of ReasonML in production",slug:"one-and-a-half-years-of-reasonml-in-production",description:"The first Reason application at Ahrefs went online on January 31, 2019. Since then, many more applications have been either rewritten in\u2026",url:"https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b?source=rss----303662d88bae--ocaml",date:"2020-07-26T15:19:31-00:00",preview_image:"https://miro.medium.com/max/1200/1*Nl5vYk_k-mC4j32XEjryHQ.jpeg",body_html:'<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Nl5vYk_k-mC4j32XEjryHQ.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@willianjusten">https://unsplash.com/@willianjusten</a></figcaption></figure><p>The first <a href="https://reasonml.org/">Reason</a> application at <a href="https://ahrefs.com">Ahrefs</a> went online on January 31, 2019. Since then, many more applications have been either rewritten in Reason, are being slowly migrated from React to ReasonReact, or are conceived from the start as Reason projects. It is safe to say that the bet placed on Reason paid off big time. We will never go back to doing pure JavaScript again, with the possible exception of simple backend\xa0scripts.</p><p>In the past few years, it\u2019s come to light that there are a number of other <a href="https://www.messenger.com/">large</a> <a href="https://www.onegraph.com/">Reason</a>/<a href="https://darklang.com/">BuckleScript</a> <a href="https://onivim.io/">codebases</a> in the wild, but there still isn\u2019t a ton of information out there about what it\u2019s really like to work with Reason in production. To help remedy that, we thought it would be instructive to ask each of our frontend team members what their Reason journey has been like so\xa0far.</p><p>We gave them the following questions as starting points (but they were free to talk about anything they\xa0wanted):</p><ul><li>How does Reason compare to other languages you\u2019ve used in the\xa0past?</li><li>What\u2019s your favorite thing about\xa0Reason?</li><li>What\u2019s your least favorite thing about\xa0Reason?</li><li>How does ReasonReact compare to other frameworks you\u2019ve\xa0used?</li><li>Was it easy to pick up Reason? Why or why\xa0not?</li></ul><h4>Javi</h4><ul><li>How does Reason compare to other languages you\u2019ve used in the\xa0past?</li></ul><p>In the past I worked with languages like Java, C, or less known like Pascal or Prolog. But the languages I\u2019ve spent more time with are Objective-C and JavaScript. The main difference between all those languages and Reason is the exhaustiveness that you get from OCaml type checker. This is maybe awkward, but it feels like you stop coding alone and suddenly you have a sidekick always sitting next to you, that is helping you notice the things you forgot about, or found new code that is not consistent with code you or someone else wrote\xa0before.</p><p>In a world that is moving towards remote work, where many of us spend hours every day coding physically far from our colleagues, it makes the experience much more delightful. Plus, it allows for teams working on different time zones to keep a healthier work-life balance, because there is less need to have synchronous communication than with more dynamic languages, as more assumptions and design decisions are \u201cembedded\u201d into the\xa0code.</p><ul><li>What\u2019s your favorite thing about\xa0Reason?</li></ul><p>Can I pick two things? It\u2019s hard to choose only\xa0one.</p><p>The first one is the exhaustiveness and quality of the type checker, as mentioned above. Sometimes it takes a bit longer to build a feature than what it would in other languages, until the types are figured out. But this is largely compensated by the confidence one has when shipping code to production, or diving into large refactors.</p><p>The second one is the speed of the BuckleScript build system, which is built on top of <a href="https://ninja-build.org/">ninja</a>. I had never worked with such fast build system. As an example, we have recently started to use remote machines to develop at Ahrefs. In one of these machines that has 72 cores, BuckleScript takes roughly 3 seconds to clean build <em>all</em> our Reason code: application, libs, decoders\u2026 everything. Many tens of thousand lines of code! We thought there were something wrong, but we realized the compiler is just So Blazing\xa0Fast\u2122\ufe0f.</p><ul><li>What\u2019s your least favorite thing about\xa0Reason?</li></ul><p>I guess we\u2019re going through a necessary stage until things stabilize in the future, but there is a lot of fragmentation at the moment between \u201cReason native\u201d, which tries to stay closer to OCaml, and \u201cReason web\u201d, which has a goal to become friendlier for JavaScript developers.</p><p>I am excited to see what <a href="https://reasonml.org/blog/bucklescript-8-1-new-syntax">BuckleScript new syntax</a> will lead to, but I would also love to see a \u201cuniversal\u201d solution that works for the main use cases out of the box, becoming sort of Rails for Ocaml or Reason. <a href="https://github.com/oxidizing/sihl/">sihl</a> is a project that seems to go in that direction and looks very promising.</p><ul><li>How does ReasonReact compare to other frameworks you\u2019ve\xa0used?</li></ul><p>I consider ReasonReact mostly like React + types on top, because the bindings layer is very thin. The thing that I like most about React is that it follows the Unix philosophy: it does one thing and it does it really well. Maybe we have forgotten already today, but having to maintain and mutate UI based on data updates was one of the main sources of bugs in the past. The other nice thing is that there is so much good content about it: blog posts, documentation, etc.</p><ul><li>Was it easy to pick up Reason? Why or why\xa0not?</li></ul><p>It took some time, as with any other language. We have things like syntax or semantics much more ingrained into our brains than we think, so there is always some \u201crewiring\u201d time that is needed to learn a new language, even if Reason makes an effort to stay close to JavaScript syntax. The most challenging part was probably the bindings one, because coming from JavaScript, there are no previous knowledge that one can use as foundation to build upon, it\u2019s all \u201cnew knowledge\u201d. glennsl <a href="https://github.com/glennsl/bucklescript-ffi-cheatsheet">BuckleScript ffi cheatsheet</a> was a huge help for\xa0me.</p><h4>Ze</h4><p>I really like working with Reason, and have wanted to do so for a while. I was quite happy to see that working with it matched my expectations.</p><p>You get so much support from the type system, and still have a lot of flexibility to represent your domain model. Coming from other languages or paradigms, you don\u2019t feel limited at all in what you can\xa0achieve.</p><p>The language has such a strong type system that you feel much more comfortable with your\xa0coding.</p><p>The OCaml type system is there to make sure you code with assurance. This is especially true when refactoring code. You can be sure that everything will work fine after it compiles. If it compiles, it works\xa0:)</p><p>It\u2019s also very helpful when working on a monorepo. You don\u2019t have to keep reading the source code of everything you use to make sure you don\u2019t have types mistakes. Changes in code in one lib reflect immediately in all the others. This makes the feedback loop much shorter and\xa0safer.</p><p>The editors integrations with the type system are quite good and help a lot to write code better and\xa0faster.</p><p>Also, compilation times are super\xa0fast.</p><p>Last, but not least, ReasonReact is, for me, the hidden gem of ReasonML. The newcomers that have some difficulty with the language should start with it. IMHO, ReasonReact is simpler and has a better developer experience than React itself. It should be the gateway drug frontend developers need to get started with Reason/OCaml \ud83d\ude04</p><h4>Liubomyr</h4><p>To me, all those language features boil down to one essential thing, and it\u2019s the easiness of refactoring. New business requirements popups all the time, and often your initial code assumptions are no longer correct. It was such a pain to modify code in a large JS codebase, as you never know how many things you potentially break in the process. With Reason, it has never been easier. If you need to change your data shape or some component API, you just do it, and from there, the compiler will guide you through all the places you broke, and help to fix\xa0those.</p><p>Coming from the JS world, it feels like the initial development is slower, because of the learning curve, missing bindings, less StackOverflow answers, but in the end, you are getting a stable software which is way easier to maintain and add features\xa0to.</p><h4>Egor</h4><p>I switched to Reason when I joined Ahrefs team about a year ago, before that I worked mostly with Ruby language.</p><p>The first thing that impressed me in ReasonML was code refactoring. Refactoring in language with a strong type system, like ReasonML and OCaml, is much easier than what I am used to. If your program compiles after your refactoring\u200a\u2014\u200amost likely you did everything right, if it doesn\u2019t compile\u200a\u2014\u200ayou can immediately see what you forgot to change. This can be achieved in languages with a dynamic type system only with a huge amount of code tests (supporting big test suite is a time consuming process as well as code support).</p><p>The other thing that I really like about ReasonML codebase\u200a\u2014\u200ahow readable it is. When you just enter into ReasonML world\u200a\u2014\u200asome things can be unfriendly from the first sight, for example, immutable let bindings, but in the end, you realize that these language decisions help you to write cleaner and simpler\xa0code.</p><h4>Seif</h4><p>The programming language I used the most in the past is JavaScript. I switched to Reason when I joined Ahrefs a few months ago. From the start, I worked mainly on the code shared by the majority of the tools and I don\u2019t think I would have had the same confidence making changes if I was doing it with JavaScript. I love JavaScript\u2019s developer experience and accessibility. Reason provided me predictability without hurting these very same things I like about JavaScript.</p><h4>Bryan</h4><p>Reason (and OCaml) is, by far, one of the easiest languages to work with. Easy in the sense that the compiler helps eliminate an entire class of errors so you don\u2019t have to worry about them. Additionally, in most other web-centric languages, it\u2019s a pain to add features to existing code that you\u2019ve not touched for a long time. With strong static typing, I can usually add the feature I want in either the backend or frontend, and then let the compiler tell me what needs to be\xa0updated.</p><p>Pattern-matching is one of my favourite features in Reason. To me, it makes more sense to be able to explicitly specify conditions that I\u2019m interested in a clear and concise manner, and let the compiler tell me if I missed out a particular condition. Records go hand-in-hand with this. As software programs are made up of data and instructions, records are the perfect data containers. They are quick to define and query, focusing on data rather than behaviour (think classes and instance methods).</p><p>It definitely took a while to pick up Reason mainly because it takes time to become familiar with idiomatic OCaml. But once I crested that learning curve, everything just made sense and all the features of the language that made Reason seemingly difficult to learn\u200a\u2014\u200astrong typing, the functional paradigm, etc, became assistants that helped me to write better\xa0code.</p><h4>Feihong</h4><p><a href="https://reasonml.github.io/reason-react/en/">ReasonReact</a> is a great library for making complex UIs in a large codebase because you get the familiarity of React coupled with the type safety of OCaml. Having two well-established technologies in its foundation is a big advantage that ReasonReact has over other functional UI libraries/frameworks in the transpile-to-JS universe. I didn\u2019t have any professional OCaml experience before joining, yet the ramp up was made much easier by my existing knowledge of React and the (somewhat superficial) similarity of the Reason syntax to JS. Oftentimes it was possible to correctly guess the intent of existing Reason code without knowing all the syntax, because most React concepts carry over pretty directly. And even though the documentation is incomplete and not perfect, it\u2019s quite usable already and among conceptually-similar frameworks is second only to the Elm documentation.</p><p>The compiler errors were difficult to get used to at first. The compiler is fairly good at pointing out the location of the error, but not necessarily as good at explaining the nature or cause of the error. As such, having a REPL would be extremely useful. Actually, OCaml does have its own REPL, but BuckleScript (the compiler used by Reason to translate OCaml to JS) does not at the moment. Nonetheless, the <a href="https://reasonml.github.io/en/try">Try Reason</a> page is a really good tool to try out small snippets of code and is extremely useful while learning the language (we will still occasionally post Try Reason links in our slack channel).</p><h3>Summary</h3><p>The reality is that Ahrefs has always been an OCaml shop, but in the past OCaml was only used to build the backend. Now that we are also using it on the frontend, we get the benefits that our backend colleagues have enjoyed for many years: the expressiveness afforded by pattern matching, the ease of refactoring in large codebases, the stability of a mature programming language, and the confidence of \u201cif it compiles, it works\u201d. To make a shoddy nautical analogy, it is as if we had built a wooden ship powered by a turbo engine. But now the wooden parts are being replaced with steel and plastic, bringing the exterior of the ship up to modern standards as well. As a result, the ship runs faster and more reliably, making the passengers (our users) more satisfied. Also, pirates (bugs) have a harder time hijacking the ship because it\u2019s sturdier and defended by well-disciplined camels. Because the ship keeps getting more and more passengers who want to experience a delightful ride and take pictures with enigmatic camels, we require a constant influx of willing and able boat engineers (who aren\u2019t allergic to camels) to extend and maintain the ship. (Yes, that means that <a href="https://ahrefs.com/jobs">we are hiring</a>\ufe0f.)</p><p><em>Thanks to Raman and Louis for fact checking this\xa0post.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2250cf5ba63b" width="1" height="1" alt=""><hr><p><a href="https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b">One and a half years of ReasonML in production</a> was originally published in <a href="https://tech.ahrefs.com">ahrefs</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>'},tl:{hd:{title:"Skylake bug: a detective story",slug:"skylake-bug-a-detective-story",description:"It was a dark and stormy night; the skylake CPU buzzed with excitement, and then, suddenly, the hyperthreads started to lock up..",url:"https://tech.ahrefs.com/skylake-bug-a-detective-story-ab1ad2beddcd?source=rss----303662d88bae--ocaml",date:"2017-06-28T18:34:51-00:00",preview_image:void 0,body_html:'<blockquote>It was a dark and stormy night; the skylake CPU buzzed with excitement, and then, suddenly, the hyperthreads started to lock\xa0up..</blockquote><p>Or something like\xa0that.</p><p>This week a new erratum for the Intel Skylake and Kabylake processors families was brought to public attention on <a href="https://lists.debian.org/debian-devel/2017/06/msg00308.html">the Debian mailing list</a>, and then on <a href="https://news.ycombinator.com/item?id=14630183">various</a> <a href="https://www.reddit.com/r/programming/comments/6jfgfp/warning_intel_skylakekaby_lake_processors_broken/">social media</a> and <a href="http://www.theregister.co.uk/2017/06/25/intel_skylake_kaby_lake_hyperthreading/">news\xa0outlets</a>.</p><p>We have been investigating this issue since January with the core <a href="http://ocaml.org">OCaml</a> team, as we were struggling with a mysterious bug affecting our developers machines, and ultimately our production system, resulting in a corruption of important data in our databases.</p><p>At <a href="https://ahrefs.com">Ahrefs</a>, we operate a fleet of thousands of servers, running a wide variety of services (huge web crawler among others). At this scale, dealing with unexpected application behaviors is common. While we try to reduce the probability of the software not functioning as expected, bugs are sadly a real part of our everyday life. Even though we can assume the underlying hardware running any infrastructure can be thought of as more reliable and less prone to bugs than software components, issues can still arise in unexpected ways. When the number of servers increases, it is not unusual to observe faults in the hardware preventing the system from functioning as specified.</p><p>It is certainly not frequent to encounter such problems in CPUs but reading through <a href="https://www3.intel.com/content/dam/www/public/us/en/documents/specification-updates/desktop-6th-gen-core-family-spec-update.pdf">the list of errata published by any manufacturer,</a> each CPU model contains a fair amount of bugs. This story is about the bug in the microcode of Skylake processor leading to incorrect code execution under certain conditions. This is certainly scary at first sight: how can we trust our system if we cannot trust its main component\xa0? Yet, like software bugs, processor defects can be identified, contained, and we can take actions to prevent them from impacting the operation of the infrastructure.</p><p>We do not know the full implications of this particular bug, especially security implications in case of untrusted code execution. But we\u2019d like to tell the story of this erratum from our point of view, to provide some context, and show that dealing with it was not much different than dealing with any usual software flaw. While this post aims to cover our own perspective on this adventure, we would like to thank Mark Shinwell, Xavier Leroy, Fr\xe9d\xe9ric Bour, everyone involved in the <a href="https://caml.inria.fr/mantis/view.php?id=7452">Mantis issue</a> and the OCaml IRC channel for their help and time spent investigating with us. Update: Xavier Leroy told his own side of the story in another <a href="http://gallium.inria.fr/blog/intel-skylake-bug/">blog\xa0post.</a></p><h3>Setting the\xa0scene</h3><p>Our story starts in late 2016 after some of our backend developers received new laptops to work on. After a few days Enguerrand Decorne noticed unusual crashes during compilation of our OCaml codebase.</p><p>This issue, considered mildly annoying at first, seemed to affect only Enguerrand\u2019s machine. For a few days no other machine would exhibit the same behavior, so we figured this was a fault specific to his system configuration.</p><p>However, concerns were subsequently raised after witnessing the generation of invalid machine code and later on, after the deployment of a service on one of our new clusters composed of Skylake Xeon processors, leading to the insertion of corrupted data into our storage system. The priority raised from the annoying level, to potentially critical. Other developers started working together to obtain more information and assess the impact on our infrastructure. Soon after we were able to reproduce the issue on several machines.</p><p>The remainder of this post is a technical description of the steps taken to ensure that our systems were operating safely. It is intended to show that such low level CPU issues is not necessarily fatal\u200a\u2014\u200ain less than two weeks, with the great help of core OCaml developers, we identified the conditions of the crash and set up a workaround.</p><h3>Tracking down crashes in\xa0OCaml</h3><p>Most of our backend code is written in <a href="https://ocaml.org">OCaml</a>, a high level and expressive language supporting functional programming style (among others), which allows us to develop robust systems with ease, thanks to its strong type system and mature\xa0legacy.</p><p>The compiler segfaults were definitely a surprise, since this shouldn\u2019t happen for any program written in OCaml, as type system and other features (such as automatic bounds-checking) usually guard us from such errors. However, stack overflows can be possible sources of segfault (when a non-optimal recursion is running too deep), so our first intuition was to increase the stack size when running the compiler. This didn\u2019t change anything, and the reported fault address wasn\u2019t anywhere near the stack address\xa0bound.</p><p>Before witnessing the crash on other machines, we suspected a failure in the virtualization software used by our two developers that were able to reproduce the crash, who use VMware as a part of their development workflow. We tried early on to switch to Virtualbox, but the migration proved itself fruitless as the crashes kept appearing. After a short while we began encountering the same issue on physical machines, so we ruled out a possible virtualization software\xa0bug.</p><p>The usual debugging process for crashing OCaml code didn\u2019t prove effective\u200a\u2014\u200awe needed to narrow down our approach.</p><p>OCaml ships with <a href="https://realworldocaml.org/v1/en/html/the-compiler-backend-byte-code-and-native-code.html">two backend implementations</a>: a bytecode interpreter and a native compiler. We were able to reproduce the issue using both a native compiler and a compiler running on the bytecode interpreter. Consequently, this ruled out a miscompilation coming from the code <em>emitted</em> by the compiler, the OCaml runtime <em>itself</em> was misbehaving.</p><p>The runtime code is written in C, and implements low level functionalities, including the garbage collector used by both backends. After rebuilding the runtime with debug symbols, we were able to retrieve a proper stack trace and core dump. The stack trace pointed to the garbage collector\u2019s mark phase. OCaml\u2019s GC is a classic generational mark and sweep collector. The mark phase walks the heap starting from pointers on the stack and other registered root values, and marks every reachable block of\xa0memory.</p><p>Further inspection with <strong><em>gdb</em></strong> of the frame and address of crash revealed that the marking code encountered a corrupted block header with invalid size information, causing what looked like a buffer overrun error. Each memory block allocated in OCaml heap begins with a header word, storing metadata used by the GC, including a tag describing the kind of value present in this memory block. The header contains the size of the block, and the crash happened when the mark code was attempting to scan an array which was supposed to be more than 1TB\xa0large.</p><p>This was obviously not the cause of the problem but rather the consequence: something corrupted the header word after this block had been properly allocated, postponing the crash until the next GC cycle. It was the right time to escalate <a href="https://caml.inria.fr/mantis/view.php?id=7452">the issue to the OCaml bugtracker</a>, after isolating a proper test case to reproduce the\xa0issue.</p><h3>A set of strange\xa0leads</h3><p>Escalating the issue to Mantis made us to take a step back and gather our findings, and we quickly got great feedback from the OCaml core\xa0team.</p><p>At this point, what does the problem look\xa0like?</p><p>We only had sparse information, but <strong><em>dmesg</em></strong> gave us interesting data point. When a page fault occurs and the kernel detects an incorrect memory access, it logs a line in kernel log buffer containing the fault address, the instruction pointer and stack\xa0pointer.</p><p>[22985.879907] ocamlopt.opt[48221]: segfault at af8 ip 00005564455169bd sp 00007ffc9f36b130 error 4 in ocamlopt.opt[556445006000+613000]</p><p>Next to the 3 addresses, already available in the coredumps, an error code is reported. This number in decimal form is actually a bitset, and the flags are documented in the Linux kernel sources in <a href="https://github.com/torvalds/linux/blob/v4.11/arch/x86/mm/fault.c#L41">arch/x86/mm/fault.c</a>. Error 4 can thus be read as a read access page fault from user mode, trying to read memory which had not been previously mmap\u2019ed.</p><p>Error codes reported following our crashes involved protection faults or access to unmapped addresses, which corroborated our earlier buffer overrun hypothesis. More interestingly we witnessed a crash with the PF_RSVD flag enabled. This left us puzzled, none of us had ever seen such fault before. Apparently it indicates that the the page table was somehow corrupted, with some entries having non-zero bits reserved by the x86 architecture specification.</p><p>It was scary that the corruption would escape the process address space, and to our limited knowledge, it could only have been caused by kernel issue or potentially hardware issues, like memory errors. Yet we were able to reproduce this on several machines with different kernel version, and different hardware. We blamed virtual machines earlier but this theory was debunked already. We still have no explanation at this time, and pursuit on this front would require intimate knowledge of virtual memory implementations that we didn\u2019t\xa0have.</p><p>One developer wasn\u2019t able to reproduce the problem at all on his machine after hours of testing, but something was fishy: it didn\u2019t sound right that an OCaml runtime bug would be able to modify the page table. Maybe it was some corner case with reserved addresses, but this something was beyond our reach here. Out of ideas, it was time to get some assistance from tools intended to track memory corruptions, like <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">asan and\xa0ubsan</a>.</p><p>Running <strong><em>Asan</em></strong> didn\u2019t yield any meaningful results. <strong><em>Valgrind</em></strong> was later tried, following advises from the OCaml team, but every tools were preventing the crash. Quickly reproducing the bug for testing required running code in a loop, keeping the CPU and memory fully\xa0busy.</p><p>This was harder to do on developers machines, due to limited resources and other processes running, and Address Sanitizer would only increase the resources usage. Dedicating a powerful server would make further investigations more comfortable, and increase the likeliness of reproducing with instrumented code.</p><p>But with great surprise, it was not possible to reproduce the problem on a server machine, with and without instrumented code. This is when we realised that all the machines exhibiting the crashes were running a processor of the Intel Skylake processors family, while the server and other developer machines had CPUs from the Broadwell family.</p><h3>The hardware, an unusual\xa0suspect</h3><p>In the meantime several core OCaml developers had been closely investigating the issue and started auditing recent changes in the runtime, and identified a few suspicious changes and known\xa0bugs.</p><p>Certainly they were more qualified for this task, but it acted as an incentive to examine the history of this bug from our angle. At first, we had assumed that the bug was specific to the new laptop with virtual machines. This could not explain why the crash never manifested on older workstations equipped with Skylake processors. Several other developers had been using them for a few months, and only noticed the crash after awareness of the issue had been raised by Enguerrand.</p><p>What had changed, besides Skylake? Only a few week before, an internal migration from OCaml version 4.02.3 to 4.03.0 was rolled out in our codebase. Intrigued, we went ahead and tested OCaml 4.02.3 again, which showed no memory corruptions after several tests. It was time to browse the <a href="https://raw.githubusercontent.com/ocaml/ocaml/trunk/Changes">OCaml changelog</a> for runtime related entries. The search stopped quickly on a promising item in the list: the OCaml C runtime build optimisation level had been increased to -O2 from\xa0-O1.</p><p>Could the optimizations dig out an undefined behavior in C code, leading to bad assumptions in the GC code corrupting the heap\xa0? Rebuilding the runtime with -O1did not corrupt memory, so the source of the corruption was in the runtime <em>and</em> was triggered by some gcc specific optimization pass. This sounded like undefined behavior, although the information we had led us to some hardware\xa0bug.</p><p>The next day, Xavier Leroy commented on the bugreport reporting that the crash had been observed in the past. Another industrial OCaml user was affected, and they had discovered HyperThreading was part of the necessary conditions. After running the test case for several hours on several machines with HT disabled in the UEFI setup, it was clear we were facing a similar situation. This led to the hypothesis of a hardware\xa0bug:</p><blockquote><em>Is it crazy to imagine that gcc -O2 on the OCaml 4.03 runtime produces a specific instruction sequence that causes hardware issues in (some steppings of) Skylake processors with hyperthreading? Perhaps it is\xa0crazy.</em></blockquote><p>This possibility had struck us too, motivated by the HyperThreading, the page table corruption and the Skylake specific set of conditions.</p><p>This issue had certainly a strange profile. But nobody was ready to fully embrace the cpu bug hypothesis yet. We convinced ourselves that disabling HT could affect cache pressure and unfold some undefined behaviours.</p><p>HT could also explain the non-determinism, since cache pressure would depend on timings and scheduling. None of us had sufficient experience in this area to assess the strength of such hypothesis, and we did not quite buy it on a single threaded OCaml program. Our debugging motto claims that \u201cassumptions are not\xa0facts\u201d.</p><p>It was time to browse Intel errata list and attempt to update the CPU microcode. Although, the errata descriptions are formulated in vague terms, none of the issues disclosed at this time were looking similar to the situation under investigation. Unfortunately, CPUs microcode had no fix waiting for us either. OCaml developers investigated the errata list from their side but the lack of detailed information turned this into a fruitless and complex\xa0task.</p><p>In the absence of better alternative, we focused our work on pinpointing the exact source of the crash as if it was a software bug, in the hope of either finding a code issue or ruling out this hypothesis while getting more detailed data. We needed a way to identify the problematic code and find a workaround. From our side, it was not only a matter of finding whether or not there was a bug in OCaml code, but more crucially we needed a guarantee on the quality of our generated code running critical services in production.</p><h3>Identifying the offending code</h3><p>The other OCaml user affected by this issue reported that they had solved the problem by switching to another C compiler. Building the runtime with clang instead of GCC would prevent the GC from crashing. They also suggested to obtain a diff of the generated assembly. Indeed, once built with clang, the runtime would not crash. But clang generates widely different assembly from GCC and we did not have the resources to analyse several hundred thousand lines of\xa0changes.</p><p>If we could isolate the problematic C code, comparing the generated code would be easier. The problem had the form of a well known\xa0nail:</p><ul><li>Around 50 C files composing the OCaml\xa0runtime,</li><li>There is a good state (when built with gcc\xa0-O1)</li><li>And a bad state (when built with gcc\xa0-O2)</li></ul><p>This nail comes with a precious hammer: bisection.</p><p>The bisection approach had a downside in this occasion. Any state can be labeled bad with certainty as soon as the test crashes, but we would need to wait several hours to be confident enough to trust a non crashing test as good data-point. The reproducibility was not always consistent and a non-crashing state could be a false negative still waiting to trigger the conditions leading to the crash. A reduction of search space was necessary.</p><p>All the coredumps we had showed that the fault was caused by a corrupted heap block header, and our testcase involved the compiler. The OCaml compiler is not 100% deterministic, and IO/s primitives and unix environment in the runtime can affect timings and allocation patterns. But it sounded sensible to assume that the code corrupting a heap header block was also the code reading and writing those blocks: the major\xa0GC.</p><p>This hypothesis made bisecting fast: the first file we tried, <strong><em>major_gc.c</em></strong>, turned out to be the one. To make sure it was not a subtle issue in linker, reordering symbols or code blocks, we tried a few others files and confirmed changing the optimization level of some other files alone made no difference.</p><p>But the generated code difference was still way too large. Bringing this topic up on the <a href="http://webchat.freenode.net/?channels=#ocaml">OCaml IRC</a> discussion channel led to some useful inputs. We were taught that gcc supports an attribute to enable specific optimizations at the function level, using __attribute__((optimize(&quot;options,...&quot;))). Following the same strategy, it was easy to trace the source of the malfunctioning code to the <strong><em>sweep_slice</em></strong> function, which implements the sweeping phase of the classic mark and sweep garbage collector for the old generation.</p><p>Ignoring the subtle details of incremental GC, the <strong><em>sweep_slice</em></strong> function is the last pass of a normal major collection cycle. It is responsible for scanning all blocks in the major heap, and reclaiming unreachable blocks to the list of unallocated space.</p><p>The bulk of this function is a switch taking action for each block depending on its status\xa0:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cfbc19fddccc5f2c1a76fcc802fae049/href">https://medium.com/media/cfbc19fddccc5f2c1a76fcc802fae049/href</a></iframe><p>This finding felt consistent with the information at hand. When the block is reachable, the color (describing the reachability status of the block) is reset. If the block became unreachable (<em>while color</em>) - it is reclaimed. In both cases, the block header is modified.</p><p>Getting back to the assembly\xa0diff.</p><p>Nobody in the team knows a great deal about assembly and we only have a really basic understanding of most of the instructions used in both versions. It quickly became obvious that the noise level in this diff, with thousands of lines of changed, was still too high for us to spot anything related to the problem. This problem was getting far beyond the common knowledge of everyone in the\xa0team.</p><p>But this was still sounding like your day to day bug tracking process. The less you know, the more careful you need to be, tackling the problem step by step. We stuck to what approach had served us well until now: bisecting.</p><p>We went through the list of optimisation passes enabled by GCC at -O2. This is a fair amount of optimisation passes and it would have been too time consuming to try them one by one, given the time needed to trigger the crash. Yet we had a hint: a memory corruption was happening semi randomly in the garbage collector. We were also keeping the undefined behaviour bug as a potential explanation. It was likely a pass which would change the structure of the code, reordering blocks and changing conditions.</p><p>After reading the description of all switches in the detailed gcc manual, the -ftree-* pass family looked promising. This set of transformations works on the <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA form</a> internal representation, a widespread intermediate language representation which has the benefit of being easy to read. They seem to make a huge impact on the generated assembly code, moving code blocks around and making assumptions on code invariants in order to move around, simplify or eliminate conditional checks altogether.</p><p>By looking at output of those passes on the related source code, we narrowed down the list of transformations to a couple of interesting passes, one of them being -ftree-vrp, which stands for Value Range Propagation. This pass computes bounds for each name binding and propagates proofs that a value must lie in a given\xa0range.</p><p>It turned out most of the other passes depended on it for further optimisations. Even though the issue ended up not being a bad assumptions in the range values, checking this pass proved to be worthwhile: enabling -ftree-vrp on <strong><em>sweep_slice</em></strong> function while every thing else was built with -O1 was enough to trigger a\xa0crash.</p><p>GCC provides very good diagnostics output, and after reading the manual we found the -fdump-tree-* switch to dump the SSA form before and after specific pass. The output is designed to be read by a human and provides meaningful naming, with source code locations, alongside the ranges propagated by the VRP pass. We spent some time studying the output and matched the difference in SSA tree between the crashing and not crashing\xa0code.</p><p>Examining the bounds and invariants derived by gcc, it was clear that no wrong hypothesis was\xa0stated.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a5a311d0b5a4f890f9541f0aed91e73e/href">https://medium.com/media/a5a311d0b5a4f890f9541f0aed91e73e/href</a></iframe><p>The only meaningful observable change involves the suppression of rechecking the loop condition in the else branch of the <strong><em>sweep_slice</em></strong> function, after Value Range Propagation proved that the condition was invariant in this\xa0branch.</p><p>Often, reading the code carefully is the fastest way to find a bug. But after spending hours staring at the major GC code, it was clear enough that this check removal should not cause any semantic\xa0changes.</p><p>In this process, we identified a suspicious bit of code, where a signed long variable was promoted to unsigned according to C standard rules, which was changing the bounds derived by gcc, assuming it was always positive. But after some thinking we realised it made no difference at assembly level and although wrong, this assumption was not used anywhere.</p><p>We were now ready to rule out the possibility of a bug in OCaml runtime. It was still possible that GCC backend had a bug and was miscompiling this particular shape of code. And we were back at the assembly level again. After writing some awk formatting script to cleanup assembly and minimise noise in the diff (by renaming labels, detecting spurious code move, etc), and preventing inlining, we found a minimal assembly patch causing the\xa0crash.</p><p>There were only cosmetic differences. The test removal was propagated down to assembly and caused gcc to reorganise the layout of each switch case\xa0block.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/532ab4896b11177a96203fd0c81eaa58/href">https://medium.com/media/532ab4896b11177a96203fd0c81eaa58/href</a></iframe><p>Among those minor differences and changes of layout, we noticed a particular change which impacted exactly the reachable block header updated which could have caused header corruption. In the unoptimised version, the updating code looked like\xa0this:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/38ca30a1decf86233084721c3803b1c4/href">https://medium.com/media/38ca30a1decf86233084721c3803b1c4/href</a></iframe><p>For some reason, the block pointer was spilled to the\xa0stack.</p><p>Perhaps naively, and because we had earlier emitted the hypothesis of HT impacting cache pressure, we spent a few hours staring at this code and check if we were missing something subtle which could affect the control flow of the whole function and the stack location from which it was reloaded could be corrupted.</p><p>Despite our lack of assembly knowledge, after spending several hours reading this tiny change, we got convinced that it made strictly no semantic difference. Reading the x86 manual carefully didn\u2019t give any hint on any subtle behavior which would trigger. Executing any of those two sequence of instruction should give the exact same\xa0output.</p><h3>Mitigating the\xa0issue</h3><p>We were now quite certain it was a CPU\xa0bug.</p><p>The OCaml developers had reached the same conclusion, and were working on escalating the issue to Intel. After internal discussions we decided to keep this bug as low profile as possible since we were unsure about potential security implications, especially for JIT implementations.</p><p>Even if we had no confirmation at this point nor any explanations of the cause of this bug, which was beyond our reach, we could take\xa0actions.</p><p>The first step was to decide against getting any new Skylake based servers until further announcement. We were left with several Skylake machines but we refrained from deploying any OCaml code on them. OCaml comes with a great package manager, <a href="https://opam.ocaml.org/">opam</a>, which supports compiler switches. Switches allow to set up a clean and distinct environment with specific packages and compiler configuration.</p><p>We patched our internal opam repository to distribute unoptimised runtime to all developers and moved forward, waiting for further announcements.</p><p>This situation made us realise that microcode requires constant updates, just like any other software in the stack. We raised awareness on this topic in our devops team, and they took measure to ensure we could roll out updates to prod\xa0easily.</p><h3>Happy end</h3><p>In late May, devops team noticed a <a href="http://metadata.ftp-master.debian.org/changelogs/non-free/i/intel-microcode/intel-microcode_3.20170511.1_changelog">debian package update for intel-microcode</a> containing the following change:</p><pre>Likely fix nightmare-level Skylake erratum SKL150. Fortunately,<br>either this erratum is very-low-hitting, or gcc/clang/icc/msvc<br>won\u2019t usually issue the affected opcode pattern and it ends up<br>being rare.<br>SKL150 \u2014 Short loops using both the AH/BH/CH/DH registers and<br>the corresponding wide register *may* result in unpredictable<br>system behavior. Requires both logical processors of the same<br>core (i.e. sibling hyperthreads) to be active to trigger, as<br>well as a \u201ccomplex set of micro-architectural conditions\u201d</pre><p>The erratum description immediately rang a bell as it matched the diff in the assembly we had observed. We tested the microcode update and confirmed it fixed the corruption.</p><p>Finally, our Skylake CPUs were feeling safe and OCaml compiler was\xa0happy.</p><p><a href="https://ahrefs.com"><em>Ahrefs</em></a><em> runs an internet-scale bot that crawls the whole Web 24/7. Our backend system is powered by a custom petabyte-scale distributed key-value storage implemented in OCaml (and some C++ and Rust). We are a small team and strongly believe in better technology leading to better solutions for real-world problems. We worship functional languages and static typing, extensively employ code generation and meta-programming, value code clarity and predictability, and are constantly seeking to automate repetitive tasks and eliminate boilerplate. And we are\xa0</em><a href="https://ahrefs.com/jobs"><em>hiring</em></a><em>!</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ab1ad2beddcd" width="1" height="1" alt=""><hr><p><a href="https://tech.ahrefs.com/skylake-bug-a-detective-story-ab1ad2beddcd">Skylake bug: a detective story</a> was originally published in <a href="https://tech.ahrefs.com">ahrefs</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>'},tl:{hd:{title:"13 Virtues",slug:"13-virtues",description:"Very early on in his life, while on lengthy voyage from London to Philadelphia,Ben Franklin created a system of thirteen virtues to live his life by. He spen...",url:"https://blog.janestreet.com/13-virtues/",date:"2015-01-02T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Very early on in his life, while on lengthy voyage from London to Philadelphia,\nBen Franklin created a system of thirteen virtues to live his life by. He spent\nthe remainder of his days giving special focus to one virtue per week in a 13\nweek cycle, as well as noting the virtues he failed to live up to at the end of\neach day.</p>"},tl:{hd:{title:"A better inliner for OCaml, and why it matters",slug:"a-better-inliner-for-ocaml-and-why-it-matters",description:"OCaml 4.03 is branched and a first release candidate is imminent, so it seemslike a good time to take stock of what\u2019s coming.",url:"https://blog.janestreet.com/flambda/",date:"2016-02-24T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>OCaml 4.03 is branched and a first release candidate is imminent, so it seems\nlike a good time to take stock of what\u2019s coming.</p>"},tl:{hd:{title:"A brief trip through Spacetime",slug:"a-brief-trip-through-spacetime",description:"Spacetime is a new memory profiling facility for OCaml to help find space leaksand unwanted allocations. Whilst still a little rough around the edges, we\u2019vef...",url:"https://blog.janestreet.com/a-brief-trip-through-spacetime/",date:"2017-01-09T00:00:00-00:00",preview_image:"https://blog.janestreet.com/a-brief-trip-through-spacetime/spacetime.jpg",body_html:'<p>Spacetime is a new memory profiling facility for OCaml to help find space leaks\nand unwanted allocations. Whilst still a little rough around the edges, we\u2019ve\nfound it to be a very useful tool. Since there\u2019s not much documentation for\nusing spacetime beyond <a href="https://github.com/lpw25/prof_spacetime/blob/master/Readme.md">this\nreadme</a>, I\u2019ve\nwritten a little intro to give people an idea of how to use it.</p>'},tl:{hd:{title:"A lighter Core",slug:"a-lighter-core",description:"We recently released a version of our open source libraries with a muchanticipatedchange\u2013 Async_kernel, the heart of the Async concurrent programming library...",url:"https://blog.janestreet.com/a-lighter-core/",date:"2015-03-21T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>We recently released a version of our open source libraries with a much\nanticipated\n<a href="https://github.com/janestreet/async_kernel/commit/bf11c4211595b2589b6517aefafceb2ad3bdc0fd">change</a>\n\u2013 Async_kernel, the heart of the Async concurrent programming library, now\ndepends only on Core_kernel rather than on Core.</p>'},tl:{hd:{title:"A look at OCaml 4.08",slug:"a-look-at-ocaml-408",description:"Now that OCaml 4.08 has been released, let\u2019s have a look at what wasaccomplished, with a particular focus on how our plans for4.08 fared. I\u2019ll mostly focus o...",url:"https://blog.janestreet.com/a-look-at-ocaml-4.08/",date:"2019-07-12T00:00:00-00:00",preview_image:"https://blog.janestreet.com/a-look-at-ocaml-4.08/ocaml_release-2019.jpg",body_html:'<p>Now that OCaml 4.08 has been released, let\u2019s have a look at what was\naccomplished, with a particular focus on how <a href="../plans-for-ocaml-408/">our plans for\n4.08</a> fared. I\u2019ll mostly focus on work that we\nin the Jane Street Tools &amp; Compilers team were involved with, but we are\njust some of the contributors to the OCaml compiler, and I\u2019ll have a\nquick look at the end of the post at some of the other work that went\ninto 4.08.</p>'},tl:{hd:{title:"A solution to the ppx versioning problem",slug:"a-solution-to-the-ppx-versioning-problem",description:"Ppx is a preprocessing system for OCaml where one maps over the OCaml abstractsyntax tree (AST) to interpret some special syntax fragments to generate code.",url:"https://blog.janestreet.com/an-solution-to-the-ppx-versioning-problem/",date:"2016-11-08T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Ppx is a preprocessing system for OCaml where one maps over the OCaml abstract\nsyntax tree (AST) to interpret some special syntax fragments to generate code.</p>"},tl:{hd:{title:"A tutorial for building web applications with Incr_dom",slug:"a-tutorial-for-building-web-applications-with-incrdom",description:"At Jane Street, our web UIs are built on top of an in-house frameworkcalled Incr_dom, modeled inpart on React\u2019s virtualDOM. Rendering differentviews efficien...",url:"https://blog.janestreet.com/a-tutorial-for-building-web-applications-with-incrdom/",date:"2019-01-15T00:00:00-00:00",preview_image:"https://blog.janestreet.com/a-tutorial-for-building-web-applications-with-incrdom/incr_dom.png",body_html:'<p>At Jane Street, our web UIs are built on top of an in-house framework\ncalled <a href="https://github.com/janestreet/incr_dom">Incr_dom</a>, modeled in\npart on <a href="https://reactjs.org/docs/faq-internals.html">React\u2019s virtual\nDOM</a>. Rendering different\nviews efficiently in response to changes made to a shared model is a\nquintessentially incremental computation\u2014so it should be no surprise\nthat Incr_dom is built on top of\n<a href="https://blog.janestreet.com/introducing-incremental/">Incremental</a>.</p>'},tl:{hd:{title:"Accelerating Self-Play Learning in Go",slug:"accelerating-self-play-learning-in-go",description:"At Jane Street, over the last few years, we\u2019ve been increasingly exploring machine learning to improve our models. Many of us are fascinated by the rapid imp...",url:"https://blog.janestreet.com/accelerating-self-play-learning-in-go/",date:"2019-02-28T00:00:00-00:00",preview_image:"https://blog.janestreet.com/accelerating-self-play-learning-in-go/go.jpg",body_html:"<p>At Jane Street, over the last few years, we\u2019ve been increasingly exploring machine learning to improve our models. Many of us are fascinated by the rapid improvement we see in a wide variety of applications due to developments in deep learning and reinforcement learning, both for its exciting potential for our own problems, and also on a personal level of pure interest and curiosity outside of work.</p>"},tl:{hd:{title:"Announcing Our Market Prediction Kaggle Competition",slug:"announcing-our-market-prediction-kaggle-competition",description:"Jane Street is running a Kaggle contest based on a real problem withreal financial data. If you like ML projects, or think you might,head over and check itou...",url:"https://blog.janestreet.com/announcing-our-market-prediction-kaggle-competition-index/",date:"2020-11-24T00:00:00-00:00",preview_image:"https://blog.janestreet.com/announcing-our-market-prediction-kaggle-competition-index/kaggle_blogpost.jpg",body_html:'<p>Jane Street is running a Kaggle contest based on a real problem with\nreal financial data. If you like ML projects, or think you might,\n<a href="https://www.kaggle.com/c/jane-street-market-prediction" target="_blank">head over and check it\nout</a>.\nWe think it\u2019s a pretty fun one. The prizes are pretty good too, with a\ntotal $100K being paid out.</p>'},tl:{hd:{title:"Announcing Signals and Threads, a new podcast from Jane Street",slug:"announcing-signals-and-threads-a-new-podcast-from-jane-street",description:"I\u2019m excited (and slightly terrified) to announce that Jane Street isreleasing a new podcast, called Signals andThreads, and I\u2019m going to be thehost.",url:"https://blog.janestreet.com/announcing-signals-and-threads-index/",date:"2020-08-31T00:00:00-00:00",preview_image:"https://blog.janestreet.com/announcing-signals-and-threads-index/./signals-and-threads.png",body_html:'<p>I\u2019m excited (and slightly terrified) to announce that Jane Street is\nreleasing a new podcast, called <a href="https://signalsandthreads.com/">Signals and\nThreads</a>, and I\u2019m going to be the\nhost.</p>'},tl:{hd:{title:"Building a lower-latency GC",slug:"building-a-lower-latency-gc",description:"We\u2019ve been doing a bunch of work recently on improving the responsiveness ofOCaml\u2019s garbage collector. I thought it would be worth discussing thesedevelopmen...",url:"https://blog.janestreet.com/building-a-lower-latency-gc/",date:"2015-04-10T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>We\u2019ve been doing a bunch of work recently on improving the responsiveness of\nOCaml\u2019s garbage collector. I thought it would be worth discussing these\ndevelopments publicly to see if there was any useful feedback to be had on the\nideas that we\u2019re investigating.</p>"},tl:{hd:{title:"Centralizing distributed version control, revisited",slug:"centralizing-distributed-version-control-revisited",description:"7 years ago, I wrote a blogpostabout how we at Jane Street were using our distributed version control system(hg, though the story would be the same for git) ...",url:"https://blog.janestreet.com/centralizing-distributed-version-control-revisited/",date:"2015-03-04T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>7 years ago, I wrote a <a href="/centralizing-distributed-version-control/" title="Centralizing Distributed Version Control">blog\npost</a>\nabout how we at Jane Street were using our distributed version control system\n(<code class="highlighter-rouge">hg</code>, though the story would be the same for <code class="highlighter-rouge">git</code>) in a partially centralized\nway. Essentially, we built a centralized repo and a continuous integration\nsystem whose job was to merge in new changesets. The key responsibility of this\nsystem was to make sure that a change was rejected unless it merged, compiled\nand <a href="http://graydon2.dreamwidth.org/1597.html" title="The Not Rocket Science Rule">tested\ncleanly</a>.</p>'},tl:{hd:{title:"Chrome extensions: Finding the missing proof",slug:"chrome-extensions-finding-the-missing-proof",description:"Web browsers have supported customplug-ins andextensions sincethe 1990s, giving users the ability to add their own features andtools for improving workflow o...",url:"https://blog.janestreet.com/chrome-extensions-finding-the-missing-proof/",date:"2020-04-17T00:00:00-00:00",preview_image:"https://blog.janestreet.com/chrome-extensions-finding-the-missing-proof/magnifying-glass.png",body_html:'<p>Web browsers have supported custom\n<a href="https://en.wikipedia.org/wiki/NPAPI">plug-ins</a> and\n<a href="https://en.wikipedia.org/wiki/Browser_extension">extensions</a> since\nthe 1990s, giving users the ability to add their own features and\ntools for improving workflow or building closer integration with\napplications or databases running on back-end servers.</p>'},tl:{hd:{title:"Clearly Failing",slug:"clearly-failing",description:"The Parable Of The Perfect Connection",url:"https://blog.janestreet.com/clearly-failing/",date:"2014-08-23T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<h1 id="the-parable-of-the-perfect-connection">The Parable Of The Perfect Connection</h1>'},tl:{hd:{title:"Code review that isn't boring",slug:"code-review-that-isnt-boring",description:"At Jane Street, we care a lot about code review. We think that high qualitycode, and in particular, readable code, helps us maintain the safety of oursystems...",url:"https://blog.janestreet.com/code-review-that-isnt-boring/",date:"2014-06-12T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>At Jane Street, we care a lot about code review. We think that high quality\ncode, and in particular, readable code, helps us maintain the safety of our\nsystems and keeps things simple and clean enough for us to stay nimble.</p>"},tl:{hd:{title:"Commas in big numbers everywhere: An OpenType adventure",slug:"commas-in-big-numbers-everywhere-an-opentype-adventure",description:"My job involves a lot of staring at large numbers, mostly latencies innanoseconds, and picking out magnitudes like microseconds. I noticedmyself constantly c...",url:"https://blog.janestreet.com/commas-in-big-numbers-everywhere/",date:"2019-10-14T00:00:00-00:00",preview_image:"https://blog.janestreet.com/commas-in-big-numbers-everywhere/numderline_header2.png",body_html:'<p>My job involves a lot of staring at large numbers, mostly latencies in\nnanoseconds, and picking out magnitudes like microseconds. I noticed\nmyself constantly counting digits in my text editor, in my terminal,\nand in <a href="https://jupyter.org/">Jupyter</a> notebooks in my browser.</p>'},tl:{hd:{title:"Converting a code base from camlp4 to ppx",slug:"converting-a-code-base-from-camlp4-to-ppx",description:"As with many projects in the OCaml world, at Jane Street we have been working onmigrating from camlp4 to ppx. After having developed equivalent ppx rewriters...",url:"https://blog.janestreet.com/converting-a-code-base-from-camlp4-to-ppx/",date:"2015-07-08T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>As with many projects in the OCaml world, at Jane Street we have been working on\nmigrating from camlp4 to ppx. After having developed equivalent ppx rewriters\nfor our camlp4 syntax extensions, the last step is to actually translate the\ncode source of all our libraries and applications from the camlp4 syntax to the\nstandard OCaml syntax with extension points and attributes.</p>"},tl:{hd:{title:"CPU Registers and OCaml",slug:"cpu-registers-and-ocaml",description:"Even though registers are a low-level CPU concept, having some knowledge aboutthem can help write faster code. Simply put, a CPU register is a storage for as...",url:"https://blog.janestreet.com/cpu-registers-and-ocaml-2/",date:"2015-05-05T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Even though registers are a low-level CPU concept, having some knowledge about\nthem can help write faster code. Simply put, a CPU register is a storage for a\nsingle variable. CPU can keep data in memory or cache or in registers and\nregisters are often much faster. Furthermore, some operations are possible only\nwhen the data is in registers. Hence, the OCaml compiler tries to keep as many\nvariables as it can in the registers.</p>"},tl:{hd:{title:"Deep learning experiments in OCaml",slug:"deep-learning-experiments-in-ocaml",description:"Last year we held a machine learning seminar in our London office,which was an opportunity to reproduce some classical deep learningresults with a nice twist...",url:"https://blog.janestreet.com/deep-learning-experiments-in-ocaml/",date:"2018-09-20T00:00:00-00:00",preview_image:"https://blog.janestreet.com/deep-learning-experiments-in-ocaml/camel.jpg",body_html:"<p>Last year we held a machine learning seminar in our London office,\nwhich was an opportunity to reproduce some classical deep learning\nresults with a nice twist: we used OCaml as a programming language\nrather than Python. This allowed us to train models defined in a\nfunctional way in OCaml on a GPU using TensorFlow.</p>"},tl:{hd:{title:"Deep-Learning the Hardest Go Problem in the World",slug:"deep-learning-the-hardest-go-problem-in-the-world",description:"Updates and a New Run",url:"https://blog.janestreet.com/deep-learning-the-hardest-go-problem-in-the-world/",date:"2019-12-06T00:00:00-00:00",preview_image:"https://blog.janestreet.com/deep-learning-the-hardest-go-problem-in-the-world/goproblem.png",body_html:'<h2 id="updates-and-a-new-run">Updates and a New Run</h2>'},tl:{hd:{title:"Do applied programming languages research at Jane Street!",slug:"do-applied-programming-languages-research-at-jane-street",description:"As our Tools & Compilers team has grown, the kinds of projects we workon has become more ambitious. Here are some of the major things we\u2019recurrently work...",url:"https://blog.janestreet.com/applied-PL-research/",date:"2019-08-16T00:00:00-00:00",preview_image:"https://blog.janestreet.com/applied-PL-research/compiler3d.jpg",body_html:"<p>As our Tools &amp; Compilers team has grown, the kinds of projects we work\non has become more ambitious. Here are some of the major things we\u2019re\ncurrently working on:</p>"},tl:{hd:{title:"Do you love dev tools? Come work at Jane Street.",slug:"do-you-love-dev-tools-come-work-at-jane-street",description:"In the last few years, we\u2019ve spent more and more effort working on developertools, to the point where we now have a tools-and-compilers group devoted to thea...",url:"https://blog.janestreet.com/do-you-love-dev-tools-come-work-at-jane-street/",date:"2016-08-30T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>In the last few years, we\u2019ve spent more and more effort working on developer\ntools, to the point where we now have a tools-and-compilers group devoted to the\narea, for which we\u2019re actively hiring.</p>"},tl:{hd:{title:"Does batch size matter?",slug:"does-batch-size-matter",description:"This post is aimed at readers who are already familiar withstochastic gradient descent(SGD) and terms like \u201cbatch size\u201d.  For an introduction to theseideas, ...",url:"https://blog.janestreet.com/does-batch-size-matter/",date:"2017-10-31T00:00:00-00:00",preview_image:"https://blog.janestreet.com/does-batch-size-matter/batch-01.png",body_html:'<p><i>This post is aimed at readers who are already familiar with\n<a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent">stochastic gradient descent</a>\n(SGD) and terms like \u201cbatch size\u201d.  For an introduction to these\nideas, I recommend Goodfellow et al.\u2019s\n<a href="http://www.deeplearningbook.org/">Deep Learning</a>, in particular the\nintroduction and, for more about SGD, Chapter 8.  The relevance of SGD\nis that it has made it feasible to work with much more complex models\nthan was formerly possible.</i></p>'},tl:{hd:{title:"Faster OCaml to C calls",slug:"faster-ocaml-to-c-calls",description:"The official OCaml documentation \u201cInterfacing C withOCaml\u201d doesn\u2019tdocument some interesting performance features.",url:"https://blog.janestreet.com/faster-ocaml-to-c-calls/",date:"2015-04-09T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>The official OCaml documentation <a href="http://caml.inria.fr/pub/docs/manual-ocaml-4.01/intfc.html">\u201cInterfacing C with\nOCaml\u201d</a> doesn\u2019t\ndocument some interesting performance features.</p>'},tl:{hd:{title:"Finding memory leaks with Memtrace",slug:"finding-memory-leaks-with-memtrace",description:"Memory issues can be hard to track down. A function that onlyallocates a few small objects can cause a space leak if it\u2019s calledoften enough and those object...",url:"https://blog.janestreet.com/finding-memory-leaks-with-memtrace/",date:"2020-10-06T00:00:00-00:00",preview_image:"https://blog.janestreet.com/finding-memory-leaks-with-memtrace/memory-leak.jpg",body_html:"<p>Memory issues can be hard to track down. A function that only\nallocates a few small objects can cause a space leak if it\u2019s called\noften enough and those objects are never collected. Even then, many\nobjects are <em>supposed</em> to be long-lived. How can a tool, armed with data\non allocations and their lifetimes,\nhelp sort out the expected from the suspicious?</p>"},tl:{hd:{title:"Growing the Hardcaml toolset",slug:"growing-the-hardcaml-toolset",description:"I am pleased to announce that we have recently released a slew of newHardcaml libraries!",url:"https://blog.janestreet.com/growing-the-hardcaml-toolset-index/",date:"2020-12-01T00:00:00-00:00",preview_image:"https://blog.janestreet.com/growing-the-hardcaml-toolset-index/Hardcaml_blog_image_scaled.png",body_html:"<p>I am pleased to announce that we have recently released a slew of new\nHardcaml libraries!</p>"},tl:{hd:{title:"Hiring an FPGA engineer",slug:"hiring-an-fpga-engineer",description:"Jane Street is looking to hire an engineer with experience in bothsoftware and hardware design to work on FPGA-based applications, andon tools for creating s...",url:"https://blog.janestreet.com/hiring-an-fpga-engineer/",date:"2017-08-16T00:00:00-00:00",preview_image:"https://blog.janestreet.com/hiring-an-fpga-engineer/fpga_hiring.jpg",body_html:"<p>Jane Street is looking to hire an engineer with experience in both\nsoftware and hardware design to work on FPGA-based applications, and\non tools for creating such applications.</p>"},tl:{hd:{title:"How Jane Street Does Code Review (Jane Street Tech Talk)",slug:"how-jane-street-does-code-review-jane-street-tech-talk",description:"It\u2019s time for our nextJane Street Tech Talk. Whenwe\u2019ve solicited suggestions for topics, one common request has been totalk about our internal development pr...",url:"https://blog.janestreet.com/jane-street-tech-talk-how-jane-street-does-code-review/",date:"2017-10-29T00:00:00-00:00",preview_image:"https://blog.janestreet.com/jane-street-tech-talk-how-jane-street-does-code-review/image.png",body_html:'<p>It\u2019s time for our next\n<a href="https://www.janestreet.com/tech-talks/">Jane Street Tech Talk</a>. When\nwe\u2019ve solicited suggestions for topics, one common request has been to\ntalk about our internal development process. Our next talk,\n<a href="https://www.janestreet.com/tech-talks/code-review/">How Jane Street Does Code Review</a>,\nshould fit the bill. The talk is being given by our own Ian Henry, and\ndiscusses how we approach code review, and in particular how Iron, the\ncode review system we\u2019ve been using and improving for some years now,\nfits in to that process.</p>'},tl:{hd:{title:"How to Build an Exchange",slug:"how-to-build-an-exchange",description:"UPDATE: We are full up. Tons of people signed up for the talk, and we\u2019renow at the limit of what we feel like we can support in the space. Thanks forall the ...",url:"https://blog.janestreet.com/how-to-build-an-exchange/",date:"2017-01-11T00:00:00-00:00",preview_image:"https://blog.janestreet.com/how-to-build-an-exchange/build_exchange.jpg",body_html:"<p><strong>UPDATE</strong>: <em>We are full up. Tons of people signed up for the talk, and we\u2019re\nnow at the limit of what we feel like we can support in the space. Thanks for\nall the interest, and if you didn\u2019t get into this one, don\u2019t worry, we have more\ntalks coming!</em></p>"},tl:{hd:{title:"How to choose a teaching language",slug:"how-to-choose-a-teaching-language",description:"If you were teaching a programming course, what language would you teach it in?",url:"https://blog.janestreet.com/how-to-choose-a-teaching-language/",date:"2014-11-17T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>If you were teaching a programming course, what language would you teach it in?</p>"},tl:{hd:{title:"How to design a tree diffing algorithm",slug:"how-to-design-a-tree-diffing-algorithm",description:"For those of you interested in whatwhatinternsdo at Jane Street, here\u2019s apost from former internTristan Hume, on his work developing tree-diffing algorithms ...",url:"https://blog.janestreet.com/how-to-design-a-tree-diffing-algorithm/",date:"2017-08-25T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>For those of you interested in what\n<a href="/what-the-interns-have-wrought-rpc_parallel-and-core_profiler">what</a>\n<a href="/what-the-interns-have-wrought-2016">interns</a>\n<a href="/what-the-interns-have-wrought-2017">do</a> at Jane Street, here\u2019s a\n<a href="http://thume.ca/2017/06/17/tree-diffing/">post</a> from former intern\nTristan Hume, on his work developing tree-diffing algorithms last\nsummer at Jane Street. It\u2019s a fun (and very detailed!) read.</p>'},tl:{hd:{title:"How to shuffle a big dataset",slug:"how-to-shuffle-a-big-dataset",description:"At Jane Street, we often work with data that has a very lowsignal-to-noise ratio, but fortunately we also have a lot of data.Where practitioners in many fiel...",url:"https://blog.janestreet.com/how-to-shuffle-a-big-dataset/",date:"2018-09-26T00:00:00-00:00",preview_image:"https://blog.janestreet.com/how-to-shuffle-a-big-dataset/shuffle_zoom.png",body_html:'<p>At Jane Street, we often work with data that has a very low\nsignal-to-noise ratio, but fortunately we also have a <em>lot</em> of data.\nWhere practitioners in many fields might be accustomed to\nhaving tens or hundreds of thousands of correctly labeled\nexamples, some of our problems are more like having a billion training\nexamples whose labels have only a slight tendency to be correct.\nThese large datasets present a number of interesting engineering\nchallenges.  The one we address here: <em>How do you shuffle a really\nlarge dataset?</em>  (If you\u2019re not familiar with why one might need this,\njump to the section <a href="#whyshuffle">Why shuffle</a> below.)</p>'},tl:{hd:{title:"Incremental computation and the web",slug:"incremental-computation-and-the-web",description:"I\u2019ve recently been thinking about the world of JavaScript and web applications.That\u2019s odd for me, since I know almost nothing about the web. Indeed, JaneStre...",url:"https://blog.janestreet.com/incrementality-and-the-web/",date:"2016-01-30T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>I\u2019ve recently been thinking about the world of JavaScript and web applications.\nThat\u2019s odd for me, since I know almost nothing about the web. Indeed, Jane\nStreet\u2019s use of web technologies is quite minimal \u2013 nearly all of our user\ninterfaces are text based, and all told we\u2019ve been pretty happy with that.</p>"},tl:{hd:{title:"Inspecting Internal TCP State on Linux",slug:"inspecting-internal-tcp-state-on-linux",description:"Sometimes it can be useful to inspect the state of a TCP endpoint. Things suchas the current congestion window, the retransmission timeout (RTO), duplicateac...",url:"https://blog.janestreet.com/inspecting-internal-tcp-state-on-linux/",date:"2014-07-09T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Sometimes it can be useful to inspect the state of a TCP endpoint. Things such\nas the current congestion window, the retransmission timeout (RTO), duplicate\nack threshold, etc. are not reflected in the segments that flow over the wire.\nTherefore, just looking at packet captures can leave you scratching your head as\nto why a TCP connection is behaving a certain way.</p>"},tl:{hd:{title:"Inspecting the Environment of a Running Process",slug:"inspecting-the-environment-of-a-running-process",description:"Sometimes its useful to be able see the values of environment variables inrunning processes. We can use the following test program to see how well we canacco...",url:"https://blog.janestreet.com/inspecting-the-environment-of-a-running-process/",date:"2014-12-01T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Sometimes its useful to be able see the values of environment variables in\nrunning processes. We can use the following test program to see how well we can\naccomplish this:</p>"},tl:{hd:{title:"Interviewing At Jane Street",slug:"interviewing-at-jane-street",description:"Software Engineering Interviews at Jane Street",url:"https://blog.janestreet.com/interviewing-at-jane-street/",date:"2014-10-24T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<h1 id="software-engineering-interviews-at-jane-street">Software Engineering Interviews at Jane Street</h1>'},tl:{hd:{title:"Introducing Incremental",slug:"introducing-incremental",description:"I\u2019m pleased to announce the release ofIncremental (wellcommented mlihere),a powerful library for building self-adjusting computations, i.e.,computations that...",url:"https://blog.janestreet.com/introducing-incremental/",date:"2015-07-18T00:00:00-00:00",preview_image:"https://blog.janestreet.com/introducing-incremental/introducing_incremental.png",body_html:'<p>I\u2019m pleased to announce the release of\n<a href="https://github.com/janestreet/incremental">Incremental</a> (well\ncommented mli\n<a href="https://github.com/janestreet/incremental/blob/master/src/incremental_intf.ml">here</a>),\na powerful library for building <em>self-adjusting computations</em>, <em>i.e.</em>,\ncomputations that can be updated efficiently when their inputs change.</p>'},tl:{hd:{title:"Iron out your release process",slug:"iron-out-your-release-process",description:"This is the third in a series of posts about the design of Iron, our new codereview and release management tool. The other two postsare hereand here.",url:"https://blog.janestreet.com/ironing-out-your-release-process/",date:"2014-06-24T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p><em>This is the third in a series of posts about the design of Iron, our new code\nreview and release management tool. The other two posts\nare <a href="/code-review-that-isnt-boring/">here</a>\nand <a href="/scrutinizing-your-code-in-style/">here</a>.</em></p>'},tl:{hd:{title:"Ironing out your development style",slug:"ironing-out-your-development-style",description:"People seem to enjoy talking about programming methodologies. Theygive them cute names, likeeXtreme programming,Agile, andScrum; runconferences and buildcomm...",url:"https://blog.janestreet.com/ironing-out-your-development-style/",date:"2017-08-24T00:00:00-00:00",preview_image:"https://blog.janestreet.com/ironing-out-your-development-style/story.jpg",body_html:'<p>People seem to enjoy talking about programming methodologies. They\ngive them cute names, like\n<a href="http://www.extremeprogramming.org/">eXtreme programming</a>,\n<a href="https://www.agilealliance.org/">Agile</a>, and\n<a href="https://www.scrum.org/resources/what-is-scrum">Scrum</a>; run\n<a href="https://www.scrumalliance.org/sgcal">conferences</a> and build\n<a href="https://www.scrumalliance.org/community">communities</a> around them;\nwrite\n<a href="https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0321278658/ref=sr_1_1?ie=UTF8&amp;qid=1503346126&amp;sr=8-1&amp;keywords=extreme+programming">books</a>\nthat describe how to use them in excruciating detail; and\n<a href="http://agilemanifesto.org/">manifestos</a> that lay out their\nphilosophy.</p>'},tl:{hd:{title:"Jane Street Tech Talk, Verifying Network Data Planes",slug:"jane-street-tech-talk-verifying-network-data-planes",description:"After a summer hiatus, the Jane Street Tech Talks series is back onfor the fall! Last we left it, our very own Dominick LoBraicopresented on the evolution of...",url:"https://blog.janestreet.com/jane-street-tech-talk-verifying-network-data-planes/",date:"2017-09-26T00:00:00-00:00",preview_image:"https://blog.janestreet.com/jane-street-tech-talk-verifying-network-data-planes/tech-talk-nate-foster.png",body_html:'<p>After a summer hiatus, the Jane Street Tech Talks series is back on\nfor the fall! Last we left it, our very own Dominick LoBraico\npresented on the evolution of our internal configuration methodology\nand the systems that support it. For anybody that missed it, you can\ncheck out a recording of the talk <a href="https://www.youtube.com/watch?v=0pX7-AG52BU">on YouTube</a>.</p>'},tl:{hd:{title:"Jane Street Tech Talks: Verifying Puppet Configs",slug:"jane-street-tech-talks-verifying-puppet-configs",description:"Our first Jane Street Tech Talk went really well!Thanks to everyone who came and made it a fun event.",url:"https://blog.janestreet.com/jane-street-tech-talks-verifying-puppet-configs/",date:"2017-02-16T00:00:00-00:00",preview_image:"https://blog.janestreet.com/jane-street-tech-talks-verifying-puppet-configs/untangling_puppet.jpg",body_html:'<p>Our first <a href="/how-to-build-an-exchange/">Jane Street Tech Talk</a> went really well!\nThanks to everyone who came and made it a fun event.</p>'},tl:{hd:{title:"L2 Regularization and Batch Norm",slug:"l2-regularization-and-batch-norm",description:"This blog post is about an interesting detail about machine learningthat I came across as a researcher at Jane Street - that of the interaction between L2 re...",url:"https://blog.janestreet.com/l2-regularization-and-batch-norm/",date:"2019-01-29T00:00:00-00:00",preview_image:"https://blog.janestreet.com/l2-regularization-and-batch-norm/l2-batch-norm_19b.png",body_html:"<p>This blog post is about an interesting detail about machine learning\nthat I came across as a researcher at Jane Street - that of the \ninteraction between L2 regularization, also known as\nweight decay, and batch normalization.</p>"},tl:{hd:{title:"Learn OCaml in NYC",slug:"learn-ocaml-in-nyc",description:"Interested in learning OCaml? In the NYC area? Then this mightbe for you!",url:"https://blog.janestreet.com/learn-ocaml-nyc/",date:"2018-02-16T00:00:00-00:00",preview_image:"https://blog.janestreet.com/learn-ocaml-nyc/ocaml_workshop.jpg",body_html:"<p>Interested in learning OCaml? In the NYC area? Then this might\nbe for you!</p>"},tl:{hd:{title:"Learning ML Depth-First",slug:"learning-ml-depth-first",description:"If you haven\u2019t heard of it, Depth FirstLearning is awonderful resource for learning about machine learning.",url:"https://blog.janestreet.com/learning-ml-depth-first/",date:"2019-04-17T00:00:00-00:00",preview_image:"https://blog.janestreet.com/learning-ml-depth-first/Depth_First_Realigned.svg",body_html:'<p>If you haven\u2019t heard of it, <a href="https://www.depthfirstlearning.com/2018/DFL-Fellowship">Depth First\nLearning</a> is a\nwonderful resource for learning about machine learning.</p>'},tl:{hd:{title:"Let syntax, and why you should use it",slug:"let-syntax-and-why-you-should-use-it",description:"Earlier this year, we createda ppx_let, a PPX rewriter thatintroduces a syntax for working with monadic and applicative libraries likeCommand, Async, Result ...",url:"https://blog.janestreet.com/let-syntax-and-why-you-should-use-it/",date:"2016-06-21T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>Earlier this year, we created\na <a href="http://github.com/janestreet/ppx_let">ppx_let</a>, a PPX rewriter that\nintroduces a syntax for working with monadic and applicative libraries like\nCommand, Async, Result and Incremental. We\u2019ve now amassed about six months of\nexperience with it, and we\u2019ve now seen enough to recommend it to a wider\naudience.</p>'},tl:{hd:{title:"Looking for a technical writer",slug:"looking-for-a-technical-writer",description:"Update: I\u2019m excited to say that we\u2019ve now hired a (great!) technicalwriter, so the position is closed.",url:"https://blog.janestreet.com/looking-for-a-technical-writer/",date:"2017-05-01T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p><em>Update: I\u2019m excited to say that we\u2019ve now hired a (great!) technical\nwriter, so the position is closed.</em></p>"},tl:{hd:{title:"Machining the ultimate hackathon prize",slug:"machining-the-ultimate-hackathon-prize",description:"Jane Street is sponsoring this year\u2019s MakeMIThackathon, and we wanted to create a prize forthe winners that would do justice to the maker spirit of thecompet...",url:"https://blog.janestreet.com/hackathon-keyboards/",date:"2019-02-28T00:00:00-00:00",preview_image:"https://blog.janestreet.com/hackathon-keyboards/keyboard.jpg",body_html:'<p>Jane Street is sponsoring this year\u2019s <a href="https://makemit.org">MakeMIT\nhackathon</a>, and we wanted to create a prize for\nthe winners that would do justice to the maker spirit of the\ncompetition. As makers ourselves \u2013 it\u2019s not unusual to find a\n\u201csoftware\u201d engineer here who hacks on FPGAs or who has a CNC machine\nat home \u2013 it felt natural to get our hands dirty.</p>'},tl:{hd:{title:"Making making better",slug:"making-making-better",description:"We spend a lot of time and effort on training new people, and it never stops forlong. Right now our winter-intern class is ending; in five months we\u2019ll have ...",url:"https://blog.janestreet.com/making-making-better/",date:"2015-01-31T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>We spend a lot of time and effort on training new people, and it never stops for\nlong. Right now our winter-intern class is ending; in five months we\u2019ll have a\nslew of new interns to get up to speed, and a few months after that we\u2019ll have\nan incoming class of new hires.</p>"},tl:{hd:{title:"Making \u201cnever break the build\u201d scale",slug:"making-never-break-the-build-scale",description:"I just stumbled across a post fromearlier this year by Graydon Hoare, of Rust fame.The post is about what he calls the \u201cNot Rocket Science Rule\u201d, which says ...",url:"https://blog.janestreet.com/making-never-break-the-build-scale/",date:"2014-07-06T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>I just stumbled across a <a href="http://graydon2.dreamwidth.org/1597.html">post</a> from\nearlier this year by Graydon Hoare, of <a href="http://www.rust-lang.org/">Rust</a> fame.\nThe post is about what he calls the \u201cNot Rocket Science Rule\u201d, which says that\nyou should automatically maintain a repository that never fails its tests. The\nadvantages of the NRS rule are pretty clear. By ensuring that you never break\nthe build, you shield people from having to deal with bugs that could easily\nhave been caught automatically.</p>'},tl:{hd:{title:"Memory allocator showdown",slug:"memory-allocator-showdown",description:"Since version 4.10, OCaml offers a new best-fit memory allocatoralongside its existing default, the next-fit allocator. At JaneStreet, we\u2019ve seen a big impro...",url:"https://blog.janestreet.com/memory-allocator-showdown/",date:"2020-09-15T00:00:00-00:00",preview_image:"https://blog.janestreet.com/memory-allocator-showdown/MemoryAllocator.jpg",body_html:"Since version 4.10, OCaml offers a new best-fit memory allocator\nalongside its existing default, the next-fit allocator. At Jane\nStreet, we've seen a big improvement after switching over to the new\nallocator.\n\nThis post isn't about how the new allocator works. For that, the best\nsource is these notes from a talk by its\nauthor.  Instead, this post is about just how tricky it is to compare two\nallocators in a reasonable way, especially for a garbage-collected\nsystem."},tl:{hd:{title:"No (functional) experience required",slug:"no-functional-experience-required",description:"Jane Street is a serious functional programming shop. We use OCaml, a staticallytyped functional language for almost everything and have what is probably the...",url:"https://blog.janestreet.com/no-functional-experience-required/",date:"2015-08-19T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Jane Street is a serious functional programming shop. We use OCaml, a statically\ntyped functional language for almost everything and have what is probably the\nlargest OCaml codebase anywhere.</p>"},tl:{hd:{title:"Notes on Naming",slug:"notes-on-naming",description:"I\u2019ve been thinking about naming recently, specifically the naming of newsystems. It\u2019s tempting to think of naming as trivial, but it really does matter.In a ...",url:"https://blog.janestreet.com/notes-on-naming/",date:"2014-06-29T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>I\u2019ve been thinking about naming recently, specifically the naming of new\nsystems. It\u2019s tempting to think of naming as trivial, but it really does matter.\nIn a technology driven organization, names are part of how you communicate about\nthe purpose and nature of your systems. And that communication matters more as\nthe number of people and systems grows.</p>"},tl:{hd:{title:"Observations of a functional programmer",slug:"observations-of-a-functional-programmer",description:"I was recently invited to do the keynote at the Commercial Users of FunctionalProgramming workshop, a 15-year-old gathering which isattached to ICFP, the pri...",url:"https://blog.janestreet.com/observations-of-a-functional-programmer/",date:"2016-10-27T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>I was recently invited to do the keynote at the <a href="http://cufp.org/2016/">Commercial Users of Functional\nProgramming</a> workshop, a 15-year-old gathering which is\nattached to ICFP, the primary academic functional programming conference.</p>'},tl:{hd:{title:"OCaml 4.03: Everything else",slug:"ocaml-403-everything-else",description:"In my previous post I wrote about Flambda, which is the singlebiggest feature coming to OCaml in this release. In this post, I\u2019ll review theother features of...",url:"https://blog.janestreet.com/ocaml-4-03-everything-else/",date:"2016-03-01T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>In my <a href="/flambda">previous post</a> I wrote about Flambda, which is the single\nbiggest feature coming to OCaml in this release. In this post, I\u2019ll review the\nother features of 4.03 that caught my eye.</p>'},tl:{hd:{title:"OCaml all the way down",slug:"ocaml-all-the-way-down",description:"One of the joys of working at Jane Street for the last 15 or so yearshas been seeing how our software stack has grown in scope. When Istarted, I was building...",url:"https://blog.janestreet.com/ocaml-all-the-way-down/",date:"2018-04-04T00:00:00-00:00",preview_image:"https://blog.janestreet.com/ocaml-all-the-way-down/fpga.jpg",body_html:"<p>One of the joys of working at Jane Street for the last 15 or so years\nhas been seeing how our software stack has grown in scope. When I\nstarted, I was building pretty narrowly focused systems for doing\nstatistical research on trading strategies, and then building systems\nfor executing those same strategies.</p>"},tl:{hd:{title:"Of Pythons and Camels",slug:"of-pythons-and-camels",description:"Welcome to another post in our series of how to use OCaml for machine learning.In previous posts we\u2019ve discussed artistic style-transfer andreinforcement lea...",url:"https://blog.janestreet.com/of-pythons-and-camels/",date:"2019-07-09T00:00:00-00:00",preview_image:"https://blog.janestreet.com/of-pythons-and-camels/camel-identify.jpg",body_html:'<p>Welcome to another post in our series of how to use OCaml for machine learning.\nIn previous posts we\u2019ve discussed <a href="https://blog.janestreet.com/deep-learning-experiments-in-ocaml/">artistic style-transfer</a> and\n<a href="https://blog.janestreet.com/playing-atari-games-with-ocaml-and-deep-rl/">reinforcement learning</a>. If you haven\u2019t read these feel\nfree to do so now, we\u2019ll wait right here until you\u2019re done. Ready? Ok, let\u2019s\ncontinue \u2026</p>'},tl:{hd:{title:"One more talk, two more videos",slug:"one-more-talk-two-more-videos",description:"I\u2019m happy to announce our next public techtalk, called SevenImplementations of Incremental, on Wednesday, April 5th, presented by yourstruly. You can registe...",url:"https://blog.janestreet.com/one-more-talk-two-more-videos/",date:"2017-03-15T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>I\u2019m happy to announce our next <a href="https://events.janestreet.com/home/tech-talks/">public tech\ntalk</a>, called <strong>Seven\nImplementations of Incremental</strong>, on Wednesday, April 5th, presented by yours\ntruly. You can register\n<a href="https://docs.google.com/forms/d/e/1FAIpQLSdtly4y-jYcLUVH8BJS-uKoiaKrQlRXSIWZeczw3tgwTx_6HA/viewform?c=0&amp;w=1">here</a>.</p>'},tl:{hd:{title:"Plans for OCaml 4.08",slug:"plans-for-ocaml-408",description:"With the external release of OCaml 4.07.0 imminent, we in Jane Street\u2019sTools & Compilers group have been planning what we want to work on forinclusion in...",url:"https://blog.janestreet.com/plans-for-ocaml-408/",date:"2018-06-29T00:00:00-00:00",preview_image:"https://blog.janestreet.com/plans-for-ocaml-408/ocaml_release.jpg",body_html:"<p>With the external release of OCaml 4.07.0 imminent, we in Jane Street\u2019s\nTools &amp; Compilers group have been planning what we want to work on for\ninclusion in OCaml 4.08. These days OCaml uses (or at least attempts) a\ntime-based release process with releases scheduled every 6 months. We\u2019re\ntrying to avoid rushing in changes at the last minute \u2013 as we\u2019ve been\nprone to do in the past \u2013 so this list is restricted to things we could\nconceivably finish in the next 4-5 months.</p>"},tl:{hd:{title:"Playing Atari Games with OCaml and Deep Reinforcement Learning",slug:"playing-atari-games-with-ocaml-and-deep-reinforcement-learning",description:"In a previous blog postwe detailed how we used OCaml to reproduce some classical deep-learning resultsthat would usually be implemented in Python. Here we wi...",url:"https://blog.janestreet.com/playing-atari-games-with-ocaml-and-deep-rl/",date:"2019-02-02T00:00:00-00:00",preview_image:"https://blog.janestreet.com/playing-atari-games-with-ocaml-and-deep-rl/atari.jpg",body_html:'<p>In a <a href="https://blog.janestreet.com/deep-learning-experiments-in-ocaml/">previous blog post</a>\nwe detailed how we used OCaml to reproduce some classical deep-learning results\nthat would usually be implemented in Python. Here we will do the same with\nsome Reinforcement Learning (RL) experiments.</p>'},tl:{hd:{title:"Proofs (and Refutations) using Z3",slug:"proofs-and-refutations-using-z3",description:"People often think of formal methods and theorem provers as forbiddingtools, cool in theory but with a steep learning curve that makes themhard to use in rea...",url:"https://blog.janestreet.com/proofs-and-refutations-using-z3/",date:"2018-02-15T00:00:00-00:00",preview_image:"https://blog.janestreet.com/proofs-and-refutations-using-z3/proof.jpg",body_html:"<p>People often think of formal methods and theorem provers as forbidding\ntools, cool in theory but with a steep learning curve that makes them\nhard to use in real life. In this post, we\u2019re going to describe a case\nwe ran into recently where we were able to leverage theorem proving\ntechnology, Z3 in particular, to validate some real world engineering\nwe were doing on the OCaml compiler. This post is aimed at readers\ninterested in compilers, but assumes no familiarity with actual\ncompiler development.</p>"},tl:{hd:{title:"Putting the I back in IDE: Towards a Github Explorer",slug:"putting-the-i-back-in-ide-towards-a-github-explorer",description:"Imagine a system for editing and reviewing code where:",url:"https://blog.janestreet.com/putting-the-i-back-in-ide-towards-a-github-explorer/",date:"2018-03-27T00:00:00-00:00",preview_image:"https://blog.janestreet.com/putting-the-i-back-in-ide-towards-a-github-explorer/postimage.jpg",body_html:"<p>Imagine a system for editing and reviewing code where:</p>"},tl:{hd:{title:"Quickcheck for Core",slug:"quickcheck-for-core",description:"Automated testing is a powerful tool for finding bugs and specifying correctnessproperties of code. Haskell\u2019s Quickcheck library is the most well-knownautoma...",url:"https://blog.janestreet.com/quickcheck-for-core/",date:"2015-10-26T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Automated testing is a powerful tool for finding bugs and specifying correctness\nproperties of code. Haskell\u2019s Quickcheck library is the most well-known\nautomated testing library, based on over 15 years of research into how to write\nproperty-base tests, generate useful sources of inputs, and report manageable\ncounterexamples. Jane Street\u2019s Core library has not had anything comparable up\nuntil now; version 113.00 of Core finally has a version of Quickcheck,\nintegrating automated testing with our other facilities like s-expression\nreporting for counterexample values, and support for asynchronous tests using\nAsync.</p>"},tl:{hd:{title:"Reading Lamport, again",slug:"reading-lamport-again",description:"We\u2019ve just kicked off an internal distributed-systems seminar. Our inaugralpaper was Lamport\u2019s classic \u201cTime, Clocks and the Ordering of Events in aDistribut...",url:"https://blog.janestreet.com/reading-lamport-again/",date:"2014-06-26T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>We\u2019ve just kicked off an internal distributed-systems seminar. Our inaugral\npaper was Lamport\u2019s classic <a href="http://web.stanford.edu/class/cs240/readings/lamport.pdf">\u201cTime, Clocks and the Ordering of Events in a\nDistributed System\u201d</a>.\nI remembered the paper fondly, but hadn\u2019t looked back it it for more than a\ndecade.</p>'},tl:{hd:{title:"Real world machine learning (part 1)",slug:"real-world-machine-learning-part-1",description:"Trading is a competitive business. You need great people and greattechnology, of course, but also trading strategies that make money.Where do those strategie...",url:"https://blog.janestreet.com/real-world-machine-learning-part-1/",date:"2017-08-28T00:00:00-00:00",preview_image:"https://blog.janestreet.com/real-world-machine-learning-part-1/inverse_colors.gif",body_html:"<p>Trading is a competitive business. You need great people and great\ntechnology, of course, but also trading strategies that make money.\nWhere do those strategies come from? In this post we\u2019ll discuss how\nthe interplay of data, math and technology informs how we develop and\nrun strategies.</p>"},tl:{hd:{title:"Really low latency multipliers and cryptographic puzzles",slug:"really-low-latency-multipliers-and-cryptographic-puzzles",description:"At Jane Street, we have some experience using FPGAs for low-latencysystems\u2013FPGAs are programmable hardware where you get the speed of anapplication-specific ...",url:"https://blog.janestreet.com/really-low-latency-multipliers-and-cryptographic-puzzles/",date:"2020-06-22T00:00:00-00:00",preview_image:"https://blog.janestreet.com/really-low-latency-multipliers-and-cryptographic-puzzles/lock.png",body_html:"<p>At Jane Street, we have some experience using FPGAs for low-latency\nsystems\u2013FPGAs are programmable hardware where you get the speed of an\napplication-specific integrated circuit (ASIC) but without being\ncommitted to a design that\u2019s burned into the chip. It wasn\u2019t so long\nago that FPGAs were expensive and rare, but these days, you can rent a\n$5,000 card on the Amazon AWS cloud for less than $3 an hour.</p>"},tl:{hd:{title:"Repeatable exploratory programming",slug:"repeatable-exploratory-programming",description:"Expect tests are a technique I\u2019ve written aboutbefore, but until recently, it\u2019s been alittle on the theoretical side. That\u2019s because it\u2019s been hard to taketh...",url:"https://blog.janestreet.com/repeatable-exploratory-programming/",date:"2018-04-22T00:00:00-00:00",preview_image:"https://blog.janestreet.com/repeatable-exploratory-programming/lambdasoup.jpg",body_html:'<p>Expect tests are a technique I\u2019ve written about\n<a href="/testing-with-expectations">before</a>, but until recently, it\u2019s been a\nlittle on the theoretical side. That\u2019s because it\u2019s been hard to take\nthese ideas out for a spin due to lack of tooling outside of Jane\nStreet\u2019s walls.</p>'},tl:{hd:{title:"Reverse web proxy in ~50 lines of BASH",slug:"reverse-web-proxy-in-50-lines-of-bash",description:"In the spirit of reinventing the wheel for fun, I hacked this together as aquick challenge to myself last week. It\u2019s a little rough around the edges, but Ith...",url:"https://blog.janestreet.com/reverse-web-proxy-in-50-lines-of-bash/",date:"2015-05-01T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>In the spirit of reinventing the wheel for fun, I hacked this together as a\nquick challenge to myself last week. It\u2019s a little rough around the edges, but I\nthought it was too cute not to share. If you have any bug fixes, please post\nthem in the comments.</p>"},tl:{hd:{title:"rsync rounds timestamps to the nearest second",slug:"rsync-rounds-timestamps-to-the-nearest-second",description:"I\u2019m not sure how I\u2019ve managed to use rsync for so many years without evernoticing this, but hey, you learn something new every day!",url:"https://blog.janestreet.com/rsync-rounds-timestamps-to-the-nearest-second/",date:"2015-10-07T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>I\u2019m not sure how I\u2019ve managed to use rsync for so many years without ever\nnoticing this, but hey, you learn something new every day!</p>"},tl:{hd:{title:"Scrutinize your code in style",slug:"scrutinize-your-code-in-style",description:"This is the second in a series of posts about the design of Iron, our new codereview tool. You can read the first post here.Also, I should give credit where ...",url:"https://blog.janestreet.com/scrutinizing-your-code-in-style/",date:"2014-06-13T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p><em>This is the second in a series of posts about the design of Iron, our new code\nreview tool. You can read the first post <a href="/code-review-that-isnt-boring/">here</a>.\nAlso, I should give credit where credit is due. While I\u2019ve been involved in some\nof the design discussions, the real work has been done by Stephen Weeks,\nValentin Gatien Baron, Olin Shivers (yes, that Olin Shivers. He\u2019s joining us for\npart of his sabbatical) and Mathieu Barbin.</em></p>'},tl:{hd:{title:"Self Adjusting DOM and Diffable Data",slug:"self-adjusting-dom-and-diffable-data",description:"In my last post, I gave some simple examples showing howyou could useself adjusting computations,or SAC, as embodied by our Incremental library, toincrementa...",url:"https://blog.janestreet.com/self-adjusting-dom-and-diffable-data/",date:"2016-02-10T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>In my last <a href="/self-adjusting-dom/">post</a>, I gave some simple examples showing how\nyou could use\n<a href="http://www.umut-acar.org/self-adjusting-computation">self adjusting computations</a>,\nor SAC, as embodied by our <a href="/introducing-incremental/">Incremental</a> library, to\nincrementalize the computation of virtual dom nodes. In this post, I\u2019d like to\ndiscuss how we can extend this approach to more realistic scales, and some of\nthe extensions to Incremental itself that are required to get there.</p>'},tl:{hd:{title:"Self Adjusting DOM",slug:"self-adjusting-dom",description:"I\u2019ve been thinking recently about how tostructure dynamic web applications, and in particular about the role thatincremental computation should play.",url:"https://blog.janestreet.com/self-adjusting-dom/",date:"2016-02-06T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>I\u2019ve been <a href="/incrementality-and-the-web/">thinking recently</a> about how to\nstructure dynamic web applications, and in particular about the role that\nincremental computation should play.</p>'},tl:{hd:{title:"Seven Implementations of Incremental",slug:"seven-implementations-of-incremental",description:"We finally got a decent recording of one of my favorite talks. This one is aboutour Incremental library (which Iwrote about here), and in particular about th...",url:"https://blog.janestreet.com/seven-implementations-of-incremental/",date:"2016-03-09T00:00:00-00:00",preview_image:"https://blog.janestreet.com/seven-implementations-of-incremental/ron-photo.jpg",body_html:'<p>We finally got a decent recording of one of my favorite talks. This one is about\nour <a href="https://github.com/janestreet/incremental">Incremental</a> library (which I\nwrote about <a href="/introducing-incremental/">here</a>), and in particular about the\nstory of how we got to the present, quite performant, implementation.</p>'},tl:{hd:{title:"Simple top-down development in OCaml",slug:"simple-top-down-development-in-ocaml",description:"Often when writing a new module, I want to write the interface first and savethe implementation for later. This lets me use the module as a black box,extendi...",url:"https://blog.janestreet.com/simple-top-down-development-in-ocaml/",date:"2014-07-18T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Often when writing a new module, I want to write the interface first and save\nthe implementation for later. This lets me use the module as a black box,\nextending the interface as needed to support the rest of the program. When\neverything else is finished, I can fill in the implementation, knowing the full\ninterface I need to support. Of course sometimes the implementation needs to\npush back on the interface \u2013 this pattern isn\u2019t an absolute \u2013 but it\u2019s certainly\na useful starting point. The trick is getting the program to compile at\nintermediate stages when the implementation hasn\u2019t been filled in.</p>"},tl:{hd:{title:"Testing with expectations",slug:"testing-with-expectations",description:"Testing is important, and it\u2019s hard to get people to do as much of it as theyshould. Testing tools matter because the smoother the process is, the more tests...",url:"https://blog.janestreet.com/testing-with-expectations/",date:"2015-12-02T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Testing is important, and it\u2019s hard to get people to do as much of it as they\nshould. Testing tools matter because the smoother the process is, the more tests\npeople will write.</p>"},tl:{hd:{title:"The Jane Street Interview Process &mdash; 2020 Edition",slug:"the-jane-street-interview-process-mdash-2020-edition",description:"We\u2019re busy preparing for our software engineering fall hiringseason. Over the years we\u2019vedone our best to make our interview process more transparent tocandi...",url:"https://blog.janestreet.com/jane-street-interview-process-2020/",date:"2020-07-24T00:00:00-00:00",preview_image:"https://blog.janestreet.com/jane-street-interview-process-2020/ocaml_code.png",body_html:'<p>We\u2019re busy preparing for our software engineering <a href="https://blog.janestreet.com/unraveling/">fall hiring\nseason</a>. Over the years we\u2019ve\ndone our best to make our interview process more transparent to\ncandidates. While many candidates show up knowing something about what\nour interviews look like, much of the information floating around on\nthe internet is outdated or wrong. These past few months have also\nchanged a lot about the process as we\u2019ve adapted to working from home\nand other effects of COVID-19.</p>'},tl:{hd:{title:"The ML Workshop looks fantastic",slug:"the-ml-workshop-looks-fantastic",description:"I\u2019m a little biased, by being on the steering committee, but this year\u2019s MLworkshop looks really interesting. Here\u2019s a link to the program:",url:"https://blog.janestreet.com/the-ml-workshop-looks-fantastic/",date:"2014-07-31T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>I\u2019m a little biased, by being on the steering committee, but this year\u2019s ML\nworkshop looks really interesting. Here\u2019s a link to the program:</p>"},tl:{hd:{title:"Thoughts from AAAI 2019",slug:"thoughts-from-aaai-2019",description:"At Jane Street, for the last several years, we have been increasingly interestedin machine learning and its many use cases. This is why it was exciting whene...",url:"https://blog.janestreet.com/thoughts-from-aaai-19/",date:"2019-05-13T00:00:00-00:00",preview_image:"https://blog.janestreet.com/thoughts-from-aaai-19/AAAI.jpg",body_html:"<p>At Jane Street, for the last several years, we have been increasingly interested\nin machine learning and its many use cases. This is why it was exciting when\nearlier this year myself and a few of my colleagues had the opportunity to\nattend the AAAI 2019 conference. We\u2019d like to take this space to share with you\nsome of the interesting projects and themes we saw at the conference.</p>"},tl:{hd:{title:"Trivial meta-programming with cinaps",slug:"trivial-meta-programming-with-cinaps",description:"From now and then, I found myself having to write some mechanical and repetitivecode. The usual solution for this is to write a code generator; for instance ...",url:"https://blog.janestreet.com/trivial-meta-programming-with-cinaps/",date:"2017-03-20T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>From now and then, I found myself having to write some mechanical and repetitive\ncode. The usual solution for this is to write a code generator; for instance in\nthe form of a ppx rewriter in the case of OCaml code. This however comes with a\ncost: code generators are harder to review than plain code and it is a new\nsyntax to learn for other developers. So when the repetitive pattern is local to\na specific library or not widely used, it is often not worth the effort.\nEspecially if the code in question is meant to be reviewed and maintained by\nseveral people.</p>"},tl:{hd:{title:"Troubleshooting systemd with SystemTap",slug:"troubleshooting-systemd-with-systemtap",description:"When we set up a schedule on a computer, such as a list of commands torun every day at particular times via Linux cronjobs, weexpect that schedule to execute...",url:"https://blog.janestreet.com/troubleshooting-systemd-with-systemtap/",date:"2020-02-03T00:00:00-00:00",preview_image:"https://blog.janestreet.com/troubleshooting-systemd-with-systemtap/data-taps.jpg",body_html:'<p>When we set up a schedule on a computer, such as a list of commands to\nrun every day at particular times via Linux <a href="https://www.ostechnix.com/a-beginners-guide-to-cron-jobs">cron\njobs</a>, we\nexpect that schedule to execute reliably.  Of course we\u2019ll check the\nlogs to see whether the job has failed, but we never question whether\nthe cron daemon itself will function.  We always assume that it will,\nas it always has done; we are not expecting mutiny in the ranks of the\noperating system.</p>'},tl:{hd:{title:"Unraveling of the tech hiring market",slug:"unraveling-of-the-tech-hiring-market",description:"Recruiting talented people has always been challenging.",url:"https://blog.janestreet.com/unraveling/",date:"2016-08-31T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Recruiting talented people has always been challenging.</p>"},tl:{hd:{title:"Using ASCII waveforms to test hardware designs",slug:"using-ascii-waveforms-to-test-hardware-designs",description:"At Jane Street, an \u201cexpecttest\u201d is atest where you don\u2019t manually write the output you\u2019d like to checkyour code against \u2013 instead, this output is captured au...",url:"https://blog.janestreet.com/using-ascii-waveforms-to-test-hardware-designs/",date:"2020-06-01T00:00:00-00:00",preview_image:"https://blog.janestreet.com/using-ascii-waveforms-to-test-hardware-designs/scientist_testing.jpg",body_html:'<p>At Jane Street, an <a href="https://blog.janestreet.com/testing-with-expectations">\u201cexpect\ntest\u201d</a> is a\ntest where you don\u2019t manually write the output you\u2019d like to check\nyour code against \u2013 instead, this output is captured automatically\nand inserted by a tool into the testing code itself. If further runs\nproduce different output, the test fails, and you\u2019re presented with\nthe diff.</p>'},tl:{hd:{title:"Using OCaml to drive a Raspberry Pi robot car",slug:"using-ocaml-to-drive-a-raspberry-pi-robot-car",description:"Back when the Raspberry Pi was first released in 2012 Michael Bacarella wrotea blog poston using OCaml and Async on this little device.Since then installing ...",url:"https://blog.janestreet.com/using-ocaml-to-drive-a-raspberry-pi-robot-car/",date:"2019-08-19T00:00:00-00:00",preview_image:"https://blog.janestreet.com/using-ocaml-to-drive-a-raspberry-pi-robot-car/robot-pi.jpg",body_html:'<p>Back when the Raspberry Pi was first released in 2012 Michael Bacarella wrote\na <a href="https://blog.janestreet.com/bootstrapping-ocamlasync-on-the-raspberry-pi/">blog post</a>\non using OCaml and Async on this little device.\nSince then installing OCaml via opam has become a pretty smooth experience\nand everything works out of the box when using Raspbian \u2013 the default Raspberry Pi\ndistribution.</p>'},tl:{hd:{title:"Using Python and OCaml in the same Jupyter notebook",slug:"using-python-and-ocaml-in-the-same-jupyter-notebook",description:"The cover image is based on Jupiter family by NASA/JPL.",url:"https://blog.janestreet.com/using-python-and-ocaml-in-the-same-jupyter-notebook/",date:"2019-12-16T00:00:00-00:00",preview_image:"https://blog.janestreet.com/using-python-and-ocaml-in-the-same-jupyter-notebook/python-ocaml.jpg",body_html:'<div style="width: 75%; margin: auto; text-align: center; font-style: italic; font-size: 75%">\nThe cover image is based on <a href="https://commons.wikimedia.org/wiki/File:Jupiter_family.jpg">Jupiter family</a> by NASA/JPL.\n</div>'},tl:{hd:{title:"Watch all of Jane Street's tech talks",slug:"watch-all-of-jane-streets-tech-talks",description:"Jane Street has been posting tech talks from internal speakers andinvited guests for years\u2014and they\u2019re all available on our YouTubechannel:",url:"https://blog.janestreet.com/watch-all-of-jane-streets-tech-talks/",date:"2020-02-20T00:00:00-00:00",preview_image:"https://blog.janestreet.com/watch-all-of-jane-streets-tech-talks/youtube-techtalks.jpg",body_html:"<p>Jane Street has been posting tech talks from internal speakers and\ninvited guests for years\u2014and they\u2019re all available on our YouTube\nchannel:</p>"},tl:{hd:{title:"What a Jane Street software engineering interview is like",slug:"what-a-jane-street-software-engineering-interview-is-like",description:"Are you thinking aboutapplying to Jane Streetfor a software engineering role? Or already have a phone interview scheduled but unsurewhat to expect? Read on a...",url:"https://blog.janestreet.com/what-a-jane-street-dev-interview-is-like/",date:"2017-02-28T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>Are you thinking about\n<a href="https://www.janestreet.com/join-jane-street/apply/">applying</a> to Jane Street\nfor a software engineering role? Or already have a phone interview scheduled but unsure\nwhat to expect? Read on as we walk through an example phone interview with you.</p>'},tl:{hd:{title:"What is gained and lost with 63-bit integers?",slug:"what-is-gained-and-lost-with-63-bit-integers",description:"Almost every programming language uses 64-bit integers on typical modern Intelmachines. OCaml uses a special 63-bit representation. How does it affect OCaml?",url:"https://blog.janestreet.com/what-is-gained-and-lost-with-63-bit-integers/",date:"2014-09-29T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Almost every programming language uses 64-bit integers on typical modern Intel\nmachines. OCaml uses a special 63-bit representation. How does it affect OCaml?</p>"},tl:{hd:{title:"What the interns have wrought, 2016",slug:"what-the-interns-have-wrought-2016",description:"Now that the interns have mostly gone back to school, it\u2019s a good time to lookback at what they did while they were here. We had a bumper crop \u2013 more than 30...",url:"https://blog.janestreet.com/what-the-interns-have-wrought-2016/",date:"2016-09-13T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>Now that the interns have mostly gone back to school, it\u2019s a good time to look\nback at what they did while they were here. We had a bumper crop \u2013 more than 30\ndev interns between our London, New York and Hong Kong offices \u2013 and they\nworked on just about every corner of our code-base.</p>"},tl:{hd:{title:"What the interns have wrought, 2017 edition",slug:"what-the-interns-have-wrought-2017-edition",description:"Intern season is coming to a close, and it\u2019s a nice time to look back(as I\u2019ve done inpreviousyears) and review some of whatthe interns did while they were he...",url:"https://blog.janestreet.com/what-the-interns-have-wrought-2017/",date:"2017-08-14T00:00:00-00:00",preview_image:"https://blog.janestreet.com/what-the-interns-have-wrought-2017/what_interns_wrought.png",body_html:'<p>Intern season is coming to a close, and it\u2019s a nice time to look back\n(as I\u2019ve done in\n<a href="/what-the-interns-have-wrought-rpc_parallel-and-core_profiler">previous</a>\n<a href="/what-the-interns-have-wrought-2016">years</a>) and review some of what\nthe interns did while they were here. The dev intern program has grown\nconsiderably, with almost 40 dev interns between our NY, London, and\nHong Kong offices.</p>'},tl:{hd:{title:"What the interns have wrought, 2018 edition",slug:"what-the-interns-have-wrought-2018-edition",description:"Yet again, intern season is coming to a close, and so it\u2019s time tolook back at what the interns have achieved in their short time withus.  I\u2019m always impress...",url:"https://blog.janestreet.com/what-the-interns-have-wrought-2018/",date:"2018-08-06T00:00:00-00:00",preview_image:"https://blog.janestreet.com/what-the-interns-have-wrought-2018/smelting.jpg",body_html:"<p>Yet again, intern season is coming to a close, and so it\u2019s time to\nlook back at what the interns have achieved in their short time with\nus.  I\u2019m always impressed by what our interns manage to squeeze into\nthe summer, and this year is no different.</p>"},tl:{hd:{title:"What the interns have wrought, 2019 edition",slug:"what-the-interns-have-wrought-2019-edition",description:"Jane Street\u2019s intern program yet again is coming to an end, which is anice opportunity to look back over the summer and see what they\u2019veaccomplished.",url:"https://blog.janestreet.com/what-the-interns-have-wrought-2019/",date:"2019-08-30T00:00:00-00:00",preview_image:"https://blog.janestreet.com/what-the-interns-have-wrought-2019/what_interns_wrought2019.jpg",body_html:"<p>Jane Street\u2019s intern program yet again is coming to an end, which is a\nnice opportunity to look back over the summer and see what they\u2019ve\naccomplished.</p>"},tl:{hd:{title:"What the interns have wrought, 2020 edition",slug:"what-the-interns-have-wrought-2020-edition",description:"It\u2019s been an unusual internship season.",url:"https://blog.janestreet.com/what-the-interns-have-wrought-2020/",date:"2020-08-17T00:00:00-00:00",preview_image:"https://blog.janestreet.com/what-the-interns-have-wrought-2020/./distributed-wrought.jpg",body_html:"<p>It\u2019s been an unusual internship season.</p>"},tl:{hd:{title:"What the interns have wrought: RPC_parallel and Core_profiler",slug:"what-the-interns-have-wrought-rpcparallel-and-coreprofiler",description:"We\u2019re in the midst of intern hiring season, and so we get a lot of questionsabout what it\u2019s like to be an intern at Jane Street. One of the things peoplemost...",url:"https://blog.janestreet.com/what-the-interns-have-wrought-rpc_parallel-and-core_profiler/",date:"2014-10-16T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>We\u2019re in the midst of intern hiring season, and so we get a lot of questions\nabout what it\u2019s like to be an intern at Jane Street. One of the things people\nmost want to know is what kind of projects they might work on as an intern.</p>"},tl:{hd:{title:"What's in a name?",slug:"whats-in-a-name",description:"In the once upon a time days of the First Age of Magic, the prudent sorcererregarded his own true name as his most valued possession but also the greatestt...",url:"https://blog.janestreet.com/whats-in-a-name/",date:"2014-07-10T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<blockquote>\n  <p>In the once upon a time days of the First Age of Magic, the prudent sorcerer\nregarded his own true name as his most valued possession but also the greatest\nthreat to his continued good health, for\u2014the stories go\u2014once an enemy, even a\nweak unskilled enemy, learned the sorcerer\u2019s true name, then routine and\nwidely known spells could destroy or enslave even the most powerful. As times\npassed, and we graduated to the Age of Reason and thence to the first and\nsecond industrial revolutions, such notions were discredited. Now it seems\nthat the Wheel has turned full circle (even if there never really was a First\nAge) and we are back to worrying about true names again.</p>\n\n  <p>\u2013 <em>True Names</em>, V.\xa0Vinge</p>\n</blockquote>"},tl:{hd:{title:"When Bash Scripts Bite",slug:"when-bash-scripts-bite",description:"There are abundant resources online trying to scare programmers away from usingshell scripts. Most of them, if anything, succeed in convincing the reader tob...",url:"https://blog.janestreet.com/when-bash-scripts-bite/",date:"2017-05-11T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:"<p>There are abundant resources online trying to scare programmers away from using\nshell scripts. Most of them, if anything, succeed in convincing the reader to\nblindly put something that resembles</p>"},tl:{hd:{title:"Why GADTs matter for performance",slug:"why-gadts-matter-for-performance",description:"When GADTs (Generalized Algebraic DataTypes) landed inOCaml, I wasn\u2019t particularly happy about it. I assumed that it was the kind ofnonsense you get when you...",url:"https://blog.janestreet.com/why-gadts-matter-for-performance/",date:"2015-03-30T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<p>When GADTs (<a href="http://en.wikipedia.org/wiki/Generalized_algebraic_data_type">Generalized Algebraic Data\nTypes</a>) landed in\nOCaml, I wasn\u2019t particularly happy about it. I assumed that it was the kind of\nnonsense you get when you let compiler writers design your programming language.</p>'},tl:{hd:{title:"Why OCaml?",slug:"why-ocaml",description:void 0,url:"https://blog.janestreet.com/why-ocaml/",date:"2016-01-25T00:00:00-00:00",preview_image:"https://blog.janestreet.com/static/img/header.png",body_html:'<div class="video-container">\n  <iframe src="https://youtube.com/embed/v1CmGbOGb2I?rel=0" width="560" height="315" frameborder="0" allowfullscreen=""></iframe>\n</div>'},tl:{hd:{title:"Work on the OCaml compiler at Jane Street!",slug:"work-on-the-ocaml-compiler-at-jane-street",description:"As Jane Street grows, the quality of the development tools we usematters more and more.  We increasingly work on the OCaml compileritself: adding useful lang...",url:"https://blog.janestreet.com/work-on-the-ocaml-compiler-at-jane-street/",date:"2017-12-20T00:00:00-00:00",preview_image:"https://blog.janestreet.com/work-on-the-ocaml-compiler-at-jane-street/compiler3d.jpg",body_html:"<p>As Jane Street grows, the quality of the development tools we use\nmatters more and more.  We increasingly work on the OCaml compiler\nitself: adding useful language features, fine-tuning the type system\nand improving the performance of the generated code. Alongside this,\nwe also work on the surrounding toolchain, developing new tools for\nprofiling, debugging, documentation and build automation.</p>"},tl:{hd:{title:"An Architecture for Interspatial Communication",slug:"an-architecture-for-interspatial-communication",description:void 0,url:"http://kcsrk.info/papers/osmose_feb_18.pdf",date:"2018-02-14T00:00:00-00:00",preview_image:void 0,body_html:'<p>Position paper on\n<a href="http://kcsrk.info/papers/osmose_feb_18.pdf">\u201cAn Architecture for Interspatial Communication\u201d</a>\naccepted to <a href="http://hotpost18.weebly.com/">HotPOST\u201918</a>.</p>'},tl:{hd:{title:"An introduction to fuzzing OCaml with AFL, Crowbar and Bun",slug:"an-introduction-to-fuzzing-ocaml-with-afl-crowbar-and-bun",description:"American Fuzzy Lop or AFL is a fuzzer: a program that tries to find bugs in\nother programs by sending them various auto-generated inputs\u2026",url:"https://tarides.com/blog/2019-09-04-an-introduction-to-fuzzing-ocaml-with-afl-crowbar-and-bun",date:"2019-09-04T00:00:00-00:00",preview_image:"https://tarides.com/static/4eed05522f6733d728f6dc01bbe33e09/2244e/feather.jpg",body_html:'<p><a href="http://lcamtuf.coredump.cx/afl/">American Fuzzy Lop</a> or AFL is a <em>fuzzer</em>: a program that tries to find bugs in\nother programs by sending them various auto-generated inputs. This article covers the\nbasics of AFL and shows an example of fuzzing a parser written in OCaml. It also introduces two\nextensions: the <a href="https://github.com/stedolan/crowbar/">Crowbar</a> library which can be used to fuzz any kind of OCaml program or\nfunction and the <a href="https://github.com/yomimono/ocaml-bun/">Bun</a> tool for integrating fuzzing into your CI.</p>\n<p>All of the examples given in this article are available on GitHub at\n<a href="https://github.com/NathanReb/ocaml-afl-examples">ocaml-afl-examples</a>. The <code>README</code> contains all the information you need to understand,\nbuild and fuzz them yourself.</p>\n<h2 id="what-is-afl" style="position:relative;"><a href="#what-is-afl" aria-label="what is afl permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is AFL?</h2>\n<p>AFL actually isn\'t <em>just</em> a fuzzer but a set of tools. What makes it so good is that it doesn\'t just\nblindly send random input to your program hoping for it to crash; it inspects the execution paths\nof the program and uses that information to figure out which mutations to apply to the previous\ninputs to trigger new execution paths. This approach allows for much more efficient and reliable\nfuzzing (as it will try to maximize coverage) but requires the binaries to be instrumented so the\nexecution can be monitored.</p>\n<p>AFL provides wrappers for the common C compilers that you can use to produce the instrumented\nbinaries along with the CLI fuzzing client: <code>afl-fuzz</code>.</p>\n<p><code>afl-fuzz</code> is straight-forward to use. It takes an input directory containing a few initial valid\ninputs to your program, an output directory and the instrumented binary. It will then repeatedly\nmutate the inputs and feed them to the program, registering the ones that lead to crashes or\nhangs in the output directory.</p>\n<p>Because it works in such a way, it makes it very easy to fuzz a parser.</p>\n<p>To fuzz a <code>parse.exe</code> binary, that takes a file as its first command-line argument and parses it,\nyou can invoke <code>afl-fuzz</code> in the following way:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ afl-fuzz -i inputs/ -o findings/ /path/to/parse.exe @@</code></pre></div>\n<p>The <code>findings/</code> directory is where <code>afl-fuzz</code> will write the crashes it finds, it will create it\nfor you if it doesn\'t exist.\nThe <code>inputs/</code> directory contains one or more valid input files for your\nprogram. By valid we mean "that don\'t crash your program".\nFinally the <code>@@</code> part tells <code>afl-fuzz</code> where on the command line the input file should be passed to\nyour program, in our case, as the first argument.</p>\n<p>Note that it is possible to supply <code>afl-fuzz</code> with more detail about how to invoke your program. If\nyou need to pass it command-line options for instance, you can run it as:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ afl-fuzz -i inputs/ -o findings/ -- /path/to/parse.exe --option=value @@</code></pre></div>\n<p>If you wish to fuzz a program that takes its input from standard input, you can also do that by removing the\n<code>@@</code> from the <code>afl-fuzz</code> invocation.</p>\n<p>Once <code>afl-fuzz</code> starts, it will draw a fancy looking table on the standard output to keep you\nupdated about its progress. From there, you\'ll mostly be interested in is the top right\ncorner which contains the number of crashes and hangs it has found so far:</p>\n<p><span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/893fd2c3d0dfbb1c576fd016b6963e96/f2793/afl_example_output.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 63.52941176470588%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACJklEQVQ4y2VT2ZKjMBAzGDBgcxsbch+bVO38//9p1UxSm519UBHibkktN0ophZ/oe4UQFIZBYRoV2j6BGkaigJpY0//f8xcFi+oaqqqgmgZplsPaDM7p7WmtRlVnyK2FrgpomyKpNBTfvyG9RJpCE8qQyHYdpnnGvK6wzuF++0WXI5ZlJXYIc8Qi5+O0uXBphoefcYsRlxBwtg0GUyHRJGzaFhP/9Dz0fDoSXi4XeO+x2+1I3G8iBacwMgkJuzzDV+vwNQ74PfZ4Fjl8nm8ulbhrSNbRXUs4CghZIPkwDBuBZnE5TXB02R72qI1FzAJW43E2OzjTQOkEOeNS7TjCkagnmmXZ3EQKCArmmyQJM6y/Bel45LOOrO88hSOC36F1LVLW5eKypwvJbqSjhuPdbzd4iiwkbOlWHFbMWWri4YCe7h2n2geP6xLRlMVWI8Jaa9mGcctvJoTweL2iEiLmIUVSXJYlIgUDRxbnDQX2rH1OHnuS/0NY8Oot1TuOayQ7Eg6nEwY2S4ajRMIYUlmLLEPGJm0MKpnofIahQM5oZGW2kQcqHZhNIFnLxsf9jkgyGf3EhjvfxeHn8krjKjmzp+fuGgpslycOG/6xknCWG+Soj+cTkW5ldVqeyXlGZ5+ENS/pcDxum9Bx5HkOSNRrZBlFGoTwvYOS00LS7pXPO6PPTGU/pV5qVvkgJn5J2YvwJ0RJIELv359nb2KB5R2YkiN3FE0T/AEuPil/sTnzzAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Example output from afl-fuzz"\n        title="Example output from afl-fuzz"\n        src="/static/893fd2c3d0dfbb1c576fd016b6963e96/c5bb3/afl_example_output.png"\n        srcset="/static/893fd2c3d0dfbb1c576fd016b6963e96/04472/afl_example_output.png 170w,\n/static/893fd2c3d0dfbb1c576fd016b6963e96/9f933/afl_example_output.png 340w,\n/static/893fd2c3d0dfbb1c576fd016b6963e96/c5bb3/afl_example_output.png 680w,\n/static/893fd2c3d0dfbb1c576fd016b6963e96/f2793/afl_example_output.png 743w"\n        sizes="(max-width: 680px) 100vw, 680px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n      />\n  </a>\n    </span></p>\n<p>You might need to change some of your CPU settings to achieve better performance while fuzzing.\n<code>afl-fuzz</code>\'s output will tell you if that\'s the case and guide you through the steps required to\nmake that happen.</p>\n<h2 id="using-afl-to-fuzz-an-ocaml-parser" style="position:relative;"><a href="#using-afl-to-fuzz-an-ocaml-parser" aria-label="using afl to fuzz an ocaml parser permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using AFL to fuzz an OCaml parser</h2>\n<p>First of all, if you want to fuzz an OCaml program with AFL you\'ll need to produce an instrumented\nbinary. <code>afl-fuzz</code> has an option to work with regular binaries but you\'d lose a lot of what makes it\nefficient. To instrument your binary you can simply install a <code>+afl</code> opam switch and build your\nexecutable from there. AFL compiler variants are available from OCaml <code>4.05.0</code> onwards. To install such\na switch you can run:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ opam switch create fuzzing-switch 4.07.1+afl</code></pre></div>\n<p>If your program already parses the standard input or a file given to it via the command line, you\ncan simply build the executable from your <code>+afl</code> switch and adapt the above examples. If it doesn\'t,\nit\'s still easy to fuzz any parsing function.</p>\n<p>Imagine we have a <code>simple-parser</code> library which exposes the following <code>parse_int</code> function:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> parse_int<span class="token punctuation">:</span> string <span class="token operator">-></span> <span class="token punctuation">(</span>int<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">></span> <span class="token variant variable">`Msg</span> <span class="token keyword">of</span> string<span class="token punctuation">]</span><span class="token punctuation">)</span> result\n<span class="token comment">(** Parse the given string as an int or return [Error (`Msg _)].\n    Does not raise, usually... *)</span></code></pre></div>\n<p>We want to use AFL to make sure our function is robust and won\'t crash when receiving unexpected\ninputs. As you can see the function returns a result and isn\'t supposed to raise exceptions. We want\nto make sure that\'s true.</p>\n<p>To find crashes, AFL traps the signals sent by your program. That means that it will consider\nuncaught OCaml exceptions as crashes. That\'s good because it makes it really simple to write a\n<code>fuzz_me.ml</code> executable that fits what <code>afl-fuzz</code> expects:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n  <span class="token keyword">let</span> file <span class="token operator">=</span> <span class="token module variable">Sys</span><span class="token punctuation">.</span>argv<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span>\n  <span class="token keyword">let</span> ic <span class="token operator">=</span> open_in file <span class="token keyword">in</span>\n  <span class="token keyword">let</span> length <span class="token operator">=</span> in_channel_length ic <span class="token keyword">in</span>\n  <span class="token keyword">let</span> content <span class="token operator">=</span> really_input_string ic length <span class="token keyword">in</span>\n  close_in ic<span class="token punctuation">;</span>\n  ignore <span class="token punctuation">(</span><span class="token module variable">Simple_parser</span><span class="token punctuation">.</span>parse_int content<span class="token punctuation">)</span></code></pre></div>\n<p>We have to provide example inputs to AFL so we can write a <code>valid</code> file to the <code>inputs/</code> directory\ncontaining <code>123</code> and an <code>invalid</code> file containing <code>not an int</code>. Both should parse without crashing\nand make good starting point for AFL as they should trigger different execution paths.</p>\n<p>Because we want to make sure AFL does find crashes we can try to hide a bug in our function:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> parse_int s <span class="token operator">=</span>\n  <span class="token keyword">match</span> <span class="token module variable">List</span><span class="token punctuation">.</span>init <span class="token punctuation">(</span><span class="token module variable">String</span><span class="token punctuation">.</span>length s<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token module variable">String</span><span class="token punctuation">.</span>get s<span class="token punctuation">)</span> <span class="token keyword">with</span>\n  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token string">\'a\'</span><span class="token punctuation">;</span> <span class="token string">\'b\'</span><span class="token punctuation">;</span> <span class="token string">\'c\'</span><span class="token punctuation">]</span> <span class="token operator">-></span> failwith <span class="token string">"secret crash"</span>\n  <span class="token operator">|</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token punctuation">(</span>\n      <span class="token keyword">match</span> int_of_string_opt s <span class="token keyword">with</span>\n      <span class="token operator">|</span> <span class="token module variable">None</span> <span class="token operator">-></span> <span class="token module variable">Error</span> <span class="token punctuation">(</span><span class="token variant variable">`Msg</span> <span class="token punctuation">(</span><span class="token module variable">Printf</span><span class="token punctuation">.</span>sprintf <span class="token string">"Not an int: %S"</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token operator">|</span> <span class="token module variable">Some</span> i <span class="token operator">-></span> <span class="token module variable">Ok</span> i<span class="token punctuation">)</span></code></pre></div>\n<p>Now we just have to build our native binary from the right switch and let <code>afl-fuzz</code> do the rest:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ afl-fuzz -i inputs/ -o findings/ ./fuzz_me.exe @@</code></pre></div>\n<p>It should find that the <code>abc</code> input leads to a crash rather quickly. Once it does, you\'ll see it in\nthe top right corner of its output as shown in the picture from the previous section.</p>\n<p>At this point you can interrupt <code>afl-fuzz</code> and have a look at the content of the <code>findings/crashes</code>:</p>\n<div class="gatsby-highlight" data-language="sh"><pre class="language-sh"><code class="language-sh">$ ls findings/crashes/\nid:000000,sig:06,src:000111,op:havoc,rep:16  README.txt</code></pre></div>\n<p>As you can see it contains a <code>README.txt</code> which will give you some details about the <code>afl-fuzz</code>\ninvocation used to find the crashes and how to reproduce them in the folder and a file of the form\n<code>id:...,sig:...,src:...,op:...,rep:...</code> per crash it found. Here there\'s just one:</p>\n<div class="gatsby-highlight" data-language="sh"><pre class="language-sh"><code class="language-sh">$ cat findings/crashes/id:000000,sig:06,src:000111,op:havoc,rep:16\nabc</code></pre></div>\n<p>As expected it contains our special input that triggers our secret crash. We can rerun the program\nwith that input ourselves to make sure it does trigger it:</p>\n<div class="gatsby-highlight" data-language="sh"><pre class="language-sh"><code class="language-sh">$ ./fuzz_me.exe findings/crashes/id:000000,sig:06,src:000111,op:havoc,rep:16\nFatal error: exception Failure(&quot;secret crash&quot;)</code></pre></div>\n<p>No surprise here, it does trigger our uncaught exception and crashes shamefully.</p>\n<h2 id="using-crowbar-and-afl-for-property-based-testing" style="position:relative;"><a href="#using-crowbar-and-afl-for-property-based-testing" aria-label="using crowbar and afl for property based testing permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using Crowbar and AFL for property-based testing</h2>\n<p>This works well but only being able to fuzz parsers is quite a limitation. That\'s where <a href="https://github.com/stedolan/crowbar/">Crowbar</a>\ncomes into play.</p>\n<p>Crowbar is a property-based testing framework. It\'s much like Haskell\'s <a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a>.\nTo test a given function, you define how its arguments are shaped, a set of properties the result\nshould satisfy and it will make sure they hold with any combinations of randomly generated\narguments.\nLet\'s clarify that with an example.</p>\n<p>I wrote a library called <code>Awesome_list</code> and I want to test its <code>sort</code> function:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> sort<span class="token punctuation">:</span> int list <span class="token operator">-></span> int list\n<span class="token comment">(** Sorts the given list of integers. Result list is sorted in increasing\n    order, most of the time... *)</span></code></pre></div>\n<p>I want to make sure it really works so I\'m going to use Crowbar to generate a whole lot of\nlists of integers and verify that when I sort them with <code>Awesome_list.sort</code> the result is, well...\nsorted.</p>\n<p>We\'ll write our tests in a <code>fuzz_me.ml</code> file.\nFirst we need to tell Crowbar how to generate arguments for our function. It exposes some\ncombinators to help you do that:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> int_list <span class="token operator">=</span> <span class="token module variable">Crowbar</span><span class="token punctuation">.</span><span class="token punctuation">(</span>list <span class="token punctuation">(</span>range <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div>\n<p>Here we\'re telling Crowbar to generate lists of any size, containing integers ranging from 0\nto 10. Crowbar also exposes more complex and custom generator combinators so don\'t worry,\nyou can use it to build more complex arguments.</p>\n<p>Now we need to define our property. Once again it\'s pretty simple, we just want the output to be\nsorted:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> is_sorted l <span class="token operator">=</span>\n  <span class="token keyword">let</span> <span class="token keyword">rec</span> is_sorted <span class="token operator">=</span> <span class="token keyword">function</span>\n    <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">_</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token boolean">true</span>\n    <span class="token operator">|</span> hd<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">(</span>hd\'<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">_</span> <span class="token keyword">as</span> tl<span class="token punctuation">)</span> <span class="token operator">-></span> hd <span class="token operator">&lt;=</span> hd\' <span class="token operator">&amp;&amp;</span> is_sorted tl\n  <span class="token keyword">in</span>\n  <span class="token module variable">Crowbar</span><span class="token punctuation">.</span>check <span class="token punctuation">(</span>is_sorted l<span class="token punctuation">)</span></code></pre></div>\n<p>All that\'s left to do now is to register our test:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n  <span class="token module variable">Crowbar</span><span class="token punctuation">.</span>add_test <span class="token label function">~name</span><span class="token punctuation">:</span><span class="token string">"Awesome_list.sort"</span> <span class="token punctuation">[</span>int_list<span class="token punctuation">]</span>\n      <span class="token punctuation">(</span><span class="token keyword">fun</span> l <span class="token operator">-></span> is_sorted <span class="token punctuation">(</span><span class="token module variable">Awesome_list</span><span class="token punctuation">.</span>sort l<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div>\n<p>and to compile that <code>fuzz_me.ml</code> file to a binary. Crowbar will take care of the magic.</p>\n<p>We can run that binary in "Quickcheck" mode where it will either try a certain amount of random\ninputs or keep trying until one of the properties breaks depending on the command-line options\nwe pass it.\nWhat we\'re interested in here is its less common "AFL" mode. Crowbar made it so our executable\ncan be used with <code>afl-fuzz</code> just like that:</p>\n<div class="gatsby-highlight" data-language="sh"><pre class="language-sh"><code class="language-sh">$ afl-fuzz -i inputs -o findings -- ./fuzz_me.exe @@</code></pre></div>\n<p>What will happen then is that our <code>fuzz_me.exe</code> binary will read the inputs provided by <code>afl-fuzz</code>\nand use it to determine which test to run and how to generate the arguments to pass to our function.\nIf the properties are satisfied, the binary will exit normally; if they aren\'t, it will make sure\nthat <code>afl-fuzz</code> interprets that as a crash by raising an exception.</p>\n<p>A nice side-effect of Crowbar\'s approach is that <code>afl-fuzz</code> will still be able to pick up\ncrashes. For instance, if we implement <code>Awesome_list.sort</code> as:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> sort <span class="token operator">=</span> <span class="token keyword">function</span>\n  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-></span> failwith <span class="token string">"secret crash"</span>\n  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">]</span>\n  <span class="token operator">|</span> l <span class="token operator">-></span> <span class="token module variable">List</span><span class="token punctuation">.</span>sort <span class="token module variable">Pervasives</span><span class="token punctuation">.</span>compare l</code></pre></div>\n<p>and use AFL and Crowbar to fuzz-test our function, it will find two crashes: one for the input\n<code>[1; 2; 3]</code> which triggers a crash and one for <code>[4; 5; 6]</code> for which the <code>is_sorted</code>\nproperty won\'t hold.</p>\n<p>The content of the input files found by <code>afl-fuzz</code> itself won\'t be of much help as it needs to be\ninterpreted by Crowbar to build the arguments that were passed to the function to trigger the bug.\nWe can invoke the <code>fuzz_me.exe</code> binary ourselves on one of the files in <code>findings/crashes</code>\nand the Crowbar binary will replay the test and give us some more helpful information about what\nexactly is going on:</p>\n<div class="gatsby-highlight" data-language="sh"><pre class="language-sh"><code class="language-sh">$ ./fuzz_me.exe findings/crashes/id\\:000000\\,sig\\:06\\,src\\:000011\\,op\\:flip1\\,pos\\:5 \nAwesome_list.sort: ....\nAwesome_list.sort: FAIL\n\nWhen given the input:\n\n    [1; 2; 3]\n    \nthe test threw an exception:\n\n    Failure(&quot;secret crash&quot;)\n    Raised at file &quot;stdlib.ml&quot;, line 33, characters 17-33\n    Called from file &quot;awesome-list/fuzz/fuzz_me.ml&quot;, line 11, characters 78-99\n    Called from file &quot;src/crowbar.ml&quot;, line 264, characters 16-19\n    \nFatal error: exception Crowbar.TestFailure\n$ ./fuzz_me.exe findings/crashes/id\\:000001\\,sig\\:06\\,src\\:000027\\,op\\:arith16\\,pos\\:5\\,val\\:+7 \nAwesome_list.sort: ....\nAwesome_list.sort: FAIL\n\nWhen given the input:\n\n    [4; 5; 6]\n    \nthe test failed:\n\n    check false\n    \nFatal error: exception Crowbar.TestFailure</code></pre></div>\n<p>We can see the actual inputs as well as distinguish the one that broke the invariant from the one\nthat triggered a crash.</p>\n<h2 id="using-bun-to-run-fuzz-testing-in-ci" style="position:relative;"><a href="#using-bun-to-run-fuzz-testing-in-ci" aria-label="using bun to run fuzz testing in ci permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using <code>bun</code> to run fuzz testing in CI</h2>\n<p>While AFL and Crowbar provide no guarantees they can give you confidence that your implementation\nis not broken. Now that you know how to use them, a natural follow-up is to want to run fuzz tests\nin your CI to enforce that level of confidence.</p>\n<p>Problem is, AFL isn\'t very CI friendly. First it has this refreshing output that isn\'t going to look\ngreat on your travis builds output and it doesn\'t tell you much besides that it could or couldn\'t find\ncrashes or invariant infrigements</p>\n<p>Hopefully, like most problems, this one has a solution:\n<a href="https://github.com/yomimono/ocaml-bun/"><code>bun</code></a>.\n<code>bun</code> is a CLI wrapper around <code>afl-fuzz</code>, written in OCaml, that helps you get the best out of AFL\neffortlessly. It mostly does two things:</p>\n<p>The first is that it will run several <code>afl-fuzz</code> processes in parallel\n(one per core by default). <code>afl-fuzz</code> starts with a bunch of deterministic steps. In my experience,\nusing parallel processes during this phase rarely proved very useful as they tend to find the same\nbugs or slight variations of those bugs. It only achieves its full potential in the second phase of\nfuzzing.</p>\n<p>The second thing, which is the one we\'re the most interested in, is that <code>bun</code> provides a useful\nand CI-friendly summary of what\'s going on with all the fuzzing processes so far. When one of them\nfinds a crash, it will stop all processes and pretty-print all of the bug-triggering inputs to help\nyou reproduce and debug them locally. See an example <code>bun</code> output after a crash was found:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Crashes found! Take a look; copy/paste to save for reproduction:\n1432\techo JXJpaWl0IA== | base64 -d &gt; crash_0.$(date -u +%s)\n1433\techo NXJhkV8QAA== | base64 -d &gt; crash_1.$(date -u +%s)\n1434\techo J3Jh//9qdGFiYmkg | base64 -d &gt; crash_2.$(date -u +%s)\n1435\t09:35.32:[ERROR]All fuzzers finished, but some crashes were found!</code></pre></div>\n<p>Using <code>bun</code> is very similar to using <code>afl-fuzz</code>. Going back to our first parser example, we can\nfuzz it with <code>bun</code> like this:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ bun --input inputs/ --output findings/ /path/to/parse.exe</code></pre></div>\n<p>You\'ll note that you don\'t need to provide the <code>@@</code> anymore. <code>bun</code> assumes that it should pass the\ninput as the first argument of your to-be-fuzzed binary.</p>\n<p><code>bun</code> also comes with an alternative <code>no-kill</code> mode which lets all the fuzzers run indefinitely\ninstead of terminating them whenever a crash is discovered. It will regularly keep you updated on\nthe number of crashes discovered so far and when terminated will pretty-print each of them just like\nit does in regular mode.</p>\n<p>This mode can be convenient if you suspect your implementation may contain a lot of bugs and\nyou don\'t want to go through the whole process of fuzz testing it to only find a single bug.</p>\n<p>You can use it in CI by running <code>bun --no-kill</code> via <code>timeout</code>. For instance:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">timeout --preserve-status 60m bun --no-kill --input inputs --output findings ./fuzz_me.exe</code></pre></div>\n<p>will fuzz <code>fuzz_me.exe</code> for an hour no matter what happens. When <code>timeout</code> terminates <code>bun</code>, it will\nprovide you with a handful of bugs to fix!</p>\n<h2 id="final-words" style="position:relative;"><a href="#final-words" aria-label="final words permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Final words</h2>\n<p>I really want to encourage you to use those tools and fuzzing in general.\nCrowbar and <code>bun</code> are fairly new so you will probably encounter bugs or find that it lacks a feature\nyou want but combined with AFL they make for very nice tools to effectively test\ncritical components of your OCaml code base or infrastructure and detect newly-introduced bugs.\nThey are already used accross the MirageOS ecosystem where it has been used to fuzz the TCP/IP stack\n<a href="https://github.com/mirage/mirage-tcpip">mirage-tcpip</a> and the DHCP implementation <a href="https://github.com/mirage/charrua">charrua</a> thanks to\n<a href="https://github.com/yomimono/somerandompacket">somerandompacket</a>.\nYou can consult Crowbar\'s <a href="https://github.com/stedolan/crowbar/issues/2">hall of fame</a> to find out about bugs uncovered by this\napproach.</p>\n<p>I also encourage anyone interested to join us in using this promising toolchain, report those bugs,\ncontribute those extra features and help the community build more robust software.</p>\n<p>Finally if you wish to learn more about how to efficienly use fuzzing for testing I recommend the\nexcellent <a href="https://blog.regehr.org/archives/1687">Write Fuzzable Code</a> article by John Regehr.</p>'},tl:{hd:{title:"An introduction to OCaml PPX ecosystem",slug:"an-introduction-to-ocaml-ppx-ecosystem",description:"These last few months, I spent some time writing new OCaml PPX rewriters or contributing to existing\nones. It's a really fun experience\u2026",url:"https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem",date:"2019-05-09T00:00:00-00:00",preview_image:"https://tarides.com/static/0e8e776eb4ab9f596324bfe7e318b854/2244e/circuit_boards.jpg",body_html:'<p>These last few months, I spent some time writing new OCaml PPX rewriters or contributing to existing\nones. It\'s a really fun experience. Toying around with the AST taught me a lot about a language I\nthought I knew really well. Turns out I actually had no idea what I was doing all these years.</p>\n<p>All jokes aside, I was surprised that the most helpful tricks I learned while writing PPX rewriters\nweren\'t properly documented. There already exist a few very good introduction articles on the\nsubject, like that\n<a href="https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/">2014\'s article from Whitequark</a>,\nthis <a href="http://rgrinberg.com/posts/extensions-points-update-1/">more recent one from Rudi Grinberg</a>\nor even <a href="https://victor.darvariu.me/jekyll/update/2018/06/19/ppx-tutorial.html">this last one from Victor Darvariu</a>\nI only discovered after I actually started writing my own. I still felt like they were slightly\noutdated or weren\'t answering all the questions I had when I started playing with PPX and writing my\nfirst rewriters.</p>\n<p>I decided to share my PPX adventures in the hope that it can help others familiarize with this bit\nof the OCaml ecosystem and eventually write their first rewriters. The scope of this article is not to\ncover every single detail about the PPX internals but just to give a gentle introduction to\nbeginners to help them get settled. That also means I might omit things that I don\'t think are worth\nmentioning or that might confuse the targetted audience but feel free to comment if you believe\nthis article missed an important point.</p>\n<p>It\'s worth mentioning that a lot of the nice tricks mentioned in these lines were given to me by a\nwonderful human being called \xc9tienne Millon, thanks \xc9tienne!</p>\n<h2 id="what-is-a-ppx" style="position:relative;"><a href="#what-is-a-ppx" aria-label="what is a ppx permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is a PPX?</h2>\n<p>PPX rewriters or PPX-es are preprocessors that are applied to your code before passing it on to the\ncompiler. They don\'t operate on your code directly but on the Abstract Syntax Tree or AST resulting\nfrom its parsing. That means that they can only be applied to syntactically correct OCaml code. You\ncan think of them as functions that take an AST and return a new AST.</p>\n<p>That means that in theory you can do a lot of things with a PPX, including pretty bad and cryptic\nthings. You could for example replace every instance of <code>true</code> by <code>false</code>, swap the branches of any\n<code>if-then-else</code> or randomize the order of every pattern-matching case.\nObviously that\'s not the kind of behaviour that we want as it would make it impossible to\nunderstand the code since it would be so far from the actual AST the compiler would get.\nIn practice PPX-es have a well defined scope and only transform parts you explicitly annotated.</p>\n<h3 id="understanding-the-ocaml-ast" style="position:relative;"><a href="#understanding-the-ocaml-ast" aria-label="understanding the ocaml ast permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Understanding the OCaml AST</h3>\n<p>First things first, what is an AST. An AST is an abstract representation of your code. As the name\nsuggests it has a tree-like structure where the root describes your entire file. It has children for\neach bits such as a function declaration or a type definition, each of them having their own\nchildren, for example for the function name, its argument and its body and that goes on until you\nreach a leaf such as a literal <code>1</code>, <code>"abc"</code> or a variable for instance.\nIn the case of OCaml it\'s a set of recursive types allowing us to represent OCaml code as an OCaml\nvalue. This value is what the parser passes to the compiler so it can type check and compile it to\nnative or byte code.\nThose types are defined in OCaml\'s <code>Parsetree</code> module. The entry points there are the <code>structure</code>\ntype which describes the content of an <code>.ml</code> file and the <code>signature</code> type which describes the\ncontent of an <code>.mli</code> file.</p>\n<p>As mentionned above, a PPX can be seen as a function that transforms an AST. Writing a PPX thus\nrequires you to understand the AST, both to interpret the one you\'ll get as input and\nto produce the right one as output. This is probably the trickiest part as unless you\'ve already\nworked on the OCaml compiler or written a PPX rewriter, that will probably be the first time you two\nmeet. Chances are also high that\'ll be a pretty bad first date and you will need some to time\nto get to know each other.</p>\n<p>The <code>Parsetree</code> module <a href="https://caml.inria.fr/pub/docs/manual-ocaml/compilerlibref/Parsetree.html">documentation</a>,\nis a good place to start. The above mentioned <code>structure</code> and <code>signature</code> types are at the root of\nthe AST but some other useful types to look at at first are:</p>\n<ul>\n<li><code>expression</code> which describes anything in OCaml that evaluates to a value, the right hand side of a\n<code>let</code> binding for instance.</li>\n<li><code>pattern</code> which is what you use to deconstruct an OCaml value, the left hand side of a <code>let</code>\nbinding or a pattern-matching case for example.</li>\n<li><code>core_type</code> which describes type expressions ie what you would find on the right hand side of a\nvalue description in a <code>.mli</code>, ie <code>val f : &#x3C;what_goes_there></code>.</li>\n<li><code>structure_item</code> and <code>signature_item</code> which describe the top level AST nodes you can find in a\n<code>structure</code> or <code>signature</code> such as type definitions, value or module declarations.</li>\n</ul>\n<p>Thing is, it\'s a bit a rough and there\'s no detailed explanation about how a specific bit of code is\nrepresented, just type definitions. Most of the time, the type, field, and variant names are\nself-explanatory but it can get harder with some of the more advanced language features.\nIt turns out there are plenty of comments that are really helpful in the actual <code>parsetree.mli</code> file\nand that aren\'t part of the generated documentation. You can find them on\n<a href="https://github.com/ocaml/ocaml/blob/trunk/parsing/parsetree.mli">github</a> but I personally prefer to\nhave it opened in a VIM tab when I work on a PPX so I usually open\n<code>~/.opam/&#x3C;current_working_switch>/lib/ocaml/compiler-libs/parsetree.mli</code>.</p>\n<p>This works well while exploring but you might also want a more straightforward approach to\ndiscovering what the AST representation is for some specific OCaml code. The\n<a href="https://github.com/ocaml-ppx/ppx_tools"><code>ppx_tools</code></a> opam package comes with a <code>dumpast</code> binary\nthat pretty prints the AST for any given piece of valid OCaml code. You can install it using opam:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$opam install ppx_tools</code></pre></div>\n<p>and then run it using <code>ocamlfind</code>:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ocamlfind ppx_tools/dumpast some_file.ml</code></pre></div>\n<p>You can use it on <code>.ml</code> and <code>.mli</code> files or to quickly get the AST for an expression with the <code>-e</code>\noption:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ocamlfind ppx_tools/dumpast -e &quot;1 + 1&quot;</code></pre></div>\n<p>Similarly, you can use the <code>-t</code> or <code>-p</code> options to respectively pretty print ASTs from type\nexpressions or patterns.</p>\n<p>Using <code>dumpast</code> to get both the ASTs of a piece of code using your future PPX and the resulting\npreprocessed code is a good way to start and will help you figure out what are the steps required to\nget there.</p>\n<p>Note that you can use the compiler or <code>utop</code> have a similar feature with the <code>-dparsetree</code> flag.\nRunning <code>ocamlc/ocamlopt -dparsetree file.ml</code> will pretty print the AST of the given file while\nrunning <code>utop -dparsetree</code> will pretty print the AST of the evaluated code alongside it\'s\nevaluation.\nI tend to prefer the pretty printed AST from <code>dumpast</code> but any of these tools will prove helpful\nin understanding the AST representation of a given piece of OCaml code.</p>\n<h3 id="language-extensions-interpreted-by-ppx-es" style="position:relative;"><a href="#language-extensions-interpreted-by-ppx-es" aria-label="language extensions interpreted by ppx es permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Language extensions interpreted by PPX-es</h3>\n<p>OCaml 4.02 introduced syntax extensions meant to be used by external tools such as PPX-es. Knowing\ntheir syntax and meaning is important to understand how most of the existing rewriters\nwork because they usually look for those language extensions in the AST to know which part of it\nthey need to modify.</p>\n<p>The two language extensions we\'re interested in here are extension nodes and attributes. They are\ndefined in detail in the OCaml manual (see the\n<a href="https://caml.inria.fr/pub/docs/manual-ocaml/attributes.html">attributes</a> and\n<a href="https://caml.inria.fr/pub/docs/manual-ocaml/extensionnodes.html">extension nodes</a> sections) but I\'ll\ntry to give a good summary here.</p>\n<p>Extension nodes are used in place of expressions, module expressions, patterns, type expressions or\nmodule type expressions. Their syntax is <code>[%extension_name payload]</code>. We\'ll come back to the payload\npart a little later.\nYou can also find extension nodes at the top level of modules or module signatures with the syntax\n<code>[%%extension_name payload]</code>.\nHopefully the following cheatsheet can help you remember the basics of how and where you can use\nthem:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> t <span class="token operator">=</span>\n  <span class="token punctuation">{</span> a <span class="token punctuation">:</span> int\n  <span class="token punctuation">;</span> b <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">%</span>ext pl<span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> x <span class="token operator">=</span>\n  <span class="token keyword">match</span> <span class="token number">1</span> <span class="token keyword">with</span>\n  <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token operator">%</span>ext pl<span class="token punctuation">]</span>\n  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token operator">%</span>ext pl<span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token boolean">true</span>\n\n<span class="token punctuation">[</span><span class="token operator">%%</span>ext pl<span class="token punctuation">]</span></code></pre></div>\n<p>Because extension nodes stand where regular AST nodes should, the compiler won\'t accept them and\nwill give you an <code>Uninterpreted extension</code> error. Extension nodes have to be expanded by a PPX for\nyour code to compile.</p>\n<p>Attributes are slightly different although their syntax is very close to extensions. Attributes\nare attached to existing AST nodes instead of replacing them. That means that they don\'t necessarily\nneed to be transformed and the compiler will ignore unknown attributes by default.\nThey can come with a payload just like extensions and use <code>@</code> instead of <code>%</code>. The number of <code>@</code>\npreceding the attribute name specifies which kind of node they are attached to:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">12</span> <span class="token punctuation">[</span><span class="token operator">@</span>attr pl<span class="token punctuation">]</span>\n\n<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token string">"some string"</span> <span class="token punctuation">[</span><span class="token operator">@@</span>attr pl<span class="token punctuation">]</span>\n\n<span class="token punctuation">[</span><span class="token operator">@@@</span>attr pl<span class="token punctuation">]</span></code></pre></div>\n<p>In the first example, the attribute is attached to the expression <code>12</code> while in the second example\nit is attached to the whole <code>let b = "some string"</code> value binding. The third one is of a slightly\ndifferent nature as it is a floating attribute. It\'s not attached to anything per-se and just ends\nup in the AST as a structure item.\nBecause there is a wide variety of nodes to which you can attach attributes, I won\'t go too far into\ndetails here but a good rule of thumb is that you use <code>@@</code> attributes when you want them attached to\nstructure or signature items, for anything deeper within the AST structure such as patterns,\nexpressions or core types, use the single <code>@</code> syntax. Looking at the <code>Parsetree</code> documentation can\nhelp you figure out where you can find attributes.</p>\n<p>Now let\'s talk about those payloads I mentioned earlier. You can think of them as "arguments" to\nthe extension points and attributes. You can pass different kinds of arguments and the syntax varies\nfor each of them:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">%</span>ext expr_or_str_item<span class="token punctuation">]</span> \n<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">%</span>ext<span class="token punctuation">:</span> type_expr_or_sig_item<span class="token punctuation">]</span>\n<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">%</span>ext<span class="token operator">?</span> pattern<span class="token punctuation">]</span></code></pre></div>\n<p>As suggested in the examples, you can pass expressions or structure items using a space character,\ntype expressions or signature items (anything you\'d find at the top level of a module signature)\nusing a <code>:</code> or a pattern using a <code>?</code>.</p>\n<p>Attributes\' payload use the same syntax:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">\'a\'</span> <span class="token punctuation">[</span><span class="token operator">@</span>attr expr_or_str_item<span class="token punctuation">]</span>\n<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token string">\'b\'</span> <span class="token punctuation">[</span><span class="token operator">@</span>attr<span class="token punctuation">:</span> type_expr_or_sig_item<span class="token punctuation">]</span>\n<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">\'a\'</span> <span class="token punctuation">[</span><span class="token operator">@</span>attr<span class="token operator">?</span> pattern<span class="token punctuation">]</span></code></pre></div>\n<p>Some PPX-es rely on other language extensions such as the suffix character you can attach to <code>int</code>\nand <code>float</code> literals (<code>10z</code> could be used by a PPX to turn it into <code>Z.of_string "10"</code> for instance)\nor quoted strings with a specific identifier (<code>{ppx_name|some quoted string|ppx_name}</code> can be used\nif you want your PPX to operate on arbitrary strings and not only syntactically correct OCaml) but\nattributes and extensions are the most commonly used ones.</p>\n<p>Attributes and extension points can be expressed using an infix syntax. The attribute version is\nbarely used but some forms of the infix syntax for extension points are used by popular PPX-es and\nit is likely you will encounter some of the following:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> infix_let_extension <span class="token operator">=</span>\n  <span class="token keyword">let</span><span class="token operator">%</span>ext x <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span>\n  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n\n<span class="token keyword">let</span> infix_match_extension <span class="token operator">=</span>\n  <span class="token keyword">match</span><span class="token operator">%</span>ext y <span class="token keyword">with</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n\n<span class="token keyword">let</span> infix_try_extension <span class="token operator">=</span>\n  <span class="token keyword">try</span><span class="token operator">%</span>ext f z <span class="token keyword">with</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></div>\n<p>which are syntactic sugar for:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> infix_let_extension <span class="token operator">=</span>\n  <span class="token punctuation">[</span><span class="token operator">%</span>ext <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>\n\n<span class="token keyword">let</span> infix_match_extension <span class="token operator">=</span>\n  <span class="token punctuation">[</span><span class="token operator">%</span>ext <span class="token keyword">match</span> y <span class="token keyword">with</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>\n\n<span class="token keyword">let</span> infix_try_extension <span class="token operator">=</span>\n  <span class="token punctuation">[</span><span class="token operator">%</span>ext <span class="token keyword">try</span> f z <span class="token keyword">with</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></code></pre></div>\n<p>A good example of a PPX making heavy use of these if\n<a href="http://ocsigen.org/lwt/4.1.0/api/Ppx_lwt"><code>lwt_ppx</code></a>. The OCaml manual also contains more examples\nof the infix syntax in the Attributes and Extension points sections mentioned above.</p>\n<h3 id="the-two-main-kind-of-ppx-es" style="position:relative;"><a href="#the-two-main-kind-of-ppx-es" aria-label="the two main kind of ppx es permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The two main kind of PPX-es</h3>\n<p>There is a wide variety of PPX rewriters but the ones you\'ll probably see the most are Extensions and\nDerivers.</p>\n<h4 id="extensions" style="position:relative;"><a href="#extensions" aria-label="extensions permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extensions</h4>\n<p>Extensions will rewrite tagged parts of the AST, usually extension nodes of the form\n<code>[%&#x3C;extension_name> payload]</code>. They will replace them with a different AST node of the same nature ie\nif the extension point was located where an expression should be, the rewriter will produce an\nexpression. Good examples of extensions are:</p>\n<ul>\n<li><a href="https://github.com/rgrinberg/ppx_getenv2"><code>ppx_getenv2</code></a> which replaces <code>[%getenv SOME_VAR]</code> with\nthe value of the environment variable <code>SOME_VAR</code> at compile time.</li>\n<li><a href="https://github.com/NathanReb/ppx_yojson"><code>ppx_yojson</code></a> which allows you to write <code>Yojson</code> values\nusing OCaml syntax to mimic actual json. For instance you\'d use <code>[%yojson {a = None; b = 1}]</code> to\nrepresent <code>{"a": null, "b": 1}</code> instead of the <code>Yojson</code>\'s notation:\n<code>Assoc [("a", Null); ("b", Int 1)]</code>.</li>\n</ul>\n<h4 id="derivers" style="position:relative;"><a href="#derivers" aria-label="derivers permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Derivers</h4>\n<p>Derivers or deriving plugins will "insert" new nodes derived from type definitions annotated with a\n<code>[@@deriving &#x3C;deriver_name>]</code> attribute. They have various applications but are particularly useful\nto derive functions that are tedious and error prone to write by hand such as comparison functions,\npretty printers or serializers. It\'s really convenient as you don\'t have to update those functions\nevery time you update your type definitions. They were inspired by Haskell Type classes. Good\nexamples of derivers are:</p>\n<ul>\n<li><a href="https://github.com/ocaml-ppx/ppx_deriving"><code>ppx_deriving</code></a> itself comes with a bunch of deriving\nplugins such as <code>eq</code>, <code>ord</code> or <code>show</code> which respectively derives, as you might have guessed,\nequality, comparison and pretty-printing functions.</li>\n<li><a href="https://github.com/ocaml-ppx/ppx_deriving_yojson"><code>ppx_deriving_yojson</code></a> which derives JSON\nserializers and deserializers.</li>\n<li><a href="https://github.com/janestreet/ppx_sexp_conv"><code>ppx_sexp_conv</code></a> which derives s-expressions\nconverters.</li>\n</ul>\n<p>Derivers often let you attach attributes to specify how some parts of the AST should be handled. For\nexample when using <code>ppx_deriving_yojson</code> you can use <code>[@default some_val]</code> to make a field of an\nobject optional:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> t <span class="token operator">=</span>\n  <span class="token punctuation">{</span> a<span class="token punctuation">:</span> int\n  <span class="token punctuation">;</span> b<span class="token punctuation">:</span> string <span class="token punctuation">[</span><span class="token operator">@</span>default <span class="token string">""</span><span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">[</span><span class="token operator">@@</span>deriving of_yojson<span class="token punctuation">]</span></code></pre></div>\n<p>will derive a deserializer that will convert the JSON value <code>{"a": 1}</code> to the OCaml\n<code>{a = 1; b = ""}</code></p>\n<h2 id="how-to-write-a-ppx-using-ppxlib" style="position:relative;"><a href="#how-to-write-a-ppx-using-ppxlib" aria-label="how to write a ppx using ppxlib permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How to write a PPX using <code>ppxlib</code></h2>\n<p>Historically there was a few libraries used by PPX rewriter authors to write their PPX-es, including\n<code>ppx_tools</code> and <code>ppx_deriving</code> but as the eco-system evolved, <code>ppxlib</code> emerged and is now the most\nup-to-date and maintained library to write and handle PPX-es. It wraps the features of those\nlibraries in a single one.\nI encourage you to use <code>ppxlib</code> to write new PPX-es as it is also easier to make various rewriters\nwork together if they are all registered through <code>ppxlib</code> and the PPX ecosystem would gain from\nbeing unified around a single PPX library and driver.</p>\n<p>It is also a great library and has some really powerful features to help you write your extensions\nand derivers.</p>\n<h3 id="writing-an-extension" style="position:relative;"><a href="#writing-an-extension" aria-label="writing an extension permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writing an extension</h3>\n<p>The entry point of <code>ppxlib</code> for extensions is <code>Ppxlib.Extension.declare</code>. You have to use that\nfunction to build an <code>Extension.t</code>, from which you can then build a <code>Context_free.Rule.t</code> before\nregistering your transformation so it\'s actually applied.</p>\n<p>The typical <code>my_ppx_extension.ml</code> will look like:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> <span class="token module variable">Ppxlib</span>\n\n<span class="token keyword">let</span> extension <span class="token operator">=</span>\n  <span class="token module variable">Extension</span><span class="token punctuation">.</span>declare\n    <span class="token string">"my_extension"</span>\n    some_context\n    some_pattern\n    expand_function\n\n<span class="token keyword">let</span> rule <span class="token operator">=</span> <span class="token module variable">Context_free</span><span class="token punctuation">.</span><span class="token module variable">Rule</span><span class="token punctuation">.</span>extension extension\n\n<span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n  <span class="token module variable">Driver</span><span class="token punctuation">.</span>register_transformation <span class="token label function">~rules</span><span class="token punctuation">:</span><span class="token punctuation">[</span>rule<span class="token punctuation">]</span> <span class="token string">"my_transformation"</span></code></pre></div>\n<p>To compile it as PPX rewriter you\'ll need to put the following in your dune file:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(library\n (public_name my_ppx)\n (kind ppx_rewriter)\n (libraries ppxlib))</code></pre></div>\n<p>Now let\'s go back a little and look at the important part:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> extension <span class="token operator">=</span>\n  <span class="token module variable">Extension</span><span class="token punctuation">.</span>declare\n    <span class="token string">"my_extension"</span>\n    some_context\n    some_pattern\n    expand_function</code></pre></div>\n<p>Here <code>"my_extension"</code> is the name of your extension and that define how you\'re going to invoke it\nin your extension point. In other words, to use this extension in our code we\'ll use a\n<code>[%my_extension ...]</code> extension point.</p>\n<p><code>some_context</code> is a <code>Ppxlib.Extension.Context.t</code> and describes where this extension can be found in\nthe AST, ie can you use <code>[%my_extension ...]</code> as an expression, a pattern, a core type. The\n<code>Ppxlib.Extension.Context</code> module defines a constant for each possible extension context which you\ncan pass as <code>some_context</code>.\nThis obviously means that it also describes the type of AST node to which it must be converted and\nthis property is actually enforced by the <code>some_pattern</code> argument. But we\'ll come back to that\nlater.</p>\n<p>Finally <code>expand_function</code> is our actual extension implementation, which basically takes the payload,\na <code>loc</code> argument which contains the location of the expanded extension point, a <code>path</code> argument\nwhich is the fully qualified path to the expanded node (eg. <code>"file.ml.A.B"</code>) and returns the\ngenerated code to replace the extension with.</p>\n<h4 id="ast_pattern" style="position:relative;"><a href="#ast_pattern" aria-label="ast_pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ast_pattern</h4>\n<p>Now let\'s get back to that <code>some_pattern</code> argument.</p>\n<p>This is one of the trickiest parts of <code>ppxlib</code> to understand but it\'s also one its most\npowerful features. The type for <code>Ast_pattern</code> is defined as <code>(\'a, \'b, \'c) t</code> where <code>\'a</code> is\nthe type of AST nodes that are matched, <code>\'b</code> is the type of the values you\'re extracting from the\nnode as a function type and <code>\'c</code> is the return type of that last function. This sounded really\nconfusing to me at first and I\'m guessing it might do to some of you too so let\'s give it a bit of\ncontext.</p>\n<p>Let\'s look at the type of <code>Extension.declare</code>:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> declare <span class="token punctuation">:</span>\n  string <span class="token operator">-></span>\n  <span class="token type-variable function">\'context</span> <span class="token module variable">Context</span><span class="token punctuation">.</span>t <span class="token operator">-></span>\n  <span class="token punctuation">(</span>payload<span class="token punctuation">,</span> <span class="token type-variable function">\'a</span><span class="token punctuation">,</span> <span class="token type-variable function">\'context</span><span class="token punctuation">)</span> <span class="token module variable">Ast_pattern</span><span class="token punctuation">.</span>t <span class="token operator">-></span>\n  <span class="token punctuation">(</span>loc<span class="token punctuation">:</span><span class="token module variable">Location</span><span class="token punctuation">.</span>t <span class="token operator">-></span> path<span class="token punctuation">:</span>string <span class="token operator">-></span> <span class="token type-variable function">\'a</span><span class="token punctuation">)</span> <span class="token operator">-></span>\n  t</code></pre></div>\n<p>Here, the expected pattern first type parameter is <code>payload</code> which means we want a pattern that\nmatches <code>payload</code> AST nodes. That makes perfect sense since it is used to describe what your\nextension\'s payload should look like and what to do with it.\nThe last type parameter is <code>\'context</code> which again seems logical. As I mentioned earlier our\n<code>expand_function</code> should return the same kind of node as the one where the extension was found.\nNow what about <code>\'a</code>. As you can see, it describes what comes after the base <code>loc</code> and <code>path</code>\nparameters of our <code>expand_function</code>. From the pattern point of view, <code>\'a</code> describes the parts of the\nmatched AST node we wish to extract for later consumption, here by our expander.</p>\n<p><code>Ast_pattern</code> contains a whole bunch of combinators to let you describe what your pattern should match\nand a specific <code>__</code> pattern that you must use to capture the various parts of the matched nodes.\n<code>__</code> has type <code>(\'a, \'a -> \'b, \'b) Ast_pattern.t</code> which means that whenever it\'s used it changes the\ntype of consumer function in the returned pattern.</p>\n<p>Let\'s consider a few examples to try wrapping our heads around this. Say I want to write an\nextension that takes an expression as a payload and I want to pass this expression to my expander so\nI can generate code based on its value. I can declare the extension like this:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> extension <span class="token operator">=</span>\n  <span class="token module variable">Extension</span><span class="token punctuation">.</span>declare\n    <span class="token string">"my_extension"</span>\n    <span class="token module variable">Extension</span><span class="token punctuation">.</span><span class="token module variable">Context</span><span class="token punctuation">.</span>expression\n    <span class="token module variable">Ast_pattern</span><span class="token punctuation">.</span><span class="token punctuation">(</span>single_expr_payload __<span class="token punctuation">)</span>\n    expand_function</code></pre></div>\n<p>In this example, <code>Extension.Context.expression</code> has type <code>expression Extension.Context.t</code>, the\npattern has type <code>(payload, expression -> expression, expression) Ast_pattern.t</code>. The pattern says we\nwant to allow a single expression in the payload and capture it. If we decompose it a bit, we can\nsee that <code>single_expr_payload</code> has type\n<code>(expression, \'a, \'b) Ast_pattern.t -> (payload, \'a, \'b) Ast_pattern.t</code> and is passed <code>__</code> which\nmakes it a <code>(expression, expression -> \'b, \'b) Ast_pattern.t</code> and that\'s exactly what we want here\nas our expander will have type <code>loc: Location.t -> path: string -> expression -> expression</code>!</p>\n<p>It works similarly to <code>Scanf.scanf</code> when you think about it. Changing the pattern changes the type of the\nconsumer function the same way changing the format string does for <code>Scanf</code> functions.</p>\n<p>This was a bit easy since we had a custom combinator just for that purpose so let\'s take a few more\ncomplex examples. Now say we want to only allow pairs of integer and string constants expressions in\nour payload. Instead of just capturing any expression and dealing with the error cases in the\n<code>expand_function</code> we can let <code>Ast_pattern</code> deal with that and pass an <code>int</code> and <code>string</code> along to\nour expander:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token module variable">Ast_pattern</span><span class="token punctuation">.</span><span class="token punctuation">(</span>single_expr_payload <span class="token punctuation">(</span>pexp_tuple <span class="token punctuation">(</span><span class="token punctuation">(</span>eint __<span class="token punctuation">)</span><span class="token operator">^::</span><span class="token punctuation">(</span>estring __<span class="token punctuation">)</span><span class="token operator">^::</span>nil<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div>\n<p>This one\'s a bit more elaborate but the idea is the same, we use <code>__</code> to capture the int and string\nfrom the expression and use combinators to specify that the payload should be made of a pair and\nthat gives us a: <code>(payload, int -> string -> \'a, \'a) Ast_pattern.t</code> which should be used with a\n<code>loc: Location.t -> path: string -> int -> string -> expression</code> expander.</p>\n<p>We can also specify that our extension should take something else than an expression as a payload,\nsay a pattern with no <code>when</code> clause so that it\'s applied as <code>[%my_ext? some_pattern_payload]</code>:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token module variable">Ast_pattern</span><span class="token punctuation">.</span><span class="token punctuation">(</span>ppat __ none<span class="token punctuation">)</span></code></pre></div>\n<p>or no payload at all and it should just be invoked as <code>[%my_ext]</code>:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token module variable">Ast_pattern</span><span class="token punctuation">.</span><span class="token punctuation">(</span>pstr nil<span class="token punctuation">)</span></code></pre></div>\n<p>You should play with <code>Ast_pattern</code> a bit if you need to express complex patterns as I think it\'s\nthe only way to get the hang of it.</p>\n<h3 id="writing-a-deriver" style="position:relative;"><a href="#writing-a-deriver" aria-label="writing a deriver permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writing a deriver</h3>\n<p>Registering a deriver is slightly different from registering an extension but in the end it remains\nrelatively simple and you will still have to provide the actual implementation in the form of an\n<code>expand</code> function.</p>\n<p>The typical <code>my_ppx_deriver.ml</code> will look like:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> <span class="token module variable">Ppxlib</span>\n\n<span class="token keyword">let</span> str_type_decl_generator <span class="token operator">=</span>\n  <span class="token module variable">Deriving</span><span class="token punctuation">.</span><span class="token module variable">Generator</span><span class="token punctuation">.</span>make_no_arg\n    <span class="token label function">~attributes</span>\n    expand_str\n\n<span class="token keyword">let</span> sig_type_decl_generator <span class="token operator">=</span>\n  <span class="token module variable">Deriving</span><span class="token punctuation">.</span><span class="token module variable">Generator</span><span class="token punctuation">.</span>make_no_arg\n    <span class="token label function">~attributes</span>\n    expand_sig\n\n<span class="token keyword">let</span> my_deriver <span class="token operator">=</span>\n  <span class="token module variable">Deriving</span><span class="token punctuation">.</span>add\n    <span class="token label function">~str_type_decl</span><span class="token punctuation">:</span>str_type_decl_generator\n    <span class="token label function">~sig_type_decl</span><span class="token punctuation">:</span>sig_type_decl_generator\n    <span class="token string">"my_deriver"</span></code></pre></div>\n<p>Which you\'ll need to compile with the following <code>library</code> stanza:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(library\n (public_name my_ppx)\n (kind ppx_deriver)\n (libraries ppxlib))</code></pre></div>\n<p>The <code>Deriving.add</code> function is declared as:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> add\n  <span class="token punctuation">:</span>  <span class="token operator">?</span>str_type_decl<span class="token punctuation">:</span><span class="token punctuation">(</span>structure<span class="token punctuation">,</span> rec_flag <span class="token operator">*</span> type_declaration list<span class="token punctuation">)</span> <span class="token module variable">Generator</span><span class="token punctuation">.</span>t\n  <span class="token operator">-></span> <span class="token operator">?</span>str_type_ext <span class="token punctuation">:</span><span class="token punctuation">(</span>structure<span class="token punctuation">,</span> type_extension                  <span class="token punctuation">)</span> <span class="token module variable">Generator</span><span class="token punctuation">.</span>t\n  <span class="token operator">-></span> <span class="token operator">?</span>str_exception<span class="token punctuation">:</span><span class="token punctuation">(</span>structure<span class="token punctuation">,</span> extension_constructor           <span class="token punctuation">)</span> <span class="token module variable">Generator</span><span class="token punctuation">.</span>t\n  <span class="token operator">-></span> <span class="token operator">?</span>sig_type_decl<span class="token punctuation">:</span><span class="token punctuation">(</span>signature<span class="token punctuation">,</span> rec_flag <span class="token operator">*</span> type_declaration list<span class="token punctuation">)</span> <span class="token module variable">Generator</span><span class="token punctuation">.</span>t\n  <span class="token operator">-></span> <span class="token operator">?</span>sig_type_ext <span class="token punctuation">:</span><span class="token punctuation">(</span>signature<span class="token punctuation">,</span> type_extension                  <span class="token punctuation">)</span> <span class="token module variable">Generator</span><span class="token punctuation">.</span>t\n  <span class="token operator">-></span> <span class="token operator">?</span>sig_exception<span class="token punctuation">:</span><span class="token punctuation">(</span>signature<span class="token punctuation">,</span> extension_constructor           <span class="token punctuation">)</span> <span class="token module variable">Generator</span><span class="token punctuation">.</span>t\n  <span class="token operator">-></span> <span class="token operator">?</span>extension<span class="token punctuation">:</span><span class="token punctuation">(</span>loc<span class="token punctuation">:</span><span class="token module variable">Location</span><span class="token punctuation">.</span>t <span class="token operator">-></span> path<span class="token punctuation">:</span>string <span class="token operator">-></span> core_type <span class="token operator">-></span> expression<span class="token punctuation">)</span>\n  <span class="token operator">-></span> string\n  <span class="token operator">-></span> t</code></pre></div>\n<p>It takes a mandatory string argument, here <code>"my_deriver"</code>, which defines how\nuser are going to invoke your deriver. In this case we\'d need to add a <code>[@@deriving my_deriver]</code> to\na type declaration in a structure or a signature to use it.\nThen there\'s just one optional argument per kind of node to which you can attach a <code>[@@deriving ...]</code>\nattribute. <code>type_decl</code> correspond to <code>type = ...</code>, <code>type_ext</code> to <code>type += ...</code> and <code>exception</code> to\n<code>exception My_exc of ...</code>.\nYou need to provide generators for the ones you wish your deriver to handle, <code>ppxlib</code>\nwill make sure users get a compile error if they try to use it elsewhere.\nWe can ignore the <code>extension</code> as it\'s just here for compatibility with <code>ppx_deriving</code>.</p>\n<p>Now let\'s take a look at <code>Generator</code>. Its type is defined as <code>(\'output_ast, \'input_ast) t</code> where\n<code>\'input_ast</code> is the type of the node to which the <code>[@@deriving ...]</code> is attached and <code>\'output_ast</code>\nthe type of the nodes it should produce, ie either a <code>structure</code> or a <code>signature</code>. The type of a\ngenerator depends on the expand function it\'s built from when you use the smart constructor\n<code>make_no_arg</code> meaning the expand function should have type\n<code>loc: Location.t -> path: string -> \'input_ast -> \'output_ast</code>. This function is the actual\nimplementation of your deriver and will generate the list of <code>structure_item</code> or <code>signature_item</code>\nfrom the type declaration.</p>\n<h4 id="compatibility-with-ppx_import" style="position:relative;"><a href="#compatibility-with-ppx_import" aria-label="compatibility with ppx_import permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compatibility with <code>ppx_import</code></h4>\n<p><a href="https://github.com/ocaml-ppx/ppx_import"><code>ppx_import</code></a> is a PPX rewriter that lets you import type\ndefinitions and spares you the need to copy and update them every time they change upstream. The\nmain reason why you would want to do that is because you need to derive values from those types\nusing a deriver thus the importance of ensuring your deriving plugin is compatible.</p>\n<p>Let\'s take an example to illustrate how <code>ppx_import</code> is used. I\'m using a library called <code>blob</code>\nwhich exposes a type <code>Blob.t</code>. For some reason I need to be able to serialize and deserialize\n<code>Blob.t</code> values to JSON. I\'d like to use a deriver to do that as I don\'t want to maintain that code\nmyself. Imagine <code>Blob.t</code> is defined as:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> t <span class="token operator">=</span>\n  <span class="token punctuation">{</span> <span class="token keyword">value</span> <span class="token punctuation">:</span> string\n  <span class="token punctuation">;</span> length <span class="token punctuation">:</span> int\n  <span class="token punctuation">;</span> id <span class="token punctuation">:</span> int\n  <span class="token punctuation">}</span></code></pre></div>\n<p>Without <code>ppx_import</code> I would define somewhere a <code>serializable_blob</code> type as follows:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> serializable_blob <span class="token operator">=</span> <span class="token module variable">Blob</span><span class="token punctuation">.</span>t <span class="token operator">=</span>\n  <span class="token punctuation">{</span> <span class="token keyword">value</span> <span class="token punctuation">:</span> string\n  <span class="token punctuation">;</span> length <span class="token punctuation">:</span> int\n  <span class="token punctuation">;</span> id <span class="token punctuation">:</span> int\n  <span class="token punctuation">}</span>\n<span class="token punctuation">[</span><span class="token operator">@@</span>deriving yojson<span class="token punctuation">]</span></code></pre></div>\n<p>That works well especially because the type definition is simple but I don\'t really care about\nhaving it here, what I really want is just the <code>to_yojson</code> and <code>of_yojson</code> functions. Also now, if\nthe type definition changes, I have to update it here manually. Maintaining many such imports can be\ntedious and duplicates a lot of code unnecessarily.</p>\n<p>What I can do instead, thanks to <code>ppx_import</code> is to write it like this:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> serializable_blob <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">%</span>import<span class="token punctuation">:</span> <span class="token module variable">Blob</span><span class="token punctuation">.</span>t<span class="token punctuation">]</span>\n<span class="token punctuation">[</span><span class="token operator">@@</span>deriving yojson<span class="token punctuation">]</span></code></pre></div>\n<p>which will ultimately be expanded into the above using <code>Blob</code>\'s definition of the type <code>t</code>.</p>\n<p>Now <code>ppx_import</code> works a bit differently from regular PPX rewriters as it needs a bit more information\nthan just the AST. We don\'t need to understand how it works but what it means is that if your\nderiving plugin is used with <code>ppx_import</code>, it will be called twice:</p>\n<ul>\n<li>A first time with <code>ocamldep</code>. This is required to determine the dependencies of a module in terms\nof other OCaml modules. PPX-es need to be applied here to find out about dependencies they may\nintroduce.</li>\n<li>A second time before actually compiling the code.</li>\n</ul>\n<p>The issue here is that during the <code>ocamldep</code> pass, <code>ppx_import</code> doesn\'t have the information it\nneeds to import the type definition yet so it can\'t copy it and it expands:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> u <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">%</span>import A<span class="token punctuation">.</span>t<span class="token punctuation">]</span></code></pre></div>\n<p>into:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> u <span class="token operator">=</span> A<span class="token punctuation">.</span>t</code></pre></div>\n<p>Only during the second pass will it actually expand it to the copied type definition.</p>\n<p>This may be a concern if your deriving plugin can\'t apply to abstract types because you will\nprobably raise an error when encountering one, meaning the first phase will fail and the whole\ncompilation will fail without giving your rewriter a chance to derive anything from the copied\ntype definition.</p>\n<p>The right way to deal with this is to have different a behaviour in the context of <code>ocamldep</code>.\nIn this case you can ignore such type declaration or eventually, if you know you are going to\ninject new dependencies in your generated code, to create dummy values referencing them and just\nbehave normally in any other context.</p>\n<p><code>ppxlib</code> versions <code>0.6.0</code> and higher allow you to do so through the <code>Deriving.Generator.V2</code> API\nwhich passes an abstract <code>ctxt</code> value to your <code>expand</code> function instead of a <code>loc</code> and a <code>path</code>.\nYou can tell whether it is the <code>ocamldep</code> pass from within the <code>expand</code> function like this:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> <span class="token module variable">Ppxlib</span>\n\n<span class="token keyword">let</span> expand <span class="token label function">~ctxt</span> input_ast <span class="token operator">=</span>\n  <span class="token keyword">let</span> omp_config <span class="token operator">=</span> <span class="token module variable">Expansion_context</span><span class="token punctuation">.</span><span class="token module variable">Deriver</span><span class="token punctuation">.</span>omp_config ctxt <span class="token keyword">in</span>\n  <span class="token keyword">let</span> is_ocamldep_pass <span class="token operator">=</span> <span class="token module variable">String</span><span class="token punctuation">.</span>equal <span class="token string">"ocamldep"</span> omp_config<span class="token punctuation">.</span><span class="token module variable">Migrate_parsetree</span><span class="token punctuation">.</span><span class="token module variable">Driver</span><span class="token punctuation">.</span>tool_name <span class="token keyword">in</span>\n  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></div>\n<h4 id="deriver-attributes" style="position:relative;"><a href="#deriver-attributes" aria-label="deriver attributes permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deriver attributes</h4>\n<p>You\'ll have noted the <code>attributes</code> parameter in the examples. It\'s an optional parameter that lets\nyou define which attributes your deriver allows the user to attach to various bits of the type,\ntype extension or exception declaration it is applied to.</p>\n<p><code>ppxlib</code> comes with a <code>Attribute</code> module that lets you to properly declare the attributes you want\nto allow and make sure they are properly used: correctly spelled, placed and with the right\npayload attached. This is especially useful since attributes are by default ignored by the compiler\nmeaning without <code>ppxlib</code>\'s care, plugin users wouldn\'t get any errors if they misused an attribute\nand it might take them a while to figure out they got it wrong and the generated code wasn\'t\nimpacted as they hoped.\nThe <code>Attribute</code> module offers another great feature: <code>Attribute.t</code> values can be used to extract the\nattribute payload from an AST node if it is present. That will spare you the need for\ninspecting attributes yourself which can prove quite tedious.</p>\n<p><code>Ppxlib.Attribute.t</code> is defined as <code>(\'context, \'payload) t</code> where <code>\'context</code> describes to which node\nthe attribute can be attached and <code>\'payload</code>, the type of its payload.\nTo build such an attribute you must use <code>Ppxlib.Attribute.declare</code>:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> declare\n  <span class="token punctuation">:</span>  string\n  <span class="token operator">-></span> <span class="token type-variable function">\'a</span> <span class="token module variable">Context</span><span class="token punctuation">.</span>t\n  <span class="token operator">-></span> <span class="token punctuation">(</span>payload<span class="token punctuation">,</span> <span class="token type-variable function">\'b</span><span class="token punctuation">,</span> <span class="token type-variable function">\'c</span><span class="token punctuation">)</span> <span class="token module variable">Ast_pattern</span><span class="token punctuation">.</span>t\n  <span class="token operator">-></span> <span class="token type-variable function">\'b</span>\n  <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token type-variable function">\'a</span><span class="token punctuation">,</span> <span class="token type-variable function">\'c</span><span class="token punctuation">)</span> t</code></pre></div>\n<p>Let\'s try to declare the <code>default</code> argument from <code>ppx_deriving_yojson</code> I mentioned earlier.</p>\n<p>The first <code>string</code> argument is the attribute name. <code>ppxlib</code> support namespaces for the attributes so\nthat users can avoid conflicting attributes between various derivers applied to the same type\ndefinitions. For instance here we could use <code>"default"</code>. It can prove helpful to use more qualified\nname such as <code>"ppx_deriving_yojson.of_yojson.default"</code>. That means that our attribute can be used as\n<code>[@@default ...]</code>, <code>[@@of_yojson.default ...]</code> or <code>[@@ppx_deriving.of_yojson.default ...]</code>.\nNow if another deriver uses a <code>[@@default ...]</code>, users can apply both derivers and provide different\n<code>default</code> values to the different derivers by writing:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> t <span class="token operator">=</span>\n  <span class="token punctuation">{</span> a <span class="token punctuation">:</span> int\n  <span class="token punctuation">;</span> b <span class="token punctuation">:</span> string <span class="token punctuation">[</span><span class="token operator">@</span>make<span class="token punctuation">.</span>default <span class="token string">"abc"</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">@</span>of_yojson<span class="token punctuation">.</span>default <span class="token string">""</span><span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">[</span><span class="token operator">@@</span>deriving make<span class="token punctuation">,</span>of_yojson<span class="token punctuation">]</span></code></pre></div>\n<p>The context argument works very similarly to the one in <code>Extension.declare</code>. Here we want the\nattribute to be attached to record field declarations so we\'ll use\n<code>Attribute.Context.label_declaration</code> which has type <code>label_declaration Attribute.Context.t</code>.</p>\n<p>The pattern argument is an <code>Ast_pattern.t</code>. Now that we know how to work with those this is pretty\neasy. Here we need to accept any expression as a payload since we should be able to apply the\n<code>default</code> attribute to any field, regardless of its type and we want to extract that expression from\nthe payload so we can use it in our deserializer so let\'s use\n<code>Ast_pattern.(single_expr_payload __)</code>.</p>\n<p>Finally the last <code>\'b</code> argument has the same type as the pattern consumer function. We can use it to\ntransform what we extracted using the previous <code>Ast_pattern</code> but in this case we just want to\nkeep the expression as we got it so we\'ll just use the identity function here.</p>\n<p>We end up with the following:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> default_attribute <span class="token operator">=</span>\n  <span class="token module variable">Attribute</span><span class="token punctuation">.</span>declare\n    <span class="token string">"ppx_deriving_yojson.of_yojson.default"</span>\n    <span class="token module variable">Attribute</span><span class="token punctuation">.</span><span class="token module variable">Context</span><span class="token punctuation">.</span>label_declaration\n    <span class="token module variable">Ast_pattern</span><span class="token punctuation">.</span><span class="token punctuation">(</span>single_expr_payload __<span class="token punctuation">)</span>\n    <span class="token punctuation">(</span><span class="token keyword">fun</span> expr <span class="token operator">-></span> expr<span class="token punctuation">)</span></code></pre></div>\n<p>and that gives us a <code>(label_declaration, expression) Attribute.t</code>.</p>\n<p>You can then use it to collect the attribute payload from a label_declaration:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token module variable">Attribute</span><span class="token punctuation">.</span>get default_attribute label_decl</code></pre></div>\n<p>which will return <code>Some expr</code> if the attribute was attached to <code>label_decl</code> or <code>None</code> otherwise.</p>\n<p>Because of their polymorphic nature, attributes need to be packed, ie to be wrapped with a variant\nto hide the type parameter, so if you want to pass it to <code>Generator.make_no_arg</code> you\'ll have to do\nit like this:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> attributes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token module variable">Attribute</span><span class="token punctuation">.</span>T default_attribute<span class="token punctuation">]</span></code></pre></div>\n<h3 id="writing-your-expand-functions" style="position:relative;"><a href="#writing-your-expand-functions" aria-label="writing your expand functions permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writing your expand functions</h3>\n<p>In the two last sections I mentioned <code>expand</code> functions that would contain the actual <code>deriver</code> or\n<code>extension</code> implementation but didn\'t actually said anything about how to write those. It will\ndepend a lot on the purpose of your PPX rewriter and what you\'re trying to achieve.</p>\n<p>Before writing your PPX you should clearly specify what it should be applied to and what code it\nshould produce. That will help you declaring the right deriving or extension rewriter and from there\nyou\'ll know the type of the <code>expand</code> functions you have to write which should help.</p>\n<p>A good way to proceed is to use the <code>dumpast</code> tool to pretty print the AST fragments of both the\ninput of your expander and the output, ie the code it should generate. To take a concrete example,\nsay you want to write a deriving plugin that generates an <code>equal</code> function from a type definition.\nYou can start by running <code>dumpast</code> on the following file:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> some_record <span class="token operator">=</span>\n  <span class="token punctuation">{</span> a <span class="token punctuation">:</span> int64\n  <span class="token punctuation">;</span> b <span class="token punctuation">:</span> string\n  <span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> equal_some_record r r\' <span class="token operator">=</span> <span class="token module variable">Int64</span><span class="token punctuation">.</span>equal r<span class="token punctuation">.</span>a r\'<span class="token punctuation">.</span>a <span class="token operator">&amp;&amp;</span> <span class="token module variable">String</span><span class="token punctuation">.</span>equal r<span class="token punctuation">.</span>b r\'<span class="token punctuation">.</span>b</code></pre></div>\n<p>That will give you the AST representation of a record type definition and the equal function you\nwant to write so you can figure out how to deconstruct your expander\'s input to be able to generate\nthe right output.</p>\n<p><code>ppxlib</code> exposes smart constructors in <code>Ppxlib.Ast_builder.Default</code> to help you build AST fragments\nwithout having to care too much attributes and such fields as well as some convenience constructors\nto keep your code concise and readable.</p>\n<p>Another convenience tool <code>ppxlib</code> exposes to help you build AST fragments is <code>metaquot</code>. I recently\nwrote a bit of documentation about it\n<a href="https://ppxlib.readthedocs.io/en/latest/ppx-for-plugin-authors.html#metaquot">here</a> which you\nshould take a look at but to sum it up <code>metaquot</code> is a PPX extension allowing you to write AST nodes\nusing the OCaml syntax they describe instead of the AST types.</p>\n<h4 id="handling-code-locations-in-a-ppx-rewriter" style="position:relative;"><a href="#handling-code-locations-in-a-ppx-rewriter" aria-label="handling code locations in a ppx rewriter permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Handling code locations in a PPX rewriter</h4>\n<p>When building AST fragments you should keep in mind that you have to set their <code>location</code>. Locations\nare part of the AST values that describes the position of the corresponding node in your source\nfile, including the file name and the line number and offset of both the beginning and the end the\ncode bit they represent.</p>\n<p>Because your code was generated after the file was parsed, it doesn\'t have a location so you need to\nset it yourself. One could think that it doesn\'t matter and we could use a dummy location but\nlocations are used by the compiler to properly report errors and that\'s why a PPX rewriter should care\nabout how it locates the generated code as it will help the end user to understand whether the error\ncomes from their code or generated code and how to eventually fix it.</p>\n<p>Both <code>Ast_builder</code> and <code>metaquot</code> expect a location. The first explicitly takes it as a labelled\n<code>loc</code> argument while the second relies on a <code>loc</code> value being available in the scope. It is\nimportant to set those with care as errors in the generated code doesn\'t necessarily mean that your\nrewriter is bugged. There are valid cases where your rewriter functioned as intended but the generated\ncode triggers an error. PPX-es often work on the assumption that some values are available in the\nscope, if the user doesn\'t properly provide those it\'s their responsibility to fix the error. To\nhelp them do so, it is important to properly locate the generated code to guide them as much as\npossible.</p>\n<p>When writing extensions, using the whole extension point location for the generated code makes\nperfect sense as that\'s where the code will sit. That\'s fairly easy as this what <code>ppxlib</code> passes\nto the expand function through the <code>loc</code> labelled argument. For deriving plugins it\'s a bit different\nas the generated code doesn\'t replace an existing part of the parsed AST but generate a new one to insert.\nCurrently <code>ppxlib</code> gives you the <code>loc</code> of the whole type declaration, extension or exception\ndeclaration your deriving plugin is applied to. Ideally it would be nice to be able to locate the\ngenerated code on the plugin name in the <code>deriving</code> attribute payload, ie here:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">[@@deriving my_plugin,another_plugin]\n            ^^^^^^^^^</code></pre></div>\n<p>I\'m currently working on making that location available to the <code>expand</code> function. In the meantime,\nyou should choose a convention. I personally locate all the generated code on the\ntype declaration. Some choose to locate the generated code on the part of the input AST they\'re\nhandling when generating it.</p>\n<h4 id="reporting-errors-to-your-rewriter-users" style="position:relative;"><a href="#reporting-errors-to-your-rewriter-users" aria-label="reporting errors to your rewriter users permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reporting errors to your rewriter users</h4>\n<p>You won\'t always be able to handle all the AST nodes passed to your expand functions, either because the\nend user misused your rewriter or because there are some cases you simply can\'t deal with.</p>\n<p>In those cases you can report the error to the user with <code>Ppxlib.Location.raise_errorf</code>. It works\nsimilarly to <code>printf</code> and you can build your error message from a format string and extra\narguments. It will then raise an exception which will be caught and reported by the compiler.\nA good practice is to prefix the error message with the name of your rewriter to help users understand\nwhat\'s going on, especially with deriving plugin as they might use several of them on the same type\ndeclaration.</p>\n<p>Another point to take care of here is, again, locations. <code>raise_errorf</code> takes a labelled <code>loc</code>\narguments. It is used so that your error is reported as any compiler error. Having good locations in\nthose error messages is just as important as sending clear error messages. Keep in mind that both\nthe errors you report yourself or errors coming from your generated code will be highlighted by\nmerlin so when properly set they make it much easier to work with your PPX rewriter.</p>\n<h3 id="testing-your-ppx" style="position:relative;"><a href="#testing-your-ppx" aria-label="testing your ppx permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testing your PPX</h3>\n<p>Just as most pieces of code do, a PPX deserves to be tested and it has become easier over the years to\ntest rewriters.</p>\n<p>I personally tend to write as many unit test as possible for my PPX-es internal libraries. I try to\nextract helper functions that can easily be unit-tested but I can\'t test it all that way.\nTesting the <code>ast -> ast</code> functions would be tedious as <code>ppxlib</code> and <code>ocaml-migrate-parsetree</code>\ndon\'t provide comparison and pretty printing functions that you can use with <code>alcotest</code> or <code>oUnit</code>.\nThat means you\'d have to import the AST types and derive them on your own. That would make a lot\nof boiler plate and even if those functions were exposed, writing such tests would be really\ntedious. There\'s a lot of things to take into account. How are you going to build the input AST values\nfor instance?  If you use <code>metaquot</code>, every node will share the same loc, making it hard to test\nthat your errors are properly located. If you don\'t, you will end up with insanely long and\nunreadable test code or fixtures.\nWhile that would allow extremely accurate testing for the generated code and errors, it will almost\ncertainly make your test code unmaintainable, at least given the current tooling.</p>\n<p>Don\'t panic, there is a very good and simple alternative. <code>ppxlib</code> makes it very easy to build a\nbinary that will parse OCaml code, preprocess the AST with your rewriter and spit it out, formatted as\ncode again.</p>\n<p>You just have to write the following <code>pp.ml</code>:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token module variable">Ppxlib</span><span class="token punctuation">.</span><span class="token module variable">Driver</span><span class="token punctuation">.</span>standalone <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>\n<p>and build the binary with the following <code>dune</code> stanza, assuming your rewriter is called\n<code>my_ppx_rewriter</code>:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(executable\n (name pp)\n (modules pp)\n (libraries my_ppx_rewriter ppxlib))</code></pre></div>\n<p>Because we\'re humans and the OCaml syntax is meant for us to write and read, it makes for much better\ntest input/output. You can now write your test input in a regular <code>.ml</code> file, use the <code>pp.exe</code>\nbinary to "apply" your preprocessor to it and compare the output with another <code>.ml</code> file containing\nthe code you expect it to generate. This kind of test pattern is really well supported by <code>dune</code>\nthanks to the <code>diff</code> user action.</p>\n<p>I usually have the following files in a <code>rewriter</code>/<code>deriver</code> folder within my test directory:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">test/rewriter/\n\u251c\u2500\u2500 dune\n\u251c\u2500\u2500 test.expected.ml\n\u251c\u2500\u2500 pp.ml\n\u2514\u2500\u2500 test.ml</code></pre></div>\n<p>Where <code>pp.ml</code> is used to produce the rewriter binary, <code>test.ml</code> contains the input OCaml code and\n<code>test.expected.ml</code> the result of preprocessing <code>test.ml</code>. The dune file content is generally similar\nto this:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(executable\n (name pp)\n (modules pp)\n (libraries my_ppx_rewriter ppxlib))\n\n(rule\n (targets test.actual.ml)\n (deps (:pp pp.exe) (:input test.ml))\n (action (run ./%{pp} -deriving-keep-w32 both --impl %{input} -o %{targets})))\n\n(alias\n (name runtest)\n (action (diff test.expected.ml test.actual.ml)))\n\n(test\n  (name test)\n  (modules test)\n  (preprocess (pps my_ppx_rewriter)))</code></pre></div>\n<p>The first stanza is the one I already introduced above and specifies how to build the rewriter binary.</p>\n<p>The <code>rule</code> stanza that comes after that indicates to <code>dune</code> how to produce the actual test output by\napplying the rewriter binary to <code>test.ml</code>. You probably noticed the <code>-deriving-keep-w32 both</code> CLI\noption passed to <code>pp.exe</code>. By default, <code>ppxlib</code> will generate values or add attributes so that your\ngenerated code doesn\'t trigger a "Unused value" warning. This is useful in real life situation but\nhere it will just pollute the test output and make it harder to read so we disable that feature.</p>\n<p>The following <code>alias</code> stanza is where all the magic happens. Running <code>dune runtest</code> will now\ngenerate <code>test.actual.ml</code> and compare it to <code>test.expected.ml</code>. It will not only do that but show\nyou how they differ from each other in a diff format. You can then automatically update\n<code>test.expected.ml</code> if you\'re happy with the results by running <code>dune promote</code>.</p>\n<p>Finally the last <code>test</code> stanza is there to ensure that the generated code compiles without type\nerrors.</p>\n<p>This makes a very convenient test setup to write your PPX-es TDD style. You can start by writing an\nidentity PPX, that will just return its input AST as it is. Then you add some OCaml code using your\nsoon to be PPX in <code>test.ml</code> and run <code>dune runtest --auto-promote</code> to prefill <code>test.expected.ml</code>.\nFrom there you can start implementing your rewriter and run <code>dune runtest</code> to check on your progress\nand update the expected result with <code>dune promote</code>.\nGoing pure TDD by writing the test works but it\'s tricky cause you\'d have to format your code the\nsame way <code>pp.exe</code> will format the AST. It would be great to be able to specify how to format\nthe generated <code>test.actual.ml</code> so that this approach would be more viable and the diff more\nreadable. Being able to use ocamlformat with a very diff friendly configuration would be great\nthere. <code>pp.exe</code> seems to offer CLI options to change the code style such as <code>-styler</code> but I haven\'t\nhad the chance to experiment with those yet.</p>\n<p>Now you can test successful rewriting this way but what about errors? There\'s a lot of value\nensuring you produce the right errors and on the right code location because that\'s the kind of\nthings you can get wrong when refactoring your rewriter code or when people try to contribute.\nThat isn\'t as likely to happen if your CI yells when you break the error reporting. So how do we do\nthat?</p>\n<p>Well pretty much the exact same way! We write a file with an erroneous invocation of our rewriter,\nrun <code>pp.exe</code> on it and compare stderr with what we expect it to be.\nThere are two major differences here. First we want to collect the stderr output of the rewriter\nbinary instead of using it to generate a file. The second is that we cant write all of our test\ncases in a single file since <code>pp.exe</code> will stop at the first error. That means we need one <code>.ml</code>\nfile per error test case.\nLuckily for us, dune offers ways to do both.</p>\n<p>For every error test file we will want to add the following stanzas:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(rule\n  (targets test_error.actual)\n  (deps (:pp pp.exe) (:input test_error.ml)) \n  (action\n    (with-stderr-to\n      %{targets}\n      (bash &quot;./%{pp} -no-color --impl %{input} || true&quot;)\n    )\n  )\n)\n\n(alias\n  (name runtest)\n  (action (diff test_error.expected test_error.actual))\n)</code></pre></div>\n<p>but obviously we don\'t want to do that by hand every time we add a new test case so we\'re gonna need\na script to generate those stanzas and then include them into our <code>dune</code> file using\n<code>(include dune.inc)</code>.</p>\n<p>To achieve that while keeping things as clean as possible I use the following directory structure:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">test/rewriter/\n\u251c\u2500\u2500 errors\n\u2502\xa0\xa0 \u251c\u2500\u2500 dune\n\u2502\xa0\xa0 \u251c\u2500\u2500 dune.inc\n\u2502\xa0\xa0 \u251c\u2500\u2500 gen_dune_rules.ml\n\u2502\xa0\xa0 \u251c\u2500\u2500 pp.ml\n\u2502\xa0\xa0 \u251c\u2500\u2500 test_some_error.expected\n\u2502\xa0\xa0 \u251c\u2500\u2500 test_some_error.ml\n\u2502\xa0\xa0 \u251c\u2500\u2500 test_some_other_error.expected\n\u2502\xa0\xa0 \u2514\u2500\u2500 test_some_other_error.ml\n\u251c\u2500\u2500 dune\n\u251c\u2500\u2500 test.expected.ml\n\u251c\u2500\u2500 pp.ml\n\u2514\u2500\u2500 test.ml</code></pre></div>\n<p>Compared to our previous setup, we only added the new <code>errors</code> folder. To keep things simple it has\nits own <code>pp.ml</code> copy but in the future I\'d like to improve it a bit and be able to use the same\n<code>pp.exe</code> binary.</p>\n<p>The most important files here are <code>gen_dune_rules.ml</code> and <code>dune.inc</code>. The first is just a simple\nOCaml script to generate the above stanzas for each test cases in the <code>errors</code> directory. The second\nis the file we\'ll include in the main <code>dune</code>. It\'s also the file to which we\'ll write the generated\nstanza.</p>\n<p>I personally use the following <code>gen_dune_rules.ml</code>:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> output_stanzas filename <span class="token operator">=</span>\n  <span class="token keyword">let</span> base <span class="token operator">=</span> <span class="token module variable">Filename</span><span class="token punctuation">.</span>remove_extension filename <span class="token keyword">in</span>\n  <span class="token module variable">Printf</span><span class="token punctuation">.</span>printf\n    <span class="token punctuation">{</span><span class="token operator">|</span>\n<span class="token punctuation">(</span>library\n  <span class="token punctuation">(</span>name <span class="token operator">%</span>s<span class="token punctuation">)</span>\n  <span class="token punctuation">(</span>modules <span class="token operator">%</span>s<span class="token punctuation">)</span>\n  <span class="token punctuation">(</span>preprocess <span class="token punctuation">(</span>pps ppx_yojson<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span>\n\n<span class="token punctuation">(</span>rule\n  <span class="token punctuation">(</span>targets <span class="token operator">%</span>s<span class="token punctuation">.</span>actual<span class="token punctuation">)</span>\n  <span class="token punctuation">(</span>deps <span class="token punctuation">(</span><span class="token punctuation">:</span>pp pp<span class="token punctuation">.</span>exe<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">:</span>input <span class="token operator">%</span>s<span class="token punctuation">.</span>ml<span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">(</span>action\n    <span class="token punctuation">(</span><span class="token keyword">with</span><span class="token operator">-</span>stderr<span class="token operator">-</span><span class="token keyword">to</span>\n      <span class="token operator">%%</span><span class="token punctuation">{</span>targets<span class="token punctuation">}</span>\n      <span class="token punctuation">(</span>bash <span class="token string">"./%%{pp} -no-color --impl %%{input} || true"</span><span class="token punctuation">)</span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">)</span>\n\n<span class="token punctuation">(</span>alias\n  <span class="token punctuation">(</span>name runtest<span class="token punctuation">)</span>\n  <span class="token punctuation">(</span>action <span class="token punctuation">(</span>diff <span class="token operator">%</span>s<span class="token punctuation">.</span>expected <span class="token operator">%</span>s<span class="token punctuation">.</span>actual<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span>\n<span class="token operator">|</span><span class="token punctuation">}</span>\n    base\n    base\n    base\n    base\n    base\n    base\n\n<span class="token keyword">let</span> is_error_test <span class="token operator">=</span> <span class="token keyword">function</span>\n  <span class="token operator">|</span> <span class="token string">"pp.ml"</span> <span class="token operator">-></span> <span class="token boolean">false</span>\n  <span class="token operator">|</span> <span class="token string">"gen_dune_rules.ml"</span> <span class="token operator">-></span> <span class="token boolean">false</span>\n  <span class="token operator">|</span> filename <span class="token operator">-></span> <span class="token module variable">Filename</span><span class="token punctuation">.</span>check_suffix filename <span class="token string">".ml"</span>\n\n<span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n  <span class="token module variable">Sys</span><span class="token punctuation">.</span>readdir <span class="token string">"."</span>\n  <span class="token operator">|></span> <span class="token module variable">Array</span><span class="token punctuation">.</span>to_list\n  <span class="token operator">|></span> <span class="token module variable">List</span><span class="token punctuation">.</span>sort <span class="token module variable">String</span><span class="token punctuation">.</span>compare\n  <span class="token operator">|></span> <span class="token module variable">List</span><span class="token punctuation">.</span>filter is_error_test\n  <span class="token operator">|></span> <span class="token module variable">List</span><span class="token punctuation">.</span>iter output_stanzas</code></pre></div>\n<p>Nothing spectacular here, we just build the list of all the <code>.ml</code> files in the directory except\n<code>pp.ml</code> and <code>gen_dune_rules.ml</code> itself and then generate the right stanzas for each of them. You\'ll\nnote the extra <code>library</code> stanza which I add to get dune to generate the right <code>.merlin</code> so that I\ncan see the error highlights when I edit the files by hand.</p>\n<p>With that we\'re almost good, add the following to the <code>dune</code> file and you\'re all set:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(executable\n  (name pp)\n  (modules pp)\n  (libraries\n    ppx_yojson\n    ppxlib\n  )\n)\n\n(include dune.inc)\n\n(executable\n  (name gen_dune_rules)\n  (modules gen_dune_rules)\n)\n\n(rule\n  (targets dune.inc.gen)\n  (deps\n    (:gen gen_dune_rules.exe)\n    (source_tree .)\n  )\n  (action\n    (with-stdout-to\n      %{targets}\n      (run %{gen})\n    ) \n  )\n)\n\n(alias\n  (name runtest)\n  (action (diff dune.inc dune.inc.gen))\n)</code></pre></div>\n<p>The first stanza is here to specify how to build the rewriter binary, same as before, while the\nsecond stanza just tells dune to include the content of <code>dune.inc</code> within this <code>dune</code> file.</p>\n<p>The interesting part comes next. As you can guess the <code>executable</code> stanza builds our little OCaml\nscript into a <code>.exe</code>. The <code>rule</code> that comes after that specifies how to generate the new stanzas\nby running <code>gen_dune_rules</code> and capturing its standard output into a <code>dune.inc.gen</code> file.\nThe last rule allows you to review the changes to the generated stanza and use promotion to accept\nthem. Once this is done, the new stanzas will be included to the <code>dune</code> file and the test will be\nrun for every test cases.</p>\n<p>Adding a new test case is then pretty easy, you can simply run:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ touch test/rewriter/errors/some_explicit_test_case_name.{ml,expected} &amp;&amp; dune runtest --auto-promote</code></pre></div>\n<p>That will create the new empty test case and update the <code>dune.inc</code> with the corresponding rules.\nFrom there you can proceed the same way as with the successful rewriting tests, update the <code>.ml</code>,\nrun <code>dune runtest</code> to take a sneak peek at the output and <code>dune promote</code> once you\'re satisfied with\nthe result.</p>\n<p>I\'ve been pretty happy with this setup so far although there\'s room for improvement. It would be\nnice to avoid duplicating <code>pp.ml</code> for errors testing. This also involves\nquite a bit of boilerplate that I have to copy into all my PPX rewriters repositories every time.\nHopefully <a href="https://github.com/ocaml/dune/issues/1855">dune plugins</a> should help with that and I\ncan\'t wait for a first version to be released so that I can write a plugin to make this test\npattern more accessible and easier to set up.</p>'},tl:{hd:{title:"Building portable user interfaces with Nottui and Lwd",slug:"building-portable-user-interfaces-with-nottui-and-lwd",description:"At Tarides, we build many tools and writing UI is usually a tedious task. In this post we will see how to write functional UIs in OCaml\u2026",url:"https://tarides.com/blog/2020-09-24-building-portable-user-interfaces-with-nottui-and-lwd",date:"2020-09-24T00:00:00-00:00",preview_image:"https://tarides.com/static/06fbdcdb40efa879b814b744c5ea3fbf/497c6/nottui-rain.png",body_html:'<p>At Tarides, we build many tools and writing UI is usually a tedious task. In this post we will see how to write functional UIs in OCaml using the <code>Nottui</code> &#x26; <code>Lwd</code> libraries.</p>\n<p>These libraries were developed for <a href="https://github.com/ocurrent/citty">Citty</a>, a frontend to the <a href="https://github.com/ocurrent/ocaml-ci">Continuous Integration service</a> of OCaml Labs.</p>\n<div>\n  <video controls width="100%">\n    <source src="./nottui-citty.mp4" type="video/mp4" />\n    <source src="./nottui-citty.webm" type="video/webm;codecs=vp9" />\n  </video>\n</div>\n<p>In this recording, you can see the lists of repositories, branches and jobs monitored by the CI service, as well as the result of job execution. Most of the logic is asynchronous, with all the contents being received from the network in a non-blocking way.</p>\n<p><code>Nottui</code> extends <a href="https://github.com/pqwy/notty">Notty</a>, a library for declaring terminal images, to better suit the needs of UIs. <code>Lwd</code> (Lightweight Document) exposes a simple form of reactive computation (values that evolve over time). It can be thought of as an alternative to the DOM, suitable for building interactive documents.\nThey are used in tandem: <code>Nottui</code> for rendering the UI and <code>Lwd</code> for making it interactive.</p>\n<h2 id="nottui--notty-with-layout-and-events" style="position:relative;"><a href="#nottui--notty-with-layout-and-events" aria-label="nottui  notty with layout and events permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nottui = Notty with layout and events</h2>\n<p>Notty exposes a nice way to display images in a terminal. A Notty image is matrix of characters with optional styling attributes (tweaking foreground and background colors, using <strong>bold</strong> glyphs...).</p>\n<p>These images are pure values and can be composed (concatenated, cropped, ...) very efficiently, making them very convenient to manipulate in a functional way.</p>\n<p>However these images are inert: their contents are fixed and their only purpose is to be displayed. Nottui reuses Notty images and exposes essentially the same interface but it adds two features: layout &#x26; event dispatch. UI elements now adapt to the space available and can react to keyboard and mouse actions.</p>\n<p><strong>Layout DSL</strong>. Specifying a layout is done using "stretchable" dimensions, a concept loosely borrowed from TeX. Each UI element has a fixed size (expressed as a number of columns and rows) and a stretchable size (possibly empty). The stretchable part is interpreted as a strength that is used to determine how to share the space available among all UI elements.</p>\n<p>This is a simple system amenable to an efficient implementation while being powerful enough to express common layout patterns.</p>\n<p><strong>Event dispatch</strong>. Reacting to mouse and keyboard events is better done using local behaviors, specific to an element. In Nottui, images are augmented with handlers for common actions. There is also a global notion of focus to determine which element should consume input events.</p>\n<h2 id="interactivity-with-lwd" style="position:relative;"><a href="#interactivity-with-lwd" aria-label="interactivity with lwd permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interactivity with Lwd</h2>\n<p>Nottui\'s additions are nice for resizing and attaching behaviors to images, but they are still static objects. In practice, user interfaces are very dynamic: parts can be independently updated to display new information.</p>\n<p>This interactivity layer is brought by Lwd and is developed separately from the core UI library. It is built around a central type, <code>\'a Lwd.t</code>, that represents a value of type <code>\'a</code> that can change over time.</p>\n<p><code>Lwd.t</code> is an <a href="https://en.wikipedia.org/wiki/Applicative_functor">applicative functor</a> (and even a monad), making it a highly composable abstraction.</p>\n<p>Primitive changes are introduced by <code>Lwd.var</code>, which are OCaml references with an extra operation <code>val get : \'a Lwd.var -> \'a Lwd.t</code>. This operation turns a variable into a <em>changing value</em> that changes whenever the variable is set.</p>\n<p>In practice this leads to a mostly declarative style of programming interactive documents (as opposed to the DOM that is deeply mutable). Most of the code is just function applications without spooky action at a distance! However, it is possible to opt-out of this pure style by introducing an <code>Lwd.var</code>, on a case-by-case basis.</p>\n<h2 id="and-much-more" style="position:relative;"><a href="#and-much-more" aria-label="and much more permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>And much more...</h2>\n<p>A few extra libraries are provided to target more specific problems.</p>\n<p><code>Lwd_table</code> and <code>Lwd_seq</code> are two datastructures to manipulate dynamic collections. <code>Nottui_pretty</code> is an interactive pretty printing library that supports arbitrary Nottui layouts and widgets. Finally <code>Tyxml_lwd</code> is a strongly-typed abstraction of the DOM driven by Lwd.</p>\n<p>Version 0.1 has just been released on OPAM.</p>\n<h2 id="getting-started" style="position:relative;"><a href="#getting-started" aria-label="getting started permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting started!</h2>\n<p>Here is a small example to start using the library. First, install the Nottui library:</p>\n<div class="gatsby-highlight" data-language="sh"><pre class="language-sh"><code class="language-sh">$ opam install nottui</code></pre></div>\n<p>Now we can play in the top-level. We will start with a simple button that counts the number of clicks:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token operator">$</span> utop\n# <span class="token directive important">#require</span> <span class="token string">"nottui"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>\n# <span class="token keyword">open</span> <span class="token module variable">Nottui</span><span class="token punctuation">;</span><span class="token punctuation">;</span>\n# <span class="token keyword">module</span> W <span class="token operator">=</span> <span class="token module variable">Nottui_widgets</span><span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token comment">(* State for holding the number of clicks *)</span>\n# <span class="token keyword">let</span> vcount <span class="token operator">=</span> <span class="token module variable">Lwd</span><span class="token punctuation">.</span>var <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token comment">(* Image of the button parametrized by the number of clicks *)</span>\n# <span class="token keyword">let</span> button count <span class="token operator">=</span>\n    W<span class="token punctuation">.</span>button <span class="token label function">~attr</span><span class="token punctuation">:</span><span class="token module variable">Notty</span><span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token punctuation">(</span>bg green <span class="token operator">++</span> fg black<span class="token punctuation">)</span>\n      <span class="token punctuation">(</span><span class="token module variable">Printf</span><span class="token punctuation">.</span>sprintf <span class="token string">"Clicked %d times!"</span> count<span class="token punctuation">)</span>\n      <span class="token punctuation">(</span><span class="token keyword">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token module variable">Lwd</span><span class="token punctuation">.</span>set vcount <span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token comment">(* Run the UI! *)</span>\n# <span class="token module variable">Ui_loop</span><span class="token punctuation">.</span>run <span class="token punctuation">(</span><span class="token module variable">Lwd</span><span class="token punctuation">.</span>map button <span class="token punctuation">(</span><span class="token module variable">Lwd</span><span class="token punctuation">.</span>get vcount<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre></div>\n<p><strong>Note:</strong> to quit the example, you can press Ctrl-Q or Esc.</p>\n<p>We will improve the example and turn it into a mini cookie clicker game.</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* Achievements to unlock in the cookie clicker *)</span>\n# <span class="token keyword">let</span> badges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">"Cursor"</span><span class="token punctuation">;</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token string">"Grandma"</span><span class="token punctuation">;</span> <span class="token number">150</span><span class="token punctuation">,</span> <span class="token string">"Farm"</span><span class="token punctuation">;</span> <span class="token number">300</span><span class="token punctuation">,</span> <span class="token string">"Mine"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token comment">(* List the achievements unlocked by the player *)</span>\n# <span class="token keyword">let</span> unlocked_ui count <span class="token operator">=</span>\n    <span class="token comment">(* Filter the achievements *)</span>\n    <span class="token keyword">let</span> predicate <span class="token punctuation">(</span>target<span class="token punctuation">,</span> text<span class="token punctuation">)</span> <span class="token operator">=</span>\n      <span class="token keyword">if</span> count <span class="token operator">>=</span> target\n      <span class="token keyword">then</span> <span class="token module variable">Some</span> <span class="token punctuation">(</span>W<span class="token punctuation">.</span>printf <span class="token string">"% 4d: %s"</span> target text<span class="token punctuation">)</span>\n      <span class="token keyword">else</span> <span class="token module variable">None</span>\n    <span class="token keyword">in</span>\n    <span class="token comment">(* Concatenate the UI elements vertically *)</span>\n    <span class="token module variable">Ui</span><span class="token punctuation">.</span>vcat <span class="token punctuation">(</span><span class="token module variable">List</span><span class="token punctuation">.</span>filter_map predicate badges<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token comment">(* Display the next achievement to reach *)</span>\n# <span class="token keyword">let</span> next_ui count <span class="token operator">=</span>\n    <span class="token keyword">let</span> predicate <span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> target <span class="token operator">></span> ciybt <span class="token keyword">in</span>\n    <span class="token keyword">match</span> <span class="token module variable">List</span><span class="token punctuation">.</span>find_opt predicate badges <span class="token keyword">with</span>\n    <span class="token operator">|</span> <span class="token module variable">Some</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">_</span><span class="token punctuation">)</span> <span class="token operator">-></span>\n      W<span class="token punctuation">.</span>printf <span class="token label function">~attr</span><span class="token punctuation">:</span><span class="token module variable">Notty</span><span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token punctuation">(</span>st bold<span class="token punctuation">)</span> <span class="token string">"% 4d: ???"</span> target\n    <span class="token operator">|</span> <span class="token module variable">None</span> <span class="token operator">-></span> <span class="token module variable">Ui</span><span class="token punctuation">.</span>empty<span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token comment">(* Let\'s make use of the fancy let-operators recently added to OCaml *)</span>\n# <span class="token keyword">open</span> <span class="token module variable">Lwd_infix</span><span class="token punctuation">;</span><span class="token punctuation">;</span>\n# <span class="token keyword">let</span> ui <span class="token operator">=</span>\n    <span class="token keyword">let</span><span class="token operator">$</span> count <span class="token operator">=</span> <span class="token module variable">Lwd</span><span class="token punctuation">.</span>get vcount <span class="token keyword">in</span>\n    <span class="token module variable">Ui</span><span class="token punctuation">.</span>vcat <span class="token punctuation">[</span>button count<span class="token punctuation">;</span> unlocked_ui count<span class="token punctuation">;</span> next_ui count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token comment">(* Launch the game! *)</span>\n# <span class="token module variable">Ui_loop</span><span class="token punctuation">.</span>run ui<span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre></div>\n<div>\n  <video controls>\n    <source src="./nottui-cookie-clicker.mp4" type="video/mp4" />\n    <source src="./nottui-cookie-clicker.webm" type="video/webm;codecs=vp9" />\n  </video>\n</div>\n<p>Et voil\xe0! We hope you enjoy experimenting with <code>Nottui</code> and <code>Lwd</code>. Check out the <a href="https://github.com/let-def/lwd/tree/master/lib/nottui">Nottui page</a> for more examples, and watch our recent presentation of these libraries at the 2020 ML Workshop here:</p>\n<div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%">\n  <iframe\n    style="position: absolute; width: 100%; height: 100%; left: 0; right: 0"\n    src="https://www.youtube-nocookie.com/embed/w7jc35kgBZE" frameborder="0"\n    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"\n    allowfullscreen>\n  </iframe>\n</div>'},tl:{hd:{title:"Decompress: Experiences with OCaml optimization",slug:"decompress-experiences-with-ocaml-optimization",description:"In our first article we mostly discussed\nthe API design of decompress and did not talk too much about the issue of\noptimizing performance\u2026",url:"https://tarides.com/blog/2019-09-13-decompress-experiences-with-ocaml-optimization",date:"2019-09-13T00:00:00-00:00",preview_image:"https://tarides.com/static/fff1a2a9a2dbdd9ac7efd7c97ac5aa2a/2244e/camel_sunset.jpg",body_html:'<p>In our <a href="https://tarides.com/blog/2019-08-26-decompress-the-new-decompress-api.html">first article</a> we mostly discussed\nthe API design of <code>decompress</code> and did not talk too much about the issue of\noptimizing performance. In this second article, we will relate our experiences\nof optimizing <code>decompress</code>.</p>\n<p>As you might suspect, <code>decompress</code> needs to be optimized a lot. It was used by\nseveral projects as an underlying layer of some formats (like Git), so it can be\na real bottleneck in those projects. Of course, we start with a footgun by using\na garbage-collected language; comparing the performance of <code>decompress</code> with a C\nimplementation (like <a href="https://zlib.net/">zlib</a> or <a href="https://github.com/richgel999/miniz">miniz</a>) is obviously not very fair.</p>\n<p>However, using something like <code>decompress</code> instead of C implementations can be\nvery interesting for many purposes, especially when thinking about <em>unikernels</em>.\nAs we said in the previous article, we can take the advantage of the <em>runtime</em>\nand the type-system to provide something <em>safer</em> (of course, it\'s not really\ntrue since zlib has received several security audits).</p>\n<p>The main idea in this article is not to give snippets to copy/paste into your\ncodebase but to explain some behaviors of the compiler / runtime and hopefully\ngive you some ideas about how to optimize your own code. We\'ll discuss the\nfollowing optimizations:</p>\n<ul>\n<li>specialization</li>\n<li>inlining</li>\n<li>untagged integers</li>\n<li>exceptions</li>\n<li>unrolling</li>\n<li>hot-loop</li>\n<li>caml_modify</li>\n<li>representation sizes</li>\n</ul>\n<h3 id="cautionary-advice" style="position:relative;"><a href="#cautionary-advice" aria-label="cautionary advice permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cautionary advice</h3>\n<p>Before we begin discussing optimization, keep this rule in mind:</p>\n<blockquote>\n<p>Only perform optimization at the <strong>end</strong> of the development process.</p>\n</blockquote>\n<p>An optimization pass\ncan change your code significantly, so you need to keep a state of your project\nthat can be trusted. This state will provide a comparison point for both\nbenchmarks and behaviors. In other words, your stable implementation will be the\noracle for your benchmarks. If you start with nothing, you\'ll achieve\narbitrarily-good performance at the cost of arbitrary behavior!</p>\n<p>We optimized <code>decompress</code> because we are using it in bigger projects for a long\ntime (2 years). So we have an oracle (even if <code>zlib</code> can act as an oracle in\nthis special case).</p>\n<h2 id="specialization" style="position:relative;"><a href="#specialization" aria-label="specialization permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Specialization</h2>\n<p>One of the biggest specializations in <code>decompress</code> is regarding the <code>min</code>\nfunction. If you don\'t know, in OCaml <code>min</code> is polymorphic; you can compare\nanything. So you probably have some concerns about how <code>min</code> is implemented?</p>\n<p>You are right to be concerned: if you examine the details, <code>min</code> calls the C\nfunction <code>do_compare_val</code>, which traverses your structure and does a comparison\naccording the run-time representation of your structure. Of course, for integers, it\nshould be only a <code>cmpq</code> assembly instruction. However, some simple code like:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> x <span class="token operator">=</span> min <span class="token number">0</span> <span class="token number">1</span></code></pre></div>\n<p>will produce this CMM and assembly code:</p>\n<div class="gatsby-highlight" data-language="cmm"><pre class="language-cmm"><code class="language-cmm">(let x/1002 (app{main.ml:1,8-15} &quot;camlStdlib__min_1028&quot; 1 3 val)\n   ...)</code></pre></div>\n<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">.L101:\n        movq    $3, %rbx\n        movq    $1, %rax\n        call    camlStdlib__min_1028@PLT</code></pre></div>\n<p>Note that <em><a href="https://en.wikipedia.org/wiki/Lambda_calculus#Beta_reduction">beta-reduction</a></em>, <em><a href="https://en.wikipedia.org/wiki/Inline_expansion">inlining</a></em> and\nspecialization were not done in this code. OCaml does not optimize your code\nvery much \u2013 the good point is predictability of the produced assembly output.</p>\n<p>If you help the compiler a little bit with:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">external</span> <span class="token punctuation">(</span> <span class="token operator">&lt;=</span> <span class="token punctuation">)</span> <span class="token punctuation">:</span> int <span class="token operator">-></span> int <span class="token operator">-></span> bool <span class="token operator">=</span> <span class="token string">"%lessequal"</span>\n<span class="token keyword">let</span> min a b <span class="token operator">=</span> <span class="token keyword">if</span> a <span class="token operator">&lt;=</span> b <span class="token keyword">then</span> a <span class="token keyword">else</span> b <span class="token punctuation">[</span><span class="token operator">@@</span>inline<span class="token punctuation">]</span>\n\n<span class="token keyword">let</span> x <span class="token operator">=</span> min <span class="token number">0</span> <span class="token number">1</span></code></pre></div>\n<p>We have:</p>\n<div class="gatsby-highlight" data-language="cmm"><pre class="language-cmm"><code class="language-cmm">(function{main.ml:2,8-43} camlMain__min_1003 (a/1004: val b/1005: val)\n (if (&lt;= a/1004 b/1005) a/1004 b/1005))\n\n(function camlMain__entry ()\n (let x/1006 1 (store val(root-init) (+a &quot;camlMain&quot; 8) 1)) 1a)</code></pre></div>\n<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">.L101:\n        cmpq    %rbx, %rax\n        jg      .L100\n        ret</code></pre></div>\n<p>So we have all optimizations, in this produced code, <code>x</code> was evaluated as <code>0</code>\n(<code>let x/... (store ... 1)</code>) (beta-reduction and inlining) and <code>min</code> was\nspecialized to accept only integers \u2013 so we are able to emit <code>cmpq</code>.</p>\n<h3 id="results" style="position:relative;"><a href="#results" aria-label="results permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Results</h3>\n<p>With specialization, we won 10 Mb/s on decompression, where <code>min</code> is used\nin several places. We completely avoid an indirection and a call to the slow\n<code>do_compare_val</code> function.</p>\n<p>This kind of specialization is already done by <a href="https://caml.inria.fr/pub/docs/manual-ocaml/flambda.html"><code>flambda</code></a>, however, we\ncurrently use OCaml 4.07.1. So we decided to this kind of optimization by\nourselves.</p>\n<h2 id="inlining" style="position:relative;"><a href="#inlining" aria-label="inlining permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inlining</h2>\n<p>In the first example, we showed code with the <code>[@@inline]</code> keyword which is\nuseful to force the compiler to inline a little function. We will go outside the\nOCaml world and study C code (gcc 5.4.0) to really understand\n<em>inlining</em>.</p>\n<p>In fact, inlining is not necessarily the best optimization. Consider the\nfollowing (nonsensical) C program:</p>\n<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HIDE_ALIGNEMENT</span></span>\n<span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">,</span> noclone<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>\n<span class="token keyword">void</span> <span class="token operator">*</span>\n<span class="token function">hide</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> ac<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>av<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n  <span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  s <span class="token operator">=</span> <span class="token function">hide</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">memset</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">\'B\'</span><span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token class-name">clock_t</span> start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1280000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>\n    s<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">\'A\'</span><span class="token punctuation">;</span>\n\n  <span class="token class-name">clock_t</span> end <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>We will compile this code with <code>-O2</code> (the second level of optimization in C),\nonce with <code>-DHIDE_ALIGNEMENT</code> and once without. The assembly emitted differs:</p>\n<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">.L3:\n\tmovq\t%rbp, %rdi\n\tcall\tstrlen\n\tsubl\t$1, %ebx\n\tmovb\t$65, 0(%rbp,%rax)\n\tjne\t.L3</code></pre></div>\n<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">.L3:\n\tmovl\t(%rdx), %ecx\n\taddq\t$4, %rdx\n\tleal\t-16843009(%rcx), %eax\n\tnotl\t%ecx\n\tandl\t%ecx, %eax\n\tandl\t$-2139062144, %eax\n\tje\t.L3</code></pre></div>\n<p>In the first output (with <code>-DHIDE_ALIGNEMENT</code>), the optimization pass\ndecides to disable inlining of <code>strlen</code>; in the second output (without\n<code>-DHIDEAlIGNEMENT</code>), it decides to inline <code>strlen</code> (and do some other clever\noptimizations). The reason behind this complex behavior from the compiler is\nclearly described <a href="https://stackoverflow.com/a/55589634">here</a>.</p>\n<p>But what we want to say is that inlining is <strong>not</strong> an automatic optimization;\nit might act as a <em>pessimization</em>. This is the goal of <code>flambda</code>: do the right\noptimization under the right context. If you are really curious about what <code>gcc</code>\ndoes and why, even if it\'s very interesting, the reverse engineering of the\noptimization process and which information is relevant about the choice to\noptimize or not is deep, long and surely too complicated.</p>\n<p>A non-spontaneous optimization is to annotate some parts of your code with\n<code>[@@inline never]</code> \u2013 so, explicitly say to the compiler to not inline the\nfunction. This constraint is to help the compiler to generate a smaller code\nwhich will have more chance to fit under the processor cache.</p>\n<p>For all of these reasons, <code>[@@inline]</code> should be used sparingly and an oracle to\ncompare performances if you inline or not this or this function is necessary to\navoid a <em>pessimization</em>.</p>\n<h3 id="in-decompress" style="position:relative;"><a href="#in-decompress" aria-label="in decompress permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>In <code>decompress</code></h3>\n<p>Inlining in <code>decompress</code> was done on small functions which need to allocate\nto return a value. If we inline them, we can take the opportunity to store\nreturned value in registers (of course, it depends how many registers are free).</p>\n<p>As we said, the goal of the inflator is to translate a bit sequence to a byte.\nThe largest bit sequence possible according to RFC 1951 has length 15. So, when\nwe process an inputs flow, we eat it 15 bits per 15 bits. For each packet, we\nwant to recognize an existing associated bit sequence and then, binded values\nwill be the real length of the bit sequence and the byte:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> find <span class="token punctuation">:</span> bits<span class="token punctuation">:</span>int <span class="token operator">-></span> <span class="token punctuation">{</span> len<span class="token punctuation">:</span> int<span class="token punctuation">;</span> byte<span class="token punctuation">:</span> int<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></div>\n<p>So for each call to this function, we need to allocate a record/tuple. It\'s\nwhy we choose to inline this function. <code>min</code> was inlined too and some other\nsmall functions. But as we said, the situation is complex; where we think that\n<em>inlining</em> can help us, it\'s not systematically true.</p>\n<p>NOTE: we can recognize bits sequence with, at most, 15 bits because a\n<a href="https://zlib.net/feldspar.html">Huffman coding</a> is <a href="https://en.wikipedia.org/wiki/Prefix_code">prefix-free</a>.</p>\n<h2 id="untagged-integers" style="position:relative;"><a href="#untagged-integers" aria-label="untagged integers permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Untagged integers</h2>\n<p>When reading assembly, the integer <code>0</code> is written as <code>$1</code>.\nIt\'s because of the <a href="https://blog.janestreet.com/what-is-gained-and-lost-with-63-bit-integers/">GC bit</a> needed to differentiate a pointer\nand an unboxed integer. This is why, in OCaml, we talk about a 31-bits integer\nor a 63-bits integer (depending on your architecture).</p>\n<p>We will not try to start a debate about this arbitrary choice on the\nrepresentation of an integer in OCaml. However, we can talk about some\noperations which can have an impact on performances.</p>\n<p>The biggest example is about the <code>mod</code> operation. Between OCaml and C, <code>%</code> or\n<code>mod</code> should be the same:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> f a b <span class="token operator">=</span> a <span class="token operator">mod</span> b</code></pre></div>\n<p>The output assembly is:</p>\n<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">.L105:\n        movq    %rdi, %rcx\n        sarq    $1, %rcx     // b &gt;&gt; 1\n        movq    (%rsp), %rax\n        sarq    $1, %rax     // a &gt;&gt; 1\n        testq   %rcx, %rcx   // b != 0\n        je      .L107\n        cqto\n        idivq   %rcx         // a % b\n        jmp     .L106\n.L107:\n        movq    caml_backtrace_pos@GOTPCREL(%rip), %rax\n        xorq    %rbx, %rbx\n        movl    %ebx, (%rax)\n        movq    caml_exn_Division_by_zero@GOTPCREL(%rip), %rax\n        call    caml_raise_exn@PLT\n.L106:\n        salq    $1, %rdx     // x &lt;&lt; 1\n        incq    %rdx         // x + 1\n        movq    %rbx, %rax</code></pre></div>\n<p>where idiomatically the same C code produce:</p>\n<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">.L2:\n        movl    -12(%rbp), %eax\n        cltd\n        idivl   -8(%rbp)\n        movl    %edx, -4(%rbp)</code></pre></div>\n<p>Of course, we can notice firstly the exception in OCaml (<code>Divided_by_zero</code>) -\nwhich is pretty good because it protects us against an interrupt from assembly\n(and keep the trace). Then, we need to <em>untag</em> <code>a</code> and <code>b</code> with <code>sarq</code> assembly\noperation. We do, as the C code, <code>idiv</code> and then we must <em>retag</em> returned value\n<code>x</code> with <code>salq</code> and <code>incq</code>.</p>\n<p>So in some parts, it should be more interesting to use <code>Nativeint</code>. However, by\ndefault, a <code>nativeint</code> is boxed. <em>boxed</em> means that the value is allocated in\nthe OCaml heap alongside a header.</p>\n<p>Of course, this is not what we want so, if our <code>nativeint ref</code> (to have\nside-effect, like <code>x</code>) stay inside a function and then, you return the real\nvalue with the deref <code>!</code> operator, OCaml, by a good planet alignment, can\ndirectly use registers and real integers. So it should be possible to avoid\nthese needed conversions.</p>\n<h3 id="readability-versus-performance" style="position:relative;"><a href="#readability-versus-performance" aria-label="readability versus performance permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Readability versus performance</h3>\n<p>We use this optimization only in few parts of the code. In fact, switch\nbetween <code>int</code> and <code>nativeint</code> is little bit noisy:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml">hold <span class="token operator">:=</span> <span class="token module variable">Nativeint</span><span class="token punctuation">.</span>logor <span class="token operator">!</span>hold <span class="token module variable">Nativeint</span><span class="token punctuation">.</span><span class="token punctuation">(</span>shift_left <span class="token punctuation">(</span>of_int <span class="token punctuation">(</span>unsafe_get_uint8 d<span class="token punctuation">.</span>i <span class="token operator">!</span>i_pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!</span>bits<span class="token punctuation">)</span></code></pre></div>\n<p>In the end, we only gained 0.5Mb/s of inflation rate, so it\'s not worthwhile\nto do systematically this optimization. Especially that the gain is not very\nbig. But this case show a more troubling problem: loss of readability.</p>\n<p>In fact, we can optimize more and more a code (OCaml or C) but we lost, step by\nstep, readability. You should be afraid by the implementation of <code>strlen</code> for\nexample. In the end, the loss of readability makes it harder to understand the purpose\nof the code, leading to errors whenever some other person (or you in 10 years time)\ntries to make a change.</p>\n<p>And we think that this kind of optimization is not the way of OCaml in general\nwhere we prefer to produce an understandable and abstracted code than a cryptic\nand super fast one.</p>\n<p>Again, <code>flambda</code> wants to fix this problem and let the compiler to do this\noptimization. The goal is to be able to write a fast code without any pain.</p>\n<h2 id="exceptions" style="position:relative;"><a href="#exceptions" aria-label="exceptions permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exceptions</h2>\n<p>If you remember our <a href="https://tarides.com/blog/2019-02-08-release-of-base64.html">article</a> about the release of <code>base64</code>, we talked a\nbit about exceptions and used them as a <em>jump</em>. In fact, it\'s pretty\ncommon for an OCaml developer to break the control-flow with an exception.\nBehind this common design/optimization, it\'s about calling convention.</p>\n<p>Indeed, choose the <em>jump</em> word to describe OCaml exception is not the best where\nwe don\'t use <code>setjmp</code>/<code>longjmp</code>.</p>\n<p>In the details, when you start a code with a <code>try .. with</code>, OCaml saves a <em>trap</em>\nin the stack which contains information about the <code>with</code>, the catcher. Then,\nwhen you <code>raise</code>, you <em>jump</em> directly to this trap and can just discard several\nstack frames (and, by this way, you did not check each return codes).</p>\n<p>In several places and mostly in the <em>hot-loop</em>, we use this <em>pattern</em>. However,\nit completely breaks the control flow and can be error-prone.</p>\n<p>To limit errors and because this pattern is usual, we prefer to use a <em>local</em>\nexception which will be used only inside the function. By this way, we enforce\nthe fact that exception should not (and can not) be caught by something else\nthan inside the function.</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml">    <span class="token keyword">let</span> <span class="token keyword">exception</span> <span class="token module variable">Break</span> <span class="token keyword">in</span>\n\n    <span class="token punctuation">(</span> <span class="token keyword">try</span> <span class="token keyword">while</span> <span class="token operator">!</span>max <span class="token operator">>=</span> <span class="token number">1</span> <span class="token keyword">do</span>\n          <span class="token keyword">if</span> bl_count<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">!</span>max<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token keyword">then</span> raise_notrace <span class="token module variable">Break</span>\n        <span class="token punctuation">;</span> decr max <span class="token keyword">done</span> <span class="token keyword">with</span> <span class="token module variable">Break</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre></div>\n<p>This code above produce this assembly code:</p>\n<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">.L105:\n        pushq   %r14\n        movq    %rsp, %r14\n.L103:\n        cmpq    $3, %rdi              // while !max &gt;= 1\n        jl      .L102\n        movq    -4(%rbx,%rdi,4), %rsi // bl_count,(!max)\n        cmpq    $1, %rsi              // bl_count.(!max) != 0\n        je      .L104\n        movq    %r14, %rsp\n        popq    %r14\n        ret                           // raise_notrace Break\n.L104:\n        addq    $-2, %rdi             // decr max\n        movq    %rdi, 16(%rsp)\n        jmp     .L103</code></pre></div>\n<p>Where the <code>ret</code> is the <code>raise_notrace Break</code>. A <code>raise_notrace</code> is needed,\notherwise, you will see:</p>\n<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">        movq    caml_backtrace_pos@GOTPCREL(%rip), %rbx\n        xorq    %rdi, %rdi\n        movl    %edi, (%rbx)\n        call    caml_raise_exn@PLT</code></pre></div>\n<p>Instead the <code>ret</code> assembly code. Indeed, in this case, we need to store where we\nraised the exception.</p>\n<h2 id="unrolling" style="position:relative;"><a href="#unrolling" aria-label="unrolling permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unrolling</h2>\n<p>When we showed the optimization done by <code>gcc</code> when the string is aligned, <code>gcc</code>\ndid another optimization. Instead of setting the string byte per byte, it decides to\nupdate it 4 bytes per 4 bytes.</p>\n<p>This kind of this optimization is an <em>unroll</em> and we did it in <code>decompress</code>.\nIndeed, when we reach the <em>copy</em> <em>opcode</em> emitted by the <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">lz77</a>\ncompressor, we want to <em>blit</em> <em>length</em> byte(s) from a source to the outputs\nflow. It can appear that this <code>memcpy</code> can be optimized to copy 4 bytes per 4\nbytes \u2013 4 bytes is generally a good idea where it\'s the size of an <code>int32</code> and\nshould fit under any architectures.</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> blit src src_off dst dst_off <span class="token operator">=</span>\n  <span class="token keyword">if</span> dst_off \u2013 src_off <span class="token operator">&lt;</span> <span class="token number">4</span>\n  <span class="token keyword">then</span> slow_blit src src_off dst dst_off\n  <span class="token keyword">else</span>\n    <span class="token keyword">let</span> len0 <span class="token operator">=</span> len <span class="token operator">land</span> <span class="token number">3</span> <span class="token keyword">in</span>\n    <span class="token keyword">let</span> len1 <span class="token operator">=</span> len <span class="token operator">asr</span> <span class="token number">2</span> <span class="token keyword">in</span>\n\n    <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">to</span> len1 \u2013 <span class="token number">1</span>\n    <span class="token keyword">do</span>\n      <span class="token keyword">let</span> i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">4</span> <span class="token keyword">in</span>\n      <span class="token keyword">let</span> v <span class="token operator">=</span> unsafe_get_uint32 src <span class="token punctuation">(</span>src_off <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token keyword">in</span>\n      unsafe_set_uint32 dst <span class="token punctuation">(</span>dst_off <span class="token operator">+</span> i<span class="token punctuation">)</span> v <span class="token punctuation">;</span>\n    <span class="token keyword">done</span> <span class="token punctuation">;</span>\n\n    <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">to</span> len0 \u2013 <span class="token number">1</span>\n    <span class="token keyword">do</span>\n      <span class="token keyword">let</span> i <span class="token operator">=</span> len1 <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">+</span> i <span class="token keyword">in</span>\n      <span class="token keyword">let</span> v <span class="token operator">=</span> unsafe_get_uint8 src <span class="token punctuation">(</span>src_off <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token keyword">in</span>\n      unsafe_set_uint8 dst <span class="token punctuation">(</span>dst_off <span class="token operator">+</span> i<span class="token punctuation">)</span> v <span class="token punctuation">;</span>\n    <span class="token keyword">done</span></code></pre></div>\n<p>In this code, at the beginning, we copy 4 bytes per 4 bytes and if <code>len</code> is not\na multiple of 4, we start the <em>trailing</em> loop to copy byte per byte then. In\nthis context, OCaml can <em>unbox</em> <code>int32</code> and use registers. So this function does\nnot deal with the heap, and by this way, with the garbage collector.</p>\n<h3 id="results-1" style="position:relative;"><a href="#results-1" aria-label="results 1 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Results</h3>\n<p>In the end, we gained an extra 10Mb/s of inflation rate. The <code>blit</code> function is the\nmost important function when it comes to inflating the window to an output flow.\nAs the specialization on the <code>min</code> function, this is one of the biggest optimization on\n<code>decompress</code>.</p>\n<h2 id="hot-loop" style="position:relative;"><a href="#hot-loop" aria-label="hot loop permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><em>hot-loop</em></h2>\n<p>A common design about decompression (but we can find it on hash implementation\ntoo), is the <em>hot-loop</em>. An <em>hot-loop</em> is mainly a loop on the most common\noperation in your process. In the context of <code>decompress</code>, the <em>hot-loop</em> is\nabout a repeated translation from bits-sequence to byte(s) from the inputs flow\nto the outputs flow and the window.</p>\n<p>The main idea behind the <em>hot-loop</em> is to initialize all information needed for\nthe translation before to start the <em>hot-loop</em>. Then, it\'s mostly an imperative\nloop with a <em>pattern-matching</em> which corresponds to the current state of the\nglobal computation.</p>\n<p>In OCaml, we can take this opportunity to use <code>int ref</code> (or <code>nativeint ref</code>), and then, they will be translated into registers (which is the fastest\narea to store something).</p>\n<p>Another deal inside the <em>hot-loop</em> is to avoid any allocation \u2013 and it\'s why we\ntalk about <code>int</code> or <code>nativeint</code>. Indeed, a more complex structure like an option\nwill add a blocker to the garbage collection (a call to <code>caml_call_gc</code>).</p>\n<p>Of course, this kind of design is completely wrong if we think in a functional\nway. However, this is the (biggest?) advantage of OCaml: hide this ugly/hacky\npart inside a functional interface.</p>\n<p>In the API, we talked about a state which represents the <em>inflation</em> (or the\n<em>deflation</em>). At the beginning, the goal is to store into some references\nessentials values like the position into the inputs flow, bits available,\ndictionary, etc. Then, we launch the <em>hot-loop</em> and only at the end, we update the state.</p>\n<p>So we keep the optimal design about <em>inflation</em> and the functional way outside\nthe <em>hot-loop</em>.</p>\n<h2 id="caml_modify" style="position:relative;"><a href="#caml_modify" aria-label="caml_modify permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>caml_modify</h2>\n<p>One issue that we need to consider is the call to <code>caml_modify</code>. In\nfact, for a complex data-structure like an <code>int array</code> or a <code>int option</code> (so,\nother than an integer or a boolean or an <em>immediate</em> value), values can move to the\nmajor heap.</p>\n<p>In this context, <code>caml_modify</code> is used to assign a new value into your mutable\nblock. It is a bit slower than a simple assignment but needed to\nensure pointer correspondence between minor heap and major heap.</p>\n<p>With this OCaml code for example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> t <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">mutable</span> v <span class="token punctuation">:</span> int option <span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> f t v <span class="token operator">=</span> t<span class="token punctuation">.</span>v <span class="token operator">&lt;-</span> v</code></pre></div>\n<p>We produce this assembly:</p>\n<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">camlExample__f_1004:\n        subq    $8, %rsp\n        movq    %rax, %rdi\n        movq    %rbx, %rsi\n        call    caml_modify@PLT\n        movq    $1, %rax\n        addq    $8, %rsp\n        ret</code></pre></div>\n<p>Where we see the call to <code>caml_modify</code> which will be take care about the\nassignment of <code>v</code> into <code>t.v</code>. This call is needed mostly because the type of <code>t.v</code> is not an <em>immediate</em> value like an integer. So, for many values in the\n<em>inflator</em> and the <em>deflator</em>, we mostly use integers.</p>\n<p>Of course, at some points, we use <code>int array</code> and set them at some specific\npoints of the <em>inflator</em> \u2013 where we inflated the dictionary. However, the impact\nof <code>caml_modify</code> is not very clear where it is commonly pretty fast.</p>\n<p>Sometimes, however, it can be a real bottleneck in your computation and\nthis depends on how long your values live in the heap. A little program (which is\nnot very reproducible) can show that:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token module variable">Array</span><span class="token punctuation">.</span>init <span class="token punctuation">(</span>int_of_string <span class="token module variable">Sys</span><span class="token punctuation">.</span>argv<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">fun</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token module variable">Random</span><span class="token punctuation">.</span>int <span class="token number">256</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> pr fmt <span class="token operator">=</span> <span class="token module variable">Format</span><span class="token punctuation">.</span>printf fmt\n\n<span class="token keyword">type</span> t0 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">mutable</span> v <span class="token punctuation">:</span> int option <span class="token punctuation">}</span>\n<span class="token keyword">type</span> t1 <span class="token operator">=</span> <span class="token punctuation">{</span> v <span class="token punctuation">:</span> int option <span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> f0 <span class="token punctuation">(</span>t0 <span class="token punctuation">:</span> t0<span class="token punctuation">)</span> <span class="token operator">=</span>\n  <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">to</span> <span class="token module variable">Array</span><span class="token punctuation">.</span>length t \u2013 <span class="token number">1</span>\n  <span class="token keyword">do</span> <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token keyword">match</span> t0<span class="token punctuation">.</span>v<span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">with</span>\n             <span class="token operator">|</span> <span class="token module variable">Some</span> <span class="token punctuation">_</span> <span class="token keyword">as</span> v<span class="token punctuation">,</span> <span class="token punctuation">_</span> <span class="token operator">-></span> v\n             <span class="token operator">|</span> <span class="token module variable">None</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">-></span> <span class="token module variable">Some</span> i\n             <span class="token operator">|</span> <span class="token module variable">None</span><span class="token punctuation">,</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token module variable">None</span> <span class="token keyword">in</span>\n     t0<span class="token punctuation">.</span>v <span class="token operator">&lt;-</span> v\n  <span class="token keyword">done</span><span class="token punctuation">;</span> t0\n\n<span class="token keyword">let</span> f1 <span class="token punctuation">(</span>t1 <span class="token punctuation">:</span> t1<span class="token punctuation">)</span> <span class="token operator">=</span>\n  <span class="token keyword">let</span> t1 <span class="token operator">=</span> ref t1 <span class="token keyword">in</span>\n  <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">to</span> <span class="token module variable">Array</span><span class="token punctuation">.</span>length t \u2013 <span class="token number">1</span>\n  <span class="token keyword">do</span> <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token keyword">match</span> <span class="token operator">!</span>t1<span class="token punctuation">.</span>v<span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">with</span>\n             <span class="token operator">|</span> <span class="token module variable">Some</span> <span class="token punctuation">_</span> <span class="token keyword">as</span> v<span class="token punctuation">,</span> <span class="token punctuation">_</span> <span class="token operator">-></span> v\n             <span class="token operator">|</span> <span class="token module variable">None</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">-></span> <span class="token module variable">Some</span> i\n             <span class="token operator">|</span> <span class="token module variable">None</span><span class="token punctuation">,</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token module variable">None</span> <span class="token keyword">in</span>\n     t1 <span class="token operator">:=</span> <span class="token punctuation">{</span> v <span class="token punctuation">}</span>\n  <span class="token keyword">done</span><span class="token punctuation">;</span> <span class="token operator">!</span>t1\n\n<span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n  <span class="token keyword">let</span> t0 <span class="token punctuation">:</span> t0 <span class="token operator">=</span> <span class="token punctuation">{</span> v<span class="token operator">=</span> <span class="token module variable">None</span> <span class="token punctuation">}</span> <span class="token keyword">in</span>\n  <span class="token keyword">let</span> t1 <span class="token punctuation">:</span> t1 <span class="token operator">=</span> <span class="token punctuation">{</span> v<span class="token operator">=</span> <span class="token module variable">None</span> <span class="token punctuation">}</span> <span class="token keyword">in</span>\n  <span class="token keyword">let</span> time0 <span class="token operator">=</span> <span class="token module variable">Unix</span><span class="token punctuation">.</span>gettimeofday <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span>\n  ignore <span class="token punctuation">(</span>f0 t0<span class="token punctuation">)</span> <span class="token punctuation">;</span>\n  <span class="token keyword">let</span> time1 <span class="token operator">=</span> <span class="token module variable">Unix</span><span class="token punctuation">.</span>gettimeofday <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span>\n  ignore <span class="token punctuation">(</span>f1 t1<span class="token punctuation">)</span> <span class="token punctuation">;</span>\n  <span class="token keyword">let</span> time2 <span class="token operator">=</span> <span class="token module variable">Unix</span><span class="token punctuation">.</span>gettimeofday <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span>\n\n  pr <span class="token string">"f0: %f ns\\n%!"</span> <span class="token punctuation">(</span>time1 <span class="token operator">-.</span> time0<span class="token punctuation">)</span> <span class="token punctuation">;</span>\n  pr <span class="token string">"f1: %f ns\\n%!"</span> <span class="token punctuation">(</span>time2 <span class="token operator">-.</span> time1<span class="token punctuation">)</span> <span class="token punctuation">;</span>\n\n  <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>\n<p>In our bare-metal server, if you launch the program with 1000, the <code>f0</code>\ncomputation, even if it has <code>caml_modify</code> will be the fastest. However, if you\nlaunch the program with 1000000000, <code>f1</code> will be the fastest.</p>\n<div class="gatsby-highlight" data-language="sh"><pre class="language-sh"><code class="language-sh">$ ./a.out 1000\nf0: 0.000006 ns\nf1: 0.000015 ns\n$ ./a.out 1000000000\nf0: 7.931782 ns\nf1: 5.719370 ns</code></pre></div>\n<h3 id="about-decompress" style="position:relative;"><a href="#about-decompress" aria-label="about decompress permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>About <code>decompress</code></h3>\n<p>At the beginning, our choice was made to have, as @dbuenzli does, mutable\nstructure to represent state. Then, @yallop did a big patch to update it to an\nimmutable state and we won 9Mb/s on <em>inflation</em>.</p>\n<p>However, the new version is more focused on the <em>hot-loop</em> and it is 3\ntimes faster than before.</p>\n<p>As we said, the deal about <code>caml_modify</code> is not clear and depends a lot about\nhow long your data lives in the heap and how many times you want to update it.\nIf we localize <code>caml_modify</code> only on few places, it should be fine. But it still\nis one of the most complex question about (macro?) optimization.</p>\n<h2 id="smaller-representation" style="position:relative;"><a href="#smaller-representation" aria-label="smaller representation permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Smaller representation</h2>\n<p>We\'ve discussed the impact that integer types can have on the use of immediate\nvalues. More generally, the choice of type to represent your values can have\nsignificant performance implications.</p>\n<p>For example, a dictionary which associates a bits-sequence (an integer) to the\nlength of it <strong>AND</strong> the byte, it can be represented by a: <code>(int * int) array</code>, or\nmore idiomatically <code>{ len: int; byte: int; } array</code> (which is structurally the\nsame).</p>\n<p>However, that means an allocation for each bytes to represent every bytes.\nExtraction of it will need an allocation if <code>find : bits:int -> { len: int; byte: int; }</code> is not inlined as we said. And about memory, the array can be\nreally <em>heavy</em> in your heap.</p>\n<p>At this point, we used <code>spacetime</code> to show how many blocks we allocated for a\ncommon <em>inflation</em> and we saw that we allocate a lot. The choice was made to use\na smaller representation. Where <code>len</code> can not be upper than 15 according RFC 1951\nand when byte can represent only 256 possibilities (and should fit under one\nbyte), we can decide to merge them into one integer (which can have, at least,\n31 bits).</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> static_literal_tree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">140</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">76</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">|</span><span class="token punctuation">]</span>\n<span class="token keyword">let</span> static_literal_tree <span class="token operator">=</span> <span class="token module variable">Array</span><span class="token punctuation">.</span>map <span class="token punctuation">(</span><span class="token keyword">fun</span> <span class="token punctuation">(</span>len<span class="token punctuation">,</span> byte<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">(</span>len <span class="token operator">lsl</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">lor</span> byte<span class="token punctuation">)</span> static_literal_tree</code></pre></div>\n<p>In the code above, we just translate the static dictionary (for a STATIC DEFLATE\nblock) to a smaller representation where <code>len</code> will be the left part of the\ninteger and <code>byte</code> will be the right part. Of course, it\'s depends on what you\nwant to store.</p>\n<p>Another point is readability. <a href="https://github.com/mirage/ocaml-cstruct#ppx"><code>cstruct-ppx</code></a> and\n<a href="https://bitbucket.org/thanatonauts/bitstring/src"><code>bitstring</code></a> can help you but <code>decompress</code>\nwants to depend only on OCaml.</p>\n<h2 id="conclusion" style="position:relative;"><a href="#conclusion" aria-label="conclusion permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>\n<p>We conclude with some closing advice about optimising your OCaml programs:</p>\n<ul>\n<li><strong>Optimization is specific to your task</strong>. The points highlighted in this\narticle may not fit your particular problem, but they are intended to give you\nideas. Our optimizations were only possible because we completely assimilated\nthe ideas of <code>zlib</code> and had a clear vision of what we really needed to\noptimize (like <code>blit</code>).\n<br/><br/>\nAs your first project, this article can not help you a lot to optimize your\ncode where it\'s mostly about <em>micro</em>-optimization under a specific context\n(<em>hot-loop</em>). But it helps you to understand what is really done by the\ncompiler \u2013 which is still really interesting.</li>\n<li><strong>Optimise only with respect to an oracle</strong>. All optimizations were done\nbecause we did a comparison point between the old implementation of\n<code>decompress</code> and <code>zlib</code> as oracles. Optimizations can change the semantics of your\ncode and you should systematically take care at any step about expected\nbehaviors. So it\'s a long run.</li>\n<li><strong>Use the predictability of the OCaml compiler to your advantage</strong>. For sure,\nthe compiler does not optimize a lot your code \u2013 but it sill produce realistic\nprograms if we think about performance. For many cases, <strong>you don\'t need</strong> to\noptimize your OCaml code. And the good point is about expected behavior.\n<br/><br/>\nThe mind-link between the OCaml and the assembly exists (much more than the C\nand the assembly sometimes where we let the C compiler to optimize the code).\nThe cool fact is to keep a mental-model about what is going on on your code\neasily without to be afraid by what the compiler can produce. And, in some\ncritical parts like <a href="https://github.com/mirage/eqaf">eqaf</a>, it\'s really needed.</li>\n</ul>\n<p>We have not discussed benchmarking, which is another hard issue: who should you\ncompare with? where? how? For example, a global comparison between <code>zlib</code> and\n<code>decompress</code> is not very relevant in many ways \u2013 especially because of the\ngarbage collector. This could be another article!</p>\n<p>Finally, all of these optimizations should be done by <code>flambda</code>; the difference\nbetween compiling <code>decompress</code> with or without <code>flambda</code> is not very big. We\noptimized <code>decompress</code> by hand mostly to keep compatibility with OCaml (since\n<code>flambda</code> needs another switch) and, in this way, to gain an understanding of\n<code>flambda</code> optimizations so that we can use it effectively!</p>'},tl:{hd:{title:"Decompress: The New Decompress API",slug:"decompress-the-new-decompress-api",description:"RFC 1951 is one of the most used standards. Indeed,\nwhen you launch your Linux kernel, it inflates itself according zlib\nstandard, a\u2026",url:"https://tarides.com/blog/2019-08-26-decompress-the-new-decompress-api",date:"2019-08-26T00:00:00-00:00",preview_image:"https://tarides.com/static/eeb13afbb9190097a8d04be9e1361642/2244e/hammock.jpg",body_html:'<p><a href="https://tools.ietf.org/html/rfc1951">RFC 1951</a> is one of the most used standards. Indeed,\nwhen you launch your Linux kernel, it inflates itself according <a href="https://zlib.net/">zlib</a>\nstandard, a superset of RFC 1951. Being a widely-used standard, we decided to\nproduce an OCaml implementation. In the process, we learned many lessons about\ndeveloping OCaml where we would normally use C. So, we are glad to present\n<a href="https://github.com/mirage/decompress"><code>decompress</code></a>.</p>\n<p>One of the many users of RFC 1951 is <a href="https://git-scm.com/">Git</a>, which uses it to pack data\nobjects into a <a href="https://git-scm.com/book/en/v2/Git-Internals-Packfiles">PACK file</a>. At the request of <a href="https://github.com/samoht">@samoht</a>,\n<code>decompress</code> appeared some years ago as a Mirage-compatible replacement for zlib\nto be used for compiling a <a href="https://mirage.io/">MirageOS</a> unikernel with\n<a href="https://github.com/mirage/ocaml-git/">ocaml-git</a>. Today, this little project passes a major release with\nsubstantial improvements in several domains.</p>\n<p><code>decompress</code> provides an API for inflating and deflating <em>flows</em><code>[1]</code>. The main\ngoal is to provide a <em>platform-agnostic</em> library: one which may be compiled on\nany platform, including JavaScript. We surely cannot be faster than C\nimplementations like <a href="https://github.com/facebook/zstd">zstd</a> or <a href="https://github.com/lz4/lz4">lz4</a>, but we can play some\noptimisation tricks to help bridge the gap. Additionally, OCaml can protect the\nuser against lot of bugs via the type-system <em>and</em> the runtime too (e.g. using\narray bounds checking). <a href="https://github.com/mirleft/ocaml-tls"><code>ocaml-tls</code></a> was implemented partly in\nresponse to the famous <a href="https://en.wikipedia.org/wiki/Heartbleed">failure</a> of <code>openssl</code>; a vulnerability\nwhich could not exist in OCaml.</p>\n<p><code>[1]</code>: A <em>flow</em>, in MirageOS land, is an abstraction which wants to receive\nand/or transmit something under a standard. So it\'s usual to say a <em>TLS-flow</em>\nfor example.</p>\n<h2 id="api-design" style="position:relative;"><a href="#api-design" aria-label="api design permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>API design</h2>\n<p>The API should be the most difficult part of designing a library - it reveals\nwhat we can do and how we should do it. In this way, an API should:</p>\n<ol>\n<li><strong>constrain the user to avoid security issues</strong>; too much freedom can be a bad\nthing. As an example, consider the <code>Hashtbl.create</code> function, which allows the\nuser to pass <code>~random:false</code> to select a fixed hash function. The resulting\nhashtable suffers deterministic key collisions, which can be exploited by an\nattacker.\n<br/><br/>\nAn example of good security-awareness in API design can be seen in\n<a href="https://github.com/mirage/digestif">digestif</a>, which provided an <code>unsafe_compare</code> instead of the common\n<code>compare</code> function (before <code>eqaf.0.5</code>). In this way, it enforced the user to\ncreate an alias of it if they want to use a hash in a <code>Map</code> \u2013 however, by this\naction, they should know that they are not protected against a timing-attack.</li>\n<li><strong>allow some degrees of freedom to fit within many environments</strong>; a\nconstrained API cannot support a hostile context. For example, when compiling\nto an <a href="https://mirage.io/blog/2018-esp32-booting">ESP32</a> target, even small details such as the length of a stream\ninput buffer must be user-definable. When deploying to a server, memory\nconsumption should be deterministic.\n<br/><br/>\nOf course, this is made difficult when too much freedom will enable misuse of\nthe API \u2013 an example is <a href="https://github.com/ocaml/dune">dune</a> which wants consciously to limit the user\nabout what they can do with it.</li>\n<li><strong>imply an optimal design of how to use it</strong>. Possibilities should serve the\nuser, but these can make the API harder to understand; this is why\ndocumentation is important. Your API should tell your users how it wants to\nbe treated.</li>\n</ol>\n<h3 id="a-dbuenzli-api" style="position:relative;"><a href="#a-dbuenzli-api" aria-label="a dbuenzli api permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A dbuenzli API</h3>\n<p>From our experiences with protocol/format, one design stands out: the\n<em><a href="https://github.com/dbuenzli/">dbuenzli</a> API</em>. If you look into some famous libraries in the OCaml\neco-system, you probably know <a href="https://github.com/dbuenzli/uutf">uutf</a>, <a href="https://github.com/dbuenzli/jsonm">jsonm</a> or <a href="https://github.com/dbuenzli/xmlm">xmlm</a>. All\nof these libraries provide the same API for computing a Unicode/JSON/XML flow \u2013\nof course, the details are not the same.</p>\n<p>From a MirageOS perspective, even if they use the <code>in_channel</code>/<code>out_channel</code>\nabstraction rather than a <a href="https://github.com/mirage/mirage-flow">Mirage flow</a>, these libraries\nare system-agnostic since they let the user to choose input and output buffers.\nMost importantly, they don\'t use the standard OCaml <code>Unix</code> module, which cannot\nbe used in a unikernel.</p>\n<p>The APIs are pretty consistent and try to do their <em>best-effort</em><code>[2]</code> of\ndecoding. The design has a type <em>state</em> which represents the current system\nstatus; the user passes this to <code>decode</code>/<code>encode</code> to carry out the processing.\nOf course, these functions have a side-effect on the state internally, but\nthis is hidden from the user. One advantage of including states in a design is\nthat the underlying implementation is very amenable to compiler optimisations (e.g.\ntail-call optimisation). Internally, of course, we have a <em>porcelain</em><code>[3]</code>\nimplementation where any details can have an rational explanation.</p>\n<p>In the beginning, <code>decompress</code> wanted to follow the same interface without the\nmutability (a choice about performances) and it did. Then, the hard test was to\nuse it in a bigger project; in this case, <a href="https://github.com/mirage/ocaml-git/">ocaml-git</a>. An iterative\nprocess was used to determine what was really needed, what we should not provide\n(like special cases) and what we should provide to reach an uniform API that is\nnot too difficult to understand.</p>\n<p>From this experience, we finalised the initial <code>decompress</code> API and it did not\nchange significantly for 4 versions (2 years).</p>\n<p><code>[2]</code>: <em>best-effort</em> means an user control on the error branch where we don\'t\nleak exception (or more generally, any interrupts)</p>\n<p><code>[3]</code>: <em>porcelain</em> means implicit invariants held in the mind of the programmer\n(or the assertions/comments).</p>\n<h2 id="the-new-decompress-api" style="position:relative;"><a href="#the-new-decompress-api" aria-label="the new decompress api permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The new <code>decompress</code> API</h2>\n<p>The new <code>decompress</code> keeps the same inflation logic, but drastically changes the\ndeflator to make the <em>flush</em> operation clearer. For many purposes, people don\'t\nwant to hand-craft their compressed flows \u2013 they just want\n<code>of_string</code>/<code>to_string</code> functions. However, in some contexts (like a PNG\nencoder/decoder), the user should be able to play with <code>decompress</code> in detail\n(OpenPGP needs this too in <a href="https://tools.ietf.org/html/rfc4880">RFC 4880</a>).</p>\n<h3 id="the-zlib-format" style="position:relative;"><a href="#the-zlib-format" aria-label="the zlib format permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Zlib format</h3>\n<p>Both <code>decompress</code> and zlib use <em><a href="https://zlib.net/feldspar.html">Huffman coding</a></em>, an algorithm\nfor building a dictionary of variable-length codewords for a given set of\nsymbols (in this case, bytes). The most common byte is assigned the shortest bit\nsequence; less common bytes are assigned longer codewords. Using this\ndictionary, we just translate each byte into its codeword and we should achieve\na good compression ratio. Of course, there are other details, such as the fact\nthat all Huffman codes are <a href="https://en.wikipedia.org/wiki/Prefix_code">prefix-free</a>. The compression can be\ntaken further with the <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">LZ77</a> algorithm.</p>\n<p>The <em><a href="https://zlib.net/">zlib</a></em> format, a superset of the <a href="https://tools.ietf.org/html/rfc1951">RFC 1951</a> format, is easy\nto understand. We will only consider the RFC 1951 format, since zlib adds only\nminor details (such as checksums). It consists of several blocks: DEFLATE\nblocks, each with a little header, and the contents. There are 3 kinds of\nDEFLATE blocks:</p>\n<ul>\n<li>a FLAT block; no compression, just a <em>blit</em> from inputs to the current block.</li>\n<li>a FIXED block; compressed using a pre-computed Huffman code.</li>\n<li>a DYNAMIC block; compressed using a user-specified Huffman code.</li>\n</ul>\n<p>The FIXED block uses a Huffman dictionary that is computed when the OCaml runtime\nis initialised. DYNAMIC blocks use dictionaries specified by the user, and so\nthese must be transmitted alongside the data (<em>after being compressed with\nanother Huffman code!</em>). The inflator decompresses this DYNAMIC dictionary and uses\nit to do the <em>reverse</em> translation from bit sequences to bytes.</p>\n<h3 id="inflator" style="position:relative;"><a href="#inflator" aria-label="inflator permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inflator</h3>\n<p>The design of the inflator did not change a lot from the last version of\n<code>decompress</code>. Indeed, it\'s about to take an input, compute it and return an\noutput like a flow. Of course, the error case can be reached.</p>\n<p>So the API is pretty-easy:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> decode <span class="token punctuation">:</span> decoder <span class="token operator">-></span> <span class="token punctuation">[</span> <span class="token variant variable">`Await</span> <span class="token operator">|</span> <span class="token variant variable">`Flush</span> <span class="token operator">|</span> <span class="token variant variable">`End</span> <span class="token operator">|</span> <span class="token variant variable">`Malformed</span> <span class="token keyword">of</span> string <span class="token punctuation">]</span></code></pre></div>\n<p>As you can see, we have 4 cases: one which expects more inputs (<code>Await</code>), the\nsecond which asks to the user to flush internal buffer (<code>Flush</code>), the <code>End</code> case\nwhen we reach the end of the flow and the <code>Malformed</code> case when we encounter an\nerror.</p>\n<p>For each case, the user can do several operations. Of course, about the <code>Await</code>\ncase, they can refill the contents with an other inputs buffer with:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> src <span class="token punctuation">:</span> decoder <span class="token operator">-></span> bigstring <span class="token operator">-></span> off<span class="token punctuation">:</span>int <span class="token operator">-></span> len<span class="token punctuation">:</span>int <span class="token operator">-></span> unit</code></pre></div>\n<p>This function provides the decoder a new input with <code>len</code> bytes to read\nstarting at <code>off</code> in the given <code>bigstring</code>.</p>\n<p>In the <code>Flush</code> case, the user wants some information like how many bytes are\navailable in the current output buffer. Then, we should provide an action to\n<em>flush</em> this output buffer. In the end, this output buffer should be given by\nthe user (how many bytes they want to allocate to store outputs flow).</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> src <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token variant variable">`Channel</span> <span class="token keyword">of</span> in_channel <span class="token operator">|</span> <span class="token variant variable">`Manual</span> <span class="token operator">|</span> <span class="token variant variable">`String</span> <span class="token keyword">of</span> string <span class="token punctuation">]</span>\n\n<span class="token keyword">val</span> dst_rem <span class="token punctuation">:</span> decoder <span class="token operator">-></span> int\n<span class="token keyword">val</span> flush <span class="token punctuation">:</span> decoder <span class="token operator">-></span> unit\n<span class="token keyword">val</span> decoder <span class="token punctuation">:</span> src <span class="token operator">-></span> o<span class="token punctuation">:</span>bigstring <span class="token operator">-></span> w<span class="token punctuation">:</span>bigstring <span class="token operator">-></span> decoder</code></pre></div>\n<p>The last function, <code>decoder</code>, is the most interesting. It lets the user, at the\nbeginning, choose the context in which they want to inflate inputs. So they\nchoose:</p>\n<ul>\n<li><code>src</code>, where come from inputs flow</li>\n<li><code>o</code>, output buffer</li>\n<li><code>w</code>, window buffer</li>\n</ul>\n<p><code>o</code> will be used to store inflated outputs, <code>dst_rem</code> will give to us how many\nbytes inflator stored in <code>o</code> and <code>flush</code> will just set <code>decoder</code> to be able to\nrecompute the flow.</p>\n<p><code>w</code> is needed for <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">lz77</a> compression. However, as we said, we let\nthe user give us this intermediate buffer. The idea behind that is to let the\nuser prepare an <em>inflation</em>. For example, in <a href="https://github.com/mirage/ocaml-git/">ocaml-git</a>, instead of\nallocating <code>w</code> systematically when we want to decompress a Git object, we\nallocate <code>w</code> one time per threads and all are able to use it and <strong>re-use</strong> it.\nIn this way, we avoid systematic allocations (and allocate only once time) which\ncan have a serious impact about performances.</p>\n<p>The design is pretty close to one idea, a <em>description</em> step by the <code>decoder</code>\nfunction and a real computation loop with the <code>decode</code> function. The idea is to\nprepare the inflation with some information (like <code>w</code> and <code>o</code>) before the main\n(and the most expensive) computation. Internally we do that too (but it\'s mostly\nabout a macro-optimization).</p>\n<p>It\'s the purpose of OCaml in general, be able to have a powerful way to describe\nsomething (with constraints). In our case, we are very limited to what we need\nto describe. But, in others libraries like <a href="https://github.com/inhabitedtype/angstrom">angstrom</a>, the description\nstep is huge (describe the parser according to the BNF) and then, we use it to\nthe main computation, in the case of angstrom, the parsing (another\nexample is [cmdliner][cmdliner]).</p>\n<p>This is why <code>decoder</code> can be considered as the main function where <code>decode</code> can\nbe wrapped under a stream.</p>\n<h3 id="deflator" style="position:relative;"><a href="#deflator" aria-label="deflator permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deflator</h3>\n<p>The deflator is a new (complex) deal. Indeed, behind it we have two concepts:</p>\n<ul>\n<li>the encoder (according to RFC 1951)</li>\n<li>the compressor</li>\n</ul>\n<p>For this new version of <code>decompress</code>, we decide to separate these concepts where\none question leads all: how to put my compression algorithm? (instead to use\n<a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">LZ77</a>).</p>\n<p>In fact, if you are interested in compression, several algorithms exist and, in\nsome context, it\'s preferable to use <a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm">lzwa</a> for example or rabin\'s\nfingerprint (with <a href="https://github.com/mirage/duff">duff</a>), etc.</p>\n<h4 id="functor" style="position:relative;"><a href="#functor" aria-label="functor permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functor</h4>\n<p>The first idea was to provide a <em>functor</em> which expects an implementation of the\ncompression algorithm. However, the indirection of a functor comes with (big)\nperformance cost. Consider the following functor example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">module</span> <span class="token keyword">type</span> S <span class="token operator">=</span> <span class="token keyword">sig</span>\n  <span class="token keyword">type</span> t\n  <span class="token keyword">val</span> add <span class="token punctuation">:</span> t <span class="token operator">-></span> t <span class="token operator">-></span> t\n  <span class="token keyword">val</span> one <span class="token punctuation">:</span> t\n<span class="token keyword">end</span>\n\n<span class="token keyword">module</span> <span class="token module variable">Make</span> <span class="token punctuation">(</span>S <span class="token punctuation">:</span> S<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token keyword">let</span> succ x <span class="token operator">=</span> S<span class="token punctuation">.</span>add x S<span class="token punctuation">.</span>one <span class="token keyword">end</span>\n\n<span class="token keyword">include</span> <span class="token module variable">Make</span> <span class="token punctuation">(</span><span class="token keyword">struct</span>\n  <span class="token keyword">type</span> t <span class="token operator">=</span> int\n  <span class="token keyword">let</span> add a b <span class="token operator">=</span> a <span class="token operator">+</span> b\n  <span class="token keyword">let</span> one <span class="token operator">=</span> <span class="token number">1</span>\n<span class="token keyword">end</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> f x <span class="token operator">=</span> succ x</code></pre></div>\n<p>Currently, with OCaml 4.07.1, the <code>f</code> function will be a <code>caml_apply2</code>. We might\nwish for a simple <a href="https://en.wikipedia.org/wiki/Inline_expansion"><em>inlining</em></a> optimisation, allowing <code>f</code> to become an\n<code>addq</code> instruction (indeed, <a href="https://caml.inria.fr/pub/docs/manual-ocaml/flambda.html"><code>flambda</code></a> does this), but optimizing\nfunctors is hard. As we learned from <a href="https://github.com/chambart">Pierre Chambart</a>, it is possible\nfor the OCaml compiler to optimize functors directly, but this requires\nrespecting several constraints that are difficult to respect in practice.</p>\n<h4 id="split-encoder-and-compressor" style="position:relative;"><a href="#split-encoder-and-compressor" aria-label="split encoder and compressor permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Split encoder and compressor</h4>\n<p>So, the choice was done to made the encoder which respects RFC 1951 and the\ncompressor under some constraints. However, this is not what <a href="https://zlib.net/">zlib</a> did\nand, by this way, we decided to provide a new design/API which did not follow,\nin first instance, zlib (or some others implementations like\n<a href="https://github.com/richgel999/miniz">miniz</a>).</p>\n<p>To be fair, the choice from zlib and miniz comes from the first\npoint about API and the context where they are used. The main problem is the\nshared queue between the encoder and the compressor. In C code, it can be hard\nfor the user to deal with it (where they are liable for buffer overflows).</p>\n<p>In OCaml and for <code>decompress</code>, the shared queue can be well-abstracted and API\ncan ensure assumptions (like bounds checking).</p>\n<p>Even if this design is much more complex than before, coverage tests are better\nwhere we can separately test the encoder and the compressor. It breaks down the\ninitial black-box where compression was intrinsec with encoding \u2013 which was\nerror-prone. Indeed, <code>decompress</code> had a bug about generation of\nHuffman codes but we never reached it because the (bad)\ncompressor was not able to produce something (a specific lengh with a specific\ndistance) to get it.</p>\n<p>NOTE: you have just read the main reason for the new version of <code>decompress</code>!</p>\n<h4 id="the-compressor" style="position:relative;"><a href="#the-compressor" aria-label="the compressor permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The compressor</h4>\n<p>The compressor is the most easy part. The goal is to produce from an inputs\nflow, an outputs flow which is an other (more compacted) representation. This\nrepresentation consists to:</p>\n<ul>\n<li>A <em>literal</em>, the byte as is</li>\n<li>A <em>copy</em> code with an <em>offset</em> and a <em>length</em></li>\n</ul>\n<p>The last one say to copy <em>length</em> byte(s) from <em>offset</em>. For example, <code>aaaa</code> can\nbe compressed as <code>[ Literal \'a\'; Copy (offset:1, len:3) ]</code>. By this way, instead\nto have 4 bytes, we have only 2 elements which will be compressed then by an\n<a href="https://zlib.net/feldspar.html">Huffman coding</a>. This is the main idea of the <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">lz77</a>\ncompression.</p>\n<p>However, the compressor should need to deal with the encoder. An easy interface,\n<em>\xe0 la <a href="https://github.com/dbuenzli/uutf">uutf</a></em> should be:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> compress <span class="token punctuation">:</span> state <span class="token operator">-></span> <span class="token punctuation">[</span> <span class="token variant variable">`Literal</span> <span class="token keyword">of</span> char <span class="token operator">|</span> <span class="token variant variable">`Copy</span> <span class="token keyword">of</span> <span class="token punctuation">(</span>int <span class="token operator">*</span> int<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token variant variable">`End</span> <span class="token operator">|</span> <span class="token variant variable">`Await</span> <span class="token punctuation">]</span></code></pre></div>\n<p>But as I said, we need to feed a queue instead.</p>\n<hr>\n<p>At this point, the purpose of the queue is not clear and not really explained.\nThe signature above still is a valid and understandable design. Then, we can\nimagine passing <code>Literal</code> and <code>Copy</code> directly to the encoder. However, we should\n(for performance purpose) use a delaying tactic between the compressor and the\ndeflator<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup>.</p>\n<p>Behind this idea, it\'s to be able to implement an <em>hot-loop</em> on the encoder\nwhich will iter inside the shared queue and <em>transmit</em>/<em>encode</em> contents\ndirectly to the outputs buffer.</p>\n<hr>\n<p>So, when we make a new <code>state</code>, we let the user supply their queue:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">val state : src -&gt; w:bistring -&gt; q:queue -&gt; state\nval compress : state -&gt; [ `Flush | `Await | `End ]</code></pre></div>\n<p>The <code>Flush</code> case appears when the queue is full. Then, we refind the <code>w</code> window\nbuffer which is needed to produce the <code>Copy</code> code. A <em>copy code</em> is limited\naccording RFC 1951 where <em>offset</em> can not be upper than the length of the window\n(commonly 32ko). <em>length</em> is limited too to <code>258</code> (an arbitrary choice).</p>\n<p>Of course, about the <code>Await</code> case, the compressor comes with a <code>src</code> function as\nthe inflator. Then, we added some accessors, <code>literals</code> and <code>distances</code>. The\ncompressor does not build the <a href="https://zlib.net/feldspar.html">Huffman coding</a> which needs\nfrequencies, so we need firstly to keep counters about that inside the state and\na way to get them (and pass them to the encoder).</p>\n<p><code>[4]</code>: About that, you should be interesting by the reason of <a href="https://www.reddit.com/r/unix/comments/6gxduc/how_is_gnu_yes_so_fast/">why GNU yes is so\nfast</a> where the secret is just about buffering.</p>\n<h4 id="the-encoder" style="position:relative;"><a href="#the-encoder" aria-label="the encoder permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The encoder</h4>\n<p>Finally, we can talk about the encoder which will take the shared queue filled\nby the compressor and provide an RFC 1951 compliant output flow.</p>\n<p>However, we need to consider a special <em>detail</em>. When we want to make a\nDYNAMIC block from frequencies and then encode the inputs flow, we can reach a\ncase where the shared queue contains an <em>opcode</em> (a <em>literal</em> or a <em>copy</em>) which\ndoes not appear in our dictionary.</p>\n<p>In fact, if we want to encode <code>[ Literal \'a\'; Literal \'b\' ]</code>, we will not try to\nmake a dictionary which will contains the 256 possibilities of a byte but we\nwill only make a dictionary from frequencies which contains only <code>\'a\'</code> and\n<code>\'b\'</code>. By this way, we can reach a case where the queue contains an <em>opcode</em>\n(like <code>Literal \'c\'</code>) which can not be encoded by the <em>pre-determined</em>\nHuffman coding \u2013 remember, the DYNAMIC block <strong>starts</strong> with\nthe dictionary.</p>\n<p>Another point is about inputs. The encoder expects, of course, contents from\nthe shared queue but it wants from the user the way to encode contents: which\nblock we want to emit. So it has two entries:</p>\n<ul>\n<li>the shared queue</li>\n<li>an <em>user-entry</em></li>\n</ul>\n<p>So for many real tests, we decided to provide this kind of API:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> dst <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token variant variable">`Channel</span> <span class="token keyword">of</span> out_channel <span class="token operator">|</span> <span class="token variant variable">`Buffer</span> <span class="token keyword">of</span> <span class="token module variable">Buffer</span><span class="token punctuation">.</span>t <span class="token operator">|</span> <span class="token variant variable">`Manual</span> <span class="token punctuation">]</span>\n\n<span class="token keyword">val</span> encoder <span class="token punctuation">:</span> dst <span class="token operator">-></span> q<span class="token punctuation">:</span>queue <span class="token operator">-></span> encoder\n<span class="token keyword">val</span> encode <span class="token punctuation">:</span> encoder <span class="token operator">-></span> <span class="token punctuation">[</span> <span class="token variant variable">`Block</span> <span class="token keyword">of</span> block <span class="token operator">|</span> <span class="token variant variable">`Flush</span> <span class="token operator">|</span> <span class="token variant variable">`Await</span> <span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span> <span class="token variant variable">`Ok</span> <span class="token operator">|</span> <span class="token variant variable">`Partial</span> <span class="token operator">|</span> <span class="token variant variable">`Block</span> <span class="token punctuation">]</span>\n<span class="token keyword">val</span> dst <span class="token punctuation">:</span> encoder <span class="token operator">-></span> bigstring <span class="token operator">-></span> off<span class="token punctuation">:</span>int <span class="token operator">-></span> len<span class="token punctuation">:</span>int <span class="token operator">-></span> unit</code></pre></div>\n<p>As expected, we take the shared queue to make a new encoder. Then, we let the\nuser to specify which kind of block they want to encode by the <code>Block</code>\noperation.</p>\n<p>The <code>Flush</code> operation tries to encode all elements present inside the shared\nqueue according to the current block and feed the outputs buffer. From it, the\nencoder can returns some values:</p>\n<ul>\n<li><code>Ok</code> and the encoder encoded all <em>opcode</em> from the shared queue</li>\n<li><code>Partial</code>, the outputs buffer is not enough to encode all <em>opcode</em>, the user\nshould flush it and give to us a new empty buffer with <code>dst</code>. Then, they must\ncontinue with the <code>Await</code> operation.</li>\n<li><code>Block</code>, the encoder reachs an <em>opcode</em> which can not be encoded with the\ncurrent block (the current dictionary). Then, the user must continue with a new\n<code>Block</code> operation.</li>\n</ul>\n<p>The hard part is about the <em>ping-pong</em> game between the user and the encoder\nwhere a <code>Block</code> expects a <code>Block</code> response from the user and a <code>Partial</code> expects\nan <code>Await</code> response. But this design reveals something higher about zlib\nthis time: the <em>flush</em> mode.</p>\n<h4 id="the-flush-mode" style="position:relative;"><a href="#the-flush-mode" aria-label="the flush mode permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <em>flush</em> mode</h4>\n<p>Firstly, we talk about <em>mode</em> because zlib does not allow the user to\ndecide what they want to do when we reach a <code>Block</code> or a <code>Ok</code> case. So, it\ndefines some <a href="https://www.bolet.org/~pornin/deflate-flush.html">under-specified <em>modes</em></a> to apply a policy of what\nto do in this case.</p>\n<p>In <code>decompress</code>, we followed the same design and see that it may be not a good\nidea where the logic is not very clear and the user wants may be an another\nbehavior. It was like a <em>black-box</em> with a <em>black-magic</em>.</p>\n<p>Because we decided to split encoder and compressor, the idea of the <em>flush mode</em>\ndoes not exists anymore where the user explicitly needs to give to the encoder\nwhat they want (make a new block? which block? keep frequencies?). So we broke\nthe <em>black-box</em>. But, as we said, it was possible mostly because we can abstract\nsafely the shared queue between the compressor and the encoder.</p>\n<p>OCaml is an expressive language and we can really talk about a queue where, in\nC, it will be just an other <em>array</em>. As we said, the deal is about performance,\nbut now, we allow the user the possibility to write their code in this corner-case\nwhich is when they reachs <code>Block</code>. Behaviors depends only on them.</p>\n<h2 id="apis-in-general" style="position:relative;"><a href="#apis-in-general" aria-label="apis in general permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>APIs in general</h2>\n<p>The biggest challenge of building a library is defining the API - you must\nstrike a compromise between allowing the user the flexibility to express their\nuse-case and constraining the user to avoid API misuse. If at all possible,\nprovide an <em>intuitive</em> API: force the user not to need to think about security\nissues, memory consumption or performance.</p>\n<p>Avoid making your API so expressive that it becomes unusable, but beware that\nthis sets hard limits on your users: the current <code>decompress</code> API can be used to\nbuild <code>of_string</code> / <code>to_string</code> functions, but the opposite is not true - you\ndefinitely cannot build a stream API from <code>of_string</code> / <code>to_string</code>.</p>\n<p>The best advice when designing a library is to keep in mind what you <strong>really</strong>\nwant and let the other details fall into place gradually. It is very important\nto work in an iterative loop of repeatedly trying to use your library; only this\ncan highlight bad design, corner-cases and details.</p>\n<p>Finally, use and re-use it on your tests (important!) and inside higher-level\nprojects to give you interesting questions about your design. The last version\nof <code>decompress</code> was not used in <a href="https://github.com/mirage/ocaml-git/">ocaml-git</a> mostly because the flush\nmode was unclear.</p>'},tl:{hd:{title:"Dune 1.2.0",slug:"dune-120",description:"After a tiny but important patch release as 1.1.1, the dune team is thrilled to\nannounce the release of dune 1.2.0! Here are some highlights\u2026",url:"https://tarides.com/blog/2018-09-06-dune-1-2-0",date:"2018-09-06T00:00:00-00:00",preview_image:"https://tarides.com/static/98e7b693b372846010bfcd8d54746146/2244e/sand_dune1.jpg",body_html:'<p>After a tiny but important patch release as 1.1.1, the dune team is thrilled to\nannounce the release of dune 1.2.0! Here are some highlights of the new\nfeatures in that version. The full list of changes can be found <a href="https://github.com/ocaml/dune/blob/e3af33b43a87d7fa2d15f7b41d8bd942302742ec/CHANGES.md#120-14092018">in the dune\nrepository</a>.</p>\n<h1 id="watch-mode" style="position:relative;"><a href="#watch-mode" aria-label="watch mode permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Watch mode</h1>\n<p>When developing, it is common to edit a file, run a build, read the error\nmessage, and fix the error. Since this is a very tight loop and developers are\ndoing this hundreds or thousands times a day, it is crucial to have the\nquickest feedback possible.</p>\n<p><code>dune build</code> and <code>dune runtest</code> now accept <a href="https://dune.readthedocs.io/en/latest/usage.html#watch-mode">a <code>-w</code>\nflag</a> that will\nwatch the filesystem for changes, and trigger a new build.</p>\n<h1 id="better-error-messages" style="position:relative;"><a href="#better-error-messages" aria-label="better error messages permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Better error messages</h1>\n<p>Inspired by the great work done in\n<a href="http://elm-lang.org/blog/compiler-errors-for-humans">Elm</a> and\n<a href="https://reasonml.github.io/blog/2017/08/25/way-nicer-error-messages.html">bucklescript</a>,\ndune now displays the relevant file in error messages.</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> % cat dune\n(executable\n (name my_program)\n (librarys cmdliner)\n)\n % dune build\nFile &quot;dune&quot;, line 3, characters 2-10:\n3 |  (librarys cmdliner)\n      ^^^^^^^^\nError: Unknown field librarys\nHint: did you mean libraries?</code></pre></div>\n<p>Many messages have also been improved, in particular to help users <a href="https://dune.readthedocs.io/en/latest/migration.html#check-list">switching\nfrom the <code>jbuild</code> format to the <code>dune</code>\nformat</a>.</p>\n<h1 id="dune-unstable-fmt" style="position:relative;"><a href="#dune-unstable-fmt" aria-label="dune unstable fmt permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dune unstable-fmt</h1>\n<p>Are you confused about how to format S-expressions? You are not alone.\nThat is why we are gradually introducing a formatter for <code>dune</code> files. It can\ntransform a valid but ugly <code>dune</code> into one that is consistently formatted.</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> % cat dune\n(executable( name ls) (libraries cmdliner)\n(preprocess (pps ppx_deriving.std)))\n % dune unstable-fmt dune\n(executable\n (name ls)\n (libraries cmdliner)\n (preprocess\n  (pps ppx_deriving.std)\n )\n)</code></pre></div>\n<p>This feature is not ready yet for the end user (hence the <code>unstable</code> part),\nand in particular the concrete syntax is not stable yet.\nBut having it already in the code base will make it possible to build useful\nintegrations with <code>dune</code> itself (to automatically reformat all dune files in a\nproject, for example) and common editors, so that they format <code>dune</code> files on\nsave.</p>\n<h1 id="first-class-support-of-findlib-plugins" style="position:relative;"><a href="#first-class-support-of-findlib-plugins" aria-label="first class support of findlib plugins permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>First class support of findlib plugins</h1>\n<p>It is now easy to support findlib plugins by just adding the <code>findlib.dynload</code>\nlibrary dependency. Then you can use <code>Fl_dynload</code> module in your code which\nwill automatically do the right thing. <a href="https://dune.readthedocs.io/en/latest/advanced-topics.html#dynamic-loading-of-packages">A complete example can be found in the\ndune manual</a>.</p>\n<h1 id="promote-only-certain-files" style="position:relative;"><a href="#promote-only-certain-files" aria-label="promote only certain files permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promote only certain files</h1>\n<p>The <code>dune promote</code> command now accept a list of files. This is useful to\npromote just the file that is opened in a text editor for example. Some emacs\nbindings are provided to do this, which works particularly well with\n<a href="https://dune.readthedocs.io/en/latest/tests.html#inline-expectation-tests">inline expectation tests</a>.</p>\n<h1 id="deprecation-message-for-wrapped-modes" style="position:relative;"><a href="#deprecation-message-for-wrapped-modes" aria-label="deprecation message for wrapped modes permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deprecation message for (wrapped) modes</h1>\n<p>By default, libraries are <code>(wrapped true)</code>, which means that they expose a\nsingle OCaml module (source files are exposed as submodules of this main\nmodule). This is usually desired as it makes link-time name collisions less\nlikely. However, a lot of libraries are using <code>(wrapped false)</code> (expose all\nsource files as modules) to keep compatibility.</p>\n<p>It can be challenging to transition from <code>(wrapped false)</code> to <code>(wrapped true)</code>\nbecause it breaks compatibility. That is why we have added <code>(wrapped (transition "message"))</code> which will generate wrapped modules but keep unwrapped\nmodules with a deprecation message to help coordinate the change.</p>\n<h1 id="credits" style="position:relative;"><a href="#credits" aria-label="credits permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Credits</h1>\n<p>Special thanks to our contributors for this release: @aantron, @anuragsoni,\n@bobot, @ddickstein, @dra27, @drjdn, @hongchangwu, @khady, @kodek16,\n@prometheansacrifice and @ryyppy.</p>'},tl:{hd:{title:"Dune 1.9.0",slug:"dune-190",description:"Tarides is pleased to have contributed to the dune 1.9.0 release which\nintroduces the concept of library variants. Thanks to this update\u2026",url:"https://tarides.com/blog/2019-04-10-dune-1-9-0",date:"2019-04-10T00:00:00-00:00",preview_image:"https://tarides.com/static/a7294df7159db3785da6121fc6ecadf8/2244e/sand_dune2.jpg",body_html:'<p>Tarides is pleased to have contributed to the dune 1.9.0 release which\nintroduces the concept of library variants. Thanks to this update,\nunikernels builds are becoming easier and faster in the MirageOS\nuniverse! This also opens the door for a better cross-compilation\nstory, which will ease the addition of new MirageOS backends\n(trustzone, ESP32, RISC-V, etc.)</p>\n<p><em>This post has also been posted to the\n<a href="https://dune.build/blog/dune-1-9-0/">Dune blog</a>.  See also the <a href="https://discuss.ocaml.org/t/ann-dune-1-9-0/3646">the discuss\nforum</a> for more\ndetails.</em></p>\n<h1 id="dune-190" style="position:relative;"><a href="#dune-190" aria-label="dune 190 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dune 1.9.0</h1>\n<p>Changes include:</p>\n<ul>\n<li>Coloring in the watch mode (<a href="https://github.com/ocaml/dune/pull/1956">#1956</a>)</li>\n<li><code>$ dune init</code> command to create or update project boilerplate (<a href="https://github.com/ocaml/dune/pull/1448">#1448</a>)</li>\n<li>Allow "." in c_names and cxx_names (<a href="https://github.com/ocaml/dune/pull/2036">#2036</a>)</li>\n<li>Experimental Coq support</li>\n<li>Support for library variants and default implementations (<a href="https://github.com/ocaml/dune/pull/1900">#1900</a>)</li>\n</ul>\n<h1 id="variants" style="position:relative;"><a href="#variants" aria-label="variants permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variants</h1>\n<p>In dune 1.7.0, the concept of virtual library was introduced:\n<a href="https://dune.build/blog/virtual-libraries/">https://dune.build/blog/virtual-libraries/</a>. This feature allows to\nmark some abstract library as virtual, and then have several\nimplementations for it. These implementations could be for multiple\ntargets (<code>unix</code>, <code>xen</code>, <code>js</code>), using different algorithms, using C\ncode or not. However each implementation in a project dependency tree\nhad to be manually selected. Dune 1.9.0 introduces features for\nautomatic selection of implementations.</p>\n<h2 id="library-variants" style="position:relative;"><a href="#library-variants" aria-label="library variants permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Library variants</h2>\n<p>Variants is a tagging mechanism to select implementations on the final\nlinking step. There\'s not much to add to make your implementation use\nvariants. For example, you could decide to design a <code>bar_js</code> library\nwhich is the javascript implementation of <code>bar</code>, a virtual\nlibrary. All you need to do is specificy a <code>js</code> tag using the\n<code>variant</code> option.</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(library\n (name bar_js)\n (implements bar)\n (variant js)); &lt;-- variant specification</code></pre></div>\n<p>Now any executable that depend on <code>bar</code> can automatically select the\n<code>bar_js</code> library variant using the <code>variants</code> option in the dune file.</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(executable\n (name foo)\n (libraries bar baz)\n (variants js)); &lt;-- variants selection</code></pre></div>\n<h2 id="common-variants" style="position:relative;"><a href="#common-variants" aria-label="common variants permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Common variants</h2>\n<h3 id="language-selection" style="position:relative;"><a href="#language-selection" aria-label="language selection permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Language selection</h3>\n<p>In your projects you might want to trade off speed for portability:</p>\n<ul>\n<li><code>ocaml</code>: pure OCaml</li>\n<li><code>c</code>: OCaml accelerated by C</li>\n</ul>\n<h3 id="javascript-backend" style="position:relative;"><a href="#javascript-backend" aria-label="javascript backend permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript backend</h3>\n<ul>\n<li><code>js</code>: code aiming for a Node backend, using <code>Js_of_ocaml</code></li>\n</ul>\n<h2 id="mirage-backends" style="position:relative;"><a href="#mirage-backends" aria-label="mirage backends permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mirage backends</h2>\n<p>The Mirage project (<a href="https://mirage.io/">mirage.io</a>) will make\nextensive use of this feature in order to select the appropriate\ndependencies according to the selected backend.</p>\n<ul>\n<li><code>unix</code>: Unikernels as Unix applications, running on top of <code>mirage-unix</code></li>\n<li><code>xen</code>: Xen backend, on top of <code>mirage-xen</code></li>\n<li><code>freestanding</code>: Freestanding backend, on top of <code>mirage-solo5</code></li>\n</ul>\n<h2 id="default-implementation" style="position:relative;"><a href="#default-implementation" aria-label="default implementation permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Default implementation</h2>\n<p>To facilitate the transition from normal libraries into virtuals ones,\nit\'s possible to specify an implementation that is selected by\ndefault. This default implementation is selected if no implementation\nis chosen after variant resolution.</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(library\n (name bar)\n (virtual_modules hello)\n (default_implementation bar_unix)); &lt;-- default implementation selection</code></pre></div>\n<h2 id="selection-mechanism" style="position:relative;"><a href="#selection-mechanism" aria-label="selection mechanism permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Selection mechanism</h2>\n<p>Implementation is done with respect to some priority rules:</p>\n<ul>\n<li>manual selection of an implementation overrides everything</li>\n<li>after that comes selection by variants</li>\n<li>finally unimplemented virtual libraries can select their default implementation</li>\n</ul>\n<p>Libraries may depend on specific implementations but this is not\nrecommended. In this case, several things can happen:</p>\n<ul>\n<li>the implementation conflicts with a manually selected implementation: resolution fails.</li>\n<li>the implementation overrides variants and default implementations: a cycle check is done and this either resolves or fails.</li>\n</ul>\n<h2 id="conclusion" style="position:relative;"><a href="#conclusion" aria-label="conclusion permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>\n<p>Variant libraries and default implementations are fully <a href="https://dune.readthedocs.io/en/latest/variants.html">documented\nhere</a>. This\nfeature improves the usability of virtual libraries.</p>\n<p>This\n<a href="https://github.com/dune-universe/mirage-entropy/commit/576d25d79e3117bba64355ae73597651cfd27631">commit</a>\nshows the amount of changes needed to make a virtual library use\nvariants.</p>\n<h1 id="coq-support" style="position:relative;"><a href="#coq-support" aria-label="coq support permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Coq support</h1>\n<p>Dune now supports building Coq projects. To enable the experimental Coq\nextension, add <code>(using coq 0.1)</code> to your <code>dune-project</code> file. Then,\nyou can use the <code>(coqlib ...)</code> stanza to declare Coq libraries.</p>\n<p>A typical <code>dune</code> file for a Coq project will look like:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(include_subdirs qualified) ; Use if your development is based on sub directories\n\n(coqlib\n  (name Equations)                  ; Name of wrapper module\n  (public_name equations.Equations) ; Generate an .install file\n  (synopsis &quot;Equations Plugin&quot;)     ; Synopsis\n  (libraries equations.plugin)      ; ML dependencies (for plugins)\n  (modules :standard \\ IdDec)       ; modules to build\n  (flags -w -notation-override))    ; coqc flags</code></pre></div>\n<p>See the <a href="https://github.com/ocaml/dune/blob/1.9/doc/coq.rst">documentation of the\nextension</a> for more\ndetails.</p>\n<h1 id="credits" style="position:relative;"><a href="#credits" aria-label="credits permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Credits</h1>\n<p>This release also contains many other changes and bug fixes that can\nbe found on the <a href="https://discuss.ocaml.org/t/ann-dune-1-9-0/3646">discuss\nannounce</a>.</p>\n<p>Special thanks to dune maintainers and contributors for this release:\n<a href="https://github.com/rgrinberg">@rgrinberg</a>,\n<a href="https://github.com/emillon">@emillon</a>,\n<a href="https://github.com/shonfeder">@shonfeder</a>\nand <a href="https://github.com/ejgallego">@ejgallego</a>!</p>'},tl:{hd:{title:"Florence and beyond: the future of Tezos storage",slug:"florence-and-beyond-the-future-of-tezos-storage",description:"In collaboration with Nomadic Labs, Marigold and DaiLambda, we're happy to\nannounce the completion of the next Tezos protocol proposal\u2026",url:"https://tarides.com/blog/2021-03-04-florence-and-beyond-the-future-of-tezos-storage",date:"2021-03-04T00:00:00-00:00",preview_image:"https://tarides.com/static/d81c504dbb5172d29c2aa38512f1dfe3/2244e/florence.jpg",body_html:'<p>In collaboration with Nomadic Labs, Marigold and DaiLambda, we\'re happy to\nannounce the completion of the next Tezos protocol proposal:\n<a href="http://doc.tzalpha.net/protocols/009_florence.html"><strong>Florence</strong></a>.</p>\n<p><a href="https://tezos.com/">Tezos</a> is an open-source decentralised blockchain network providing a\nplatform for smart contracts and digital assets. A crucial feature of Tezos is\n<a href="https://tezos.com/static/white_paper-2dc8c02267a8fb86bd67a108199441bf.pdf"><em>self-amendment</em></a>: the network protocol can be upgraded\ndynamically by the network participants themselves. This amendment process is\ninitiated when a participant makes a <em>proposal</em>, which is then subject to a\nvote. After several years working on the Tezos storage stack, this is our first\ncontribution to a proposal; we hope that it will be the first of many!</p>\n<p>As detailed in today\'s <a href="https://blog.nomadic-labs.com/florence-our-next-protocol-upgrade-proposal.html">announcement from Nomadic Labs</a>,\nthe Florence proposal contains several important changes, from the introduction\nof Baking Accounts to major quality-of-life improvements for smart contract\ndevelopers. Of all of these changes, we\'re especially excited about the\nintroduction of <em>sub-trees</em> to the blockchain context API. In this post, we\'ll\ngive a brief tour of what these sub-trees will bring for the future of Tezos.\nBut first, what <em>are</em> they?</p>\n<h3 id="merkle-sub-trees" style="position:relative;"><a href="#merkle-sub-trees" aria-label="merkle sub trees permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Merkle sub-trees</h3>\n<p>The Tezos protocol runs on top of a versioned tree called the \u201ccontext\u201d, which\nholds the chain state (balances, contracts etc.). Ever since the pre-Alpha era,\nthe Tezos context has been implemented using <a href="https://github.com/mirage/irmin">Irmin</a> \u2013 an open-source\nMerkle tree database originally written for use by MirageOS unikernels.</p>\n<p>For MirageOS, Irmin\u2019s key strength is flexibility: it can run over arbitrary\nbackends. This is a perfect fit for Tezos, which must be agile and\nwidely-deployable. Indeed, the Tezos shell has already leveraged this agility\nmany times, all the way from initial prototypes using a Git backend to the\noptimised <a href="https://tarides.com/blog/2020-09-01-introducing-irmin-pack"><code>irmin-pack</code></a> implementation used today.</p>\n<p>But Irmin can do more than just swapping backends! It also allows users to\nmanipulate the underlying Merkle tree structure of the store with a high-level\nAPI. This \u201c<a href="https://mirage.github.io/irmin/irmin/Irmin/module-type-S/Tree/">Tree</a>\u201d API enables lots of interesting use-cases of\nIrmin, from mergeable data types (<a href="https://kcsrk.info/papers/banyan_aplas20.pdf">MRDTs</a>) to zero-knowledge proofs.\nTezos doesn\'t use these more powerful features directly yet; that\u2019s where Merkle\nproofs come in!</p>\n<h3 id="proofs-and-lightweight-tezos-clients" style="position:relative;"><a href="#proofs-and-lightweight-tezos-clients" aria-label="proofs and lightweight tezos clients permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Proofs and lightweight Tezos clients</h3>\n<p>Since the Tezos context keeps track of the current "state" of the blockchain,\neach participant needs their own copy of the tree to run transactions against.\nThis context can grow to be very large, so it\'s important that it be stored as\ncompactly as possible: this goal shaped the design of <code>irmin-pack</code>, our latest\nIrmin backend.</p>\n<p>However, it\'s possible to reduce the storage requirements even further via the\nmagic of Merkle trees: individuals only need to store a <em>fragment</em> of the root\ntree, provided they can demonstrate that this fragment is valid by sending\n\u201c<a href="https://bentnib.org/posts/2016-04-12-authenticated-data-structures-as-a-library.html">proofs</a>\u201d of its membership to the other participants.</p>\n<p>This property can be used to support ultra-lightweight Tezos clients, a feature\n<a href="https://gitlab.com/smelc/tezos/-/commits/tweag-client-light-mode">currently being developed</a> by TweagIO. To make this a reality,\nthe Tezos protocol needs fine-grained access to context sub-trees in order build\nMerkle proofs out of them. Fortunately, Irmin already supports this! We\n<a href="https://gitlab.com/tezos/tezos/-/merge_requests/2457">extended the protocol</a> to understand sub-trees, lifting the power\nof Merkle trees to the user.</p>\n<p>We\u2019re excited to work with TweagIO and Nomadic Labs on lowering the barriers to\nentering the Tezos ecosystem and look forward to seeing what they achieve with\nsub-trees!</p>\n<h3 id="efficient-merkle-proof-representations" style="position:relative;"><a href="#efficient-merkle-proof-representations" aria-label="efficient merkle proof representations permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Efficient Merkle proof representations</h3>\n<p>Simply exposing sub-trees in the Tezos context API isn\u2019t quite enough:\nlightweight clients will also need to <em>serialize</em> them efficiently, since proofs\nmust be exchanged over the network to establish trust between collaborating\nnodes. Enter <a href="https://dailambda.jp/blog/2020-05-11-plebeia/">Plebeia</a>.</p>\n<p>Plebeia is an alternative Tezos storage layer \u2013 developed by DaiLambda \u2013 with\nstrengths that complement those of Irmin. In particular, Plebeia is capable of\ngenerating very compact Merkle proofs. This is partly due to its specialized\nstore structure, and partly due to clever optimizations such as path compression\nand inlining.</p>\n<p>We\u2019re working with the DaiLambda team to unite the strengths of Irmin and\nPlebeia, which will bring built-in Merkle proof support to the Tezos storage\nstack. The future is bright for Merkle proofs in Tezos!</p>\n<h3 id="baking-account-migrations" style="position:relative;"><a href="#baking-account-migrations" aria-label="baking account migrations permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Baking account migrations</h3>\n<p>Trees don\u2019t just enable <em>new</em> features; they have a big impact on performance\ntoo! Currently, indexing into the context always happens from its <em>root</em>, which\nduplicates effort when accessing adjacent values deep in the tree. Fortunately,\nthe new sub-trees provide a natural representation for \u201ccursors\u201d into the\ncontext, allowing the protocol to optimize its interactions with the storage\nlayer.</p>\n<p>To take just one example, DaiLambda recently exploited this feature to reduce\nthe migration time necessary to introduce Baking Accounts to the network by a\nfactor of 15! We\u2019ll be teaming up with Nomadic Labs and DaiLambda to ensure that\nTezos extracts every bit of performance from its storage.</p>\n<p>It\'s especially exciting to have access to lightning-fast storage migrations,\nsince this enables Tezos to evolve rapidly even as the ecosystem expands.</p>\n<h3 id="storage-in-other-languages" style="position:relative;"><a href="#storage-in-other-languages" aria-label="storage in other languages permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Storage in other languages</h3>\n<p>Of course, Tezos isn\u2019t just an OCaml project: the storage layer also has a\nperformant Rust implementation as part of <a href="https://github.com/simplestaking/tezedge">TezEdge</a>. We\u2019re working with\n<a href="https://github.com/simplestaking">Simple Staking</a> to bring Irmin to the Rust community via an\n<a href="https://github.com/simplestaking/ocaml-interop">FFI toolchain</a>, enabling closer alignment between the different\nTezos shell implementations.</p>\n<h3 id="conclusion" style="position:relative;"><a href="#conclusion" aria-label="conclusion permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h3>\n<p>All in all, it\u2019s an exciting time to work on Tezos storage, with many\nopen-source collaborators from around the world. We\u2019re especially happy to see\nTezos taking greater advantage of Irmin\u2019s features, which will strengthen both\nprojects and help them grow together.</p>\n<p>If all of this sounds interesting, you can play with it yourself using the\nrecently-released <a href="https://github.com/mirage/irmin">Irmin 2.5.0</a>. Thanks for reading, and stay tuned for\nfuture Tezos development updates!</p>'},tl:{hd:{title:"Fuzzing OCamlFormat with AFL and Crowbar",slug:"fuzzing-ocamlformat-with-afl-and-crowbar",description:"AFL (and fuzzing in general) is often used\nto find bugs in low-level code like parsers, but it also works very well to find\nbugs in high\u2026",url:"https://tarides.com/blog/2020-08-03-fuzzing-ocamlformat-with-afl-and-crowbar",date:"2020-08-03T00:00:00-00:00",preview_image:"https://tarides.com/static/e6219992a464284115d27348b49c3910/2244e/feather2.jpg",body_html:'<p><a href="https://lcamtuf.coredump.cx/afl/">AFL</a> (and fuzzing in general) is often used\nto find bugs in low-level code like parsers, but it also works very well to find\nbugs in high level code, provided the right ingredients. We applied this\ntechnique to feed random programs to OCamlFormat and found many formatting bugs.</p>\n<p>OCamlFormat is a tool to format source code. To do so, it parses the source code\nto an Abstract Syntax Tree (AST) and then applies formatting rules to the AST.</p>\n<p>It can be tricky to correctly format the output. For example, say we want to\nformat <code>(a+b)*c</code>. The corresponding AST will look like <code>Apply("*", Apply ("+", Var "a", Var "b"), Var "c")</code>. A naive formatter would look like this:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> format <span class="token operator">=</span> <span class="token keyword">function</span>\n  <span class="token operator">|</span> <span class="token module variable">Var</span> s <span class="token operator">-></span> s\n  <span class="token operator">|</span> <span class="token module variable">Apply</span> <span class="token punctuation">(</span>op<span class="token punctuation">,</span> e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span> <span class="token operator">-></span>\n      <span class="token module variable">Printf</span><span class="token punctuation">.</span>sprintf <span class="token string">"%s %s %s"</span> <span class="token punctuation">(</span>format e1<span class="token punctuation">)</span> op <span class="token punctuation">(</span>format e2<span class="token punctuation">)</span></code></pre></div>\n<p>But this is not correct, as it will print <code>(a+b)*c</code> as <code>a+b*c</code>, which is a\ndifferent program. In this particular case, the common solution would be to\ntrack the relative precedence of the expressions and to emit only necessary\nparentheses.</p>\n<p>OCamlFormat has similar cases. To make sure we do not change a program when\nformatting it, there is an extra check at the end to parse the output and\ncompare the output AST with the input AST. This ensures that, in case of bugs,\nOCamlFormat exits with an error rather than changing the meaning of the input\nprogram.</p>\n<p>When we consider the whole OCaml language, the rules are complex and it is\ndifficult to make sure that we are correctly handling all programs. There are\ntwo main failure modes: either we put too many parentheses, and the program does\nnot look good, or we do not put enough, and the AST changes (and OCamlFormat\nexits with an error). We need a way to make sure that the latter does not\nhappen. Tests work to some extent, but some edge cases happen only when a\ncertain combination of language features is used. Because of this combinatorial\nexplosion, it is impossible to get good coverage using tests only.</p>\n<p>Fortunately there is a technique we can use to automatically explore the program\nspace: fuzzing. For a primer on using this technique on OCaml programs, one can\nrefer to <a href="https://tarides.com/blog/2019-09-04-an-introduction-to-fuzzing-ocaml-with-afl-crowbar-and-bun">this article</a>.</p>\n<p>To make this work we need two elements: a random program generator, and a\nproperty to check. Here, we are interested in programs that are valid (in the\nsense that they parse correctly) but do not format correctly. We can use the\nOCamlFormat internals to do the following:</p>\n<ol>\n<li>try to parse input: in case of a parse error, just reject this input as\ninvalid.</li>\n<li>otherwise, with have a valid program. try to format it. If this happens with\nno error at all, reject this input as well.</li>\n<li>otherwise, it means that the AST changed, comments moved, or something\nsimilar, in a valid program. This is what we are after.</li>\n</ol>\n<p>Generating random programs is a bit more difficult. We can feed random strings\nto AFL, but even with a corpus of existing valid code it will generate many\ninvalid programs. We are not interested in these for this project, we would\nrather start from valid programs.</p>\n<p>A good way to do that is to use Crowbar to directly generate AST values. Thanks\nto <a href="https://github.com/yomimono/ppx_deriving_crowbar"><code>ppx_deriving_crowbar</code></a> and <a href="https://github.com/ocaml-ppx/ppx_import"><code>ppx_import</code></a>\nit is possible to generate random values for an external type like\n<code>Parsetree.structure</code> (the contents of <code>.ml</code> files). Even more fortunately\n<a href="https://github.com/yomimono/ocaml-test-omp/blob/d086037027537ba4e23ce027766187979c85aa3d/test/parsetree_405.ml">somebody already did the work</a>. Thanks, Mindy!</p>\n<p>This approach works really well: it generates 5k-10k programs per second, which\nis very good performance (AFL starts complaining below 100/s).</p>\n<p>Quickly, AFL was able to find crashes related to attributes. These are "labels"\nattached to various nodes of the AST. For example the expression <code>(x || y) [@a]</code>\n(logical or between <code>x</code> and <code>y</code>, attach attribute <code>a</code> to the "or" expression)\nwould get formatted as <code>x || y [@a]</code> (attribute <code>a</code> is attached to the <code>y</code>\nvariable). Once again, there is a check in place in OCamlFormat to make sure\nthat it does not save the file in this case, but it would exit with an error.</p>\n<p>After the fuzzer has run for a bit longer, it found crashes where comments would\njump around in expressions like <code>f (*a*) (*bb*) x</code>. Wait, what? We never told\nthe program generator how to generate comments. Inspecting the intermediate AST,\nthe part in the middle is actually an integer literal with value <code>"(*a*) (*bb*)"</code> (integer literals are represented as strings so that <a href="https://github.com/Drup/Zarith-ppx">a third party\nlibrary could add literals for arbitrary precision numbers</a> for\nexample).</p>\n<p>AFL comes with a program called <code>afl-tmin</code> that is used to minimize a crash. It\nwill try to find a smaller example of a program that crashes OCamlFormat. It\nworks well even with Crowbar in between. For example it is able to turn <code>(new aaaaaa &#x26; [0;0;0;0])[@aaaaaaaaaa]</code> into <code>(0&#x26;0)[@a]</code> (neither AFL nor OCamlFormat\nknows about types, so they can operate on nonsensical programs. Finding a\nwell-typed version of a crash is usually not very difficult, but it has to be\ndone manually).</p>\n<p>In total, letting AFL run overnight on a single core (that is relatively short\nin terms of fuzzing) caused 453 crashes. After minimization and deduplication,\nthis corresponded to <a href="https://github.com/ocaml-ppx/ocamlformat/issues?q=label%3Afuzz">about 30 unique issues</a>.</p>\n<p>Most of them are related to attributes that OCamlFormat did not try to include\nin the output, or where it forgot to add parentheses. Fortunately, there are\nsafeguards in OCamlFormat: since it checks that the formatting preserves the AST\nstructure, it will exit with an error instead of outputting a different program.</p>\n<p>Once again, fuzzing has proved itself as a powerful technique to find actual\nbugs (including high-level ones). A possible approach for a next iteration is to\ntry to detect more problems during formatting, such as finding cases where lines\nare longer than allowed. It is also possible to extend the random program\ngenerator so that it tries to generate comments, and let OCamlFormat check that\nthey are all laid out correctly in the output. We look forward to employing\nfuzzing more extensively for OCamlFormat development in future.</p>'},tl:{hd:{title:"How configurator reads C constants",slug:"how-configurator-reads-c-constants",description:void 0,url:"https://dune.build/blog/configurator-constants/",date:"2019-01-03T00:00:00-00:00",preview_image:void 0,body_html:"<p>Dune comes with a library to query OS-specific information, called configurator.\nIt is able to evaluate C expressions and turn them into OCaml value.\nSurprisingly, it even works when compiling for a different architecture. How can\nit do that?</p>"},tl:{hd:{title:"Introducing irmin-pack",slug:"introducing-irmin-pack",description:"irmin-pack is an Irmin storage backend\nthat we developed over the last year specifically to meet the\nTezos use-case. Tezos nodes were\u2026",url:"https://tarides.com/blog/2020-09-01-introducing-irmin-pack",date:"2020-09-01T00:00:00-00:00",preview_image:"https://tarides.com/static/5dbd4ce5058bf6225c3a8ac98e4dda54/2244e/drawers.jpg",body_html:'<p><code>irmin-pack</code> is an Irmin <a href="https://irmin.org/tutorial/backend">storage backend</a>\nthat we developed over the last year specifically to meet the\n<a href="https://tezos.gitlab.io/">Tezos</a> use-case. Tezos nodes were initially using an\nLMDB-based backend for their storage, which after only a year of activity led to\n<code>250 GB</code> disk space usage, with a monthly growth of <code>25 GB</code>. Our goal was to\ndramatically reduce this disk space usage.</p>\n<p>Part of the <a href="https://tarides.com/blog/2019-11-21-irmin-v2">Irmin.2.0.0 release</a>\nand still under active development, it has been successfully integrated as the\nstorage layer of Tezos nodes and has been running in production for the last ten\nmonths with great results. It reduces disk usage by a factor of 10, while still\nensuring similar performance and consistency guarantees in a memory-constrained\nand concurrent environment.</p>\n<p><code>irmin-pack</code> was presented along with Irmin v2 at the OCaml workshop 2020; you\ncan watch the presentation here:</p>\n<div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%">\n  <iframe \n    style="position: absolute; width: 100%; height: 100%; left: 0; right: 0"\n    src="https://www.youtube-nocookie.com/embed/v1lfMUM332w" frameborder="0"\n    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"\n    allowfullscreen>\n  </iframe>\n</div>\n<h2 id="general-structure" style="position:relative;"><a href="#general-structure" aria-label="general structure permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>General structure</h2>\n<p><code>irmin-pack</code> exposes functors that allow the user to provide arbitrary low-level\nmodules for handling I/O, and provides a fast key-value store interface composed\nof three components:</p>\n<ul>\n<li>The <code>pack</code> is used to store the data contained in the Irmin store, as blobs.</li>\n<li>The <code>dict</code> stores the paths where these blobs should live.</li>\n<li>The <code>index</code> keeps track of the blobs that are present in the repository by\ncontaining location information in the <code>pack</code>.</li>\n</ul>\n<p>Each of these use both on-disk storage for persistence and concurrence and\nvarious in-memory caches for speed.</p>\n<h3 id="storing-the-data-in-the-pack-file" style="position:relative;"><a href="#storing-the-data-in-the-pack-file" aria-label="storing the data in the pack file permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Storing the data in the <code>pack</code> file</h3>\n<p>The <code>pack</code> contains most of the data stored in this Irmin backend. It is an\nappend-only file containing the serialized data stored in the Irmin repository.\nAll three Irmin stores (see our <a href="https://irmin.org/tutorial/architecture">architecture\npage</a> in the tutorial to learn more)\nare contained in this single file.</p>\n<p><code>Content</code> and <code>Commit</code> serialization is straightforward through\n<a href="https://docs.mirage.io/irmin/Irmin/Type/index.html"><code>Irmin.Type</code></a>. They are written along with their length (to allow\ncorrect reading) and hash (to enable integrity checks). The hash is used to\nresolve internal links inside the pack when nodes are written.</p>\n<p><span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/65f80d5690bb49cd0ead891e2e7346c8/f989d/pack.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 16.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMACSfAAAknwAFlKNyIAAAAxElEQVQI1x2O206DQABE+f//MTE8mJhoL1mLSBM1SHEXXGDZbsrN0FaT48rDZOZk5mGCPvugrwx1Z7FTgx0NZjDkpkR3irrXi5pBUziNtKXva7RztGPDPDt+Lz2X+cTPuSOwtzck4T0P6QtPasvmsGKnYsIoIqmfEVKwztbsm5iV39wlAvG5JdxFnh852hijBDrfcB1TgnP6js0kh7bkyz8qTwrlClKtfZYLF17/XdZI3nSGdDmvpVx8mipm//h7qLjOLX+3ito8uSttdAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="The `pack` file"\n        title="The `pack` file"\n        src="/static/65f80d5690bb49cd0ead891e2e7346c8/c5bb3/pack.png"\n        srcset="/static/65f80d5690bb49cd0ead891e2e7346c8/04472/pack.png 170w,\n/static/65f80d5690bb49cd0ead891e2e7346c8/9f933/pack.png 340w,\n/static/65f80d5690bb49cd0ead891e2e7346c8/c5bb3/pack.png 680w,\n/static/65f80d5690bb49cd0ead891e2e7346c8/b12f7/pack.png 1020w,\n/static/65f80d5690bb49cd0ead891e2e7346c8/b5a09/pack.png 1360w,\n/static/65f80d5690bb49cd0ead891e2e7346c8/f989d/pack.png 5206w"\n        sizes="(max-width: 680px) 100vw, 680px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n      />\n  </a>\n    </span></p>\n<h4 id="optimizing-large-nodes" style="position:relative;"><a href="#optimizing-large-nodes" aria-label="optimizing large nodes permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optimizing large nodes</h4>\n<p>Serializing nodes is not as simple as contents. In fact, nodes might contain an\narbitrarily large number of children, and serializing them as a long list of\nreferences might harm performance, as that means loading and writing a large\namount of data for each modification, no matter how small this modification\nmight be. Similarly, browsing the tree means reading large blocks of data, even\nthough only one child is needed.</p>\n<p>For this reason, we implemented a <a href="https://en.wikipedia.org/wiki/Radix_tree">Patricia Tree</a> representation of\ninternal nodes that allows us to split the child list into smaller parts that\ncan be accessed and modified independently, while still being quickly available\nwhen needed. This reduces duplication of tree data in the Irmin store and\nimproves disk access times.</p>\n<p>Of course, we provide a custom hashing mechanism, so that hashing the nodes\nusing this partitioning is still backwards-compatible for users who rely on hash\ninformation regardless of whether the node is split or not.</p>\n<h4 id="optimizing-internal-references" style="position:relative;"><a href="#optimizing-internal-references" aria-label="optimizing internal references permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optimizing internal references</h4>\n<p>In the Git model, all data are content-addressable (i.e. data are always\nreferenced by their hash). This naturally lends to indexing data by hashes on\nthe disk itself (i.e. the links from <code>commits</code> to <code>nodes</code> and from <code>nodes</code> to\n<code>nodes</code> or <code>contents</code> are realized by hash).</p>\n<p>We did not comply to this approach in <code>irmin-pack</code>, for at least two reasons:</p>\n<ul>\n<li>Referencing by hash does not allow fast recovery of the children, since\nthere is no way to find the relevant blob directly in the <code>pack</code> by providing\nthe hash. We will go into the details of this later in this post.</li>\n<li>While hashes are being used as simple objects, their size is not negligible.\nThe default hashing function in Irmin is BLAKE2B, which provides 64-byte\ndigests.</li>\n</ul>\n<p>Instead, our internal links in the <code>pack</code> file are concretized by the offsets \u2013\n<code>int64</code> integers \u2013 of the children instead of their hash. Provided that the\ntrees are always written bottom-up (so that children already exist in the <code>pack</code>\nwhen their parents are written), this solves both issues above. The data handled\nby the backend is always immutable, and the file is append-only, ensuring that\nthe links can never be broken.</p>\n<p>Of course, that encoding does not break the content-addressable property: one\ncan always retrieve an arbitrary piece of data through its hash, but it allows\ninternal links to avoid that indirection.</p>\n<h3 id="deduplicating-the-path-names-through-the-dict" style="position:relative;"><a href="#deduplicating-the-path-names-through-the-dict" aria-label="deduplicating the path names through the dict permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deduplicating the path names through the <code>dict</code></h3>\n<p>In fact, the most common operations when using <code>irmin-pack</code> consist of modifying\nthe tree\'s leaves rather then its shape. This is similar to the way most of us\nuse Git: modifying the contents of files is very frequent, while renaming or\nadding new files is rather rare. Even still, when writing a <code>node</code> in a new\ncommit, that node must contain the path names of its children, which end up\nbeing duplicated a large number of times.</p>\n<p>The <code>dict</code> is used for deduplication of path names so that the <code>pack</code> file can\nuniquely reference them using shorter identifiers. It is composed of an\nin-memory bidirectional hash table, allowing to query from path to identifier\nwhen serializing and referencing, and from identifier to path when deserializing\nand dereferencing.</p>\n<p>To ensure persistence of the data across multiple runs and in case of crashes,\nthe small size of the <code>dict</code> \u2013 less than <code>15 Mb</code> in the Tezos use-case \u2013 allows\nus to write the bindings to a write-only, append-only file that is fully read\nand loaded on start-up.</p>\n<p>We guarantee that the <code>dict</code> memory usage is bounded by providing a <code>capacity</code>\nparameter. Adding a binding is guarded by this capacity, and will be inlined in\nthe <code>pack</code> file in case this limit has been reached. This scenario does not\nhappen during normal use of <code>irmin-pack</code>, but prevents attacks that would make\nthe memory grow in an unbounded way.</p>\n<p><span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/cec17f425cdf458a385babbac24c0c04/f7171/dict.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 46.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMACSfAAAknwAFlKNyIAAABxUlEQVQoz22RWXPaMBSF/f//T2danhoIBcJmNhunIbFZDQEbu94Xvl4b+pRq5o6ONNK5n44U0zDIfJ80Doiy8Gul4X/3syymyFOKIqUsslrnWYLitJ5IBwM28y4TW2W+n6BuB8xknu3VWs8PU6b7ca0XD312dFL/ndB943rSib0VeWiibL5/Y9dosOg0aBnPjKwhbaPJL6Nd66b+k+5rF3Wj0tQq3WFoDbi4c1wxX+ktPuTscT2EVAy9Tpt0NGKr9Zja0n03YrIb1lQVTUVZ6Rfzud5fHjXGQnonNAlqQoPE/xDCNUoeRVSVJRElBW54Ikg8irIgziO82OEaXTgHNk74SSz5OcGRWLKlvFHKuaqKPJMMUxQe43a7sdR1HNfDT1z82MULHVIJvyyK+nIuwQfyedfwysnfkeSx7GX13X9DqRbV+lbmnA86T+OlPHEuz+pjXzSId2ShRRqYkKw5Hne0ZjqT/RBNovjj/ZZmYvqAUngYIs8tozWN3oz++5DuW5fP60KCtsTIvFdhcjiY/OiPeVn1GMvnxIEhTtndozKsCbkbxv6apmqg2Roz6X4n3ErYFllg1YS2vRFCDf00R7dnXwj/AnWTnre1NW7QAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="The `dict`"\n        title="The `dict`"\n        src="/static/cec17f425cdf458a385babbac24c0c04/c5bb3/dict.png"\n        srcset="/static/cec17f425cdf458a385babbac24c0c04/04472/dict.png 170w,\n/static/cec17f425cdf458a385babbac24c0c04/9f933/dict.png 340w,\n/static/cec17f425cdf458a385babbac24c0c04/c5bb3/dict.png 680w,\n/static/cec17f425cdf458a385babbac24c0c04/b12f7/dict.png 1020w,\n/static/cec17f425cdf458a385babbac24c0c04/b5a09/dict.png 1360w,\n/static/cec17f425cdf458a385babbac24c0c04/f7171/dict.png 3456w"\n        sizes="(max-width: 680px) 100vw, 680px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n      />\n  </a>\n    </span></p>\n<h3 id="retrieve-the-data-in-the-pack-by-indexing" style="position:relative;"><a href="#retrieve-the-data-in-the-pack-by-indexing" aria-label="retrieve the data in the pack by indexing permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Retrieve the data in the <code>pack</code> by indexing</h3>\n<p>Since the <code>pack</code> file is append-only, naively reading its data would require a\nlinear search through the whole file for each lookup. Instead, we provide an\nindex that maps hashes of data blocks to their location in the <code>pack</code> file,\nalong with their length. This module allows quick recovery of the values queried\nby hash.</p>\n<p>It provides a simple key-value interface, that actually hides the most complex\npart of <code>irmin-pack</code>.</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> t\n<span class="token keyword">val</span> v <span class="token punctuation">:</span> readonly<span class="token punctuation">:</span>bool <span class="token operator">-></span> path<span class="token punctuation">:</span>string <span class="token operator">-></span> t\n\n<span class="token keyword">val</span> find    <span class="token punctuation">:</span> t <span class="token operator">-></span> <span class="token module variable">Key</span><span class="token punctuation">.</span>t <span class="token operator">-></span> <span class="token module variable">Value</span><span class="token punctuation">.</span>t\n<span class="token keyword">val</span> replace <span class="token punctuation">:</span> t <span class="token operator">-></span> <span class="token module variable">Key</span><span class="token punctuation">.</span>t <span class="token operator">-></span> <span class="token module variable">Value</span><span class="token punctuation">.</span>t <span class="token operator">-></span> unit\n<span class="token comment">(* ... *)</span></code></pre></div>\n<p>It has lead most of our efforts in the development of <code>irmin-pack</code> and is now\navailable as a separate library, wisely named <code>index,</code> that you can checkout on\nGitHub under <a href="https://github.com/mirage/index/">mirage/index</a> and via <code>opam</code> as\nthe <code>index</code> and <code>index-unix</code> packages.</p>\n<p>When <code>index</code> is used inside <code>irmin-pack</code>, the keys are the hashes of the data\nstored in the backend, and the values are the <code>(offset, length)</code> pair that\nindicates the location in the <code>pack</code> file. From now on in this post, we will\nstick to the <code>index</code> abstraction: <code>key</code> and <code>value</code> will refer to the keys and\nvalues as viewed by the <code>index</code>.</p>\n<p>Our index is split into two major parts. The <code>log</code> is relatively small, and most\nimportantly, bounded; it contains the recently-added bindings. The <code>data</code> is\nmuch larger, and contains older bindings.</p>\n<p>The <code>log</code> part consists of a hash table associating keys to values. In order to\nensure concurrent access, and to be able to recover on a crash, we also maintain\na write-only, append-only file with the same contents, such that both always\ncontain exactly the same data at any time.</p>\n<p>When a new key-value binding is added index, the value is simply serialized\nalong with its key and added to the <code>log</code>.</p>\n<p>An obvious caveat of this approach is that the in-memory representation of the\n<code>log</code> (the hashtable) is unbounded. It also grows a lot, as the Tezos node\nstores more that 400 million objects. Our memory constraint obviously does not\nallow such unbounded structures. This is where the <code>data</code> part comes in.</p>\n<p>When the <code>log</code> size reaches a \u2013 customizable \u2013 threshold, its bindings are\nflushed into a <code>data</code> component, that may already contain flushed data from\nformer <code>log</code> overloads. We call this operation a <em>merge</em>.</p>\n<p><span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/7663e5dd55a9fa612393be5ae1952bf5/e9c53/merges.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 28.82352941176471%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAC4jAAAuIwF4pT92AAABNUlEQVQY032PW1OCUBRG+f9/yrIMLwVdHDSVPAcU5CKXlCQMV3toemv6ZtasOfthn28b3sxh4c5YbV3CPCTIArIioiwSilxc5vymbS+0Xy3/xQiuezwvTUwtuAMGgh/aRJ5FqCfE4Yr3Y8XlAnkSMl1b6L2Ll7nilfite//OjEgpvECzTQOSMiEuYvZ5TJruSGRBlqfSrKWqTqjYxfJNHjxTPOReD7j37n6s77q54WgbS42Zbixe4ynz3QuzSBBPw0c2hQZpV5YHFsEM863HWN10TGTR02aC7Y+wvRGP/hjDlp/G+oaR6gvidb9jom4Zrq9YRg5Nc+5OrpoDQenhZwqVuBQfGe2l5fzVUH+ehBpjnS5ZJfMON3kVfrzYOTjbJ4Lcp64bDscj+yynOp74rM9d67/yDeIQult6YeS1AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Merging the index"\n        title="Merging the index"\n        src="/static/7663e5dd55a9fa612393be5ae1952bf5/c5bb3/merges.png"\n        srcset="/static/7663e5dd55a9fa612393be5ae1952bf5/04472/merges.png 170w,\n/static/7663e5dd55a9fa612393be5ae1952bf5/9f933/merges.png 340w,\n/static/7663e5dd55a9fa612393be5ae1952bf5/c5bb3/merges.png 680w,\n/static/7663e5dd55a9fa612393be5ae1952bf5/b12f7/merges.png 1020w,\n/static/7663e5dd55a9fa612393be5ae1952bf5/b5a09/merges.png 1360w,\n/static/7663e5dd55a9fa612393be5ae1952bf5/e9c53/merges.png 7470w"\n        sizes="(max-width: 680px) 100vw, 680px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n      />\n  </a>\n    </span></p>\n<p>The important invariant maintained by the <code>merge</code> operation is that the <code>data</code>\nfile must remain sorted by the hash of the bindings. This will enable a fast\nrecovery of the data.</p>\n<p>During this operation, both the <code>log</code> and the former <code>data</code> are read in sorted\norder \u2013 <code>data</code> is already sorted, and <code>log</code> is small thus easy to sort in\nmemory \u2013 and merged into a <code>merging_data</code> file. This file is atomically renamed\nat the end of the operation to replace the older <code>data</code> while still ensuring\ncorrect concurrent accesses.</p>\n<p>This operation obviously needs to re-write the whole index, so its execution\nis very expensive. For this reason, it is performed by a separate thread in the\nbackground to still allow regular use of the index and be transparent to the\nuser.</p>\n<p>In the meantime, a <code>log_async</code> \u2013 similar to <code>log</code>, with a file and a hash table\n\u2013 is used to hold new bindings and ensure the data being merged and the new data\nare correctly separated. At the end of the merge, the <code>log_async</code> becomes the\nnew <code>log</code> and is cleared to be ready for the next merge.</p>\n<h4 id="recovering-the-data" style="position:relative;"><a href="#recovering-the-data" aria-label="recovering the data permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Recovering the data</h4>\n<p>This design allows us a fast lookup of the data present in the index. Whenever\n<code>find</code> or <code>mem</code> is called, we first look into the <code>log</code>, which is simply a call\nto the corresponding <code>Hashtbl</code> function, since this data is contained in memory.\nIf the data is not found in the <code>log</code>, the <code>data</code> file will be browsed. This\nmeans access to recent values is generally faster, because it does not require\nany access to the disk.</p>\n<p>Searching in the <code>data</code> file is made efficient by the invariant that we kept\nduring the <code>merge</code>: the file is sorted by hash. The search algorithm consists in\nan interpolation search, which is permitted by the even distribution of the\nhashes that we store. The theoretical complexity of the interpolation search is\n<code>O(log (log n))</code>, which is generally better than a binary search, provided that\nthe computation of the interpolant is cheaper than reads, which is the case\nhere.</p>\n<p>This approach allows us to find the data using approximately 5-6 reading steps\nin the file, which is good, but still a source of slowdowns. For this reason, we\nuse a fan-out module on top of the interpolation search, able to tell us the\nexact page in which a given key is located, in constant time, for an additional\nspace cost of <code>~100 Mb</code>. We use this to find the correct page of the disk, then\nrun the interpolation search in that page only. That approach allows us to find\nthe correct value with a single read in the <code>data</code> file.</p>\n<h2 id="conclusion" style="position:relative;"><a href="#conclusion" aria-label="conclusion permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>\n<p>This new backend is now used byt the Tezos nodes in production, and manages to\nreduce the storage size from <code>250 Gb</code> down to <code>25 Gb</code>, with a monthly growth\nrate of <code>2 Gb</code> , achieving a tenfold reduction.</p>\n<p>In the meantime, it provides and single writer, multiple readers access pattern\nthat enables bakers and clients to connect to the same storage while it is operated.</p>\n<p>On the memory side, all our components are memory bounded, and the bound is\ngenerally customizable, the largest source of memory usage being the <code>log</code> part\nof the <code>index</code>. While it can be reduced to fit in <code>1 Gb</code> of memory and run on\nsmall VPS or Raspberry Pi, one can easily set a higher memory limit on a more\npowerful machine, and achieve even better time performance.</p>'},tl:{hd:{title:"Introducing the GraphQL API for Irmin 2.0",slug:"introducing-the-graphql-api-for-irmin-20",description:"With the release of Irmin 2.0.0, we are happy to announce a new package - irmin-graphql, which can be used to serve data from Irmin over\u2026",url:"https://tarides.com/blog/2019-11-27-introducing-the-graphql-api-for-irmin-2-0",date:"2019-11-27T00:00:00-00:00",preview_image:"https://tarides.com/static/774a33033c774c2c0c5b638f61694621/497c6/irmin-graphql.png",body_html:'<p>With the release of Irmin 2.0.0, we are happy to announce a new package - <code>irmin-graphql</code>, which can be used to serve data from Irmin over HTTP. This blog post will give you some examples to help you get started, there is also <a href="https://irmin.org/tutorial/graphql">a section in the <code>irmin-tutorial</code></a> with similar information. To avoid writing the same thing twice, this post will cover the basics of getting started, plus a few interesting ideas for queries.</p>\n<p>Getting the <code>irmin-graphql</code> server running from the command-line is easy:</p>\n<div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">$ irmin graphql --root<span class="token operator">=</span>/tmp/irmin</code></pre></div>\n<p>where <code>/tmp/irmin</code> is the actual path to your repository. This will start the server on <code>localhost:8080</code>, but it\'s possible to customize this using the <code>--address</code> and <code>--port</code> flags.</p>\n<p>The new GraphQL API has been added to address some of the shortcomings that have been identified with the old HTTP API, as well as enable a number of new features and capabilities.</p>\n<h1 id="graphql" style="position:relative;"><a href="#graphql" aria-label="graphql permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GraphQL</h1>\n<p><a href="https://graphql.org/">GraphQL</a> is a query language for exposing data as a graph via an API, typically using HTTP as a transport. The centerpiece of a GraphQL API is the <em>schema</em>, which describes the graph in terms of types and relationships between these types. The schema is accessible by the consumer, and acts as a contract between the API and the consumer, by clearly defining all API operations and fully assigning types to all interactions.</p>\n<p>Viewing Irmin data as a graph turns out to be a natural and useful model. Concepts such as branches and commits fit in nicely, and the stored application data is organized as a tree. Such highly hierarchical data can be challenging to interact with using REST, but is easy to represent and navigate with GraphQL.</p>\n<p><span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 74.11764705882352%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAADTElEQVQ4y5WSaWxMURTHz7TWqtbSqlRQPhAaRYmIICIiIXzkG4nlE59ok0pJ0Yits5XZLaFIELHWniCp0lCtmmn7Zp/hdWbem7d1ZlSn6cx17lCxfelN/jnn3nvu7953/g/grzFVZ4YCnVVVqLdCoc5SUqCz7MrXmLfnakzbMN+Na0sLcI+qSGeB/450Og0+jwt8bgbeOOywoeH6iBF1Rpiitx5BkZKz58lswwVCc7zoKdSqofLRs6za5ndACIFUKvUv0OPqBhfTCazXnSlad+EK5KqN1RO0ZjILYQssl8hEzPPVxoe77jRman7XH8OgPQ5eFwNuBNo/fhhjZ5iiwKtnRftu3lq78vL1ihUXr1Ust106sOrKzcptt+5t7vnQUtzDRwslRcmmMDtqnvYsFGhsAJIUUslyODsSDo50dXeBGOVW2zvaHO9a3jSJXORlUuAfsF2Oxm98pDEpRp8goIHjuBser+d1LyHTKXDn7QcjJ+mt2dhjFSCMQiGRECCZ7IWtm9ZPsBlM47Ewhx0ko6GVwI7qmrzaulMzSAnAgbccfVUOatSA/tBksN6FaRoDTKZGUZMQuBSBulg8eiIW47U+b+cNRYnUCEJwjCj2bMRcjVETCnltSi93UpJ69tBXjdOYj83Umdqnas3PJ+os99GsRwgspa87jYcIy3qIx+0ggsASvIQgpBzjE9wnwYCT+H3ddI3ElIisbmqagYfF4jPnyGJbAylFwxBIiutt2ymwigLCYT8e6iJR/vMQcA7GqzRnv7hJwI9AhCty2Fvf3JQLx+sbRtcZXXkaU0eO2tiuOnnGDkfVy+gn5yF00bd+pYyQgbJ4PLoQYaUDAzEVrhehygcHE7iXLMPaxbzAluAnj21jmMOP3783PG1tNb6wO/QtTqeJ4yKrfpnytU+EVPorYB8z874+KROp+tGswVQiUyvKHAiKnBcKBvYHmO4q56eOY6zHXaXwfI0kimuGDmXJciiLxiH9vEj1+14myrwqrvhVcjwyvz8VX9LW1rwlzAdWKAmuXFK+5MNwhiSFhy6aS3tLDQyFfITjgmk6pwYPG4gC2mP6ZyCIOJkO4kfD6ByBxmECf/QUXzMO416EVGGvK+MJoRLnB6lp3wHVMaPbwiwNvgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Git data model"\n        title="Git data model"\n        src="/static/77be7ca8c9940e693b03660d2d5cee01/c5bb3/git-data-model.png"\n        srcset="/static/77be7ca8c9940e693b03660d2d5cee01/04472/git-data-model.png 170w,\n/static/77be7ca8c9940e693b03660d2d5cee01/9f933/git-data-model.png 340w,\n/static/77be7ca8c9940e693b03660d2d5cee01/c5bb3/git-data-model.png 680w,\n/static/77be7ca8c9940e693b03660d2d5cee01/5a190/git-data-model.png 800w"\n        sizes="(max-width: 680px) 100vw, 680px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n      />\n    </span>\n(image from <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">Pro Git</a>)</p>\n<p>As a consumer of an API, one of the biggest initial challenges is understanding what operations are exposed and how to use them. Conversely, as a developer of an API, keeping documentation up-to-date is challenging and time consuming. Though no substitute for more free-form documentation, a GraphQL schema provides an excellent base line for understanding a GraphQL API that is guaranteed to be accurate and up-to-date. This issue is definitely true of the old Irmin HTTP API, which was hard to approach for newcomers due to lack of documentation.</p>\n<p>Being able to inspect the schema of a GraphQL API enables powerful tooling. A great example of this is <a href="graphiql">GraphiQL</a>, which is a browser-based IDE for GraphQL queries. GraphiQL can serve both as an interactive API explorer and query designer with intelligent autocompletion, formatting and more.</p>\n<p><span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/19632cbb13504bb32d6d6d285ec1f542/82e86/graphiql.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 48.23529411764706%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABe0lEQVQoz3WS6W6DMBCEef9XbP5ECkcAY3xiG5Pprk3SFqkrjbjszzO7NLfbDW3bouu6j4ZhgBCiaGbN8x/xe208rI94HQeUUkhpR4wRzSIVnN/Kw1spJVjnIEYBtSoYawlQxfdyXSEWiWkW8Fvdm3MualazYRAGwOtUrRADASW+7iOk0thChA+hXLU2WJalOI10+O9qGGJcgCHbOSrse12w0cl8ei80Hk8B5zwcxfSURhtDUI09HbT9hbwHcsfxMwNBkEzAFTk5/n46jBTbF/C4KOiV4g4SVpoS8bl6PNoRXt6RNokUFAETmoOayj3L+06wg1SJIVQg6ymojwS0o/oAJxUwjwN2NxYjOfmyv2EYQ991BfLAikMCmW6BVZb6GBDJQAwUN23UKo7P6SgyT4Yhv1WBoQJJEwGNYocrAV0ZznvdtRr8UzH+OJylrpFpQPzst1BSMfNqppmmCX3fl9/Ae3bkytXQJHkzayCHaiaXDwGrT4dnm65OvwHODwhMLGNqDQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="GraphiQL"\n        title="GraphiQL"\n        src="/static/19632cbb13504bb32d6d6d285ec1f542/c5bb3/graphiql.png"\n        srcset="/static/19632cbb13504bb32d6d6d285ec1f542/04472/graphiql.png 170w,\n/static/19632cbb13504bb32d6d6d285ec1f542/9f933/graphiql.png 340w,\n/static/19632cbb13504bb32d6d6d285ec1f542/c5bb3/graphiql.png 680w,\n/static/19632cbb13504bb32d6d6d285ec1f542/b12f7/graphiql.png 1020w,\n/static/19632cbb13504bb32d6d6d285ec1f542/b5a09/graphiql.png 1360w,\n/static/19632cbb13504bb32d6d6d285ec1f542/82e86/graphiql.png 1978w"\n        sizes="(max-width: 680px) 100vw, 680px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n      />\n  </a>\n    </span></p>\n<p>The combination of introspection and a strongly typed schema also allows creating smart clients using code generation. This is already a quite wide-spread idea with <a href="apollo-swift">Apollo for iOS</a>, <a href="apollo-java">Apollo for Android</a> or <a href="graphql_ppx"><code>graphql_ppx</code></a> for OCaml/Reason. Though generic GraphQL client libraries will do a fine job interacting with the Irmin GraphQL API, these highlighted libraries will offer excellent ergonomics and type-safety out of the box.</p>\n<p>One of the problems that GraphQL set out to solve is that of over- and underfetching. When designing REST API response payloads, there is always a tension between including too little data, which will require clients to make more network requests, and including too much data, which wastes resources for both client and server (serialization, network transfer, deserialization, etc).<br/>\nThe existing low-level Irmin HTTP API is a perfect example of this. Fetching the contents of a particular file on the master branch requires at least 4 HTTP requests (fetch the branch, fetch the commit, fetch the tree, fetch the blob), i.e. massive underfetching. By comparison, this is something easily solved with a single request to the new GraphQL API. More generally, the GraphQL API allows you to fetch <em>exactly</em> the data you need in a single request without making one-off endpoints.</p>\n<p>For the curious, here\'s the GraphQL query to fetch the contents of <code>README.md</code> from the branch <code>master</code>:</p>\n<div class="gatsby-highlight" data-language="graphql"><pre class="language-graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token punctuation">{</span>\n  master <span class="token punctuation">{</span>\n    tree <span class="token punctuation">{</span>\n      get<span class="token punctuation">(</span><span class="token attr-name">key</span><span class="token punctuation">:</span> <span class="token string">"README.md"</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>The response will look something like this:</p>\n<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>\n  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"master"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"tree"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token property">"get"</span><span class="token operator">:</span> <span class="token string">"The contents of README.md"</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>The GraphQL API is not limited to only reading data, you can also write data to your Irmin store. Here\'s a simple example that will set the key <code>README.md</code> to <code>"foo"</code>, and return the hash of that commit:</p>\n<div class="gatsby-highlight" data-language="graphql"><pre class="language-graphql"><code class="language-graphql"><span class="token keyword">mutation</span> <span class="token punctuation">{</span>\n  set<span class="token punctuation">(</span><span class="token attr-name">key</span><span class="token punctuation">:</span> <span class="token string">"README.md"</span><span class="token punctuation">,</span> <span class="token attr-name">value</span><span class="token punctuation">:</span> <span class="token string">"foo"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    hash\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>By default, GraphQL allows you to do multiple operations in a single query, so you get bulk operations for free. Here\'s a more complex example that modifies two different branches, <code>branch-a</code> and <code>branch-b</code>, and then merges <code>branch-b</code> into <code>branch-a</code> <em>all in a single query</em>:</p>\n<div class="gatsby-highlight" data-language="graphql"><pre class="language-graphql"><code class="language-graphql"><span class="token keyword">mutation</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">branch_a</span><span class="token punctuation">:</span> set<span class="token punctuation">(</span><span class="token attr-name">branch</span><span class="token punctuation">:</span> <span class="token string">"branch-a"</span><span class="token punctuation">,</span> <span class="token attr-name">key</span><span class="token punctuation">:</span> <span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token attr-name">value</span><span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    hash\n  <span class="token punctuation">}</span>\n\n  <span class="token attr-name">branch_b</span><span class="token punctuation">:</span> set<span class="token punctuation">(</span><span class="token attr-name">branch</span><span class="token punctuation">:</span> <span class="token string">"branch-a"</span><span class="token punctuation">,</span> <span class="token attr-name">key</span><span class="token punctuation">:</span> <span class="token string">"baz"</span><span class="token punctuation">,</span> <span class="token attr-name">value</span><span class="token punctuation">:</span> <span class="token string">"qux"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    hash\n  <span class="token punctuation">}</span>\n\n  merge_with_branch<span class="token punctuation">(</span><span class="token attr-name">branch</span><span class="token punctuation">:</span> <span class="token string">"branch-b"</span><span class="token punctuation">,</span> <span class="token attr-name">from</span><span class="token punctuation">:</span> <span class="token string">"branch-a"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    hash\n    tree <span class="token punctuation">{</span>\n      list_contents_recursively <span class="token punctuation">{</span>\n        key\n        value\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>Here\'s what the response might look like:</p>\n<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>\n  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"branch_a"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"hash"</span><span class="token operator">:</span> <span class="token string">"0a1313ae9dfe1d4339aee946dd76b383e02949b6"</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token property">"branch_b"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"hash"</span><span class="token operator">:</span> <span class="token string">"28855c277671ccc180c81058a28d3254f17d2f7b"</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token property">"merge_with_branch"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"hash"</span><span class="token operator">:</span> <span class="token string">"7b17437a16a858816d2710a94ccaa1b9c3506d1f"</span><span class="token punctuation">,</span>\n      <span class="token property">"tree"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token property">"list_contents_recursively"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n          <span class="token punctuation">{</span>\n            <span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"/foo"</span><span class="token punctuation">,</span>\n            <span class="token property">"value"</span><span class="token operator">:</span> <span class="token string">"bar"</span>\n          <span class="token punctuation">}</span><span class="token punctuation">,</span>\n          <span class="token punctuation">{</span>\n            <span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"/baz"</span><span class="token punctuation">,</span>\n            <span class="token property">"value"</span><span class="token operator">:</span> <span class="token string">"qux"</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">]</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>Overall, the new GraphQL API operates at a much higher level than the old HTTP API, and offers a number of complex operations that were tricky to accomplish before.</p>\n<h1 id="customizable" style="position:relative;"><a href="#customizable" aria-label="customizable permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Customizable</h1>\n<p>With GraphQL, all request and response data is fully described by the schema. Because Irmin allows the user to have custom content types, this leaves the question of what type to assign to such values. By default, the GraphQL API will expose all values as strings, i.e. the serialized version of the data that your application stores. This works quite well when Irmin is used as a simple key-value store, but it can be very inconvenient scheme when storing more complex values. As an example, consider storing contacts (name, email, phone, tags, etc) in your Irmin store, where values have the following type:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* Custom content type: a contact *)</span>\n<span class="token keyword">type</span> contact <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name <span class="token punctuation">:</span> string<span class="token punctuation">;</span>\n  email <span class="token punctuation">:</span> string<span class="token punctuation">;</span>\n  <span class="token comment">(* ... *)</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>Fetching such a value will by default be returned to the client as the JSON encoded representation. Assume we\'re storing a contact under the key <code>john-doe</code>, which we fetch with the following query:</p>\n<div class="gatsby-highlight" data-language="graphql"><pre class="language-graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token punctuation">{</span>\n  master <span class="token punctuation">{</span>\n    tree <span class="token punctuation">{</span>\n      get<span class="token punctuation">(</span><span class="token attr-name">key</span><span class="token punctuation">:</span> <span class="token string">"john-doe"</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>The response would then look something like this:</p>\n<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>\n  <span class="token property">"master"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"tree"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"get"</span><span class="token operator">:</span> <span class="token string">"{\\"name\\":\\"John Doe\\", \\"email\\": \\"john.doe@gmail.com/"</span><span class="token punctuation">,</span> ...<span class="token punctuation">}</span>"\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>The client will have to parse this JSON string and cannot choose to only fetch parts of the value (say, only the email). Optimally we would want the client to get a structured response such as the following:</p>\n<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>\n  <span class="token property">"master"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"tree"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"get"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span>\n        <span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"john.doe@gmail.com"</span><span class="token punctuation">,</span>\n        ...\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>To achieve this, the new GraphQL API allows providing an "output type" and an "input type" for most of the configurable types in your store (<code>contents</code>, <code>key</code>, <code>metadata</code>, <code>hash</code>, <code>branch</code>). The output type specifies how data is presented to the client, while the input type controls how data can be provided by the client. Let\'s take a closer look at specifying a custom output type.</p>\n<p>Essentially you have to construct a value of type <code>(unit, \'a option) Graphql_lwt.Schema.typ</code> (from the <a href="ocaml-graphql-server"><code>graphql-lwt</code></a> package), assuming your content type is <code>\'a</code>. We could construct a GraphQL object type for our example content type <code>contact</code> as follows:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* (unit, contact option) Graphql_lwt.Schema.typ *)</span>\n<span class="token keyword">let</span> contact_schema_typ <span class="token operator">=</span> <span class="token module variable">Graphql_lwt</span><span class="token punctuation">.</span><span class="token module variable">Schema</span><span class="token punctuation">.</span><span class="token punctuation">(</span>obj <span class="token string">"Contact"</span>\n  <span class="token label function">~fields</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">fun</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token punctuation">[</span>\n    field <span class="token string">"name"</span>\n      <span class="token label function">~typ</span><span class="token punctuation">:</span><span class="token punctuation">(</span>non_null string<span class="token punctuation">)</span>\n      <span class="token label function">~args</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span>\n      <span class="token label function">~resolve</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">fun</span> <span class="token punctuation">_</span> contact <span class="token operator">-></span>\n        contact<span class="token punctuation">.</span>name\n      <span class="token punctuation">)</span>\n    <span class="token punctuation">;</span>\n    <span class="token comment">(* ... more fields *)</span>\n  <span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span></code></pre></div>\n<p>To use the custom type, you need to instantiate the functor <code>Irmin_unix.Graphql.Server.Make_ext</code> (assuming you\'re deploying to a Unix target) with an Irmin store (type <code>Irmin.S</code>) and a custom types module (type <code>Irmin_graphql.Server.CUSTOM_TYPES</code>). This requires a bit of plumbing:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* Instantiate the Irmin functor somehow *)</span>\n<span class="token keyword">module</span> S <span class="token punctuation">:</span> <span class="token module variable">Irmin</span><span class="token punctuation">.</span>S <span class="token keyword">with</span> <span class="token keyword">type</span> contents <span class="token operator">=</span> contact <span class="token operator">=</span>\n  <span class="token comment">(* ... *)</span>\n\n<span class="token comment">(* Custom GraphQL presentation module *)</span>\n<span class="token keyword">module</span> <span class="token module variable">Custom_types</span> <span class="token operator">=</span> <span class="token keyword">struct</span>\n  <span class="token comment">(* Construct default GraphQL types *)</span>\n  <span class="token keyword">module</span> <span class="token module variable">Defaults</span> <span class="token operator">=</span> <span class="token module variable">Irmin_graphql</span><span class="token punctuation">.</span><span class="token module variable">Server</span><span class="token punctuation">.</span><span class="token module variable">Default_types</span> <span class="token punctuation">(</span>S<span class="token punctuation">)</span>\n\n  <span class="token comment">(* Use the default types for most things *)</span>\n  <span class="token keyword">module</span> <span class="token module variable">Key</span> <span class="token operator">=</span> <span class="token module variable">Defaults</span><span class="token punctuation">.</span><span class="token module variable">Key</span>\n  <span class="token keyword">module</span> <span class="token module variable">Metadata</span> <span class="token operator">=</span> <span class="token module variable">Defaults</span><span class="token punctuation">.</span><span class="token module variable">Metadata</span>\n  <span class="token keyword">module</span> <span class="token module variable">Hash</span> <span class="token operator">=</span> <span class="token module variable">Defaults</span><span class="token punctuation">.</span><span class="token module variable">Hash</span>\n  <span class="token keyword">module</span> <span class="token module variable">Branch</span> <span class="token operator">=</span> <span class="token module variable">Defaults</span><span class="token punctuation">.</span><span class="token module variable">Branch</span>\n\n  <span class="token comment">(* Use custom output type for contents *)</span>\n  <span class="token keyword">module</span> <span class="token module variable">Contents</span> <span class="token operator">=</span> <span class="token keyword">struct</span>\n    <span class="token keyword">include</span> <span class="token module variable">Defaults</span><span class="token punctuation">.</span><span class="token module variable">Contents</span>\n    <span class="token keyword">let</span> schema_typ <span class="token operator">=</span> contact_schema_typ\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">module</span> <span class="token module variable">Remote</span> <span class="token operator">=</span> <span class="token keyword">struct</span>\n  <span class="token keyword">let</span> remote <span class="token operator">=</span> <span class="token module variable">Some</span> s<span class="token punctuation">.</span>remote\n<span class="token keyword">end</span>\n\n<span class="token keyword">module</span> <span class="token module variable">GQL</span> <span class="token operator">=</span> <span class="token module variable">Irmin_unix</span><span class="token punctuation">.</span><span class="token module variable">Graphql</span><span class="token punctuation">.</span><span class="token module variable">Server</span><span class="token punctuation">.</span><span class="token module variable">Make_ext</span> <span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token module variable">Remote</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token module variable">Custom_types</span><span class="token punctuation">)</span></code></pre></div>\n<p>With this in hand, we can now query specifically for the email of <code>john-doe</code>:</p>\n<div class="gatsby-highlight" data-language="graphql"><pre class="language-graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token punctuation">{</span>\n  master <span class="token punctuation">{</span>\n    tree <span class="token punctuation">{</span>\n      get<span class="token punctuation">(</span><span class="token attr-name">key</span><span class="token punctuation">:</span> <span class="token string">"john-doe"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        email\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>... and get a nicely structured JSON response back:</p>\n<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>\n  <span class="token property">"master"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"tree"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"get"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"john.doe@gmail.com"</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>The custom types is very powerful and opens up for transforming or enriching the data at query time, e.g. geocoding the address of a contact, or checking an on-line status.</p>\n<h1 id="watches" style="position:relative;"><a href="#watches" aria-label="watches permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Watches</h1>\n<p>A core feature of Irmin is the ability to <em>watch</em> for changes to the underlying data store in real-time. <code>irmin-graphql</code> takes advantage of GraphQL subscriptions to expose Irmin watches. Subscriptions are a relative recent addition to the GraphQL spec (<a href="graphql-spec-june-2018">June 2018</a>), which allows clients to <em>subscribe</em> to changes. These changes are pushed to the client over a suitable transport mechanism, e.g. websockets, Server-Sent Events, or a chunked HTTP response, as a regular GraphQL response.</p>\n<p>As an example, the following query watches for all changes and returns the new hash:</p>\n<div class="gatsby-highlight" data-language="graphql"><pre class="language-graphql"><code class="language-graphql"><span class="token keyword">subscription</span> <span class="token punctuation">{</span>\n  watch <span class="token punctuation">{</span>\n    commit <span class="token punctuation">{</span>\n      hash\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>For every change, a message like the following will be sent:</p>\n<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>\n  <span class="token property">"watch"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"commit"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"hash"</span><span class="token operator">:</span> <span class="token string">"c01a59bacc16d89e9cdd344a969f494bb2698d8f"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>Under the hood, subscriptions in <code>irmin-graphql</code> are implemented using Irmin watches, but this is opaque to the client -- this will work with any GraphQL spec compliant client!</p>\n<p>Here\'s a video, which hows how the GraphQL response changes live as the Irmin store is being manipulated:</p>\n<p><video controls width=680><source src="/blog/2019-11-27-introducing-irmin-graphql/irmin-subscriptions.mp4" type=video/mp4></video></p>\n<p>Note that the current implementation only supports websockets with more transport options coming soon.</p>\n<h1 id="wrap-up" style="position:relative;"><a href="#wrap-up" aria-label="wrap up permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wrap-up</h1>\n<p>Irmin 2.0 ships with a powerful new GraphQL API, that makes it much easier to interact with Irmin over the network. This makes Irmin available for many more languages and contexts, not just applications using OCaml (or Javascript). The new API operates at a much high level than the old API, and offers advanced features such as "bring your own GraphQL types", and watching for changes via GraphQL subscriptions.</p>\n<p>We\'re looking forward to seeing what you\'ll build with it!</p>'},tl:{hd:{title:"Irmin: September 2020 update",slug:"irmin-september-2020-update",description:"This post will survey the latest design decisions and performance improvements\nmade to irmin-pack, the Irmin storage backend used by\nTezos\u2026",url:"https://tarides.com/blog/2020-09-08-irmin-september-2020-update",date:"2020-09-08T00:00:00-00:00",preview_image:"https://tarides.com/static/eb48bbf490e4011a9fa8806a56d4098b/2244e/tree_autumn.jpg",body_html:'<p>This post will survey the latest design decisions and performance improvements\nmade to <code>irmin-pack</code>, the <a href="https://irmin.org/">Irmin</a> storage backend used by\n<a href="https://tezos.gitlab.io/">Tezos</a>. Tezos is an open-source blockchain technology,\nwritten in OCaml, which uses many libraries from the MirageOS ecosystem. For\nmore context on the design of <code>irmin-pack</code> and how it is optimised for the Tezos\nuse-case, you can check out our <a href="https://tarides.com/blog/2020-09-01-introducing-irmin-pack">previous blog post</a>.</p>\n<p>This post showcases the improvements to <code>irmin-pack</code> since its initial\ndeployment on Tezos:</p>\n<ol>\n<li><a href="#faster-read-only-store-instances">Faster read-only store instances</a></li>\n<li><a href="#better-flushing-for-the-read-write-instance">Improved automatic flushing</a></li>\n<li><a href="#faster-serialisation-for-irmintype">Staging generic serialisation operations</a></li>\n<li><a href="#more-control-over-indexmerge">More control over <code>Index.merge</code></a></li>\n<li><a href="#clearing-stores">Clearing stores</a></li>\n</ol>\n<h2 id="faster-read-only-store-instances" style="position:relative;"><a href="#faster-read-only-store-instances" aria-label="faster read only store instances permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Faster read-only store instances</h2>\n<p>The Tezos use-case of Irmin requires both <em>read-only</em> and <em>read-write</em>\nstore handles, with multiple readers and a single writer all accessing the same\nIrmin store concurrently. These store handles are held by different processes\n(with disjoint memory spaces) so the instances must use files on disk to\nsynchronise, ensuring that the readers never miss updates from the writer. The\nwriter instance automatically flushes its internal buffers to disk at regular\nintervals, allowing the readers to regularly pick up <code>replace</code> calls.</p>\n<p>Until recently, each time a reader looked for a value \u2013 be it a commit, a node,\nor a blob \u2013 it first checked if the writer had flushed new contents to disk. This\nensured that the readers always see the latest changes from the writer. However,\nif the writer isn\'t actively modifying the regions being read, the readers make\none unnecessary system call per <code>find</code>. The higher the rate of reads, the more\ntime is lost to these synchronisation points. This is particularly problematic\nin two use-cases:</p>\n<ul>\n<li><strong>Taking snapshots of the store</strong>. Tezos supports <a href="https://tezos.gitlab.io/user/snapshots.html">exporting portable\nsnapshots</a> of the store data. Since this operation only reads\n<em>historic</em> data in the store (traversing backwards from a given block hash),\nit\'s never necessary to synchronise with the writer.</li>\n<li><strong>Bulk writes</strong>. It\'s sometimes necessary for the writer to dump lots of new\ndata to disk at once (for instance, when adding a commit to the history). In\nthese cases, any readers will repeatedly synchronise with the disk even though\nthey don\'t need to do so until the bulk operation is complete. More on this in\nthe coming months!</li>\n</ul>\n<p>To better support these use-cases, we dropped the requirement for readers to\nmaintain strict consistency with the writer instance. Instead, readers can call\nan explicit <code>sync</code> function only when they <em>need</em> to see the latest concurrent\nupdates from the writer instance.</p>\n<p>In our benchmarks, there is a clear speed-up for <code>find</code> operations from readers:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">[RO] Find in random order with implicit syncs\n        Total time: 67.276527\n        Operations per second: 148640.253086\n        Mbytes per second: 6.378948\n        Read amplification in syscalls: 3.919739\n        Read amplification in bytes: 63.943734\n\n[RO] Find in random order with only one call to sync\n        Total time: 40.817458\n        Operations per second: 244993.208543\n        Mbytes per second: 10.513968\n        Read amplification in syscalls: 0.919588\n        Read amplification in bytes: 63.258072</code></pre></div>\n<p>Not only it is faster, we can see also that fewer system calls are used in the\n<code>Read amplification in syscalls</code> column. The benchmarks consists of reading\n10,000,000 entries of 45 bytes each.</p>\n<p>Relevant PRs: <a href="https://github.com/mirage/irmin/pull/1008">irmin #1008</a>,\n<a href="https://github.com/mirage/index/pull/175">index #175</a>,\n<a href="https://github.com/mirage/index/pull/198">index #198</a> and\n<a href="https://github.com/mirage/index/pull/203">index #203</a>.</p>\n<h2 id="better-flushing-for-the-read-write-instance" style="position:relative;"><a href="#better-flushing-for-the-read-write-instance" aria-label="better flushing for the read write instance permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Better flushing for the read-write instance</h2>\n<p>Irmin-pack uses an <a href="https://github.com/mirage/index/">index</a> to speed up <code>find</code>\ncalls: a <code>pack</code> file is used to store pairs of <code>(key, value)</code> and an <code>index</code>\nrecords the address in pack where a <code>key</code> is stored. A read-write instance has\nto write both the <code>index</code> and the <code>pack</code> file, for a read-only instance to find\na value. Moreover, the order in which the data is flushed to disk for the two\nfiles is important: the address for the pair <code>(key, value)</code> cannot be written\nbefore the pair itself. Otherwise the read-only instance can read an address for\na non existing <code>(key, value)</code> pair. But both <code>pack</code> and <code>index</code> have internal\nbuffers that accumulate data, in order to reduce the number of system calls, and\nboth decide arbitrarily when to flush those buffers to disk.</p>\n<p>We introduce a <code>flush_callback</code> argument in <code>index</code>, which registers a callback\nfor whenever the index decides to flush. <code>irmin-pack</code> uses this callback to flush\nits pack file, resolving the issue of the dangling address.</p>\n<p>Relevant PRs: <a href="https://github.com/mirage/index/pull/189">index #189</a>,\n<a href="https://github.com/mirage/index/pull/216">index #216</a>,\n<a href="https://github.com/mirage/irmin/pull/1051">irmin #1051</a>.</p>\n<h2 id="faster-serialisation-for-irmintype" style="position:relative;"><a href="#faster-serialisation-for-irmintype" aria-label="faster serialisation for irmintype permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Faster serialisation for <code>Irmin.Type</code></h2>\n<p>Irmin uses a library of <a href="http://ocamllabs.io/iocamljs/generic_programming.html"><em>generic</em></a> operations: functions\nthat take a runtime representation of a type and derive some operation on that\ntype. These are used in many places to automatically derive encoders and\ndecoders for our types, which are then used to move data to and from disk. For\ninstance:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> decode <span class="token punctuation">:</span> <span class="token type-variable function">\'a</span> t <span class="token operator">-></span> string <span class="token operator">-></span> <span class="token type-variable function">\'a</span>\n<span class="token comment">(** [decode t] is the binary decoder of values represented by [t]. *)</span>\n\n<span class="token comment">(** Read an integer from a binary-encoded file. *)</span>\n<span class="token keyword">let</span> int_of_file <span class="token label function">~path</span> <span class="token operator">=</span> open_in_bin path <span class="token operator">|></span> input_line <span class="token operator">|></span> decode <span class="token module variable">Irmin</span><span class="token punctuation">.</span><span class="token module variable">Type</span><span class="token punctuation">.</span>int32</code></pre></div>\n<p>The generic <code>decode</code> takes a <em>representation</em> of the type <code>int32</code> and uses\nthis to select the right binary decoder. Unfortunately, we pay the cost of this\nruntime specialisation <em>every time</em> we call <code>int_of_file</code>. If we\'re invoking\nthe decoder for a particular type very often \u2013 such as when serialising store\nvalues \u2013 it\'s more efficient to specialise <code>decode</code> once:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(** Specialised binary decoder for integers. *)</span>\n<span class="token keyword">let</span> decode_int32 <span class="token operator">=</span> decode <span class="token module variable">Irmin</span><span class="token punctuation">.</span><span class="token module variable">Type</span><span class="token punctuation">.</span>int32\n\n<span class="token keyword">let</span> int_of_file_fast <span class="token label function">~path</span> <span class="token operator">=</span> open_in_bin path <span class="token operator">|></span> input_line <span class="token operator">|></span> decode_int32 contents</code></pre></div>\n<p>The question then becomes: how can we change <code>decode</code> to encourage it to be\nused in this more-efficient way? We can add a type wrapper \u2013 called <code>staged</code> \u2013\nto prevent the user from passing two arguments to <code>decode</code> at once:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">module</span> <span class="token module variable">Staged</span> <span class="token punctuation">:</span> <span class="token keyword">sig</span>\n  <span class="token keyword">type</span> <span class="token operator">+</span><span class="token type-variable function">\'a</span> t\n  <span class="token keyword">val</span>   stage <span class="token punctuation">:</span> <span class="token type-variable function">\'a</span>   <span class="token operator">-></span> <span class="token type-variable function">\'a</span> t\n  <span class="token keyword">val</span> unstage <span class="token punctuation">:</span> <span class="token type-variable function">\'a</span> t <span class="token operator">-></span> <span class="token type-variable function">\'a</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">val</span> decode <span class="token punctuation">:</span> <span class="token type-variable function">\'a</span> t <span class="token operator">-></span> <span class="token punctuation">(</span>string <span class="token operator">-></span> <span class="token type-variable function">\'a</span><span class="token punctuation">)</span> <span class="token module variable">Staged</span><span class="token punctuation">.</span>t\n<span class="token comment">(** [decode t] needs to be explicitly unstaged before being used. *)</span></code></pre></div>\n<p>By forcing the user to add a <code>Staged.unstage</code> type coercion when using this\nfunction, we\'re encouraging them to hoist such operations out of their\nhot-loops:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(** The slow implementation no longer type-checks: *)</span>\n\n<span class="token keyword">let</span> int_of_file <span class="token label function">~path</span> <span class="token operator">=</span> open_in_bin path <span class="token operator">|></span> input_line <span class="token operator">|></span> decode <span class="token module variable">Irmin</span><span class="token punctuation">.</span><span class="token module variable">Type</span><span class="token punctuation">.</span>int32\n<span class="token comment">(* Error: This expression has type (string -> \'a) Staged.t\n *        but an expression was expected of type string -> \'a *)</span>\n\n<span class="token comment">(* Instead, we know to pull [Staged.t] values out of hot-loops: *)</span>\n\n<span class="token keyword">let</span> decode_int32 <span class="token operator">=</span> <span class="token module variable">Staged</span><span class="token punctuation">.</span>unstage <span class="token punctuation">(</span>decode <span class="token module variable">Irmin</span><span class="token punctuation">.</span><span class="token module variable">Type</span><span class="token punctuation">.</span>int32<span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> int_of_file_fast <span class="token label function">~path</span> <span class="token operator">=</span> open_in_bin path <span class="token operator">|></span> input_line <span class="token operator">|></span> decode_int32 contents</code></pre></div>\n<p>We made similar changes to the performance-critical generic functions in\n<a href="https://mirage.github.io/irmin/irmin/Irmin/Type/index.html"><code>Irmin.Type</code></a>, and observed significant performance improvements.\nWe also added benchmarks for serialising various types.</p>\n<div style="text-align: center;">\n  <img src="./staged-type.svg" style="height: 550px; max-width: 100%">\n</div>\n<p>Relevant PRs: <a href="https://github.com/mirage/irmin/pull/1030">irmin #1030</a> and\n<a href="https://github.com/mirage/irmin/pull/1028">irmin #1028</a>.</p>\n<p>There are other interesting factors at play, such as altering <code>decode</code> to\nincrease the efficiency of the specialised decoders; we leave this for a future\nblog post.</p>\n<h2 id="more-control-over-indexmerge" style="position:relative;"><a href="#more-control-over-indexmerge" aria-label="more control over indexmerge permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>More control over <code>Index.merge</code></h2>\n<p>index regularly does a maintenance operation, called <code>merge</code>, to ensure fast\nlook-ups while having a small memory imprint. This operation is concurrent with\nthe most of other functions, it is however not concurrent with itself: a second\nmerge needs to wait for a previous one to finish. When writing big chunks of\ndata very often, <code>merge</code> operations become blocking. To help measuring and\ndetecting a blocking <code>merge</code>, we added in the <code>index</code> API calls to check whether\na merge is ongoing, and to time it.</p>\n<p>We mentioned that <code>merge</code> is concurrent with most of the other function in\n<code>index</code>. One notable exception was <code>close</code>, which had to wait for any ongoing\n<code>merge</code> to finish, before closing the index. Now <code>close</code> interrupts an ongoing\nmerge, but still leaves the index in a clean state.</p>\n<p>Relevant PRs: <a href="https://github.com/mirage/index/pull/185">index #185</a>,\n<a href="https://github.com/mirage/irmin/pull/1049">irmin #1049</a> and\n<a href="https://github.com/mirage/index/pull/215">index #215</a>.</p>\n<h2 id="clearing-stores" style="position:relative;"><a href="#clearing-stores" aria-label="clearing stores permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Clearing stores</h2>\n<p>Another feature we recently added is the possibility to <code>clear</code> the store. It is\nimplemented by removing the old files on disk and opening fresh ones. However\nin <code>irmin-pack</code>, the read-only instance has to detect that a clear occurred. To\ndo this, we add a <code>generation</code> in the header of the files used by an\n<code>irmin-pack</code> store, which is increased by the clear operation. A generation\nchange signals to the read-only instance that it needs to close the file and\nopen it again, to be able to read the latest values.</p>\n<p>As the header of the files on disk changed with the addition of the clear\noperation, the <code>irmin-pack</code> stores created previous to this change are no longer\nsupported. We added a migration function for stores created with the previous\nversion (version 1) to the new version (version 2) of the store. You can call\nthis migration function as follows:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"> <span class="token keyword">let</span> open_store <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n    <span class="token module variable">Store</span><span class="token punctuation">.</span><span class="token module variable">Repo</span><span class="token punctuation">.</span>v config\n  <span class="token keyword">in</span>\n  <span class="token module variable">Lwt</span><span class="token punctuation">.</span>catch open_store <span class="token punctuation">(</span><span class="token keyword">function</span>\n      <span class="token operator">|</span> <span class="token module variable">Irmin_pack</span><span class="token punctuation">.</span><span class="token module variable">Unsupported_version</span> <span class="token variant variable">`V1</span> <span class="token operator">-></span>\n          <span class="token module variable">Logs</span><span class="token punctuation">.</span>app <span class="token punctuation">(</span><span class="token keyword">fun</span> l <span class="token operator">-></span> l <span class="token string">"migrating store to version 2"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>\n          <span class="token module variable">Store</span><span class="token punctuation">.</span>migrate config <span class="token punctuation">;</span>\n          <span class="token module variable">Logs</span><span class="token punctuation">.</span>app <span class="token punctuation">(</span><span class="token keyword">fun</span> l <span class="token operator">-></span> l <span class="token string">"migration ended, opening store"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>\n          open_store <span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token operator">|</span> exn <span class="token operator">-></span>\n          <span class="token module variable">Lwt</span><span class="token punctuation">.</span>fail exn<span class="token punctuation">)</span></code></pre></div>\n<p>Relevant PRs: <a href="https://github.com/mirage/index/pull/211">index #211</a>,\n<a href="https://github.com/mirage/irmin/pull/1047">irmin #1047</a>,\n<a href="https://github.com/mirage/irmin/pull/1070">irmin #1070</a> and\n<a href="https://github.com/mirage/irmin/pull/1071">irmin #1071</a>.</p>\n<h2 id="conclusion" style="position:relative;"><a href="#conclusion" aria-label="conclusion permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>\n<p>We hope you\'ve enjoyed this discussion of our recent work. <a href="https://twitter.com/tarides_">Stay\ntuned</a> for our next Tezos / MirageOS development update! Thanks\nto our commercial customers, users and open-source contributors for making this\nwork possible.</p>'},tl:{hd:{title:"Irmin usability enhancements",slug:"irmin-usability-enhancements",description:"For the next few months I will be working on Irmin, focusing on improving general usability. The goal of this effort is to make Irmin more accessible to potential users and clean up the rough edges for existing users.  One of the biggest problems I see right now is that the documentation is out of sync with the current implementation. I\u2019ve just been getting starting refreshing the documentation and tutorials, however here are a few more projects that @samoht and I have discussed:   Better RPC AP...",url:"https://discuss.ocaml.org/t/irmin-usability-enhancements/2017",date:"2018-05-18T00:00:00-00:00",preview_image:"https://aws1.discourse-cdn.com/standard11/uploads/ocaml/original/2X/d/d4dc9fe40b17e2bcced034f9fe103917b7999275.svg",body_html:'<p>Zach Shipko is working on improving the UI/UX for Irmin.\nHe is looking for <a href="https://discuss.ocaml.org/t/irmin-usability-enhancements/2017">feedback</a>\nto make Irmin more accessible to potential users and clean up the rough edges for existing users.</p>'},tl:{hd:{title:"Irmin v2",slug:"irmin-v2",description:"We are pleased to announce Irmin\n2.0.0, a major release of the\nGit-like distributed branching and storage substrate that underpins\nMirageOS\u2026",url:"https://tarides.com/blog/2019-11-21-irmin-v2",date:"2019-11-21T00:00:00-00:00",preview_image:"https://tarides.com/static/d702f060cc02fbcb7329077e2d71741d/497c6/irmin2.png",body_html:'<p>We are pleased to announce <a href="https://github.com/mirage/irmin/releases">Irmin\n2.0.0</a>, a major release of the\nGit-like distributed branching and storage substrate that underpins\n<a href="https://mirage.io">MirageOS</a>.  We began the release process for all the\ncomponents that make up Irmin <a href="https://tarides.com/blog/2019-05-13-on-the-road-to-irmin-v2">back in May\n2019</a>, and there\nhave been close to 1000 commits since Irmin 1.4.0 released back in June 2018. To\ncelebrate this milestone, we have a new logo and opened a dedicated website:\n<a href="https://irmin.org">irmin.org</a>.</p>\n<p>Our focus this year has been on ensuring the production success of our\nearly adopters -- such as the\n<a href="https://gitlab.com/tezos/tezos/tree/master/src/lib_storage">Tezos</a> blockchain\nand the <a href="https://github.com/moby/datakit">Datakit 9P</a>\nstack -- as well as spawning new research projects into the practical\napplication of distributed and mergeable data stores.  We are also\nvery pleased to welcome several new maintainers into the Mirage\nproject for their contributions to Irmin, namely\n<a href="https://github.com/icristescu">Ioana Cristescu</a>,\n<a href="https://github.com/CraigFe">Craig Ferguson</a>,\n<a href="https://github.com/andreas">Andreas Garnaes</a>,\n<a href="https://github.com/pascutto">Cl\xe9ment Pascutto</a> and\n<a href="https://github.com/zshipko">Zach Shipko</a>.</p>\n<h2 id="new-major-features" style="position:relative;"><a href="#new-major-features" aria-label="new major features permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>New Major Features</h2>\n<h3 id="new-cli" style="position:relative;"><a href="#new-cli" aria-label="new cli permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>New CLI</h3>\n<p>While Irmin is normally used as a library, it is obviously useful to\nbe able to interact with a data store from a shell.  The <code>irmin-unix</code>\nopam package now provides an <code>irmin</code> binary that is configured via a\nYaml file and can perform queries and mutations against a Git store.</p>\n<div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token builtin class-name">echo</span> <span class="token string">"root: ."</span> <span class="token operator">></span> irmin.yml\n$ irmin init\n$ irmin <span class="token builtin class-name">set</span> foo/bar <span class="token string">"testing 123"</span>\n$ irmin get foo/bar</code></pre></div>\n<p>Try <code>irmin --help</code> to see all the commands and options available.</p>\n<h3 id="tezos-and-irmin-pack" style="position:relative;"><a href="#tezos-and-irmin-pack" aria-label="tezos and irmin pack permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tezos and irmin-pack</h3>\n<p>Another big user of Irmin is the <a href="https://tezos.com">Tezos blockchain</a>,\nand we have been optimising the persistent space usage of Irmin as their\nnetwork grows.  Because Tezos doesn\u2019t require full Git format support,\nwe created a hybrid backend that grabs the best bits of Git (e.g. the\npackfile mechanism) and engineered a domain-specific backend tailored\nfor Tezos usage. Crucially, because of the way Irmin is split into\nclean libraries and OCaml modules, we only had to modify a small part\nof the codebase and could also reuse elements of our\n<a href="https://github.com/mirage/ocaml-git">OCaml-git</a> codebase as well.</p>\n<p>The <a href="https://github.com/mirage/irmin/pull/615">irmin-pack backend</a> is available\nfor <a href="https://github.com/mirage/irmin/pull/888">use in the CLI</a> and provides a\nsignificant improvement in disk usage.  There is a corresponding <a href="https://gitlab.com/tezos/tezos/merge_requests/1268">Tezos merge\nrequest</a> using the Irmin\n2.0 code that has been integrated downstream and will become available via\ntheir release process in due course.</p>\n<p>As part of this development process, we also released an efficient multi-level\nindex implementation (imaginatively dubbed\n<a href="https://github.com/mirage/index">index</a> in opam). Our implementation takes an\narbitrary IO implementation and user-supplied content types and supplies a\nstandard key-value interface for persistent storage. Index provides instance\nsharing by default, so each OCaml runtime shares a common singleton instance.</p>\n<h3 id="irmin-graphql-and-browser-irmin" style="position:relative;"><a href="#irmin-graphql-and-browser-irmin" aria-label="irmin graphql and browser irmin permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Irmin-GraphQL and \u201cbrowser Irmin\u201d</h3>\n<p>Another new area of huge interest to us is\n<a href="https://graphql.org">GraphQL</a> in order to provide frontends with a rich\nquery language for Irmin-hosted applications.  Irmin 2.0 includes a\nbuilt-in GraphQL server so you can <a href="https://twitter.com/cuvius/status/1017136581755457539">manipulate your Git repo via\nGraphQL</a>.</p>\n<p>If you are interested in (for example) compiling elements of Irmin to\nJavaScript or wasm, for usage in frontends, then the Irmin 2.0 release\nmakes it significantly easier to support this architecture.  We\u2019ve\nalready seen some exploratory efforts <a href="https://github.com/mirage/irmin/issues/681">report issues</a>\nwhen doing this, and we\u2019ve had it working ourselves in <a href="http://roscidus.com/blog/blog/2015/04/28/cuekeeper-gitting-things-done-in-the-browser/">Irmin 1.0 Cuekeeper</a>\nso we are excited by the potential power of applications built using\nthis model.  If you have ideas/questions, please get in touch on the\n<a href="https://github.com/mirage/irmin/issues">issue tracker</a> with your\nusecase.</p>\n<h3 id="wodan" style="position:relative;"><a href="#wodan" aria-label="wodan permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wodan</h3>\n<p>Irmin\u2019s storage layer is also well abstracted, so backends other than\na Unix filesystem or Git are supported.  Irmin can run in highly\ndiverse and OS-free environments, and so we began engineering the\n<a href="https://github.com/mirage/wodan">Wodan filesystem</a> as a\ndomain-specific filesystem designed for MirageOS, Irmin and modern\nflash drives.  See <a href="https://g2p.github.io/research/wodan.pdf">the OCaml Workshop 2017 abstract on\nit</a> for more design\nrationale.</p>\n<p>As part of the Irmin 2.0 release, Wodan is also being prepared for a\nrelease, and you can find <a href="https://github.com/mirage/wodan/tree/master/src/wodan-irmin">Irmin 2.0\nsupport</a>\nin the source.  If you\u2019d like a standalone block-device based\npersistence environment for Irmin, please try this out.  This is the\npreferred backend for using Irmin storage in a unikernel.</p>\n<h3 id="versioned-caldav" style="position:relative;"><a href="#versioned-caldav" aria-label="versioned caldav permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>\xa0Versioned CalDAV</h3>\n<p>An application pulling all these pieces together is being developed\nby our friends at <a href="https://robur.io/About%20Us/Team">Robur</a>: an Irmin-based\n<a href="https://github.com/roburio/caldav">CalDAV calendaring server</a>\nthat even hosts its DNS server using a versioned Irmin store.  We\'ll\nblog more about this as the components get released and stabilised, but\nthe unikernel enthusiasts among you may want to browse the\n<a href="https://github.com/roburio/unikernels/tree/future">Robur unikernels future branch</a>\nto see how they are deploying them today.</p>\n<p>A huge thank you to all our commercial customers, end users and open-source\ndevelopers who have contributed their time, expertise and\nfinancial support to help us achieve our goal of delivering a modern\nstorage stack in the spirit of Git.  Our next steps for Irmin are to\ncontinue to increase the performance and optimise the storage,\nand to build more end-to-end applications using the application core\non top of MirageOS.</p>'},tl:{hd:{title:"MirageOS, towards a smaller and safer OS",slug:"mirageos-towards-a-smaller-and-safer-os",description:"This presentation by Romain Calascibetta took place at Lambda World C\xe1diz on October 26th, 2018 at the Palacio de Congresos in C\xe1diz, Spain.MirageOS, towards...",url:"https://www.youtube.com/watch?v=urG5BjvjW18",date:"2018-12-06T00:00:00-00:00",preview_image:"https://i.ytimg.com/vi/urG5BjvjW18/maxresdefault.jpg",body_html:"<p>Presentation about MirageOS in Lambda World Cad\xecz on October 26th</p>"},tl:{hd:{title:"Mr. MIME - Parse and generate emails",slug:"mr-mime---parse-and-generate-emails",description:"We're glad to announce the first release of mrmime, a parser and a\ngenerator of emails. This library provides an OCaml way to analyze and\u2026",url:"https://tarides.com/blog/2019-09-25-mr-mime-parse-and-generate-emails",date:"2019-09-25T00:00:00-00:00",preview_image:"https://tarides.com/static/14bcc335478eae1bbad1c2f4cdd244af/2244e/mailboxes2.jpg",body_html:'<p>We\'re glad to announce the first release of <a href="https://github.com/mirage/mrmime.git"><code>mrmime</code></a>, a parser and a\ngenerator of emails. This library provides an <em>OCaml way</em> to analyze and craft\nan email. The eventual goal is to build an entire <em>unikernel-compatible</em> stack\nfor email (such as SMTP or IMAP).</p>\n<p>In this article, we will show what is currently possible with <code>mrmime</code> and\npresent a few of the useful libraries that we developed along the way.</p>\n<h2 id="an-email-parser" style="position:relative;"><a href="#an-email-parser" aria-label="an email parser permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>An email parser</h2>\n<p>Some years ago, Romain gave <a href="https://www.youtube.com/watch?v=kQkRsNEo25k">a talk</a> about what an email really <em>is</em>.\nBehind the human-comprehensible format (or <em>rich-document</em> as we said a\nlong time ago), there are several details of emails which complicate the process of\nanalyzing them (and can be prone to security lapses). These details are mostly described\nby three RFCs:</p>\n<ul>\n<li><a href="https://tools.ietf.org/html/rfc822">RFC822</a></li>\n<li><a href="https://tools.ietf.org/html/rfc2822">RFC2822</a></li>\n<li><a href="https://tools.ietf.org/html/rfc5322">RFC5322</a></li>\n</ul>\n<p>Even though they are cross-compatible, providing full legacy email parsing is an\narchaeological exercise: each RFC retains support for the older design decisions\n(which were not recognized as bad or ugly in 1970 when they were first standardized).</p>\n<p>The latest email-related RFC (RFC5322) tried to fix the issue and provide a better\n<a href="https://tools.ietf.org/html/rfc5234">formal specification</a> of the email format \u2013 but of course, it comes with plenty of\n<em>obsolete</em> rules which need to be implemented. In the standard, you find\nboth the current grammar rule and its obsolete equivalent.</p>\n<h3 id="an-extended-email-parser" style="position:relative;"><a href="#an-extended-email-parser" aria-label="an extended email parser permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>An extended email parser</h3>\n<p>Even if the email format can defined by "only" 3 RFCs, you will\nmiss email internationalization (<a href="https://tools.ietf.org/html/rfc6532">RFC6532</a>), the MIME format\n(<a href="https://tools.ietf.org/html/rfc2045">RFC2045</a>, <a href="https://tools.ietf.org/html/rfc2046">RFC2046</a>, <a href="https://tools.ietf.org/html/rfc2047">RFC2047</a>,\n<a href="https://tools.ietf.org/html/rfc2049">RFC2049</a>), or certain details needed to be interoperable with SMTP\n(<a href="https://tools.ietf.org/html/rfc5321">RFC5321</a>). There are still more RFCs which add extra features\nto the email format such as S/MIME or the Content-Disposition field.</p>\n<p>Given this complexity, we took the most general RFCs and tried to provide an easy way to deal\nwith them. The main difficulty is the <em>multipart</em> parser, which deals with email\nattachments (anyone who has tried to make an HTTP 1.1 parser knows about this).</p>\n<h3 id="a-realistic-email-parser" style="position:relative;"><a href="#a-realistic-email-parser" aria-label="a realistic email parser permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A realistic email parser</h3>\n<p>Respecting the rules described by RFCs is not enough to be able to analyze any\nemail from the real world: existing email generators can, and do, produce\n<em>non-compliant</em> email. We stress-tested <code>mrmime</code> by feeding it a batch of 2\nbillion emails taken from the wild, to see if it could parse everything (even if\nit does not produce the expected result). Whenever we noticed a recurring\nformatting mistake, we updated the details of the <a href="https://tools.ietf.org/html/rfc5234">ABNF</a> to enable\n<code>mrmime</code> to parse it anyway.</p>\n<h3 id="a-parser-usable-by-others" style="position:relative;"><a href="#a-parser-usable-by-others" aria-label="a parser usable by others permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A parser usable by others</h3>\n<p>One demonstration of the usability of <code>mrmime</code> is <a href="https://github.com/dinosaure/ocaml-dkim.git"><code>ocaml-dkim</code></a>, which wants to\nextract a specific field from your mail and then verify that the hash and signature\nare as expected.</p>\n<p><code>ocaml-dkim</code> is used by the latest implementation of <a href="https://github.com/mirage/ocaml-dns.git"><code>ocaml-dns</code></a> to request\npublic keys in order to verify email.</p>\n<p>The most important question about <code>ocaml-dkim</code> is: is it able to\nverify your email in one pass? Indeed, currently some implementations of DKIM\nneed 2 passes to verify your email (one to extract the DKIM signature, the other\nto digest some fields and bodies). We focused on verifying in a <em>single</em> pass in\norder to provide a unikernel SMTP <em>relay</em> with no need to store your email between\nverification passes.</p>\n<h2 id="an-email-generator" style="position:relative;"><a href="#an-email-generator" aria-label="an email generator permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>An email generator</h2>\n<p>OCaml is a good language for making little DSLs for specialized use-cases. In this\ncase, we took advantage of OCaml to allow the user to easily craft an email from\nnothing.</p>\n<p>The idea is to build an OCaml value describing the desired email header, and\nthen let the Mr. MIME generator transform this into a stream of characters that\ncan be consumed by, for example, an SMTP implementation. The description step\nis quite simple:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token directive important">#require</span> <span class="token string">"mrmime"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token directive important">#require</span> <span class="token string">"ptime.clock.os"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">open</span> <span class="token module variable">Mrmime</span>\n\n<span class="token keyword">let</span> romain_calascibetta <span class="token operator">=</span>\n  <span class="token keyword">let</span> <span class="token keyword">open</span> <span class="token module variable">Mailbox</span> <span class="token keyword">in</span>\n  <span class="token module variable">Local</span><span class="token punctuation">.</span><span class="token punctuation">[</span> w <span class="token string">"romain"</span><span class="token punctuation">;</span> w <span class="token string">"calascibetta"</span> <span class="token punctuation">]</span> <span class="token operator">@</span> <span class="token module variable">Domain</span><span class="token punctuation">.</span><span class="token punctuation">(</span>domain<span class="token punctuation">,</span> <span class="token punctuation">[</span> a <span class="token string">"gmail"</span><span class="token punctuation">;</span> a <span class="token string">"com"</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> john_doe <span class="token operator">=</span>\n  <span class="token keyword">let</span> <span class="token keyword">open</span> <span class="token module variable">Mailbox</span> <span class="token keyword">in</span>\n  <span class="token module variable">Local</span><span class="token punctuation">.</span><span class="token punctuation">[</span> w <span class="token string">"john"</span> <span class="token punctuation">]</span> <span class="token operator">@</span> <span class="token module variable">Domain</span><span class="token punctuation">.</span><span class="token punctuation">(</span>domain<span class="token punctuation">,</span> <span class="token punctuation">[</span> a <span class="token string">"doe"</span><span class="token punctuation">;</span> a <span class="token string">"org"</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token operator">|></span> with_name <span class="token module variable">Phrase</span><span class="token punctuation">.</span><span class="token punctuation">(</span>v <span class="token punctuation">[</span> w <span class="token string">"John"</span><span class="token punctuation">;</span> w <span class="token string">"D."</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> now <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n  <span class="token keyword">let</span> <span class="token keyword">open</span> <span class="token module variable">Date</span> <span class="token keyword">in</span>\n  of_ptime <span class="token label function">~zone</span><span class="token punctuation">:</span><span class="token module variable">Zone</span><span class="token punctuation">.</span><span class="token module variable">GMT</span> <span class="token punctuation">(</span><span class="token module variable">Ptime_clock</span><span class="token punctuation">.</span>now <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> subject <span class="token operator">=</span>\n  <span class="token module variable">Unstructured</span><span class="token punctuation">.</span><span class="token punctuation">[</span> v <span class="token string">"A"</span><span class="token punctuation">;</span> sp <span class="token number">1</span><span class="token punctuation">;</span> v <span class="token string">"Simple"</span><span class="token punctuation">;</span> sp <span class="token number">1</span><span class="token punctuation">;</span> v <span class="token string">"Mail"</span> <span class="token punctuation">]</span>\n\n<span class="token keyword">let</span> header <span class="token operator">=</span>\n  <span class="token keyword">let</span> <span class="token keyword">open</span> <span class="token module variable">Header</span> <span class="token keyword">in</span>\n  <span class="token module variable">Field</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token module variable">Subject</span> <span class="token operator">$</span> subject<span class="token punctuation">)</span>\n  <span class="token operator">&amp;</span> <span class="token module variable">Field</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token module variable">Sender</span> <span class="token operator">$</span> romain_calascibetta<span class="token punctuation">)</span>\n  <span class="token operator">&amp;</span> <span class="token module variable">Field</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token module variable">To</span> <span class="token operator">$</span> <span class="token module variable">Address</span><span class="token punctuation">.</span><span class="token punctuation">[</span> mailbox john_doe <span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token operator">&amp;</span> <span class="token module variable">Field</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token module variable">Date</span> <span class="token operator">$</span> now <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token operator">&amp;</span> empty\n\n<span class="token keyword">let</span> stream <span class="token operator">=</span> <span class="token module variable">Header</span><span class="token punctuation">.</span>to_stream header\n\n<span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n  <span class="token keyword">let</span> <span class="token keyword">rec</span> go <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n    <span class="token keyword">match</span> stream <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">with</span>\n    <span class="token operator">|</span> <span class="token module variable">Some</span> buf <span class="token operator">-></span> print_string buf<span class="token punctuation">;</span> go <span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token operator">|</span> <span class="token module variable">None</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token keyword">in</span>\n  go <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>\n<p>This code produces the following header:</p>\n<div class="gatsby-highlight" data-language="mail"><pre class="language-mail"><code class="language-mail">Date: 2 Aug 2019 14:10:10 GMT\nTo: John &quot;D.&quot; &lt;john@doe.org&gt;\nSender: romain.calascibetta@gmail.com\nSubject: A Simple Mail</code></pre></div>\n<h3 id="78-character-rule" style="position:relative;"><a href="#78-character-rule" aria-label="78 character rule permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>78-character rule</h3>\n<p>One aspect about email and SMTP is about some historical rules of how to\ngenerate them. One of them is about the limitation of bytes per line. Indeed, a\ngenerator of mail should emit at most 80 bytes per line - and, of course, it\nshould emits entirely the email line per line.</p>\n<p>So <code>mrmime</code> has his own encoder which tries to wrap your mail into this limit.\nIt was mostly inspired by <a href="https://github.com/inhabitedtype/faraday">Faraday</a> and <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html">Format</a> powered with\nGADT to easily describe how to encode/generate parts of an email.</p>\n<h3 id="a-multipart-email-generator" style="position:relative;"><a href="#a-multipart-email-generator" aria-label="a multipart email generator permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A multipart email generator</h3>\n<p>Of course, the main point about email is to be able to generate a multipart\nemail - just to be able to send file attachments. And, of course, a deep work\nwas done about that to make parts, compose them into specific <code>Content-Type</code>\nfields and merge them into one email.</p>\n<p>Eventually, you can easily make a stream from it, which respects rules (78 bytes\nper line, stream line per line) and use it directly into an SMTP implementation.</p>\n<p>This is what we did with the project <a href="https://github.com/dinosaure/facteur"><code>facteur</code></a>. It\'s a little\ncommand-line tool to send with file attachement mails in pure OCaml - but it\nworks only on an UNIX operating system for instance.</p>\n<h2 id="behind-the-forest" style="position:relative;"><a href="#behind-the-forest" aria-label="behind the forest permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Behind the forest</h2>\n<p>Even if you are able to parse and generate an email, more work is needed to get the expected results.</p>\n<p>Indeed, email is a exchange unit between people and the biggest deal on that is\nto find a common way to ensure a understable communication each others. About\nthat, encoding is probably the most important piece and when a French person wants\nto communicate with a <em>latin1</em> encoding, an American person can still use ASCII.</p>\n<h3 id="rosetta" style="position:relative;"><a href="#rosetta" aria-label="rosetta permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rosetta</h3>\n<p>So about this problem, the choice was made to unify any contents to UTF-8 as the\nmost general encoding of the world. So, we did some libraries which map an encoding flow\nto Unicode code-point, and we use <code>uutf</code> (thanks to <a href="https://github.com/dbuenzli">dbuenzli</a>) to normalize it to UTF-8.</p>\n<p>The main goal is to avoid a headache to the user about that and even if\ncontents of the mail is encoded with <em>latin1</em> we ensure to translate it\ncorrectly (and according RFCs) to UTF-8.</p>\n<p>This project is <a href="https://github.com/mirage/rosetta"><code>rosetta</code></a> and it comes with:</p>\n<ul>\n<li><a href="https://github.com/mirage/uuuu"><code>uuuu</code></a> for ISO-8859 encoding</li>\n<li><a href="https://github.com/mirage/coin"><code>coin</code></a> for KOI8-{R,U} encoding</li>\n<li><a href="https://github.com/mirage/yuscii"><code>yuscii</code></a> for UTF-7 encoding</li>\n</ul>\n<h3 id="pecu-and-base64" style="position:relative;"><a href="#pecu-and-base64" aria-label="pecu and base64 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pecu and Base64</h3>\n<p>Then, bodies can be encoded in some ways, 2 precisely (if we took the main\nstandard):</p>\n<ul>\n<li>A base64 encoding, used to store your file</li>\n<li>A quoted-printable encoding</li>\n</ul>\n<p>So, about the <code>base64</code> package, it comes with a sub-package <code>base64.rfc2045</code>\nwhich respects the special case to encode a body according RFC2045 and SMTP\nlimitation.</p>\n<p>Then, <code>pecu</code> was made to encode and decode <em>quoted-printable</em> contents. It was\ntested and fuzzed of course like any others MirageOS\'s libraries.</p>\n<p>These libraries are needed for an other historical reason which is: bytes used\nto store mail should use only 7 bits instead of 8 bits. This is the purpose of\nthe base64 and the <em>quoted-printable</em> encoding which uses only 127 possibilities\nof a byte. Again, this limitation comes with SMTP protocol.</p>\n<h2 id="conclusion" style="position:relative;"><a href="#conclusion" aria-label="conclusion permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>\n<p><code>mrmime</code> is tackling the difficult task to parse and generate emails according to 50 years of usability, several RFCs and legacy rules.\nSo, it\nstill is an experimental project. We reach the first version of it because we\nare currently able to parse many mails and then generate them correctly.</p>\n<p>Of course, a <em>bug</em> (a malformed mail, a server which does not respect standards\nor a bad use of our API) can appear easily where we did not test everything. But\nwe have the feeling it was the time to release it and let people to use\nit.</p>\n<p>The best feedback about <code>mrmime</code> and the best improvement is yours. So don\'t be\nafraid to use it and start to hack your emails with it.</p>'},tl:{hd:{title:"ocaml-git 2.0",slug:"ocaml-git-20",description:"I'm very happy to announce a new major release of ocaml-git (2.0).\nThis release is a 2-year effort to get a revamped\nstreaming API offering\u2026",url:"https://tarides.com/blog/2018-10-19-ocaml-git-2-0",date:"2018-10-19T00:00:00-00:00",preview_image:"https://tarides.com/static/1d805022c72839f1abe63b28f225fd32/2244e/mesh.jpg",body_html:'<p>I\'m very happy to announce a new major release of <code>ocaml-git</code> (2.0).\nThis release is a 2-year effort to get a revamped\nstreaming API offering a full control over memory\nallocation. This new version also adds production-ready implementations of\nthe wire protocol: <code>git push</code> and <code>git pull</code> now work very reliably\nusing the raw Git and smart HTTP protocol (SSH support will come\nsoon). <code>git gc</code> is also implemented, and all of the basic bricks are\nnow available to create Git servers. MirageOS support is available\nout-of-the-box.</p>\n<p>Two years ago, we decided to rewrite <code>ocaml-git</code> and split it into\nstandalone libraries. More details about these new libraries are also\ngiven below.</p>\n<p>But first, let\'s focus on <code>ocaml-git</code>\'s new design. The primary goal was\nto fix memory consumption issues that our users noticed with the previous version,\nand to make <code>git push</code> work reliably. We also took care about\nnot breaking the API too much, to ease the transition for current users.</p>\n<h2 id="controlled-allocations" style="position:relative;"><a href="#controlled-allocations" aria-label="controlled allocations permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Controlled allocations</h2>\n<p>There is a big difference in the way <code>ocaml-git</code> and <code>git</code>\nare designed: <code>git</code> is a short-lived command-line tool which does not\ncare that much about allocation policies, whereas we wanted to build a\nlibrary that can be linked with long-lived Git client and/or server\napplications. We had to make some (performance) compromises to support\nthat use-case, at the benefit of tighter allocation policies \u2014 and hence\nmore predictable memory consumption patterns.\nOther Git libraries such as <a href="https://libgit2.org/">libgit2</a>\nalso have to <a href="https://libgit2.org/security/">deal</a> with similar concerns.</p>\n<p>In order to keep a tight control on the allocated memory, we decided to\nuse <a href="https://github.com/mirage/decompress">decompress</a> instead of\n<code>camlzip</code>. <code>decompress</code> allows the users to provide their own buffer\ninstead of allocating dynamically. This allowed us to keep a better\ncontrol on memory consumption. See below for more details on <code>decompress</code>.</p>\n<p>We also used <a href="https://github.com/inhabitedtype/angstrom">angstrom</a> and\n<a href="https://github.com/mirage/encore">encore</a> to provide a streaming interface\nto encode and decode Git objects. The streaming API is currently hidden\nto the end-user, but it helped us a lot to build abstraction and, again, on\nmanaging the allocation policy of the library.</p>\n<h2 id="complete-pack-file-support-including-gc" style="position:relative;"><a href="#complete-pack-file-support-including-gc" aria-label="complete pack file support including gc permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Complete PACK file support (including GC)</h2>\n<p>In order to find the right abstraction for manipulating pack files in\na long-lived application, we experimented with\n<a href="https://github.com/dinosaure/sirodepac">various</a>\n<a href="https://github.com/dinosaure/carton">prototypes</a>. We haven\'t found the\nright abstractions just yet, but we believe the PACK format could be useful\nto store any kind of data in the future (and not especially Git objects).</p>\n<p>We implemented <code>git gc</code> by following the same heuristics as\n<a href="https://github.com/git/git/blob/master/Documentation/technical/pack-heuristics.txt">Git</a>\nto compress pack files and\nwe produce something similar in size \u2014 <code>decompress</code> has a good ratio about\ncompression \u2014 and we are using <code>duff</code>, our own implementation of <code>xdiff</code>, the\nbinary diff algorithm used by Git (more details on <code>duff</code> below).\nWe also had to re-implement the streaming algorithm to reconstruct <code>idx</code> files on\nthe fly, when receiving pack file on the network.</p>\n<p>One notable feature of our compression algorithms is they work without\nthe assumption that the underlying system implements POSIX: hence,\nthey can work fully in-memory, in a browser using web storage or\ninside a MirageOS unikernel with <a href="https://github.com/mirage/wodan">wodan</a>.</p>\n<h2 id="production-ready-push-and-pull" style="position:relative;"><a href="#production-ready-push-and-pull" aria-label="production ready push and pull permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Production-ready push and pull</h2>\n<p>We re-implemented and abstracted the <a href="https://github.com/git/git/blob/master/Documentation/technical/http-protocol.txt">Git Smart protocol</a>, and used that\nabstraction to make <code>git push</code> and <code>git pull</code> work over HTTP.  By\ndefault we provide a <a href="https://github.com/mirage/cohttp">cohttp</a>\nimplementation but users can use their own \u2014 for instance based on\n<a href="https://github.com/inhabitedtype/httpaf">httpaf</a>.\nAs proof-of-concept, the <a href="https://github.com/mirage/ocaml-git/pull/227">initial\npull-request</a> of <code>ocaml-git</code> 2.0 was\ncreated using this new implementation; moreover, we wrote a\nprototype of a Git client compiled with <code>js_of_ocaml</code>, which was able\nto run <code>git pull</code> over HTTP inside a browser!</p>\n<p>Finally, that implementation will allow MirageOS unikernels to synchronize their\ninternal state with external Git stores (hosted for instance on GitHub)\nusing push/pull mechanisms. We also expect to release a server-side implementation\nof the smart HTTP protocol, so that the state of any unikernel can be inspected\nvia <code>git pull</code>. Stay tuned for more updates on that topic!</p>\n<h2 id="standalone-dependencies" style="position:relative;"><a href="#standalone-dependencies" aria-label="standalone dependencies permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Standalone Dependencies</h2>\n<p>Below you can find the details of the new stable releases of libraries that are\nused by <code>ocaml-git</code> 2.0.</p>\n<h3 id="optint-and-checkseum" style="position:relative;"><a href="#optint-and-checkseum" aria-label="optint and checkseum permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>optint</code> and <code>checkseum</code></h3>\n<p>In some parts of <code>ocaml-git</code>, we need to compute a Circular\nRedundancy Check value. It is 32-bit integer value. <code>optint</code> provides\nan abstraction of it but structurally uses an unboxed integer or a\nboxed <code>int32</code> value depending on target (32 bit or 64 bit architecture).</p>\n<p><code>checkseum</code> relies on <code>optint</code> and provides 3 implementations of CRC:</p>\n<ul>\n<li>Adler32 (used by <code>zlib</code> format)</li>\n<li>CRC32 (used by <code>gzip</code> format and <code>git</code>)</li>\n<li>CRC32-C (used by <code>wodan</code>)</li>\n</ul>\n<p><code>checkseum</code> uses the <em>linking trick</em>: this means that users of the\nlibrary program against an abstract API (only the <code>cmi</code> is provided);\nat link-time, users have to select which implementation to use:\n<code>checkseum.c</code> (the C implementation) or <code>checkseum.ocaml</code> (the OCaml\nimplementation). The process is currently a bit cumbersome but upcoming\n<code>dune</code> release will make that process much more transparent to the users.</p>\n<h3 id="encore-angkor" style="position:relative;"><a href="#encore-angkor" aria-label="encore angkor permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>encore</code> (/<em>angkor</em>/)</h3>\n<p>In <code>git</code>, we work with Git <em>objects</em> (<em>tree</em>, <em>blob</em> or\n<em>commit</em>). These objects are encoded in a specific format. Then,\nthe hash of these objects are computed from the encoded\nresult to get a unique identifier. For example, the hash of your last commit is:\n<code>sha1(encode(commit))</code>.</p>\n<p>A common operation in <code>git</code> is to decode Git objects from an encoded\nrepresentation of them (especially in <code>.git/objects/*</code> as a <em>loose</em>\nfile) and restore them in another part of your Git repository (like in a\nPACK file or on the command-line).</p>\n<p>Hence, we need to ensure that encoding is always deterministic, and\nthat decoding an encoded Git object is always the identity, e.g. there is\nan <em>isomorphism</em> between the decoder and the encoder.</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> decoder <span class="token operator">&lt;.></span> encoder <span class="token punctuation">:</span> <span class="token keyword">value</span> <span class="token operator">-></span> <span class="token keyword">value</span> <span class="token operator">=</span> id\n<span class="token keyword">let</span> encoder <span class="token operator">&lt;.></span> decoder <span class="token punctuation">:</span> string <span class="token operator">-></span> string <span class="token operator">=</span> id</code></pre></div>\n<p><a href="https://github.com/mirage/encore">encore</a> is a library in which you\ncan describe a format (like Git format) and from it, we can derive a\nstreaming decoder <strong>and</strong> encoder that are isomorphic by\nconstruction.</p>\n<h3 id="duff" style="position:relative;"><a href="#duff" aria-label="duff permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>duff</code></h3>\n<p><a href="https://github.com/mirage/duff">duff</a> is a pure implementation in\nOCaml of the <code>xdiff</code> algorithm.\nGit has an optimized representation of your Git repository. It\'s a\nPACK file. This format uses a binary diff algorithm called <code>xdiff</code>\nto compress binary data. <code>xdiff</code> takes a source A and a target B and try\nto find common sub-strings between A and B.</p>\n<p>This is done by a Rabin\'s fingerprint of the source A applied to the\ntarget B. The fingerprint can then be used to produce a lightweight\nrepresentation of B in terms of sub-strings of A.</p>\n<p><code>duff</code> implements this algorithm (with additional Git\'s constraints,\nregarding the size of the sliding windows) in OCaml. It provides a\nsmall binary <code>xduff</code> that complies with the format of Git without the <code>zlib</code>\nlayer.</p>\n<div class="gatsby-highlight" data-language="sh"><pre class="language-sh"><code class="language-sh">$ xduff diff source target &gt; target.xduff\n$ xduff patch source &lt; target.xduff &gt; target.new\n$ diff target target.new\n$ echo $?\n0</code></pre></div>\n<h3 id="decompress" style="position:relative;"><a href="#decompress" aria-label="decompress permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>decompress</code></h3>\n<p><a href="https://github.com/mirage/decompress">decompress</a>\nis a pure implementation in OCaml of <code>zlib</code> and\n<code>rfc1951</code>. You can compress and decompress data flows and, obviously,\nGit does this compression in <em>loose</em> files and PACK files.</p>\n<p>It provides a non-blocking interface and is easily usable in a server\ncontext. Indeed, the implementation never allocates and only relies on\nwhat the user provides (<code>window</code>, input and output buffer). Then, the\ndistribution provides an easy example of how to use <code>decompress</code>:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> inflate<span class="token punctuation">:</span> <span class="token operator">?</span>level<span class="token punctuation">:</span>int <span class="token operator">-></span> string <span class="token operator">-></span> string\n<span class="token keyword">val</span> deflate<span class="token punctuation">:</span> string <span class="token operator">-></span> string</code></pre></div>\n<h3 id="digestif" style="position:relative;"><a href="#digestif" aria-label="digestif permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>digestif</code></h3>\n<p><a href="https://github.com/mirage/digestif">digestif</a> is a toolbox providing\nmany implementations of hash algorithms such as:</p>\n<ul>\n<li>MD5</li>\n<li>SHA1</li>\n<li>SHA224</li>\n<li>SHA256</li>\n<li>SHA384</li>\n<li>SHA512</li>\n<li>BLAKE2B</li>\n<li>BLAKE2S</li>\n<li>RIPEMD160</li>\n</ul>\n<p>Like <code>checkseum</code>, <code>digestif</code> uses the linking trick too: from a\nshared interface, it provides 2 implementations, in C (<code>digestif.c</code>)\nand OCaml (<code>digestif.ocaml</code>).</p>\n<p>Regarding Git, we use the SHA1 implementation and we are ready to\nmigrate <code>ocaml-git</code> to BLAKE2{B,S} as the Git core team expects - and,\nin the OCaml world, it is just a <em>functor</em> application with\nanother implementation.</p>\n<h3 id="eqaf" style="position:relative;"><a href="#eqaf" aria-label="eqaf permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>eqaf</code></h3>\n<p>Some applications require that secret values are compared in constant\ntime. Functions like <code>String.equal</code> do not have this property, so we\nhave decided to provide a small package \u2014 <a href="https://github.com/mirage/eqaf">eqaf</a> \u2014\nproviding a <em>constant-time</em> <code>equal</code> function.\n<code>digestif</code> uses it to check equality of hashes \u2014 it also exposes\n<code>unsafe_compare</code> if you don\'t care about timing attacks in your application.</p>\n<p>Of course, the biggest work on this package is not about the\nimplementation of the <code>equal</code> function but a way to check the\nconstant-time assumption on this function. Using this, we did a\n<a href="https://github.com/mirage/eqaf/tree/master/test">benchmark</a> on Linux,\nWindows and Mac to check it.</p>\n<p>An interesting fact is that after various experiments, we replaced the\ninitial implementation in C (extracted from OpenBSD\'s <a href="https://man.openbsd.org/timingsafe_bcmp.3">timingsafe_memcmp</a>) with an OCaml\nimplementation behaving in a much more predictable way on all the\ntested platforms.</p>\n<h2 id="conclusion" style="position:relative;"><a href="#conclusion" aria-label="conclusion permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>\n<p>The upcoming version 2.0 of <a href="https://irmin.org">Irmin</a> is using ocaml-git\nto create small applications that <a href="https://github.com/mirage/irmin/blob/master/examples/push.ml">push and pull their state\nto GitHub</a>.\nWe think that Git offers a very nice model to persist data for distributed\napplications and we hope that more people will use ocaml-git to experiment\nand manipulate application data in Git. Please\n<a href="https://github.com/mirage/ocaml-git/issues">send us</a> your feedback!</p>'},tl:{hd:{title:"OCamlFormat 0.8",slug:"ocamlformat-08",description:"We are proud to announce the release of OCamlFormat 0.8 (available on opam). To ease the transition from the previous 0.7 release here are\u2026",url:"https://tarides.com/blog/2018-10-17-ocamlformat-0-8",date:"2018-10-17T00:00:00-00:00",preview_image:"https://tarides.com/static/9b70dfbba6abba837b47f644a75b33dc/2244e/code_black1.jpg",body_html:'<p>We are proud to announce the release of OCamlFormat 0.8 (available on opam). To ease the transition from the previous 0.7 release here are some highlights of the new features of this release. The <a href="https://github.com/ocaml-ppx/ocamlformat/blob/v0.8/CHANGES.md#08-2018-10-09">full changelog</a> is available on the project repository.</p>\n<h1 id="precedence-of-options" style="position:relative;"><a href="#precedence-of-options" aria-label="precedence of options permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Precedence of options</h1>\n<p>In the previous version you could override command line options with <code>.ocamlformat</code> files configuration. 0.8 fixed this so that the OCamlFormat configuration is first established by reading <code>.ocamlformat</code> and <code>.ocp-indent</code> files:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">margin = 77\nwrap-comments = true</code></pre></div>\n<p>By default, these files in current and all ancestor directories for each input file are used, as well as the global configuration defined in <code>$XDG_CONFIG_HOME/ocamlformat</code>. The global <code>$XDG_CONFIG_HOME/ocamlformat</code> configuration has the lowest priority, then the closer the directory is to the processed file, the higher the priority. In each directory, both <code>.ocamlformat</code> and <code>.ocp-indent</code> files are read, with <code>.ocamlformat</code> files having the higher priority.</p>\n<p>For now <code>ocp-indent</code> options support is very partial and is expected to be extended in the future.</p>\n<p>Then the parameters can be overriden with the <code>OCAMLFORMAT</code> environment variable:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">OCAMLFORMAT=field-space=tight,type-decl=compact</code></pre></div>\n<p>and finally the parameters can be overriden again with the command lines parameters.</p>\n<h1 id="reading-input-from-stdin" style="position:relative;"><a href="#reading-input-from-stdin" aria-label="reading input from stdin permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reading input from stdin</h1>\n<p>It is now possible to read the input from stdin instead of OCaml files. The following command invokes OCamlFormat that reads its input from the pipe:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">echo &quot;let f x = x + 1&quot; | ocamlformat --name a.ml -</code></pre></div>\n<p>The <code>-</code> on the command line indicates that <code>ocamlformat</code> should read from stdin instead of expecting input files. It is then necessary to use the <code>--name</code> option to designate the input (<code>a.ml</code> here).</p>\n<h1 id="preset-profiles" style="position:relative;"><a href="#preset-profiles" aria-label="preset profiles permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preset profiles</h1>\n<p>Preset profiles allow you to have a consistent configuration without needing to tune every option.</p>\n<p>Preset profiles set all options, overriding lower priority configuration. A preset profile can be set using the <code>--profile</code> (or <code>-p</code>) option. You can pass the option <code>--profile=&#x3C;name></code> on the command line or add <code>profile = &#x3C;name></code> in an <code>.ocamlformat</code> configuration file.</p>\n<p>The available profiles are:</p>\n<ul>\n<li><code>default</code> sets each option to its default value</li>\n<li><code>compact</code> sets options for a generally compact code style</li>\n<li><code>sparse</code> sets options for a generally sparse code style</li>\n<li><code>janestreet</code> is the profile used at JaneStreet</li>\n</ul>\n<p>To get a better feel of it, here is the formatting of the <a href="https://github.com/ocaml/ocaml/blob/trunk/typing/env.ml#L227-L234"><code>mk_callback</code></a> function from the OCaml compiler with the <code>compact</code> profile:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">let mk_callback rest name desc = function\n  | None -&gt; nothing\n  | Some f -&gt; (\n      fun () -&gt;\n        match rest with\n        | [] -&gt; f name None\n        | (hidden, _) :: _ -&gt; f name (Some (desc, hidden)) )</code></pre></div>\n<p>then the same function formatted with the <code>sparse</code> profile:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">let mk_callback rest name desc = function\n  | None -&gt;\n      nothing\n  | Some f -&gt;\n      fun () -&gt;\n        ( match rest with\n        | [] -&gt;\n            f name None\n        | (hidden, _) :: _ -&gt;\n            f name (Some (desc, hidden)) )</code></pre></div>\n<h1 id="project-root" style="position:relative;"><a href="#project-root" aria-label="project root permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Project root</h1>\n<p>The project root of an input file is taken to be the nearest ancestor directory that contains a <code>.git</code> or <code>.hg</code> or <code>dune-project</code> file.\nIf the new option <code>--disable-outside-detected-project</code> is set, <code>.ocamlformat</code> configuration files are not read outside of the current project. If no configuration file is found, formatting is disabled.</p>\n<p>A new option, <code>--root</code> allows to specify the root directory for a project. If specified, OCamlFormat only takes into account <code>.ocamlformat</code> configuration files inside the root directory and its subdirectories.</p>\n<h1 id="credits" style="position:relative;"><a href="#credits" aria-label="credits permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Credits</h1>\n<p>This release also contains many other changes and bug fixes that we cannot detail here. Check out the <a href="https://github.com/ocaml-ppx/ocamlformat/blob/v0.8/CHANGES.md#08-2018-10-09">full changelog</a>.</p>\n<p>Special thanks to our maintainers and contributors for this release: David Allsopp, Josh Berdine, Hugo Heuzard, Brandon Kase, Anil Madhavapeddy and Guillaume Petiot.</p>'},tl:{hd:{title:"On the road to Irmin v2",slug:"on-the-road-to-irmin-v2",description:"Over the past few months, we have been heavily engaged in release\nengineering the Irmin 2.0 release,\nwhich covers multiple years of work on\u2026",url:"https://tarides.com/blog/2019-05-13-on-the-road-to-irmin-v2",date:"2019-05-13T00:00:00-00:00",preview_image:"https://tarides.com/static/76876b69b77bdec1f25009b2ef2a6d33/2244e/tree_canopy2.jpg",body_html:'<p>Over the past few months, we have been heavily engaged in release\nengineering the <a href="https://github.com/mirage/irmin/issues/658">Irmin 2.0 release</a>,\nwhich covers multiple years of work on all of its constituent\nelements. We first began Irmin in late 2013 to act as a\n<a href="https://mirage.io/blog/introducing-irmin">Git-like distributed and branchable storage substrate</a>\nthat would let us escape the <a href="https://www.cl.cam.ac.uk/~pes20/SOSP15-paper102-submitted.pdf">perils of POSIX filesystems</a>.</p>\n<p>The Irmin libraries provide snapshotting, branching and merging\noperations over storage and can communicate via Git both on-disk and\nremotely. Irmin today therefore consists of many discrete OCaml\nlibraries that compose together to form a set of <a href="https://blog.acolyer.org/2015/01/14/mergeable-persistent-data-structures/">mergeable data structures</a>\nthat can be used in MirageOS unikernels and normal OCaml daemons such\nas <a href="http://tezos.com">Tezos</a>.</p>\n<p>In this blog post, we wanted to explain some of the release\nengineering ongoing, and to highlight some areas where we could use\nhelp from the community to test out pieces (and hopefully find your\nown uses in your own infrastructure for it).  The overall effort is\ntracked in <a href="https://github.com/mirage/irmin/issues/658">mirage/irmin#658</a>, so\nfeel free to comment on there as well.</p>\n<h3 id="ocaml-git" style="position:relative;"><a href="#ocaml-git" aria-label="ocaml git permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ocaml-git</h3>\n<p>Irmin is parameterised over the exact communication mechanisms it uses\nbetween nodes, both as an on-disk format and also the remoting\nprotocol.  The most important concrete implementation is Git, which\nhas turned into the world\u2019s most popular version control system.  In\norder to seamlessly integrate with Irmin, we embarked on an effort to\nbuild a complete re-implementation of\n<a href="https://github.com/mirage/ocaml-git">Git from scratch in pure OCaml</a>.</p>\n<p>You can read <a href="https://tarides.com/blog/2018-10-19-ocaml-git-2-0.html">details of the git 2.0 release</a>\non this blog, but from a release engineering perspective we have steadily\nbeen fixing corner cases in this implementation.  The development\nocaml-git trees feature <a href="https://github.com/mirage/ocaml-git/pull/348">fixes to https+git</a>,\nfor <a href="https://github.com/mirage/ocaml-git/pull/351">listing remotes</a>, supporting\n<a href="https://github.com/mirage/ocaml-git/pull/341">authenticated URIs</a> and\nmore.</p>\n<p>These fixes are possible because users tried end-to-end usecases that\nfound these corner cases, so we\u2019d really like to see more.  For\nexample, our friends at <a href="https://robur.io">Robur</a> have submitted fixes\nfrom their integration of it into their upcoming <a href="https://github.com/roburio/caldav">CalDAV engine</a>.\nThe Mirage <a href="https://github.com/Engil/Canopy">canopy</a> blog engine can now also\npush/pull reliably from pure MirageOS unikernels between nodes, which\nis a huge step.</p>\n<p>If you get a chance to try ocaml-git in your infrastructure, please\nlet us know how you get along as we prepare a release of the git\nlibraries with all these fixes (which will be used in Irmin 2.0).</p>\n<h3 id="wodan" style="position:relative;"><a href="#wodan" aria-label="wodan permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wodan</h3>\n<p>Irmin\u2019s storage layer is also well abstracted, so backends other than\na Unix filesystem or Git are supported.  Irmin can run in highly\ndiverse and OS-free environments, and so we began engineering the\n<a href="https://github.com/mirage/wodan">Wodan filesystem</a> as a\ndomain-specific filesystem designed for MirageOS, Irmin and modern\nflash drives.  See <a href="https://g2p.github.io/research/wodan.pdf">the OCaml Workshop 2017 abstract on\nit</a> for more design\nrationale)</p>\n<p>As part of the Irmin 2.0 release, Wodan is also being prepared for a\nrelease, and you can find <a href="https://github.com/mirage/wodan/tree/master/src/wodan-irmin">Irmin 2.0\nsupport</a>\nin the source.  If you\u2019d like a standalone block-device based\npersistence environment for Irmin, please try this out.  This is the\npreferred backend for using Irmin storage in a unikernel.</p>\n<h3 id="tezos-and-irmin-pack" style="position:relative;"><a href="#tezos-and-irmin-pack" aria-label="tezos and irmin pack permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tezos and irmin-pack</h3>\n<p>Another big user of Irmin is the <a href="https://tezos.com">Tezos blockchain</a>,\nand we have been optimising the persistent space usage of Irmin as their\nnetwork grows.  Because Tezos doesn\u2019t require full Git format support,\nwe created a hybrid backend that grabs the best bits of Git (e.g. the\npackfile mechanism) and engineered a domain-specific backend tailored\nfor Tezos usage. Crucially, because of the way Irmin is split into\nclean libraries and OCaml modules, we only had to modify a small part\nof the codebase and could also re-use elements of the Git 2.0\nengineering effort we described above.</p>\n<p>The <a href="https://github.com/mirage/irmin/pull/615">irmin-pack backend</a> is\ncurrently being reviewed and integrated ahead of Irmin 2.0 to provide\na significant improvement in disk usage -- more information to come soon.\nThere is a corresponding <a href="https://gitlab.com/samoht/tezos/tree/snapshot-irmin-pack">Tezos branch</a>\nusing the Irmin 2.0 code that will be integrated downstream in Tezos\nonce we complete the Irmin 2.0 tests.</p>\n<h3 id="irmin-graphql-and-browser-irmin" style="position:relative;"><a href="#irmin-graphql-and-browser-irmin" aria-label="irmin graphql and browser irmin permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Irmin-GraphQL and \u201cbrowser Irmin\u201d</h3>\n<p>Another new area of huge interest to us is\n<a href="https://graphql.org">GraphQL</a> in order to provide frontends a rich\nquery language for Irmin hosted applications.  Irmin 2.0 includes a\nbuiltin GraphQL server so you can <a href="https://twitter.com/cuvius/status/1017136581755457539">manipulate your Git repo via\nGraphQL</a>.</p>\n<p>If you are interested in (for example) compiling elements of Irmin to\nJavaScript or wasm, for usage in frontends, then the Irmin 2.0 release\nmakes it significantly easier to support this architecture.  We\u2019ve\nalready seen some exploratory efforts <a href="https://github.com/mirage/irmin/issues/681">report issues</a>\nwhen doing this, and we\u2019ve had it working ourselves in <a href="http://roscidus.com/blog/blog/2015/04/28/cuekeeper-gitting-things-done-in-the-browser/">Irmin 1.0 Cuekeeper</a>\nso we are excited by the potential power of applications built using\nthis model.  If you have ideas/questions, please get in touch on the\n<a href="https://github.com/mirage/irmin/issues">issue tracker</a> with your\nusecase.</p>\n<p>This post is just the precursor to the Irmin 2.0 release, so expect to\nhear more about it in the coming weeks and months.  This is primarily\na call for help from early adopters interested in helping the project\nout.  All of our code is liberally licensed open source, and so this\nis a good time to tie together end-to-end usecases and help ensure we\ndon\u2019t make any decisions in Irmin 2.0 that go counter to some product\nyou\u2019d like to build. That\u2019s only possible with your feedback, so\neither get in touch via the <a href="https://github.com/mirage/irmin/issues">issue tracker</a>, on\n<a href="https://discuss.ocaml.org">discuss.ocaml.org</a> via the <code>mirageos</code> tag,\nor just <a href="mailto:mirageos-devel@lists.xenproject.org">email us</a>.</p>\n<p>A huge thank you to all our commercial customers, end users and open\nsource developers who have contributed their time, expertise and\nfinancial support to help us achieve our goal of delivering a modern\nstorage stack in the spirit of Git. We look forward to getting Irmin\n2.0 into your hands very soon!</p>'},tl:{hd:{title:"Recent and upcoming changes to Merlin",slug:"recent-and-upcoming-changes-to-merlin",description:"Merlin is a language server for the OCaml programming language; that is, a daemon\nthat connects to your favourite text editor and provides\u2026",url:"https://tarides.com/blog/2021-01-26-recent-and-upcoming-changes-to-merlin",date:"2021-01-26T00:00:00-00:00",preview_image:"https://tarides.com/static/1d86af9747be51519d2c89b476b5b306/2244e/camelgicien.jpg",body_html:'<p>Merlin is a language server for the OCaml programming language; that is, a daemon\nthat connects to your favourite text editor and provides the usual services of\nan IDE: instant feedback on warnings and errors, autocompletion, "type of the\ncode under the cursor", "go to definition", etc. As we (Fr\xe9d\xe9ric Bour, Ulysse\nG\xe9rard and I) are about to do a new major release, we thought now would be a\ngood time to talk a bit about some of the changes that are going into this\nrelease.</p>\n<h2 id="project-configuration" style="position:relative;"><a href="#project-configuration" aria-label="project configuration permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Project configuration</h2>\n<p>Since its very first release, merlin has been getting information about the\nproject being worked on through a <code>.merlin</code> file, which used to be written by\nthe user, but is now often generated by build systems.</p>\n<p>This had the advantage of being fairly simple: Merlin would just look in the\ncurrent directory if such a file existed, otherwise it would look in the parent\ndirectories until it found one; and then read it. But there were also some\nsore points: the granularity of the configuration is the directory not the file,\nand this information is duplicated from the build system configuration (be it\ndune, Makefiles, or, back in the days, ocamlbuild).</p>\n<p>After years of thinking about it, we\'ve finally decided to make some light\nchanges to this process. Since version 3.4, when it scans the filesystem Merlin\nis now looking for either a <code>.merlin</code> file or a dune (or dune-project) file. And\nwhen it finds one of those, it starts an external process in the directory where\nthat file lives, and asks that process for the configuration of the ml(i) file\nbeing edited.</p>\n<p>The process in charge of communicating the configuration to Merlin will either\nbe a specific dune subcommand (when a dune file is found), or a dedicated\n<code>.merlin</code> reader program.</p>\n<p>We see several advantages in doing things this way (rather than, for instance,\nchanging the format of <code>.merlin</code> files):</p>\n<ol>\n<li>this change is entirely backward compatible, and indeed the transition has\nalready happened silently; although dune is still emitting <code>.merlin</code> files,\nthis will only stop with dune 2.8.</li>\n<li>externalizing the reading of <code>.merlin</code> files and simply requiring a\n"normalized" version of the config (i.e. with no mention of packages, just of\nflags and paths) allowed us to simplify the internals of Merlin.</li>\n<li>talking to the build system directly not only gets us a much finer grained\nconfiguration (which is important when you build different executables with\ndifferent flags in the same directory, or if you apply different ppxes to\ndifferent files of a library), it opens the door to getting a nicer behavior\nof Merlin in some circumstances. For instance, the build system can (and\ndoes) tell Merlin when the project isn\'t built. Currently we only report that\ninformation to the user when he asks for errors, alongside all the other\n(mostly rubbish) errors. Which is already helpful in itself. But in the\nfuture we can start filtering the other errors to only report those that\nwould remain even after building the project (e.g. parse errors).</li>\n</ol>\n<p>There are however some changes to look out for:</p>\n<ul>\n<li>people who still use <code>.merlin</code> files but do not install Merlin using opam need\nto make sure to also have the <code>dot-merlin-reader</code> binary in their PATH (it is\navailable as an opam package, but is also buildable from Merlin\'s git\nrepository)</li>\n<li>vim and emacs users who could previously load packages interactively (by\ncalling <code>M-x merlin-use</code> or <code>:MerlinUse</code>) cannot do that anymore, since Merlin\nitself stopped linking with findlib. They\'ll have to write a <code>.merlin</code> file.</li>\n</ul>\n<h2 id="dropping-support-for-old-versions-of-ocaml" style="position:relative;"><a href="#dropping-support-for-old-versions-of-ocaml" aria-label="dropping support for old versions of ocaml permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dropping support for old versions of OCaml</h2>\n<p>Until now, every release of Merlin has kept support from OCaml 4.02 to the\nlatest version of OCaml available at the time of that release.</p>\n<p>We have done this by having one version of "<em>the frontend</em>" (i.e. handling of\nbuffer state, project configuration; analyses like <em>jump-to-definition</em>,\n<em>prefix-completion</em>, etc.), but several versions of "<em>the backend</em>" (OCaml\'s\nASTs, parser and typechecker), and choosing at build time which one to use.\nThe reason for doing this instead of having, for instance, one branch of Merlin\nper version of OCaml, is that while the backends are fairly stable once\nreleased, Merlin\'s frontend keeps evolving. Having just one version of it makes\nit easier to add features and fix bugs (patches don\'t need to be duplicated),\nwhilst ensuring that Merlin\'s behavior is consistent across every version of\nOCaml that we support.</p>\n<p>For this to work however, one needs a well defined API between the frontend and\nall the versions of the backend. This implies mapping every versions of OCaml\'s\ninternal ASTs (which receive modifications from one version to the next), to a\nunified one, so as to keep Merlin\'s various features version agnostic. But it\nalso means being resilient to OCaml\'s internal API changes. For instance between\n4.02 and 4.11 there were big refactorings impacting: the way one accesses the\ntyping environment, the way one accesses the "load path" (the part of the file\nsystem the compiler/Merlin is aware of), the way error message are produced, ...</p>\n<p>The rate of changes on the compiler is a lot higher than what it was when we\nfirst started Merlin (7 years ago now!) which doesn\'t just mean that we have to\nspend more and more time on updating the common interface, but also that the\ninterface is getting harder to define. Recently (with the 4.11 release) some of\nthe changes were significant enough that for some parts of the backend we just\ndidn\'t manage to produce a single interface to access old and new versions, so\ninstead we had to start duplicating and specializing parts of the frontend.\nAnd we don\'t expect things to get much better in the near future.</p>\n<p>Furthermore, Merlin\'s backends are patched to be more resilient to parsing and\ntyping errors in the user\'s code. Those patches also need to be evolved at each\nnew release of the compiler.\nThe work required to keep the "unified interface" working was taking time away\nfrom updating our patches properly, and our support of user errors has slowly\nbeen getting worse over the past few years, resulting in less precise type\ninformation when asked, incomplete results when asking for auto-completion, etc.</p>\n<p>Therefore we have decided to stop dragging older versions of OCaml along. We\nplan to switch to a system where we have one branch of Merlin per version of\nOCaml, and each opam release of Merlin will only be buildable with one version\nof OCaml. We will keep maintaining all the relatively recent branches (that is:\n4.02 definitely will not get fixes, but 4.06 is still in the clear). However,\nall the new features will be developed against the latest version of OCaml and\ncherry-picked to older branches if, and only if, there are no merge conflicts\nand they work as expected without changes.</p>\n<p>We hope that this will make it easier for us to update to new versions of OCaml\n(actually, we already know it does, working on adding support for 4.12 was\neasier than for any of the other recent versions), will allow us to clean up\nMerlin\'s codebase (let\'s call that a work in progress), and will free some time\nto work on new features.</p>\n<p>You might wonder what all this changes for you, as a user, in practice. Well, it\ndepends:</p>\n<ul>\n<li>if you install Merlin from opam: nothing, or almost nothing. Everything that\nyou currently do with Merlin will keep working. In the future, perhaps some\nnew feature will appear that won\'t work on all versions. But that day hasn\'t\ncome yet.</li>\n<li>if you install Merlin some other way (manually?): you can\'t just fetch master\nand build it anymore. You have to pick the appropriate branch for your\nversion of OCaml.</li>\n<li>if you\'re reusing Merlin\'s codebase as part of another project and (even\nworse) have patches on it: come and talk to us if you haven\'t done so already!\nWe can try and integrate your patches, so that you only need to worry about\nvendoring the right version(s) for your needs.</li>\n</ul>\n<hr>\n<p>Over the years, Merlin has received bugfixes and improvements from a long list of\npeople, but for the upcoming release Fr\xe9d\xe9ric and I are particularly grateful to\nRudi Grinberg, a long time and regular contributor who also maintains the OCaml\nLSP project, as well as Ulysse G\xe9rard, who joined our team a year ago now. They\nare in particular the main authors of the work to improve the handling of\nprojects\' configuration.</p>\n<p>We hope you\'ll be as excited as us by all these changes!</p>'},tl:{hd:{title:"Release of Base64",slug:"release-of-base64",description:"MirageOS is a library operating system written from the ground up in OCaml.\nIt has an impossible and incredibly huge goal to re-implement\u2026",url:"https://tarides.com/blog/2019-02-08-release-of-base64",date:"2019-02-08T00:00:00-00:00",preview_image:"https://tarides.com/static/50a0344945c9df2a67b60ef32ee43a0f/2244e/mailboxes.jpg",body_html:'<p>MirageOS is a library operating system written from the ground up in OCaml.\nIt has an impossible and incredibly huge goal to re-implement all of the\nworld! Looking back at the work accomplished by the MirageOS team, it appears that\'s\nwhat happened for several years. Re-implementing the entire stack, in particular\nthe lower layers that we often take for granted, requires a great attention to\ndetail. While it may seem reasonably easy to implement a given RFC, a huge\namount of work is often hidden under the surface.</p>\n<p>In this article, we will explain the development process we went through, as we\nupdated a small part of the MirageOS stack: the library <code>ocaml-base64</code>. It\'s a\nsuitable example as the library is small (few hundreds lines of code), but it\nneeds ongoing development to ensure good quality and to be able to trust it for\nhigher level libraries (like <a href="https://github.com/mirage/mrmime">mrmime</a>).</p>\n<p>Updating the library was instigated by a problem I ran into with the existing\nbase64 implementation while working on the e-mail stack. Indeed, we got some\nerrors when we tried to compute an <em>encoded-word</em> according to the <a href="https://www.ietf.org/rfc/rfc2047.txt">RFC\n2047</a>. So after several years of not being touched, we decided to\nupdate <a href="https://github.com/mirage/ocaml-base64"><code>ocaml-base64</code></a>.</p>\n<h1 id="the-critique-of-pure-reason" style="position:relative;"><a href="#the-critique-of-pure-reason" aria-label="the critique of pure reason permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Critique of Pure Reason</h1>\n<h2 id="the-first-problem" style="position:relative;"><a href="#the-first-problem" aria-label="the first problem permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The first problem</h2>\n<p>We started by attempting to use <code>ocaml-base64</code> on some examples extracted from\nactual e-mails, and we quickly ran into cases where the library failed. This\nhighlighted that reality is much more complex than you can imagine from reading\nan RFC. In this situation, what do you do: try to implement a best-effort\nstrategy and continue parsing? Or stick to the letter of the RFC and fail? In\nthe context of e-mails, which has accumulated a lot of baggage over time, you\ncannot get around implementing a best-effort strategy.</p>\n<p>The particular error we were seeing was a <code>Not_found</code> exception when decoding an\n<em>encoded-word</em>. This exception appeared because the implementation relied on\n<code>String.contains</code>, and the input contained a character which was not part of the\nbase64 alphabet.</p>\n<p>This was the first reason why we thought it necessary to rewrite <code>ocaml-base64</code>.\nOf course, we could just catch the exception and continue the initial\ncomputation, but then another reason appeared.</p>\n<h2 id="the-second-problem" style="position:relative;"><a href="#the-second-problem" aria-label="the second problem permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The second problem</h2>\n<p>As <a href="https://github.com/clecat">@clecat</a> and I reviewed RFC 2045, we noticed the\nfollowing requirement:</p>\n<blockquote>\n<p>The encoded output stream must be represented in lines of no more than 76\ncharacters each.</p>\n<p>See RFC 2045, section 6.8</p>\n</blockquote>\n<p>Pretty specific, but general to e-mails, we should never have more than 78\ncharacters per line according to <a href="https://www.ietf.org/rfc/rfc822.txt">RFC 822</a>, nor more than 998 characters\naccording to <a href="https://www.ietf.org/rfc/rfc2822.txt">RFC 2822</a>.</p>\n<p>Having a decoder that abided RFC 2045 more closely, including the requirement\nabove, further spurred us to implement a new decoder.</p>\n<p>As part of the new implementation, we decided to implement tests and fuzzers to\nensure correctness. This also had the benefit, that we could run the fuzzer on\nthe existing codebase. When fuzzing an encoder/decoder pair, an excellent check\nis whether the following isomorphism holds:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> iso0 input <span class="token operator">=</span> <span class="token keyword">assert</span> <span class="token punctuation">(</span>decode <span class="token punctuation">(</span>encode input<span class="token punctuation">)</span> <span class="token operator">=</span> input<span class="token punctuation">)</span>\n<span class="token keyword">let</span> iso1 input <span class="token operator">=</span> <span class="token keyword">assert</span> <span class="token punctuation">(</span>encode <span class="token punctuation">(</span>decode input<span class="token punctuation">)</span> <span class="token operator">=</span> input<span class="token punctuation">)</span></code></pre></div>\n<p>However, at this point <a href="https://github.com/hannesm">@hannesm</a> ran into another error (see\n<a href="https://github.com/mirage/ocaml-base64/issues/20">#20</a>).</p>\n<h2 id="the-third-problem" style="position:relative;"><a href="#the-third-problem" aria-label="the third problem permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The third problem</h2>\n<p>We started to review the <a href="https://github.com/mirleft/ocaml-nocrypto"><code>nocrypto</code></a> implementation of base64, which\nrespects our requirements. We had some concerns about the performance of the\nimplementation though, so we decided to see if we would get a performance\nregression by switching to this implementation.</p>\n<p>A quick benchmark based on random input revealed the opposite, however!\n<code>nocrypto</code>\'s implementation was faster than <code>ocaml-base64</code>:</p>\n<div class="gatsby-highlight" data-language="sh"><pre class="language-sh"><code class="language-sh">ocaml-base64&#39;s implementation on bytes (length: 5000): 466 272.34ns\nnocrypto&#39;s implementation on bytes (length: 5000): 137 406.04ns</code></pre></div>\n<p>Based on all these observations, we thought there was sufficient reason to\nreconsider the <code>ocaml-base64</code> implementation. It\'s also worth mentioning that\nthe last real release (excluding <code>dune</code>/<code>jbuilder</code>/<code>topkg</code> updates) is from Dec.\n24 2014. So, it\'s pretty old code and the OCaml eco-system has improved a lot\nsince 2014.</p>\n<h1 id="implementation--review" style="position:relative;"><a href="#implementation--review" aria-label="implementation  review permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementation &#x26; review</h1>\n<p>We started integrating the <code>nocrypto</code> implementation. Of course, implementing\n<a href="https://www.ietf.org/rfc/rfc4648.txt">RFC 4648</a> is not as easy as just reading examples and trying to do\nsomething which works. The devil is in the detail.</p>\n<p>@hannesm and <a href="https://github.com/cfcs">@cfcs</a> decided to do a big review of expected behavior\naccording to the RFC, and another about implementation and security issues.</p>\n<h2 id="canonicalization" style="position:relative;"><a href="#canonicalization" aria-label="canonicalization permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Canonicalization</h2>\n<p>The biggest problem about RFC 4648 is regarding canonical inputs. Indeed, there\nare cases where two different inputs are associated with the same value:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token module variable">Base64</span><span class="token punctuation">.</span>decode <span class="token string">"Zm9vCg=="</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token operator">-</span> <span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token string">"foo\\n"</span>\n<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token module variable">Base64</span><span class="token punctuation">.</span>decode <span class="token string">"Zm9vCh=="</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token operator">-</span> <span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token string">"foo\\n"</span></code></pre></div>\n<p>This is mostly because the base64 format encodes the input 6 bits at a time. The\nresult is that 4 base64 encoded bytes are equal to 3 decoded bytes (<code>6 * 4 = 8 * 3</code>). Because of this, 2 base64 encoded bytes provide 1 byte plus 4 bits. What do\nwe need to do with these 4 bits? Nothing.</p>\n<p>That\'s why the last character in our example can be something else than <code>g</code>. <code>g</code>\nis the canonical byte to indicate using the 2 bits afterward the 6 bits\ndelivered by <code>C</code> (and make a byte - 8 bits). But <code>h</code> can be used where we just\nneed 2 bits at the end.</p>\n<p>Due to this behavior, the check used for fuzzing changes: from a canonical\ninput, we should check isomorphism.</p>\n<h2 id="invalid-character" style="position:relative;"><a href="#invalid-character" aria-label="invalid character permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Invalid character</h2>\n<p>As mentioned above ("The first problem"), how should invalid characters be\nhandled? This happens when decoding a byte which is not a part of the base64\nalphabet. In the old version, <code>ocaml-base64</code> would simply leak a <code>Not_found</code>\nexception from <code>String.contains</code>.</p>\n<p>The MirageOS team has taken <a href="https://mirage.io/wiki/mirage-3.0-errors">a stance on exceptions</a>, which is\nto "use exceptions for exceptional conditions" - invalid input is hardly one of\nthose. This is to avoid any exception leaks, as it can be really hard to track\nthe origin of an exception in a unikernel. Because of this, several packages\nhave been updated to return a <code>result</code> type instead, and we wanted the new\nimplementation to follow suit.</p>\n<p>On the other hand, exceptions can be useful when considered as a more\nconstrained form of assembly jump. Of course, they break the control flow, but\nfrom a performance point of view, it\'s interesting to use this trick:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">exception</span> <span class="token module variable">Found</span>\n\n<span class="token keyword">let</span> contains str chr <span class="token operator">=</span>\n  <span class="token keyword">let</span> idx <span class="token operator">=</span> ref <span class="token number">0</span> <span class="token keyword">in</span>\n  <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token module variable">String</span><span class="token punctuation">.</span>length str <span class="token keyword">in</span>\n  <span class="token keyword">try</span> <span class="token keyword">while</span> <span class="token operator">!</span>idx <span class="token operator">&lt;</span> len\n      <span class="token keyword">do</span> <span class="token keyword">if</span> <span class="token module variable">String</span><span class="token punctuation">.</span>unsafe_get str <span class="token operator">!</span>idx <span class="token operator">=</span> chr <span class="token keyword">then</span> raise <span class="token module variable">Found</span> <span class="token punctuation">;</span> incr idx <span class="token keyword">done</span> <span class="token punctuation">;</span>\n      <span class="token module variable">None</span>\n  <span class="token keyword">with</span> <span class="token module variable">Found</span> <span class="token operator">-></span> <span class="token module variable">Some</span> <span class="token operator">!</span>idx</code></pre></div>\n<p>This kind of code for example is ~20% faster than <code>String.contains</code>.</p>\n<p>As such, exceptions can be a useful tool for performance optimizations, but we\nneed to be extra careful not to expose them to the users of the library. This\ncode needs to be hidden behind a fancy functional interface. With this in mind,\nwe should assert that our <code>decode</code> function never leaks an exception. We\'ll\ndescribe how we\'ve adressed this problem later.</p>\n<h2 id="special-cases" style="position:relative;"><a href="#special-cases" aria-label="special cases permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Special cases</h2>\n<p>RFC 4648 has some detailed cases and while we would sometimes like to work in a\nperfect world where we will never need to deal with such errors, from our\nexperience, we cannot imagine what the end-user will do to formats, protocols\nand such.</p>\n<p>Even though the RFC has detailed examples, we have to read between lines to know\nspecial cases and how to deal with them.</p>\n<p>@hannesm noticed one of these cases, where padding (<code>=</code> sign at the end of\ninput) is not mandatory:</p>\n<blockquote>\n<p>The pad character "=" is typically percent-encoded when used in an URI [9],\nbut if the data length is known implicitly, this can be avoided by skipping\nthe padding; see section 3.2.</p>\n<p>See RFC 4648, section 5</p>\n</blockquote>\n<p>That mostly means that the following kind of input can be valid:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token module variable">Base64</span><span class="token punctuation">.</span>decode <span class="token label function">~pad</span><span class="token punctuation">:</span><span class="token boolean">false</span> <span class="token string">"Zm9vCg"</span>\n<span class="token operator">-</span> <span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token string">"foo\\n"</span></code></pre></div>\n<p>It\'s only valid in a specific context though: when <em>length is known implicitly</em>.\nOnly the caller of <code>decode</code> can determine whether the length is implicitly known\nsuch that padding can be omitted. To that end, we\'ve added a new optional\nargument <code>?pad</code> to the function <code>Base64.decode</code>.</p>\n<h2 id="allocation-sub-off-and-len" style="position:relative;"><a href="#allocation-sub-off-and-len" aria-label="allocation sub off and len permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Allocation, <code>sub</code>, <code>?off</code> and <code>?len</code></h2>\n<p>Xavier Leroy has described the garbage collector in the following way:</p>\n<blockquote>\n<p>You see, the Caml garbage collector is like a god from ancient mythology:\nmighty, but very irritable. If you mess with it, it\'ll make you suffer in\nsurprising ways.</p>\n</blockquote>\n<p>That\'s probably why my experience with improving the allocation policy of\n(<code>ocaml-git</code>)<a href="https://github.com/mirage/ocaml-git">ocaml-git</a> was quite a nightmare. Allowing the user to control\nallocation is important for efficiency, and we wanted to <code>ocaml-base64</code> to be a\ngood citizen.</p>\n<p>At the beginning, <code>ocaml-base64</code> had a very simple API:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> decode <span class="token punctuation">:</span> string <span class="token operator">-></span> string\n<span class="token keyword">val</span> encode <span class="token punctuation">:</span> string <span class="token operator">-></span> string</code></pre></div>\n<p>This API forces allocations in two ways.</p>\n<p>Firstly, if the caller needs to encode a part of a string, this part needs to be\nextracted, e.g. using <code>String.sub</code>, which will allocate a new string. To avoid\nthis, two new optional arguments have been added to <code>encode</code>: <code>?off</code> and <code>?len</code>,\nwhich specifies the substring to encode. Here\'s an example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* We want to encode the part \'foo\' without prefix or suffix *)</span>\n\n<span class="token comment">(* Old API -- forces allocation *)</span>\n<span class="token module variable">Base64</span><span class="token punctuation">.</span>encode <span class="token punctuation">(</span><span class="token module variable">String</span><span class="token punctuation">.</span>sub <span class="token string">"prefix foo suffix"</span> <span class="token number">7</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token operator">-</span> <span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token string">"Zm9v"</span>\n\n<span class="token comment">(* New API -- avoids allocation *)</span>\n<span class="token module variable">Base64</span><span class="token punctuation">.</span>encode <span class="token label function">~off</span><span class="token punctuation">:</span><span class="token number">7</span> <span class="token label function">~len</span><span class="token punctuation">:</span><span class="token number">3</span> <span class="token string">"prefix foo suffix"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token operator">-</span> <span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token string">"Zm9v"</span></code></pre></div>\n<p>Secondly, a new string is allocated to hold the resulting string. We can\ncalculate a bound on the length of this string in the following manner:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token operator">//</span><span class="token punctuation">)</span> x y <span class="token operator">=</span>\n  <span class="token keyword">if</span> y <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token keyword">then</span> raise <span class="token module variable">Division_by_zero</span> <span class="token punctuation">;</span>\n  <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> y<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span>\n\n<span class="token keyword">let</span> encode input <span class="token operator">=</span>\n  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token module variable">Bytes</span><span class="token punctuation">.</span>create <span class="token punctuation">(</span><span class="token module variable">String</span><span class="token punctuation">.</span>length input <span class="token operator">//</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">in</span>\n  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n\n<span class="token keyword">let</span> decode input <span class="token operator">=</span>\n  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token module variable">Bytes</span><span class="token punctuation">.</span>create <span class="token punctuation">(</span><span class="token module variable">String</span><span class="token punctuation">.</span>length input <span class="token operator">//</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">in</span>\n  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></div>\n<p>Unfortunately we cannot know the exact length of the result prior to computing\nit. This forces a call to <code>String.sub</code> at the end of the computation to return a\nstring of the correct length. This means we have two allocations rather than\none. To avoid the additional allocation, [@avsm][avsm] proposed to provide a new\ntype <code>sub = string * int * int</code>. This lets the user call <code>String.sub</code> if\nrequired (and allocate a new string), or use simply use the returned <code>sub</code> for\n<em>blit</em>ting to another buffer or similar.</p>\n<h1 id="fuzz-everything" style="position:relative;"><a href="#fuzz-everything" aria-label="fuzz everything permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fuzz everything!</h1>\n<p>There\'s a strong trend of fuzzing libraries for MirageOS, which is quite easy\nthanks to the brilliant work by <a href="https://github.com/yomimono">@yomimono</a> and <a href="https://github.com/stedolan">@stedolan</a>!\nThe integrated fuzzing in OCaml builds on <a href="http://lcamtuf.coredump.cx/afl/">American fuzzy lop</a>, which is\nvery smart about discarding paths of execution that have already been tested and\ngenerating unseen inputs which break your assumptions. My first experience with\nfuzzing was with the library <a href="https://github.com/mirage/decompress"><code>decompress</code></a>, and I was impressed by\n<a href="https://github.com/mirage/decompress/pull/34">precise error</a> it found about a name clash.</p>\n<p>Earlier in this article, I listed some properties we wanted to check for\n<code>ocaml-base64</code>:</p>\n<ul>\n<li>The functions <code>encode</code> and <code>decode</code> should be be isomorphic taking\ncanonicalization into account:</li>\n</ul>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> iso0 input <span class="token operator">=</span>\n  <span class="token keyword">match</span> <span class="token module variable">Base64</span><span class="token punctuation">.</span>decode <span class="token label function">~pad</span><span class="token punctuation">:</span><span class="token boolean">false</span> input <span class="token keyword">with</span>\n  <span class="token operator">|</span> <span class="token module variable">Error</span> <span class="token punctuation">_</span> <span class="token operator">-></span> fail <span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token operator">|</span> <span class="token module variable">Ok</span> result0 <span class="token operator">-></span>\n    <span class="token keyword">let</span> result1 <span class="token operator">=</span> <span class="token module variable">Base64</span><span class="token punctuation">.</span>encode_exn result0 <span class="token keyword">in</span>\n    <span class="token keyword">match</span> <span class="token module variable">Base64</span><span class="token punctuation">.</span>decode <span class="token label function">~pad</span><span class="token punctuation">:</span><span class="token boolean">true</span> result1 <span class="token keyword">with</span>\n    <span class="token operator">|</span> <span class="token module variable">Error</span> <span class="token punctuation">_</span> <span class="token operator">-></span> fail <span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token operator">|</span> <span class="token module variable">Ok</span> result2 <span class="token operator">-></span> check_eq result0 result2\n\n<span class="token keyword">let</span> iso1 input <span class="token operator">=</span>\n  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token module variable">Base64</span><span class="token punctuation">.</span>encode_exn input <span class="token keyword">in</span>\n  <span class="token keyword">match</span> <span class="token module variable">Base64</span><span class="token punctuation">.</span>decode <span class="token label function">~pad</span><span class="token punctuation">:</span><span class="token boolean">true</span> result0 <span class="token keyword">with</span>\n  <span class="token operator">|</span> <span class="token module variable">Error</span> <span class="token punctuation">_</span> <span class="token operator">-></span> fail <span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token operator">|</span> <span class="token module variable">Ok</span> result1 <span class="token operator">-></span>\n    <span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token module variable">Base64</span><span class="token punctuation">.</span>encode_exn result1 <span class="token keyword">in</span>\n    check_eq result0 result2</code></pre></div>\n<ul>\n<li>The function <code>decode</code> should <em>never</em> raise an exception, but rather return a\nresult type:</li>\n</ul>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> no_exn input <span class="token operator">=</span>\n  <span class="token keyword">try</span> ignore <span class="token operator">@@</span> <span class="token module variable">Base64</span><span class="token punctuation">.</span>decode input <span class="token keyword">with</span> <span class="token punctuation">_</span> <span class="token operator">-></span> fail <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>\n<ul>\n<li>And finally, we should randomize <code>?off</code> and <code>?len</code> arguments to ensure that we\ndon\'t get an <code>Out_of_bounds</code> exception when accessing input.</li>\n</ul>\n<p>Just because we\'ve applied fuzzing to the new implementation for a long time, it\ndoesn\'t mean that the code is completely infallible. People can use our library\nin an unimaginable way (and it\'s mostly what happens in the real world) and get\nan unknowable error.</p>\n<p>But, with the fuzzer, we\'ve managed to test some properties across a very wide\nrange of input instead of unit testing with random (or not so random) inputs\nfrom our brains. This development process allows <em>fixing the semantics</em> of\nimplementations (even if it\'s <strong>not</strong> a formal definition of semantics), but\nit\'s better than nothing or outdated documentation.</p>\n<h1 id="conclusion" style="position:relative;"><a href="#conclusion" aria-label="conclusion permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h1>\n<p>Based on our recent update to <code>ocaml-base64</code>, this blog post explains our\ndevelopment process as go about rewriting the world to MirageOS, one bit at a\ntime. There\'s an important point to be made though:</p>\n<p><code>ocaml-base64</code> is a small project. Currently, the implementation is about 250\nlines of code. So it\'s a really small project. But as stated in the\nintroduction, we are fortunate enough to push the restart button of the computer\nworld - yes, we want to make a new operating system.</p>\n<p>That\'s a massive task, and we shouldn\'t make it any harder on ourselves than\nnecessary. As such, we need to justify any step, any line of code, and why we\ndecided to spend our time on any change (why we decided to re-implement <code>git</code>\nfor example). So before committing any time to projects, we try to do a deep\nanalysis of the problem, get feedback from others, and find a consensus between\nwhat we already know, what we want and what we should have (in the case of\n<code>ocaml-base64</code>, @hannesm did a look on the PHP implementation and the Go\nimplementation).</p>\n<p>Indeed, this is a hard question which nobody can answer perfectly in isolation.\nSo, the story of this update to <code>ocaml-base64</code> is an invitation for you to enter\nthe arcanas of the computer world through MirageOS :) ! Don\'t be afraid!</p>'},tl:{hd:{title:"Release of OCamlFormat 0.10",slug:"release-of-ocamlformat-010",description:"We are pleased to announce the release of OCamlFormat 0.10 (available on opam). There have been numerous changes since the last release, so\u2026",url:"https://tarides.com/blog/2019-06-27-release-of-ocamlformat-0-10",date:"2019-06-27T00:00:00-00:00",preview_image:"https://tarides.com/static/dd98e4198ca9305bbbd638c382587e5b/2244e/keyboard.jpg",body_html:'<p>We are pleased to announce the release of OCamlFormat 0.10 (available on opam).</p>\n<p>There have been numerous changes since the last release, so here is a comprehensive list of the new features and breaking changes to help the transition from OCamlFormat 0.9.</p>\n<p><code>ocamlformat-0.10</code> now works on the 4.08 AST, although the formatting should not differ greatly from the one of <code>ocamlformat-0.9</code> in this regard.\nPlease note that it is necessary to build <code>ocamlformat</code> with 4.08 to be able to parse new features like <code>let*</code>.</p>\n<p>Upgrading from <code>ocamlformat-0.9</code> requires to install the following dependencies:</p>\n<ul>\n<li>ocaml-migrate-parsetree >= 1.3.1 (upgrade)</li>\n<li>uuseg >= 10.0.0 (new)</li>\n<li>uutf >= 1.0.1 (upgrade)</li>\n</ul>\n<p>This release focuses on preserving the style of the original source and on handling more <code>ocp-indent</code> options.</p>\n<h2 id="style-preservation" style="position:relative;"><a href="#style-preservation" aria-label="style preservation permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Style preservation</h2>\n<h3 id="expression-grouping" style="position:relative;"><a href="#expression-grouping" aria-label="expression grouping permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Expression grouping</h3>\n<p>The new option <code>exp-grouping</code> has been added to preserve the keywords <code>begin</code>/<code>end</code> that are used to delimit expressions instead of parentheses. <code>exp-grouping=parens</code> always uses parentheses to delimit expressions. <code>exp-grouping=preserve</code> preserves the original grouping syntax (parentheses or <code>begin</code>/<code>end</code>).</p>\n<h3 id="horizontal-alignment" style="position:relative;"><a href="#horizontal-alignment" aria-label="horizontal alignment permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Horizontal alignment</h3>\n<p>Horizontal alignment is something that users often use to make pattern-matching or type declarations easier to read, and it is a feature that has been requested many times. Three new options have been added to horizontally align the lines.</p>\n<p><code>align-cases</code> horizontally aligns the match/try cases:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> fooooooooooo <span class="token operator">=</span>\n  <span class="token keyword">match</span> foooooooooooooooooooooooo <span class="token keyword">with</span>\n  <span class="token operator">|</span> <span class="token module variable">Bfooooooooooooooooo</span> <span class="token operator">-></span> foooooooooooo\n  <span class="token operator">|</span> C <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span>      <span class="token operator">-></span> fooooooooooooooooooo\n  <span class="token operator">|</span> <span class="token punctuation">_</span>                   <span class="token operator">-></span> fooooooooooooooooooo</code></pre></div>\n<p><code>align-constructors-decl</code> horizontally aligns type declarations:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> t <span class="token operator">=</span>\n  <span class="token operator">|</span> <span class="token punctuation">(</span> <span class="token punctuation">:</span><span class="token punctuation">:</span> <span class="token punctuation">)</span> <span class="token keyword">of</span> a <span class="token operator">*</span> b\n  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token keyword">of</span> looooooooooooooooooooooooooooooooooooooong_break</code></pre></div>\n<p><code>align-variants-decl</code> horizontally aligns variants type declarations:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> x <span class="token operator">=</span>\n  <span class="token punctuation">[</span> <span class="token variant variable">`Foooooooo</span>      <span class="token keyword">of</span> int\n  <span class="token operator">|</span> <span class="token variant variable">`Fooooooooooooo</span> <span class="token keyword">of</span> int <span class="token punctuation">]</span></code></pre></div>\n<h3 id="preserve-blank-lines-in-sequences" style="position:relative;"><a href="#preserve-blank-lines-in-sequences" aria-label="preserve blank lines in sequences permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preserve blank lines in sequences</h3>\n<p>The new option <code>sequence-blank-line</code> decides whether a blank line is preserved between expressions of a sequence. <code>sequence-blank-line=compact</code> will not keep any blank line between expressions of a sequence, this is still the default behavior. <code>sequence-blank-line=preserve</code> will keep a blank line between two expressions of a sequence if the input contains at least one.</p>\n<p>This option can help preserving the readability of the code in this situation:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> foo x y <span class="token operator">=</span>\n  do_some_setup y <span class="token punctuation">;</span>\n\n  important_function x</code></pre></div>\n<h2 id="supporting-more-ocp-indent-options" style="position:relative;"><a href="#supporting-more-ocp-indent-options" aria-label="supporting more ocp indent options permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Supporting more <code>ocp-indent</code> options</h2>\n<p>The long term goal of <code>ocamlformat</code> is to handle every <code>ocp-indent</code> option, this release got closer to this goal as the following <code>ocp-indent</code> options are now supported by <code>ocamlformat</code>:</p>\n<ul>\n<li>max_indent</li>\n<li>with</li>\n<li>strict_with</li>\n<li>ppx_stritem_ext</li>\n<li>base</li>\n<li>in</li>\n<li>type</li>\n</ul>\n<h3 id="offset-added-to-a-new-line" style="position:relative;"><a href="#offset-added-to-a-new-line" aria-label="offset added to a new line permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Offset added to a new line</h3>\n<p>The new option <code>max-indent</code> sets the maximum offset (number of columns) added to a new line in addition to the offset of the previous line. If this offset is set to 2 columns, then each new line can only be indented by 2 columns more in addition to the previous line, for example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n  fooooo\n  <span class="token operator">|></span> <span class="token module variable">List</span><span class="token punctuation">.</span>iter <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-></span>\n    <span class="token keyword">let</span> x <span class="token operator">=</span> x <span class="token operator">$</span> y <span class="token keyword">in</span>\n    fooooooooooo x<span class="token punctuation">)</span></code></pre></div>\n<p>This option is equivalent to the <code>max_indent</code> option of <code>ocp-indent</code>, and it will be set if <code>max_indent</code> is set in an <code>.ocp-indent</code> configuration file.</p>\n<h3 id="indentation-of-pattern-matching-cases" style="position:relative;"><a href="#indentation-of-pattern-matching-cases" aria-label="indentation of pattern matching cases permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Indentation of pattern matching cases</h3>\n<p>The new options <code>funtion-indent</code> and <code>match-indent</code> respectively decide the indentation of function cases and the indentation of match/try cases.\nThese options are equivalent to the <code>with</code> option of <code>ocp-indent</code>, and they will be set if <code>with</code> is set in an <code>ocp-indent</code> configuration file.\nIf the indentation is set to 4 columns, cases are formatted like this:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> foooooooo <span class="token operator">=</span> <span class="token keyword">function</span>\n    <span class="token operator">|</span> fooooooooooooooooooooooo <span class="token operator">-></span> foooooooooooooooooooooooooo\n\n<span class="token keyword">let</span> foooooooo <span class="token operator">=</span>\n  <span class="token keyword">match</span> fooooooooooooooooooooooo <span class="token keyword">with</span>\n      <span class="token operator">|</span> fooooooooooooooooooooooo <span class="token operator">-></span> foooooooooooooooooooooooooo</code></pre></div>\n<p>The new options <code>function-indent-nested</code> and <code>match-indent-nested</code> respectively decide whether the <code>function-indent</code> and the <code>match-indent</code> parameters should be applied even when in a sub-block. If these options are set to <code>never</code>, it only applies <code>function-indent</code> or <code>match-indent</code> if the function or match block starts a line. If these options are set to <code>always</code>, then the indent parameters are always applied. The <code>auto</code> value applies the indentation parameter when seen fit.</p>\n<p>These options are equivalent to the <code>strict_with</code> option of <code>ocp-indent</code>, and they will be set if <code>strict_with</code> is set in an <code>ocp-indent</code> configuration file.</p>\n<h3 id="indentation-inside-extension-nodes" style="position:relative;"><a href="#indentation-inside-extension-nodes" aria-label="indentation inside extension nodes permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Indentation inside extension nodes</h3>\n<p>The new option <code>extension-indent</code> sets the indentation of items (that are not at structure level) inside extension nodes.\nThe new option <code>stritem-extension-indent</code> sets the indentation of structure items inside extension nodes. This option is equivalent to the <code>ppx_stritem_ext</code> option of <code>ocp-indent</code>, and it will be set if <code>ppx_stritem_ext</code> is set in an <code>.ocp-indent</code> configuration file.</p>\n<p>For example if <code>extension-indent</code> is set to 5 and <code>stritem-extension-indent</code> is set to 3:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> foo <span class="token operator">=</span>\n  <span class="token punctuation">[</span><span class="token operator">%</span>foooooooooo\n       fooooooooooooooooooooooooooo foooooooooooooooooooooooooooooooooo\n         foooooooooooooooooooooooooooo<span class="token punctuation">]</span>\n  <span class="token punctuation">[</span><span class="token operator">@@</span>foooooooooo\n       fooooooooooooooooooooooooooo foooooooooooooooooooooooooooooooooo\n         foooooooooooooooooooooooooooo<span class="token punctuation">]</span>\n\n<span class="token punctuation">[</span><span class="token operator">@@@</span>foooooooooo\n   fooooooooooooooooooooooooooo foooooooooooooooooooooooooooooooooo\n     foooooooooooooooooooooooooooo<span class="token punctuation">]</span></code></pre></div>\n<h3 id="let-binding-indentation" style="position:relative;"><a href="#let-binding-indentation" aria-label="let binding indentation permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Let-binding indentation</h3>\n<p>The new option <code>let-binding-indent</code> sets the indentation of let binding expressions if they do not fit on a single line. This option is equivalent to the <code>base</code> option of <code>ocp-indent</code>.\nThe new option <code>indent-after-in</code> sets the indentation after <code>let ... in</code>, unless followed by another <code>let</code>. This option is equivalent to the <code>in</code> option of <code>ocp-indent</code>.\nThe new option <code>type-decl-indent</code> sets the indentation of type declarations if they do not fit on a single line. This option is equivalent to the <code>type</code> option of <code>ocp-indent</code>.</p>\n<p>These options will be set if their <code>ocp-indent</code> counterparts are set in an <code>.ocp-indent</code> configuration file.</p>\n<h2 id="miscellaneous-features" style="position:relative;"><a href="#miscellaneous-features" aria-label="miscellaneous features permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Miscellaneous features</h2>\n<p>This release also brings some new options, new values for existing features, or corrects erroneous behaviours.</p>\n<h3 id="indicate-multiline-delimiters" style="position:relative;"><a href="#indicate-multiline-delimiters" aria-label="indicate multiline delimiters permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Indicate multiline delimiters</h3>\n<p>The former <code>indicate-multiline-delimiters</code> boolean option is now a 3-valued option:</p>\n<ul>\n<li><code>indicate-multiline-delimiters=space</code> (was equivalent to <code>true</code>) prints a space inside the delimiter to indicate the matching one is on a different line.</li>\n<li><code>indicate-multiline-delimiters=no</code> (was equivalent to <code>false</code>) doesn\'t do anything special to indicate the closing delimiter.</li>\n<li><code>indicate-multiline-delimiters=closing-on-separate-line</code> is the new feature of this option, it makes sure that the closing delimiter is on its own line.</li>\n</ul>\n<p>On this example we can see the closing parenthesis delimiting the nested pattern-matchings are on their own line and are aligned with the matching opening parenthesis:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n   <span class="token keyword">match</span> v <span class="token keyword">with</span>\n   <span class="token operator">|</span> <span class="token module variable">None</span> <span class="token operator">-></span> <span class="token module variable">None</span>\n   <span class="token operator">|</span> <span class="token module variable">Some</span> x <span class="token operator">-></span>\n       <span class="token punctuation">(</span> <span class="token keyword">match</span> x <span class="token keyword">with</span>\n       <span class="token operator">|</span> <span class="token module variable">None</span> <span class="token operator">-></span> <span class="token module variable">None</span>\n       <span class="token operator">|</span> <span class="token module variable">Some</span> x <span class="token operator">-></span>\n           <span class="token punctuation">(</span> <span class="token keyword">match</span> x <span class="token keyword">with</span>\n           <span class="token operator">|</span> <span class="token module variable">None</span> <span class="token operator">-></span> <span class="token module variable">None</span>\n           <span class="token operator">|</span> <span class="token module variable">Some</span> x <span class="token operator">-></span> x\n           <span class="token punctuation">)</span>\n       <span class="token punctuation">)</span></code></pre></div>\n<h3 id="formatting-of-literal-strings" style="position:relative;"><a href="#formatting-of-literal-strings" aria-label="formatting of literal strings permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Formatting of literal strings</h3>\n<p><code>break-string-literals=newlines</code> now takes into account pretty-printing commands like <code>@,</code>, <code>@;</code> and <code>@\\n</code> to produce more readable strings. A new value for this option has been added, <code>break-string-literals=newlines-and-wrap</code>, to break lines at newlines delimiters (including pretty-printing commands) and also wrap the string literals at the margin.</p>\n<p>Here is how <code>break-string-literals=newlines-and-wrap</code> formats a string:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> fooooooooooo <span class="token operator">=</span>\n  "<span class="token module variable">Lorem</span> ipsum dolor sit amet<span class="token punctuation">,</span> consectetur adipiscing elit<span class="token punctuation">,</span> sed <span class="token keyword">do</span> eiusmod \\\n   tempor incididunt ut labore et dolore magna aliqua<span class="token punctuation">.</span><span class="token operator">@</span><span class="token punctuation">;</span>\\\n   <span class="token module variable">Ut</span> enim ad minim veniam<span class="token punctuation">,</span> quis nostrud exercitation ullamco laboris nisi \\\n   ut aliquip ex ea commodo consequat<span class="token punctuation">.</span><span class="token operator">@</span><span class="token punctuation">;</span>\\\n   <span class="token module variable">Duis</span> aute irure dolor <span class="token keyword">in</span> reprehenderit <span class="token keyword">in</span> voluptate velit esse cillum \\\n   dolore eu fugiat nulla pariatur<span class="token punctuation">.</span><span class="token operator">@</span><span class="token punctuation">;</span>\\\n   <span class="token module variable">Excepteur</span> sint occaecat cupidatat non proident<span class="token punctuation">,</span> sunt <span class="token keyword">in</span> culpa qui \\\n   officia deserunt mollit anim id est laborum<span class="token punctuation">.</span>"</code></pre></div>\n<p><strong>Warning:</strong> the <code>break-string-literals</code> will likely be removed in the next release and the default behavior would be <code>newlines-and-wrap</code>.</p>\n<h3 id="break-before-the-in-keyword" style="position:relative;"><a href="#break-before-the-in-keyword" aria-label="break before the in keyword permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Break before the <code>in</code> keyword</h3>\n<p>The new option <code>break-before-in</code> has been added to decide whether the line should break before the <code>in</code> keyword of a <code>let</code> binding. <code>break-before-in=fit-or-vertical</code> will always break the line before the <code>in</code> keyword if the whole <code>let</code> binding does not fit on a single line, it is still the default behavior. <code>break-before-in=auto</code> will only break the line if the <code>in</code> keyword does not fit on the previous line.</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">_</span> <span class="token operator">=</span>\n  <span class="token keyword">let</span> short <span class="token operator">=</span> this is short <span class="token keyword">in</span>\n  <span class="token keyword">let</span> fooo <span class="token operator">=</span>\n    <span class="token punctuation">(</span>this is very long<span class="token punctuation">)</span> but <span class="token punctuation">(</span>the <span class="token keyword">in</span> keyword can fit<span class="token punctuation">)</span> on the same line <span class="token keyword">in</span>\n  foooooo</code></pre></div>\n<h3 id="indentation-of-nested-pattern-matching" style="position:relative;"><a href="#indentation-of-nested-pattern-matching" aria-label="indentation of nested pattern matching permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Indentation of nested pattern-matching</h3>\n<p>The new option <code>nested-match</code> defines the style of pattern-matchings nested in the last case of another pattern-matching. <code>nested-match=wrap</code> wraps the nested pattern-matching with parentheses and adds indentation, this is still the default behavior. <code>nested-match=align</code> vertically aligns the nested pattern-matching under the encompassing pattern-matching, for example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>\n  <span class="token keyword">match</span> v <span class="token keyword">with</span>\n  <span class="token operator">|</span> <span class="token module variable">None</span> <span class="token operator">-></span> <span class="token module variable">None</span>\n  <span class="token operator">|</span> <span class="token module variable">Some</span> x <span class="token operator">-></span>\n  <span class="token keyword">match</span> x <span class="token keyword">with</span>\n  <span class="token operator">|</span> <span class="token module variable">None</span> <span class="token operator">-></span> <span class="token module variable">None</span>\n  <span class="token operator">|</span> <span class="token module variable">Some</span> x <span class="token operator">-></span> x</code></pre></div>\n<p>The new option <code>cases-matching-exp-indent</code> decides the indentation of cases right-hand sides which are <code>match</code> or <code>try</code> expressions. <code>cases-matching-exp-indent=compact</code> forces an indentation of 2, unless <code>nested-match</code> is set to <code>align</code> and this is the last case of the pattern matching. <code>compact</code> is the default behavior. <code>cases-matching-exp-indent=normal</code> indents as it would any other expression.</p>\n<h3 id="whitelist-of-files-to-format" style="position:relative;"><a href="#whitelist-of-files-to-format" aria-label="whitelist of files to format permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Whitelist of files to format</h3>\n<p>A new kind of configuration files is now handled by <code>ocamlformat</code>: <code>.ocamlformat-enable</code> files.\nIf the <code>disable</code> option is set, an <code>.ocamlformat-enable</code> file can list the files that <code>ocamlformat</code> should format even when the <code>disable</code> option is set. Each line in an <code>.ocamlformat-enable</code> file specifies a filename relative to the directory containing the <code>.ocamlformat-enable</code> file.</p>\n<p>The <code>.ocamlformat-enable</code> files are using the same syntax as the <code>.ocamlformat-ignore</code> files: lines starting with <code>#</code> are ignored and can be used as comments.</p>\n<p>These new configuration files do not contradict the existing <code>.ocamlformat-ignore</code> files, as <code>.ocamlformat-enable</code> are only considered when <code>disable</code> is set, and <code>.ocamlformat-ignore</code> are only considered when <code>disable</code> is not set.</p>\n<h3 id="disable-outside-detected-project" style="position:relative;"><a href="#disable-outside-detected-project" aria-label="disable outside detected project permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disable outside detected project</h3>\n<p>The <code>disable-outside-detected-project</code> option is now set by default.</p>\n<p>When the option <code>--enable-outside-detected-project</code> is not set, <code>.ocamlformat</code> files outside of the project (including the one in <code>XDG_CONFIG_HOME</code>) are not read. The project root of an input file is taken to be the nearest ancestor directory that contains a .git or .hg or dune-project file. If no config file is found, formatting is disabled.</p>\n<h3 id="space-around-collection-expressions" style="position:relative;"><a href="#space-around-collection-expressions" aria-label="space around collection expressions permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Space around collection-expressions</h3>\n<p>The former option <code>space-around-collection-expressions</code> that was deciding whether a space should be added inside the delimiters of collection expressions (lists, arrays, records, variants) has been replaced by 4 new options: <code>space-around-arrays</code>, <code>space-around-lists</code>, <code>space-around-records</code> and <code>space-around-variants</code>, to allow a finer grain customization.</p>\n<h3 id="fit-or-vertical-mode-for-pattern-matching" style="position:relative;"><a href="#fit-or-vertical-mode-for-pattern-matching" aria-label="fit or vertical mode for pattern matching permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fit-or-vertical mode for pattern matching</h3>\n<p>The <code>break-cases</code> option that decides the shape of pattern matching has a new value <code>fit-or-vertical</code>. <code>break-cases=fit-or-vertical</code> tries to fit all or-patterns on the same line, otherwise breaks each or-pattern (they are wrapped in other modes).\nFor example if this set of or-patterns does not fit on a single line, we get the following output:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> ffffff <span class="token operator">=</span>\n  <span class="token keyword">match</span> foooooooooooo <span class="token keyword">with</span>\n  <span class="token operator">|</span> <span class="token module variable">Aaaaaaaaaaaaaaaaa</span>\n  <span class="token operator">|</span> <span class="token module variable">Bbbbbbbbbbbbbbbbb</span>\n  <span class="token operator">|</span> <span class="token module variable">Ccccccccccccccccc</span>\n  <span class="token operator">|</span> <span class="token module variable">Ddddddddddddddddd</span>\n  <span class="token operator">|</span> <span class="token module variable">Eeeeeeeeeeeeeeeee</span> <span class="token operator">-></span> foooooooooooooooooooo\n  <span class="token operator">|</span> <span class="token module variable">Fffffffffffffffff</span> <span class="token operator">-></span> fooooooooooooooooo</code></pre></div>\n<h3 id="kr-style-for-if-then-else" style="position:relative;"><a href="#kr-style-for-if-then-else" aria-label="kr style for if then else permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>K&#x26;R style for if-then-else</h3>\n<p>The <code>if-then-else</code> option now has a new value <code>k-r</code> that uses parentheses (when necessary) to reproduce a formatting close to the K&#x26;R style. For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">_</span> <span class="token operator">=</span>\n  <span class="token keyword">if</span> b <span class="token keyword">then</span> <span class="token punctuation">(</span>\n    something loooooooooooooooooooooooooooooooong enough to_trigger a break <span class="token punctuation">;</span>\n    this is more\n  <span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token keyword">if</span> b1 <span class="token keyword">then</span> <span class="token punctuation">(</span>\n    something loooooooooooooooooooooooooooooooong enough to_trigger a break <span class="token punctuation">;</span>\n    this is more\n  <span class="token punctuation">)</span> <span class="token keyword">else</span>\n    e</code></pre></div>\n<h2 id="breaking-changes" style="position:relative;"><a href="#breaking-changes" aria-label="breaking changes permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Breaking changes</h2>\n<ul>\n<li>the <code>indicate-multiline-delimiters</code> option is no longer a boolean option but now has 3 values: <code>space</code>, <code>no</code> and <code>closing-on-separate-line</code> that are detailed in this patch note.</li>\n<li>the <code>disable-outside-detected-project</code> option is now set by default.</li>\n<li>the <code>default</code> preset profile has been removed (it was equivalent to the <code>ocamlformat</code> profile with <code>break-cases=fit</code>).</li>\n<li>the <code>space-around-collection-expressions</code> option has been replaced by 4 new options: <code>space-around-arrays</code>, <code>space-around-lists</code>, <code>space-around-records</code> and <code>space-around-variants</code>.</li>\n</ul>\n<h2 id="whats-next" style="position:relative;"><a href="#whats-next" aria-label="whats next permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What\'s next?</h2>\n<p>We strongly encourage our users to try out the <code>conventional</code> preset profile, as we plan to make it the default profile in a future release. This profile\'s purpose is to reproduce the most commonly encountered styles, and it may be more pleasing to the eye than the current default options.</p>\n<p>As stated previously, the <code>break-string-literals</code> will likely be removed in the next release and the default behavior would be <code>newlines-and-wrap</code>.</p>\n<h2 id="credits" style="position:relative;"><a href="#credits" aria-label="credits permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Credits</h2>\n<p>This release also contains many other changes and bug fixes that we cannot detail here.</p>\n<p>We would like to thank our maintainers and contributors for this release: Jules Aguillon, Josh Berdine, Hugo Heuzard, Guillaume Petiot and Thomas Refis, and especially our industrial users Jane Street, Ahrefs and Nomadic Labs that made this work possible by funding this project and providing helpful contributions and feedback.</p>\n<p>We would be happy to provide support for more customers, please contact us at contact@tarides.com</p>\n<p>If you wish to get involved with OCamlFormat development or file an issue, please read the <a href="https://github.com/ocaml-ppx/ocamlformat/blob/master/CONTRIBUTING.md">contributing guide</a>, any contribution is welcomed.</p>'},tl:{hd:{title:"Release of OCamlFormat 0.9",slug:"release-of-ocamlformat-09",description:"We are pleased to announce the release of OCamlFormat (available on opam).\nThere have been numerous changes since the last release,\nso here\u2026",url:"https://tarides.com/blog/2019-03-29-release-of-ocamlformat-0-9",date:"2019-03-29T00:00:00-00:00",preview_image:"https://tarides.com/static/b0a6eda566f64c66aa1761737cf3ea4a/2244e/ceiling-arches.jpg",body_html:'<p>We are pleased to announce the release of OCamlFormat (available on opam).\nThere have been numerous changes since the last release,\nso here is a comprehensive list of the new features and breaking changes to help the transition from OCamlFormat 0.8.</p>\n<h1 id="additional-dependencies" style="position:relative;"><a href="#additional-dependencies" aria-label="additional dependencies permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Additional dependencies</h1>\n<p>OCamlFormat now requires:</p>\n<ul>\n<li>ocaml >= 4.06 (up from 4.04.1)</li>\n<li>dune >= 1.1.1</li>\n<li>octavius >= 1.2.0</li>\n<li>uutf</li>\n</ul>\n<p>OCamlFormat_Reason now requires:</p>\n<ul>\n<li>ocaml >= 4.06</li>\n<li>dune >= 1.1.1</li>\n<li>ocaml-migrate-parsetree >= 1.0.10 (up from 1.0.6)</li>\n<li>octavius >= 1.2.0</li>\n<li>uutf</li>\n<li>reason >= 3.2.0 (up from 1.13.4)</li>\n</ul>\n<h1 id="new-preset-profiles" style="position:relative;"><a href="#new-preset-profiles" aria-label="new preset profiles permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>New preset profiles</h1>\n<p>The <code>ocamlformat</code> profile aims to take advantage of the strengths of a parsetree-based auto-formatter,\nand to limit the consequences of the weaknesses imposed by the current implementation.\nThis is a style which optimizes for what the formatter can do best, rather than to match the style of any existing code.\nGeneral guidelines that have directed the design include:</p>\n<ul>\n<li>Legibility, in the sense of making it as hard as possible for quick visual parsing to give the wrong interpretation,\nis of highest priority;</li>\n<li>Whenever possible the high-level structure of the code should be obvious by looking only at the left margin,\nin particular, it should not be necessary to visually jump from left to right hunting for critical keywords, tokens, etc;</li>\n<li>All else equal compact code is preferred as reading without scrolling is easier,\nso indentation or white space is avoided unless it helps legibility;</li>\n<li>Attention has been given to making some syntactic gotchas visually obvious.\n<code>ocamlformat</code> is the new default profile.</li>\n</ul>\n<p>The <code>conventional</code> profile aims to be as familiar and "conventional" appearing as the available options allow.</p>\n<p>The <code>default</code> profile is <code>ocamlformat</code> with <code>break-cases=fit</code>.\n<code>default</code> is deprecated and will be removed in version 0.10.</p>\n<h1 id="ocamlformat-diff-tool" style="position:relative;"><a href="#ocamlformat-diff-tool" aria-label="ocamlformat diff tool permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCamlFormat diff tool</h1>\n<p><code>ocamlformat-diff</code> is a tool that uses OCamlFormat to apply the same formatting to compared OCaml files,\nso that the formatting differences between the two files are not displayed.\nNote that <code>ocamlformat-diff</code> comes in a separate opam package and is not included in the <code>ocamlformat</code> package.</p>\n<p>The file comparison is then performed by any diff backend.</p>\n<p>The options\' documentation is available through <code>ocamlformat-diff --help</code>.</p>\n<p>The option <code>--diff</code> allows you to configure the diff command that is used to compare the formatted files.\nThe default value is the vanilla <code>diff</code>, but you can also use <code>patdiff</code> or any other similar comparison tool.</p>\n<p><code>ocamlformat-diff</code> can be integrated with <code>git diff</code>,\nas explained in the <a href="https://github.com/ocaml-ppx/ocamlformat/blob/0.9/tools/ocamlformat-diff/README.md">online documentation</a>.</p>\n<h1 id="formatting-docstrings" style="position:relative;"><a href="#formatting-docstrings" aria-label="formatting docstrings permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Formatting docstrings</h1>\n<p>Previously, the docstrings <code>(** This is a docstring *)</code> could only be formatted like regular comments,\na new option <code>--parse-docstrings</code> has been added so that docstrings can be nicely formatted.</p>\n<p>Here is a small example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(** {1 Printers and escapes used by Cmdliner module} *)</span>\n\n<span class="token keyword">val</span> subst_vars <span class="token punctuation">:</span> subst<span class="token punctuation">:</span><span class="token punctuation">(</span>string <span class="token operator">-></span> string option<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token module variable">Buffer</span><span class="token punctuation">.</span>t <span class="token operator">-></span> string <span class="token operator">-></span> string\n<span class="token comment">(** [subst b ~subst s], using [b], substitutes in [s] variables of the form\n    "$(doc)" by their [subst] definition. This leaves escapes and markup\n    directives $(markup,...) intact.\n    @raise Invalid_argument in case of illegal syntax. *)</span></code></pre></div>\n<p>Note that this option is disabled by default and you have to set it manually by adding <code>--parse-docstrings</code> to your command line\nor <code>parse-docstrings=true</code> to your <code>.ocamlformat</code> file.\nIf you get the following error message:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Error: Formatting of (** ... *) is unstable (e.g. parses as a list or not depending on the margin), please tighten up this comment in the source or disable the formatting using the option --no-parse-docstrings.</code></pre></div>\n<p>It means the original docstring cannot be formatted (e.g. because it does not comply with the odoc syntax)\nand you have to edit it or disable the formatting of docstrings.</p>\n<p>Of course if you think your docstring complies with the odoc syntax and there might be a bug in OCamlFormat,\n<a href="https://github.com/ocaml-ppx/ocamlformat/issues">feel free to file an issue on github</a>.</p>\n<h1 id="print-the-configuration" style="position:relative;"><a href="#print-the-configuration" aria-label="print the configuration permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Print the configuration</h1>\n<p>The new <code>--print-config</code> flag prints the configuration determined by the environment variable,\nthe configuration files, preset profiles and command line. Attributes are not considered.</p>\n<p>It provides the full list of options with the values they are set to, and the source of this value.\nFor example <code>ocamlformat --print-config</code> prints:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">profile=ocamlformat (file .ocamlformat:1)\nquiet=false (profile ocamlformat (file .ocamlformat:1))\nmax-iters=10 (profile ocamlformat (file .ocamlformat:1))\ncomment-check=true (profile ocamlformat (file .ocamlformat:1))\nwrap-fun-args=true (profile ocamlformat (file .ocamlformat:1))\nwrap-comments=true (file .ocamlformat:5)\ntype-decl=compact (profile ocamlformat (file .ocamlformat:1))\nspace-around-collection-expressions=false (profile ocamlformat (file .ocamlformat:1))\nsingle-case=compact (profile ocamlformat (file .ocamlformat:1))\nsequence-style=separator (profile ocamlformat (file .ocamlformat:1))\nparse-docstrings=true (file .ocamlformat:4)\nparens-tuple-patterns=multi-line-only (profile ocamlformat (file .ocamlformat:1))\nparens-tuple=always (profile ocamlformat (file .ocamlformat:1))\nparens-ite=false (profile ocamlformat (file .ocamlformat:1))\nocp-indent-compat=false (profile ocamlformat (file .ocamlformat:1))\nmodule-item-spacing=sparse (profile ocamlformat (file .ocamlformat:1))\nmargin=77 (file .ocamlformat:3)\nlet-open=preserve (profile ocamlformat (file .ocamlformat:1))\nlet-binding-spacing=compact (profile ocamlformat (file .ocamlformat:1))\nlet-and=compact (profile ocamlformat (file .ocamlformat:1))\nleading-nested-match-parens=false (profile ocamlformat (file .ocamlformat:1))\ninfix-precedence=indent (profile ocamlformat (file .ocamlformat:1))\nindicate-nested-or-patterns=space (profile ocamlformat (file .ocamlformat:1))\nindicate-multiline-delimiters=true (profile ocamlformat (file .ocamlformat:1))\nif-then-else=compact (profile ocamlformat (file .ocamlformat:1))\nfield-space=tight (profile ocamlformat (file .ocamlformat:1))\nextension-sugar=preserve (profile ocamlformat (file .ocamlformat:1))\nescape-strings=preserve (profile ocamlformat (file .ocamlformat:1))\nescape-chars=preserve (profile ocamlformat (file .ocamlformat:1))\ndoc-comments-tag-only=default (profile ocamlformat (file .ocamlformat:1))\ndoc-comments-padding=2 (profile ocamlformat (file .ocamlformat:1))\ndoc-comments=after (profile ocamlformat (file .ocamlformat:1))\ndisable=false (profile ocamlformat (file .ocamlformat:1))\ncases-exp-indent=4 (profile ocamlformat (file .ocamlformat:1))\nbreak-struct=force (profile ocamlformat (file .ocamlformat:1))\nbreak-string-literals=wrap (profile ocamlformat (file .ocamlformat:1))\nbreak-sequences=false (profile ocamlformat (file .ocamlformat:1))\nbreak-separators=before (profile ocamlformat (file .ocamlformat:1))\nbreak-infix-before-func=true (profile ocamlformat (file .ocamlformat:1))\nbreak-infix=wrap (profile ocamlformat (file .ocamlformat:1))\nbreak-fun-decl=wrap (profile ocamlformat (file .ocamlformat:1))\nbreak-collection-expressions=fit-or-vertical (profile ocamlformat (file .ocamlformat:1))\nbreak-cases=fit (file .ocamlformat:2)</code></pre></div>\n<p>If many input files are specified, only print the configuration for the first file.\nIf no input file is specified, print the configuration for the root directory if specified,\nor for the current working directory otherwise.</p>\n<h1 id="parentheses-around-if-then-else-branches" style="position:relative;"><a href="#parentheses-around-if-then-else-branches" aria-label="parentheses around if then else branches permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parentheses around if-then-else branches</h1>\n<p>A new option <code>parens-ite</code> has been added to decide whether to use parentheses\naround if-then-else branches that spread across multiple lines.</p>\n<p>If this option is set, the following function:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> loop count a <span class="token operator">=</span>\n  <span class="token keyword">if</span> count <span class="token operator">>=</span> self#len\n  <span class="token keyword">then</span> a\n  <span class="token keyword">else</span>\n    <span class="token keyword">let</span> a\' <span class="token operator">=</span> f cur#get count a <span class="token keyword">in</span>\n    cur#incr <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    loop <span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> a\'</code></pre></div>\n<p>will be formatted as:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> loop count a <span class="token operator">=</span>\n  <span class="token keyword">if</span> count <span class="token operator">>=</span> self#len\n  <span class="token keyword">then</span> a\n  <span class="token keyword">else</span> <span class="token punctuation">(</span>\n    <span class="token keyword">let</span> a\' <span class="token operator">=</span> f cur#get count a <span class="token keyword">in</span>\n    cur#incr <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    loop <span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> a\' <span class="token punctuation">)</span></code></pre></div>\n<h1 id="parentheses-around-tuple-patterns" style="position:relative;"><a href="#parentheses-around-tuple-patterns" aria-label="parentheses around tuple patterns permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parentheses around tuple patterns</h1>\n<p>A new option <code>parens-tuple-patterns</code> has been added, that mimics <code>parens-tuple</code> but only applies to patterns,\nwhereas <code>parens-tuples</code> only applies to expressions.\n<code>parens-tuple-patterns=multi-line-only</code> mode will try to skip parentheses for single-line tuple patterns,\nthis is the default value.\n<code>parens-tuple-patterns=always</code> always uses parentheses around tuples patterns.</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* with parens-tuple-patterns=always *)</span>\n<span class="token keyword">let</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>\n\n<span class="token comment">(* with parens-tuple-patterns=multi-line-only *)</span>\n<span class="token keyword">let</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></code></pre></div>\n<h1 id="single-case-pattern-matching-expressions" style="position:relative;"><a href="#single-case-pattern-matching-expressions" aria-label="single case pattern matching expressions permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Single-case pattern-matching expressions</h1>\n<p>The new option <code>single-case</code> defines the style of pattern-matching expressions with only a single case.\n<code>single-case=compact</code> will try to format a single case on a single line, this is the default value.\n<code>single-case=sparse</code> will always break the line before a single case.</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* with single-case=compact *)</span>\n<span class="token keyword">try</span> some_irrelevant_expression\n<span class="token keyword">with</span> <span class="token module variable">Undefined_recursive_module</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token boolean">true</span>\n\n<span class="token comment">(* with single-case=sparse *)</span>\n<span class="token keyword">try</span> some_irrelevant_expression\n<span class="token keyword">with</span>\n<span class="token operator">|</span> <span class="token module variable">Undefined_recursive_module</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token boolean">true</span></code></pre></div>\n<h1 id="space-around-collection-expressions" style="position:relative;"><a href="#space-around-collection-expressions" aria-label="space around collection expressions permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Space around collection expressions</h1>\n<p>The new option <code>space-around-collection-expressions</code> decides whether to add a space\ninside the delimiters of collection expressions (lists, arrays, records).</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* by default *)</span>\n<span class="token keyword">type</span> wkind <span class="token operator">=</span> <span class="token punctuation">{</span>f <span class="token punctuation">:</span> <span class="token type-variable function">\'a</span><span class="token punctuation">.</span> <span class="token type-variable function">\'a</span> tag <span class="token operator">-></span> <span class="token type-variable function">\'a</span> kind<span class="token punctuation">}</span>\n<span class="token keyword">let</span> l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Nil"</span><span class="token punctuation">,</span> <span class="token module variable">TCnoarg</span> <span class="token module variable">Thd</span><span class="token punctuation">;</span> <span class="token string">"Cons"</span><span class="token punctuation">,</span> <span class="token module variable">TCarg</span> <span class="token punctuation">(</span><span class="token module variable">Ttl</span> <span class="token module variable">Thd</span><span class="token punctuation">,</span> tcons<span class="token punctuation">)</span><span class="token punctuation">]</span>\n\n<span class="token comment">(* with space-around-collection-expressions *)</span>\n<span class="token keyword">type</span> wkind <span class="token operator">=</span> <span class="token punctuation">{</span> f <span class="token punctuation">:</span> <span class="token type-variable function">\'a</span><span class="token punctuation">.</span> <span class="token type-variable function">\'a</span> tag <span class="token operator">-></span> <span class="token type-variable function">\'a</span> kind <span class="token punctuation">}</span>\n<span class="token keyword">let</span> l <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">"Nil"</span><span class="token punctuation">,</span> <span class="token module variable">TCnoarg</span> <span class="token module variable">Thd</span><span class="token punctuation">;</span> <span class="token string">"Cons"</span><span class="token punctuation">,</span> <span class="token module variable">TCarg</span> <span class="token punctuation">(</span><span class="token module variable">Ttl</span> <span class="token module variable">Thd</span><span class="token punctuation">,</span> tcons<span class="token punctuation">)</span> <span class="token punctuation">]</span></code></pre></div>\n<h1 id="break-separators" style="position:relative;"><a href="#break-separators" aria-label="break separators permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Break separators</h1>\n<p>The new option <code>break-separators</code> decides whether to break before or after separators such as <code>;</code> in list or record expressions,\n<code>*</code> in tuples or <code>-></code> in arrow types.\n<code>break-separators=before</code> breaks the expressions before the separator, this is the default value.\n<code>break-separators=after</code> breaks the expressions after the separator.\n<code>break-separators=after-and-docked</code> breaks the expressions after the separator and docks the brackets for records.</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* with break-separators=before *)</span>\n<span class="token keyword">type</span> t <span class="token operator">=</span>\n  <span class="token punctuation">{</span> foooooooooooooooooooooooo<span class="token punctuation">:</span> foooooooooooooooooooooooooooooooooooooooo\n  <span class="token punctuation">;</span> fooooooooooooooooooooooooooooo<span class="token punctuation">:</span> fooooooooooooooooooooooooooo <span class="token punctuation">}</span>\n\n<span class="token comment">(* with break-separators=after *)</span>\n<span class="token keyword">type</span> t <span class="token operator">=</span>\n  <span class="token punctuation">{</span> foooooooooooooooooooooooo<span class="token punctuation">:</span> foooooooooooooooooooooooooooooooooooooooo<span class="token punctuation">;</span>\n    fooooooooooooooooooooooooooooo<span class="token punctuation">:</span> fooooooooooooooooooooooooooo <span class="token punctuation">}</span>\n\n<span class="token comment">(* with break-separators=after-and-docked *)</span>\n<span class="token keyword">type</span> t <span class="token operator">=</span> <span class="token punctuation">{</span>\n  foooooooooooooooooooooooo<span class="token punctuation">:</span> foooooooooooooooooooooooooooooooooooooooo<span class="token punctuation">;</span>\n  fooooooooooooooooooooooooooooo<span class="token punctuation">:</span> fooooooooooooooooooooooooooo\n<span class="token punctuation">}</span></code></pre></div>\n<h1 id="not-breaking-before-bindmap-operators" style="position:relative;"><a href="#not-breaking-before-bindmap-operators" aria-label="not breaking before bindmap operators permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Not breaking before bind/map operators</h1>\n<p>The new option <code>break-infix-before-func</code> decides whether to break infix operators\nwhose right arguments are anonymous functions specially.\nThis option is set by default, if you disable it with <code>--no-break-infix-before-func</code>,\nit will not break before the operator so that the first line of the function appears docked at the end of line after the operator.</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* by default *)</span>\nf x\n<span class="token operator">>>=</span> <span class="token keyword">fun</span> y <span class="token operator">-></span>\ng y\n<span class="token operator">>>=</span> <span class="token keyword">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span>\nf x <span class="token operator">>>=</span> <span class="token keyword">fun</span> y <span class="token operator">-></span> g y <span class="token operator">>>=</span> <span class="token keyword">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> f x <span class="token operator">>>=</span> <span class="token keyword">fun</span> y <span class="token operator">-></span> g y <span class="token operator">>>=</span> <span class="token keyword">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> y <span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">(* with break-infix-before-func = false *)</span>\nf x <span class="token operator">>>=</span> <span class="token keyword">fun</span> y <span class="token operator">-></span>\ng y <span class="token operator">>>=</span> <span class="token keyword">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span>\nf x <span class="token operator">>>=</span> <span class="token keyword">fun</span> y <span class="token operator">-></span> g y <span class="token operator">>>=</span> <span class="token keyword">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> f x <span class="token operator">>>=</span> <span class="token keyword">fun</span> y <span class="token operator">-></span> g y <span class="token operator">>>=</span> <span class="token keyword">fun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> y <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>\n<h1 id="break-toplevel-cases" style="position:relative;"><a href="#break-toplevel-cases" aria-label="break toplevel cases permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Break toplevel cases</h1>\n<p>There is a new value for the <code>break-cases</code> option: <code>toplevel</code>,\nthat forces top-level cases (i.e. not nested or-patterns) to break across lines,\notherwise breaks naturally at the margin.</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> f <span class="token operator">=</span>\n  <span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token keyword">function</span>\n    <span class="token operator">|</span> H <span class="token keyword">when</span> x y <span class="token operator">&lt;></span> k <span class="token operator">-></span> <span class="token number">2</span>\n    <span class="token operator">|</span> T <span class="token operator">|</span> P <span class="token operator">|</span> U <span class="token operator">-></span> <span class="token number">3</span>\n  <span class="token keyword">in</span>\n  <span class="token keyword">fun</span> x g t h y u <span class="token operator">-></span>\n    <span class="token keyword">match</span> x <span class="token keyword">with</span>\n    <span class="token operator">|</span> E <span class="token operator">-></span> <span class="token number">4</span>\n    <span class="token operator">|</span> Z <span class="token operator">|</span> P <span class="token operator">|</span> M <span class="token operator">-></span> <span class="token punctuation">(</span>\n      <span class="token keyword">match</span> y <span class="token keyword">with</span>\n      <span class="token operator">|</span> O <span class="token operator">-></span> <span class="token number">5</span>\n      <span class="token operator">|</span> P <span class="token keyword">when</span> h x <span class="token operator">-></span> <span class="token punctuation">(</span>\n          <span class="token keyword">function</span>\n          <span class="token operator">|</span> A <span class="token operator">-></span> <span class="token number">6</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span></code></pre></div>\n<h1 id="number-of-spaces-before-docstrings" style="position:relative;"><a href="#number-of-spaces-before-docstrings" aria-label="number of spaces before docstrings permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Number of spaces before docstrings</h1>\n<p>The new option <code>doc-comments-padding</code> controls how many spaces are printed before doc comments in type declarations.\nThe default value is 2.</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* with doc-comments-padding = 2 *)</span>\n<span class="token keyword">type</span> t <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span> int  <span class="token comment">(** a *)</span><span class="token punctuation">;</span> b<span class="token punctuation">:</span> int  <span class="token comment">(** b *)</span><span class="token punctuation">}</span>\n\n<span class="token comment">(* with doc-comments-padding = 1 *)</span>\n<span class="token keyword">type</span> t <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span> int <span class="token comment">(** a *)</span><span class="token punctuation">;</span> b<span class="token punctuation">:</span> int <span class="token comment">(** b *)</span><span class="token punctuation">}</span></code></pre></div>\n<h1 id="ignore-files" style="position:relative;"><a href="#ignore-files" aria-label="ignore files permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ignore files</h1>\n<p>An <code>.ocamlformat-ignore</code> file specifies files that OCamlFormat should ignore.\nEach line in an <code>.ocamlformat-ignore</code> file specifies a filename relative to the directory containing the <code>.ocamlformat-ignore</code> file.\nLines starting with <code>#</code> are ignored and can be used as comments.</p>\n<p>Here is an example of such <code>.ocamlformat-ignore</code> file:</p>\n<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">#This is a comment\ndir2/ignore_1.ml</code></pre></div>\n<h1 id="tag-only-docstrings" style="position:relative;"><a href="#tag-only-docstrings" aria-label="tag only docstrings permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tag-only docstrings</h1>\n<p>The new option <code>doc-comments-tag-only</code> controls the position of doc comments only containing tags.\n<code>doc-comments-tag-only=default</code> means no special treatment is done, this is the default value.\n<code>doc-comments-tag-only=fit</code> puts doc comments on the same line if it fits.</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* with doc-comments-tag-only = default *)</span>\n\n<span class="token comment">(** @deprecated  *)</span>\n<span class="token keyword">open</span> <span class="token module variable">Module</span>\n\n<span class="token comment">(* with doc-comments-tag-only = fit *)</span>\n\n<span class="token keyword">open</span> <span class="token module variable">Module</span> <span class="token comment">(** @deprecated  *)</span></code></pre></div>\n<h1 id="fit-or-vertical-mode-for-if-then-else" style="position:relative;"><a href="#fit-or-vertical-mode-for-if-then-else" aria-label="fit or vertical mode for if then else permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fit or vertical mode for if-then-else</h1>\n<p>There is a new value for the option <code>if-then-else</code>: <code>fit-or-vertical</code>.\n<code>fit-or-vertical</code> vertically breaks all branches if they do not fit on a single line.\nCompared to the <code>compact</code> (default) value, it breaks all branches if at least one of them does not fit on a single line.</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* with if-then-else = compact *)</span>\n<span class="token keyword">let</span> <span class="token punctuation">_</span> <span class="token operator">=</span>\n  <span class="token keyword">if</span> foo <span class="token keyword">then</span>\n    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">in</span>\n    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span>\n    a <span class="token operator">+</span> b\n  <span class="token keyword">else</span> <span class="token keyword">if</span> foo <span class="token keyword">then</span> <span class="token number">12</span>\n  <span class="token keyword">else</span> <span class="token number">0</span>\n\n<span class="token comment">(* with if-then-else = fit-or-vertical *)</span>\n<span class="token keyword">let</span> <span class="token punctuation">_</span> <span class="token operator">=</span>\n  <span class="token keyword">if</span> foo <span class="token keyword">then</span>\n    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">in</span>\n    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span>\n    a <span class="token operator">+</span> b\n  <span class="token keyword">else</span> <span class="token keyword">if</span> foo <span class="token keyword">then</span>\n    <span class="token number">12</span>\n  <span class="token keyword">else</span>\n    <span class="token number">0</span></code></pre></div>\n<h1 id="check-mode" style="position:relative;"><a href="#check-mode" aria-label="check mode permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Check mode</h1>\n<p>A new <code>--check</code> flag has been added.\nIt checks whether the input files already are formatted.\nThis flag is mutually exclusive with <code>--inplace</code> and <code>--output</code>.\nIt returns <code>0</code> if the input files are indeed already formatted, or <code>1</code> otherwise.</p>\n<h1 id="break-function-declarations" style="position:relative;"><a href="#break-function-declarations" aria-label="break function declarations permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Break function declarations</h1>\n<p>The new option <code>break-fun-decl</code> controls the style for function declarations and types.\n<code>break-fun-decl=wrap</code> breaks only if necessary, this is the default value.\n<code>break-fun-decl=fit-or-vertical</code> vertically breaks arguments if they do not fit on a single line.\n<code>break-fun-decl=smart</code> is like <code>fit-or-vertical</code> but try to fit arguments on their line if they fit.\nThe <code>wrap-fun-args</code> option now only controls the style for function calls, and no more for function declarations.</p>\n<p>For example:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* with break-fun-decl = wrap *)</span>\n<span class="token keyword">let</span> ffffffffffffffffffff aaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbb\n    cccccccccccccccccccccc <span class="token operator">=</span>\n  g\n\n<span class="token comment">(* with break-fun-decl = fit-or-vertical *)</span>\n<span class="token keyword">let</span> ffffffffffffffffffff\n    aaaaaaaaaaaaaaaaaaaaaa\n    bbbbbbbbbbbbbbbbbbbbbb\n    cccccccccccccccccccccc <span class="token operator">=</span>\n  g\n\n<span class="token comment">(* with break-fun-decl = smart *)</span>\n<span class="token keyword">let</span> ffffffffffffffffffff\n    aaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccc <span class="token operator">=</span>\n  g</code></pre></div>\n<h1 id="disable-configuration-in-files-and-attributes" style="position:relative;"><a href="#disable-configuration-in-files-and-attributes" aria-label="disable configuration in files and attributes permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disable configuration in files and attributes</h1>\n<p>Two new options have been added so that <code>.ocamlformat</code> configuration files and attributes in OCaml files do not change the\nconfiguration.\nThese options can be useful if you use some preset profile\nand you do not want attributes and <code>.ocamlformat</code> files to interfere with your preset configuration.\n<code>--disable-conf-attrs</code> disables the configuration in attributes,\nand <code>--disable-conf-files</code> disables <code>.ocamlformat</code> configuration files.</p>\n<h1 id="preserve-module-items-spacing" style="position:relative;"><a href="#preserve-module-items-spacing" aria-label="preserve module items spacing permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preserve module items spacing</h1>\n<p>There is a new value for the option <code>module-item-spacing</code>: <code>preserve</code>,\nthat will not leave open lines between one-liners of similar sorts unless there is an open line in the input.</p>\n<p>For example the line breaks are preserved in the following code:</p>\n<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> cmos_rtc_seconds <span class="token operator">=</span> <span class="token number">0x00</span>\n<span class="token keyword">let</span> cmos_rtc_seconds_alarm <span class="token operator">=</span> <span class="token number">0x01</span>\n<span class="token keyword">let</span> cmos_rtc_minutes <span class="token operator">=</span> <span class="token number">0x02</span>\n\n<span class="token keyword">let</span> x <span class="token operator">=</span> o\n\n<span class="token keyword">let</span> log_other <span class="token operator">=</span> <span class="token number">0x000001</span>\n<span class="token keyword">let</span> log_cpu <span class="token operator">=</span> <span class="token number">0x000002</span>\n<span class="token keyword">let</span> log_fpu <span class="token operator">=</span> <span class="token number">0x000004</span></code></pre></div>\n<h1 id="breaking-changes" style="position:relative;"><a href="#breaking-changes" aria-label="breaking changes permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Breaking changes</h1>\n<ul>\n<li>When <code>--disable-outside-detected-project</code> is set, disable ocamlformat when no <code>.ocamlformat</code> file is found.</li>\n<li>Files are not parsed when ocamlformat is disabled.</li>\n<li>Disallow <code>-</code> with other input files.</li>\n<li>The <code>wrap-fun-args</code> option now only controls the style for function calls, and no more for function declarations.</li>\n<li>The default profile is now named <code>ocamlformat</code>.</li>\n<li>The deprecated syntax for <code>.ocamlformat</code> files: <code>option value</code> is no more supported anymore and you should use the <code>option = value</code> syntax instead.</li>\n</ul>\n<h1 id="miscellaneous-bugfixes" style="position:relative;"><a href="#miscellaneous-bugfixes" aria-label="miscellaneous bugfixes permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Miscellaneous bugfixes</h1>\n<ul>\n<li>Preserve shebang (e.g. <code>#!/usr/bin/env ocaml</code>) at the beginning of a file.</li>\n<li>Improve the formatting when <code>ocp-indent-compat</code> is set.</li>\n<li>UTF8 characters are now correctly printed in comments.</li>\n<li>Add parentheses around a constrained any-pattern (e.g. <code>let (_ : int) = x1</code>).</li>\n<li>Emacs: the temporary buffer is now killed.</li>\n<li>Emacs: add the keybinding in tuareg\'s map instead of merlin\'s.</li>\n<li>Lots of improvements on the comments, docstrings, attributes formatting.</li>\n<li>Lots of improvements on the formatting of modules.</li>\n<li>Lots of improvements in the Reason support.</li>\n<li>Do not rely on the file-system to format sources.</li>\n<li>The <code>--debug</code> mode is more user-friendly.</li>\n</ul>\n<h1 id="credits" style="position:relative;"><a href="#credits" aria-label="credits permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Credits</h1>\n<p>This release also contains many other changes and bug fixes that we cannot detail here.</p>\n<p>Special thanks to our maintainers and contributors for this release: Jules Aguillon, Mathieu Barbin, Josh Berdine, J\xe9r\xe9mie Dimino, Hugo Heuzard, Ludwig Pacifici, Guillaume Petiot, Nathan Rebours and Louis Roch\xe9.</p>\n<p>If you wish to get involved with OCamlFormat development or file an issue,\nplease read the <a href="https://github.com/ocaml-ppx/ocamlformat/blob/master/CONTRIBUTING.md">contributing guide</a>,\nany contribution is welcomed.</p>'},tl:{hd:{title:"Tarides is now a sponsor of the OCaml Software Foundation",slug:"tarides-is-now-a-sponsor-of-the-ocaml-software-foundation",description:"Tarides is pleased to provide support for the OCaml Software\nFoundation, a non-profit foundation hosted by\nthe Inria Foundation. The OCaml\u2026",url:"https://tarides.com/blog/2020-09-17-tarides-is-now-a-sponsor-of-the-ocaml-software-foundation",date:"2020-09-17T00:00:00-00:00",preview_image:"https://tarides.com/static/305bd3e2ab2e164e61b7781d183976fd/497c6/ocaml-software-foundation.png",body_html:'<p>Tarides is pleased to provide support for the <a href="https://ocaml-sf.org">OCaml Software\nFoundation</a>, a non-profit foundation hosted by\nthe Inria Foundation. The OCaml Software Foundation\'s mission is to\npromote the OCaml programming language and its ecosystem by\nsupporting the growth of a diverse and international community of\nOCaml users.</p>\n<p>Tarides develops secure-by-design solutions in which OCaml\'s memory and\ntype-safety guarantees play a major role. Hence, most of the software\ndevelopment that is done at Tarides is in OCaml: for instance,\n<a href="https://mirage.io">MirageOS</a>, a library operating system that\nconstructs unikernels for secure, high-performance network\napplications; and <a href="https://irmin.org">Irmin</a>, a library for building\nmergeable, branchable distributed data stores, with built-in\nsnapshotting and support for a wide variety of storage backends.</p>\n<p>Tarides is also very involved in the OCaml compiler development and\nOCaml developer tooling ecosystem: as active maintainers of the <a href="https://www.youtube.com/watch?v=E8T_4zqWmq8&#x26;list=PLKO_ZowsIOu5fHjRj0ua7_QWE_L789K_f&#x26;ab_channel=ocaml2020">OCaml\nplatform</a>, Tarides is involved with most of the major\nOCaml developer tools, including <a href="https://github.com/ocaml/ocaml">opam</a>, <a href="https://github.com/ocaml/dune">dune</a> and <a href="https://github.com/ocaml/merlin">merlin</a>.</p>'},tl:{hd:{title:"The future of Tezos on MirageOS",slug:"the-future-of-tezos-on-mirageos",description:"We are very glad to announce that Tarides has been awarded two new grants from\nthe Tezos Foundation. Thanks to these new grants, Tarides\u2026",url:"https://tarides.com/blog/2020-04-20-the-future-of-tezos-on-mirageos",date:"2020-04-20T00:00:00-00:00",preview_image:"https://tarides.com/static/bb44e4615f4730d8692d1214f5b238a3/497c6/tezosgrants.png",body_html:"<p>We are very glad to announce that Tarides has been awarded two new grants from\nthe Tezos Foundation.</p>\n<p>Thanks to these new grants, Tarides will continue to work on the integration\nbetween Tezos and MirageOS. We believe that the secure deployment of blockchains\nis still a major challenge today, and that deploying Tezos as a unikernel will\nhave a big impact in term of safety and security. It will be a key\ndifferentiator that will separate Tezos from other blockchains.</p>\n<p>The Tezos codebase is written in OCaml and is currently using more than 100\nexternal packages, among which one third comes from the MirageOS project.\nHowever, it still heavily depends on non-compatible Unix libraries. Making the\nTezos codebase fully compatible with MirageOS will help Tezos with: distribution\nand packaging, portability, secure deployment and operational safety.</p>\n<p>We\u2019ll regularly publish development progress updates, so stay tuned!</p>"},tl:0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},l={hd:{title:"OCaml Users and Developers Workshop 2021",slug:"ocaml-users-and-developers-workshop-2021",description:"The OCaml Workshop 2021 as part of ICFP",url:"https://icfp21.sigplan.org/home/ocaml-2021",date:"2021-08-27T09:00:40.154Z",tags:{hd:"ocaml-workshop",tl:0},online:!0,textual_location:void 0,location:void 0},tl:{hd:{title:"OCaml Users and Developers Workshop 2020",slug:"ocaml-users-and-developers-workshop-2020",description:"The OCaml Workshop 2020 as part of ICFP",url:"https://icfp20.sigplan.org/home/ocaml-2020",date:"2020-08-20T09:00:42.358Z",tags:{hd:"ocaml-workshop",tl:0},online:!0,textual_location:"Jersey City",location:'{"type":"Point","coordinates":[-74.0739787,40.7262413]}'},tl:{hd:{title:"OCaml User and Developer Workshop 2019",slug:"ocaml-user-and-developer-workshop-2019",description:"The OCaml Workshop 2019 as part of ICFP",url:"https://icfp19.sigplan.org/home/ocaml-2019#Call-for-Presentations",date:"2019-08-23T00:00:00.000Z",tags:{hd:"ocaml-workshop",tl:0},online:!1,textual_location:"Berlin",location:'{"type":"Point","coordinates":[13.4163451,52.4861467]}'},tl:0}}},c={hd:{title:"A Syntactic Approach to Type Soundness",slug:"a-syntactic-approach-to-type-soundness",publication:"Information & Computation, 115(1):38\u221294",authors:{hd:"Andrew K. Wright",tl:{hd:"Matthias Felleisen",tl:0}},abstract:"This paper describes the semantics and the type system of Core ML,  and uses a simple syntactic technique to prove that well-typed programs cannot go wrong.\n",tags:{hd:"core",tl:{hd:"language",tl:0}},year:1994,links:{hd:"https://www.cs.rice.edu/CS/PLT/Publications/Scheme/ic94-wf.ps.gz",tl:0}},tl:{hd:{title:"The Essence of ML Type Inference",slug:"the-essence-of-ml-type-inference",publication:"Benjamin C. Pierce, editor, Advanced Topics in Types and Programming Languages, MIT Press",authors:{hd:"Fran\xe7ois Pottier",tl:{hd:"Didier R\xe9my",tl:0}},abstract:"This book chapter gives an in-depth abstract of the Core ML type system, with an emphasis on type inference.  The type inference algorithm is described as the composition of a constraint generator, which produces a system  of type equations, and a constraint solver, which is presented as a set of rewrite rules.\n",tags:{hd:"core",tl:{hd:"language",tl:0}},year:2005,links:{hd:"https://cristal.inria.fr/attapl/preversion.ps.gz",tl:0}},tl:{hd:{title:"Relaxing the value restriction",slug:"relaxing-the-value-restriction",publication:"International Symposium on Functional and Logic Programming",authors:{hd:"Jacques Garrigue",tl:0},abstract:"This paper explains why it is sound to generalize certain type variables at a `let` binding, even when the expression that is being `let`-bound is not a value. This relaxed version of Wright's classic \u201cvalue restriction\u201d was introduced in OCaml 3.07.\n",tags:{hd:"core",tl:{hd:"language",tl:0}},year:2004,links:{hd:"https://caml.inria.fr/pub/papers/garrigue-value_restriction-fiwflp04.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/garrigue-value_restriction-fiwflp04.ps.gz",tl:0}}},tl:{hd:{title:"Manifest Types, Modules, and Separate Compilation",slug:"manifest-types-modules-and-separate-compilation",publication:"Principles of Programming Languages",authors:{hd:"Xavier Leroy",tl:0},abstract:"This paper presents a variant of the Standard ML module system that introduces a strict distinction between abstract  and manifest types. The latter are types whose definitions explicitly appear as part of a module interface. This proposal  is meant to retain most of the expressive power of the Standard ML module system, while providing much better support for  separate compilation. This work sets the formal bases for OCaml's module system.\n",tags:{hd:"core",tl:{hd:"language",tl:{hd:"modules",tl:0}}},year:1994,links:{hd:"https://caml.inria.fr/pub/papers/xleroy-manifest_types-popl94.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/xleroy-manifest_types-popl94.ps.gz",tl:{hd:"https://caml.inria.fr/pub/papers/xleroy-manifest_types-popl94.dvi.gz",tl:0}}}},tl:{hd:{title:"Applicative Functors and Fully Transparent Higher-order Modules",slug:"applicative-functors-and-fully-transparent-higher-order-modules",publication:"Principles of Programming Languages",authors:{hd:"Xavier Leroy",tl:0},abstract:"This work extends the above paper by introducing so-called applicative functors, that is, functors that produce compatible  abstract types when applied to provably equal arguments. Applicative functors are also a feature of OCaml.\n",tags:{hd:"core",tl:{hd:"language",tl:{hd:"modules",tl:0}}},year:1995,links:{hd:"https://caml.inria.fr/pub/papers/xleroy-applicative_functors-popl95.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/xleroy-applicative_functors-popl95.ps.gz",tl:{hd:"https://caml.inria.fr/pub/papers/xleroy-applicative_functors-popl95.dvi.gz",tl:0}}}},tl:{hd:{title:"A Modular Module System",slug:"a-modular-module-system",publication:"Journal of Functional Programming, 10(3):269-303",authors:{hd:"Xavier Leroy",tl:0},abstract:"This accessible paper describes a simplified implementation of the OCaml module system, emphasizing the fact that the module system  is largely independent of the underlying core language. This is a good tutorial to learn both how modules can be used and how  they are typechecked.\n",tags:{hd:"core",tl:{hd:"language",tl:{hd:"modules",tl:0}}},year:2e3,links:{hd:"https://caml.inria.fr/pub/papers/xleroy-modular_modules-jfp.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/xleroy-modular_modules-jfp.ps.gz",tl:{hd:"https://caml.inria.fr/pub/papers/xleroy-modular_modules-jfp.dvi.gz",tl:0}}}},tl:{hd:{title:"A Proposal for Recursive Modules in Objective Caml",slug:"a-proposal-for-recursive-modules-in-objective-caml",publication:"Unpublication",authors:{hd:"Xavier Leroy",tl:0},abstract:"This note describes the experimental recursive modules introduced in OCaml 3.07.\n",tags:{hd:"core",tl:{hd:"language",tl:{hd:"modules",tl:0}}},year:2003,links:{hd:"https://caml.inria.fr/pub/papers/xleroy-recursive_modules-03.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/xleroy-recursive_modules-03.ps.gz",tl:0}}},tl:{hd:{title:"Objective ML: An effective object-oriented extension to ML",slug:"objective-ml-an-effective-object-oriented-extension-to-ml",publication:"Theory And Practice of Objects Systems, 4(1):27\u221250",authors:{hd:"Didier R\xe9my",tl:{hd:"J\xe9r\xf4me Vouillon",tl:0}},abstract:"This paper provides theoretical foundations for OCaml's object-oriented layer, including dynamic and static semantics.\n",tags:{hd:"core",tl:{hd:"language",tl:{hd:"objects",tl:0}}},year:1998,links:{hd:"https://caml.inria.fr/pub/papers/remy_vouillon-objective_ml-tapos98.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/remy_vouillon-objective_ml-tapos98.ps.gz",tl:{hd:"https://caml.inria.fr/pub/papers/remy_vouillon-objective_ml-tapos98.dvi.gz",tl:0}}}},tl:{hd:{title:"Extending ML with Semi-Explicit Higher-Order Polymorphism",slug:"extending-ml-with-semi-explicit-higher-order-polymorphism",publication:"Information & Computation, 155(1/2):134\u2212169",authors:{hd:"Jacques Garrigue",tl:{hd:"Didier R\xe9my",tl:0}},abstract:"This paper proposes a device for re-introducing first-class polymorphic values into ML while preserving its type inference  mechanism. This technology underlies OCaml's polymorphic methods.\n",tags:{hd:"core",tl:{hd:"language",tl:{hd:"objects",tl:0}}},year:1999,links:{hd:"https://caml.inria.fr/pub/papers/garrigue_remy-poly-ic99.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/garrigue_remy-poly-ic99.ps.gz",tl:{hd:"https://caml.inria.fr/pub/papers/garrigue_remy-poly-ic99.dvi.gz",tl:0}}}},tl:{hd:{title:"Programming with Polymorphic Variants",slug:"programming-with-polymorphic-variants",publication:"ML Workshop",authors:{hd:"Jacques Garrigue",tl:0},abstract:"This paper briefly explains what polymorphic variants are about and how they are compiled.\n",tags:{hd:"core",tl:{hd:"language",tl:{hd:"polymorphic variants",tl:0}}},year:1998,links:{hd:"https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.ps.gz",tl:0}}},tl:{hd:{title:"Code Reuse through Polymorphic Variants",slug:"code-reuse-through-polymorphic-variants",publication:"Workshop on Foundations of Software Engineering",authors:{hd:"Jacques Garrigue",tl:0},abstract:"This short paper explains how to design a modular, extensible interpreter using polymorphic variants.\n",tags:{hd:"core",tl:{hd:"language",tl:{hd:"polymorphic variants",tl:0}}},year:2e3,links:{hd:"https://caml.inria.fr/pub/papers/garrigue-variant-reuse-2000.ps.gz",tl:0}},tl:{hd:{title:"Simple Type Inference for Structural Polymorphism",slug:"simple-type-inference-for-structural-polymorphism",publication:"Workshop on Foundations of Object-Oriented Languages",authors:{hd:"Jacques Garrigue",tl:0},abstract:"This paper explains most of the typechecking machinery behind polymorphic variants.  At its heart is an extension of Core ML's type discipline with so-called local constraints.\n",tags:{hd:"core",tl:{hd:"language",tl:{hd:"polymorphic variants",tl:0}}},year:2002,links:{hd:"https://caml.inria.fr/pub/papers/garrigue-structural_poly-fool02.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/garrigue-structural_poly-fool02.ps.gz",tl:0}}},tl:{hd:{title:"Typing Deep Pattern-matching in Presence of Polymorphic Variants",slug:"typing-deep-pattern-matching-in-presence-of-polymorphic-variants",publication:"JSSST Workshop on Programming and Programming Languages",authors:{hd:"Jacques Garrigue",tl:0},abstract:"This paper provides more details about the technical machinery behind polymorphic variants, focusing  on the rules for typechecking deep pattern matching constructs.\n",tags:{hd:"core",tl:{hd:"language",tl:{hd:"polymorphic variants",tl:0}}},year:2004,links:{hd:"https://caml.inria.fr/pub/papers/garrigue-deep-variants-2004.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/garrigue-deep-variants-2004.ps.gz",tl:0}}},tl:{hd:{title:"Labeled and Optional Arguments for Objective Caml",slug:"labeled-and-optional-arguments-for-objective-caml",publication:"JSSST Workshop on Programming and Programming Languages",authors:{hd:"Jacques Garrigue",tl:0},abstract:"This paper offers a dynamic semantics, a static semantics, and a compilation scheme for OCaml's labeled  and optional function parameters.\n",tags:{hd:"core",tl:{hd:"language",tl:0}},year:2001,links:{hd:"https://caml.inria.fr/pub/papers/garrigue-labels-ppl01.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/garrigue-labels-ppl01.ps.gz",tl:{hd:"https://caml.inria.fr/pub/papers/garrigue-labels-ppl01.dvi.gz",tl:0}}}},tl:{hd:{title:"Meta-programming Tutorial with CamlP4",slug:"meta-programming-tutorial-with-camlp4",publication:"Commercial Users of Functional Programming",authors:{hd:"Jake Donham",tl:0},abstract:"Meta-programming tutorial with Camlp4",tags:{hd:"core",tl:{hd:"language",tl:0}},year:2010,links:{hd:"https://github.com/jaked/cufp-metaprogramming-tutorial",tl:0}},tl:{hd:{title:"The ZINC experiment, an Economical Implementation of the ML language",slug:"the-zinc-experiment-an-economical-implementation-of-the-ml-language",publication:"Technical report 117, INRIA",authors:{hd:"Xavier Leroy",tl:0},abstract:"This report contains a abstract of the ZINC compiler, which later evolved into Caml Light, then into OCaml. Large parts  of this report are out of date, but it is still valuable as a abstract of the abstract machine used in Caml Light and  (with some further simplifications and speed improvements) in OCaml.\n",tags:{hd:"compiler",tl:{hd:"runtime",tl:0}},year:1990,links:{hd:"https://caml.inria.fr/pub/papers/xleroy-zinc.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/xleroy-zinc.ps.gz",tl:0}}},tl:{hd:{title:"The Effectiveness of Type-based Unboxing",slug:"the-effectiveness-of-type-based-unboxing",publication:"Workshop on Types in Compilation",authors:{hd:"Xavier Leroy",tl:0},abstract:"This paper surveys and compares several data representation strategies, including the one used in the OCaml native-code compiler.\n",tags:{hd:"compiler",tl:{hd:"runtime",tl:0}},year:1997,links:{hd:"https://caml.inria.fr/pub/papers/xleroy-unboxing-tic97.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/xleroy-unboxing-tic97.ps.gz",tl:0}}},tl:{hd:{title:"A Concurrent, Generational Garbage Collector for a Multithreaded Implementation of ML",slug:"a-concurrent-generational-garbage-collector-for-a-multithreaded-implementation-of-ml",publication:"Principles of Programming Languages",authors:{hd:"Damien Doligez",tl:{hd:"Xavier Leroy",tl:0}},abstract:'Superseded by "Portable, Unobtrusive Garbage Collection for Multiprocessor Systems"\n',tags:{hd:"garbage collection",tl:{hd:"runtime",tl:0}},year:1993,links:{hd:"https://caml.inria.fr/pub/papers/doligez_xleroy-concurrent_gc-popl93.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/doligez_xleroy-concurrent_gc-popl93.ps.gz",tl:0}}},tl:{hd:{title:"Portable, Unobtrusive Garbage Collection for Multiprocessor Systems",slug:"portable-unobtrusive-garbage-collection-for-multiprocessor-systems",publication:"Principles of Programming Languages",authors:{hd:"Damien Doligez",tl:{hd:"Georges Gonthier",tl:0}},abstract:"This paper describes a concurrent version of the garbage collector found in Caml Light and OCaml's runtime system.\n",tags:{hd:"garbage collection",tl:{hd:"runtime",tl:0}},year:1994,links:{hd:"https://caml.inria.fr/pub/papers/doligez_gonthier-gc-popl94.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/doligez_gonthier-gc-popl94.ps.gz",tl:0}}},tl:{hd:{title:"Conception, r\xe9alisation et certification d'un glaneur de cellules concurrent",slug:"conception-ralisation-et-certification-dun-glaneur-de-cellules-concurrent",publication:"Ph.D. thesis, Universit\xe9 Paris 7",authors:{hd:"Damien Doligez",tl:{hd:"Georges Gonthier",tl:0}},abstract:"All you ever wanted to know about the garbage collector found in Caml Light and OCaml's runtime system.\n",tags:{hd:"garbage collection",tl:{hd:"runtime",tl:0}},year:1995,links:{hd:"https://caml.inria.fr/pub/papers/doligez-these.pdf",tl:{hd:"https://caml.inria.fr/pub/papers/doligez-these.ps.gz",tl:0}}},tl:{hd:{title:"Optimizing Pattern Matching",slug:"optimizing-pattern-matching",publication:"Proceedings of the sixth ACM SIGPLAN International Conference on Functional Programming (ICFP)",authors:{hd:"Fabrice Le Fessant",tl:{hd:"Luc Maranget",tl:0}},abstract:"All you ever wanted to know about the garbage collector found in Caml Light and OCaml's runtime system.\n",tags:{hd:"pattern-matching",tl:{hd:"runtime",tl:0}},year:2001,links:{hd:"https://dl.acm.org/citation.cfm?id=507641",tl:0}},tl:{hd:{title:"OCaml for the Masses",slug:"ocaml-for-the-masses",publication:"ACM Queue",authors:{hd:"Yaron Minsky",tl:0},abstract:"Why the next language you learn should be functional.\n",tags:{hd:"industrial",tl:0},year:2011,links:{hd:"https://queue.acm.org/detail.cfm?id=2038036",tl:0}},tl:{hd:{title:"Xen and the Art of OCaml",slug:"xen-and-the-art-of-ocaml",publication:"Commercial Users of Functional Programming (CUFP)",authors:{hd:"Anil Madhavapeddy",tl:0},abstract:"In this talk, we will firstly describe the architecture of XenServer and the XenAPI and discuss the challenges faced with implementing  an Objective Caml based solution. These challenges range from the low-level concerns of interfacing with Xen and the  Linux kernel, to the high-level algorithmic problems such as distributed failure planning. In addition, we will  discuss the challenges imposed by using OCaml in a commercial environment, such as supporting product upgrades,  enhancing supportability and scaling the development team.\n",tags:{hd:"industrial",tl:{hd:"application",tl:0}},year:2008,links:{hd:"https://cufp.org/archive/2008/slides/MadhavapeddyAnil.pdf",tl:0}},tl:{hd:{title:"Chemoinformatics and Structural Bioinformatics in OCaml",slug:"chemoinformatics-and-structural-bioinformatics-in-ocaml",publication:"Journal of Cheminformatics",authors:{hd:"Fran\xe7ois Berenger",tl:{hd:"Kam Y. J. Zhang",tl:{hd:"Yoshihiro Yamanishi",tl:0}}},abstract:"In this article, we share our experience in prototyping chemoinformatics and structural bioinformatics software in OCaml\n",tags:{hd:"industrial",tl:{hd:"application",tl:{hd:"bioinformatics",tl:0}}},year:2019,links:{hd:"https://jcheminf.biomedcentral.com/articles/10.1186/s13321-019-0332-0",tl:0}},tl:{hd:{title:"A Declarative Syntax Definition for OCaml",slug:"a-declarative-syntax-definition-for-ocaml",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Luis Eduardo de Souza Amorim",tl:{hd:"Eelco Visser",tl:0}},abstract:"In this talk we present our work on a syntax definition for the OCaml language in the syntax definition formalism SDF3.  SDF3 supports high-level definition of concrete and abstract syntax through declarative disambiguation and definition of  constructors, enabling a direct mapping to abstract syntax. Based on the SDF3 syntax definition, the Spoofax language  workbench produces a complete syntax aware editor with a parser, syntax checking, parse error recovery, syntax highlighting,  formatting with correct parenthesis insertion, and syntactic completion. The syntax definition should provide a good  basis for experiments with the design of OCaml and the development of further tooling. In the talk we will highlight  interesting aspects the syntax definition, discuss issues we encountered in the syntax of OCaml, and demonstrate the editor.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://eelcovisser.org/talks/2020/08/28/ocaml/",tl:0}},tl:{hd:{title:"A Simple State-Machine Framework for Property-Based Testing in OCaml",slug:"a-simple-state-machine-framework-for-property-based-testing-in-ocaml",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Jan Midtgaard",tl:0},abstract:"Since their inception state-machine frameworks have proven their worth by finding defects in everything  from the underlying AUTOSAR components of Volvo cars to digital invoicing sys- tems. These case studies were carried  out with Erlang\u2019s commercial QuickCheck state-machine framework from Quviq, but such frameworks are now also available  for Haskell, F#, Scala, Elixir, Java, etc. We present a typed state-machine framework for OCaml based on the QCheck  library and illustrate a number concepts common to all such frameworks: state modeling, commands, interpreting commands, preconditions, and agreement checking.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://janmidtgaard.dk/papers/Midtgaard%3AOCaml20.pdf",tl:0}},tl:{hd:{title:"AD-OCaml: Algorithmic Differentiation for OCaml",slug:"ad-ocaml-algorithmic-differentiation-for-ocaml",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Markus Mottl",tl:0},abstract:"AD-OCaml is a library framework for calculating mathematically exact derivatives and  deep power series approximations of almost arbitrary OCaml programs via algorithmic  differentiation. Unlike similar frameworks, this includes programs with side effects,  aliasing, and programs with nested derivative operators. The framework also offers implicit  parallelization of both user programs and their transformations. The presentation will provide  a short introduction to the mathematical problem, the difficulties of implementing a solution,  the design of the library, and a demonstration of its capabilities.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://icfp20.sigplan.org/details/ocaml-2020-papers/12/AD-OCaml-Algorithmic-Differentiation-for-OCaml",tl:0}},tl:{hd:{title:"API migration: compare transformed",slug:"api-migration-compare-transformed",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Joseph Harrison",tl:{hd:"Steven Varoumas",tl:{hd:"Simon Thompson",tl:{hd:"Reuben Rowe",tl:0}}}},abstract:"In this talk we describe our experience in using an automatic API-migration strategy dedicated at changing  the signatures of OCaml functions, using the Rotor refactoring tool for OCaml. We perform a case study on  open source Jane Street libraries by using Rotor to refactor comparison functions so that they return a  more precise variant type rather than an integer. We discuss the difficulties of refactoring the Jane Street  code base, which makes extensive use of ppx macros, and ongoing work implementing new refactorings.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://icfp20.sigplan.org/details/ocaml-2020-papers/7/API-migration-compare-transformed",tl:{hd:"https://www.cs.kent.ac.uk/people/staff/sjt/Pubs/OCaml_workshop2020.pdf",tl:0}}},tl:{hd:{title:"Irmin v2",slug:"irmin-v2",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Cl\xe9ment Pascutto",tl:{hd:"Ioana Cristescu",tl:{hd:"Craig Ferguson",tl:{hd:"Thomas Gazagnaire",tl:{hd:"Romain Liautaud",tl:0}}}}},abstract:"Irmin is an OCaml library for building distributed databases with the same design principles as Git.  Existing Git users will find many familiar features: branching/merging, immutable causal history for  all changes, and the ability to restore to any previous state. Irmin v2 adds new accessibility methods  to the store: we can now use Irmin from a CLI, or in a browser using irmin-graphql. It also has a new  backend, irmin-pack, which is optimised for space usage and is used by the Tezos blockchain.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://icfp20.sigplan.org/details/ocaml-2020-papers/10/Irmin-v2",tl:{hd:"https://tarides.com/blog/2019-11-21-irmin-v2",tl:0}}},tl:{hd:{title:"LexiFi Runtime Types",slug:"lexifi-runtime-types",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Patrik Keller",tl:{hd:"Marc Lasson",tl:0}},abstract:"LexiFi maintains an OCaml compiler extension that enables introspection through runtime type representations.  Recently, we implemented a syntax extension (PPX) that enables the use of LexiFi runtime types on vanilla compilers.  We propose to present our publicly available runtime types and their features. Most notably, we want to present  a mechanism for pattern matching on runtime types with holes.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://icfp20.sigplan.org/details/ocaml-2020-papers/9/LexiFi-Runtime-Types",tl:{hd:"https://informationsecurity.uibk.ac.at/pdfs/KL2020_LexiFi_Runtime_Types_OCAML.pdf",tl:{hd:"https://www.lexifi.com/blog/ocaml/runtime-types/",tl:0}}}},tl:{hd:{title:"OCaml Under the Hood: SmartPy",slug:"ocaml-under-the-hood-smartpy",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Sebastien Mondet",tl:0},abstract:"SmartPy is a complete system to develop smart-contracts for the Tezos blockchain. It is an embedded EDSL in python  to write contracts and their tests scenarios. It includes an online IDE, a chain explorer, and a command line interface.  Python is used to generate programs in an imperative, type inferred, intermediate language called SmartML. SmartML is  also the name of the OCaml library which provides an interpreter, a compiler to Michelson (the smart-contract language of Tezos),  as well as a scenario \u201con-chain\u201d interpreter. The IDE uses a mix of OCaml built with js_of_ocaml and pure Javascript.  The command line interface also builds with js_of_ocaml to run on Node.js.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://icfp20.sigplan.org/details/ocaml-2020-papers/11/OCaml-Under-The-Hood-SmartPy",tl:{hd:"https://wr.mondet.org/paper/smartpy-ocaml-2020.pdf",tl:0}}},tl:{hd:{title:"OCaml-CI: A Zero-Configuration CI",slug:"ocaml-ci-a-zero-configuration-ci",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Thomas Leonard",tl:{hd:"Craig Ferguson",tl:{hd:"Kate Deplaix",tl:{hd:"Magnus Skjegstad",tl:{hd:"Anil Madhavapeddy",tl:0}}}}},abstract:"OCaml-CI is a CI service for OCaml projects. It uses metadata from the project\u2019s opam and dune files to work out what to build,  and uses caching to make builds fast. It automatically tests projects against multiple OCaml versions and OS platforms. The CI has been deployed on around 50 projects so far on GitHub, and many of them see response times an order of magnitude quicker than  with less integrated CI solutions. This talk will introduce the CI service and then look at some of the technologies used to build it.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://icfp20.sigplan.org/details/ocaml-2020-papers/6/OCaml-CI-A-Zero-Configuration-CI",tl:0}},tl:{hd:{title:"Parallelising your OCaml Code with Multicore OCaml",slug:"parallelising-your-ocaml-code-with-multicore-ocaml",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Sadiq Jaffer",tl:{hd:"Sudha Parimala",tl:{hd:"KC Sivaramarkrishnan",tl:{hd:"Tom Kelly",tl:{hd:"Anil Madhavapeddy",tl:0}}}}},abstract:"With the availability of multicore variants of the recent OCaml versions (4.10 and 4.11) that maintain  backwards compatibility with the existing OCaml C-API, there has been increasing interest in the wider  OCaml community for parallelising existing OCaml code.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://github.com/ocaml-multicore/multicore-talks/blob/master/ocaml2020-workshop-parallel/multicore-ocaml20.pdf",tl:{hd:"https://icfp20.sigplan.org/details/ocaml-2020-papers/5/Parallelising-your-OCaml-Code-with-Multicore-OCaml",tl:0}}},tl:{hd:{title:"The ImpFS Filesystem",slug:"the-impfs-filesystem",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Tom Ridge",tl:0},abstract:"This proposal describes a presentation to be given at the OCaml\u201920 workshop. The presentation will cover a new OCaml filesystem,  ImpFS, and the related libraries. The filesystem makes use of a B-tree library presented at OCaml\u201917, and a key-value store  presented at ML\u201919. In addition, there are a number of other support libraries that may be of interest to the community. ImpFS  represents a single point in the filesystem design space, but we hope that the libraries we have developed will enable others to  build further filesystems with novel features.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://icfp20.sigplan.org/details/ocaml-2020-papers/8/The-ImpFS-filesystem",tl:0}},tl:{hd:{title:"The final pieces of the OCaml documentation puzzle",slug:"the-final-pieces-of-the-ocaml-documentation-puzzle",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Jonathan Ludlam",tl:{hd:"Gabriel Radanne",tl:{hd:"Leo White",tl:0}}},abstract:"Odoc is the latest attempt at creating a documentation tool which handles the full complexity of the OCaml language. It has been a long  time coming as tackling both the module system and rendering into rich documents makes for a difficult task. Nevertheless we believe  the two recent developments provides the final pieces of the OCaml documentation puzzle. This two improvements split odoc in two  layers: a model layer, with a deep understanding of the module system, and a document layer allowing for easy definition of new outputs.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://icfp20.sigplan.org/details/ocaml-2020-papers/4/The-final-pieces-of-the-OCaml-documentation-puzzle",tl:0}},tl:{hd:{title:"Types in Amber",slug:"types-in-amber",publication:"International Conference on Functional Programming (ICFP)",authors:{hd:"Paul Steckler",tl:{hd:"Matthew Ryan",tl:0}},abstract:"Coda is a new cryptocurrency that uses zk-SNARKs to dramatically reduce the size of data needed by nodes running its protocol. Nodes communicate  in a format automatically derived from type definitions in OCaml source files. As the Coda software evolves, these formats for sent data may change. We wish to allow nodes running older versions of the software to communicate with newer versions. To achieve that, we identify stable types that  must not change over time, so that their serializations also do not change.\n",tags:{hd:"ocaml-workshop",tl:0},year:2020,links:{hd:"https://icfp20.sigplan.org/details/ocaml-2020-papers/3/Types-in-amber",tl:0}},tl:0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},d={hd:{title:"A Declarative Syntax Definition for OCaml",slug:"a-declarative-syntax-definition-for-ocaml",description:"In this talk, we present our work on a syntax definition for the OCaml language in the syntax definition formalism SDF3. SDF3 supports the high-level definition of concrete and abstract syntax through declarative disambiguation and definition of constructors, enabling a direct mapping to abstract syntax. Based on the SDF3 syntax definition, the Spoofax language workbench produces a complete syntax aware editor with a parser, syntax checking, parse error recovery, syntax highlighting, formatting with correct parenthesis insertion, and syntactic completion. The syntax definition should provide a good basis for experiments with the design of OCaml and the development of further tooling. In the talk, we will highlight interesting aspects of the syntax definition, discuss issues we encountered in the syntax of OCaml, and demonstrate the editor.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:0},paper:"A Declarative Syntax Definition for OCaml",link:"https://watch.ocaml.org/videos/watch/a5b86864-8e43-4138-b6d6-ed48d2d4b63d",embed:"https://watch.ocaml.org/videos/embed/a5b86864-8e43-4138-b6d6-ed48d2d4b63d",year:2020},tl:{hd:{title:"The Final Pieces of the OCaml Documentation Puzzle",slug:"the-final-pieces-of-the-ocaml-documentation-puzzle",description:"Rendering OCaml document is widely known as a very difficult task: The ever-evolving OCaml module system is extremely rich and can include complex set of inter-dependencies that are both difficult to compute and to render in a concise document. Its tasks are even harder than the typechecker as it also needs to keep track of documentation comments precisely and efficiently. As an example, signatures such as include F(X).T and destructive substitutions were never handled properly by any documentation generator.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:0},paper:"The final pieces of the OCaml documentation puzzle",link:"https://watch.ocaml.org/videos/watch/2acebff9-25fa-4733-83cc-620a65b12251",embed:"https://watch.ocaml.org/videos/embed/2acebff9-25fa-4733-83cc-620a65b12251",year:2020},tl:{hd:{title:"OCaml-CI: A Zero-Configuration CI",slug:"ocaml-ci-a-zero-configuration-ci",description:"OCaml-CI is a CI service for OCaml projects. It uses metadata from the project\u2019s opam and dune files to work out what to build, and uses caching to make builds fast. It automatically tests projects against multiple OCaml versions and OS platforms. The CI has been deployed on around 50 projects so far on GitHub, and many of them see response times an order of magnitude quicker than with less integrated CI solutions. This talk will introduce the CI service and then look at some of the technologies used to build it.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:0},paper:"OCaml-CI: A Zero-Configuration CI",link:"https://watch.ocaml.org/videos/watch/0fee79e8-715a-400b-bfcc-34c3610f4890",embed:"https://watch.ocaml.org/videos/embed/0fee79e8-715a-400b-bfcc-34c3610f4890",year:2020},tl:{hd:{title:"State of the OCaml Platform 2020",slug:"state-of-the-ocaml-platform-2020",description:"This talk covers: integrated development environments, next steps for the OCaml Platform and plans for 2020-2021",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:{hd:"ocaml-platform",tl:0}},paper:void 0,link:"https://watch.ocaml.org/videos/watch/0e2070fd-798b-47f7-8e69-ef75e967e516",embed:"https://watch.ocaml.org/videos/embed/0e2070fd-798b-47f7-8e69-ef75e967e516",year:2020},tl:{hd:{title:"Parallelising your OCaml Code with Multicore OCaml",slug:"parallelising-your-ocaml-code-with-multicore-ocaml",description:"This presentation will take the attendees through the following steps aimed at developing parallel programs with Multicore OCaml: installing the latest Multicore OCaml compiler, brief overview of the low-level API for parallel programming, a tour of domainslib \u2013 a high-level parallel programming library for Multicore OCaml, common pitfalls when parallelising and tools for diagnosing Multicore OCaml performance.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:{hd:"multicore-ocaml",tl:0}},paper:"Parallelising your OCaml Code with Multicore OCaml",link:"https://watch.ocaml.org/videos/watch/ce20839e-4bfc-4d74-925b-485a6b052ddf",embed:"https://watch.ocaml.org/videos/embed/ce20839e-4bfc-4d74-925b-485a6b052ddf",year:2020},tl:{hd:{title:"Types in Amber",slug:"types-in-amber",description:"Coda is a new cryptocurrency that uses zk-SNARKs to dramatically reduce the size of data needed by nodes running its protocol. Nodes communicate in a format automatically derived from type definitions in OCaml source files. As the Coda software evolves, these formats for sent data may change. We wish to allow nodes running older versions of the software to communicate with newer versions. To achieve that, we identify stable types that must not change over time, so that their serializations also do not change.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:0},paper:"Types in Amber",link:"https://watch.ocaml.org/videos/watch/99b3dc75-9f93-4677-9f8b-076546725512",embed:"https://watch.ocaml.org/videos/embed/99b3dc75-9f93-4677-9f8b-076546725512",year:2020},tl:{hd:{title:"OCaml under the Hood: SmartPy",slug:"ocaml-under-the-hood-smartpy",description:"SmartPy is a complete system to develop smart-contracts for the Tezos blockchain. It is an embedded EDSL in python to write contracts and their test scenarios. It includes an online IDE, a chain explorer, and a command-line interface. Python is used to generate programs in an imperative, type-inferred, intermediate language called SmartML. SmartML is also the name of the OCaml library which provides an interpreter, a compiler to Michelson (the smart-contract language of Tezos), as well as a scenario \u201con-chain\u201d interpreter. The IDE uses a mix of OCaml built with js_of_ocaml and pure Javascript. The command-line interface also builds with js_of_ocaml to run on Node.js.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:0},paper:"OCaml Under the Hood: SmartPy",link:"https://watch.ocaml.org/videos/watch/7446ad4d-4ae2-4e1a-bc38-af8f71e8ebd8",embed:"https://watch.ocaml.org/videos/embed/7446ad4d-4ae2-4e1a-bc38-af8f71e8ebd8",year:2020},tl:{hd:{title:"LexiFi Runtime Types",slug:"lexifi-runtime-types",description:"OCaml programmers make deliberate use of abstract data types for composing safe and reliable software systems. The OCaml compiler relies on the invariants imposed by the type system to produce efficient and compact runtime data representations. Being no longer relevant, the type information is discarded after compilation. The resulting performance is a key feature of the OCaml language.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:0},paper:"LexiFi Runtime Types",link:"https://watch.ocaml.org/videos/watch/cc7e3242-0bef-448a-aa13-8827bba933e3",embed:"https://watch.ocaml.org/videos/embed/cc7e3242-0bef-448a-aa13-8827bba933e3",year:2020},tl:{hd:{title:"The ImpFS Filesystem",slug:"the-impfs-filesystem",description:"This proposal describes a presentation to be given at the OCaml\u201920 workshop. The presentation will cover a new OCaml filesystem, ImpFS, and the related libraries. The filesystem makes use of a B-tree library presented at OCaml\u201917, and a key-value store presented at ML\u201919. In addition, there are a number of other support libraries that may be of interest to the community. ImpFS represents a single point in the filesystem design space, but we hope that the libraries we have developed will enable others to build further filesystems with novel features.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:0},paper:"The ImpFS Filesystem",link:"https://watch.ocaml.org/videos/watch/28545b27-4637-47a5-8edd-6b904daef19c",embed:"https://watch.ocaml.org/videos/embed/28545b27-4637-47a5-8edd-6b904daef19c",year:2020},tl:{hd:{title:"Irmin v2",slug:"irmin-v2",description:"Irmin is an OCaml library for building distributed databases with the same design principles as Git. Existing Git users will find many familiar features: branching/merging, immutable causal history for all changes, and the ability to restore to any previous state. It has been extensively used by major software projects over the past few years such as Docker for Mac/Windows, and noticeably through DataKit, which powers hundreds of thousands monthly builds on the opam-repository CI contributors may be familiar with.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:{hd:"irmin",tl:0}},paper:"Irmin v2",link:"https://watch.ocaml.org/videos/watch/53e497b0-898f-4c85-8da9-39f65ef0e0b1",embed:"https://watch.ocaml.org/videos/embed/53e497b0-898f-4c85-8da9-39f65ef0e0b1",year:2020},tl:{hd:{title:"Why OCaml",slug:"why-ocaml",description:"A summary of why Jane Street uses OCaml, including a discussion of how OCaml fits into the broader space of programming languages. Given to our summer interns.",people:0,kind:"Lecture",tags:{hd:"jane-street",tl:0},paper:void 0,link:"https://watch.ocaml.org/videos/watch/3abacf08-a3a1-405c-975b-a4efb54f0dd0",embed:"https://watch.ocaml.org/videos/embed/3abacf08-a3a1-405c-975b-a4efb54f0dd0",year:2015},tl:{hd:{title:"AD-OCaml: Algorithmic Differentiation for OCaml",slug:"ad-ocaml-algorithmic-differentiation-for-ocaml",description:"AD-OCaml is a library framework for calculating mathematically exact derivatives and deep power series approximations of almost arbitrary OCaml programs via algorithmic differentiation. Unlike similar frameworks, this includes programs with side effects, aliasing, and programs with nested derivative operators. The framework also offers implicit parallelization of both user programs and their transformations.\n\nThe presentation will provide a short introduction to the mathematical problem, the difficulties of implementing a solution, the design of the library, and a demonstration of its capabilities.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:0},paper:"AD-OCaml: Algorithmic Differentiation for OCaml",link:"https://watch.ocaml.org/videos/watch/c9e85690-732f-4b03-836f-2ee0fd8f0658",embed:"https://watch.ocaml.org/videos/embed/c9e85690-732f-4b03-836f-2ee0fd8f0658",year:2020},tl:{hd:{title:"API migration: compare transformed",slug:"api-migration-compare-transformed",description:"In this talk we describe our experience in using an automatic API-migration strategy dedicated at changing the signatures of OCaml functions, using the Rotor refactoring tool for OCaml. We perform a case study on open source Jane Street libraries by using Rotor to refactor comparison functions so that they return a more precise variant type rather than an integer. We discuss the difficulties of refactoring the Jane Street code base, which makes extensive use of ppx macros, and ongoing work implementing new refactorings.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:0},paper:"API migration: compare transformed",link:"https://watch.ocaml.org/videos/watch/c46b925b-bd77-404f-ac5d-5dab65047529",embed:"https://watch.ocaml.org/videos/embed/c46b925b-bd77-404f-ac5d-5dab65047529",year:2020},tl:{hd:{title:"A Simple State-Machine Framework for Property-Based Testing in OCaml",slug:"a-simple-state-machine-framework-for-property-based-testing-in-ocaml",description:"Since their inception, state-machine frameworks have proven their worth by finding defects in everything from the underlying AUTOSAR components of Volvo cars to digital invoicing systems. These case studies were carried out with Erlang\u2019s commercial QuickCheck state-machine framework from Quviq, but such frameworks are now also available for Haskell, F#, Scala, Elixir, Java, etc. We present a typed state-machine framework for OCaml based on the QCheck library and illustrate a number of concepts common to all such frameworks: state modeling, commands, interpreting commands, preconditions, and agreement checking.",people:0,kind:"Conference",tags:{hd:"ocaml-workshop",tl:0},paper:"A Simple State-Machine Framework for Property-Based Testing in OCaml",link:"https://watch.ocaml.org/videos/watch/08b429ea-2eb8-427d-a625-5495f4ee0fef",embed:"https://watch.ocaml.org/videos/embed/08b429ea-2eb8-427d-a625-5495f4ee0fef",year:2020},tl:0}}}}}}}}}}}}}},p={hd:{title:"Up and Running with OCaml",slug:"up-and-running-with-ocaml",description:"Help you install OCaml, the Dune build system, and support for your favourite text editor or IDE.\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"getting-started",tl:0},users:{hd:"Beginner",tl:0},body_md:"\nThis page will help you install OCaml, the Dune build system, and support for\nyour favourite text editor or IDE. These instructions work on Windows, Unix\nsystems like Linux, and macOS.\n\n## Installing OCaml\n\nThere are two procedures: one for Unix-like systems, and one for Windows.\n\n### For Linux and macOS\n\nWe will install OCaml using opam, the OCaml package manager.  We will also use\nopam when we wish to install third-party OCaml libraries.\n\n**For macOS**\n\n```\n# Homebrew\nbrew install opam\n\n# MacPort\nport install opam\n```\n\n**For Linux** the preferred way is to use your system's package manager on\nLinux (e.g `apt-get install opam` or similar). [Details of all installation\nmethods.](https://opam.ocaml.org/doc/Install.html)\n\nThen, we install an OCaml compiler:\n\n```\n# environment setup\nopam init\neval `opam env`\n\n# install given version of the compiler\nopam switch create 4.11.1\neval `opam env`\n```\n\nNow, OCaml is up and running:\n\n```\n$ which ocaml\n/Users/frank/.opam/4.11.1/bin/ocaml\n\n$ ocaml -version\nThe OCaml toplevel, version 4.11.1\n```\n\n**For either Linux or macOS** as an alternative, a binary distribution of opam is\navailable:\n\n```\nsh <(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)\n```\n\n### For Windows\n\nWe use the [OCaml for Windows](https://fdopen.github.io/opam-repository-mingw/)\ninstaller which comes in 32bit and 64bit versions. This installer gives you\nopam and OCaml installations all in one go. It is used from within a Cygwin\nenvironment, but the executables produced have no dependency on Cygwin at all.\n\n## The OCaml top level\n\nOCaml comes with two compilers: for native code, and for byte code. We shall\nuse one of those in a moment. But first, let's use OCaml's top level (sometimes\nknown as a REPL in other languages):\n\n```\n$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n\n```\n\nWe typed the phrase `1 + 2 * 3` and then signalled to OCaml that we had\nfinished by typing `;;` followed by the Enter key. OCaml calculated the\nresult, `7` and its type `int` and showed them to us. We exit by running the\nbuilt-in `exit` function with exit code 0:\n\n```\n$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n# exit 0;;\n$\n```\n\nThere are two ways to improve your experience with the OCaml top level: you can\ninstall the popular [`rlwrap`](https://github.com/hanslub42/rlwrap) on your\nsystem and invoke `rlwrap ocaml` instead of `ocaml` to get line-editing\nfacilities inside the OCaml top level, or you can install the alternative top\nlevel `utop` using opam:\n\n```\n$ opam install utop\n```\n\nWe run it by typing `utop` instead of `ocaml`. You can read more about\n[utop](https://github.com/ocaml-community/utop).\n\n## Installing the Dune build system\n\nDune is a build system for OCaml. It takes care of all the low level details of\nOCaml compilation. We install it with opam:\n\n```\n$ opam install dune\nThe following actions will be performed:\n  - install dune 2.7.1\n\n<><> Gathering sources ><><><><><><><><><><><><><><><><><><><><><><><><>\n[default] https://opam.ocaml.org/2.0.7/archives/dune.2.7.1+opam.tar.gz\ndownloaded\n\n<><> Processing actions <><><><><><><><><><><><><><><><><><><><><><><><>\n-> installed dune.2.7.1\nDone.\n```\n\n## A first project\n\nLet's begin the simplest project with Dune and OCaml. We create a new directory\nand ask `dune` to initialise a new project:\n\n```\n$ mkdir helloworld\n$ cd helloworld/\n$ dune init exe helloworld\nSuccess: initialized executable component named helloworld\n```\n\nBuilding our program is as simple as typing `dune build`:\n\n```\n$ dune build\nInfo: Creating file dune-project with this contents:\n| (lang dune 2.7)\nDone: 8/11 (jobs: 1)\n```\n\nWhen we change our program, we type `dune build` again to make a new\nexecutable. We can run the executable with `dune exec` (it's called\n`helloworld.exe` even when we're not using Windows):\n\n```\n$ dune exec ./helloworld.exe\nHello, World!        \n```\n\nLet's look at the contents of our new directory. Dune has added the\n`helloworld.ml` file, which is our OCaml program. It has also added our `dune`\nfile, which tells dune how to build the program, and a `_build` subdirectory,\nwhich is dune's working space.\n\n```\n$ ls\n_build\t\tdune\t\thelloworld.ml\n```\n\nThe `helloworld.exe` executable is stored inside the `_build/default` subdirectory, so\nit's easier to run with `dune exec`. To ship the executable, we can just copy\nit from inside `_build/default` to somewhere else.\n\nHere is the contents of the automatically-generated `dune` file. When we want\nto add components to your project, such as third-party libraries, we edit this\nfile.\n\n```\n(executable\n (name helloworld))\n```\n\n## Editor support for OCaml\n\nFor **Visual Studio Code**, and other editors support the Language Server\nProtocol, the OCaml language server can be installed with opam:\n\n```\n$ opam install ocaml-lsp-server\n```\n\nNow, we install the OCaml Platform Visual Studio Code extension from the Visual\nStudio Marketplace.\n\nUpon first loading an OCaml source file, you may be prompted to select the\ntoolchain in use: pick OCaml the version of OCaml you are using, e.g. 4.11.1\nfrom the list. Now, help is available by hovering over symbols in your program:\n\n![Visual Studio Code](/tutorials/vscode.png \"\")\n\n**On Windows**, we must launch Visual Studio Code from within the Cygwin window,\nrather than by clicking on its icon (otherwise, the language server will not be\nfound):\n\n```\n$ /cygdrive/c/Users/Frank\\ Smith/AppData/Local/Programs/Microsoft\\ VS\\ Code/Code.exe\n```\n\n**For Vim and Emacs**, install the [Merlin](https://github.com/ocaml/merlin)\nsystem using opam:\n\n```\n$ opam install merlin\n```\n\nThe installation procedure will print instructions on how to link Merlin with\nyour editor.\n\n**On Windows**, when using Vim, the default cygwin Vim will not work with\nMerlin. You will need install Vim separately. In addition to the usual\ninstructions printed when installing Merlin, you may need to set the PATH in\nVim:\n\n```\nlet $PATH .= \";\".substitute(system('opam config var bin'),'\\n$','','''')\n```\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#installing-ocaml">Installing OCaml</a>\n</li>\n<li><a href="#the-ocaml-top-level">The OCaml top level</a>\n</li>\n<li><a href="#installing-the-dune-build-system">Installing the Dune build system</a>\n</li>\n<li><a href="#a-first-project">A first project</a>\n</li>\n<li><a href="#editor-support-for-ocaml">Editor support for OCaml</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>This page will help you install OCaml, the Dune build system, and support for\nyour favourite text editor or IDE. These instructions work on Windows, Unix\nsystems like Linux, and macOS.</p>\n<h2 id="installing-ocaml">Installing OCaml</h2>\n<p>There are two procedures: one for Unix-like systems, and one for Windows.</p>\n<h3 id="for-linux-and-macos">For Linux and macOS</h3>\n<p>We will install OCaml using opam, the OCaml package manager.  We will also use\nopam when we wish to install third-party OCaml libraries.</p>\n<p><strong>For macOS</strong></p>\n<pre><code># Homebrew\nbrew install opam\n\n# MacPort\nport install opam\n</code></pre>\n<p><strong>For Linux</strong> the preferred way is to use your system\'s package manager on\nLinux (e.g <code>apt-get install opam</code> or similar). <a href="https://opam.ocaml.org/doc/Install.html">Details of all installation\nmethods.</a></p>\n<p>Then, we install an OCaml compiler:</p>\n<pre><code># environment setup\nopam init\neval `opam env`\n\n# install given version of the compiler\nopam switch create 4.11.1\neval `opam env`\n</code></pre>\n<p>Now, OCaml is up and running:</p>\n<pre><code>$ which ocaml\n/Users/frank/.opam/4.11.1/bin/ocaml\n\n$ ocaml -version\nThe OCaml toplevel, version 4.11.1\n</code></pre>\n<p><strong>For either Linux or macOS</strong> as an alternative, a binary distribution of opam is\navailable:</p>\n<pre><code>sh &lt;(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)\n</code></pre>\n<h3 id="for-windows">For Windows</h3>\n<p>We use the <a href="https://fdopen.github.io/opam-repository-mingw/">OCaml for Windows</a>\ninstaller which comes in 32bit and 64bit versions. This installer gives you\nopam and OCaml installations all in one go. It is used from within a Cygwin\nenvironment, but the executables produced have no dependency on Cygwin at all.</p>\n<h2 id="the-ocaml-top-level">The OCaml top level</h2>\n<p>OCaml comes with two compilers: for native code, and for byte code. We shall\nuse one of those in a moment. But first, let\'s use OCaml\'s top level (sometimes\nknown as a REPL in other languages):</p>\n<pre><code>$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n\n</code></pre>\n<p>We typed the phrase <code>1 + 2 * 3</code> and then signalled to OCaml that we had\nfinished by typing <code>;;</code> followed by the Enter key. OCaml calculated the\nresult, <code>7</code> and its type <code>int</code> and showed them to us. We exit by running the\nbuilt-in <code>exit</code> function with exit code 0:</p>\n<pre><code>$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n# exit 0;;\n$\n</code></pre>\n<p>There are two ways to improve your experience with the OCaml top level: you can\ninstall the popular <a href="https://github.com/hanslub42/rlwrap"><code>rlwrap</code></a> on your\nsystem and invoke <code>rlwrap ocaml</code> instead of <code>ocaml</code> to get line-editing\nfacilities inside the OCaml top level, or you can install the alternative top\nlevel <code>utop</code> using opam:</p>\n<pre><code>$ opam install utop\n</code></pre>\n<p>We run it by typing <code>utop</code> instead of <code>ocaml</code>. You can read more about\n<a href="https://github.com/ocaml-community/utop">utop</a>.</p>\n<h2 id="installing-the-dune-build-system">Installing the Dune build system</h2>\n<p>Dune is a build system for OCaml. It takes care of all the low level details of\nOCaml compilation. We install it with opam:</p>\n<pre><code>$ opam install dune\nThe following actions will be performed:\n  - install dune 2.7.1\n\n&lt;&gt;&lt;&gt; Gathering sources &gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;\n[default] https://opam.ocaml.org/2.0.7/archives/dune.2.7.1+opam.tar.gz\ndownloaded\n\n&lt;&gt;&lt;&gt; Processing actions &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;\n-&gt; installed dune.2.7.1\nDone.\n</code></pre>\n<h2 id="a-first-project">A first project</h2>\n<p>Let\'s begin the simplest project with Dune and OCaml. We create a new directory\nand ask <code>dune</code> to initialise a new project:</p>\n<pre><code>$ mkdir helloworld\n$ cd helloworld/\n$ dune init exe helloworld\nSuccess: initialized executable component named helloworld\n</code></pre>\n<p>Building our program is as simple as typing <code>dune build</code>:</p>\n<pre><code>$ dune build\nInfo: Creating file dune-project with this contents:\n| (lang dune 2.7)\nDone: 8/11 (jobs: 1)\n</code></pre>\n<p>When we change our program, we type <code>dune build</code> again to make a new\nexecutable. We can run the executable with <code>dune exec</code> (it\'s called\n<code>helloworld.exe</code> even when we\'re not using Windows):</p>\n<pre><code>$ dune exec ./helloworld.exe\nHello, World!        \n</code></pre>\n<p>Let\'s look at the contents of our new directory. Dune has added the\n<code>helloworld.ml</code> file, which is our OCaml program. It has also added our <code>dune</code>\nfile, which tells dune how to build the program, and a <code>_build</code> subdirectory,\nwhich is dune\'s working space.</p>\n<pre><code>$ ls\n_build\t\tdune\t\thelloworld.ml\n</code></pre>\n<p>The <code>helloworld.exe</code> executable is stored inside the <code>_build/default</code> subdirectory, so\nit\'s easier to run with <code>dune exec</code>. To ship the executable, we can just copy\nit from inside <code>_build/default</code> to somewhere else.</p>\n<p>Here is the contents of the automatically-generated <code>dune</code> file. When we want\nto add components to your project, such as third-party libraries, we edit this\nfile.</p>\n<pre><code>(executable\n (name helloworld))\n</code></pre>\n<h2 id="editor-support-for-ocaml">Editor support for OCaml</h2>\n<p>For <strong>Visual Studio Code</strong>, and other editors support the Language Server\nProtocol, the OCaml language server can be installed with opam:</p>\n<pre><code>$ opam install ocaml-lsp-server\n</code></pre>\n<p>Now, we install the OCaml Platform Visual Studio Code extension from the Visual\nStudio Marketplace.</p>\n<p>Upon first loading an OCaml source file, you may be prompted to select the\ntoolchain in use: pick OCaml the version of OCaml you are using, e.g. 4.11.1\nfrom the list. Now, help is available by hovering over symbols in your program:</p>\n<p><img src="/tutorials/vscode.png" alt="Visual Studio Code" title="" /></p>\n<p><strong>On Windows</strong>, we must launch Visual Studio Code from within the Cygwin window,\nrather than by clicking on its icon (otherwise, the language server will not be\nfound):</p>\n<pre><code>$ /cygdrive/c/Users/Frank\\ Smith/AppData/Local/Programs/Microsoft\\ VS\\ Code/Code.exe\n</code></pre>\n<p><strong>For Vim and Emacs</strong>, install the <a href="https://github.com/ocaml/merlin">Merlin</a>\nsystem using opam:</p>\n<pre><code>$ opam install merlin\n</code></pre>\n<p>The installation procedure will print instructions on how to link Merlin with\nyour editor.</p>\n<p><strong>On Windows</strong>, when using Vim, the default cygwin Vim will not work with\nMerlin. You will need install Vim separately. In addition to the usual\ninstructions printed when installing Merlin, you may need to set the PATH in\nVim:</p>\n<pre><code>let $PATH .= &quot;;&quot;.substitute(system(\'opam config var bin\'),\'\\n$\',\'\',\'\'\'\')\n</code></pre>\n'},tl:{hd:{title:"A First Hour with OCaml",slug:"a-first-hour-with-ocaml",description:"Discover the OCaml programming language in this longer tutorial that takes you from absolute beginner to someone who is able to write programs in OCaml.\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"getting-started",tl:0},users:{hd:"Beginner",tl:0},body_md:"\nYou may follow along with this tutorial with just a basic OCaml installation,\nas described in [Up and Running](up_and_running.html).\n\nAlternatively, you may follow almost all of it by running OCaml in your browser\nusing [TryOCaml](https://try.ocamlpro.com), with no installation required!!!\n\n## Running OCaml code\n\nThe easiest way to get started is to run an interactive session in\nyour browser thanks to [TryOCaml](https://try.ocamlpro.com).\n\nTo install OCaml on your computer, see the [Install](/docs/install.html) documentation.\n\nTo quickly try small OCaml expressions, you can use an interactive\ntoplevel, or REPL (Read\u2013Eval\u2013Print Loop). The `ocaml` command provides\na very basic toplevel (you should install `rlwrap` through your system\npackage manager and run `rlwrap ocaml` to get history navigation).\n\nThe recommended alternative REPL [utop](https://github.com/diml/utop) may be\ninstalled through [OPAM](/docs/install.html#OPAM) or your system package\nmanager. It has the same basic interface but is much more convenient to use\n(history navigation, auto-completion, etc.).\n\nUse `;;` to indicate that you've finished entering each expression and prompt OCaml to evaluate it. Here is what running `ocaml` looks like:\n\n```console\n$ ocaml\n        OCaml version OCaml version 4.12.0\n\n# 1 + 1;;\n- : int = 2\n```\n\nThis is how running the same code looks when using `utop`:\n\n```console\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\n       \u2502 Welcome to utop version 2.7.0 (using OCaml version 4.12.0)! \u2502     \n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \n\nType #utop_help for help about using utop.\n\n\u2500( 10:12:16 )\u2500< command 0 >\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nutop # 1 + 1;;\n- : int = 2\n```\n\n## Comments\n\nOCaml comments are delimited by `(*` and `*)`, like this:\n\n```ocaml\n(* This is a single-line comment. *)\n\n(* This is a\n   multi-line\n   comment.\n*)\n```\n\nIn other words, the commenting convention is very similar to original C\n(`/* ... */`). There is no single-line comment syntax (like\n`# ...` in Python or `// ...` in C99/C++/Java).\n\nOCaml counts nested `(* ... *)` blocks, and this allows you to comment\nout regions of code very easily:\n\n```ocaml\n(* This code is broken ...\n\n(* Primality test. *)\nlet is_prime n =\n  (* note to self: ask about this on the mailing lists *) XXX\n\n*)\n```\n\n## Calling functions\n\nLet's say you've written a function \u2014 we'll call it `repeated` \u2014 which\ntakes a string `s` and a number `n`, and returns a new string which\ncontains original `s` repeated `n` times.\n\nIn most C-derived languages a call to this function will look like this:\n\n```C\nrepeated (\"hello\", 3)  /* this is C code */\n```\n\nThis means \"call the function `repeated` with two arguments, first\nargument the string hello and second argument the number 3\".\n\nOCaml, in common with other functional languages, writes and brackets\nfunction calls differently, and this is the cause of many mistakes. Here\nis the same function call in OCaml:\n\n```ocaml\nlet repeated a b = a ^ (Int.to_string b);;\nrepeated \"hello\" 3  (* this is OCaml code *)\n```\n\nNote \u2014 **no** brackets, and **no** comma between the arguments.\n\nThe syntax `repeated (\"hello\", 3)` **is** meaningful in OCaml. It means\n\"call the function `repeated` with ONE argument, that argument being a\n'pair' structure of two elements\". Of course that would be a mistake,\nbecause the `repeated` function is expecting two arguments, not one, and\nthe first argument should be a string, not a pair. But let's not worry\nabout pairs (\"tuples\") just yet. Instead, just remember that it's a\nmistake to put the brackets and commas in around function call\narguments.\n\nLet's have another function \u2014 `prompt_string` \u2014 which takes a string to\nprompt and returns the string entered by the user. We want to pass this\nstring into `repeated`. Here are the C and OCaml versions:\n\n```C\n/* C code: */\nrepeated (prompt_string (\"Name please: \"), 3)\n```\n\n```ocaml\nlet prompt_string p = \"\";;\n(* OCaml code: *)\nrepeated (prompt_string \"Name please: \") 3\n```\n\nTake a careful look at the bracketing and the missing comma. In the\nOCaml version, the brackets enclose the first argument of repeated\nbecause that argument is the result of another function call. In general\nthe rule is: \"bracket around the whole function call \u2014 don't put\nbrackets around the arguments to a function call\". Here are some more\nexamples:\n\n```ocaml\nlet f a b c = \"\";;\nlet g a = \"\";;\nlet f2 a = \"\";;\nlet g2 a b = \"\";;\nf 5 (g \"hello\") 3;;    (* f has three arguments, g has one argument *)\nf2 (g2 3 4)            (* f2 has one argument, g2 has two arguments *)\n```\n\n```ocaml\n# repeated (\"hello\", 3)     (* OCaml will spot the mistake *)\nLine 1, characters 10-22:\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n```\n\n## Defining a function\n\nWe all know how to define a function (or static method, in Java)\nin our existing languages. How do we do it in OCaml?\n\nThe OCaml syntax is pleasantly concise. Here's a function which takes\ntwo floating point numbers and calculates the average:\n\n```ocaml\nlet average a b =\n  (a +. b) /. 2.0\n```\n\nType this into the OCaml interactive toplevel (on Unix, type the command `ocaml`\nfrom the shell) and you'll see this:\n\n```ocaml\n# let average a b =\n    (a +. b) /. 2.0;;\nval average : float -> float -> float = <fun>\n```\n\nIf you look at the function definition closely, and also at what OCaml\nprints back at you, you'll have a number of questions:\n\n* What are those periods in `+.` and `/.` for?\n* What does `float -> float -> float` mean?\n\nI'll answer those questions in the next sections, but first I want to go\nand define the same function in C (the Java definition would be fairly\nsimilar to C), and hopefully that should raise even more questions.\nHere's our C version of `average`:\n\n```C\ndouble average (double a, double b)\n{\n  return (a + b) / 2;\n}\n```\n\nNow look at our much shorter OCaml definition above. Hopefully you'll be\nasking:\n\n* Why don't we have to define the types of `a` and `b` in the OCaml\n  version? How does OCaml know what the types are (indeed, *does*\n  OCaml know what the types are, or is OCaml completely dynamically\n  typed?).\n* In C, the `2` is implicitly converted into a `double`, can't OCaml\n  do the same thing?\n* What is the OCaml way to write `return`?\n\nOK, let's get some answers.\n\n* OCaml is a strongly *statically typed* language (in other words,\n  there's nothing dynamic going on between int, float and string).\n* OCaml uses *type inference* to work out the types, so you don't have\n  to.  If you use the OCaml interactive toplevel as above, then OCaml\n  will tell you\n  its inferred type for your function.\n* OCaml doesn't do any implicit casting. If you want a float, you have\n  to write `2.0` because `2` is an integer. OCaml does **no automatic\n  conversion** between int, float, string or any other type.\n* As a side-effect of type inference in OCaml, functions (including\n  operators) can't have overloaded definitions. OCaml defines `+` as\n  the *integer* addition function. To add floats, use `+.` (note the\n  trailing period). Similarly, use `-.`, `*.`, `/.` for other float\n  operations.\n* OCaml doesn't have a `return` keyword \u2014 the last expression in a\n  function becomes the result of the function automatically.\n\nWe will present more details in the following sections and chapters.\n\n## Basic types\n\nThe basic types in OCaml are:\n\n```text\nOCaml type  Range\n\nint         31-bit signed int (roughly +/- 1 billion) on 32-bit\n            processors, or 63-bit signed int on 64-bit processors\nfloat       IEEE double-precision floating point, equivalent to C's double\nbool        A boolean, written either 'true' or 'false'\nchar        An 8-bit character\nstring      A string\nunit        Written as ()\n```\n\nOCaml uses one of the bits in an `int` internally in order to be able to\nautomatically manage the memory use (garbage collection). This is why\nthe basic `int` is 31 bits, not 32 bits (63 bits if you're using a 64\nbit platform). In practice this isn't an issue except in a few\nspecialised cases. For example if you're counting things in a loop, then\nOCaml limits you to counting up to 1 billion instead of 2 billion. However if you need to do things\nsuch as processing 32 bit types (eg. you're writing crypto code or a\nnetwork stack), OCaml provides a `nativeint` type which matches the\nnative integer type for your platform.\n\nOCaml doesn't have a basic unsigned integer type, but you can get the\nsame effect using `nativeint`. OCaml doesn't have built-in single-precision \nfloating point numbers.\n\nOCaml provides a `char` type which is used for characters, written `'x'`\nfor example. Unfortunately the `char` type does not support Unicode or\nUTF-8, There are [comprehensive Unicode libraries](https://github.com/yoriyuki/Camomile)\nwhich provide this functionality.\n\nStrings are not just lists of characters. They have their own, more\nefficient internal representation. Strings are immutable.\n\nThe `unit` type is sort of like `void` in C, but we'll talk about it\nmore below.\n\n## Implicit vs. explicit casts\n\nIn C-derived languages ints get promoted to floats in certain\ncircumstances. For example if you write `1 + 2.5` then the first\nargument (which is an integer) is promoted to a floating point number,\nand the result is also a floating point number. It's as if you had\nwritten `((double) 1) + 2.5`, but all done implicitly.\n\nOCaml never does implicit casts like this. In OCaml, `1 + 2.5` is a type\nerror. The `+` operator in OCaml requires two ints as arguments, and\nhere we're giving it an int and a float, so it reports this error:\n\n```ocaml\n# 1 + 2.5;;\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n```\n\nTo add two floats together you need to use a different operator, `+.`\n(note the trailing period).\n\nOCaml doesn't promote ints to floats automatically so this is also an\nerror:\n\n```ocaml\n# 1 +. 2.5\nLine 1, characters 1-2:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.'?\n```\n\nHere OCaml is now complaining about the first argument.\n\nWhat if you actually want to add an integer and a floating point number\ntogether? (Say they are stored as `i` and `f`). In OCaml you need to\nexplicitly cast:\n\n```ocaml\nlet i = 1;;\nlet f = 2.0;;\nfloat_of_int i +. f\n```\n\n`float_of_int` is a function which takes an `int` and returns a `float`.\nThere are a whole load of these functions, called such things as\n`int_of_float`, `char_of_int`, `int_of_char`, `string_of_int` and so on,\nand they mostly do what you expect.\n\nSince converting an `int` to a `float` is a particularly common\noperation, the `float_of_int` function has a shorter alias: the above\nexample could simply have been written\n\n```ocaml\nfloat i +. f\n```\n\n(Note that it is perfectly valid in OCaml for a type and a\nfunction to have the same name.)\n\n### Is implicit or explicit casting better?\n\nYou might think that these explicit casts are ugly, time-consuming even,\nand you have a point, but there are at least two arguments in their\nfavour. Firstly, OCaml needs this explicit casting to be able to do type\ninference (see below), and type inference is such a wonderful\ntime-saving feature that it easily offsets the extra keyboarding of\nexplicit casts. Secondly, if you've spent time debugging C programs\nyou'll know that (a) implicit casts cause errors which are hard to find,\nand (b) much of the time you're sitting there trying to work out where\nthe implicit casts happen. Making the casts explicit helps you in\ndebugging. Thirdly, some casts (particularly int <-> float) are\nactually very expensive operations. You do yourself no favours by hiding\nthem.\n\n## Ordinary functions and recursive functions\n\nUnlike in C-derived languages, a function isn't recursive unless you\nexplicitly say so by using `let rec` instead of just `let`. Here's an\nexample of a recursive function:\n\n```ocaml\n# let rec range a b =\n    if a > b then []\n    else a :: range (a + 1) b\nval range : int -> int -> int list = <fun>\n```\n\nNotice that `range` calls itself.\n\nThe only difference between `let` and `let rec` is in the scoping of the\nfunction name. If the above function had been defined with just `let`,\nthen the call to `range` would have tried to look for an existing\n(previously defined) function called `range`, not the\ncurrently-being-defined function. Using `let` (without `rec`) allows you\nto re-define a value in terms of the previous definition. For example:\n\n```ocaml\n# let positive_sum a b = \n    let a = max a 0\n    and b = max b 0 in\n    a + b\nval positive_sum : int -> int -> int = <fun>\n```\n\nThis redefinition hides the previous \"bindings\" of `a` and `b` from the\nfunction definition. In some situations coders prefer this pattern to\nusing a new variable name (`let a_pos = max a 0`) as it makes the old\nbinding inaccessible, so that only the latest values of `a` and `b` are\naccessible.\n\nThere is no performance difference between functions defined using `let`\nand functions defined using `let rec`, so if you prefer you could always\nuse the `let rec` form and get the same semantics as C-like languages.\n\n## Types of functions\n\nBecause of type inference you will rarely if ever need to explicitly\nwrite down the type of your functions. However, OCaml often prints out\nwhat it thinks are the types of your functions, so you need to know the\nsyntax for this. For a function `f` which takes arguments `arg1`,\n`arg2`, ... `argn`, and returns type `rettype`, the compiler will print:\n\n```\nf : arg1 -> arg2 -> ... -> argn -> rettype\n```\n\nThe arrow syntax looks strange now, but when we come to so-called\n\"currying\" later you'll see why it was chosen. For now I'll just give\nyou some examples.\n\nOur function `repeated` which takes a string and an integer and returns\na string has type:\n\n```ocaml\n# repeated\n- : string -> int -> string = <fun>\n```\n\nOur function `average` which takes two floats and returns a float has\ntype:\n\n```ocaml\n# average\n- : float -> float -> float = <fun>\n```\n\nThe OCaml standard `int_of_char` casting function:\n\n```ocaml\n# int_of_char\n- : char -> int = <fun>\n```\n\nIf a function returns nothing (`void` for C and Java programmers), then\nwe write that it returns the `unit` type. Here, for instance, is the\nOCaml equivalent of C's *[fputc(3)](https://pubs.opengroup.org/onlinepubs/009695399/functions/fputc.html)*:\n\n```ocaml\n# output_char\n- : out_channel -> char -> unit = <fun>\n```\n\n### Polymorphic functions\n\nNow for something a bit stranger. What about a function which takes\n*anything* as an argument? Here's an odd function which takes an\nargument, but just ignores it and always returns 3:\n\n```ocaml\nlet give_me_a_three x = 3\n```\n\nWhat is the type of this function? In OCaml we use a special placeholder\nto mean \"any type you fancy\". It's a single quote character followed by\na letter. The type of the above function would normally be written:\n\n```ocaml\n# give_me_a_three\n- : 'a -> int = <fun>\n```\n\nwhere `'a` (pronounced alpha) really does mean any type. You can, for example, call this\nfunction as `give_me_a_three \"foo\"` or `give_me_a_three 2.0` and both\nare quite valid expressions in OCaml.\n\nIt won't be clear yet why polymorphic functions are useful, but they are\nvery useful and very common, and so we'll discuss them later on. (Hint:\npolymorphism is kind of like templates in C++ or generics in Java).\n\n## Type inference\n\nSo the theme of this tutorial is that functional languages have many\nreally cool features, and OCaml is a language which has all of these\nreally cool features stuffed into it at once, thus making it a very\npractical language for real programmers to use. But the odd thing is\nthat most of these cool features have nothing to do with \"functional\nprogramming\" at all. In fact, I've come to the first really cool\nfeature, and I still haven't talked about why functional programming is\ncalled \"functional\". Anyway, here's the first really cool feature: type\ninference.\n\nSimply put: you don't need to declare the types of your functions and\nvariables, because OCaml will just figure them out for you!\n\nIn addition OCaml goes on to check all your types match up (even across\ndifferent files).\n\nBut OCaml is also a practical language, and for this reason it contains\nbackdoors into the type system allowing you to bypass this checking on\nthe rare occasions that it is sensible to do this. Only gurus will\nprobably need to bypass the type checking.\n\nLet's go back to the `average` function which we typed into the OCaml\ninteractive toplevel:\n\n```ocaml\n# let average a b =\n    (a +. b) /. 2.0\nval average : float -> float -> float = <fun>\n```\n\nOCaml worked out all on its own that the function takes\ntwo `float` arguments and returns a `float`!\n\nHow did it do this? Firstly it looks at where `a` and `b` are used,\nnamely in the expression `(a +. b)`. Now, `+.` is itself a function\nwhich always takes two `float` arguments, so by simple deduction, `a`\nand `b` must both also have type `float`.\n\nSecondly, the `/.` function returns a `float`, and this is the same as\nthe return value of the `average` function, so `average` must return a\n`float`. The conclusion is that `average` has this type signature:\n\n```ocaml\n# average\n- : float -> float -> float = <fun>\n```\n\nType inference is obviously easy for such a short program, but it works\neven for large programs, and it's a major time-saving feature because it\nremoves a whole class of errors which cause segfaults,\n`NullPointerException`s and `ClassCastException`s in other languages (or\nimportant but often ignored runtime warnings).\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#running-ocaml-code">Running OCaml code</a>\n</li>\n<li><a href="#comments">Comments</a>\n</li>\n<li><a href="#calling-functions">Calling functions</a>\n</li>\n<li><a href="#defining-a-function">Defining a function</a>\n</li>\n<li><a href="#basic-types">Basic types</a>\n</li>\n<li><a href="#implicit-vs-explicit-casts">Implicit vs. explicit casts</a>\n</li>\n<li><a href="#ordinary-functions-and-recursive-functions">Ordinary functions and recursive functions</a>\n</li>\n<li><a href="#types-of-functions">Types of functions</a>\n</li>\n<li><a href="#type-inference">Type inference</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>You may follow along with this tutorial with just a basic OCaml installation,\nas described in <a href="up_and_running.html">Up and Running</a>.</p>\n<p>Alternatively, you may follow almost all of it by running OCaml in your browser\nusing <a href="https://try.ocamlpro.com">TryOCaml</a>, with no installation required!!!</p>\n<h2 id="running-ocaml-code">Running OCaml code</h2>\n<p>The easiest way to get started is to run an interactive session in\nyour browser thanks to <a href="https://try.ocamlpro.com">TryOCaml</a>.</p>\n<p>To install OCaml on your computer, see the <a href="/docs/install.html">Install</a> documentation.</p>\n<p>To quickly try small OCaml expressions, you can use an interactive\ntoplevel, or REPL (Read\u2013Eval\u2013Print Loop). The <code>ocaml</code> command provides\na very basic toplevel (you should install <code>rlwrap</code> through your system\npackage manager and run <code>rlwrap ocaml</code> to get history navigation).</p>\n<p>The recommended alternative REPL <a href="https://github.com/diml/utop">utop</a> may be\ninstalled through <a href="/docs/install.html#OPAM">OPAM</a> or your system package\nmanager. It has the same basic interface but is much more convenient to use\n(history navigation, auto-completion, etc.).</p>\n<p>Use <code>;;</code> to indicate that you\'ve finished entering each expression and prompt OCaml to evaluate it. Here is what running <code>ocaml</code> looks like:</p>\n<pre><code class="language-console">$ ocaml\n        OCaml version OCaml version 4.12.0\n\n# 1 + 1;;\n- : int = 2\n</code></pre>\n<p>This is how running the same code looks when using <code>utop</code>:</p>\n<pre><code class="language-console">\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\n       \u2502 Welcome to utop version 2.7.0 (using OCaml version 4.12.0)! \u2502     \n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \n\nType #utop_help for help about using utop.\n\n\u2500( 10:12:16 )\u2500&lt; command 0 &gt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nutop # 1 + 1;;\n- : int = 2\n</code></pre>\n<h2 id="comments">Comments</h2>\n<p>OCaml comments are delimited by <code>(*</code> and <code>*)</code>, like this:</p>\n<pre><code class="language-ocaml">(* This is a single-line comment. *)\n\n(* This is a\n   multi-line\n   comment.\n*)\n</code></pre>\n<p>In other words, the commenting convention is very similar to original C\n(<code>/* ... */</code>). There is no single-line comment syntax (like\n<code># ...</code> in Python or <code>// ...</code> in C99/C++/Java).</p>\n<p>OCaml counts nested <code>(* ... *)</code> blocks, and this allows you to comment\nout regions of code very easily:</p>\n<pre><code class="language-ocaml">(* This code is broken ...\n\n(* Primality test. *)\nlet is_prime n =\n  (* note to self: ask about this on the mailing lists *) XXX\n\n*)\n</code></pre>\n<h2 id="calling-functions">Calling functions</h2>\n<p>Let\'s say you\'ve written a function \u2014 we\'ll call it <code>repeated</code> \u2014 which\ntakes a string <code>s</code> and a number <code>n</code>, and returns a new string which\ncontains original <code>s</code> repeated <code>n</code> times.</p>\n<p>In most C-derived languages a call to this function will look like this:</p>\n<pre><code class="language-C">repeated (&quot;hello&quot;, 3)  /* this is C code */\n</code></pre>\n<p>This means &quot;call the function <code>repeated</code> with two arguments, first\nargument the string hello and second argument the number 3&quot;.</p>\n<p>OCaml, in common with other functional languages, writes and brackets\nfunction calls differently, and this is the cause of many mistakes. Here\nis the same function call in OCaml:</p>\n<pre><code class="language-ocaml">let repeated a b = a ^ (Int.to_string b);;\nrepeated &quot;hello&quot; 3  (* this is OCaml code *)\n</code></pre>\n<p>Note \u2014 <strong>no</strong> brackets, and <strong>no</strong> comma between the arguments.</p>\n<p>The syntax <code>repeated (&quot;hello&quot;, 3)</code> <strong>is</strong> meaningful in OCaml. It means\n&quot;call the function <code>repeated</code> with ONE argument, that argument being a\n\'pair\' structure of two elements&quot;. Of course that would be a mistake,\nbecause the <code>repeated</code> function is expecting two arguments, not one, and\nthe first argument should be a string, not a pair. But let\'s not worry\nabout pairs (&quot;tuples&quot;) just yet. Instead, just remember that it\'s a\nmistake to put the brackets and commas in around function call\narguments.</p>\n<p>Let\'s have another function \u2014 <code>prompt_string</code> \u2014 which takes a string to\nprompt and returns the string entered by the user. We want to pass this\nstring into <code>repeated</code>. Here are the C and OCaml versions:</p>\n<pre><code class="language-C">/* C code: */\nrepeated (prompt_string (&quot;Name please: &quot;), 3)\n</code></pre>\n<pre><code class="language-ocaml">let prompt_string p = &quot;&quot;;;\n(* OCaml code: *)\nrepeated (prompt_string &quot;Name please: &quot;) 3\n</code></pre>\n<p>Take a careful look at the bracketing and the missing comma. In the\nOCaml version, the brackets enclose the first argument of repeated\nbecause that argument is the result of another function call. In general\nthe rule is: &quot;bracket around the whole function call \u2014 don\'t put\nbrackets around the arguments to a function call&quot;. Here are some more\nexamples:</p>\n<pre><code class="language-ocaml">let f a b c = &quot;&quot;;;\nlet g a = &quot;&quot;;;\nlet f2 a = &quot;&quot;;;\nlet g2 a b = &quot;&quot;;;\nf 5 (g &quot;hello&quot;) 3;;    (* f has three arguments, g has one argument *)\nf2 (g2 3 4)            (* f2 has one argument, g2 has two arguments *)\n</code></pre>\n<pre><code class="language-ocaml"># repeated (&quot;hello&quot;, 3)     (* OCaml will spot the mistake *)\nLine 1, characters 10-22:\nError: This expression has type \'a * \'b\n       but an expression was expected of type string\n</code></pre>\n<h2 id="defining-a-function">Defining a function</h2>\n<p>We all know how to define a function (or static method, in Java)\nin our existing languages. How do we do it in OCaml?</p>\n<p>The OCaml syntax is pleasantly concise. Here\'s a function which takes\ntwo floating point numbers and calculates the average:</p>\n<pre><code class="language-ocaml">let average a b =\n  (a +. b) /. 2.0\n</code></pre>\n<p>Type this into the OCaml interactive toplevel (on Unix, type the command <code>ocaml</code>\nfrom the shell) and you\'ll see this:</p>\n<pre><code class="language-ocaml"># let average a b =\n    (a +. b) /. 2.0;;\nval average : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>If you look at the function definition closely, and also at what OCaml\nprints back at you, you\'ll have a number of questions:</p>\n<ul>\n<li>What are those periods in <code>+.</code> and <code>/.</code> for?\n</li>\n<li>What does <code>float -&gt; float -&gt; float</code> mean?\n</li>\n</ul>\n<p>I\'ll answer those questions in the next sections, but first I want to go\nand define the same function in C (the Java definition would be fairly\nsimilar to C), and hopefully that should raise even more questions.\nHere\'s our C version of <code>average</code>:</p>\n<pre><code class="language-C">double average (double a, double b)\n{\n  return (a + b) / 2;\n}\n</code></pre>\n<p>Now look at our much shorter OCaml definition above. Hopefully you\'ll be\nasking:</p>\n<ul>\n<li>Why don\'t we have to define the types of <code>a</code> and <code>b</code> in the OCaml\nversion? How does OCaml know what the types are (indeed, <em>does</em>\nOCaml know what the types are, or is OCaml completely dynamically\ntyped?).\n</li>\n<li>In C, the <code>2</code> is implicitly converted into a <code>double</code>, can\'t OCaml\ndo the same thing?\n</li>\n<li>What is the OCaml way to write <code>return</code>?\n</li>\n</ul>\n<p>OK, let\'s get some answers.</p>\n<ul>\n<li>OCaml is a strongly <em>statically typed</em> language (in other words,\nthere\'s nothing dynamic going on between int, float and string).\n</li>\n<li>OCaml uses <em>type inference</em> to work out the types, so you don\'t have\nto.  If you use the OCaml interactive toplevel as above, then OCaml\nwill tell you\nits inferred type for your function.\n</li>\n<li>OCaml doesn\'t do any implicit casting. If you want a float, you have\nto write <code>2.0</code> because <code>2</code> is an integer. OCaml does <strong>no automatic\nconversion</strong> between int, float, string or any other type.\n</li>\n<li>As a side-effect of type inference in OCaml, functions (including\noperators) can\'t have overloaded definitions. OCaml defines <code>+</code> as\nthe <em>integer</em> addition function. To add floats, use <code>+.</code> (note the\ntrailing period). Similarly, use <code>-.</code>, <code>*.</code>, <code>/.</code> for other float\noperations.\n</li>\n<li>OCaml doesn\'t have a <code>return</code> keyword \u2014 the last expression in a\nfunction becomes the result of the function automatically.\n</li>\n</ul>\n<p>We will present more details in the following sections and chapters.</p>\n<h2 id="basic-types">Basic types</h2>\n<p>The basic types in OCaml are:</p>\n<pre><code class="language-text">OCaml type  Range\n\nint         31-bit signed int (roughly +/- 1 billion) on 32-bit\n            processors, or 63-bit signed int on 64-bit processors\nfloat       IEEE double-precision floating point, equivalent to C\'s double\nbool        A boolean, written either \'true\' or \'false\'\nchar        An 8-bit character\nstring      A string\nunit        Written as ()\n</code></pre>\n<p>OCaml uses one of the bits in an <code>int</code> internally in order to be able to\nautomatically manage the memory use (garbage collection). This is why\nthe basic <code>int</code> is 31 bits, not 32 bits (63 bits if you\'re using a 64\nbit platform). In practice this isn\'t an issue except in a few\nspecialised cases. For example if you\'re counting things in a loop, then\nOCaml limits you to counting up to 1 billion instead of 2 billion. However if you need to do things\nsuch as processing 32 bit types (eg. you\'re writing crypto code or a\nnetwork stack), OCaml provides a <code>nativeint</code> type which matches the\nnative integer type for your platform.</p>\n<p>OCaml doesn\'t have a basic unsigned integer type, but you can get the\nsame effect using <code>nativeint</code>. OCaml doesn\'t have built-in single-precision\nfloating point numbers.</p>\n<p>OCaml provides a <code>char</code> type which is used for characters, written <code>\'x\'</code>\nfor example. Unfortunately the <code>char</code> type does not support Unicode or\nUTF-8, There are <a href="https://github.com/yoriyuki/Camomile">comprehensive Unicode libraries</a>\nwhich provide this functionality.</p>\n<p>Strings are not just lists of characters. They have their own, more\nefficient internal representation. Strings are immutable.</p>\n<p>The <code>unit</code> type is sort of like <code>void</code> in C, but we\'ll talk about it\nmore below.</p>\n<h2 id="implicit-vs-explicit-casts">Implicit vs. explicit casts</h2>\n<p>In C-derived languages ints get promoted to floats in certain\ncircumstances. For example if you write <code>1 + 2.5</code> then the first\nargument (which is an integer) is promoted to a floating point number,\nand the result is also a floating point number. It\'s as if you had\nwritten <code>((double) 1) + 2.5</code>, but all done implicitly.</p>\n<p>OCaml never does implicit casts like this. In OCaml, <code>1 + 2.5</code> is a type\nerror. The <code>+</code> operator in OCaml requires two ints as arguments, and\nhere we\'re giving it an int and a float, so it reports this error:</p>\n<pre><code class="language-ocaml"># 1 + 2.5;;\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n</code></pre>\n<p>To add two floats together you need to use a different operator, <code>+.</code>\n(note the trailing period).</p>\n<p>OCaml doesn\'t promote ints to floats automatically so this is also an\nerror:</p>\n<pre><code class="language-ocaml"># 1 +. 2.5\nLine 1, characters 1-2:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.\'?\n</code></pre>\n<p>Here OCaml is now complaining about the first argument.</p>\n<p>What if you actually want to add an integer and a floating point number\ntogether? (Say they are stored as <code>i</code> and <code>f</code>). In OCaml you need to\nexplicitly cast:</p>\n<pre><code class="language-ocaml">let i = 1;;\nlet f = 2.0;;\nfloat_of_int i +. f\n</code></pre>\n<p><code>float_of_int</code> is a function which takes an <code>int</code> and returns a <code>float</code>.\nThere are a whole load of these functions, called such things as\n<code>int_of_float</code>, <code>char_of_int</code>, <code>int_of_char</code>, <code>string_of_int</code> and so on,\nand they mostly do what you expect.</p>\n<p>Since converting an <code>int</code> to a <code>float</code> is a particularly common\noperation, the <code>float_of_int</code> function has a shorter alias: the above\nexample could simply have been written</p>\n<pre><code class="language-ocaml">float i +. f\n</code></pre>\n<p>(Note that it is perfectly valid in OCaml for a type and a\nfunction to have the same name.)</p>\n<h3 id="is-implicit-or-explicit-casting-better">Is implicit or explicit casting better?</h3>\n<p>You might think that these explicit casts are ugly, time-consuming even,\nand you have a point, but there are at least two arguments in their\nfavour. Firstly, OCaml needs this explicit casting to be able to do type\ninference (see below), and type inference is such a wonderful\ntime-saving feature that it easily offsets the extra keyboarding of\nexplicit casts. Secondly, if you\'ve spent time debugging C programs\nyou\'ll know that (a) implicit casts cause errors which are hard to find,\nand (b) much of the time you\'re sitting there trying to work out where\nthe implicit casts happen. Making the casts explicit helps you in\ndebugging. Thirdly, some casts (particularly int &lt;-&gt; float) are\nactually very expensive operations. You do yourself no favours by hiding\nthem.</p>\n<h2 id="ordinary-functions-and-recursive-functions">Ordinary functions and recursive functions</h2>\n<p>Unlike in C-derived languages, a function isn\'t recursive unless you\nexplicitly say so by using <code>let rec</code> instead of just <code>let</code>. Here\'s an\nexample of a recursive function:</p>\n<pre><code class="language-ocaml"># let rec range a b =\n    if a &gt; b then []\n    else a :: range (a + 1) b\nval range : int -&gt; int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Notice that <code>range</code> calls itself.</p>\n<p>The only difference between <code>let</code> and <code>let rec</code> is in the scoping of the\nfunction name. If the above function had been defined with just <code>let</code>,\nthen the call to <code>range</code> would have tried to look for an existing\n(previously defined) function called <code>range</code>, not the\ncurrently-being-defined function. Using <code>let</code> (without <code>rec</code>) allows you\nto re-define a value in terms of the previous definition. For example:</p>\n<pre><code class="language-ocaml"># let positive_sum a b = \n    let a = max a 0\n    and b = max b 0 in\n    a + b\nval positive_sum : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>This redefinition hides the previous &quot;bindings&quot; of <code>a</code> and <code>b</code> from the\nfunction definition. In some situations coders prefer this pattern to\nusing a new variable name (<code>let a_pos = max a 0</code>) as it makes the old\nbinding inaccessible, so that only the latest values of <code>a</code> and <code>b</code> are\naccessible.</p>\n<p>There is no performance difference between functions defined using <code>let</code>\nand functions defined using <code>let rec</code>, so if you prefer you could always\nuse the <code>let rec</code> form and get the same semantics as C-like languages.</p>\n<h2 id="types-of-functions">Types of functions</h2>\n<p>Because of type inference you will rarely if ever need to explicitly\nwrite down the type of your functions. However, OCaml often prints out\nwhat it thinks are the types of your functions, so you need to know the\nsyntax for this. For a function <code>f</code> which takes arguments <code>arg1</code>,\n<code>arg2</code>, ... <code>argn</code>, and returns type <code>rettype</code>, the compiler will print:</p>\n<pre><code>f : arg1 -&gt; arg2 -&gt; ... -&gt; argn -&gt; rettype\n</code></pre>\n<p>The arrow syntax looks strange now, but when we come to so-called\n&quot;currying&quot; later you\'ll see why it was chosen. For now I\'ll just give\nyou some examples.</p>\n<p>Our function <code>repeated</code> which takes a string and an integer and returns\na string has type:</p>\n<pre><code class="language-ocaml"># repeated\n- : string -&gt; int -&gt; string = &lt;fun&gt;\n</code></pre>\n<p>Our function <code>average</code> which takes two floats and returns a float has\ntype:</p>\n<pre><code class="language-ocaml"># average\n- : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>The OCaml standard <code>int_of_char</code> casting function:</p>\n<pre><code class="language-ocaml"># int_of_char\n- : char -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>If a function returns nothing (<code>void</code> for C and Java programmers), then\nwe write that it returns the <code>unit</code> type. Here, for instance, is the\nOCaml equivalent of C\'s <em><a href="https://pubs.opengroup.org/onlinepubs/009695399/functions/fputc.html">fputc(3)</a></em>:</p>\n<pre><code class="language-ocaml"># output_char\n- : out_channel -&gt; char -&gt; unit = &lt;fun&gt;\n</code></pre>\n<h3 id="polymorphic-functions">Polymorphic functions</h3>\n<p>Now for something a bit stranger. What about a function which takes\n<em>anything</em> as an argument? Here\'s an odd function which takes an\nargument, but just ignores it and always returns 3:</p>\n<pre><code class="language-ocaml">let give_me_a_three x = 3\n</code></pre>\n<p>What is the type of this function? In OCaml we use a special placeholder\nto mean &quot;any type you fancy&quot;. It\'s a single quote character followed by\na letter. The type of the above function would normally be written:</p>\n<pre><code class="language-ocaml"># give_me_a_three\n- : \'a -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>where <code>\'a</code> (pronounced alpha) really does mean any type. You can, for example, call this\nfunction as <code>give_me_a_three &quot;foo&quot;</code> or <code>give_me_a_three 2.0</code> and both\nare quite valid expressions in OCaml.</p>\n<p>It won\'t be clear yet why polymorphic functions are useful, but they are\nvery useful and very common, and so we\'ll discuss them later on. (Hint:\npolymorphism is kind of like templates in C++ or generics in Java).</p>\n<h2 id="type-inference">Type inference</h2>\n<p>So the theme of this tutorial is that functional languages have many\nreally cool features, and OCaml is a language which has all of these\nreally cool features stuffed into it at once, thus making it a very\npractical language for real programmers to use. But the odd thing is\nthat most of these cool features have nothing to do with &quot;functional\nprogramming&quot; at all. In fact, I\'ve come to the first really cool\nfeature, and I still haven\'t talked about why functional programming is\ncalled &quot;functional&quot;. Anyway, here\'s the first really cool feature: type\ninference.</p>\n<p>Simply put: you don\'t need to declare the types of your functions and\nvariables, because OCaml will just figure them out for you!</p>\n<p>In addition OCaml goes on to check all your types match up (even across\ndifferent files).</p>\n<p>But OCaml is also a practical language, and for this reason it contains\nbackdoors into the type system allowing you to bypass this checking on\nthe rare occasions that it is sensible to do this. Only gurus will\nprobably need to bypass the type checking.</p>\n<p>Let\'s go back to the <code>average</code> function which we typed into the OCaml\ninteractive toplevel:</p>\n<pre><code class="language-ocaml"># let average a b =\n    (a +. b) /. 2.0\nval average : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>OCaml worked out all on its own that the function takes\ntwo <code>float</code> arguments and returns a <code>float</code>!</p>\n<p>How did it do this? Firstly it looks at where <code>a</code> and <code>b</code> are used,\nnamely in the expression <code>(a +. b)</code>. Now, <code>+.</code> is itself a function\nwhich always takes two <code>float</code> arguments, so by simple deduction, <code>a</code>\nand <code>b</code> must both also have type <code>float</code>.</p>\n<p>Secondly, the <code>/.</code> function returns a <code>float</code>, and this is the same as\nthe return value of the <code>average</code> function, so <code>average</code> must return a\n<code>float</code>. The conclusion is that <code>average</code> has this type signature:</p>\n<pre><code class="language-ocaml"># average\n- : float -&gt; float -&gt; float = &lt;fun&gt;\n</code></pre>\n<p>Type inference is obviously easy for such a short program, but it works\neven for large programs, and it\'s a major time-saving feature because it\nremoves a whole class of errors which cause segfaults,\n<code>NullPointerException</code>s and <code>ClassCastException</code>s in other languages (or\nimportant but often ignored runtime warnings).</p>\n'},tl:{hd:{title:"OCaml Programming Guidelines",slug:"ocaml-programming-guidelines",description:"Opinionated guidelines for writing OCaml code\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"getting-started",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:{hd:"Advanced",tl:0}}},body_md:"\nThis is a set of reasonable guidelines for formatting OCaml\nprograms\u2014guidelines which reflect the consensus among veteran OCaml\nprogrammers. Nevertheless, all detailed notifications of possible errors\nor omissions will be noted with pleasure. To send your comments using\n[GitHub issues](https://github.com/ocaml/ocaml.org/issues?state=open).\n<br />\nOriginal translation from French: [Ruchira\nDatta](mailto:datta@math.berkeley.edu).\n\nThanks to all those who have already participated in the critique of\nthis page: Daniel de Rauglaudre, Luc Maranget, Jacques Garrigue, Damien\nDoligez, Xavier Leroy, Bruno Verlyck, Bruno Petazzoni, Francois Maltey,\nBasile Starynkevitch, Toby Moth, Pierre Lescanne.\n\n## General guidelines to write programs\n###  Be simple and readable\nThe time you spend typing the programs is negligible compared to the\ntime spent reading them. That's the reason why you save a lot of time if\nyou work hard to optimize readability.\n\nAll the time you are \"wasting\" to get a simpler program today, will\nreturn a hundred times in the future during the uncountably many\nmodifications and readings of the program (starting with the first\ndebugging).\n\n> \n> **Writing programs law**: A program is written once, modified ten\n> times, and read 100 times. So simplify its writing, always keep future\n> modifications in mind, and never jeopardize readability.\n> \n\n## Program formatting guidelines\n###  Lexical conventions\n> \n> **Pseudo spaces law**: never hesitate to separate words of your\n> programs with spaces; the space bar is the easiest key to find on the\n> keyboard, press it as often as necessary!\n> \n\n####  Delimiters\nA space should always follow a delimiter symbol, and spaces should\nsurround operator symbols. It has been a great step forward in\ntypography to separate words by spaces to make written texts easier to\nread. Do the same in your programs if you want them to be readable.\n\n####  How to write pairs\nA tuple is parenthesized and the commas therein (delimiters) are each\nfollowed by a space: `(1, 2)`, `let   triplet = (x, y, z)`...\n\n* **Commonly accepted exceptions**:\n    * **Definition of the components of a pair**: In place of\n `let (x, y) =       ...`, you can write `let x, y = ...`.\n\n> **Justification**: The point is to define several values\n> simultaneously, not to construct a tuple. Moreover, the\n> pattern is set off nicely between `let` and `=`.\n\n- **Matching several values simultaneously**: It's okay to omit\n  parentheses around n-tuples when matching several values\n  simultaneously.\n\n        match x, y with\n        | 1, _ -> ...\n        | x, 1 -> ...\n        | x, y -> ...\n\n  > **Justification**: The point is to match several values in\n  > parallel, not to construct a tuple. Moreover, the expressions\n  > being matched are set off by `match` and `with`, while the\n  > patterns are set off nicely by `|` and `->`.\n\n\n####  How to write lists\nWrite `x :: l` with spaces around the `::` (since `::` is an infix\noperator, hence surrounded by spaces) and `[1; 2; 3]` (since `;` is a\ndelimiter, hence followed by a space).\n\n####  How to write operator symbols\nBe careful to keep operator symbols well separated by spaces: not only\nwill your formulas be more readable, but you will avoid confusion with\nmulti-character operators. (Obvious exceptions to this rule: the symbols\n`!` and `.` are not separated from their arguments.)<br />\nExample: write `x + 1` or `x + !y`.\n\n \n> **Justification**: If you left out the spaces then `x+1` would be\n> understood, but `x+!y` would change its meaning since `+!` would\n> be interpreted as a multi-character operator.\n> \n> **Criticism**: The absence of spaces around an operator improves the\n> readability of formulas when you use it to reflect the relative\n> precedences of operators. For example `x*y + 2*z` makes it very\n> obvious that multiplication takes precedence over addition.\n> \n> **Response**: This is a bad idea, a chimera, because nothing in the\n> language ensures that the spaces properly reflect the meaning of the\n> formula. For example `x * z-1` means `(x * z) - 1`, and not\n> `x * (z - 1)` as the proposed interpretation of spaces would seem to\n> suggest. Besides, the problem of multi-character symbols would keep\n> you from using this convention in a uniform way: you couldn't leave\n> out the spaces around the multiplication to write `x*!y + 2*!z`.\n> Finally, this playing with the spaces is a subtle and flimsy\n> convention, a subliminal message which is difficult to grasp on\n> reading. If you want to make the precedences obvious, use the\n> expressive means brought to you by the language: write parentheses.\n> \n> **Additional justification**: Systematically surrounding operators\n> with spaces simplify the treatment of infix operators which are no\n> more a complex particular case; in effect, whereas you can write `(+)`\n> without spaces, you evidently cannot write `(*)` since `(*` is read as\n> the beginning of a comment. You must write at least one space as in\n> \u201c`( *)`\u201d, although an extra space after `*` is definitively preferable\n> if you want to avoid that `*)` could be read, in some contexts, as the\n> end of a comment. All those difficulties are easily avoided if you\n> adopt the simple rule proposed here: keep operator symbols well\n> separated by spaces.<br />\n> In fact you will quickly feel that this rule is not so difficult to\n> follow: the space bar is the greatest and best situated key of the\n> keyboard, it is the easiest to enter and you cannot miss it!\n\n\n####  How to write long character strings\nIndent long character strings with the convention in force at that line\nplus an indication of string continuation at the end of each line (a `\\`\ncharacter at the end of the line that omits white spaces on the\nbeginning of next line):\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet universal_declaration =\n  \"-1- Programs are born and remain free and equal under the law;\\n\\\n   distinctions can only be based on the common good.\" in\n  ...\n```\n\n## Indentation of programs\n> \n> **Landin's pseudo law**: Treat the indentation of your programs as if\n> it determines the meaning of your programs.\n> \n\nI would add to this law: carefully treat the indentation of programs\nbecause in some cases it really gives the meaning of the program!\n\nThe indentation of programs is an art which excites many strong\nopinions. Here several indentation styles are given which are drawn from\nexperience and which have not been severely criticized.\n\nWhen a justification for the adopted style has seemed obvious to me, I\nhave indicated it. On the other hand, criticisms are also noted.\n\nSo each time, you have to choose between the different styles\nsuggested.<br />\n The only absolute rule is the first below.\n\n###  Consistency of indentation\nChoose a generally accepted style of indentation, then use it\nsystematically throughout the whole application.\n\n###  Width of the page\nThe page is 80 columns wide.\n\n> **Justification**: This width makes it possible to read the code on\n> all displays and to print it in a legible font on a standard sheet.\n \n\n###  Height of the page\nA function should always fit within one screenful (of about 70 lines),\nor in exceptional cases two, at the very most three. To go beyond this\nis unreasonable.\n\n \n> **Justification**: When a function goes beyond one screenful, it's\n> time to divide it into subproblems and handle them independently.\n> Beyond a screenful, one gets lost in the code. The indentation is not\n> readable and is difficult to keep correct.\n\n\n###  How much to indent\nThe change in indentation between successive lines of the program is\ngenerally 1 or 2 spaces. Pick an amount to indent and stick with it\nthroughout the program.\n\n###  Using tab stops\nUsing the tab character (ASCII character 9) is absolutely *not*\nrecommended.\n\n\n> **Justification**: Between one display and another, the indentation of\n> the program changes completely; it can also become completely wrong,\n> if the programmer used both tabulations and spaces to indent the\n> program.\n> \n> **Criticism**: The purpose of using tabulations is just to allow the\n> readers of the program to indent more or less by changing the tabs\n> stops. The overall indentation remains correct and the reader is glad\n> to easily customize the indentation amount.\n> \n> **Answer**: It seems almost impossible to use this method since you\n> should always use tabulations to indent, which is hard and unnatural.\n \n\n###  How to indent global `let ... ;;` definitions\nThe body of a function defined globally in a module is generally\nindented normally. However, it's okay to treat this case specially to\nset off the definition better.\n\nWith a regular indentation of 1 or 2 spaces:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet f x = function\n  | C ->\n  | D ->\n  ...\n\nlet g x =\n  let tmp =\n    match x with\n    | C -> 1\n    | x -> 0 in\n  tmp + 1\n```\n> \n> **Justification**: No exception to the amount of indentation.\n> \n\nOther conventions are acceptable, for example:\n\n* The body is left-justified in the case of pattern-matching.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet f x = function\n| C ->\n| D ->\n...\n```\n> \n> **Justification**: The vertical bars separating the patterns stop\n> when the definition is done, so it's still easy to pass on to the\n> following definition.\n> \n> **Criticism**: An unpleasant exception to the normal indentation.\n> \n\n\n* The body is justified just under the name of the defined function.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet f x =\n    let tmp = ... in\n    try g x with\n    | Not_found ->\n    ...\n```\n> \n> **Justification**: The first line of the definition is set off\n> nicely, so it's easier to pass from definition to definition.\n> \n> **Criticism**: You run into the right margin too quickly.\n> \n\n\n###  How to indent `let ... in` constructs\nThe expression following a definition introduced by `let` is indented to\nthe same level as the keyword `let`, and the keyword `in` which\nintroduces it is written at the end of the line:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet expr1 = ... in\nexpr1 + expr1\n```\n\nIn the case of a series of `let` definitions, the preceding rule implies\nthat these definitions should be placed at the same indentation level:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet expr1 = ... in\nlet n = ... in\n...\n```\n> \n> **Justification**: It is suggested that a series of \u201clet ... in\u201d\n> constructs is analogous to a set of assumptions in a mathematical\n> text, whence the same indentation level for all the assumptions.\n> \n\nVariation: some write the keyword `in` alone on one line to set apart\nthe final expression of the computation:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet e1 = ... in\nlet e2 = ... in\nlet new_expr =\n  let e1' = derive_expression e1\n  and e2' = derive_expression e2 in\n  Add_expression e1' e2'\nin\nMult_expression (new_expr, new_expr)\n```\n> \n> **Criticism**: Lack of consistency.\n> \n\n###  How to indent `if ... then   ... else ... `\n####  Multiple branches\nWrite conditions with multiple branches at the same level of\nindentation:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nif cond1 ...\nif cond2 ...\nif cond3 ...\n```\n> \n> **Justification**: Analogous treatment to pattern-matching clauses,\n> all aligned to the same tab stop.\n> \n\nIf the sizes of the conditions and the expressions allow, write for\nexample:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nif cond1 then e1 else\nif cond2 then e2 else\nif cond3 then e3 else\ne4\n\n```\nIf expressions in the branches of multiple conditions have to be\nenclosed (when they include statements for instance), write:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nif cond then begin\n    e1\n  end else\nif cond2 then begin\n    e2\n  end else\nif cond3 then ...\n```\nSome suggest another method for multiple conditionals, starting each\nline by the keyword `else`:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nif cond1 ...\nelse if cond2 ...\nelse if cond3 ...\n```\n> \n> **Justification**: `elsif` is a keyword in many languages, so use\n> indentation and `else if` to bring it to mind. Moreover, you do not\n> have to look to the end of line to know whether the condition is\n> continued or another test is performed.\n> \n> **Criticism**: Lack of consistency in the treatment of all the\n> conditions. Why a special case for the first condition?\n> \n\nYet again, choose your style and use it systematically.\n\n####  Single branches\nSeveral styles are possible for single branches, according to the size\nof the expressions in question and especially the presence of `begin`\n`end` or `(` `)` delimiters for these expressions.\n\nIn the case of delimiting the branches of a conditional, several styles\nare used:\n\n> `(` at end of line:\n> \n> ```ocaml\n> if cond then (\n>   e1\n> ) else (\n>   e2\n> )\n> ```\n> Or alternatively first `begin` at beginning of line:\n> \n> ```ocaml\n> if cond then\n>   begin\n>     e1\n>   end else begin\n>     e2\n>   end\n> ```\n\nIn fact the indentation of conditionals depends on the sizes of the\nexpressions which make them up.\n\n> \n> If `cond`, `e1` and `e2` are small, simply write them on one line:\n> \n> ```ocaml\n> if cond then e1 else e2\n> ```\n> If the expressions making up a conditional are purely functional\n> (without side effects), we advocate binding them within the\n> conditional with `let e = ... in` when they're too big to fit on a\n> line.\n> \n> > \n> > **Justification**: This way you get back the simple indentation on\n> > one line which is the most readable. As a side benefit, the naming\n> > acts as an aid to comprehension.\n> > \n> \n> So now we consider the case in which the expressions in question do\n> have side effects, which keeps us from simply binding them with a\n> `let e = ... in`.\n> \n> > \n> > If `e1` and `cond` are small, but `e2` large:\n> > \n> > ```ocaml\n> > if cond then e1 else\n> >   e2\n> > ```\n> > \n> > If `e1` and `cond` are large and `e2` small:\n> > \n> > ```ocaml\n> > if cond then\n> >   e1\n> > else e2\n> > ```\n> > \n> > If all the expressions are large:\n> > \n> > ```ocaml\n> > if cond then\n> >   e1\n> > else\n> >   e2\n> > ```\n> > \n> > If there are `( )` delimiters:\n> > \n> > ```ocaml\n> > if cond then (\n> >   e1\n> > ) else (\n> >   e2\n> > )\n> > ```\n> > \n> > A mixture where `e1` requires `( )` but `e2` is small:\n> > \n> > ```ocaml\n> > if cond then (\n> >     e1\n> > ) else e2\n> > ```\n\n###  How to indent pattern-matching constructs\n####  General principles\nAll the pattern-matching clauses are introduced by a vertical bar,\n*including* the first one.\n\n> \n> **Criticism**: The first vertical bar is not mandatory: hence, there\n> is no need to write it.\n> \n> **Answer to criticism**: If you omit the first bar the indentation\n> seems unnatural : the first case gets an indentation that is greater\n> than a normal new line would necessitate. It is thus a useless\n> exception to the correct indentation rule. It also insists not to use\n> the same syntax for the whole set of clauses, writing the first clause\n> as an exception with a slightly different syntax. Last, aesthetic\n> value is doubtful (some people would say \u201cawful\u201d instead of\n> \u201cdoubtful\u201d).\n> \n\nAlign all the pattern-matching clauses at the level of the vertical bar\nwhich begins each clause, *including* the first one.\n\nIf an expression in a clause is too large to fit on the line, you must\nbreak the line immediately after the arrow of the corresponding clause.\nThen indent normally, starting from the beginning of the pattern of the\nclause.\n\nArrows of pattern matching clauses should not be aligned.\n\n####  `match` or `try`\nFor a `match` or a `try` align the clauses with the beginning of the\nconstruct:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmatch lam with\n| Abs (x, body) -> 1 + size_lambda body\n| App (lam1, lam2) -> size_lambda lam1 + size_lambda lam2\n| Var v -> 1\n\ntry f x with\n| Not_found -> ...\n| Failure \"not yet implemented\" -> ...\n```\nPut the keyword `with` at the end of the line. If the preceding\nexpression extends beyond one line, put `with` on a line by itself:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\ntry\n  let y = f x in\n  if ...\nwith\n| Not_found -> ...\n| Failure \"not yet implemented\" -> ...\n```\n> \n> **Justification**: The keyword `with`, on a line by itself shows that\n> the program enters the pattern matching part of the construct.\n> \n\n####  Indenting expressions inside clauses\nIf the expression on the right of the pattern matching arrow is too\nlarge, cut the line after the arrow.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmatch lam with\n| Abs (x, body) ->\n   1 + size_lambda body\n| App (lam1, lam2) ->\n   size_lambda lam1 + size_lambda lam2\n| Var v ->\n```\nSome programmers generalize this rule to all clauses, as soon as one\nexpressions overflows. They will then indent the last clause like this:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\n| Var v ->\n   1\n```\nOther programmers go one step further and apply this rule systematically\nto any clause of any pattern matching.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec fib = function\n  | 0 ->\n     1\n  | 1 ->\n     1\n  | n ->\n     fib (n - 1) + fib ( n - 2)\n```\n> \n> **Criticism**: May be not compact enough; for simple pattern matchings\n> (or simple clauses in complex matchings), the rule does not add any\n> good to readability.\n> \n> **Justification**: I don't see any good reason for this rule, unless\n> you are paid proportionally to the number of lines of code: in this\n> case use this rule to get more money without adding more bugs in your\n> OCaml programs!\n> \n\n####  Pattern matching in anonymous functions\nSimilarly to `match` or `try`, pattern matching of anonymous functions,\nstarting by `function`, are indented with respect to the `function`\nkeyword:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmap\n  (function\n   | Abs (x, body) -> 1 + size_lambda 0 body\n   | App (lam1, lam2) -> size_lambda (size_lambda 0 lam1) lam2\n   | Var v -> 1)\n  lambda_list\n```\n####  Pattern matching in named functions\nPattern-matching in functions defined by `let` or `let rec` gives rise\nto several reasonable styles which obey the preceding rules for pattern\nmatching (the one for anonymous functions being evidently excepted). See\nabove for recommended styles.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec size_lambda accu = function\n  | Abs (x, body) -> size_lambda (succ accu) body\n  | App (lam1, lam2) -> size_lambda (size_lambda accu lam1) lam2\n  | Var v -> succ accu\n\nlet rec size_lambda accu = function\n| Abs (x, body) -> size_lambda (succ accu) body\n| App (lam1, lam2) -> size_lambda (size_lambda accu lam1) lam2\n| Var v -> succ accu\n```\n###  Bad indentation of pattern-matching constructs\n####  No *beastly* indentation of functions and case analyses.\nThis consists in indenting normally under the keyword `match` or\n`function` which has previously been pushed to the right. Don't write:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec f x = function\n              | [] -> ...\n              ...\n```\nbut choose to indent the line under the `let` keyword:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec f x = function\n  | [] -> ...\n  ...\n```\n> \n> **Justification**: You bump into the margin. The aesthetic value is\n> doubtful...\n> \n\n####  No *beastly* alignment of the `->` symbols in pattern-matching clauses.\nCareful alignment of the arrows of a pattern matching is considered bad\npractice, as exemplify in the following fragment:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet f = function\n  | C1          -> 1\n  | Long_name _ -> 2\n  | _           -> 3\n```\n> \n> **Justification**: This makes it harder to maintain the program (the\n> addition of a supplementary case can lead the indentations of all the\n> lines to change and so ... we often give up alignment at that time,\n> then it is better not to align the arrows in the first place!).\n> \n\n###  How to indent function calls\n####  Indentation to the function's name:\nNo problem arises except for functions with many arguments&mdash;or very\ncomplicated arguments as well&mdash;which can't fit on the same line. You\nmust indent the expressions with respect to the name of the function (1\nor 2 spaces according to the chosen convention). Write small arguments\non the same line, and change lines at the start of an argument.\n\nAs far as possible, avoid arguments which consist of complex\nexpressions: in these cases define the \u201clarge\u201d argument by a `let`\nconstruction.\n\n> \n> **Justification**: No indentation problem; if the name given to the\n> expressions is meaningful, the code is more readable as well.\n> \n> **Additional justification**: If the evaluation of the arguments\n> produces side effects, the `let` binding is in fact necessary to\n> explicitly define the order of evaluation.\n> \n\n####  Naming complex arguments:\nIn place of\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet temp =\n  f x y z\n    \u201clarge\n    expression\u201d\n    \u201cother large\n    expression\u201d in\n...\n```\nwrite\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet t =\n  \u201clarge\n  expression\u201d\nand u =\n  \u201cother large\n  expression\u201d in\nlet temp =\n  f x y z t u in\n...\n```\n####  Naming anonymous functions:\nIn the case of an iterator whose argument is a complex function, define\nthe function by a `let` binding as well. In place of\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nList.map\n  (function x ->\n    blabla\n    blabla\n    blabla)\n  l\n```\nwrite\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet f x =\n  blabla\n  blabla\n  blabla in\nList.map f l\n```\n> \n> **Justification**: Much clearer, in particular if the name given to\n> the function is meaningful.\n> \n\n###  How to indent operations\nWhen an operator takes complex arguments, or in the presence of multiple\ncalls to the same operator, start the next the line with the operator,\nand don't indent the rest of the operation. For example:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nx + y + z\n+ t + u\n```\n> \n> **Justification**: When the operator starts the line, it is clear that\n> the operation continues on this line.\n> \n\nIn the case of a \u201clarge expression\u201d in such an operation sequence,\nto define the \u201clarge expression\u201d with the help of a `let in`\nconstruction is preferable to having to indent the line. In place of\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nx + y + z\n+ \u201clarge\n  expression\u201d\n```\nwrite\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet t =\n  \u201clarge\n   expression\u201d in\nx + y + z + t\n```\nYou most certainly must bind those expressions too large to be written\nin one operation in the case of a combination of operators. In place of\nthe unreadable expression\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\n(x + y + z * t)\n/ (\u201clarge\n    expression\u201d)\n```\nwrite\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet u =\n  \u201clarge\n  expression\u201d in\n(x + y + z * t) / u\n```\nThese guidelines extend to all operators. For example:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet u =\n  \u201clarge\n  expression\u201d in\nx :: y\n:: z + 1 :: t :: u\n```\n## Programming guidelines\n###  How to program\n> \n> *Always put your handiwork back on the bench,<br />\n>  and then polish it and re-polish it.*\n> \n\n####  Write simple and clear programs\nWhen this is done, reread, simplify and clarify. At every stage of\ncreation, use your head!\n\n####  Subdivide your programs into little functions\nSmall functions are easier to master.\n\n####  Factor out snippets of repeated code by defining them in separate functions\nThe sharing of code obtained in this way facilitates maintenance since\nevery correction or improvement automatically spreads throughout the\nprogram. Besides, the simple act of isolating and naming a snippet of\ncode sometimes lets you identify an unsuspected feature.\n\n####  Never copy-paste code when programming\nPasting code almost surely indicates introducing a default of code\nsharing and neglecting to identify and write a useful auxiliary\nfunction; hence, it means that some code sharing is lost in the program.\nLosing code sharing implies that you will have more problems afterwards\nfor maintenance: a bug in the pasted code has to be corrected at each\noccurrence of the bug in each copy of the code!\n\nMoreover, it is difficult to identify that the same set of 10 lines of\ncode is repeated 20 times throughout the program. By contrast, if an\nauxiliary function defines those 10 lines, it is fairly easy to see and\nfind where those lines are used: that's simply where the function is\ncalled. If code is copy-pasted all over the place then the program is\nmore difficult to understand.\n\nIn conclusion, copy-pasting code leads to programs that are more\ndifficult to read and more difficult to maintain: it has to be banished.\n\n###  How to comment programs\n####  Don't hesitate to comment when there's a difficulty\n####  If there's no difficulty, there's no point in commenting\n####  Avoid comments in the bodies of functions\n####  Prefer one comment at the beginning of the function...\n...which explains how the algorithm that is used works. Once more, if\nthere is no difficulty, there is no point in commenting.\n\n####  Avoid nocuous comments\nA *nocuous* comment is a comment that does not add any value, i.e. no\nnon-trivial information. The nocuous comment is evidently not of\ninterest; it is a nuisance since it uselessly distracts the reader. It\nis often used to fulfill some strange criteria related to the so-called\n*software metrology*, for instance the ratio *number of comments* /\n*number of lines of code* that perfectly measures a ratio that I don't\nknow the theoretical or practical interpretation. Absolutely avoid\nnocuous comments.\n\nAn example of what to avoid: the following comment uses technical words\nand is thus masquerade into a real comment when it has no additional\ninformation of interest;\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\n(*\n  Function print_lambda:\n  print a lambda-expression given as argument.\n\n  Arguments: lam, any lambda-expression.\n  Returns: nothing.\n\n  Remark: print_lambda can only be used for its side effect.\n*)\nlet rec print_lambda lam =\n  match lam with\n  | Var s -> printf \"%s\" s\n  | Abs l -> printf \"\\\\ %a\" print_lambda l\n  | App (l1, l2) ->\n     printf \"(%a %a)\" print_lambda l1 print_lambda l2\n```\n####  Usage in module interface\nThe function's usage must appear in the interface of the module which\nexports it, not in the program which implements it. Choose comments as\nin the OCaml system's interface modules, which will subsequently allow\nthe documentation of the interface module to be extracted automatically\nif need be.\n\n####  Use assertions\nUse assertions as much as possible: they let you avoid verbose comments,\nwhile allowing a useful verification upon execution.\n\nFor example, the conditions for the arguments of a function to be valid\nare usefully verified by assertions.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet f x =\n  assert (x >= 0);\n  ...\n```\nNote as well that an assertion is often preferable to a comment because\nit's more trustworthy: an assertion is forced to be pertinent because it\nis verified upon each execution, while a comment can quickly become\nobsolete and then becomes actually detrimental to the comprehension of\nthe program.\n\n####  Comments line by line in imperative code\nWhen writing difficult code, and particularly in case of highly\nimperative code with a lot of memory modifications (physical mutations\nin data structures), it is sometime mandatory to comment inside the body\nof functions to explain the implementation of the algorithm encoded\nhere, or to follow successive modifications of invariants that the\nfunction must maintain. Once more, if there is some difficulty\ncommenting is mandatory, for each program line if necessary.\n\n###  How to choose identifiers\nIt's hard to choose identifiers whose name evokes the meaning of the\ncorresponding portion of the program. This is why you must devote\nparticular care to this, emphasizing clarity and regularity of\nnomenclature.\n\n####  Don't use abbreviations for global names\nGlobal identifiers (including especially the names of functions) can be\nlong, because it's important to understand what purpose they serve far\nfrom their definition.\n\n####  Separate words by underscores: (`int_of_string`, not `intOfString`)\nCase modifications are meaningful in OCaml: in effect capitalized words\nare reserved for constructors and module names in OCaml; in contrast\nregular variables (functions or identifiers) must start by a lowercase\nletter. Those rules prevent proper usage of case modification for words\nseparation in identifiers: the first word starts the identifier, hence\nit must be lower case and it is forbidden to choose `IntOfString` as the\nname of a function.\n\n####  Always give the same name to function arguments which have the same meaning\nIf necessary, make this nomenclature explicit in a comment at the top of\nthe file); if there are several arguments with the same meaning then\nattach numeral suffixes to them.\n\n####  Local identifiers can be brief, and should be reused from one function to another\nThis augments regularity of style. Avoid using identifiers whose\nappearance can lead to confusion such as `l` or `O`, easy to confuse\nwith `1` and `0`.\n\nExample:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet add_expression expr1 expr2 = ...\nlet print_expression expr = ...\n```\nAn exception to the recommendation not to use capitalization to separate\nwords within identifiers is tolerated in the case of interfacing with\nexisting libraries which use this naming convention: this lets OCaml\nusers of the library to orient themselves in the original library\ndocumentation more easily.\n\n###  When to use parentheses within an expression\nParentheses are meaningful: they indicate the necessity of using an\nunusual precedence. So they should be used wisely and not sprinkled\nrandomly throughout programs. To this end, you should know the usual\nprecedences, that is, the combinations of operations which do not\nrequire parentheses. Quite fortunately this is not complicated if you\nknow a little mathematics or strive to follow the following rules:\n\n####  Arithmetic operators: the same rules as in mathematics\nFor example: `1 + 2 * x` means `1 + (2 * x)`.\n\n####  Function application: the same rules as those in mathematics for usage of *trigonometric functions*\nIn mathematics you write `sin x` to mean `sin (x)`. In the same way\n`sin x + cos x` means `(sin x) + (cos x)` not `sin (x + (cos x))`. Use\nthe same conventions in OCaml: write `f x + g x` to mean\n`(f x) + (g x)`.<br />\nThis convention generalizes **to all (infix) operators**: `f x :: g x`\nmeans `(f x) :: (g x)`, `f x @ g x` means `(f x) @ (g x)`, and\n`failwith s ^ s'` means `(failwith s) ^ s'`, *not* `failwith (s ^ s')`.\n\n####  Comparisons and boolean operators\nComparisons are infix operators, so the preceding rules apply. This is\nwhy `f x < g x` means `(f x) < (g x)`. For type reasons (no other\nsensible interpretation) the expression `f x < x + 2` means\n`(f x) < (x + 2)`. In the same way `f x < x + 2 && x > 3` means\n`((f x) < (x + 2)) && (x > 3)`.\n\n####  The relative precedences of the boolean operators are those of mathematics\nAlthough mathematicians have a tendency to overuse parens in this case,\nthe boolean \u201cor\u201d operator is analogous to addition and the \u201cand\u201d\nto multiplication. So, just as `1 + 2 * x` means `1 + (2 * x)`,\n`true || false && x` means `true || (false && x)`.\n\n###  How to delimit constructs in programs\nWhen it is necessary to delimit syntactic constructs in programs, use as\ndelimiters the keywords `begin` and `end` rather than parentheses.\nHowever using parentheses is acceptable if you do it in a consistent,\nthat is, systematic, way.\n\nThis explicit delimiting of constructs essentially concerns\npattern-matching constructs or sequences embedded within\n`if then     else` constructs.\n\n####  `match` construct in a `match` construct\nWhen a `match ... with` or `try ... with` construct appears in a\npattern-matching clause, it is absolutely necessary to delimit this\nembedded construct (otherwise subsequent clauses of the enclosing\npattern-matching construct will automatically be associated with the\nenclosed pattern-matching construct). For example:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmatch x with\n| 1 ->\n  begin match y with\n  | ...\n  end\n| 2 ->\n...\n```\n####  Sequences inside branches of `if`\nIn the same way, a sequence which appears in the `then` or `else` part\nof a conditional must be delimited:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nif cond then begin\n  e1;\n  e2\nend else begin\n  e3;\n  e4\nend\n```\n###  How to use modules\n####  Subdividing into modules\nYou must subdivide your programs into coherent modules.\n\nFor each module, you must explicitly write an interface.\n\nFor each interface, you must document the things defined by the module:\nfunctions, types, exceptions, etc.\n\n####  Opening modules\nAvoid `open` directives, using instead the qualified identifier\nnotation. Thus you will prefer short but meaningful module names.\n\n> \n> **Justification**: The use of unqualified identifiers is ambiguous and\n> gives rise to difficult-to-detect semantic errors.\n> \n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet lim = String.length name - 1 in\n...\nlet lim = Array.length v - 1 in\n...\n... List.map succ ...\n... Array.map succ ...\n```\n####  When to use open modules rather than leaving them closed\nYou can consider it normal to open a module which modifies the\nenvironment, and brings other versions of an important set of functions.\nFor example, the `Format` module provides automatically indented\nprinting. This module redefines the usual printing functions\n`print_string`, `print_int`, `print_float`, etc. So when you use\n`Format`, open it systematically at the top of the file.<br />\nIf you don't open `Format` you could miss the qualification of a\nprinting function, and this could be perfectly silent, since many of\n`Format`'s functions have a counterpart in the default environment\n(`Pervasives`). Mixing printing functions from `Format` and `Pervasives`\nleads to subtle bugs in the display, that are difficult to trace. For\ninstance:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet f () =\n  Format.print_string \"Hello World!\"; print_newline ()\n```\nis bogus since it does not call `Format.print_newline` to flush the\npretty-printer queue and output `\"Hello World!\"`. Instead\n`\"Hello World!\"` is stuck into the pretty-printer queue, while\n`Pervasives.print_newline` outputs a carriage return on the standard\noutput ... If `Format` is printing on a file and standard output is the\nterminal, the user will have a bad time finding that a carriage return\nis missing in the file (and the display of material on the file is\nstrange, since boxes that should be closed by `Format.print_newline` are\nstill open), while a spurious carriage return appeared on the screen!\n\nFor the same reason, open large libraries such as the one with\narbitrary-precision integers so as not to burden the program which uses\nthem.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nopen Num\n\nlet rec fib n =\n  if n <= 2 then Int 1 else fib (n - 1) +/ fib (n - 2)\n```\n> \n> **Justification**: The program would be less readable if you had to\n> qualify all the identifiers.\n> \n\nIn a program where type definitions are shared, it is good to gather\nthese definitions into one or more module(s) without implementations\n(containing only types). Then it's acceptable to systematically open the\nmodule which exports the shared type definitions.\n\n###  Pattern-matching\n####  Never be afraid of over-using pattern-matching!\n####  On the other hand, be careful to avoid non-exhaustive pattern-matching constructs\nComplete them with care, without using a \u201ccatch-all\u201d clause such as\n`| _ -> ...` or `| x -> ...` when it's possible to do without it (for\nexample when matching a concrete type defined within the program). See\nalso the next section: compiler warnings.\n\n###  Compiler warnings\nCompiler warnings are meant to prevent potential errors; this is why you\nabsolutely must heed them and correct your programs if compiling them\nproduces such warnings. Besides, programs whose compilation produces\nwarnings have an odor of amateurism which certainly doesn't suit your\nown work!\n\n####  Pattern-matching warnings\nWarnings about pattern-matching must be treated with the upmost care:\n\n* Those concerning useless clauses should of course be eliminated.\n\n\n* For non-exhaustive pattern-matching you must complete the\n corresponding pattern-matching construct, without adding a default\n case \u201ccatch-all\u201d, such as `| _ -> ... `, but with an explicit\n list of the constructors not examined by the rest of the construct,\n for example `| Cn _ | Cn1 _ -> ... `.\n\n> \n> **Justification**: It's not really any more complicated to write\n> it this way, and this allows the program to evolve more safely. In\n> effect the addition of a new constructor to the datatype being\n> matched will produce an alert anew, which will allow the\n> programmer to add a clause corresponding to the new constructor if\n> that is warranted. On the contrary, the \u201ccatch-all\u201d clause\n> will make the function compile silently and it might be thought\n> that the function is correct as the new constructor will be\n> handled by the default case.\n> \n\n\n* Non-exhaustive pattern-matches induced by clauses with guards must\n also be corrected. A typical case consists in suppressing a\n redundant guard.\n\n####  De-structuring `let` bindings\n\\[Translator's note: a \u201cde-structuring `let` binding\u201d is one which\nbinds several names to several expressions simultaneously. You pack all\nthe names you want bound into a collection such as a tuple or a list,\nand you correspondingly pack all the expressions into a collective\nexpression. When the `let` binding is evaluated, it unpacks the\ncollections on both sides and binds each expression to its corresponding\nname. For example, `let x, y = 1, 2` is a de-structuring `let` binding\nwhich performs both the bindings `let x = 1` and `let y = 2`\nsimultaneously.\\]<br />\nThe `let` binding is not limited to simple identifier definitions: you\ncan use it with more complex or simpler patterns. For instance\n\n* `let` with complex patterns:<br />\n `let [x; y] as l = ...`<br />\n simultaneously defines a list `l` and its two elements `x` and `y`.\n* `let` with simple pattern:<br />\n `let _ = ...` does not define anything, it just evaluate the\n expression on the right hand side of the `=` symbol.\n\n####  The de-structuring `let` must be exhaustive\nOnly use de-structuring `let` bindings in the case where the\npattern-matching is exhaustive (the pattern can never fail to match).\nTypically, you will thus be limited to definitions of product types\n(tuples or records) or definitions of variant type with a single case.\nIn any other case, you should use an explicit `match   ... with`\nconstruct.\n\n* `let ... in`: de-structuring `let` that give a warning must be\n replaced by an explicit pattern matching. For instance, instead of\n `let [x; y] as l = List.map succ     (l1 @ l2) in expression` write:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmatch List.map succ (l1 @ l2) with\n| [x; y] as l -> expression\n| _ -> assert false\n```\n\n\n* Global definition with de-structuring lets should be rewritten with\n explicit pattern matching and tuples:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet x, y, l =\n  match List.map succ (l1 @ l2) with\n  | [x; y] as l -> x, y, l\n  | _ -> assert false\n```\n\n\n> \n> **Justification**: There is no way to make the pattern-matching\n> exhaustive if you use general de-structuring `let` bindings.\n> \n\n####  Sequence warnings and `let _ = ...`\nWhen the compiler emits a warning about the type of an expression in a\nsequence, you have to explicitly indicate that you want to ignore the\nresult of this expression. To this end:\n\n* use a vacuous binding and suppress the sequence warning of\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nList.map f l;\nprint_newline ()\n```\nwrite\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet _ = List.map f l in\nprint_newline ()\n```\n\n\n* you can also use the predefined function `ignore : 'a     -> unit`\n that ignores its argument to return `unit`.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nignore (List.map f l);\nprint_newline ()\n```\n\n\n* In any case, the best way to suppress this warning is to understand\n why it is emitted by the compiler: the compiler warns you because\n your code computes a result that is useless since this result is\n just deleted after computation. Hence, if useful at all, this\n computation is performed only for its side-effects; hence it should\n return unit.<br />\n Most of the time, the warning indicates the use of the wrong\n function, a probable confusion between the side-effect only version\n of a function (which is a procedure whose result is irrelevant) with\n its functional counterpart (whose result is meaningful).<br />\n In the example mentioned above, the first situation prevailed, and\n the programmer should have called `iter` instead of `map`, and\n simply write\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nList.iter f l;\nprint_newline ()\n```\nIn actual programs, the suitable (side-effect only) function may not\nexist and has to be written: very often, a careful separation of the\nprocedural part from the functional part of the function at hand\nelegantly solves the problem, and the resulting program just looks\nbetter afterwards! For instance, you would turn the problematic\ndefinition:\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet add x y =\n  if x > 1 then print_int x;\n  print_newline ();\n  x + y;;\n```\ninto the clearer separate definitions and change old calls to `add`\naccordingly.\n\n\n\nIn any case, use the `let _ = ...` construction exactly in those cases\nwhere you want to ignore a result. Don't systematically replace\nsequences with this construction.\n\n> \n> **Justification**: Sequences are much clearer! Compare `e1; e2; e3` to\n> \n> ```ocaml\n> let _ = e1 in\n> let _ = e2 in\n> e3\n> ```\n\n###  The `hd` and `tl` functions\nDon't use the `hd` and `tl` functions, but pattern-match the list\nargument explicitly.\n\n> \n> **Justification**: This is just as brief as and much clearer than\n> using `hd` and `tl` which must of necessity be protected by\n> `try... with...` to catch the exception which might be raised by these\n> functions.\n> \n\n###  Loops\n####  `for` loops\nTo simply traverse an array or a string, use a `for` loop.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nfor i = 0 to Array.length v - 1 do\n  ...\ndone\n```\nIf the loop is complex or returns a result, use a recursive function.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet find_index e v =\n  let rec loop i =\n    if i >= Array.length v then raise Not_found else\n    if v.(i) = e then i else loop (i + 1) in\n  loop 0;;\n```\n> \n> **Justification**: The recursive function lets you code any loop\n> whatsoever simply, even a complex one, for example with multiple exit\n> points or with strange index steps (steps depending on a data value\n> for example).\n> \n> Besides, the recursive loop avoids the use of mutables whose value can\n> be modified in any part of the body of the loop whatsoever (or even\n> outside): on the contrary the recursive loop explicitly takes as\n> arguments the values susceptible to change during the recursive calls.\n> \n\n####  `while` loops\n> \n> **While loops law**: Beware: usually a while loop is wrong, unless its\n> loop invariant has been explicitly written.\n> \n\nThe main use of the `while` loop is the infinite loop\n`while true do     ...`. You get out of it through an exception,\ngenerally on termination of the program.\n\nOther `while` loops are hard to use, unless they come from canned\nprograms from algorithms courses where they were proved.\n\n> \n> **Justification**: `while` loops require one or more mutables in order\n> that the loop condition change value and the loop finally terminate.\n> To prove their correctness, you must therefore discover the loop\n> invariants, an interesting but difficult sport.\n> \n\n###  Exceptions\nDon't be afraid to define your own exceptions in your programs, but on\nthe other hand use as much as possible the exceptions predefined by the\nsystem. For example, every search function which fails should raise the\npredefined exception `Not_found`. Be careful to handle the exceptions\nwhich may be raised by a function call with the help of a\n`try ... with`.\n\nHandling all exceptions by `try     ... with _ ->` is usually reserved\nfor the main function of the program. If you need to catch all\nexceptions to maintain an invariant of an algorithm, be careful to name\nthe exception and re-raise it, after having reset the invariant.\nTypically:\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet ic = open_in ...\nand oc = open_out ... in\ntry\n  treatment ic oc;\n  close_in ic; close_out oc\nwith x -> close_in ic; close_out oc; raise x\n```\n> \n> **Justification**: `try ... with _     ->` silently catches all\n> exceptions, even those which have nothing to do with the computation\n> at hand (for example an interruption will be captured and the\n> computation will continue anyway!).\n> \n\n###  Data structures\nOne of the great strengths of OCaml is the power of the data structures\nwhich can be defined and the simplicity of manipulating them. So you\nmust take advantage of this to the fullest extent; don't hesitate to\ndefine your own data structures. In particular, don't systematically\nrepresent enumerations by whole numbers, nor enumerations with two cases\nby booleans. Examples:\n\n```ocaml\ntype figure =\n   | Triangle | Square | Circle | Parallelogram\ntype convexity =\n   | Convex | Concave | Other\ntype type_of_definition =\n   | Recursive | Non_recursive\n```\n> \n> **Justification**: A boolean value often prevents intuitive\n> understanding of the corresponding code. For example, if\n> `type_of_definition` is coded by a boolean, what does `true` signify?\n> A \u201cnormal\u201d definition (that is, non-recursive) or a recursive\n> definition?\n> \n> In the case of an enumerated type encode by an integer, it is very\n> difficult to limit the range of acceptable integers: one must define\n> construction functions that will ensure the mandatory invariants of\n> the program (and verify afterwards that no values has been built\n> directly), or add assertions in the program and guards in pattern\n> matchings. This is not good practice, when the definition of a sum\n> type elegantly solves this problem, with the additional benefit of\n> firing the full power of pattern matching and compiler's verifications\n> of exhaustiveness.\n> \n> **Criticism**: For binary enumerations, one can systematically define\n> predicates whose names carry the semantics of the boolean that\n> implements the type. For instance, we can adopt the convention that a\n> predicate ends by the letter `p`. Then, in place of defining a new sum\n> type for `type_of_definition`, we will use a predicate function\n> `recursivep` that returns true if the definition is recursive.\n> \n> **Answer**: This method is specific to binary enumeration and cannot\n> be easily extended; moreover it is not well suited to pattern\n> matching. For instance, for definitions encoded by\n> `| Let of bool * string * expression` a typical pattern matching would\n> look like:\n> \n> ```ocaml\n> | Let (_, v, e) as def ->\n>    if recursivep def then code_for_recursive_case\n>    else code_for_non_recursive_case\n> ```\n> \n> or, if `recursivep` can be applied to booleans:\n> \n> ```ocaml\n> | Let (b, v, e) ->\n>    if recursivep b then code_for_recursive_case\n>    else code_for_non_recursive_case\n> ```\n> \n> contrast with an explicit encoding:\n> \n> ```ocaml\n> | Let (Recursive, v, e) -> code_for_recursive_case\n> | Let (Non_recursive, v, e) -> code_for_non_recursive_case\n> ```\n> \n> The difference between the two programs is subtle and you may think\n> that this is just a matter of taste; however the explicit encoding is\n> definitively more robust to modifications and fits better with the\n> language.\n> \n\n*A contrario*, it is not necessary to systematically define new types\nfor boolean flags, when the interpretation of constructors `true` and\n`false` is clear. The usefulness of the definition of the following\ntypes is then questionable:\n\x3c!-- $MDX skip --\x3e\n```ocaml\ntype switch = On | Off\ntype bit = One | Zero\n```\nThe same objection is admissible for enumerated types represented as\nintegers, when those integers have an evident interpretation with\nrespect to the data to be represented.\n\n###  When to use mutables\nMutable values are useful and sometimes indispensable to simple and\nclear programming. Nevertheless, you must use them with discernment:\nOCaml's normal data structures are immutable. They are to be preferred\nfor the clarity and safety of programming which they allow.\n\n###  Iterators\nOCaml's iterators are a powerful and useful feature. However you should\nnot overuse them, nor *a contrario* neglect them: they are provided to\nyou by libraries and have every chance of being correct and\nwell-thought-out by the author of the library. So it's useless to\nreinvent them.\n\nSo write\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet square_elements elements = List.map square elements\n```\nrather than:\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec square_elements = function\n  | [] -> []\n  | elem :: elements -> square elem :: square_elements elements\n```\nOn the other hand avoid writing:\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet iterator f x l =\n  List.fold_right (List.fold_left f) [List.map x l] l\n```\neven though you get:\n\x3c!-- $MDX skip --\x3e\n```ocaml\n  let iterator f x l =\n    List.fold_right (List.fold_left f) [List.map x l] l;;\n  iterator (fun l x -> x :: l) (fun l -> List.rev l) [[1; 2; 3]]\n```\nIn case of express need, you must be careful to add an explanatory\ncomment: in my opinion it's absolutely necessary!\n\n###  How to optimize programs\n> \n> **Pseudo law of optimization**: No optimization *a priori*.<br />\n>  No optimization *a posteriori* either.\n> \n\nAbove all program simply and clearly. Don't start optimizing until the\nprogram bottleneck has been identified (in general a few routines). Then\noptimization consists above all of changing *the complexity* of the\nalgorithm used. This often happens through redefining the data\nstructures being manipulated and completely rewriting the part of the\nprogram which poses a problem.\n\n> \n> **Justification**: Clarity and correctness of programs take\n> precedence. Besides, in a substantial program, it is practically\n> impossible to identify *a priori* the parts of the program whose\n> efficiency is of prime importance.\n> \n\n###  How to choose between classes and modules\nYou should use OCaml classes when you need inheritance, that is,\nincremental refinement of data and their functionality.\n\nYou should use conventional data structures (in particular, variant\ntypes) when you need pattern-matching.\n\nYou should use modules when the data structures are fixed and their\nfunctionality is equally fixed or it's enough to add new functions in\nthe programs which use them.\n\n###  Clarity of OCaml code\nThe OCaml language includes powerful constructs which allow simple and\nclear programming. The main problem to obtain crystal clear programs it\nto use them appropriately.\n\nThe language features numerous programming styles (or programming\nparadigms): imperative programming (based on the notion of state and\nassignment), functional programming (based on the notion of function,\nfunction results, and calculus), object oriented programming (based of\nthe notion of objects encapsulating a state and some procedures or\nmethods that can modify the state). The first work of the programmer is\nto choose the programming paradigm that fits the best the problem at\nhand. When using one of those programming paradigms, the difficulty is\nto use the language construct that expresses in the most natural and\neasiest way the computation that implements the algorithm.\n\n####  Style dangers\nConcerning programming styles, one can usually observe the two\nsymmetrical problematic behaviors: on the one hand, the \u201call\nimperative\u201d way (*systematic* usage of loops and assignment), and on\nthe other hand the \u201cpurely functional\u201d way (*never* use loops nor\nassignments); the \u201c100% object\u201d style will certainly appear in the\nnext future, but (fortunately) it is too new to be discussed here.\n\n* **The \u201cToo much imperative\u201d danger**:\n    * It is a bad idea to use imperative style to code a function that\n is *naturally* recursive. For instance, to compute the length of\n a list, you should not write:\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet list_length l =\n  let l = ref l in\n  let res = ref 0 in\n  while !l <> [] do\n    incr res; l := List.tl !l\n  done;\n  !res;;\n```\nin place of the following recursive function, so simple and\nclear:\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec list_length = function\n  | [] -> 0\n  | _ :: l -> 1 + list_length l\n```\n(For those that would contest the equivalence of those two\nversions, see the [note below](#Imperativeandfunctionalversionsoflistlength)).\n\n\n* Another common \u201cover imperative error\u201d in the imperative world is\n  not to systematically choose the simple `for` loop to iter on the\n  element of a vector, but instead to use a complex `while` loop, with\n  one or two references (too many useless assignments, too many\n  opportunity for errors).\n\n* This category of programmer feels that the `mutable` keyword in\n  the record type definitions should be implicit.\n\n* **The \u201cToo much functional\u201d danger**:\n    * The programmer that adheres to this dogma avoids\n using arrays and assignment. In the most severe case, one\n observes a complete denial of writing any imperative\n construction, even in case it is evidently the most elegant way\n to solve the problem.\n    * Characteristic symptoms: systematic rewriting of `for` loops\n with recursive functions, usage of lists in contexts where\n imperative data structures seem to be mandatory to anyone,\n passing numerous global parameters of the problem to every\n functions, even if a global reference would be perfect to avoid\n these spurious parameters that are mainly invariants that must\n be passed all over the place.\n    * This programmer feels that the `mutable` keyword in the record\n type definitions should be suppressed from the language.\n\n####  OCaml code generally considered unreadable\nThe OCaml language includes powerful constructs which allow simple and\nclear programming. However the power of these constructs also lets you\nwrite uselessly complicated code, to the point where you get a perfectly\nunreadable program.\n\nHere are a number of known ways:\n\n* Use useless (hence novice for readability) `if then else`, as in\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet flush_ps () =\n  if not !psused then psused := true\n```\nor (more subtle)\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet sync b =\n  if !last_is_dvi <> b then last_is_dvi := b\n```\n\n\n* Code one construct with another. For example code a `let ... in` by\n the application of an anonymous function to an argument. You would\n write<br />\n\x3c!-- $MDX skip --\x3e\n```ocaml\n(fun x y -> x + y)\n   e1 e2\n```\ninstead of simply writing\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet x = e1\nand y = e2 in\nx + y\n```\n\n\n* Systematically code sequences with `let in` bindings.\n\n\n* Mix computations and side effects, particularly in function calls.\n Recall that the order of evaluation of arguments in a function call\n is unspecified, which implies that you must not mix side effects and\n computations in function calls. However, when there is only one\n argument you might take advantage of this to perform a side effect\n within the argument, which is extremely troublesome for the reader\n albeit without danger to the program semantics. To be absolutely\n forbidden.\n\n\n* Misuse of iterators and higher-order functions (i.e. over- or\n under-use). For example it's better to use `List.map` or\n `List.iter` than to write their equivalents in-line using specific\n recursive functions of your own. Even worse, you don't use\n `List.map` or `List.iter` but write their equivalents in terms of\n `List.fold_right` and `List.fold_left`.\n\n\n* Another efficient way to write unreadable code is to mix all or some\n of these methods. For example:\n\x3c!-- $MDX skip --\x3e\n```ocaml\n(fun u -> print_string \"world\"; print_string u)\n  (let temp = print_string \"Hello\"; \"!\" in\n   ((fun x -> print_string x; flush stdout) \" \";\n    temp));;\n```\n\n\nIf you naturally write the program `print_string \"Hello world!\"` in this\nway, you can without a doubt submit your work to the [Obfuscated OCaml\nContest](mailto:Pierre.Weis@inria.fr).\n\n## Managing program development\nWe give here tips from veteran OCaml programmers, which have served in\ndeveloping the compilers which are good examples of large complex\nprograms developed by small teams.\n\n###  How to edit programs\nMany developers nurture a kind of veneration towards the Emacs editor\n(gnu-emacs in general) which they use to write their programs. The\neditor interfaces well with the language since it is capable of syntax\ncoloring OCaml source code (rendering different categories of words in\ncolor, coloring keywords for example).\n\nThe following two commands are considered indispensable:\n\n* `CTRL-C-CTRL-C` or `Meta-X compile`: launches re-compilation from\n within the editor (using the `make` command).\n* `` CTRL-X-` ``: puts the cursor in the file and at the exact place\n where the OCaml compiler has signaled an error.\n\nDevelopers describe thus how to use these features: `CTRL-C-CTRL-C`\ncombination recompiles the whole application; in case of errors, a\nsuccession of `` CTRL-X-` `` commands permits correction of all the\nerrors signaled; the cycle begins again with a new re-compilation\nlaunched by `CTRL-C-CTRL-C`.\n\n####  Other emacs tricks\nThe `ESC-/` command (dynamic-abbrev-expand) automatically completes the\nword in front of the cursor with one of the words present in one of the\nfiles being edited. Thus this lets you always choose meaningful\nidentifiers without the tedium of having to type extended names in your\nprograms: the `ESC-/` easily completes the identifier after typing the\nfirst letters. In case it brings up the wrong completion, each\nsubsequent `ESC-/` proposes an alternate completion.\n\nUnder Unix, the `CTRL-C-CTRL-C` or `Meta-X     compile` combination,\nfollowed by `` CTRL-X-` `` is also used to find all occurrences of a\ncertain string in a OCaml program. Instead of launching `make` to\nrecompile, you launch the `grep` command; then all the \u201cerror\nmessages\u201d from `grep` are compatible with the `` CTRL-X-` `` usage\nwhich automatically takes you to the file and the place where the string\nis found.\n\n###  How to edit with the interactive system\nUnder Unix: use the line editor `ledit` which offers great editing\ncapabilities \u201c\xe0 la emacs\u201d (including `ESC-/`!), as well as a history\nmechanism which lets you retrieve previously typed commands and even\nretrieve commands from one session in another. `ledit` is written in\nOCaml and can be freely down-loaded\n[here](ftp://ftp.inria.fr/INRIA/Projects/cristal/caml-light/bazar-ocaml/ledit.tar.gz).\n\n###  How to compile\nThe `make` utility is indispensable for managing the compilation and\nre-compilation of programs. Sample `make` files can be found on [The\nHump](https://caml.inria.fr//cgi-bin/hump.en.cgi). You can also consult\nthe `Makefiles` for the OCaml compilers.\n\n###  How to develop as a team: version control\nUsers of the [Git](https://git-scm.com/) software version control system\nnever run out of good things to say about the productivity gains it\nbrings. This system supports managing development by a team of\nprogrammers while imposing consistency among them, and also maintains a\nlog of changes made to the software.<br />\n Git also supports simultaneous development by several teams, possibly\ndispersed among several sites linked on the Net.\n\nAn anonymous Git read-only mirror [contains the working sources of the\nOCaml compilers](https://github.com/ocaml/ocaml), and the sources of\nother software related to OCaml.\n\n##  Notes\n###  Imperative and functional versions of `list_length`\nThe two versions of `list_length` are not completely equivalent in term\nof complexity, since the imperative version uses a constant amount of\nstack room to execute, whereas the functional version needs to store\nreturn addresses of suspended recursive calls (whose maximum number is\nequal to the length of the list argument). If you want to retrieve a\nconstant space requirement to run the functional program you just have\nto write a function that is recursive in its tail (or *tail-rec*), that\nis a function that just ends by a recursive call (which is not the case\nhere since a call to `+` has to be perform after the recursive call has\nreturned). Just use an accumulator for intermediate results, as in:\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet list_length l =\n  let rec loop accu = function\n    | [] -> accu\n    | _ :: l -> loop (accu + 1) l in\n  loop 0 l\n```\nThis way, you get a program that has the same computational properties\nas the imperative program with the additional clarity and natural\nlook of an algorithm that performs pattern matching and recursive\ncalls to handle an argument that belongs to a recursive sum data type.\n\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#general-guidelines-to-write-programs">General guidelines to write programs</a>\n</li>\n<li><a href="#program-formatting-guidelines">Program formatting guidelines</a>\n</li>\n<li><a href="#indentation-of-programs">Indentation of programs</a>\n</li>\n<li><a href="#programming-guidelines">Programming guidelines</a>\n</li>\n<li><a href="#managing-program-development">Managing program development</a>\n</li>\n<li><a href="#notes">Notes</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>This is a set of reasonable guidelines for formatting OCaml\nprograms\u2014guidelines which reflect the consensus among veteran OCaml\nprogrammers. Nevertheless, all detailed notifications of possible errors\nor omissions will be noted with pleasure. To send your comments using\n<a href="https://github.com/ocaml/ocaml.org/issues?state=open">GitHub issues</a>.\n<br />\nOriginal translation from French: <a href="mailto:datta@math.berkeley.edu">Ruchira\nDatta</a>.</p>\n<p>Thanks to all those who have already participated in the critique of\nthis page: Daniel de Rauglaudre, Luc Maranget, Jacques Garrigue, Damien\nDoligez, Xavier Leroy, Bruno Verlyck, Bruno Petazzoni, Francois Maltey,\nBasile Starynkevitch, Toby Moth, Pierre Lescanne.</p>\n<h2 id="general-guidelines-to-write-programs">General guidelines to write programs</h2>\n<h3 id="be-simple-and-readable">Be simple and readable</h3>\n<p>The time you spend typing the programs is negligible compared to the\ntime spent reading them. That\'s the reason why you save a lot of time if\nyou work hard to optimize readability.</p>\n<p>All the time you are &quot;wasting&quot; to get a simpler program today, will\nreturn a hundred times in the future during the uncountably many\nmodifications and readings of the program (starting with the first\ndebugging).</p>\n<blockquote>\n<p><strong>Writing programs law</strong>: A program is written once, modified ten\ntimes, and read 100 times. So simplify its writing, always keep future\nmodifications in mind, and never jeopardize readability.</p>\n</blockquote>\n<h2 id="program-formatting-guidelines">Program formatting guidelines</h2>\n<h3 id="lexical-conventions">Lexical conventions</h3>\n<blockquote>\n<p><strong>Pseudo spaces law</strong>: never hesitate to separate words of your\nprograms with spaces; the space bar is the easiest key to find on the\nkeyboard, press it as often as necessary!</p>\n</blockquote>\n<h4 id="delimiters">Delimiters</h4>\n<p>A space should always follow a delimiter symbol, and spaces should\nsurround operator symbols. It has been a great step forward in\ntypography to separate words by spaces to make written texts easier to\nread. Do the same in your programs if you want them to be readable.</p>\n<h4 id="how-to-write-pairs">How to write pairs</h4>\n<p>A tuple is parenthesized and the commas therein (delimiters) are each\nfollowed by a space: <code>(1, 2)</code>, <code>let   triplet = (x, y, z)</code>...</p>\n<ul>\n<li><strong>Commonly accepted exceptions</strong>:\n<ul>\n<li><strong>Definition of the components of a pair</strong>: In place of\n<code>let (x, y) =       ...</code>, you can write <code>let x, y = ...</code>.\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Justification</strong>: The point is to define several values\nsimultaneously, not to construct a tuple. Moreover, the\npattern is set off nicely between <code>let</code> and <code>=</code>.</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>Matching several values simultaneously</strong>: It\'s okay to omit\nparentheses around n-tuples when matching several values\nsimultaneously.</p>\n<pre><code>  match x, y with\n  | 1, _ -&gt; ...\n  | x, 1 -&gt; ...\n  | x, y -&gt; ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The point is to match several values in\nparallel, not to construct a tuple. Moreover, the expressions\nbeing matched are set off by <code>match</code> and <code>with</code>, while the\npatterns are set off nicely by <code>|</code> and <code>-&gt;</code>.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id="how-to-write-lists">How to write lists</h4>\n<p>Write <code>x :: l</code> with spaces around the <code>::</code> (since <code>::</code> is an infix\noperator, hence surrounded by spaces) and <code>[1; 2; 3]</code> (since <code>;</code> is a\ndelimiter, hence followed by a space).</p>\n<h4 id="how-to-write-operator-symbols">How to write operator symbols</h4>\n<p>Be careful to keep operator symbols well separated by spaces: not only\nwill your formulas be more readable, but you will avoid confusion with\nmulti-character operators. (Obvious exceptions to this rule: the symbols\n<code>!</code> and <code>.</code> are not separated from their arguments.)<br />\nExample: write <code>x + 1</code> or <code>x + !y</code>.</p>\n<blockquote>\n<p><strong>Justification</strong>: If you left out the spaces then <code>x+1</code> would be\nunderstood, but <code>x+!y</code> would change its meaning since <code>+!</code> would\nbe interpreted as a multi-character operator.</p>\n<p><strong>Criticism</strong>: The absence of spaces around an operator improves the\nreadability of formulas when you use it to reflect the relative\nprecedences of operators. For example <code>x*y + 2*z</code> makes it very\nobvious that multiplication takes precedence over addition.</p>\n<p><strong>Response</strong>: This is a bad idea, a chimera, because nothing in the\nlanguage ensures that the spaces properly reflect the meaning of the\nformula. For example <code>x * z-1</code> means <code>(x * z) - 1</code>, and not\n<code>x * (z - 1)</code> as the proposed interpretation of spaces would seem to\nsuggest. Besides, the problem of multi-character symbols would keep\nyou from using this convention in a uniform way: you couldn\'t leave\nout the spaces around the multiplication to write <code>x*!y + 2*!z</code>.\nFinally, this playing with the spaces is a subtle and flimsy\nconvention, a subliminal message which is difficult to grasp on\nreading. If you want to make the precedences obvious, use the\nexpressive means brought to you by the language: write parentheses.</p>\n<p><strong>Additional justification</strong>: Systematically surrounding operators\nwith spaces simplify the treatment of infix operators which are no\nmore a complex particular case; in effect, whereas you can write <code>(+)</code>\nwithout spaces, you evidently cannot write <code>(*)</code> since <code>(*</code> is read as\nthe beginning of a comment. You must write at least one space as in\n\u201c<code>( *)</code>\u201d, although an extra space after <code>*</code> is definitively preferable\nif you want to avoid that <code>*)</code> could be read, in some contexts, as the\nend of a comment. All those difficulties are easily avoided if you\nadopt the simple rule proposed here: keep operator symbols well\nseparated by spaces.<br />\nIn fact you will quickly feel that this rule is not so difficult to\nfollow: the space bar is the greatest and best situated key of the\nkeyboard, it is the easiest to enter and you cannot miss it!</p>\n</blockquote>\n<h4 id="how-to-write-long-character-strings">How to write long character strings</h4>\n<p>Indent long character strings with the convention in force at that line\nplus an indication of string continuation at the end of each line (a <code>\\</code>\ncharacter at the end of the line that omits white spaces on the\nbeginning of next line):</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let universal_declaration =\n  &quot;-1- Programs are born and remain free and equal under the law;\\n\\\n   distinctions can only be based on the common good.&quot; in\n  ...\n</code></pre>\n<h2 id="indentation-of-programs">Indentation of programs</h2>\n<blockquote>\n<p><strong>Landin\'s pseudo law</strong>: Treat the indentation of your programs as if\nit determines the meaning of your programs.</p>\n</blockquote>\n<p>I would add to this law: carefully treat the indentation of programs\nbecause in some cases it really gives the meaning of the program!</p>\n<p>The indentation of programs is an art which excites many strong\nopinions. Here several indentation styles are given which are drawn from\nexperience and which have not been severely criticized.</p>\n<p>When a justification for the adopted style has seemed obvious to me, I\nhave indicated it. On the other hand, criticisms are also noted.</p>\n<p>So each time, you have to choose between the different styles\nsuggested.<br />\nThe only absolute rule is the first below.</p>\n<h3 id="consistency-of-indentation">Consistency of indentation</h3>\n<p>Choose a generally accepted style of indentation, then use it\nsystematically throughout the whole application.</p>\n<h3 id="width-of-the-page">Width of the page</h3>\n<p>The page is 80 columns wide.</p>\n<blockquote>\n<p><strong>Justification</strong>: This width makes it possible to read the code on\nall displays and to print it in a legible font on a standard sheet.</p>\n</blockquote>\n<h3 id="height-of-the-page">Height of the page</h3>\n<p>A function should always fit within one screenful (of about 70 lines),\nor in exceptional cases two, at the very most three. To go beyond this\nis unreasonable.</p>\n<blockquote>\n<p><strong>Justification</strong>: When a function goes beyond one screenful, it\'s\ntime to divide it into subproblems and handle them independently.\nBeyond a screenful, one gets lost in the code. The indentation is not\nreadable and is difficult to keep correct.</p>\n</blockquote>\n<h3 id="how-much-to-indent">How much to indent</h3>\n<p>The change in indentation between successive lines of the program is\ngenerally 1 or 2 spaces. Pick an amount to indent and stick with it\nthroughout the program.</p>\n<h3 id="using-tab-stops">Using tab stops</h3>\n<p>Using the tab character (ASCII character 9) is absolutely <em>not</em>\nrecommended.</p>\n<blockquote>\n<p><strong>Justification</strong>: Between one display and another, the indentation of\nthe program changes completely; it can also become completely wrong,\nif the programmer used both tabulations and spaces to indent the\nprogram.</p>\n<p><strong>Criticism</strong>: The purpose of using tabulations is just to allow the\nreaders of the program to indent more or less by changing the tabs\nstops. The overall indentation remains correct and the reader is glad\nto easily customize the indentation amount.</p>\n<p><strong>Answer</strong>: It seems almost impossible to use this method since you\nshould always use tabulations to indent, which is hard and unnatural.</p>\n</blockquote>\n<h3 id="how-to-indent-global-let---definitions">How to indent global <code>let ... ;;</code> definitions</h3>\n<p>The body of a function defined globally in a module is generally\nindented normally. However, it\'s okay to treat this case specially to\nset off the definition better.</p>\n<p>With a regular indentation of 1 or 2 spaces:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let f x = function\n  | C -&gt;\n  | D -&gt;\n  ...\n\nlet g x =\n  let tmp =\n    match x with\n    | C -&gt; 1\n    | x -&gt; 0 in\n  tmp + 1\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: No exception to the amount of indentation.</p>\n</blockquote>\n<p>Other conventions are acceptable, for example:</p>\n<ul>\n<li>The body is left-justified in the case of pattern-matching.\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let f x = function\n| C -&gt;\n| D -&gt;\n...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The vertical bars separating the patterns stop\nwhen the definition is done, so it\'s still easy to pass on to the\nfollowing definition.</p>\n<p><strong>Criticism</strong>: An unpleasant exception to the normal indentation.</p>\n</blockquote>\n<ul>\n<li>The body is justified just under the name of the defined function.\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let f x =\n    let tmp = ... in\n    try g x with\n    | Not_found -&gt;\n    ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The first line of the definition is set off\nnicely, so it\'s easier to pass from definition to definition.</p>\n<p><strong>Criticism</strong>: You run into the right margin too quickly.</p>\n</blockquote>\n<h3 id="how-to-indent-let--in-constructs">How to indent <code>let ... in</code> constructs</h3>\n<p>The expression following a definition introduced by <code>let</code> is indented to\nthe same level as the keyword <code>let</code>, and the keyword <code>in</code> which\nintroduces it is written at the end of the line:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let expr1 = ... in\nexpr1 + expr1\n</code></pre>\n<p>In the case of a series of <code>let</code> definitions, the preceding rule implies\nthat these definitions should be placed at the same indentation level:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let expr1 = ... in\nlet n = ... in\n...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: It is suggested that a series of \u201clet ... in\u201d\nconstructs is analogous to a set of assumptions in a mathematical\ntext, whence the same indentation level for all the assumptions.</p>\n</blockquote>\n<p>Variation: some write the keyword <code>in</code> alone on one line to set apart\nthe final expression of the computation:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let e1 = ... in\nlet e2 = ... in\nlet new_expr =\n  let e1\' = derive_expression e1\n  and e2\' = derive_expression e2 in\n  Add_expression e1\' e2\'\nin\nMult_expression (new_expr, new_expr)\n</code></pre>\n<blockquote>\n<p><strong>Criticism</strong>: Lack of consistency.</p>\n</blockquote>\n<h3 id="how-to-indent-if--then----else--">How to indent <code>if ... then   ... else ... </code></h3>\n<h4 id="multiple-branches">Multiple branches</h4>\n<p>Write conditions with multiple branches at the same level of\nindentation:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">if cond1 ...\nif cond2 ...\nif cond3 ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: Analogous treatment to pattern-matching clauses,\nall aligned to the same tab stop.</p>\n</blockquote>\n<p>If the sizes of the conditions and the expressions allow, write for\nexample:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">if cond1 then e1 else\nif cond2 then e2 else\nif cond3 then e3 else\ne4\n\n</code></pre>\n<p>If expressions in the branches of multiple conditions have to be\nenclosed (when they include statements for instance), write:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">if cond then begin\n    e1\n  end else\nif cond2 then begin\n    e2\n  end else\nif cond3 then ...\n</code></pre>\n<p>Some suggest another method for multiple conditionals, starting each\nline by the keyword <code>else</code>:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">if cond1 ...\nelse if cond2 ...\nelse if cond3 ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: <code>elsif</code> is a keyword in many languages, so use\nindentation and <code>else if</code> to bring it to mind. Moreover, you do not\nhave to look to the end of line to know whether the condition is\ncontinued or another test is performed.</p>\n<p><strong>Criticism</strong>: Lack of consistency in the treatment of all the\nconditions. Why a special case for the first condition?</p>\n</blockquote>\n<p>Yet again, choose your style and use it systematically.</p>\n<h4 id="single-branches">Single branches</h4>\n<p>Several styles are possible for single branches, according to the size\nof the expressions in question and especially the presence of <code>begin</code>\n<code>end</code> or <code>(</code> <code>)</code> delimiters for these expressions.</p>\n<p>In the case of delimiting the branches of a conditional, several styles\nare used:</p>\n<blockquote>\n<p><code>(</code> at end of line:</p>\n<pre><code class="language-ocaml">if cond then (\n  e1\n) else (\n  e2\n)\n</code></pre>\n<p>Or alternatively first <code>begin</code> at beginning of line:</p>\n<pre><code class="language-ocaml">if cond then\n  begin\n    e1\n  end else begin\n    e2\n  end\n</code></pre>\n</blockquote>\n<p>In fact the indentation of conditionals depends on the sizes of the\nexpressions which make them up.</p>\n<blockquote>\n<p>If <code>cond</code>, <code>e1</code> and <code>e2</code> are small, simply write them on one line:</p>\n<pre><code class="language-ocaml">if cond then e1 else e2\n</code></pre>\n<p>If the expressions making up a conditional are purely functional\n(without side effects), we advocate binding them within the\nconditional with <code>let e = ... in</code> when they\'re too big to fit on a\nline.</p>\n<blockquote>\n<p><strong>Justification</strong>: This way you get back the simple indentation on\none line which is the most readable. As a side benefit, the naming\nacts as an aid to comprehension.</p>\n</blockquote>\n<p>So now we consider the case in which the expressions in question do\nhave side effects, which keeps us from simply binding them with a\n<code>let e = ... in</code>.</p>\n<blockquote>\n<p>If <code>e1</code> and <code>cond</code> are small, but <code>e2</code> large:</p>\n<pre><code class="language-ocaml">if cond then e1 else\n  e2\n</code></pre>\n<p>If <code>e1</code> and <code>cond</code> are large and <code>e2</code> small:</p>\n<pre><code class="language-ocaml">if cond then\n  e1\nelse e2\n</code></pre>\n<p>If all the expressions are large:</p>\n<pre><code class="language-ocaml">if cond then\n  e1\nelse\n  e2\n</code></pre>\n<p>If there are <code>( )</code> delimiters:</p>\n<pre><code class="language-ocaml">if cond then (\n  e1\n) else (\n  e2\n)\n</code></pre>\n<p>A mixture where <code>e1</code> requires <code>( )</code> but <code>e2</code> is small:</p>\n<pre><code class="language-ocaml">if cond then (\n    e1\n) else e2\n</code></pre>\n</blockquote>\n</blockquote>\n<h3 id="how-to-indent-pattern-matching-constructs">How to indent pattern-matching constructs</h3>\n<h4 id="general-principles">General principles</h4>\n<p>All the pattern-matching clauses are introduced by a vertical bar,\n<em>including</em> the first one.</p>\n<blockquote>\n<p><strong>Criticism</strong>: The first vertical bar is not mandatory: hence, there\nis no need to write it.</p>\n<p><strong>Answer to criticism</strong>: If you omit the first bar the indentation\nseems unnatural : the first case gets an indentation that is greater\nthan a normal new line would necessitate. It is thus a useless\nexception to the correct indentation rule. It also insists not to use\nthe same syntax for the whole set of clauses, writing the first clause\nas an exception with a slightly different syntax. Last, aesthetic\nvalue is doubtful (some people would say \u201cawful\u201d instead of\n\u201cdoubtful\u201d).</p>\n</blockquote>\n<p>Align all the pattern-matching clauses at the level of the vertical bar\nwhich begins each clause, <em>including</em> the first one.</p>\n<p>If an expression in a clause is too large to fit on the line, you must\nbreak the line immediately after the arrow of the corresponding clause.\nThen indent normally, starting from the beginning of the pattern of the\nclause.</p>\n<p>Arrows of pattern matching clauses should not be aligned.</p>\n<h4 id="match-or-try"><code>match</code> or <code>try</code></h4>\n<p>For a <code>match</code> or a <code>try</code> align the clauses with the beginning of the\nconstruct:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">match lam with\n| Abs (x, body) -&gt; 1 + size_lambda body\n| App (lam1, lam2) -&gt; size_lambda lam1 + size_lambda lam2\n| Var v -&gt; 1\n\ntry f x with\n| Not_found -&gt; ...\n| Failure &quot;not yet implemented&quot; -&gt; ...\n</code></pre>\n<p>Put the keyword <code>with</code> at the end of the line. If the preceding\nexpression extends beyond one line, put <code>with</code> on a line by itself:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">try\n  let y = f x in\n  if ...\nwith\n| Not_found -&gt; ...\n| Failure &quot;not yet implemented&quot; -&gt; ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The keyword <code>with</code>, on a line by itself shows that\nthe program enters the pattern matching part of the construct.</p>\n</blockquote>\n<h4 id="indenting-expressions-inside-clauses">Indenting expressions inside clauses</h4>\n<p>If the expression on the right of the pattern matching arrow is too\nlarge, cut the line after the arrow.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">match lam with\n| Abs (x, body) -&gt;\n   1 + size_lambda body\n| App (lam1, lam2) -&gt;\n   size_lambda lam1 + size_lambda lam2\n| Var v -&gt;\n</code></pre>\n<p>Some programmers generalize this rule to all clauses, as soon as one\nexpressions overflows. They will then indent the last clause like this:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">| Var v -&gt;\n   1\n</code></pre>\n<p>Other programmers go one step further and apply this rule systematically\nto any clause of any pattern matching.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec fib = function\n  | 0 -&gt;\n     1\n  | 1 -&gt;\n     1\n  | n -&gt;\n     fib (n - 1) + fib ( n - 2)\n</code></pre>\n<blockquote>\n<p><strong>Criticism</strong>: May be not compact enough; for simple pattern matchings\n(or simple clauses in complex matchings), the rule does not add any\ngood to readability.</p>\n<p><strong>Justification</strong>: I don\'t see any good reason for this rule, unless\nyou are paid proportionally to the number of lines of code: in this\ncase use this rule to get more money without adding more bugs in your\nOCaml programs!</p>\n</blockquote>\n<h4 id="pattern-matching-in-anonymous-functions">Pattern matching in anonymous functions</h4>\n<p>Similarly to <code>match</code> or <code>try</code>, pattern matching of anonymous functions,\nstarting by <code>function</code>, are indented with respect to the <code>function</code>\nkeyword:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">map\n  (function\n   | Abs (x, body) -&gt; 1 + size_lambda 0 body\n   | App (lam1, lam2) -&gt; size_lambda (size_lambda 0 lam1) lam2\n   | Var v -&gt; 1)\n  lambda_list\n</code></pre>\n<h4 id="pattern-matching-in-named-functions">Pattern matching in named functions</h4>\n<p>Pattern-matching in functions defined by <code>let</code> or <code>let rec</code> gives rise\nto several reasonable styles which obey the preceding rules for pattern\nmatching (the one for anonymous functions being evidently excepted). See\nabove for recommended styles.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec size_lambda accu = function\n  | Abs (x, body) -&gt; size_lambda (succ accu) body\n  | App (lam1, lam2) -&gt; size_lambda (size_lambda accu lam1) lam2\n  | Var v -&gt; succ accu\n\nlet rec size_lambda accu = function\n| Abs (x, body) -&gt; size_lambda (succ accu) body\n| App (lam1, lam2) -&gt; size_lambda (size_lambda accu lam1) lam2\n| Var v -&gt; succ accu\n</code></pre>\n<h3 id="bad-indentation-of-pattern-matching-constructs">Bad indentation of pattern-matching constructs</h3>\n<h4 id="no-beastly-indentation-of-functions-and-case-analyses">No <em>beastly</em> indentation of functions and case analyses.</h4>\n<p>This consists in indenting normally under the keyword <code>match</code> or\n<code>function</code> which has previously been pushed to the right. Don\'t write:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec f x = function\n              | [] -&gt; ...\n              ...\n</code></pre>\n<p>but choose to indent the line under the <code>let</code> keyword:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec f x = function\n  | [] -&gt; ...\n  ...\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: You bump into the margin. The aesthetic value is\ndoubtful...</p>\n</blockquote>\n<h4 id="no-beastly-alignment-of-the---symbols-in-pattern-matching-clauses">No <em>beastly</em> alignment of the <code>-&gt;</code> symbols in pattern-matching clauses.</h4>\n<p>Careful alignment of the arrows of a pattern matching is considered bad\npractice, as exemplify in the following fragment:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let f = function\n  | C1          -&gt; 1\n  | Long_name _ -&gt; 2\n  | _           -&gt; 3\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: This makes it harder to maintain the program (the\naddition of a supplementary case can lead the indentations of all the\nlines to change and so ... we often give up alignment at that time,\nthen it is better not to align the arrows in the first place!).</p>\n</blockquote>\n<h3 id="how-to-indent-function-calls">How to indent function calls</h3>\n<h4 id="indentation-to-the-functions-name">Indentation to the function\'s name:</h4>\n<p>No problem arises except for functions with many arguments\u2014or very\ncomplicated arguments as well\u2014which can\'t fit on the same line. You\nmust indent the expressions with respect to the name of the function (1\nor 2 spaces according to the chosen convention). Write small arguments\non the same line, and change lines at the start of an argument.</p>\n<p>As far as possible, avoid arguments which consist of complex\nexpressions: in these cases define the \u201clarge\u201d argument by a <code>let</code>\nconstruction.</p>\n<blockquote>\n<p><strong>Justification</strong>: No indentation problem; if the name given to the\nexpressions is meaningful, the code is more readable as well.</p>\n<p><strong>Additional justification</strong>: If the evaluation of the arguments\nproduces side effects, the <code>let</code> binding is in fact necessary to\nexplicitly define the order of evaluation.</p>\n</blockquote>\n<h4 id="naming-complex-arguments">Naming complex arguments:</h4>\n<p>In place of</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let temp =\n  f x y z\n    \u201clarge\n    expression\u201d\n    \u201cother large\n    expression\u201d in\n...\n</code></pre>\n<p>write</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let t =\n  \u201clarge\n  expression\u201d\nand u =\n  \u201cother large\n  expression\u201d in\nlet temp =\n  f x y z t u in\n...\n</code></pre>\n<h4 id="naming-anonymous-functions">Naming anonymous functions:</h4>\n<p>In the case of an iterator whose argument is a complex function, define\nthe function by a <code>let</code> binding as well. In place of</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">List.map\n  (function x -&gt;\n    blabla\n    blabla\n    blabla)\n  l\n</code></pre>\n<p>write</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let f x =\n  blabla\n  blabla\n  blabla in\nList.map f l\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: Much clearer, in particular if the name given to\nthe function is meaningful.</p>\n</blockquote>\n<h3 id="how-to-indent-operations">How to indent operations</h3>\n<p>When an operator takes complex arguments, or in the presence of multiple\ncalls to the same operator, start the next the line with the operator,\nand don\'t indent the rest of the operation. For example:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">x + y + z\n+ t + u\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: When the operator starts the line, it is clear that\nthe operation continues on this line.</p>\n</blockquote>\n<p>In the case of a \u201clarge expression\u201d in such an operation sequence,\nto define the \u201clarge expression\u201d with the help of a <code>let in</code>\nconstruction is preferable to having to indent the line. In place of</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">x + y + z\n+ \u201clarge\n  expression\u201d\n</code></pre>\n<p>write</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let t =\n  \u201clarge\n   expression\u201d in\nx + y + z + t\n</code></pre>\n<p>You most certainly must bind those expressions too large to be written\nin one operation in the case of a combination of operators. In place of\nthe unreadable expression</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">(x + y + z * t)\n/ (\u201clarge\n    expression\u201d)\n</code></pre>\n<p>write</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let u =\n  \u201clarge\n  expression\u201d in\n(x + y + z * t) / u\n</code></pre>\n<p>These guidelines extend to all operators. For example:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let u =\n  \u201clarge\n  expression\u201d in\nx :: y\n:: z + 1 :: t :: u\n</code></pre>\n<h2 id="programming-guidelines">Programming guidelines</h2>\n<h3 id="how-to-program">How to program</h3>\n<blockquote>\n<p><em>Always put your handiwork back on the bench,<br />\nand then polish it and re-polish it.</em></p>\n</blockquote>\n<h4 id="write-simple-and-clear-programs">Write simple and clear programs</h4>\n<p>When this is done, reread, simplify and clarify. At every stage of\ncreation, use your head!</p>\n<h4 id="subdivide-your-programs-into-little-functions">Subdivide your programs into little functions</h4>\n<p>Small functions are easier to master.</p>\n<h4 id="factor-out-snippets-of-repeated-code-by-defining-them-in-separate-functions">Factor out snippets of repeated code by defining them in separate functions</h4>\n<p>The sharing of code obtained in this way facilitates maintenance since\nevery correction or improvement automatically spreads throughout the\nprogram. Besides, the simple act of isolating and naming a snippet of\ncode sometimes lets you identify an unsuspected feature.</p>\n<h4 id="never-copy-paste-code-when-programming">Never copy-paste code when programming</h4>\n<p>Pasting code almost surely indicates introducing a default of code\nsharing and neglecting to identify and write a useful auxiliary\nfunction; hence, it means that some code sharing is lost in the program.\nLosing code sharing implies that you will have more problems afterwards\nfor maintenance: a bug in the pasted code has to be corrected at each\noccurrence of the bug in each copy of the code!</p>\n<p>Moreover, it is difficult to identify that the same set of 10 lines of\ncode is repeated 20 times throughout the program. By contrast, if an\nauxiliary function defines those 10 lines, it is fairly easy to see and\nfind where those lines are used: that\'s simply where the function is\ncalled. If code is copy-pasted all over the place then the program is\nmore difficult to understand.</p>\n<p>In conclusion, copy-pasting code leads to programs that are more\ndifficult to read and more difficult to maintain: it has to be banished.</p>\n<h3 id="how-to-comment-programs">How to comment programs</h3>\n<h4 id="dont-hesitate-to-comment-when-theres-a-difficulty">Don\'t hesitate to comment when there\'s a difficulty</h4>\n<h4 id="if-theres-no-difficulty-theres-no-point-in-commenting">If there\'s no difficulty, there\'s no point in commenting</h4>\n<h4 id="avoid-comments-in-the-bodies-of-functions">Avoid comments in the bodies of functions</h4>\n<h4 id="prefer-one-comment-at-the-beginning-of-the-function">Prefer one comment at the beginning of the function...</h4>\n<p>...which explains how the algorithm that is used works. Once more, if\nthere is no difficulty, there is no point in commenting.</p>\n<h4 id="avoid-nocuous-comments">Avoid nocuous comments</h4>\n<p>A <em>nocuous</em> comment is a comment that does not add any value, i.e. no\nnon-trivial information. The nocuous comment is evidently not of\ninterest; it is a nuisance since it uselessly distracts the reader. It\nis often used to fulfill some strange criteria related to the so-called\n<em>software metrology</em>, for instance the ratio <em>number of comments</em> /\n<em>number of lines of code</em> that perfectly measures a ratio that I don\'t\nknow the theoretical or practical interpretation. Absolutely avoid\nnocuous comments.</p>\n<p>An example of what to avoid: the following comment uses technical words\nand is thus masquerade into a real comment when it has no additional\ninformation of interest;</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">(*\n  Function print_lambda:\n  print a lambda-expression given as argument.\n\n  Arguments: lam, any lambda-expression.\n  Returns: nothing.\n\n  Remark: print_lambda can only be used for its side effect.\n*)\nlet rec print_lambda lam =\n  match lam with\n  | Var s -&gt; printf &quot;%s&quot; s\n  | Abs l -&gt; printf &quot;\\\\ %a&quot; print_lambda l\n  | App (l1, l2) -&gt;\n     printf &quot;(%a %a)&quot; print_lambda l1 print_lambda l2\n</code></pre>\n<h4 id="usage-in-module-interface">Usage in module interface</h4>\n<p>The function\'s usage must appear in the interface of the module which\nexports it, not in the program which implements it. Choose comments as\nin the OCaml system\'s interface modules, which will subsequently allow\nthe documentation of the interface module to be extracted automatically\nif need be.</p>\n<h4 id="use-assertions">Use assertions</h4>\n<p>Use assertions as much as possible: they let you avoid verbose comments,\nwhile allowing a useful verification upon execution.</p>\n<p>For example, the conditions for the arguments of a function to be valid\nare usefully verified by assertions.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let f x =\n  assert (x &gt;= 0);\n  ...\n</code></pre>\n<p>Note as well that an assertion is often preferable to a comment because\nit\'s more trustworthy: an assertion is forced to be pertinent because it\nis verified upon each execution, while a comment can quickly become\nobsolete and then becomes actually detrimental to the comprehension of\nthe program.</p>\n<h4 id="comments-line-by-line-in-imperative-code">Comments line by line in imperative code</h4>\n<p>When writing difficult code, and particularly in case of highly\nimperative code with a lot of memory modifications (physical mutations\nin data structures), it is sometime mandatory to comment inside the body\nof functions to explain the implementation of the algorithm encoded\nhere, or to follow successive modifications of invariants that the\nfunction must maintain. Once more, if there is some difficulty\ncommenting is mandatory, for each program line if necessary.</p>\n<h3 id="how-to-choose-identifiers">How to choose identifiers</h3>\n<p>It\'s hard to choose identifiers whose name evokes the meaning of the\ncorresponding portion of the program. This is why you must devote\nparticular care to this, emphasizing clarity and regularity of\nnomenclature.</p>\n<h4 id="dont-use-abbreviations-for-global-names">Don\'t use abbreviations for global names</h4>\n<p>Global identifiers (including especially the names of functions) can be\nlong, because it\'s important to understand what purpose they serve far\nfrom their definition.</p>\n<h4 id="separate-words-by-underscores-intofstring-not-intofstring">Separate words by underscores: (<code>int_of_string</code>, not <code>intOfString</code>)</h4>\n<p>Case modifications are meaningful in OCaml: in effect capitalized words\nare reserved for constructors and module names in OCaml; in contrast\nregular variables (functions or identifiers) must start by a lowercase\nletter. Those rules prevent proper usage of case modification for words\nseparation in identifiers: the first word starts the identifier, hence\nit must be lower case and it is forbidden to choose <code>IntOfString</code> as the\nname of a function.</p>\n<h4 id="always-give-the-same-name-to-function-arguments-which-have-the-same-meaning">Always give the same name to function arguments which have the same meaning</h4>\n<p>If necessary, make this nomenclature explicit in a comment at the top of\nthe file); if there are several arguments with the same meaning then\nattach numeral suffixes to them.</p>\n<h4 id="local-identifiers-can-be-brief-and-should-be-reused-from-one-function-to-another">Local identifiers can be brief, and should be reused from one function to another</h4>\n<p>This augments regularity of style. Avoid using identifiers whose\nappearance can lead to confusion such as <code>l</code> or <code>O</code>, easy to confuse\nwith <code>1</code> and <code>0</code>.</p>\n<p>Example:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let add_expression expr1 expr2 = ...\nlet print_expression expr = ...\n</code></pre>\n<p>An exception to the recommendation not to use capitalization to separate\nwords within identifiers is tolerated in the case of interfacing with\nexisting libraries which use this naming convention: this lets OCaml\nusers of the library to orient themselves in the original library\ndocumentation more easily.</p>\n<h3 id="when-to-use-parentheses-within-an-expression">When to use parentheses within an expression</h3>\n<p>Parentheses are meaningful: they indicate the necessity of using an\nunusual precedence. So they should be used wisely and not sprinkled\nrandomly throughout programs. To this end, you should know the usual\nprecedences, that is, the combinations of operations which do not\nrequire parentheses. Quite fortunately this is not complicated if you\nknow a little mathematics or strive to follow the following rules:</p>\n<h4 id="arithmetic-operators-the-same-rules-as-in-mathematics">Arithmetic operators: the same rules as in mathematics</h4>\n<p>For example: <code>1 + 2 * x</code> means <code>1 + (2 * x)</code>.</p>\n<h4 id="function-application-the-same-rules-as-those-in-mathematics-for-usage-of-trigonometric-functions">Function application: the same rules as those in mathematics for usage of <em>trigonometric functions</em></h4>\n<p>In mathematics you write <code>sin x</code> to mean <code>sin (x)</code>. In the same way\n<code>sin x + cos x</code> means <code>(sin x) + (cos x)</code> not <code>sin (x + (cos x))</code>. Use\nthe same conventions in OCaml: write <code>f x + g x</code> to mean\n<code>(f x) + (g x)</code>.<br />\nThis convention generalizes <strong>to all (infix) operators</strong>: <code>f x :: g x</code>\nmeans <code>(f x) :: (g x)</code>, <code>f x @ g x</code> means <code>(f x) @ (g x)</code>, and\n<code>failwith s ^ s\'</code> means <code>(failwith s) ^ s\'</code>, <em>not</em> <code>failwith (s ^ s\')</code>.</p>\n<h4 id="comparisons-and-boolean-operators">Comparisons and boolean operators</h4>\n<p>Comparisons are infix operators, so the preceding rules apply. This is\nwhy <code>f x &lt; g x</code> means <code>(f x) &lt; (g x)</code>. For type reasons (no other\nsensible interpretation) the expression <code>f x &lt; x + 2</code> means\n<code>(f x) &lt; (x + 2)</code>. In the same way <code>f x &lt; x + 2 &amp;&amp; x &gt; 3</code> means\n<code>((f x) &lt; (x + 2)) &amp;&amp; (x &gt; 3)</code>.</p>\n<h4 id="the-relative-precedences-of-the-boolean-operators-are-those-of-mathematics">The relative precedences of the boolean operators are those of mathematics</h4>\n<p>Although mathematicians have a tendency to overuse parens in this case,\nthe boolean \u201cor\u201d operator is analogous to addition and the \u201cand\u201d\nto multiplication. So, just as <code>1 + 2 * x</code> means <code>1 + (2 * x)</code>,\n<code>true || false &amp;&amp; x</code> means <code>true || (false &amp;&amp; x)</code>.</p>\n<h3 id="how-to-delimit-constructs-in-programs">How to delimit constructs in programs</h3>\n<p>When it is necessary to delimit syntactic constructs in programs, use as\ndelimiters the keywords <code>begin</code> and <code>end</code> rather than parentheses.\nHowever using parentheses is acceptable if you do it in a consistent,\nthat is, systematic, way.</p>\n<p>This explicit delimiting of constructs essentially concerns\npattern-matching constructs or sequences embedded within\n<code>if then     else</code> constructs.</p>\n<h4 id="match-construct-in-a-match-construct"><code>match</code> construct in a <code>match</code> construct</h4>\n<p>When a <code>match ... with</code> or <code>try ... with</code> construct appears in a\npattern-matching clause, it is absolutely necessary to delimit this\nembedded construct (otherwise subsequent clauses of the enclosing\npattern-matching construct will automatically be associated with the\nenclosed pattern-matching construct). For example:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">match x with\n| 1 -&gt;\n  begin match y with\n  | ...\n  end\n| 2 -&gt;\n...\n</code></pre>\n<h4 id="sequences-inside-branches-of-if">Sequences inside branches of <code>if</code></h4>\n<p>In the same way, a sequence which appears in the <code>then</code> or <code>else</code> part\nof a conditional must be delimited:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">if cond then begin\n  e1;\n  e2\nend else begin\n  e3;\n  e4\nend\n</code></pre>\n<h3 id="how-to-use-modules">How to use modules</h3>\n<h4 id="subdividing-into-modules">Subdividing into modules</h4>\n<p>You must subdivide your programs into coherent modules.</p>\n<p>For each module, you must explicitly write an interface.</p>\n<p>For each interface, you must document the things defined by the module:\nfunctions, types, exceptions, etc.</p>\n<h4 id="opening-modules">Opening modules</h4>\n<p>Avoid <code>open</code> directives, using instead the qualified identifier\nnotation. Thus you will prefer short but meaningful module names.</p>\n<blockquote>\n<p><strong>Justification</strong>: The use of unqualified identifiers is ambiguous and\ngives rise to difficult-to-detect semantic errors.</p>\n</blockquote>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let lim = String.length name - 1 in\n...\nlet lim = Array.length v - 1 in\n...\n... List.map succ ...\n... Array.map succ ...\n</code></pre>\n<h4 id="when-to-use-open-modules-rather-than-leaving-them-closed">When to use open modules rather than leaving them closed</h4>\n<p>You can consider it normal to open a module which modifies the\nenvironment, and brings other versions of an important set of functions.\nFor example, the <code>Format</code> module provides automatically indented\nprinting. This module redefines the usual printing functions\n<code>print_string</code>, <code>print_int</code>, <code>print_float</code>, etc. So when you use\n<code>Format</code>, open it systematically at the top of the file.<br />\nIf you don\'t open <code>Format</code> you could miss the qualification of a\nprinting function, and this could be perfectly silent, since many of\n<code>Format</code>\'s functions have a counterpart in the default environment\n(<code>Pervasives</code>). Mixing printing functions from <code>Format</code> and <code>Pervasives</code>\nleads to subtle bugs in the display, that are difficult to trace. For\ninstance:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let f () =\n  Format.print_string &quot;Hello World!&quot;; print_newline ()\n</code></pre>\n<p>is bogus since it does not call <code>Format.print_newline</code> to flush the\npretty-printer queue and output <code>&quot;Hello World!&quot;</code>. Instead\n<code>&quot;Hello World!&quot;</code> is stuck into the pretty-printer queue, while\n<code>Pervasives.print_newline</code> outputs a carriage return on the standard\noutput ... If <code>Format</code> is printing on a file and standard output is the\nterminal, the user will have a bad time finding that a carriage return\nis missing in the file (and the display of material on the file is\nstrange, since boxes that should be closed by <code>Format.print_newline</code> are\nstill open), while a spurious carriage return appeared on the screen!</p>\n<p>For the same reason, open large libraries such as the one with\narbitrary-precision integers so as not to burden the program which uses\nthem.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">open Num\n\nlet rec fib n =\n  if n &lt;= 2 then Int 1 else fib (n - 1) +/ fib (n - 2)\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The program would be less readable if you had to\nqualify all the identifiers.</p>\n</blockquote>\n<p>In a program where type definitions are shared, it is good to gather\nthese definitions into one or more module(s) without implementations\n(containing only types). Then it\'s acceptable to systematically open the\nmodule which exports the shared type definitions.</p>\n<h3 id="pattern-matching">Pattern-matching</h3>\n<h4 id="never-be-afraid-of-over-using-pattern-matching">Never be afraid of over-using pattern-matching!</h4>\n<h4 id="on-the-other-hand-be-careful-to-avoid-non-exhaustive-pattern-matching-constructs">On the other hand, be careful to avoid non-exhaustive pattern-matching constructs</h4>\n<p>Complete them with care, without using a \u201ccatch-all\u201d clause such as\n<code>| _ -&gt; ...</code> or <code>| x -&gt; ...</code> when it\'s possible to do without it (for\nexample when matching a concrete type defined within the program). See\nalso the next section: compiler warnings.</p>\n<h3 id="compiler-warnings">Compiler warnings</h3>\n<p>Compiler warnings are meant to prevent potential errors; this is why you\nabsolutely must heed them and correct your programs if compiling them\nproduces such warnings. Besides, programs whose compilation produces\nwarnings have an odor of amateurism which certainly doesn\'t suit your\nown work!</p>\n<h4 id="pattern-matching-warnings">Pattern-matching warnings</h4>\n<p>Warnings about pattern-matching must be treated with the upmost care:</p>\n<ul>\n<li>\n<p>Those concerning useless clauses should of course be eliminated.</p>\n</li>\n<li>\n<p>For non-exhaustive pattern-matching you must complete the\ncorresponding pattern-matching construct, without adding a default\ncase \u201ccatch-all\u201d, such as <code>| _ -&gt; ... </code>, but with an explicit\nlist of the constructors not examined by the rest of the construct,\nfor example <code>| Cn _ | Cn1 _ -&gt; ... </code>.</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>Justification</strong>: It\'s not really any more complicated to write\nit this way, and this allows the program to evolve more safely. In\neffect the addition of a new constructor to the datatype being\nmatched will produce an alert anew, which will allow the\nprogrammer to add a clause corresponding to the new constructor if\nthat is warranted. On the contrary, the \u201ccatch-all\u201d clause\nwill make the function compile silently and it might be thought\nthat the function is correct as the new constructor will be\nhandled by the default case.</p>\n</blockquote>\n<ul>\n<li>Non-exhaustive pattern-matches induced by clauses with guards must\nalso be corrected. A typical case consists in suppressing a\nredundant guard.\n</li>\n</ul>\n<h4 id="de-structuring-let-bindings">De-structuring <code>let</code> bindings</h4>\n<p>[Translator\'s note: a \u201cde-structuring <code>let</code> binding\u201d is one which\nbinds several names to several expressions simultaneously. You pack all\nthe names you want bound into a collection such as a tuple or a list,\nand you correspondingly pack all the expressions into a collective\nexpression. When the <code>let</code> binding is evaluated, it unpacks the\ncollections on both sides and binds each expression to its corresponding\nname. For example, <code>let x, y = 1, 2</code> is a de-structuring <code>let</code> binding\nwhich performs both the bindings <code>let x = 1</code> and <code>let y = 2</code>\nsimultaneously.]<br />\nThe <code>let</code> binding is not limited to simple identifier definitions: you\ncan use it with more complex or simpler patterns. For instance</p>\n<ul>\n<li><code>let</code> with complex patterns:<br />\n<code>let [x; y] as l = ...</code><br />\nsimultaneously defines a list <code>l</code> and its two elements <code>x</code> and <code>y</code>.\n</li>\n<li><code>let</code> with simple pattern:<br />\n<code>let _ = ...</code> does not define anything, it just evaluate the\nexpression on the right hand side of the <code>=</code> symbol.\n</li>\n</ul>\n<h4 id="the-de-structuring-let-must-be-exhaustive">The de-structuring <code>let</code> must be exhaustive</h4>\n<p>Only use de-structuring <code>let</code> bindings in the case where the\npattern-matching is exhaustive (the pattern can never fail to match).\nTypically, you will thus be limited to definitions of product types\n(tuples or records) or definitions of variant type with a single case.\nIn any other case, you should use an explicit <code>match   ... with</code>\nconstruct.</p>\n<ul>\n<li><code>let ... in</code>: de-structuring <code>let</code> that give a warning must be\nreplaced by an explicit pattern matching. For instance, instead of\n<code>let [x; y] as l = List.map succ     (l1 @ l2) in expression</code> write:\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">match List.map succ (l1 @ l2) with\n| [x; y] as l -&gt; expression\n| _ -&gt; assert false\n</code></pre>\n<ul>\n<li>Global definition with de-structuring lets should be rewritten with\nexplicit pattern matching and tuples:\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let x, y, l =\n  match List.map succ (l1 @ l2) with\n  | [x; y] as l -&gt; x, y, l\n  | _ -&gt; assert false\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: There is no way to make the pattern-matching\nexhaustive if you use general de-structuring <code>let</code> bindings.</p>\n</blockquote>\n<h4 id="sequence-warnings-and-let---">Sequence warnings and <code>let _ = ...</code></h4>\n<p>When the compiler emits a warning about the type of an expression in a\nsequence, you have to explicitly indicate that you want to ignore the\nresult of this expression. To this end:</p>\n<ul>\n<li>use a vacuous binding and suppress the sequence warning of\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">List.map f l;\nprint_newline ()\n</code></pre>\n<p>write</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let _ = List.map f l in\nprint_newline ()\n</code></pre>\n<ul>\n<li>you can also use the predefined function <code>ignore : \'a     -&gt; unit</code>\nthat ignores its argument to return <code>unit</code>.\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">ignore (List.map f l);\nprint_newline ()\n</code></pre>\n<ul>\n<li>In any case, the best way to suppress this warning is to understand\nwhy it is emitted by the compiler: the compiler warns you because\nyour code computes a result that is useless since this result is\njust deleted after computation. Hence, if useful at all, this\ncomputation is performed only for its side-effects; hence it should\nreturn unit.<br />\nMost of the time, the warning indicates the use of the wrong\nfunction, a probable confusion between the side-effect only version\nof a function (which is a procedure whose result is irrelevant) with\nits functional counterpart (whose result is meaningful).<br />\nIn the example mentioned above, the first situation prevailed, and\nthe programmer should have called <code>iter</code> instead of <code>map</code>, and\nsimply write\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">List.iter f l;\nprint_newline ()\n</code></pre>\n<p>In actual programs, the suitable (side-effect only) function may not\nexist and has to be written: very often, a careful separation of the\nprocedural part from the functional part of the function at hand\nelegantly solves the problem, and the resulting program just looks\nbetter afterwards! For instance, you would turn the problematic\ndefinition:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let add x y =\n  if x &gt; 1 then print_int x;\n  print_newline ();\n  x + y;;\n</code></pre>\n<p>into the clearer separate definitions and change old calls to <code>add</code>\naccordingly.</p>\n<p>In any case, use the <code>let _ = ...</code> construction exactly in those cases\nwhere you want to ignore a result. Don\'t systematically replace\nsequences with this construction.</p>\n<blockquote>\n<p><strong>Justification</strong>: Sequences are much clearer! Compare <code>e1; e2; e3</code> to</p>\n<pre><code class="language-ocaml">let _ = e1 in\nlet _ = e2 in\ne3\n</code></pre>\n</blockquote>\n<h3 id="the-hd-and-tl-functions">The <code>hd</code> and <code>tl</code> functions</h3>\n<p>Don\'t use the <code>hd</code> and <code>tl</code> functions, but pattern-match the list\nargument explicitly.</p>\n<blockquote>\n<p><strong>Justification</strong>: This is just as brief as and much clearer than\nusing <code>hd</code> and <code>tl</code> which must of necessity be protected by\n<code>try... with...</code> to catch the exception which might be raised by these\nfunctions.</p>\n</blockquote>\n<h3 id="loops">Loops</h3>\n<h4 id="for-loops"><code>for</code> loops</h4>\n<p>To simply traverse an array or a string, use a <code>for</code> loop.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">for i = 0 to Array.length v - 1 do\n  ...\ndone\n</code></pre>\n<p>If the loop is complex or returns a result, use a recursive function.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let find_index e v =\n  let rec loop i =\n    if i &gt;= Array.length v then raise Not_found else\n    if v.(i) = e then i else loop (i + 1) in\n  loop 0;;\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: The recursive function lets you code any loop\nwhatsoever simply, even a complex one, for example with multiple exit\npoints or with strange index steps (steps depending on a data value\nfor example).</p>\n<p>Besides, the recursive loop avoids the use of mutables whose value can\nbe modified in any part of the body of the loop whatsoever (or even\noutside): on the contrary the recursive loop explicitly takes as\narguments the values susceptible to change during the recursive calls.</p>\n</blockquote>\n<h4 id="while-loops"><code>while</code> loops</h4>\n<blockquote>\n<p><strong>While loops law</strong>: Beware: usually a while loop is wrong, unless its\nloop invariant has been explicitly written.</p>\n</blockquote>\n<p>The main use of the <code>while</code> loop is the infinite loop\n<code>while true do     ...</code>. You get out of it through an exception,\ngenerally on termination of the program.</p>\n<p>Other <code>while</code> loops are hard to use, unless they come from canned\nprograms from algorithms courses where they were proved.</p>\n<blockquote>\n<p><strong>Justification</strong>: <code>while</code> loops require one or more mutables in order\nthat the loop condition change value and the loop finally terminate.\nTo prove their correctness, you must therefore discover the loop\ninvariants, an interesting but difficult sport.</p>\n</blockquote>\n<h3 id="exceptions">Exceptions</h3>\n<p>Don\'t be afraid to define your own exceptions in your programs, but on\nthe other hand use as much as possible the exceptions predefined by the\nsystem. For example, every search function which fails should raise the\npredefined exception <code>Not_found</code>. Be careful to handle the exceptions\nwhich may be raised by a function call with the help of a\n<code>try ... with</code>.</p>\n<p>Handling all exceptions by <code>try     ... with _ -&gt;</code> is usually reserved\nfor the main function of the program. If you need to catch all\nexceptions to maintain an invariant of an algorithm, be careful to name\nthe exception and re-raise it, after having reset the invariant.\nTypically:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let ic = open_in ...\nand oc = open_out ... in\ntry\n  treatment ic oc;\n  close_in ic; close_out oc\nwith x -&gt; close_in ic; close_out oc; raise x\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: <code>try ... with _     -&gt;</code> silently catches all\nexceptions, even those which have nothing to do with the computation\nat hand (for example an interruption will be captured and the\ncomputation will continue anyway!).</p>\n</blockquote>\n<h3 id="data-structures">Data structures</h3>\n<p>One of the great strengths of OCaml is the power of the data structures\nwhich can be defined and the simplicity of manipulating them. So you\nmust take advantage of this to the fullest extent; don\'t hesitate to\ndefine your own data structures. In particular, don\'t systematically\nrepresent enumerations by whole numbers, nor enumerations with two cases\nby booleans. Examples:</p>\n<pre><code class="language-ocaml">type figure =\n   | Triangle | Square | Circle | Parallelogram\ntype convexity =\n   | Convex | Concave | Other\ntype type_of_definition =\n   | Recursive | Non_recursive\n</code></pre>\n<blockquote>\n<p><strong>Justification</strong>: A boolean value often prevents intuitive\nunderstanding of the corresponding code. For example, if\n<code>type_of_definition</code> is coded by a boolean, what does <code>true</code> signify?\nA \u201cnormal\u201d definition (that is, non-recursive) or a recursive\ndefinition?</p>\n<p>In the case of an enumerated type encode by an integer, it is very\ndifficult to limit the range of acceptable integers: one must define\nconstruction functions that will ensure the mandatory invariants of\nthe program (and verify afterwards that no values has been built\ndirectly), or add assertions in the program and guards in pattern\nmatchings. This is not good practice, when the definition of a sum\ntype elegantly solves this problem, with the additional benefit of\nfiring the full power of pattern matching and compiler\'s verifications\nof exhaustiveness.</p>\n<p><strong>Criticism</strong>: For binary enumerations, one can systematically define\npredicates whose names carry the semantics of the boolean that\nimplements the type. For instance, we can adopt the convention that a\npredicate ends by the letter <code>p</code>. Then, in place of defining a new sum\ntype for <code>type_of_definition</code>, we will use a predicate function\n<code>recursivep</code> that returns true if the definition is recursive.</p>\n<p><strong>Answer</strong>: This method is specific to binary enumeration and cannot\nbe easily extended; moreover it is not well suited to pattern\nmatching. For instance, for definitions encoded by\n<code>| Let of bool * string * expression</code> a typical pattern matching would\nlook like:</p>\n<pre><code class="language-ocaml">| Let (_, v, e) as def -&gt;\n   if recursivep def then code_for_recursive_case\n   else code_for_non_recursive_case\n</code></pre>\n<p>or, if <code>recursivep</code> can be applied to booleans:</p>\n<pre><code class="language-ocaml">| Let (b, v, e) -&gt;\n   if recursivep b then code_for_recursive_case\n   else code_for_non_recursive_case\n</code></pre>\n<p>contrast with an explicit encoding:</p>\n<pre><code class="language-ocaml">| Let (Recursive, v, e) -&gt; code_for_recursive_case\n| Let (Non_recursive, v, e) -&gt; code_for_non_recursive_case\n</code></pre>\n<p>The difference between the two programs is subtle and you may think\nthat this is just a matter of taste; however the explicit encoding is\ndefinitively more robust to modifications and fits better with the\nlanguage.</p>\n</blockquote>\n<p><em>A contrario</em>, it is not necessary to systematically define new types\nfor boolean flags, when the interpretation of constructors <code>true</code> and\n<code>false</code> is clear. The usefulness of the definition of the following\ntypes is then questionable:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">type switch = On | Off\ntype bit = One | Zero\n</code></pre>\n<p>The same objection is admissible for enumerated types represented as\nintegers, when those integers have an evident interpretation with\nrespect to the data to be represented.</p>\n<h3 id="when-to-use-mutables">When to use mutables</h3>\n<p>Mutable values are useful and sometimes indispensable to simple and\nclear programming. Nevertheless, you must use them with discernment:\nOCaml\'s normal data structures are immutable. They are to be preferred\nfor the clarity and safety of programming which they allow.</p>\n<h3 id="iterators">Iterators</h3>\n<p>OCaml\'s iterators are a powerful and useful feature. However you should\nnot overuse them, nor <em>a contrario</em> neglect them: they are provided to\nyou by libraries and have every chance of being correct and\nwell-thought-out by the author of the library. So it\'s useless to\nreinvent them.</p>\n<p>So write</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let square_elements elements = List.map square elements\n</code></pre>\n<p>rather than:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec square_elements = function\n  | [] -&gt; []\n  | elem :: elements -&gt; square elem :: square_elements elements\n</code></pre>\n<p>On the other hand avoid writing:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let iterator f x l =\n  List.fold_right (List.fold_left f) [List.map x l] l\n</code></pre>\n<p>even though you get:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">  let iterator f x l =\n    List.fold_right (List.fold_left f) [List.map x l] l;;\n  iterator (fun l x -&gt; x :: l) (fun l -&gt; List.rev l) [[1; 2; 3]]\n</code></pre>\n<p>In case of express need, you must be careful to add an explanatory\ncomment: in my opinion it\'s absolutely necessary!</p>\n<h3 id="how-to-optimize-programs">How to optimize programs</h3>\n<blockquote>\n<p><strong>Pseudo law of optimization</strong>: No optimization <em>a priori</em>.<br />\nNo optimization <em>a posteriori</em> either.</p>\n</blockquote>\n<p>Above all program simply and clearly. Don\'t start optimizing until the\nprogram bottleneck has been identified (in general a few routines). Then\noptimization consists above all of changing <em>the complexity</em> of the\nalgorithm used. This often happens through redefining the data\nstructures being manipulated and completely rewriting the part of the\nprogram which poses a problem.</p>\n<blockquote>\n<p><strong>Justification</strong>: Clarity and correctness of programs take\nprecedence. Besides, in a substantial program, it is practically\nimpossible to identify <em>a priori</em> the parts of the program whose\nefficiency is of prime importance.</p>\n</blockquote>\n<h3 id="how-to-choose-between-classes-and-modules">How to choose between classes and modules</h3>\n<p>You should use OCaml classes when you need inheritance, that is,\nincremental refinement of data and their functionality.</p>\n<p>You should use conventional data structures (in particular, variant\ntypes) when you need pattern-matching.</p>\n<p>You should use modules when the data structures are fixed and their\nfunctionality is equally fixed or it\'s enough to add new functions in\nthe programs which use them.</p>\n<h3 id="clarity-of-ocaml-code">Clarity of OCaml code</h3>\n<p>The OCaml language includes powerful constructs which allow simple and\nclear programming. The main problem to obtain crystal clear programs it\nto use them appropriately.</p>\n<p>The language features numerous programming styles (or programming\nparadigms): imperative programming (based on the notion of state and\nassignment), functional programming (based on the notion of function,\nfunction results, and calculus), object oriented programming (based of\nthe notion of objects encapsulating a state and some procedures or\nmethods that can modify the state). The first work of the programmer is\nto choose the programming paradigm that fits the best the problem at\nhand. When using one of those programming paradigms, the difficulty is\nto use the language construct that expresses in the most natural and\neasiest way the computation that implements the algorithm.</p>\n<h4 id="style-dangers">Style dangers</h4>\n<p>Concerning programming styles, one can usually observe the two\nsymmetrical problematic behaviors: on the one hand, the \u201call\nimperative\u201d way (<em>systematic</em> usage of loops and assignment), and on\nthe other hand the \u201cpurely functional\u201d way (<em>never</em> use loops nor\nassignments); the \u201c100% object\u201d style will certainly appear in the\nnext future, but (fortunately) it is too new to be discussed here.</p>\n<ul>\n<li><strong>The \u201cToo much imperative\u201d danger</strong>:\n<ul>\n<li>It is a bad idea to use imperative style to code a function that\nis <em>naturally</em> recursive. For instance, to compute the length of\na list, you should not write:\n</li>\n</ul>\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let list_length l =\n  let l = ref l in\n  let res = ref 0 in\n  while !l &lt;&gt; [] do\n    incr res; l := List.tl !l\n  done;\n  !res;;\n</code></pre>\n<p>in place of the following recursive function, so simple and\nclear:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec list_length = function\n  | [] -&gt; 0\n  | _ :: l -&gt; 1 + list_length l\n</code></pre>\n<p>(For those that would contest the equivalence of those two\nversions, see the <a href="#Imperativeandfunctionalversionsoflistlength">note below</a>).</p>\n<ul>\n<li>\n<p>Another common \u201cover imperative error\u201d in the imperative world is\nnot to systematically choose the simple <code>for</code> loop to iter on the\nelement of a vector, but instead to use a complex <code>while</code> loop, with\none or two references (too many useless assignments, too many\nopportunity for errors).</p>\n</li>\n<li>\n<p>This category of programmer feels that the <code>mutable</code> keyword in\nthe record type definitions should be implicit.</p>\n</li>\n<li>\n<p><strong>The \u201cToo much functional\u201d danger</strong>:</p>\n<ul>\n<li>The programmer that adheres to this dogma avoids\nusing arrays and assignment. In the most severe case, one\nobserves a complete denial of writing any imperative\nconstruction, even in case it is evidently the most elegant way\nto solve the problem.\n</li>\n<li>Characteristic symptoms: systematic rewriting of <code>for</code> loops\nwith recursive functions, usage of lists in contexts where\nimperative data structures seem to be mandatory to anyone,\npassing numerous global parameters of the problem to every\nfunctions, even if a global reference would be perfect to avoid\nthese spurious parameters that are mainly invariants that must\nbe passed all over the place.\n</li>\n<li>This programmer feels that the <code>mutable</code> keyword in the record\ntype definitions should be suppressed from the language.\n</li>\n</ul>\n</li>\n</ul>\n<h4 id="ocaml-code-generally-considered-unreadable">OCaml code generally considered unreadable</h4>\n<p>The OCaml language includes powerful constructs which allow simple and\nclear programming. However the power of these constructs also lets you\nwrite uselessly complicated code, to the point where you get a perfectly\nunreadable program.</p>\n<p>Here are a number of known ways:</p>\n<ul>\n<li>Use useless (hence novice for readability) <code>if then else</code>, as in\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let flush_ps () =\n  if not !psused then psused := true\n</code></pre>\n<p>or (more subtle)</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let sync b =\n  if !last_is_dvi &lt;&gt; b then last_is_dvi := b\n</code></pre>\n<ul>\n<li>Code one construct with another. For example code a <code>let ... in</code> by\nthe application of an anonymous function to an argument. You would\nwrite<br />\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">(fun x y -&gt; x + y)\n   e1 e2\n</code></pre>\n<p>instead of simply writing</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let x = e1\nand y = e2 in\nx + y\n</code></pre>\n<ul>\n<li>\n<p>Systematically code sequences with <code>let in</code> bindings.</p>\n</li>\n<li>\n<p>Mix computations and side effects, particularly in function calls.\nRecall that the order of evaluation of arguments in a function call\nis unspecified, which implies that you must not mix side effects and\ncomputations in function calls. However, when there is only one\nargument you might take advantage of this to perform a side effect\nwithin the argument, which is extremely troublesome for the reader\nalbeit without danger to the program semantics. To be absolutely\nforbidden.</p>\n</li>\n<li>\n<p>Misuse of iterators and higher-order functions (i.e. over- or\nunder-use). For example it\'s better to use <code>List.map</code> or\n<code>List.iter</code> than to write their equivalents in-line using specific\nrecursive functions of your own. Even worse, you don\'t use\n<code>List.map</code> or <code>List.iter</code> but write their equivalents in terms of\n<code>List.fold_right</code> and <code>List.fold_left</code>.</p>\n</li>\n<li>\n<p>Another efficient way to write unreadable code is to mix all or some\nof these methods. For example:</p>\n</li>\n</ul>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">(fun u -&gt; print_string &quot;world&quot;; print_string u)\n  (let temp = print_string &quot;Hello&quot;; &quot;!&quot; in\n   ((fun x -&gt; print_string x; flush stdout) &quot; &quot;;\n    temp));;\n</code></pre>\n<p>If you naturally write the program <code>print_string &quot;Hello world!&quot;</code> in this\nway, you can without a doubt submit your work to the <a href="mailto:Pierre.Weis@inria.fr">Obfuscated OCaml\nContest</a>.</p>\n<h2 id="managing-program-development">Managing program development</h2>\n<p>We give here tips from veteran OCaml programmers, which have served in\ndeveloping the compilers which are good examples of large complex\nprograms developed by small teams.</p>\n<h3 id="how-to-edit-programs">How to edit programs</h3>\n<p>Many developers nurture a kind of veneration towards the Emacs editor\n(gnu-emacs in general) which they use to write their programs. The\neditor interfaces well with the language since it is capable of syntax\ncoloring OCaml source code (rendering different categories of words in\ncolor, coloring keywords for example).</p>\n<p>The following two commands are considered indispensable:</p>\n<ul>\n<li><code>CTRL-C-CTRL-C</code> or <code>Meta-X compile</code>: launches re-compilation from\nwithin the editor (using the <code>make</code> command).\n</li>\n<li><code>CTRL-X-`</code>: puts the cursor in the file and at the exact place\nwhere the OCaml compiler has signaled an error.\n</li>\n</ul>\n<p>Developers describe thus how to use these features: <code>CTRL-C-CTRL-C</code>\ncombination recompiles the whole application; in case of errors, a\nsuccession of <code>CTRL-X-`</code> commands permits correction of all the\nerrors signaled; the cycle begins again with a new re-compilation\nlaunched by <code>CTRL-C-CTRL-C</code>.</p>\n<h4 id="other-emacs-tricks">Other emacs tricks</h4>\n<p>The <code>ESC-/</code> command (dynamic-abbrev-expand) automatically completes the\nword in front of the cursor with one of the words present in one of the\nfiles being edited. Thus this lets you always choose meaningful\nidentifiers without the tedium of having to type extended names in your\nprograms: the <code>ESC-/</code> easily completes the identifier after typing the\nfirst letters. In case it brings up the wrong completion, each\nsubsequent <code>ESC-/</code> proposes an alternate completion.</p>\n<p>Under Unix, the <code>CTRL-C-CTRL-C</code> or <code>Meta-X     compile</code> combination,\nfollowed by <code>CTRL-X-`</code> is also used to find all occurrences of a\ncertain string in a OCaml program. Instead of launching <code>make</code> to\nrecompile, you launch the <code>grep</code> command; then all the \u201cerror\nmessages\u201d from <code>grep</code> are compatible with the <code>CTRL-X-`</code> usage\nwhich automatically takes you to the file and the place where the string\nis found.</p>\n<h3 id="how-to-edit-with-the-interactive-system">How to edit with the interactive system</h3>\n<p>Under Unix: use the line editor <code>ledit</code> which offers great editing\ncapabilities \u201c\xe0 la emacs\u201d (including <code>ESC-/</code>!), as well as a history\nmechanism which lets you retrieve previously typed commands and even\nretrieve commands from one session in another. <code>ledit</code> is written in\nOCaml and can be freely down-loaded\n<a href="ftp://ftp.inria.fr/INRIA/Projects/cristal/caml-light/bazar-ocaml/ledit.tar.gz">here</a>.</p>\n<h3 id="how-to-compile">How to compile</h3>\n<p>The <code>make</code> utility is indispensable for managing the compilation and\nre-compilation of programs. Sample <code>make</code> files can be found on <a href="https://caml.inria.fr//cgi-bin/hump.en.cgi">The\nHump</a>. You can also consult\nthe <code>Makefiles</code> for the OCaml compilers.</p>\n<h3 id="how-to-develop-as-a-team-version-control">How to develop as a team: version control</h3>\n<p>Users of the <a href="https://git-scm.com/">Git</a> software version control system\nnever run out of good things to say about the productivity gains it\nbrings. This system supports managing development by a team of\nprogrammers while imposing consistency among them, and also maintains a\nlog of changes made to the software.<br />\nGit also supports simultaneous development by several teams, possibly\ndispersed among several sites linked on the Net.</p>\n<p>An anonymous Git read-only mirror <a href="https://github.com/ocaml/ocaml">contains the working sources of the\nOCaml compilers</a>, and the sources of\nother software related to OCaml.</p>\n<h2 id="notes">Notes</h2>\n<h3 id="imperative-and-functional-versions-of-listlength">Imperative and functional versions of <code>list_length</code></h3>\n<p>The two versions of <code>list_length</code> are not completely equivalent in term\nof complexity, since the imperative version uses a constant amount of\nstack room to execute, whereas the functional version needs to store\nreturn addresses of suspended recursive calls (whose maximum number is\nequal to the length of the list argument). If you want to retrieve a\nconstant space requirement to run the functional program you just have\nto write a function that is recursive in its tail (or <em>tail-rec</em>), that\nis a function that just ends by a recursive call (which is not the case\nhere since a call to <code>+</code> has to be perform after the recursive call has\nreturned). Just use an accumulator for intermediate results, as in:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let list_length l =\n  let rec loop accu = function\n    | [] -&gt; accu\n    | _ :: l -&gt; loop (accu + 1) l in\n  loop 0 l\n</code></pre>\n<p>This way, you get a program that has the same computational properties\nas the imperative program with the additional clarity and natural\nlook of an algorithm that performs pattern matching and recursive\ncalls to handle an argument that belongs to a recursive sum data type.</p>\n'},tl:{hd:{title:"Compiling OCaml Projects",slug:"compiling-ocaml-projects",description:"An introduction to the OCaml compiler tools for building OCaml projects as well as the most common build tools\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"getting-started",tl:0},users:{hd:"Intermediate",tl:0},body_md:"\nThis tutorial explains how to compile your OCaml programs into executable form.\nIt addresses, in turn:\n\n1. The compilation commands `ocamlc` and `ocamlopt` provided with OCaml. It is\n   useful to learn these commands to understand OCaml's compilation model.\n\n1. The `ocamlfind` front-end to the compiler, which saves you from worrying\n   about where libraries have been installed on your particular system. \n\n1. Automatic build systems for OCaml, such as `dune`, which release us from\n   details of compiler command invocation, so we never touch `ocamlc`,\n   `ocamlopt`, or even `ocamlfind`.\n\nIn our [up and running tutorial](up_and_running.html) we jumped straight to using\nthe automated build system `dune`. Now we shall look under the hood.\n\n## Compilation basics\n\nIn this section, we will first see how to compile a simple program using\nonly `ocamlc` or `ocamlopt`. Then we will see how to use libraries and how\nto take advantage of the\n[findlib](https://projects.camlcity.org/projects/findlib.html)\nsystem, which provides the `ocamlfind` command.\n\n### The ocamlc and ocamlopt compilers\n\nOCaml comes with two compilers: `ocamlc` is the bytecode compiler, and\n`ocamlopt` is the native code compiler. If you don't know which one to use, use\n`ocamlopt` since it provides executables that are faster than bytecode.\n\nLet's assume that our program `program` has two source files,\n`module1.ml` and `module2.ml`. We will compile them to native code,\nusing `ocamlopt`. For now, we also assume that they do not use any other\nlibrary than the standard library, which is automatically loaded. You\ncan compile the program in one single step:\n\n```shell\nocamlopt -o program module1.ml module2.ml\n```\n\nThe compiler produces an executable named `program` or `program.exe`. The order\nof the source files matters, and so `module1.ml` cannot depend upon things that\nare defined in `module2.ml`.\n\nThe OCaml distribution is shipped with the standard library, plus several other\nlibraries. There are also a large number of third-party libraries, for a wide\nrange of applications, from networking to graphics. You should understand the\nfollowing:\n\n1. The OCaml compilers know where the standard library is and use it\n   systematically (try: `ocamlc -where`). You don't have to worry much about\n   it.\n\n1. The other libraries that ship with the OCaml distribution (str, unix, etc.)\n   are installed in the same directory as the standard library.\n\n1. Third-party libraries may be installed in various places, and even a given\n   library can be installed in different places from one system to another.\n\nIf your program uses the unix library in addition to the standard library, for\nexample, the command line would be:\n\n```shell\nocamlopt -o program unix.cmxa module1.ml module2.ml\n```\n\nNote that `.cmxa` is the extension of native code libraries, while `.cma` is\nthe extension of bytecode libraries. The file `unix.cmxa` is found because it\nis always installed at the same place as the standard library, and this\ndirectory is in the library search path.\n\nIf your program depends upon third-party libraries, you must pass them on the\ncommand line. You must also indicate the libraries on which these libraries\ndepend. You must also pass the -I option to `ocamlopt` for each directory where\nthey may be found. This becomes complicated, and this information is\ninstallation dependent. So we will use `ocamlfind` instead, which does these\njobs for us.\n\n###  Using the ocamlfind front-end\n\nThe `ocamlfind` front-end is often used for compiling programs that use\nthird-party OCaml libraries. Library authors themselves make their library\ninstallable with `ocamlfind` as well. You can install `ocamlfind` using the\nopam package manager, by typing `opam install ocamlfind`.\n\nLet's assume that all the libraries you want to use have been installed\nproperly with ocamlfind. You can see which libraries are available in your\nsystem by typing:\n\n```shell\nocamlfind list\n```\n\nThis shows the list of package names, with their versions. Note that most\nopam packages install software using ocamlfind, so your list of ocamlfind\nlibraries will be somewhat similar to your list of installed opam packages\nobtained by `opam list`.\n\nThe command for compiling our program using package `pkg` will be:\n\n```shell\nocamlfind ocamlopt -o program -linkpkg -package pkg module1.ml module2.ml\n```\n\nMultiple packages may be specified using commas e.g `pkg1,pkg2`. Ocamlfind\nknows how to find any files `ocamlopt` may need from the package, for example\n`.cmxa` implementation files or `.cmi` interface files, because they have been\npackaged together and installed at a known location by ocamlfind. We need only\nthe name `pkg` to refer to them all - ocamlfind does the rest.\n\nNote that you can compile the files separately. This is useful if\nyou want to recompile only some parts of the programs. Here are the\nequivalent commands that perform a separate compilation of the source\nfiles and link them together in a final step:\n\n```shell\nocamlfind ocamlopt -c -package pkg module1.ml\nocamlfind ocamlopt -c -package pkg module2.ml\nocamlfind ocamlopt -o program -linkpkg -package pkg module1.cmx module2.cmx\n```\n\nSeparate compilation (one command for `module1.ml`, another for `module2.ml`\nand another to link the final output) is usually not performed manually but\nonly when using an automated build system that will take care of recompiling\nonly what it necessary.\n\n## Interlude: making a custom toplevel\n\nOCaml provides another tool `ocamlmktop` to make an interactive toplevel with\nlibraries accessible. For example:\n\n```shell\nocamlmktop -o toplevel unix.cma module1.ml module2.ml\n```\n\nWe run `toplevel` and get an OCaml toplevel with modules `Unix`, `Module1`, and\n`Module2` all available, allowing us to experiment interactively with our\nprogram.\n\nOCamlfind also supports `ocamlmktop`:\n\n```shell\nocamlfind ocamlmktop -o toplevel unix.cma -package pkg module1.ml module2.ml\n```\n\n## Dune: an automated build system\n\nThe most popular modern system for building OCaml projects is\n[dune](https://dune.readthedocs.io/en/stable/) which may be installed with\n`opam install dune`. It allows one to build OCaml projects from a simple\ndescription of their elements. For example, the dune file for our project might\nlook like this:\n\n```scheme\n;; our example project\n(executable\n  (name program)\n  (libraries unix pkg))\n```\n\nThe dune [quick-start\nguide](https://dune.readthedocs.io/en/latest/quick-start.html) shows you how to\nwrite such description files for more complicated situations, and how to\nstructure, build, and run dune projects. \n\n## Other build systems\n\n- [OMake](https://github.com/ocaml-omake/omake) Another OCaml build system.\n- [GNU make](https://www.gnu.org/software/make/) GNU make can build anything, including OCaml. May be used in conjunction with [OCamlmakefile](https://github.com/mmottl/ocaml-makefile)\n- [Oasis](https://github.com/ocaml/oasis) Generates a configure, build, and install system from a specification.\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#compilation-basics">Compilation basics</a>\n</li>\n<li><a href="#interlude-making-a-custom-toplevel">Interlude: making a custom toplevel</a>\n</li>\n<li><a href="#dune-an-automated-build-system">Dune: an automated build system</a>\n</li>\n<li><a href="#other-build-systems">Other build systems</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>This tutorial explains how to compile your OCaml programs into executable form.\nIt addresses, in turn:</p>\n<ol>\n<li>\n<p>The compilation commands <code>ocamlc</code> and <code>ocamlopt</code> provided with OCaml. It is\nuseful to learn these commands to understand OCaml\'s compilation model.</p>\n</li>\n<li>\n<p>The <code>ocamlfind</code> front-end to the compiler, which saves you from worrying\nabout where libraries have been installed on your particular system.</p>\n</li>\n<li>\n<p>Automatic build systems for OCaml, such as <code>dune</code>, which release us from\ndetails of compiler command invocation, so we never touch <code>ocamlc</code>,\n<code>ocamlopt</code>, or even <code>ocamlfind</code>.</p>\n</li>\n</ol>\n<p>In our <a href="up_and_running.html">up and running tutorial</a> we jumped straight to using\nthe automated build system <code>dune</code>. Now we shall look under the hood.</p>\n<h2 id="compilation-basics">Compilation basics</h2>\n<p>In this section, we will first see how to compile a simple program using\nonly <code>ocamlc</code> or <code>ocamlopt</code>. Then we will see how to use libraries and how\nto take advantage of the\n<a href="https://projects.camlcity.org/projects/findlib.html">findlib</a>\nsystem, which provides the <code>ocamlfind</code> command.</p>\n<h3 id="the-ocamlc-and-ocamlopt-compilers">The ocamlc and ocamlopt compilers</h3>\n<p>OCaml comes with two compilers: <code>ocamlc</code> is the bytecode compiler, and\n<code>ocamlopt</code> is the native code compiler. If you don\'t know which one to use, use\n<code>ocamlopt</code> since it provides executables that are faster than bytecode.</p>\n<p>Let\'s assume that our program <code>program</code> has two source files,\n<code>module1.ml</code> and <code>module2.ml</code>. We will compile them to native code,\nusing <code>ocamlopt</code>. For now, we also assume that they do not use any other\nlibrary than the standard library, which is automatically loaded. You\ncan compile the program in one single step:</p>\n<pre><code class="language-shell">ocamlopt -o program module1.ml module2.ml\n</code></pre>\n<p>The compiler produces an executable named <code>program</code> or <code>program.exe</code>. The order\nof the source files matters, and so <code>module1.ml</code> cannot depend upon things that\nare defined in <code>module2.ml</code>.</p>\n<p>The OCaml distribution is shipped with the standard library, plus several other\nlibraries. There are also a large number of third-party libraries, for a wide\nrange of applications, from networking to graphics. You should understand the\nfollowing:</p>\n<ol>\n<li>\n<p>The OCaml compilers know where the standard library is and use it\nsystematically (try: <code>ocamlc -where</code>). You don\'t have to worry much about\nit.</p>\n</li>\n<li>\n<p>The other libraries that ship with the OCaml distribution (str, unix, etc.)\nare installed in the same directory as the standard library.</p>\n</li>\n<li>\n<p>Third-party libraries may be installed in various places, and even a given\nlibrary can be installed in different places from one system to another.</p>\n</li>\n</ol>\n<p>If your program uses the unix library in addition to the standard library, for\nexample, the command line would be:</p>\n<pre><code class="language-shell">ocamlopt -o program unix.cmxa module1.ml module2.ml\n</code></pre>\n<p>Note that <code>.cmxa</code> is the extension of native code libraries, while <code>.cma</code> is\nthe extension of bytecode libraries. The file <code>unix.cmxa</code> is found because it\nis always installed at the same place as the standard library, and this\ndirectory is in the library search path.</p>\n<p>If your program depends upon third-party libraries, you must pass them on the\ncommand line. You must also indicate the libraries on which these libraries\ndepend. You must also pass the -I option to <code>ocamlopt</code> for each directory where\nthey may be found. This becomes complicated, and this information is\ninstallation dependent. So we will use <code>ocamlfind</code> instead, which does these\njobs for us.</p>\n<h3 id="using-the-ocamlfind-front-end">Using the ocamlfind front-end</h3>\n<p>The <code>ocamlfind</code> front-end is often used for compiling programs that use\nthird-party OCaml libraries. Library authors themselves make their library\ninstallable with <code>ocamlfind</code> as well. You can install <code>ocamlfind</code> using the\nopam package manager, by typing <code>opam install ocamlfind</code>.</p>\n<p>Let\'s assume that all the libraries you want to use have been installed\nproperly with ocamlfind. You can see which libraries are available in your\nsystem by typing:</p>\n<pre><code class="language-shell">ocamlfind list\n</code></pre>\n<p>This shows the list of package names, with their versions. Note that most\nopam packages install software using ocamlfind, so your list of ocamlfind\nlibraries will be somewhat similar to your list of installed opam packages\nobtained by <code>opam list</code>.</p>\n<p>The command for compiling our program using package <code>pkg</code> will be:</p>\n<pre><code class="language-shell">ocamlfind ocamlopt -o program -linkpkg -package pkg module1.ml module2.ml\n</code></pre>\n<p>Multiple packages may be specified using commas e.g <code>pkg1,pkg2</code>. Ocamlfind\nknows how to find any files <code>ocamlopt</code> may need from the package, for example\n<code>.cmxa</code> implementation files or <code>.cmi</code> interface files, because they have been\npackaged together and installed at a known location by ocamlfind. We need only\nthe name <code>pkg</code> to refer to them all - ocamlfind does the rest.</p>\n<p>Note that you can compile the files separately. This is useful if\nyou want to recompile only some parts of the programs. Here are the\nequivalent commands that perform a separate compilation of the source\nfiles and link them together in a final step:</p>\n<pre><code class="language-shell">ocamlfind ocamlopt -c -package pkg module1.ml\nocamlfind ocamlopt -c -package pkg module2.ml\nocamlfind ocamlopt -o program -linkpkg -package pkg module1.cmx module2.cmx\n</code></pre>\n<p>Separate compilation (one command for <code>module1.ml</code>, another for <code>module2.ml</code>\nand another to link the final output) is usually not performed manually but\nonly when using an automated build system that will take care of recompiling\nonly what it necessary.</p>\n<h2 id="interlude-making-a-custom-toplevel">Interlude: making a custom toplevel</h2>\n<p>OCaml provides another tool <code>ocamlmktop</code> to make an interactive toplevel with\nlibraries accessible. For example:</p>\n<pre><code class="language-shell">ocamlmktop -o toplevel unix.cma module1.ml module2.ml\n</code></pre>\n<p>We run <code>toplevel</code> and get an OCaml toplevel with modules <code>Unix</code>, <code>Module1</code>, and\n<code>Module2</code> all available, allowing us to experiment interactively with our\nprogram.</p>\n<p>OCamlfind also supports <code>ocamlmktop</code>:</p>\n<pre><code class="language-shell">ocamlfind ocamlmktop -o toplevel unix.cma -package pkg module1.ml module2.ml\n</code></pre>\n<h2 id="dune-an-automated-build-system">Dune: an automated build system</h2>\n<p>The most popular modern system for building OCaml projects is\n<a href="https://dune.readthedocs.io/en/stable/">dune</a> which may be installed with\n<code>opam install dune</code>. It allows one to build OCaml projects from a simple\ndescription of their elements. For example, the dune file for our project might\nlook like this:</p>\n<pre><code class="language-scheme">;; our example project\n(executable\n  (name program)\n  (libraries unix pkg))\n</code></pre>\n<p>The dune <a href="https://dune.readthedocs.io/en/latest/quick-start.html">quick-start\nguide</a> shows you how to\nwrite such description files for more complicated situations, and how to\nstructure, build, and run dune projects.</p>\n<h2 id="other-build-systems">Other build systems</h2>\n<ul>\n<li><a href="https://github.com/ocaml-omake/omake">OMake</a> Another OCaml build system.\n</li>\n<li><a href="https://www.gnu.org/software/make/">GNU make</a> GNU make can build anything, including OCaml. May be used in conjunction with <a href="https://github.com/mmottl/ocaml-makefile">OCamlmakefile</a>\n</li>\n<li><a href="https://github.com/ocaml/oasis">Oasis</a> Generates a configure, build, and install system from a specification.\n</li>\n</ul>\n'},tl:{hd:{title:"Data Types and Matching",slug:"data-types-and-matching",description:"Learn to build custom types and write function to process this data\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"language",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:'\nIn this tutorial we learn how to build our own types in OCaml, and how to write\nfunctions which process this new data.\n\n## Built-in compound types\n\nWe have already seen simple data types such as `int`, `float`, `string`, and\n`bool`.  Let\'s recap the built-in compound data types we can use in OCaml to\ncombine such values. First, we have lists which are ordered collections of any\nnumber of elements of like type:\n\n```ocaml\n# []\n- : \'a list = []\n# [1; 2; 3]\n- : int list = [1; 2; 3]\n# [[1; 2]; [3; 4]; [5; 6]]\n- : int list list = [[1; 2]; [3; 4]; [5; 6]]\n# [false; true; false]\n- : bool list = [false; true; false]\n```\n\nNext, we have tuples, which collect a fixed number of elements together:\n\n```ocaml\n# (5.0, 6.5)\n- : float * float = (5., 6.5)\n# (true, 0.0, 0.45, 0.73, "french blue")\n- : bool * float * float * float * string =\n(true, 0., 0.45, 0.73, "french blue")\n```\n\nWe have records, which are like labeled tuples. They are defined by writing a\ntype definition giving a name for the record, and names for each of its fields,\nand their types:\n\n```ocaml\n# type point = {x : float; y : float}\ntype point = { x : float; y : float; }\n# let a = {x = 5.0; y = 6.5}\nval a : point = {x = 5.; y = 6.5}\n# type colour = {websafe : bool; r : float; g : float; b : float; name : string}\ntype colour = {\n  websafe : bool;\n  r : float;\n  g : float;\n  b : float;\n  name : string;\n}\n# let b = {websafe = true; r = 0.0; g = 0.45; b = 0.73; name = "french blue"}\nval b : colour =\n  {websafe = true; r = 0.; g = 0.45; b = 0.73; name = "french blue"}\n```\n\nA record must contain all fields:\n\n```ocaml\n# let c = {name = "puce"}\nLine 1, characters 9-24:\nError: Some record fields are undefined: websafe r g b\n```\n\nRecords may be mutable:\n\n```ocaml\n# type person =\n  {first_name : string;\n   surname : string;\n   mutable age : int}\ntype person = { first_name : string; surname : string; mutable age : int; }\n# let birthday p =\n  p.age <- p.age + 1\nval birthday : person -> unit = <fun>\n```\n\nAnother mutable compound data type is the fixed-length array which, just as a\nlist, must contain elements of like type. However, its elements may be accessed\nin constant time:\n\n```ocaml\n# let arr = [|1; 2; 3|]\nval arr : int array = [|1; 2; 3|]\n# arr.(0)\n- : int = 1\n# arr.(0) <- 0\n- : unit = ()\n# arr\n- : int array = [|0; 2; 3|]\n```\n\nIn this tutorial, we will define our own compound data types, using the `type`\nkeyword, and some of these built-in structures as building blocks.\n\n## A simple custom type\n\nWe can define a new data type `colour` which can take one of four values.\n\n```ocaml env=colours\ntype colour = Red | Green | Blue | Yellow\n```\n\nOur new type is called `colour`, and has four *constructors* `Red`, `Green`,\n`Blue` and `Yellow`. The name of the type must begin with a lower case letter,\nand the names of the constructors with upper case letters. We can use our new\ntype anywhere a built-in type could be used:\n\n```ocaml env=colours\n# let additive_primaries = (Red, Green, Blue)\nval additive_primaries : colour * colour * colour = (Red, Green, Blue)\n# let pattern = [(1, Red); (3, Green); (1, Red); (2, Green)]\nval pattern : (int * colour) list =\n  [(1, Red); (3, Green); (1, Red); (2, Green)]\n```\n\nNotice the types inferred by OCaml for these expressions. We can pattern-match\non our new type, just as with any built-in type:\n\n```ocaml env=colours\n# let example c =\n  match c with\n  | Red -> "rose"\n  | Green -> "grass"\n  | Blue -> "sky"\n  | Yellow -> "banana"\nval example : colour -> string = <fun>\n```\n\nNotice the type of the function includes the name of our new type `colour`. We\ncan make the function shorter and elide its parameter `c` by using the\nalternative `function` keyword which allows direct matching:\n\n```ocaml env=colours\n# let example = function\n  | Red -> "rose"\n  | Green -> "grass"\n  | Blue -> "sky"\n  | Yellow -> "banana"\nval example : colour -> string = <fun>\n```\n\nWe can match on more than one case at a time too:\n\n```ocaml env=colours\n# let rec is_primary = function\n  | Red | Green | Blue -> true\n  | _ -> false\nval is_primary : colour -> bool = <fun>\n```\n\n## Constructors with data\n\nEach constructor in a data type can carry additional information with it. Let\'s\nextend our `colour` type to allow arbitrary RGB triples, each element begin a\nnumber from 0 (no colour) to 1 (full colour): \n\n```ocaml env=colours\n# type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\ntype colour = Red | Green | Blue | Yellow | RGB of float * float * float\n\n# [Red; Blue; RGB (0.5, 0.65, 0.12)]\n- : colour list = [Red; Blue; RGB (0.5, 0.65, 0.12)]\n```\n\nTypes, just like functions, may be recursively-defined. We extend our data type\nto allow mixing of colours:\n\n```ocaml env=colours\n# type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\n  | Mix of float * colour * colour\ntype colour =\n    Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\n  | Mix of float * colour * colour\n# Mix (0.5, Red, Mix (0.5, Blue, Green))\n- : colour = Mix (0.5, Red, Mix (0.5, Blue, Green))\n```\n\nHere is a function over our new `colour` data type:\n\n```ocaml env=colours\n# let rec rgb_of_colour = function\n  | Red -> (1.0, 0.0, 0.0)\n  | Green -> (0.0, 1.0, 0.0)\n  | Blue -> (0.0, 0.0, 1.0)\n  | Yellow -> (1.0, 1.0, 0.0)\n  | RGB (r, g, b) -> (r, g, b)\n  | Mix (p, a, b) ->\n      let (r1, g1, b1) = rgb_of_colour a in\n      let (r2, g2, b2) = rgb_of_colour b in\n      let mix x y = x *. p +. y *. (1.0 -. p) in\n        (mix r1 r2, mix g1 g2, mix b1 b2)\nval rgb_of_colour : colour -> float * float * float = <fun>\n```\n\nWe can use records directly in the data type instead to label our components:\n\n```ocaml env=colours\n# type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of {r : float; g : float; b : float}\n  | Mix of {proportion : float; c1 : colour; c2 : colour}\ntype colour =\n    Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of { r : float; g : float; b : float; }\n  | Mix of { proportion : float; c1 : colour; c2 : colour; }\n```\n\n## Example: trees\n\nData types may be polymorphic as well as recursive. Here is an OCaml data type\nfor a binary tree carrying any kind of data:\n\n```ocaml env=trees\n# type \'a tree =\n  | Leaf\n  | Node of \'a tree * \'a * \'a tree\ntype \'a tree = Leaf | Node of \'a tree * \'a * \'a tree\n# let t =\n    Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Leaf))\nval t : int tree =\n  Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Leaf))\n```\n\nNotice that we give the type parameter `\'a` before the type name (if there is\nmore than one, we write `(\'a, \'b)` etc).  A `Leaf` holds no information,\njust like an empty list. A `Node` holds a left tree, a value of type `\'a`\nand a right tree. In our example, we built an integer tree, but any type can be\nused. Now we can write recursive and polymorphic functions over these trees, by\npattern matching on our new constructors:\n\n```ocaml env=trees\n# let rec total = function\n  | Leaf -> 0\n  | Node (l, x, r) -> total l + x + total r\nval total : int tree -> int = <fun>\n# let rec flip = function\n  | Leaf -> Leaf\n  | Node (l, x, r) -> Node (flip r, x, flip l)\nval flip : \'a tree -> \'a tree = <fun>\n```\n\nHere, `flip` is polymorphic while `total` operates only on trees of type `int\ntree`. Let\'s try our new functions out:\n\n```ocaml env=trees\n# let all = total t\nval all : int = 10\n# let flipped = flip t\nval flipped : int tree =\n  Node (Node (Leaf, 4, Node (Leaf, 3, Leaf)), 2, Node (Leaf, 1, Leaf))\n# t = flip flipped\n- : bool = true\n```\n\nInstead of integers, we could build a tree of key-value pairs. Then, if we\ninsist that the keys are unique and that a smaller key is always left of a\nlarger key, we have a data structure for dictionaries which performs better\nthan a simple list of pairs. It is known as a *binary search tree*:\n\n```ocaml env=trees\n# let rec insert (k, v) = function\n  | Leaf -> Node (Leaf, (k, v), Leaf)\n  | Node (l, (k\', v\'), r) ->\n      if k < k\' then Node (insert (k, v) l, (k\', v\'), r) \n      else if k > k\' then Node (l, (k\', v\'), insert (k, v) r)\n      else Node (l, (k, v), r)\nval insert : \'a * \'b -> (\'a * \'b) tree -> (\'a * \'b) tree = <fun>\n```\n\nSimilar functions can be written to look up values in a dictionary, to convert\na list of pairs to or from a tree dictionary and so on.\n\n## Example: mathematical expressions\n\nWe wish to represent simple mathematical expressions like `n * (x + y)` and\nmultiply them out symbolically to get `n * x + n * y`.\n\nLet\'s define a type for these expressions:\n\n```ocaml env=expr\ntype expr =\n  | Plus of expr * expr        (* a + b *)\n  | Minus of expr * expr       (* a - b *)\n  | Times of expr * expr       (* a * b *)\n  | Divide of expr * expr      (* a / b *)\n  | Var of string              (* "x", "y", etc. *)\n```\n\nThe expression `n * (x + y)` would be written:\n\n```ocaml env=expr\n# Times (Var "n", Plus (Var "x", Var "y"))\n- : expr = Times (Var "n", Plus (Var "x", Var "y"))\n```\n\nLet\'s write a function which prints out `Times (Var "n", Plus (Var "x", Var\n"y"))` as something more like `n * (x + y)`.\n\n```ocaml env=expr\n# let rec to_string e =\n  match e with\n  | Plus (left, right) ->\n     "(" ^ to_string left ^ " + " ^ to_string right ^ ")"\n  | Minus (left, right) ->\n     "(" ^ to_string left ^ " - " ^ to_string right ^ ")"\n  | Times (left, right) ->\n   "(" ^ to_string left ^ " * " ^ to_string right ^ ")"\n  | Divide (left, right) ->\n   "(" ^ to_string left ^ " / " ^ to_string right ^ ")"\n  | Var v -> v\nval to_string : expr -> string = <fun>\n# let print_expr e =\n  print_endline (to_string e)\nval print_expr : expr -> unit = <fun>\n```\n\n(The `^` operator concatenates strings). We separate the function into two so\nthat our `to_string` function is usable in other contexts. Here\'s the\n`print_expr` function in action:\n\n```ocaml env=expr\n# print_expr (Times (Var "n", Plus (Var "x", Var "y")))\n(n * (x + y))\n- : unit = ()\n```\n\nWe can write a function to multiply out expressions of the form `n * (x + y)`\nor `(x + y) * n` and for this we will use a nested pattern:\n\n```ocaml env=expr\n# let rec multiply_out e =\n  match e with\n  | Times (e1, Plus (e2, e3)) ->\n     Plus (Times (multiply_out e1, multiply_out e2),\n           Times (multiply_out e1, multiply_out e3))\n  | Times (Plus (e1, e2), e3) ->\n     Plus (Times (multiply_out e1, multiply_out e3),\n           Times (multiply_out e2, multiply_out e3))\n  | Plus (left, right) ->\n     Plus (multiply_out left, multiply_out right)\n  | Minus (left, right) ->\n     Minus (multiply_out left, multiply_out right)\n  | Times (left, right) ->\n     Times (multiply_out left, multiply_out right)\n  | Divide (left, right) ->\n     Divide (multiply_out left, multiply_out right)\n  | Var v -> Var v\nval multiply_out : expr -> expr = <fun>\n```\n\nHere it is in action:\n\n```ocaml env=expr\n# print_expr (multiply_out (Times (Var "n", Plus (Var "x", Var "y"))))\n((n * x) + (n * y))\n- : unit = ()\n```\n\nHow does the `multiply_out` function work? The key is in the first two\npatterns. The first pattern is `Times (e1, Plus (e2, e3))` which matches\nexpressions of the form `e1 * (e2 + e3)`. Now look at the right hand side of\nthis first pattern match, and convince yourself that it is the equivalent of\n`(e1 * e2) + (e1 * e3)`. The second pattern does the same thing, except for\nexpressions of the form `(e1 + e2) * e3`.\n\nThe remaining patterns don\'t change the form of the expression, but they\ncrucially *do* call the `multiply_out` function recursively on their\nsubexpressions. This ensures that all subexpressions within the expression get\nmultiplied out too (if you only wanted to multiply out the very top level of an\nexpression, then you could replace all the remaining patterns with a simple `e\n-> e` rule).\n\nCan we do the reverse (i.e. factorizing out common subexpressions)? We can!\n(But it\'s a bit more complicated). The following version only works for the top\nlevel expression. You could certainly extend it to cope with all levels of an\nexpression and more complex cases:\n\n```ocaml env=expr\n# let factorize e =\n  match e with\n  | Plus (Times (e1, e2), Times (e3, e4)) when e1 = e3 ->\n     Times (e1, Plus (e2, e4))\n  | Plus (Times (e1, e2), Times (e3, e4)) when e2 = e4 ->\n     Times (Plus (e1, e3), e4)\n  | e -> e\nval factorize : expr -> expr = <fun>\n# factorize (Plus (Times (Var "n", Var "x"),\n                   Times (Var "n", Var "y")))\n- : expr = Times (Var "n", Plus (Var "x", Var "y"))\n```\n\nThe factorize function above introduces another couple of features. You can add\nwhat are known as *guards* to each pattern match. A guard is the conditional\nwhich follows the `when`, and it means that the pattern match only happens if\nthe pattern matches *and* the condition in the `when`-clause is satisfied.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmatch value with\n| pattern [ when condition ] -> result\n| pattern [ when condition ] -> result\n  ...\n```\n\nThe second feature is the `=` operator which tests for "structural equality"\nbetween two expressions. That means it goes recursively into each expression\nchecking they\'re exactly the same at all levels down.\n\nAnother feature which is useful when we build more complicated nested patterns\nis the `as` keyword, which can be used to name part of an expression. For\nexample:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nName ("/DeviceGray" | "/DeviceRGB" | "/DeviceCMYK") as n -> n\n\nNode (l, ((k, _) as pair), r) when k = k\' -> Some pair\n```\n\n## Mutually recursive data types\n\nData types may be mutually-recursive when declared with `and`:\n\n```ocaml\ntype t = A | B of t\' and t\' = C | D of t\n```\n\nOne common use for mutually-recursive data types is to *decorate* a tree, by\nadding information to each node using mutually-recursive types, one of which is\na tuple or record. For example:\n\n```ocaml\ntype t\' = Int of int | Add of t * t\nand t = {annotation : string; data : t\'}\n```\n\nValues of such mutually-recursive data type are manipulated by accompanying\nmutually-recursive functions:\n\n```ocaml\n# let rec sum_t\' = function\n  | Int i -> i\n  | Add (i, i\') -> sum_t i + sum_t i\'\n  and sum_t {annotation; data} =\n    if annotation <> "" then Printf.printf "Touching %s\\n" annotation;\n    sum_t\' data\nval sum_t\' : t\' -> int = <fun>\nval sum_t : t -> int = <fun>\n```\n\n## A note on tupled constructors\n\nThere is a difference between `RGB of float * float * float` and `RGB of (float\n* float * float)`. The first is a constructor with three pieces of data\nassociated with it, the second is a constructor with one tuple associated with\nit. There are two ways this matters: the memory layout differs between the two\n(a tuple is an extra indirection), and the ability to create or match using a\ntuple:\n\n```ocaml\n# type t = T of int * int\ntype t = T of int * int\n\n# type t2 = T2 of (int * int)\ntype t2 = T2 of (int * int)\n\n# let pair = (1, 2)\nval pair : int * int = (1, 2)\n\n# T2 pair\n- : t2 = T2 (1, 2)\n\n# T pair\nLine 1, characters 1-7:\nError: The constructor T expects 2 argument(s),\n       but is applied here to 1 argument(s)\n\n# match T2 (1, 2) with T2 x -> fst x\n- : int = 1\n\n# match T (1, 2) with T x -> fst x\nLine 1, characters 21-24:\nError: The constructor T expects 2 argument(s),\n       but is applied here to 1 argument(s)\n```\n\nNote, however, that OCaml allows us to use the always-matching `_` in either\nversion:\n\n```ocaml\n# match T2 (1, 2) with T2 _ -> 0\n- : int = 0\n\n# match T (1, 2) with T _ -> 0\n- : int = 0\n```\n\n## Types and modules\n\nOften, a module will provide a single type and operations on that type. For\nexample, a module for a file format like PNG might have the following `png.mli`\ninterface:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\ntype t\n\nval of_file : filename -> t\n\nval to_file : t -> filename -> unit\n\nval flip_vertical : t -> t\n\nval flip_horizontal : t -> t\n\nval rotate : float -> t -> t\n```\n\nTraditionally, we name the type `t`. In the program using this library, it\nwould then be `Png.t` which is shorter, reads better than `Png.png`, and avoids\nconfusion if the library also defines other types.\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#built-in-compound-types">Built-in compound types</a>\n</li>\n<li><a href="#a-simple-custom-type">A simple custom type</a>\n</li>\n<li><a href="#constructors-with-data">Constructors with data</a>\n</li>\n<li><a href="#example-trees">Example: trees</a>\n</li>\n<li><a href="#example-mathematical-expressions">Example: mathematical expressions</a>\n</li>\n<li><a href="#mutually-recursive-data-types">Mutually recursive data types</a>\n</li>\n<li><a href="#a-note-on-tupled-constructors">A note on tupled constructors</a>\n</li>\n<li><a href="#types-and-modules">Types and modules</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>In this tutorial we learn how to build our own types in OCaml, and how to write\nfunctions which process this new data.</p>\n<h2 id="built-in-compound-types">Built-in compound types</h2>\n<p>We have already seen simple data types such as <code>int</code>, <code>float</code>, <code>string</code>, and\n<code>bool</code>.  Let\'s recap the built-in compound data types we can use in OCaml to\ncombine such values. First, we have lists which are ordered collections of any\nnumber of elements of like type:</p>\n<pre><code class="language-ocaml"># []\n- : \'a list = []\n# [1; 2; 3]\n- : int list = [1; 2; 3]\n# [[1; 2]; [3; 4]; [5; 6]]\n- : int list list = [[1; 2]; [3; 4]; [5; 6]]\n# [false; true; false]\n- : bool list = [false; true; false]\n</code></pre>\n<p>Next, we have tuples, which collect a fixed number of elements together:</p>\n<pre><code class="language-ocaml"># (5.0, 6.5)\n- : float * float = (5., 6.5)\n# (true, 0.0, 0.45, 0.73, &quot;french blue&quot;)\n- : bool * float * float * float * string =\n(true, 0., 0.45, 0.73, &quot;french blue&quot;)\n</code></pre>\n<p>We have records, which are like labeled tuples. They are defined by writing a\ntype definition giving a name for the record, and names for each of its fields,\nand their types:</p>\n<pre><code class="language-ocaml"># type point = {x : float; y : float}\ntype point = { x : float; y : float; }\n# let a = {x = 5.0; y = 6.5}\nval a : point = {x = 5.; y = 6.5}\n# type colour = {websafe : bool; r : float; g : float; b : float; name : string}\ntype colour = {\n  websafe : bool;\n  r : float;\n  g : float;\n  b : float;\n  name : string;\n}\n# let b = {websafe = true; r = 0.0; g = 0.45; b = 0.73; name = &quot;french blue&quot;}\nval b : colour =\n  {websafe = true; r = 0.; g = 0.45; b = 0.73; name = &quot;french blue&quot;}\n</code></pre>\n<p>A record must contain all fields:</p>\n<pre><code class="language-ocaml"># let c = {name = &quot;puce&quot;}\nLine 1, characters 9-24:\nError: Some record fields are undefined: websafe r g b\n</code></pre>\n<p>Records may be mutable:</p>\n<pre><code class="language-ocaml"># type person =\n  {first_name : string;\n   surname : string;\n   mutable age : int}\ntype person = { first_name : string; surname : string; mutable age : int; }\n# let birthday p =\n  p.age &lt;- p.age + 1\nval birthday : person -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>Another mutable compound data type is the fixed-length array which, just as a\nlist, must contain elements of like type. However, its elements may be accessed\nin constant time:</p>\n<pre><code class="language-ocaml"># let arr = [|1; 2; 3|]\nval arr : int array = [|1; 2; 3|]\n# arr.(0)\n- : int = 1\n# arr.(0) &lt;- 0\n- : unit = ()\n# arr\n- : int array = [|0; 2; 3|]\n</code></pre>\n<p>In this tutorial, we will define our own compound data types, using the <code>type</code>\nkeyword, and some of these built-in structures as building blocks.</p>\n<h2 id="a-simple-custom-type">A simple custom type</h2>\n<p>We can define a new data type <code>colour</code> which can take one of four values.</p>\n<pre><code class="language-ocaml">type colour = Red | Green | Blue | Yellow\n</code></pre>\n<p>Our new type is called <code>colour</code>, and has four <em>constructors</em> <code>Red</code>, <code>Green</code>,\n<code>Blue</code> and <code>Yellow</code>. The name of the type must begin with a lower case letter,\nand the names of the constructors with upper case letters. We can use our new\ntype anywhere a built-in type could be used:</p>\n<pre><code class="language-ocaml"># let additive_primaries = (Red, Green, Blue)\nval additive_primaries : colour * colour * colour = (Red, Green, Blue)\n# let pattern = [(1, Red); (3, Green); (1, Red); (2, Green)]\nval pattern : (int * colour) list =\n  [(1, Red); (3, Green); (1, Red); (2, Green)]\n</code></pre>\n<p>Notice the types inferred by OCaml for these expressions. We can pattern-match\non our new type, just as with any built-in type:</p>\n<pre><code class="language-ocaml"># let example c =\n  match c with\n  | Red -&gt; &quot;rose&quot;\n  | Green -&gt; &quot;grass&quot;\n  | Blue -&gt; &quot;sky&quot;\n  | Yellow -&gt; &quot;banana&quot;\nval example : colour -&gt; string = &lt;fun&gt;\n</code></pre>\n<p>Notice the type of the function includes the name of our new type <code>colour</code>. We\ncan make the function shorter and elide its parameter <code>c</code> by using the\nalternative <code>function</code> keyword which allows direct matching:</p>\n<pre><code class="language-ocaml"># let example = function\n  | Red -&gt; &quot;rose&quot;\n  | Green -&gt; &quot;grass&quot;\n  | Blue -&gt; &quot;sky&quot;\n  | Yellow -&gt; &quot;banana&quot;\nval example : colour -&gt; string = &lt;fun&gt;\n</code></pre>\n<p>We can match on more than one case at a time too:</p>\n<pre><code class="language-ocaml"># let rec is_primary = function\n  | Red | Green | Blue -&gt; true\n  | _ -&gt; false\nval is_primary : colour -&gt; bool = &lt;fun&gt;\n</code></pre>\n<h2 id="constructors-with-data">Constructors with data</h2>\n<p>Each constructor in a data type can carry additional information with it. Let\'s\nextend our <code>colour</code> type to allow arbitrary RGB triples, each element begin a\nnumber from 0 (no colour) to 1 (full colour):</p>\n<pre><code class="language-ocaml"># type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\ntype colour = Red | Green | Blue | Yellow | RGB of float * float * float\n\n# [Red; Blue; RGB (0.5, 0.65, 0.12)]\n- : colour list = [Red; Blue; RGB (0.5, 0.65, 0.12)]\n</code></pre>\n<p>Types, just like functions, may be recursively-defined. We extend our data type\nto allow mixing of colours:</p>\n<pre><code class="language-ocaml"># type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\n  | Mix of float * colour * colour\ntype colour =\n    Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\n  | Mix of float * colour * colour\n# Mix (0.5, Red, Mix (0.5, Blue, Green))\n- : colour = Mix (0.5, Red, Mix (0.5, Blue, Green))\n</code></pre>\n<p>Here is a function over our new <code>colour</code> data type:</p>\n<pre><code class="language-ocaml"># let rec rgb_of_colour = function\n  | Red -&gt; (1.0, 0.0, 0.0)\n  | Green -&gt; (0.0, 1.0, 0.0)\n  | Blue -&gt; (0.0, 0.0, 1.0)\n  | Yellow -&gt; (1.0, 1.0, 0.0)\n  | RGB (r, g, b) -&gt; (r, g, b)\n  | Mix (p, a, b) -&gt;\n      let (r1, g1, b1) = rgb_of_colour a in\n      let (r2, g2, b2) = rgb_of_colour b in\n      let mix x y = x *. p +. y *. (1.0 -. p) in\n        (mix r1 r2, mix g1 g2, mix b1 b2)\nval rgb_of_colour : colour -&gt; float * float * float = &lt;fun&gt;\n</code></pre>\n<p>We can use records directly in the data type instead to label our components:</p>\n<pre><code class="language-ocaml"># type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of {r : float; g : float; b : float}\n  | Mix of {proportion : float; c1 : colour; c2 : colour}\ntype colour =\n    Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of { r : float; g : float; b : float; }\n  | Mix of { proportion : float; c1 : colour; c2 : colour; }\n</code></pre>\n<h2 id="example-trees">Example: trees</h2>\n<p>Data types may be polymorphic as well as recursive. Here is an OCaml data type\nfor a binary tree carrying any kind of data:</p>\n<pre><code class="language-ocaml"># type \'a tree =\n  | Leaf\n  | Node of \'a tree * \'a * \'a tree\ntype \'a tree = Leaf | Node of \'a tree * \'a * \'a tree\n# let t =\n    Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Leaf))\nval t : int tree =\n  Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Leaf))\n</code></pre>\n<p>Notice that we give the type parameter <code>\'a</code> before the type name (if there is\nmore than one, we write <code>(\'a, \'b)</code> etc).  A <code>Leaf</code> holds no information,\njust like an empty list. A <code>Node</code> holds a left tree, a value of type <code>\'a</code>\nand a right tree. In our example, we built an integer tree, but any type can be\nused. Now we can write recursive and polymorphic functions over these trees, by\npattern matching on our new constructors:</p>\n<pre><code class="language-ocaml"># let rec total = function\n  | Leaf -&gt; 0\n  | Node (l, x, r) -&gt; total l + x + total r\nval total : int tree -&gt; int = &lt;fun&gt;\n# let rec flip = function\n  | Leaf -&gt; Leaf\n  | Node (l, x, r) -&gt; Node (flip r, x, flip l)\nval flip : \'a tree -&gt; \'a tree = &lt;fun&gt;\n</code></pre>\n<p>Here, <code>flip</code> is polymorphic while <code>total</code> operates only on trees of type <code>int tree</code>. Let\'s try our new functions out:</p>\n<pre><code class="language-ocaml"># let all = total t\nval all : int = 10\n# let flipped = flip t\nval flipped : int tree =\n  Node (Node (Leaf, 4, Node (Leaf, 3, Leaf)), 2, Node (Leaf, 1, Leaf))\n# t = flip flipped\n- : bool = true\n</code></pre>\n<p>Instead of integers, we could build a tree of key-value pairs. Then, if we\ninsist that the keys are unique and that a smaller key is always left of a\nlarger key, we have a data structure for dictionaries which performs better\nthan a simple list of pairs. It is known as a <em>binary search tree</em>:</p>\n<pre><code class="language-ocaml"># let rec insert (k, v) = function\n  | Leaf -&gt; Node (Leaf, (k, v), Leaf)\n  | Node (l, (k\', v\'), r) -&gt;\n      if k &lt; k\' then Node (insert (k, v) l, (k\', v\'), r) \n      else if k &gt; k\' then Node (l, (k\', v\'), insert (k, v) r)\n      else Node (l, (k, v), r)\nval insert : \'a * \'b -&gt; (\'a * \'b) tree -&gt; (\'a * \'b) tree = &lt;fun&gt;\n</code></pre>\n<p>Similar functions can be written to look up values in a dictionary, to convert\na list of pairs to or from a tree dictionary and so on.</p>\n<h2 id="example-mathematical-expressions">Example: mathematical expressions</h2>\n<p>We wish to represent simple mathematical expressions like <code>n * (x + y)</code> and\nmultiply them out symbolically to get <code>n * x + n * y</code>.</p>\n<p>Let\'s define a type for these expressions:</p>\n<pre><code class="language-ocaml">type expr =\n  | Plus of expr * expr        (* a + b *)\n  | Minus of expr * expr       (* a - b *)\n  | Times of expr * expr       (* a * b *)\n  | Divide of expr * expr      (* a / b *)\n  | Var of string              (* &quot;x&quot;, &quot;y&quot;, etc. *)\n</code></pre>\n<p>The expression <code>n * (x + y)</code> would be written:</p>\n<pre><code class="language-ocaml"># Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;))\n- : expr = Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;))\n</code></pre>\n<p>Let\'s write a function which prints out <code>Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;))</code> as something more like <code>n * (x + y)</code>.</p>\n<pre><code class="language-ocaml"># let rec to_string e =\n  match e with\n  | Plus (left, right) -&gt;\n     &quot;(&quot; ^ to_string left ^ &quot; + &quot; ^ to_string right ^ &quot;)&quot;\n  | Minus (left, right) -&gt;\n     &quot;(&quot; ^ to_string left ^ &quot; - &quot; ^ to_string right ^ &quot;)&quot;\n  | Times (left, right) -&gt;\n   &quot;(&quot; ^ to_string left ^ &quot; * &quot; ^ to_string right ^ &quot;)&quot;\n  | Divide (left, right) -&gt;\n   &quot;(&quot; ^ to_string left ^ &quot; / &quot; ^ to_string right ^ &quot;)&quot;\n  | Var v -&gt; v\nval to_string : expr -&gt; string = &lt;fun&gt;\n# let print_expr e =\n  print_endline (to_string e)\nval print_expr : expr -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>(The <code>^</code> operator concatenates strings). We separate the function into two so\nthat our <code>to_string</code> function is usable in other contexts. Here\'s the\n<code>print_expr</code> function in action:</p>\n<pre><code class="language-ocaml"># print_expr (Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;)))\n(n * (x + y))\n- : unit = ()\n</code></pre>\n<p>We can write a function to multiply out expressions of the form <code>n * (x + y)</code>\nor <code>(x + y) * n</code> and for this we will use a nested pattern:</p>\n<pre><code class="language-ocaml"># let rec multiply_out e =\n  match e with\n  | Times (e1, Plus (e2, e3)) -&gt;\n     Plus (Times (multiply_out e1, multiply_out e2),\n           Times (multiply_out e1, multiply_out e3))\n  | Times (Plus (e1, e2), e3) -&gt;\n     Plus (Times (multiply_out e1, multiply_out e3),\n           Times (multiply_out e2, multiply_out e3))\n  | Plus (left, right) -&gt;\n     Plus (multiply_out left, multiply_out right)\n  | Minus (left, right) -&gt;\n     Minus (multiply_out left, multiply_out right)\n  | Times (left, right) -&gt;\n     Times (multiply_out left, multiply_out right)\n  | Divide (left, right) -&gt;\n     Divide (multiply_out left, multiply_out right)\n  | Var v -&gt; Var v\nval multiply_out : expr -&gt; expr = &lt;fun&gt;\n</code></pre>\n<p>Here it is in action:</p>\n<pre><code class="language-ocaml"># print_expr (multiply_out (Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;))))\n((n * x) + (n * y))\n- : unit = ()\n</code></pre>\n<p>How does the <code>multiply_out</code> function work? The key is in the first two\npatterns. The first pattern is <code>Times (e1, Plus (e2, e3))</code> which matches\nexpressions of the form <code>e1 * (e2 + e3)</code>. Now look at the right hand side of\nthis first pattern match, and convince yourself that it is the equivalent of\n<code>(e1 * e2) + (e1 * e3)</code>. The second pattern does the same thing, except for\nexpressions of the form <code>(e1 + e2) * e3</code>.</p>\n<p>The remaining patterns don\'t change the form of the expression, but they\ncrucially <em>do</em> call the <code>multiply_out</code> function recursively on their\nsubexpressions. This ensures that all subexpressions within the expression get\nmultiplied out too (if you only wanted to multiply out the very top level of an\nexpression, then you could replace all the remaining patterns with a simple <code>e -&gt; e</code> rule).</p>\n<p>Can we do the reverse (i.e. factorizing out common subexpressions)? We can!\n(But it\'s a bit more complicated). The following version only works for the top\nlevel expression. You could certainly extend it to cope with all levels of an\nexpression and more complex cases:</p>\n<pre><code class="language-ocaml"># let factorize e =\n  match e with\n  | Plus (Times (e1, e2), Times (e3, e4)) when e1 = e3 -&gt;\n     Times (e1, Plus (e2, e4))\n  | Plus (Times (e1, e2), Times (e3, e4)) when e2 = e4 -&gt;\n     Times (Plus (e1, e3), e4)\n  | e -&gt; e\nval factorize : expr -&gt; expr = &lt;fun&gt;\n# factorize (Plus (Times (Var &quot;n&quot;, Var &quot;x&quot;),\n                   Times (Var &quot;n&quot;, Var &quot;y&quot;)))\n- : expr = Times (Var &quot;n&quot;, Plus (Var &quot;x&quot;, Var &quot;y&quot;))\n</code></pre>\n<p>The factorize function above introduces another couple of features. You can add\nwhat are known as <em>guards</em> to each pattern match. A guard is the conditional\nwhich follows the <code>when</code>, and it means that the pattern match only happens if\nthe pattern matches <em>and</em> the condition in the <code>when</code>-clause is satisfied.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">match value with\n| pattern [ when condition ] -&gt; result\n| pattern [ when condition ] -&gt; result\n  ...\n</code></pre>\n<p>The second feature is the <code>=</code> operator which tests for &quot;structural equality&quot;\nbetween two expressions. That means it goes recursively into each expression\nchecking they\'re exactly the same at all levels down.</p>\n<p>Another feature which is useful when we build more complicated nested patterns\nis the <code>as</code> keyword, which can be used to name part of an expression. For\nexample:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">Name (&quot;/DeviceGray&quot; | &quot;/DeviceRGB&quot; | &quot;/DeviceCMYK&quot;) as n -&gt; n\n\nNode (l, ((k, _) as pair), r) when k = k\' -&gt; Some pair\n</code></pre>\n<h2 id="mutually-recursive-data-types">Mutually recursive data types</h2>\n<p>Data types may be mutually-recursive when declared with <code>and</code>:</p>\n<pre><code class="language-ocaml">type t = A | B of t\' and t\' = C | D of t\n</code></pre>\n<p>One common use for mutually-recursive data types is to <em>decorate</em> a tree, by\nadding information to each node using mutually-recursive types, one of which is\na tuple or record. For example:</p>\n<pre><code class="language-ocaml">type t\' = Int of int | Add of t * t\nand t = {annotation : string; data : t\'}\n</code></pre>\n<p>Values of such mutually-recursive data type are manipulated by accompanying\nmutually-recursive functions:</p>\n<pre><code class="language-ocaml"># let rec sum_t\' = function\n  | Int i -&gt; i\n  | Add (i, i\') -&gt; sum_t i + sum_t i\'\n  and sum_t {annotation; data} =\n    if annotation &lt;&gt; &quot;&quot; then Printf.printf &quot;Touching %s\\n&quot; annotation;\n    sum_t\' data\nval sum_t\' : t\' -&gt; int = &lt;fun&gt;\nval sum_t : t -&gt; int = &lt;fun&gt;\n</code></pre>\n<h2 id="a-note-on-tupled-constructors">A note on tupled constructors</h2>\n<p>There is a difference between <code>RGB of float * float * float</code> and `RGB of (float</p>\n<ul>\n<li>float * float)`. The first is a constructor with three pieces of data\nassociated with it, the second is a constructor with one tuple associated with\nit. There are two ways this matters: the memory layout differs between the two\n(a tuple is an extra indirection), and the ability to create or match using a\ntuple:\n</li>\n</ul>\n<pre><code class="language-ocaml"># type t = T of int * int\ntype t = T of int * int\n\n# type t2 = T2 of (int * int)\ntype t2 = T2 of (int * int)\n\n# let pair = (1, 2)\nval pair : int * int = (1, 2)\n\n# T2 pair\n- : t2 = T2 (1, 2)\n\n# T pair\nLine 1, characters 1-7:\nError: The constructor T expects 2 argument(s),\n       but is applied here to 1 argument(s)\n\n# match T2 (1, 2) with T2 x -&gt; fst x\n- : int = 1\n\n# match T (1, 2) with T x -&gt; fst x\nLine 1, characters 21-24:\nError: The constructor T expects 2 argument(s),\n       but is applied here to 1 argument(s)\n</code></pre>\n<p>Note, however, that OCaml allows us to use the always-matching <code>_</code> in either\nversion:</p>\n<pre><code class="language-ocaml"># match T2 (1, 2) with T2 _ -&gt; 0\n- : int = 0\n\n# match T (1, 2) with T _ -&gt; 0\n- : int = 0\n</code></pre>\n<h2 id="types-and-modules">Types and modules</h2>\n<p>Often, a module will provide a single type and operations on that type. For\nexample, a module for a file format like PNG might have the following <code>png.mli</code>\ninterface:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">type t\n\nval of_file : filename -&gt; t\n\nval to_file : t -&gt; filename -&gt; unit\n\nval flip_vertical : t -&gt; t\n\nval flip_horizontal : t -&gt; t\n\nval rotate : float -&gt; t -&gt; t\n</code></pre>\n<p>Traditionally, we name the type <code>t</code>. In the program using this library, it\nwould then be <code>Png.t</code> which is shorter, reads better than <code>Png.png</code>, and avoids\nconfusion if the library also defines other types.</p>\n'},tl:{hd:{title:"Functional Programming",slug:"functional-programming",description:"A guide to functional programming in OCaml\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"language",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:'\n## What is functional programming?\nWe\'ve got quite far into the tutorial, yet we haven\'t really considered\n**functional programming**. All of the features given so far - rich data\ntypes, pattern matching, type inference, nested functions - you could\nimagine could exist in a kind of "super C" language. These are Cool\nFeatures certainly, and make your code concise, easy to read, and have\nfewer bugs, but they actually have very little to do with functional\nprogramming. In fact my argument is going to be that the reason that\nfunctional languages are so great is *not* because of functional\nprogramming, but because we\'ve been stuck with C-like languages for\nyears and in the meantime the cutting edge of programming has moved on\nconsiderably. So while we were writing\n`struct { int type; union { ... } }` for the umpteenth time, ML and\nHaskell programmers had safe variants and pattern matching on datatypes.\nWhile we were being careful to `free` all our `malloc`s, there have been\nlanguages with garbage collectors able to outperform hand-coding since\nthe 80s.\n\nWell, after that I\'d better tell you what functional programming is\nanyhow.\n\nThe basic, and not very enlightening definition is this: in a\n**functional language**, **functions** are first-class citizens.\n\nLot of words there that don\'t really make much sense. So let\'s have an\nexample:\n\n```ocaml\n# let double x = x * 2 in\n    List.map double [1; 2; 3]\n- : int list = [2; 4; 6]\n```\n\nIn this example, I\'ve first defined a nested function called `double`\nwhich takes an argument `x` and returns `x * 2`. Then `map` calls\n`double` on each element of the given list (`[1; 2; 3]`) to produce the\nresult: a list with each number doubled.\n\n`map` is known as a **higher-order function** (HOF). Higher-order\nfunctions are just a fancy way of saying that the function takes a\nfunction as one of its arguments. So far so simple. If you\'re familiar\nwith C/C++ then this looks like passing a function pointer around.\n\n**Closures** are functions which carry around some of the "environment"\nin which they were defined. In particular, a closure can reference\nvariables which were available at the point of its definition. Let\'s\ngeneralise the function above so that now we can take any list of\nintegers and multiply each element by an arbitrary value `n`:\n\n```ocaml\n# let multiply n list =\n    let f x = n * x in\n      List.map f list\nval multiply : int -> int list -> int list = <fun>\n```\n\nHence:\n\n```ocaml\n# multiply 2 [1; 2; 3]\n- : int list = [2; 4; 6]\n# multiply 5 [1; 2; 3]\n- : int list = [5; 10; 15]\n```\n\nThe important point to note about the `multiply` function is the nested\nfunction `f`. This is a closure. Look at how `f` uses the value of `n`\nwhich isn\'t actually passed as an explicit argument to `f`. Instead `f`\npicks it up from its environment - it\'s an argument to the `multiply`\nfunction and hence available within this function.\n\nThis might sound straightforward, but let\'s look a bit closer at that\ncall to map: `List.map f list`.\n\n`map` is defined in the `List` module, far away from the current code.\nIn other words, we\'re passing `f` into a module defined "a long time\nago, in a galaxy far far away". For all we know that code might pass `f`\nto other modules, or save a reference to `f` somewhere and call it\nlater. Whether it does this or not, the closure will ensure that `f`\nalways has access back to its parental environment, and to `n`.\n\nHere\'s a real example from lablgtk. This is actually a method on a class\n(we haven\'t talked about classes and objects yet, but just think of it\nas a function definition for now).\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nclass html_skel obj = object (self)\n  ...\n  ...\n  method save_to_channel chan =\n    let receiver_fn content =\n      output_string chan content;\n      true\n    in\n      save obj receiver_fn\n  ...\nend\n```\nFirst of all you need to know that the `save` function called at the end\nof the method takes as its second argument a function (`receiver_fn`).\nIt repeatedly calls `receiver_fn` with snippets of text from the widget\nthat it\'s trying to save.\n\nNow look at the definition of `receiver_fn`. This function is a closure\nalright because it keeps a reference to `chan` from its environment.\n\n## Partial function applications and currying\nLet\'s define a plus function which just adds two integers:\n\n```ocaml\n# let plus a b =\n    a + b\nval plus : int -> int -> int = <fun>\n```\nSome questions for people asleep at the back of the class.\n\n1. What is `plus`?\n1. What is `plus 2 3`?\n1. What is `plus 2`?\n\nQuestion 1 is easy. `plus` is a function, it takes two arguments which\nare integers and it returns an integer. We write its type like this:\n\n```ocaml\n# plus\n- : int -> int -> int = <fun>\n```\nQuestion 2 is even easier. `plus 2 3` is a number, the integer `5`. We\nwrite its value and type like this:\n\n```ocaml\n# 5\n- : int = 5\n```\nBut what about question 3? It looks like `plus 2` is a mistake, a bug.\nIn fact, however, it isn\'t. If we type this into the OCaml toplevel, it\ntells us:\n\n```ocaml\n# plus 2\n- : int -> int = <fun>\n```\nThis isn\'t an error. It\'s telling us that `plus 2` is in fact a\n*function*, which takes an `int` and returns an `int`. What sort of\nfunction is this? We experiment by first of all giving this mysterious\nfunction a name (`f`), and then trying it out on a few integers to see\nwhat it does:\n\n```ocaml\n# let f = plus 2\nval f : int -> int = <fun>\n# f 10\n- : int = 12\n# f 15\n- : int = 17\n# f 99\n- : int = 101\n```\nIn engineering this is sufficient [proof by example](humor_proof.html)\nfor us to state that `plus 2` is the function which adds 2 to things.\n\nGoing back to the original definition, let\'s "fill in" the first\nargument (`a`) setting it to 2 to get:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet plus 2 b =       (* This is not real OCaml code! *)\n  2 + b\n```\nYou can kind of see, I hope, why `plus 2` is the function which adds 2\nto things.\n\nLooking at the types of these expressions we may be able to see some\nrationale for the strange `->` arrow notation used for function types:\n\n```ocaml\n# plus\n- : int -> int -> int = <fun>\n# plus 2\n- : int -> int = <fun>\n# plus 2 3\n- : int = 5\n```\nThis process is called **currying** (or perhaps it\'s called\n**uncurrying**, I never was really sure which was which). It is called\nthis after Haskell Curry who did some important stuff related to the\nlambda calculus. Since I\'m trying to avoid entering into the mathematics\nbehind OCaml because that makes for a very boring and irrelevant\ntutorial, I won\'t go any further on the subject. You can find much more\ninformation about currying if it interests you by [doing a search on\nGoogle](https://www.google.com/search?q=currying "https://www.google.com/search?q=currying").\n\nRemember our `double` and `multiply` functions from earlier on?\n`multiply` was defined as this:\n\n```ocaml\n# let multiply n list =\n  let f x = n * x in\n    List.map f list\nval multiply : int -> int list -> int list = <fun>\n```\nWe can now define `double`, `triple` &amp;c functions very easily just like\nthis:\n\n```ocaml\n# let double = multiply 2\nval double : int list -> int list = <fun>\n# let triple = multiply 3\nval triple : int list -> int list = <fun>\n```\nThey really are functions, look:\n\n```ocaml\n# double [1; 2; 3]\n- : int list = [2; 4; 6]\n# triple [1; 2; 3]\n- : int list = [3; 6; 9]\n```\n\nYou can also use partial application directly (without the intermediate\n`f` function) like this:\n\n```ocaml\n# let multiply n = List.map (( * ) n)\nval multiply : int -> int list -> int list = <fun>\n# let double = multiply 2\nval double : int list -> int list = <fun>\n# let triple = multiply 3\nval triple : int list -> int list = <fun>\n# double [1; 2; 3]\n- : int list = [2; 4; 6]\n# triple [1; 2; 3]\n- : int list = [3; 6; 9]\n```\n\nIn the example above, `(( * ) n)` is the partial application of the `( * )`\n(times) function. Note the extra spaces needed so that OCaml doesn\'t\nthink `(*` starts a comment.\n\nYou can put infix operators into brackets to make functions. Here\'s an\nidentical definition of the `plus` function as before:\n\n```ocaml\n# let plus = ( + )\nval plus : int -> int -> int = <fun>\n# plus 2 3\n- : int = 5\n```\nHere\'s some more currying fun:\n\n```ocaml\n# List.map (plus 2) [1; 2; 3]\n- : int list = [3; 4; 5]\n# let list_of_functions = List.map plus [1; 2; 3]\nval list_of_functions : (int -> int) list = [<fun>; <fun>; <fun>]\n```\n\n##  What is functional programming good for?\nFunctional programming, like any good programming technique, is a useful\ntool in your armoury for solving some classes of problems. It\'s very\ngood for callbacks, which have multiple uses from GUIs through to\nevent-driven loops. It\'s great for expressing generic algorithms.\n`List.map` is really a generic algorithm for applying functions over any\ntype of list. Similarly you can define generic functions over trees.\nCertain types of numerical problems can be solved more quickly with\nfunctional programming (for example, numerically calculating the\nderivative of a mathematical function).\n\n##  Pure and impure functional programming\nA **pure function** is one without any **side-effects**. A side-effect\nreally means that the function keeps some sort of hidden state inside\nit. `strlen` is a good example of a pure function in C. If you call\n`strlen` with the same string, it always returns the same length. The\noutput of `strlen` (the length) only depends on the inputs (the string)\nand nothing else. Many functions in C are, unfortunately, impure. For\nexample, `malloc` - if you call it with the same number, it certainly\nwon\'t return the same pointer to you. `malloc`, of course, relies on a\nhuge amount of hidden internal state (objects allocated on the heap, the\nallocation method in use, grabbing pages from the operating system,\netc.).\n\nML-derived languages like OCaml are "mostly pure". They allow\nside-effects through things like references and arrays, but by and large\nmost of the code you\'ll write will be pure functional because they\nencourage this thinking. Haskell, another functional language, is pure\nfunctional. OCaml is therefore more practical because writing impure\nfunctions is sometimes useful.\n\nThere are various theoretical advantages of having pure functions. One\nadvantage is that if a function is pure, then if it is called several\ntimes with the same arguments, the compiler only needs to actually call\nthe function once. A good example in C is:\n\n```C\nfor (i = 0; i < strlen (s); ++i)\n  {\n    // Do something which doesn\'t affect s.\n  }\n```\nIf naively compiled, this loop is O(n<sup>2</sup>) because `strlen (s)`\nis called each time and `strlen` needs to iterate over the whole of `s`.\nIf the compiler is smart enough to work out that `strlen` is pure\nfunctional *and* that `s` is not updated in the loop, then it can remove\nthe redundant extra calls to `strlen` and make the loop O(n). Do\ncompilers really do this? In the case of `strlen` yes, in other cases,\nprobably not.\n\nConcentrating on writing small pure functions allows you to construct\nreusable code using a bottom-up approach, testing each small function as\nyou go along. The current fashion is for carefully planning your\nprograms using a top-down approach, but in the author\'s opinion this\noften results in projects failing.\n\n##  Strictness vs laziness\nC-derived and ML-derived languages are strict. Haskell and Miranda are\nnon-strict, or lazy, languages. OCaml is strict by default but allows a\nlazy style of programming where it is needed.\n\nIn a strict language, arguments to functions are always evaluated first,\nand the results are then passed to the function. For example in a strict\nlanguage, the call `give_me_a_three (1/0)` is always going to result in\na divide-by-zero error:\n\n```ocaml\n# let give_me_a_three _ = 3\nval give_me_a_three : \'a -> int = <fun>\n# give_me_a_three (1/0)\nException: Division_by_zero.\n```\n\nIf you\'ve programmed in any conventional language, this is just how\nthings work, and you\'d be surprised that things could work any other\nway.\n\nIn a lazy language, something stranger happens. Arguments to functions\nare only evaluated if the function actually uses them. Remember that the\n`give_me_a_three` function throws away its argument and always returns a\n3? Well in a lazy language, the above call would *not* fail because\n`give_me_a_three` never looks at its first argument, so the first\nargument is never evaluated, so the division by zero doesn\'t happen.\n\nLazy languages also let you do really odd things like defining an\ninfinitely long list. Provided you don\'t actually try to iterate over\nthe whole list this works (say, instead, that you just try to fetch the\nfirst 10 elements).\n\nOCaml is a strict language, but has a `Lazy` module that lets you write\nlazy expressions. Here\'s an example. First we create a lazy expression\nfor `1/0`:\n\n```ocaml\n# let lazy_expr = lazy (1 / 0)\nval lazy_expr : int lazy_t = <lazy>\n```\n\nNotice the type of this lazy expression is `int lazy_t`.\n\nBecause `give_me_a_three` takes `\'a` (any type) we can pass this lazy\nexpression into the function:\n\n```ocaml\n# give_me_a_three lazy_expr\n- : int = 3\n```\n\nTo evaluate a lazy expression, you must use the `Lazy.force` function:\n\n```ocaml\n# Lazy.force lazy_expr\nException: Division_by_zero.\n```\n\n##  Boxed vs. unboxed types\nOne term which you\'ll hear a lot when discussing functional languages is\n"boxed". I was very confused when I first heard this term, but in fact\nthe distinction between boxed and unboxed types is quite simple if\nyou\'ve used C, C++ or Java before (in Perl, everything is boxed).\n\nThe way to think of a boxed object is to think of an object which has\nbeen allocated on the heap using `malloc` in C (or equivalently `new` in\nC++), and/or is referred to through a pointer. Take a look at this\nexample C program:\n\n```C\n#include <stdio.h>\n\nvoid\nprintit (int *ptr)\n{\n  printf ("the number is %d\\n", *ptr);\n}\n\nvoid\nmain ()\n{\n  int a = 3;\n  int *p = &a;\n\n  printit (p);\n}\n```\n\nThe variable `a` is allocated on the stack, and is quite definitely\nunboxed.\n\nThe function `printit` takes a boxed integer and prints it.\n\nThe diagram below shows an array of unboxed (top) vs. boxed (below)\nintegers:\n\n![Boxed Array](/tutorials/boxedarray.png "")\n\nNo prizes for guessing that the array of unboxed integers is much faster\nthan the array of boxed integers. In addition, because there are fewer\nseparate allocations, garbage collection is much faster and simpler on\nthe array of unboxed objects.\n\nIn C or C++ you should have no problems constructing either of the two\ntypes of arrays above. In Java, you have two types, `int` which is\nunboxed and `Integer` which is boxed, and hence considerably less\nefficient. In OCaml, the basic types are all unboxed.\n\n## Aliases for function names and arguments\nIt\'s possible to use this as a neat trick to save typing: aliasing function\nnames, and function arguments.\n\nAlthough we haven\'t looked at object-oriented programming (that\'s the\nsubject for the ["Objects" section](objects.html)),\nhere\'s an example from OCamlNet of an\naliased function call. All you need to know is that\n`cgi # output # output_string "string"` is a method call, similar to\n`cgi.output().output_string ("string")` in Java.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet begin_page cgi title =\n  let out = cgi # output # output_string in\n  out "<html>\\n";\n  out "<head>\\n";\n  out ("<title>" ^ text title ^ "</title>\\n");\n  out ("<style type=\\"text/css\\">\\n");\n  out "body { background: white; color: black; }\\n";\n  out "</style>\\n";\n  out "</head>\\n";\n  out "<body>\\n";\n  out ("<h1>" ^ text title ^ "</h1>\\n")\n```\n\nThe `let out = ... ` is a partial function application for that method\ncall (partial, because the string parameter hasn\'t been applied). `out`\nis therefore a function, which takes a string parameter.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nout "<html>\\n";\n```\n\nis equivalent to:\n\x3c!-- $MDX skip --\x3e\n```ocaml\ncgi # output # output_string "<html>\\n";\n```\n\nWe saved ourselves a lot of typing there.\n\nWe can also add arguments. This alternative definition of `print_string`\ncan be thought of as a kind of alias for a function name plus arguments:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet print_string = output_string stdout\n```\n\n`output_string` takes two arguments (a channel and a string), but since\nwe have only supplied one, it is partially applied. So `print_string` is\na function, expecting one string argument.\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#what-is-functional-programming">What is functional programming?</a>\n</li>\n<li><a href="#partial-function-applications-and-currying">Partial function applications and currying</a>\n</li>\n<li><a href="#what-is-functional-programming-good-for">What is functional programming good for?</a>\n</li>\n<li><a href="#pure-and-impure-functional-programming">Pure and impure functional programming</a>\n</li>\n<li><a href="#strictness-vs-laziness">Strictness vs laziness</a>\n</li>\n<li><a href="#boxed-vs-unboxed-types">Boxed vs. unboxed types</a>\n</li>\n<li><a href="#aliases-for-function-names-and-arguments">Aliases for function names and arguments</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="what-is-functional-programming">What is functional programming?</h2>\n<p>We\'ve got quite far into the tutorial, yet we haven\'t really considered\n<strong>functional programming</strong>. All of the features given so far - rich data\ntypes, pattern matching, type inference, nested functions - you could\nimagine could exist in a kind of &quot;super C&quot; language. These are Cool\nFeatures certainly, and make your code concise, easy to read, and have\nfewer bugs, but they actually have very little to do with functional\nprogramming. In fact my argument is going to be that the reason that\nfunctional languages are so great is <em>not</em> because of functional\nprogramming, but because we\'ve been stuck with C-like languages for\nyears and in the meantime the cutting edge of programming has moved on\nconsiderably. So while we were writing\n<code>struct { int type; union { ... } }</code> for the umpteenth time, ML and\nHaskell programmers had safe variants and pattern matching on datatypes.\nWhile we were being careful to <code>free</code> all our <code>malloc</code>s, there have been\nlanguages with garbage collectors able to outperform hand-coding since\nthe 80s.</p>\n<p>Well, after that I\'d better tell you what functional programming is\nanyhow.</p>\n<p>The basic, and not very enlightening definition is this: in a\n<strong>functional language</strong>, <strong>functions</strong> are first-class citizens.</p>\n<p>Lot of words there that don\'t really make much sense. So let\'s have an\nexample:</p>\n<pre><code class="language-ocaml"># let double x = x * 2 in\n    List.map double [1; 2; 3]\n- : int list = [2; 4; 6]\n</code></pre>\n<p>In this example, I\'ve first defined a nested function called <code>double</code>\nwhich takes an argument <code>x</code> and returns <code>x * 2</code>. Then <code>map</code> calls\n<code>double</code> on each element of the given list (<code>[1; 2; 3]</code>) to produce the\nresult: a list with each number doubled.</p>\n<p><code>map</code> is known as a <strong>higher-order function</strong> (HOF). Higher-order\nfunctions are just a fancy way of saying that the function takes a\nfunction as one of its arguments. So far so simple. If you\'re familiar\nwith C/C++ then this looks like passing a function pointer around.</p>\n<p><strong>Closures</strong> are functions which carry around some of the &quot;environment&quot;\nin which they were defined. In particular, a closure can reference\nvariables which were available at the point of its definition. Let\'s\ngeneralise the function above so that now we can take any list of\nintegers and multiply each element by an arbitrary value <code>n</code>:</p>\n<pre><code class="language-ocaml"># let multiply n list =\n    let f x = n * x in\n      List.map f list\nval multiply : int -&gt; int list -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Hence:</p>\n<pre><code class="language-ocaml"># multiply 2 [1; 2; 3]\n- : int list = [2; 4; 6]\n# multiply 5 [1; 2; 3]\n- : int list = [5; 10; 15]\n</code></pre>\n<p>The important point to note about the <code>multiply</code> function is the nested\nfunction <code>f</code>. This is a closure. Look at how <code>f</code> uses the value of <code>n</code>\nwhich isn\'t actually passed as an explicit argument to <code>f</code>. Instead <code>f</code>\npicks it up from its environment - it\'s an argument to the <code>multiply</code>\nfunction and hence available within this function.</p>\n<p>This might sound straightforward, but let\'s look a bit closer at that\ncall to map: <code>List.map f list</code>.</p>\n<p><code>map</code> is defined in the <code>List</code> module, far away from the current code.\nIn other words, we\'re passing <code>f</code> into a module defined &quot;a long time\nago, in a galaxy far far away&quot;. For all we know that code might pass <code>f</code>\nto other modules, or save a reference to <code>f</code> somewhere and call it\nlater. Whether it does this or not, the closure will ensure that <code>f</code>\nalways has access back to its parental environment, and to <code>n</code>.</p>\n<p>Here\'s a real example from lablgtk. This is actually a method on a class\n(we haven\'t talked about classes and objects yet, but just think of it\nas a function definition for now).</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">class html_skel obj = object (self)\n  ...\n  ...\n  method save_to_channel chan =\n    let receiver_fn content =\n      output_string chan content;\n      true\n    in\n      save obj receiver_fn\n  ...\nend\n</code></pre>\n<p>First of all you need to know that the <code>save</code> function called at the end\nof the method takes as its second argument a function (<code>receiver_fn</code>).\nIt repeatedly calls <code>receiver_fn</code> with snippets of text from the widget\nthat it\'s trying to save.</p>\n<p>Now look at the definition of <code>receiver_fn</code>. This function is a closure\nalright because it keeps a reference to <code>chan</code> from its environment.</p>\n<h2 id="partial-function-applications-and-currying">Partial function applications and currying</h2>\n<p>Let\'s define a plus function which just adds two integers:</p>\n<pre><code class="language-ocaml"># let plus a b =\n    a + b\nval plus : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>Some questions for people asleep at the back of the class.</p>\n<ol>\n<li>What is <code>plus</code>?\n</li>\n<li>What is <code>plus 2 3</code>?\n</li>\n<li>What is <code>plus 2</code>?\n</li>\n</ol>\n<p>Question 1 is easy. <code>plus</code> is a function, it takes two arguments which\nare integers and it returns an integer. We write its type like this:</p>\n<pre><code class="language-ocaml"># plus\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>Question 2 is even easier. <code>plus 2 3</code> is a number, the integer <code>5</code>. We\nwrite its value and type like this:</p>\n<pre><code class="language-ocaml"># 5\n- : int = 5\n</code></pre>\n<p>But what about question 3? It looks like <code>plus 2</code> is a mistake, a bug.\nIn fact, however, it isn\'t. If we type this into the OCaml toplevel, it\ntells us:</p>\n<pre><code class="language-ocaml"># plus 2\n- : int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>This isn\'t an error. It\'s telling us that <code>plus 2</code> is in fact a\n<em>function</em>, which takes an <code>int</code> and returns an <code>int</code>. What sort of\nfunction is this? We experiment by first of all giving this mysterious\nfunction a name (<code>f</code>), and then trying it out on a few integers to see\nwhat it does:</p>\n<pre><code class="language-ocaml"># let f = plus 2\nval f : int -&gt; int = &lt;fun&gt;\n# f 10\n- : int = 12\n# f 15\n- : int = 17\n# f 99\n- : int = 101\n</code></pre>\n<p>In engineering this is sufficient <a href="humor_proof.html">proof by example</a>\nfor us to state that <code>plus 2</code> is the function which adds 2 to things.</p>\n<p>Going back to the original definition, let\'s &quot;fill in&quot; the first\nargument (<code>a</code>) setting it to 2 to get:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let plus 2 b =       (* This is not real OCaml code! *)\n  2 + b\n</code></pre>\n<p>You can kind of see, I hope, why <code>plus 2</code> is the function which adds 2\nto things.</p>\n<p>Looking at the types of these expressions we may be able to see some\nrationale for the strange <code>-&gt;</code> arrow notation used for function types:</p>\n<pre><code class="language-ocaml"># plus\n- : int -&gt; int -&gt; int = &lt;fun&gt;\n# plus 2\n- : int -&gt; int = &lt;fun&gt;\n# plus 2 3\n- : int = 5\n</code></pre>\n<p>This process is called <strong>currying</strong> (or perhaps it\'s called\n<strong>uncurrying</strong>, I never was really sure which was which). It is called\nthis after Haskell Curry who did some important stuff related to the\nlambda calculus. Since I\'m trying to avoid entering into the mathematics\nbehind OCaml because that makes for a very boring and irrelevant\ntutorial, I won\'t go any further on the subject. You can find much more\ninformation about currying if it interests you by <a href="https://www.google.com/search?q=currying" title="https://www.google.com/search?q=currying">doing a search on\nGoogle</a>.</p>\n<p>Remember our <code>double</code> and <code>multiply</code> functions from earlier on?\n<code>multiply</code> was defined as this:</p>\n<pre><code class="language-ocaml"># let multiply n list =\n  let f x = n * x in\n    List.map f list\nval multiply : int -&gt; int list -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>We can now define <code>double</code>, <code>triple</code> &amp;c functions very easily just like\nthis:</p>\n<pre><code class="language-ocaml"># let double = multiply 2\nval double : int list -&gt; int list = &lt;fun&gt;\n# let triple = multiply 3\nval triple : int list -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>They really are functions, look:</p>\n<pre><code class="language-ocaml"># double [1; 2; 3]\n- : int list = [2; 4; 6]\n# triple [1; 2; 3]\n- : int list = [3; 6; 9]\n</code></pre>\n<p>You can also use partial application directly (without the intermediate\n<code>f</code> function) like this:</p>\n<pre><code class="language-ocaml"># let multiply n = List.map (( * ) n)\nval multiply : int -&gt; int list -&gt; int list = &lt;fun&gt;\n# let double = multiply 2\nval double : int list -&gt; int list = &lt;fun&gt;\n# let triple = multiply 3\nval triple : int list -&gt; int list = &lt;fun&gt;\n# double [1; 2; 3]\n- : int list = [2; 4; 6]\n# triple [1; 2; 3]\n- : int list = [3; 6; 9]\n</code></pre>\n<p>In the example above, <code>(( * ) n)</code> is the partial application of the <code>( * )</code>\n(times) function. Note the extra spaces needed so that OCaml doesn\'t\nthink <code>(*</code> starts a comment.</p>\n<p>You can put infix operators into brackets to make functions. Here\'s an\nidentical definition of the <code>plus</code> function as before:</p>\n<pre><code class="language-ocaml"># let plus = ( + )\nval plus : int -&gt; int -&gt; int = &lt;fun&gt;\n# plus 2 3\n- : int = 5\n</code></pre>\n<p>Here\'s some more currying fun:</p>\n<pre><code class="language-ocaml"># List.map (plus 2) [1; 2; 3]\n- : int list = [3; 4; 5]\n# let list_of_functions = List.map plus [1; 2; 3]\nval list_of_functions : (int -&gt; int) list = [&lt;fun&gt;; &lt;fun&gt;; &lt;fun&gt;]\n</code></pre>\n<h2 id="what-is-functional-programming-good-for">What is functional programming good for?</h2>\n<p>Functional programming, like any good programming technique, is a useful\ntool in your armoury for solving some classes of problems. It\'s very\ngood for callbacks, which have multiple uses from GUIs through to\nevent-driven loops. It\'s great for expressing generic algorithms.\n<code>List.map</code> is really a generic algorithm for applying functions over any\ntype of list. Similarly you can define generic functions over trees.\nCertain types of numerical problems can be solved more quickly with\nfunctional programming (for example, numerically calculating the\nderivative of a mathematical function).</p>\n<h2 id="pure-and-impure-functional-programming">Pure and impure functional programming</h2>\n<p>A <strong>pure function</strong> is one without any <strong>side-effects</strong>. A side-effect\nreally means that the function keeps some sort of hidden state inside\nit. <code>strlen</code> is a good example of a pure function in C. If you call\n<code>strlen</code> with the same string, it always returns the same length. The\noutput of <code>strlen</code> (the length) only depends on the inputs (the string)\nand nothing else. Many functions in C are, unfortunately, impure. For\nexample, <code>malloc</code> - if you call it with the same number, it certainly\nwon\'t return the same pointer to you. <code>malloc</code>, of course, relies on a\nhuge amount of hidden internal state (objects allocated on the heap, the\nallocation method in use, grabbing pages from the operating system,\netc.).</p>\n<p>ML-derived languages like OCaml are &quot;mostly pure&quot;. They allow\nside-effects through things like references and arrays, but by and large\nmost of the code you\'ll write will be pure functional because they\nencourage this thinking. Haskell, another functional language, is pure\nfunctional. OCaml is therefore more practical because writing impure\nfunctions is sometimes useful.</p>\n<p>There are various theoretical advantages of having pure functions. One\nadvantage is that if a function is pure, then if it is called several\ntimes with the same arguments, the compiler only needs to actually call\nthe function once. A good example in C is:</p>\n<pre><code class="language-C">for (i = 0; i &lt; strlen (s); ++i)\n  {\n    // Do something which doesn\'t affect s.\n  }\n</code></pre>\n<p>If naively compiled, this loop is O(n<sup>2</sup>) because <code>strlen (s)</code>\nis called each time and <code>strlen</code> needs to iterate over the whole of <code>s</code>.\nIf the compiler is smart enough to work out that <code>strlen</code> is pure\nfunctional <em>and</em> that <code>s</code> is not updated in the loop, then it can remove\nthe redundant extra calls to <code>strlen</code> and make the loop O(n). Do\ncompilers really do this? In the case of <code>strlen</code> yes, in other cases,\nprobably not.</p>\n<p>Concentrating on writing small pure functions allows you to construct\nreusable code using a bottom-up approach, testing each small function as\nyou go along. The current fashion is for carefully planning your\nprograms using a top-down approach, but in the author\'s opinion this\noften results in projects failing.</p>\n<h2 id="strictness-vs-laziness">Strictness vs laziness</h2>\n<p>C-derived and ML-derived languages are strict. Haskell and Miranda are\nnon-strict, or lazy, languages. OCaml is strict by default but allows a\nlazy style of programming where it is needed.</p>\n<p>In a strict language, arguments to functions are always evaluated first,\nand the results are then passed to the function. For example in a strict\nlanguage, the call <code>give_me_a_three (1/0)</code> is always going to result in\na divide-by-zero error:</p>\n<pre><code class="language-ocaml"># let give_me_a_three _ = 3\nval give_me_a_three : \'a -&gt; int = &lt;fun&gt;\n# give_me_a_three (1/0)\nException: Division_by_zero.\n</code></pre>\n<p>If you\'ve programmed in any conventional language, this is just how\nthings work, and you\'d be surprised that things could work any other\nway.</p>\n<p>In a lazy language, something stranger happens. Arguments to functions\nare only evaluated if the function actually uses them. Remember that the\n<code>give_me_a_three</code> function throws away its argument and always returns a\n3? Well in a lazy language, the above call would <em>not</em> fail because\n<code>give_me_a_three</code> never looks at its first argument, so the first\nargument is never evaluated, so the division by zero doesn\'t happen.</p>\n<p>Lazy languages also let you do really odd things like defining an\ninfinitely long list. Provided you don\'t actually try to iterate over\nthe whole list this works (say, instead, that you just try to fetch the\nfirst 10 elements).</p>\n<p>OCaml is a strict language, but has a <code>Lazy</code> module that lets you write\nlazy expressions. Here\'s an example. First we create a lazy expression\nfor <code>1/0</code>:</p>\n<pre><code class="language-ocaml"># let lazy_expr = lazy (1 / 0)\nval lazy_expr : int lazy_t = &lt;lazy&gt;\n</code></pre>\n<p>Notice the type of this lazy expression is <code>int lazy_t</code>.</p>\n<p>Because <code>give_me_a_three</code> takes <code>\'a</code> (any type) we can pass this lazy\nexpression into the function:</p>\n<pre><code class="language-ocaml"># give_me_a_three lazy_expr\n- : int = 3\n</code></pre>\n<p>To evaluate a lazy expression, you must use the <code>Lazy.force</code> function:</p>\n<pre><code class="language-ocaml"># Lazy.force lazy_expr\nException: Division_by_zero.\n</code></pre>\n<h2 id="boxed-vs-unboxed-types">Boxed vs. unboxed types</h2>\n<p>One term which you\'ll hear a lot when discussing functional languages is\n&quot;boxed&quot;. I was very confused when I first heard this term, but in fact\nthe distinction between boxed and unboxed types is quite simple if\nyou\'ve used C, C++ or Java before (in Perl, everything is boxed).</p>\n<p>The way to think of a boxed object is to think of an object which has\nbeen allocated on the heap using <code>malloc</code> in C (or equivalently <code>new</code> in\nC++), and/or is referred to through a pointer. Take a look at this\nexample C program:</p>\n<pre><code class="language-C">#include &lt;stdio.h&gt;\n\nvoid\nprintit (int *ptr)\n{\n  printf (&quot;the number is %d\\n&quot;, *ptr);\n}\n\nvoid\nmain ()\n{\n  int a = 3;\n  int *p = &amp;a;\n\n  printit (p);\n}\n</code></pre>\n<p>The variable <code>a</code> is allocated on the stack, and is quite definitely\nunboxed.</p>\n<p>The function <code>printit</code> takes a boxed integer and prints it.</p>\n<p>The diagram below shows an array of unboxed (top) vs. boxed (below)\nintegers:</p>\n<p><img src="/tutorials/boxedarray.png" alt="Boxed Array" title="" /></p>\n<p>No prizes for guessing that the array of unboxed integers is much faster\nthan the array of boxed integers. In addition, because there are fewer\nseparate allocations, garbage collection is much faster and simpler on\nthe array of unboxed objects.</p>\n<p>In C or C++ you should have no problems constructing either of the two\ntypes of arrays above. In Java, you have two types, <code>int</code> which is\nunboxed and <code>Integer</code> which is boxed, and hence considerably less\nefficient. In OCaml, the basic types are all unboxed.</p>\n<h2 id="aliases-for-function-names-and-arguments">Aliases for function names and arguments</h2>\n<p>It\'s possible to use this as a neat trick to save typing: aliasing function\nnames, and function arguments.</p>\n<p>Although we haven\'t looked at object-oriented programming (that\'s the\nsubject for the <a href="objects.html">&quot;Objects&quot; section</a>),\nhere\'s an example from OCamlNet of an\naliased function call. All you need to know is that\n<code>cgi # output # output_string &quot;string&quot;</code> is a method call, similar to\n<code>cgi.output().output_string (&quot;string&quot;)</code> in Java.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let begin_page cgi title =\n  let out = cgi # output # output_string in\n  out &quot;&lt;html&gt;\\n&quot;;\n  out &quot;&lt;head&gt;\\n&quot;;\n  out (&quot;&lt;title&gt;&quot; ^ text title ^ &quot;&lt;/title&gt;\\n&quot;);\n  out (&quot;&lt;style type=\\&quot;text/css\\&quot;&gt;\\n&quot;);\n  out &quot;body { background: white; color: black; }\\n&quot;;\n  out &quot;&lt;/style&gt;\\n&quot;;\n  out &quot;&lt;/head&gt;\\n&quot;;\n  out &quot;&lt;body&gt;\\n&quot;;\n  out (&quot;&lt;h1&gt;&quot; ^ text title ^ &quot;&lt;/h1&gt;\\n&quot;)\n</code></pre>\n<p>The <code>let out = ... </code> is a partial function application for that method\ncall (partial, because the string parameter hasn\'t been applied). <code>out</code>\nis therefore a function, which takes a string parameter.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">out &quot;&lt;html&gt;\\n&quot;;\n</code></pre>\n<p>is equivalent to:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">cgi # output # output_string &quot;&lt;html&gt;\\n&quot;;\n</code></pre>\n<p>We saved ourselves a lot of typing there.</p>\n<p>We can also add arguments. This alternative definition of <code>print_string</code>\ncan be thought of as a kind of alias for a function name plus arguments:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let print_string = output_string stdout\n</code></pre>\n<p><code>output_string</code> takes two arguments (a channel and a string), but since\nwe have only supplied one, it is partially applied. So <code>print_string</code> is\na function, expecting one string argument.</p>\n'},tl:{hd:{title:"If Statements, Loops and Recursions",slug:"if-statements-loops-and-recursions",description:"Learn basic control-flow and recusion in OCaml\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"language",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:'\n## If statements (actually, these are if expressions)\nOCaml has an `if` statement with two variations, and the obvious meaning:\n\n```ocaml\nif boolean-condition then expression\n  \nif boolean-condition then expression else other-expression\n```\n```mdx-error\nLine 3, characters 3-5:\nError: Syntax error\n```\n\nUnlike in the conventional languages you\'ll be used to, `if` statements\nare really expressions. In other words, they\'re much more like\n`boolean-condition ? expression : other-expression` in C than like the if\nstatements you may be used to.\n\nHere\'s a simple example of an `if` statement:\n\n```ocaml\n# let max a b =\n  if a > b then a else b\nval max : \'a -> \'a -> \'a = <fun>\n```\n\nAs a short aside, if you type this into the OCaml\ninteractive toplevel (as above), you\'ll\nnotice that OCaml decides that this function is polymorphic, with the\nfollowing type:\n\n```ocaml\n# max\n- : \'a -> \'a -> \'a = <fun>\n```\n\nAnd indeed OCaml lets you use `max` on any type:\n\n```ocaml\n# max 3 5\n- : int = 5\n# max 3.5 13.0\n- : float = 13.\n# max "a" "b"\n- : string = "b"\n```\n\nThis is because `>` is in fact polymorphic. It works on any type, even\nobjects (it does a binary comparison).\n\n\\[Note that the `Stdlib` module defines `min` and `max` for you.\\]\n\nLet\'s look a bit more closely at the `if` expression. Here\'s the `range`\nfunction which I showed you earlier without much explanation. You should\nbe able to combine your knowledge of recursive functions, lists and if\nexpressions to see what it does:\n\n```ocaml\n# let rec range a b =\n    if a > b then []\n    else a :: range (a + 1) b\nval range : int -> int -> int list = <fun>\n```\n\nLet\'s examine some typical calls to this function. Let\'s start with the\neasy case of `a > b`. A call to `range 11 10` returns `[]` (the empty\nlist) and that\'s it.\n\nWhat about calling `range 10 10`? Since `10 > 10` is false, the\n`else`-clause is evaluated, which is: `10 :: (range 11 10)` (I\'ve added\nthe brackets to make the order of evaluation more clear). We\'ve just\nworked out that `range 11 10` = `[]`, so this is: `10 :: []`. Remember\nour formal description of lists and the `::` (cons) operator? `10 :: []`\nis just the same as `[10]`.\n\nLet\'s try `range 9 10`:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nrange 9 10\n\u2192 9 :: (range 10 10)\n\u2192 9 :: [10]\n\u2192 [9; 10]\n```\n\nIt should be fairly clear that `range 1 10` evaluates to\n`[1; 2; 3; 4; 5; 6; 7; 8; 9; 10]`.\n\nWhat we\'ve got here is a simple case of recursion. Functional\nprogramming can be said to prefer recursion over loops, but I\'m jumping\nahead of myself. We\'ll discuss recursion more at the end of this\nchapter.\n\nBack, temporarily, to `if` statements. What does this function do?\n\n```ocaml\n# let f x y =\n    x + if y > 0 then y else 0\nval f : int -> int -> int = <fun>\n```\n\nClue: add brackets around the whole of the if expression. It clips `y`\nlike an [electronic diode](https://en.wikipedia.org/wiki/Diode#Current.E2.80.93voltage_characteristic).\n\nThe `abs` (absolute value) function is defined in `Stdlib` as:\n\n```ocaml\n# let abs x =\n    if x >= 0 then x else -x\nval abs : int -> int = <fun>\n```\n\nAlso in `Stdlib`, the `string_of_float` function contains a complex\npair of nested `if` expressions:\n\n```ocaml\n# let string_of_float f =\n  let s = format_float "%.12g" f in\n  let l = string_length s in\n  let rec loop i =\n    if i >= l then s ^ "."\n    else if s.[i] = \'.\' || s.[i] = \'e\' then s\n    else loop (i + 1)\n  in\n    loop 0\nLine 2, characters 11-23:\nError: Unbound value format_float\n```\n\nLet\'s examine this function. Suppose the function is called with `f` =\n12.34. Then `s` = "12.34", and `l` = 5. We call `loop` the first time\nwith `i` = 0.\n\n`i` is not greater than or equal to `l`, and `s.[i]` (the\n`i`<sup>th</sup> character in `s`) is not a period or `\'e\'`. So\n`loop (i + 1)` is called, ie. `loop 1`.\n\nWe go through the same dance for `i` = 1, and end up calling `loop 2`.\n\nFor `i` = 2, however, `s.[i]` is a period (refer to the original string,\n`s` = "12.34"). So this immediately returns `s`, and the function\n`string_of_float` returns "12.34".\n\nWhat is `loop` doing? In fact it\'s checking whether the string returned\nfrom `format_float` contains a period (or `\'e\'`). Suppose that we called\n`string_of_float` with `12.0`. `format_float` would return the string\n"12", but `string_of_float` must return "12." or "12.0" (because\nfloating point constants in OCaml must contain a period to differentiate\nthem from integer constants). Hence the check.\n\nThe strange use of recursion in this function is almost certainly for\nefficiency. OCaml supports for loops, so why didn\'t the authors use for\nloops? We\'ll see in the next section that OCaml\'s for loops are limited\nin a way which prevents them from being used in `string_of_float`. Here,\nhowever, is a more straightforward, but approximately twice as slow, way\nof writing `string_of_float`:\n\n```ocaml\n# let string_of_float f =\n  let s = format_float "%.12g" f in\n    if String.contains s \'.\' || String.contains s \'e\'\n      then s\n      else s ^ "."\nLine 2, characters 11-23:\nError: Unbound value format_float\n```\n\n## Using begin ... end\nHere is some code from lablgtk:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nif GtkBase.Object.is_a obj cls then\n  fun _ -> f obj\nelse begin\n  eprintf "Glade-warning: %s expects a %s argument.\\n" name cls;\n  raise Not_found\nend\n```\n\n`begin` and `end` are what is known as **syntactic sugar** for open and\nclose parentheses. In the example above, all they do is group the two\nstatements in the `else`-clause together. Suppose the author had written\nthis instead:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nif GtkBase.Object.is_a obj cls then\n  fun _ -> f obj\nelse\n  eprintf "Glade-warning: %s expects a %s argument.\\n" name cls;\n  raise Not_found\n```\nFully bracketing and properly indenting the above expression gives:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\n(if GtkBase.Object.is_a obj cls then\n   fun _ -> f obj\n else\n   eprintf "Glade-warning: %s expects a %s argument.\\n" name cls\n);\nraise Not_found\n```\nNot what was intended at all. So the `begin` and `end` are necessary to\ngroup together multiple statements in a `then` or `else` clause of an if\nexpression. You can also use plain ordinary parentheses `( ... )` if you\nprefer (and I do prefer, because I **loathe** Pascal :-). Here are two\nsimple examples:\n\n```ocaml\n# if 1 = 0 then\n    print_endline "THEN"\n  else begin\n    print_endline "ELSE";\n    failwith "else clause"\n  end\nException: Failure "else clause".\nELSE\n# if 1 = 0 then\n    print_endline "THEN"\n  else (\n    print_endline "ELSE";\n    failwith "else clause"\n  )\nException: Failure "else clause".\nELSE\n```\n\n## For loops and while loops\nOCaml supports a rather limited form of the familiar `for` loop:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nfor variable = start_value to end_value do\n  expression\ndone\n  \nfor variable = start_value downto end_value do\n  expression\ndone\n```\nA simple but real example from lablgtk:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nfor i = 1 to n_jobs () do\n  do_next_job ()\ndone\n```\nIn OCaml, `for` loops are just shorthand for writing:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet i = 1 in\ndo_next_job ();\nlet i = 2 in\ndo_next_job ();\nlet i = 3 in\ndo_next_job ();\n  ...\nlet i = n_jobs () in\ndo_next_job ();\n()\n```\n\nOCaml doesn\'t support the concept of breaking out of a `for` loop early\ni.e. it has no `break`, `continue` or `last` statements. (You *could*\nthrow an exception and catch it outside, and this would run fast but\noften looks clumsy.)\n\nThe expression inside an OCaml for loop should evaluate to `unit`\n(otherwise you\'ll get a warning), and the for loop expression as a whole\nreturns `unit`:\n\n```ocaml\n# for i = 1 to 10 do i done\nLine 1, characters 20-21:\nWarning 10: this expression should have type unit.\n- : unit = ()\n```\nFunctional programmers tend to use recursion instead of explicit loops,\nand regard **for** loops with suspicion since it can\'t return anything,\nhence OCaml\'s relatively powerless **for** loop. We talk about recursion\nbelow.\n\n**While loops** in OCaml are written:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nwhile boolean-condition do\n  expression\ndone\n```\nAs with for loops, there is no way provided by the language to break out\nof a while loop, except by throwing an exception, and this means that\nwhile loops have fairly limited use. Again, remember that functional\nprogrammers like recursion, and so while loops are second-class citizens\nin the language.\n\nIf you stop to consider while loops, you may see that they aren\'t really\nany use at all, except in conjunction with our old friend references.\nLet\'s imagine that OCaml didn\'t have references for a moment:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet quit_loop = false in\n  while not quit_loop do\n    print_string "Have you had enough yet? (y/n) ";\n    let str = read_line () in\n      if str.[0] = \'y\' then\n        (* how do I set quit_loop to true ?!? *)\n  done\n```\nRemember that `quit_loop` is not a real "variable" - the let-binding\njust makes `quit_loop` a shorthand for `false`. This means the while\nloop condition (shown in red) is always true, and the loop runs on\nforever!\n\nLuckily OCaml *does have* references, so we can write the code above if\nwe want. Don\'t get confused and think that the `!` (exclamation mark)\nmeans "not" as in C/Java. It\'s used here to mean "dereference the\npointer", similar in fact to Forth. You\'re better off reading `!` as\n"get" or "deref".\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet quit_loop = ref false in\n  while not !quit_loop do\n    print_string "Have you had enough yet? (y/n) ";\n    let str = read_line () in\n      if str.[0] = \'y\' then quit_loop := true\n  done;;\n```\n\n## Looping over lists\nIf you want to loop over a list, don\'t be an imperative programmer and\nreach for your trusty six-shooter Mr. For Loop! OCaml has some better\nand faster ways to loop over lists, and they are all located in the\n`List` module. There are in fact dozens of good functions in `List`, but\nI\'ll only talk about the most useful ones here.\n\nFirst off, let\'s define a list for us to use:\n\n```ocaml\n# let my_list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\nval my_list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n```\n\nIf you want to call a function once on every element of the list, use\n`List.iter`, like this:\n\n```ocaml\n# let f elem =\n    Printf.printf "I\'m looking at element %d now\\n" elem\n  in\n    List.iter f my_list\nI\'m looking at element 1 now\nI\'m looking at element 2 now\nI\'m looking at element 3 now\nI\'m looking at element 4 now\nI\'m looking at element 5 now\nI\'m looking at element 6 now\nI\'m looking at element 7 now\nI\'m looking at element 8 now\nI\'m looking at element 9 now\nI\'m looking at element 10 now\n- : unit = ()\n```\n\n`List.iter` is in fact what you should think about using first every\ntime your cerebellum suggests you use a for loop.\n\nIf you want to *transform* each element separately in the list - for\nexample, doubling each element in the list - then use `List.map`.\n\n```ocaml\n# List.map (( * ) 2) my_list\n- : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]\n```\n\nThe function `List.filter` collects only those elements of a list which satisfy\nsome condition - e.g. returning all even numbers in a list.\n\n```ocaml\n# let is_even i =\n    i mod 2 = 0\n  in\n    List.filter is_even my_list\n- : int list = [2; 4; 6; 8; 10]\n```\n\nTo find out if a list contains some element, use `List.mem` (short for\nmember):\n\n```ocaml\n# List.mem 12 my_list\n- : bool = false\n```\n\n`List.for_all` and `List.exists` are the same as the "forall" and\n"exist" operators in predicate logic.\n\nFor operating over two lists at the same time, there are "-2" variants\nof some of these functions, namely `iter2`, `map2`, `for_all2`,\n`exists2`.\n\nThe `map` and `filter` functions operate on individual list elements in\nisolation. **Fold** is a more unusual operation that is best\nthought about as "inserting an operator between each element of the\nlist". Suppose I wanted to add all the numbers in my list together. In\nhand-waving terms what I want to do is insert a plus sign between the\nelements in my list:\n\n```ocaml\n# 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10\n- : int = 55\n```\n\nThe fold operation does this, although the exact details are a little\nbit more tricky. First of all, what happens if I try to fold an empty\nlist? In the case of summing the list it would be nice if the answer was\nzero, instead of error. However if I was trying to find the product of\nthe list, I\'d like the answer to be one instead. So I obviously have to\nprovide some sort of "default" argument to my fold. The second issue\ndoesn\'t arise with simple operators like `+` and `*`: what happens if\nthe operator I\'m using isn\'t associative, ie. (a *op* b) *op* c not\nequal to a *op* (b *op* c)? In that case it would matter if I started\nfrom the left hand end of the list and worked right, versus if I started\nfrom the right and worked left. For this reason there are two versions\nof fold, called `List.fold_left` (works left to right) and\n`List.fold_right` (works right to left, and is also less efficient).\n\nLet\'s use `List.fold_left` to define `sum` and `product` functions for\ninteger lists:\n\n```ocaml\n# let sum = List.fold_left ( + ) 0\nval sum : int list -> int = <fun>\n# let product = List.fold_left ( * ) 1\nval product : int list -> int = <fun>\n# sum my_list\n- : int = 55\n# product my_list\n- : int = 3628800\n```\n\nThat was easy! Notice that I\'ve accidentally come up with a way to do\nmathematical factorials:\n\n```ocaml\n# let fact n = product (range 1 n)\nval fact : int -> int = <fun>\n# fact 10\n- : int = 3628800\n```\n\n(Notice that this factorial function isn\'t very useful because it\noverflows the integers and gives wrong answers even for quite small\nvalues of `n`.)\n\n## Looping over strings\nThe `String` module also contains many dozens of useful string-related\nfunctions, and some of them are concerned with looping over strings.\n\n`String.copy` copies a string, like `strdup`. There is also a `String.iter`\nfunction which works like `List.iter`, except over the characters of the\nstring.\n\n## Recursion\nNow we come to a hard topic - recursion. Functional programmers are\ndefined by their love of recursive functions, and in many ways recursive\nfunctions in f.p. are the equivalent of loops in imperative programming.\nIn functional languages loops are second-class citizens, whilst\nrecursive functions get all the best support.\n\nWriting recursive functions requires a change in mindset from writing\nfor loops and while loops. So what I\'ll give you in this section will be\njust an introduction and examples.\n\nIn the first example we\'re going to read the whole of a file into memory\n(into a long string). There are essentially three possible approaches to\nthis:\n\n###  Approach 1\nGet the length of the file, and read it all in one go using the\n`really_input` method. This is the simplest, but it might not work on\nchannels which are not really files (eg. reading keyboard input) which\nis why we look at the other two approaches.\n\n###  Approach 2\nThe imperative approach, using a while loop which is broken out of using\nan exception.\n\n###  Approach 3\nA recursive loop, breaking out of the recursion again using an\nexception.\n\nWe\'re going to introduce a few new concepts here. Our second two\napproaches will use the `Buffer` module - an expandable buffer which you\ncan think of like a string onto which you can efficiently append more\ntext at the end. We\'re also going to be catching the `End_of_file`\nexception which the input functions throw when they reach the end of the\ninput. Also we\'re going to use `Sys.argv.(1)` to get the first command\nline parameter.\n\n```ocaml\n(* Read whole file: Approach 1 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let len = in_channel_length chan in\n  let result = (Bytes.create len) in\n    really_input chan result 0 len;\n    (Bytes.to_string result)\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n    printf "I read %d characters from %s\\n" (String.length str) filename\n```\n\nApproach 1 works but is not very satisfactory because `read_whole_chan`\nwon\'t work on non-file channels like keyboard input or sockets. Approach\n2 involves a while loop:\n\n```ocaml\n(* Read whole file: Approach 2 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let buf = Buffer.create 4096 in\n  try\n    while true do\n      let line = input_line chan in\n        Buffer.add_string buf line;\n        Buffer.add_char buf \'\\n\'\n    done;\n    assert false (* This is never executed\n\t                (always raises Assert_failure). *)\n  with\n    End_of_file -> Buffer.contents buf\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n    printf "I read %d characters from %s\\n" (String.length str) filename\n```\n\nThe key to approach 2 is to look at the central while loop. Remember\nthat I said the only way to break out of a while loop early was with an\nexception? This is exactly what we\'re doing here. Although I haven\'t\ncovered exceptions yet, you probably won\'t have any trouble\nunderstanding the `End_of_file` exception thrown in the code above by\n`input_line` when it hits the end of the file. The buffer `buf`\naccumulates the contents of the file, and when we hit the end of the\nfile we return it (`Buffer.contents buf`).\n\nOne curious point about this is the apparently superfluous statement\n(`assert false`) just after the while loop. What is it for?  Remember\nthat while loops, like for loops, are just expressions, and they return\nthe `unit` object (`()`). However OCaml demands that the return type\ninside a `try` matches the return type of each caught exception. In this\ncase because `End_of_file` results in a `string`, the main body of the\n`try` must also "return" a string \u2014 even though because of the infinite\nwhile loop the string could never actually be returned.  `assert false`\nhas a polymorphic type, so will unify with whatever value is returned\nby the `with` branch.\n\nHere\'s our recursive version. Notice that it\'s *shorter* than approach\n2, but not so easy to understand for imperative programmers at least:\n\n```ocaml\n(* Read whole file: Approach 3 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let buf = Buffer.create 4096 in\n  let rec loop () =\n    let line = input_line chan in\n      Buffer.add_string buf line;\n      Buffer.add_char buf \'\\n\';\n      loop ()\n  in\n    try loop () with\n      End_of_file -> Buffer.contents buf\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n  printf "I read %d characters from %s\\n" (String.length str) filename\n```\n\nAgain we have an infinite loop - but in this case done using recursion.\n`loop` calls itself at the end of the function. The infinite recursion\nis broken when `input_line` throws an `End_of_file` exception.\n\nIt looks like approach 3 might overflow the stack if you gave it a\nparticularly large file, but this is in fact not the case. Because of\ntail recursion (discussed below) the compiler will turn the recursive\n`loop` function into a real while loop (!) which runs in constant stack\nspace.\n\nIn the next example we will show how recursion is great for constructing\nor examining certain types of data structures, particularly trees. Let\'s\nhave a recursive type to represent files in a filesystem:\n\n```ocaml\n# type filesystem = File of string | Directory of filesystem list\ntype filesystem = File of string | Directory of filesystem list\n```\n\nThe `opendir` and `readdir` functions are used to open a directory and\nread elements from the directory. I\'m going to define a handy\n`readdir_no_ex` function which hides the annoying `End_of_file`\nexception that `readdir` throws when it reaches the end of the\ndirectory:\n\n```ocaml\n# #load "unix.cma"\n# open Unix\n# let readdir_no_ex dirh =\n  try\n    Some (readdir dirh)\n  with\n    End_of_file -> None\nval readdir_no_ex : dir_handle -> string option = <fun>\n```\nThe type of `readdir_no_ex` is this. Recall our earlier discussion about\nnull pointers.\n\n```ocaml\n# readdir_no_ex\n- : dir_handle -> string option = <fun>\n```\n\nI\'m also going to define a simple recursive function which I can use to\nconvert the `filesystem` type into a string for (eg) printing:\n\n```ocaml\n# let rec string_of_filesystem fs =\n  match fs with\n  | File filename -> filename ^ "\\n"\n  | Directory fs_list ->\n      List.fold_left (^) "" (List.map string_of_filesystem fs_list)\nval string_of_filesystem : filesystem -> string = <fun>\n```\n\nNote the use of `fold_left` and `map`. The `map` is used to\n(recursively) convert each `filesystem` in the list into a `string`.\nThen the `fold_left (^) ""` concatenates the list together into one big\nstring. Notice also the use of pattern matching. (The library defines a\nfunction called `String.concat` which is essentially equivalent to\n`fold_left (^) `, but implemented more efficiently).\n\nNow let\'s define a function to read a directory structure, recursively,\nand return a recursive `filesystem` data structure. I\'m going to show\nthis function in steps, but I\'ll print out the entire function at the\nend of this section. First the outline of the function:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec read_directory path =\n  let dirh = opendir path in\n  let rec loop () =\n    (* ..... *) in\n  Directory (loop ())\n```\n\nThe call to `opendir` opens up the given path and returns a `dir_handle`\nfrom which we will be able to read the names using `readdir_no_ex`\nlater. The return value of the function is going to be a\n`Directory fs_list`, so all we need to do to complete the function is to\nwrite our function `loop` which returns a list of `filesystem`s. The\ntype of `loop` will be:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nloop : unit -> filesystem list\n```\n\nHow do we define loop? Let\'s take it in steps again.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec loop () =\n  let filename = readdir_no_ex dirh in\n  (* ..... *)\n```\n\nFirst we read the next filename from the directory handle. `filename`\nhas type `string option`, in other words it could be `None` or\n`Some "foo"` where `foo` is the name of the next filename in the\ndirectory. We also need to ignore the `"."` and `".."` files (ie. the\ncurrent directory and the parent directory). We can do all this with a\nnice pattern match:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec loop () =\n  let filename = readdir_no_ex dirh in\n    match filename with\n    | None -> []\n    | Some "." -> loop ()\n    | Some ".." -> loop ()\n    | Some filename ->\n        (* ..... *)\n```\n\nThe `None` case is easy. Thinking recursively (!) if `loop` is called\nand we\'ve reached the end of the directory, `loop` needs to return a\nlist of entries - and there\'s no entries - so it returns the empty list\n(`[]`).\n\nFor `"."` and `".."` we just ignore the file and call `loop` again.\n\nWhat do we do when `loop` reads a real filename (the `Some filename`\nmatch below)? Let `pathname` be the full path to the file. We \'stat\' the\nfile to see if it\'s really a directory. If it *is* a directory, we set\n`this` by recursively calling `read_directory` which will return\n`Directory something`. Notice that the overall result of\n`read_directory` is `Directory (loop ())`. If the file is really a file\n(not a directory) then we let `this` be `File pathname`. Then we do\nsomething clever: we return `this :: loop ()`. This is the recursive\ncall to `loop ()` to calculate the remaining directory members (a list),\nto which we prepend `this`.\n\n```ocaml\n# let rec read_directory path =\n  let dirh = opendir path in\n  let rec loop () =\n    let filename = readdir_no_ex dirh in\n      match filename with\n      | None -> []\n      | Some "." -> loop ()\n      | Some ".." -> loop ()\n      | Some filename ->\n          let pathname = path ^ "/" ^ filename in\n          let stat = lstat pathname in\n          let this =\n            if stat.st_kind = S_DIR then\n              read_directory pathname\n            else\n              File pathname\n          in\n            this :: loop ()\n  in\n    Directory (loop ())\nval read_directory : string -> filesystem = <fun>\n```\n\nThat\'s quite a complex bit of recursion, but although this is a made-up\nexample, it\'s fairly typical of the complex patterns of recursion found\nin real-world functional programs. The two important lessons to take\naway from this are:\n\n* The use of recursion to build a list:\n\n    \x3c!-- $MDX skip --\x3e\n    ```ocaml\n    let rec loop () =\n      a match or if statement\n      | base case -> []\n      | recursive case -> element :: loop ()\n    ```\n    Compare this to our previous `range` function. The pattern of recursion\n    is exactly the same:\n    \n    ```ocaml\n    # let rec range a b =\n      if a > b then []            (* Base case *)\n      else a :: range (a + 1) b     (* Recursive case *)\n    ```\n\t\n* The use of recursion to build up trees:\n\n    \x3c!-- $MDX skip --\x3e\n    ```ocaml\n    let rec read_directory path =\n      (* blah blah *)\n      if file-is-a-directory then\n        read_directory path-to-file\n      else\n        Leaf file\n    ```\n    All that remains now to make this a working program is a little bit of\n    code to call `read_directory` and display the result:\n    \n    \x3c!-- $MDX skip --\x3e\n    ```ocaml\n    let path = Sys.argv.(1) in\n    let fs = read_directory path in\n    print_endline (string_of_filesystem fs)\n    ```\n\n###  Recursion example: maximum element in a list\nRemember the basic recursion pattern for lists:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec loop () =\n  a match or if statement\n  | base case -> []\n  | recursive case -> element :: loop ()\n```\nThe key here is actually the use of the match / base case / recursive\ncase pattern. In this example - finding the maximum element in a list -\nwe\'re going to have two base cases and one recursive case. But before I\njump ahead to the code, let\'s just step back and think about the\nproblem. By thinking about the problem, the solution will appear "as if\nby magic" (I promise you :-)\n\nFirst of all, let\'s be clear that the maximum element of a list is just\nthe biggest one, e.g. the maximum element of the list `[1; 2; 3; 4; 1]`\nis `4`.\n\nAre there any special cases? Yes, there are. What\'s the maximum element\nof the empty list `[]`? There *isn\'t one*. If we are passed an empty\nlist, we should throw an error.\n\nWhat\'s the maximum element of a single element list such as `[4]`?\nThat\'s easy: it\'s just the element itself. So `list_max [4]` should\nreturn `4`, or in the general case, `list_max [x]` should return `x`.\n\nWhat\'s the maximum element of the general list `x :: remainder` (this is\nthe "cons" notation for the list, so `remainder` is the tail - also a\nlist)?\n\nThink about this for a while. Suppose you know the maximum element of\n`remainder`, which is, say, `y`. What\'s the maximum element of\n`x :: remainder`? It depends on whether `x > y` or `x <= y`. If `x` is\nbigger than `y`, then the overall maximum is `x`, whereas conversely if\n`x` is less than `y`, then the overall maximum is `y`.\n\nDoes this really work? Consider `[1; 2; 3; 4; 1]` again. This is\n`1 :: [2; 3; 4; 1]`. Now the maximum element of the remainder,\n`[2; 3; 4; 1]`, is `4`. So now we\'re interested in `x = 1` and `y = 4`.\nThat head element `x = 1` doesn\'t matter because `y = 4` is bigger, so\nthe overall maximum of the whole list is `y = 4`.\n\nLet\'s now code those rules above up, to get a working function:\n\n```ocaml\n# let rec list_max xs =\n  match xs with\n  | [] -> (* empty list: fail *)\n      failwith "list_max called on empty list"\n  | [x] -> (* single element list: return the element *)\n      x\n  | x :: remainder -> (* multiple element list: recursive case *)\n      max x (list_max remainder)\nval list_max : \'a list -> \'a = <fun>\n```\nI\'ve added comments so you can see how the rules / special cases we\ndecided upon above really correspond to lines of code.\n\nDoes it work?\n\n```ocaml\n# list_max [1; 2; 3; 4; 1]\n- : int = 4\n# list_max []\nException: Failure "list_max called on empty list".\n# list_max [5; 4; 3; 2; 1]\n- : int = 5\n# list_max [5; 4; 3; 2; 1; 100]\n- : int = 100\n```\nNotice how the solution proposed is both (a) very different from the\nimperative for-loop solution, and (b) much more closely tied to the\nproblem specification. Functional programmers will tell you that this is\nbecause the functional style is much higher level than the imperative\nstyle, and therefore better and simpler. Whether you believe them is up\nto you. It\'s certainly true that it\'s much simpler to reason logically\nabout the functional version, which is useful if you wanted to formally\nprove that `list_max` is correct ("correct" being the mathematical way\nto say that a program is provably bug-free, useful for space shuttles,\nnuclear power plants and higher quality software in general).\n\n###  Tail recursion\nLet\'s look at the `range` function again for about the twentieth time:\n\n```ocaml\n# let rec range a b =\n  if a > b then []\n  else a :: range (a+1) b\nval range : int -> int -> int list = <fun>\n```\nI\'m going to rewrite it slightly to make something about the structure\nof the program clearer (still the same function however):\n\n```ocaml\n# let rec range a b =\n  if a > b then [] else\n    let result = range (a+1) b in\n      a :: result\nval range : int -> int -> int list = <fun>\n```\nLet\'s call it:\n\n```ocaml\n# List.length (range 1 10)\n- : int = 10\n# List.length (range 1 1000000)\nStack overflow during evaluation (looping recursion?).\n```\nHmmm ... at first sight this looks like a problem with recursive\nprogramming, and hence with the whole of functional programming! If you\nwrite your code recursively instead of iteratively then you necessarily\nrun out of stack space on large inputs, right?\n\nIn fact, wrong. Compilers can perform a simple optimisation on certain\ntypes of recursive functions to turn them into while loops. These\ncertain types of recursive functions therefore run in constant stack\nspace, and with the equivalent efficiency of imperative while loops.\nThese functions are called **tail-recursive functions**.\n\nIn tail-recursive functions, the recursive call happens last of all.\nRemember our `loop ()` functions above? They all had the form:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec loop () =\n  (* do something *)\n  loop ()\n```\nBecause the recursive call to `loop ()` happens as the very last thing,\n`loop` is tail-recursive and the compiler will turn the whole thing into\na while loop.\n\nUnfortunately `range` is not tail-recursive, and the longer version\nabove shows why. The recursive call to `range` doesn\'t happen as the\nvery last thing. In fact the last thing to happen is the `::` (cons)\noperation. As a result, the compiler doesn\'t turn the recursion into a\nwhile loop, and the function is not efficient in its use of stack space.\n\nThe use of an accumulating argument or `accumulator` allows one to write\nfunctions such as `range` above in a tail-recursive manner, which means they\nwill be efficient and work properly on large inputs. Let\'s plan our rewritten\n`range` function which will use an accumulator argument to store the "result so\nfar":\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec range2 a b accum =\n  (* ... *)\n  \nlet range a b =\n  range2 a b []\n```\n\nThe `accum` argument is going to accumulate the result. It\'s the "result\nso far". We pass in the empty list ("no result so far"). The easy case\nis when `a > b`:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec range2 a b accum =\n  if a > b then accum\n  else\n    (* ... *)\n```\nIf `a > b` (i.e. if we\'ve reached the end of the recursion), then stop\nand return the result (`accum`).\n\nNow the trick is to write the `else`-clause and make sure that the call\nto `range2` is the very last thing that we do, so the function is\ntail-recursive:\n\n```ocaml\n# let rec range2 a b accum =\n  if a > b then accum\n  else range2 (a + 1) b (a :: accum)\nval range2 : int -> int -> int list -> int list = <fun>\n```\nThere\'s only one slight problem with this function: it constructs the\nlist backwards! However, this is easy to rectify by redefining range as:\n\n```ocaml\n# let range a b = List.rev (range2 a b [])\nval range : int -> int -> int list = <fun>\n```\nIt works this time, although it\'s a bit slow to run because it really\ndoes have to construct a list with a million elements in it:\n\n```ocaml\n# List.length (range 1 1000000)\n- : int = 1000000\n```\nThe following implementation is twice as fast as the previous one,\nbecause it does not need to reverse a list:\n\n```ocaml\n# let rec range2 a b accum =\n  if b < a then accum\n  else range2 a (b - 1) (b :: accum)\nval range2 : int -> int -> int list -> int list = <fun>\n# let range a b =\n  range2 a b []\nval range : int -> int -> int list = <fun>\n```\nThat was a brief overview of tail recursion, but in real world\nsituations determining if a function is tail recursive can be quite\nhard. What did we really learn here? One thing is that recursive\nfunctions have a dangerous trap for inexperienced programmers. Your\nfunction can appear to work for small inputs (during testing), but fail\ncatastrophically in the field when exposed to large inputs. This is one\nargument *against* using recursive functions, and for using explicit\nwhile loops when possible.\n\n## Mutable records, references (again!) and arrays\nPreviously we mentioned records in passing. These are like C `struct`s:\n\n```ocaml\n# type pair_of_ints = {a : int; b : int}\ntype pair_of_ints = { a : int; b : int; }\n# {a = 3; b = 5}\n- : pair_of_ints = {a = 3; b = 5}\n# {a = 3}\nLine 1, characters 1-8:\nError: Some record fields are undefined: b\n```\n\nOne feature which I didn\'t cover: OCaml records can have mutable fields.\nNormally an expression like `{a = 3; b = 5}` is an immutable, constant\nobject. However if the record has **mutable fields**, then\nthere is a way to change those fields in the record. This is an\nimperative feature of OCaml, because functional languages don\'t normally\nallow mutable objects (or references or mutable arrays, which we\'ll look\nat in a moment).\n\nHere is an object defined with a mutable field. This field is used to\ncount how many times the object has been accessed. You could imagine\nthis being used in a caching scheme to decide which objects you\'d evict\nfrom memory.\n\n```ocaml\n# type name = {name : string; mutable access_count : int}\ntype name = { name : string; mutable access_count : int; }\n```\n\nHere is a function defined on names which prints the `name` field and\nincrements the mutable `access_count` field:\n\n```ocaml\n# let print_name name =\n  print_endline ("The name is " ^ name.name);\n  name.access_count <- name.access_count + 1\nval print_name : name -> unit = <fun>\n```\n\nNotice a strange, and very non-functional feature of `print_name`: it modifies\nits `access_count` parameter. This function is not "pure". OCaml is a\nfunctional language, but not to the extent that it forces functional\nprogramming down your throat.\n\nAnyway, let\'s see `print_name` in action:\n\n```ocaml\n# let n = {name = "Richard Jones"; access_count = 0}\nval n : name = {name = "Richard Jones"; access_count = 0}\n# n\n- : name = {name = "Richard Jones"; access_count = 0}\n# print_name n\nThe name is Richard Jones\n- : unit = ()\n# n\n- : name = {name = "Richard Jones"; access_count = 1}\n# print_name n\nThe name is Richard Jones\n- : unit = ()\n# n\n- : name = {name = "Richard Jones"; access_count = 2}\n```\n\nOnly fields explicitly marked as `mutable` can be assigned to using the\n`<-` operator. If you try to assign to a non-mutable field, OCaml won\'t\nlet you:\n\n```ocaml\n# n.name <- "John Smith"\nLine 1, characters 1-23:\nError: The record field name is not mutable\n```\nReferences, with which we should be familiar by now, are implemented\nusing records with a mutable `contents` field. Check out the definition\nin `Stdlib`:\n\n```ocaml\ntype \'a ref = {mutable contents : \'a}\n```\n\nAnd look closely at what the OCaml toplevel prints out for the value of\na reference:\n\n```ocaml\n# let r = ref 100\nval r : int Stdlib.ref = {Stdlib.contents = 100}\n```\n\nArrays are another sort of mutable structure provided by OCaml. In\nOCaml, plain lists are implemented as linked lists, and linked lists are\nslow for some types of operation. For example, getting the head of a\nlist, or iterating over a list to perform some operation on each element\nis reasonably fast. However, jumping to the n<sup>th</sup> element of a\nlist, or trying to randomly access a list - both are slow operations.\nThe OCaml `Array` type is a real array, so random access is fast, but\ninsertion and deletion of elements is slow. `Array`s are also mutable so\nyou can randomly change elements too.\n\nThe basics of arrays are simple:\n\n```ocaml\n# let a = Array.create 10 0\nLine 1, characters 9-21:\nAlert deprecated: Stdlib.Array.create\nUse Array.make instead.\nval a : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]\n# for i = 0 to Array.length a - 1 do\n  a.(i) <- i\nLine 3, characters 1-3:\nError: Syntax error\n# a\n- : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]\n```\nNotice the syntax for writing arrays: `[| element; element; ... |]`\n\nThe OCaml compiler was designed with heavy numerical processing in mind\n(the sort of thing that FORTRAN is traditionally used for), and so it\ncontains various optimisations specifically for arrays of numbers,\nvectors and matrices. Here is some benchmark code for doing dense matrix\nmultiplication. Notice that it uses for-loops and is generally very\nimperative in style:\n\n```ocaml\n# let size = 30\nval size : int = 30\n\n# let mkmatrix rows cols =\n  let count = ref 1\n  and last_col = cols - 1\n  and m = Array.make_matrix rows cols 0 in\n    for i = 0 to rows - 1 do\n      let mi = m.(i) in\n        for j = 0 to last_col do\n          mi.(j) <- !count;\n          incr count\n        done;\n    done;\n    m\nval mkmatrix : int -> int -> int array array = <fun>\n\n# let rec inner_loop k v m1i m2 j =\n  if k < 0 then v\n  else inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j\nval inner_loop : int -> int -> int array -> int array array -> int -> int =\n  <fun>\n\n# let mmult rows cols m1 m2 m3 =\n  let last_col = cols - 1\n  and last_row = rows - 1 in\n    for i = 0 to last_row do\n      let m1i = m1.(i) and m3i = m3.(i) in\n      for j = 0 to last_col do\n        m3i.(j) <- inner_loop last_row 0 m1i m2 j\n      done;\n    done\nval mmult :\n  int -> int -> int array array -> int array array -> int array array -> unit =\n  <fun>\n\n# let () =\n  let n =\n    try int_of_string Sys.argv.(1)\n    with Invalid_argument _ -> 1\n  and m1 = mkmatrix size size\n  and m2 = mkmatrix size size\n  and m3 = Array.make_matrix size size 0 in\n    for i = 1 to n - 1 do\n      mmult size size m1 m2 m3\n    done;\n    mmult size size m1 m2 m3;\n    Printf.printf "%d %d %d %d\\n" m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)\nException: Failure "int_of_string".\n```\n\n## Mutually recursive functions\nSuppose I want to define two functions which call each other. This is\nactually not a very common thing to do, but it can be useful sometimes.\nHere\'s a contrived example (thanks to Ryan Tarpine): The number 0 is\neven. Other numbers greater than 0 are even if their predecessor is odd.\nHence:\n\n```ocaml\n# let rec even n =\n  match n with\n  | 0 -> true\n  | x -> odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n```\n\nThe code above doesn\'t compile because we haven\'t defined the function\n`odd` yet! That\'s easy though. Zero is not odd, and other numbers\ngreater than 0 are odd if their predecessor is even. So to make this\ncomplete we need that function too:\n\n```ocaml\n# let rec even n =\n  match n with\n  | 0 -> true\n  | x -> odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n# let rec odd n =\n  match n with\n  | 0 -> false\n  | x -> even (x - 1)\nLine 4, characters 10-14:\nError: Unbound value even\n```\n\nThe only problem is... this program doesn\'t compile. In order to compile\nthe `even` function, we already need the definition of `odd`, and to\ncompile `odd` we need the definition of `even`. So swapping the two\ndefinitions around won\'t help either.\n\nThere are no "forward prototypes" (as seen in languages descended\nfrom C) in OCaml but there is a special syntax\nfor defining a set of two or more mutually recursive functions, like\n`odd` and `even`:\n\n```ocaml\n# let rec even n =\n  match n with\n  | 0 -> true\n  | x -> odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n```\nYou can also\nuse similar syntax for writing mutually recursive class definitions and\nmodules.\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#if-statements-actually-these-are-if-expressions">If statements (actually, these are if expressions)</a>\n</li>\n<li><a href="#using-begin--end">Using begin ... end</a>\n</li>\n<li><a href="#for-loops-and-while-loops">For loops and while loops</a>\n</li>\n<li><a href="#looping-over-lists">Looping over lists</a>\n</li>\n<li><a href="#looping-over-strings">Looping over strings</a>\n</li>\n<li><a href="#recursion">Recursion</a>\n</li>\n<li><a href="#mutable-records-references-again-and-arrays">Mutable records, references (again!) and arrays</a>\n</li>\n<li><a href="#mutually-recursive-functions">Mutually recursive functions</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="if-statements-actually-these-are-if-expressions">If statements (actually, these are if expressions)</h2>\n<p>OCaml has an <code>if</code> statement with two variations, and the obvious meaning:</p>\n<pre><code class="language-ocaml">if boolean-condition then expression\n  \nif boolean-condition then expression else other-expression\n</code></pre>\n<pre><code class="language-mdx-error">Line 3, characters 3-5:\nError: Syntax error\n</code></pre>\n<p>Unlike in the conventional languages you\'ll be used to, <code>if</code> statements\nare really expressions. In other words, they\'re much more like\n<code>boolean-condition ? expression : other-expression</code> in C than like the if\nstatements you may be used to.</p>\n<p>Here\'s a simple example of an <code>if</code> statement:</p>\n<pre><code class="language-ocaml"># let max a b =\n  if a &gt; b then a else b\nval max : \'a -&gt; \'a -&gt; \'a = &lt;fun&gt;\n</code></pre>\n<p>As a short aside, if you type this into the OCaml\ninteractive toplevel (as above), you\'ll\nnotice that OCaml decides that this function is polymorphic, with the\nfollowing type:</p>\n<pre><code class="language-ocaml"># max\n- : \'a -&gt; \'a -&gt; \'a = &lt;fun&gt;\n</code></pre>\n<p>And indeed OCaml lets you use <code>max</code> on any type:</p>\n<pre><code class="language-ocaml"># max 3 5\n- : int = 5\n# max 3.5 13.0\n- : float = 13.\n# max &quot;a&quot; &quot;b&quot;\n- : string = &quot;b&quot;\n</code></pre>\n<p>This is because <code>&gt;</code> is in fact polymorphic. It works on any type, even\nobjects (it does a binary comparison).</p>\n<p>[Note that the <code>Stdlib</code> module defines <code>min</code> and <code>max</code> for you.]</p>\n<p>Let\'s look a bit more closely at the <code>if</code> expression. Here\'s the <code>range</code>\nfunction which I showed you earlier without much explanation. You should\nbe able to combine your knowledge of recursive functions, lists and if\nexpressions to see what it does:</p>\n<pre><code class="language-ocaml"># let rec range a b =\n    if a &gt; b then []\n    else a :: range (a + 1) b\nval range : int -&gt; int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Let\'s examine some typical calls to this function. Let\'s start with the\neasy case of <code>a &gt; b</code>. A call to <code>range 11 10</code> returns <code>[]</code> (the empty\nlist) and that\'s it.</p>\n<p>What about calling <code>range 10 10</code>? Since <code>10 &gt; 10</code> is false, the\n<code>else</code>-clause is evaluated, which is: <code>10 :: (range 11 10)</code> (I\'ve added\nthe brackets to make the order of evaluation more clear). We\'ve just\nworked out that <code>range 11 10</code> = <code>[]</code>, so this is: <code>10 :: []</code>. Remember\nour formal description of lists and the <code>::</code> (cons) operator? <code>10 :: []</code>\nis just the same as <code>[10]</code>.</p>\n<p>Let\'s try <code>range 9 10</code>:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">range 9 10\n\u2192 9 :: (range 10 10)\n\u2192 9 :: [10]\n\u2192 [9; 10]\n</code></pre>\n<p>It should be fairly clear that <code>range 1 10</code> evaluates to\n<code>[1; 2; 3; 4; 5; 6; 7; 8; 9; 10]</code>.</p>\n<p>What we\'ve got here is a simple case of recursion. Functional\nprogramming can be said to prefer recursion over loops, but I\'m jumping\nahead of myself. We\'ll discuss recursion more at the end of this\nchapter.</p>\n<p>Back, temporarily, to <code>if</code> statements. What does this function do?</p>\n<pre><code class="language-ocaml"># let f x y =\n    x + if y &gt; 0 then y else 0\nval f : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>Clue: add brackets around the whole of the if expression. It clips <code>y</code>\nlike an <a href="https://en.wikipedia.org/wiki/Diode#Current.E2.80.93voltage_characteristic">electronic diode</a>.</p>\n<p>The <code>abs</code> (absolute value) function is defined in <code>Stdlib</code> as:</p>\n<pre><code class="language-ocaml"># let abs x =\n    if x &gt;= 0 then x else -x\nval abs : int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>Also in <code>Stdlib</code>, the <code>string_of_float</code> function contains a complex\npair of nested <code>if</code> expressions:</p>\n<pre><code class="language-ocaml"># let string_of_float f =\n  let s = format_float &quot;%.12g&quot; f in\n  let l = string_length s in\n  let rec loop i =\n    if i &gt;= l then s ^ &quot;.&quot;\n    else if s.[i] = \'.\' || s.[i] = \'e\' then s\n    else loop (i + 1)\n  in\n    loop 0\nLine 2, characters 11-23:\nError: Unbound value format_float\n</code></pre>\n<p>Let\'s examine this function. Suppose the function is called with <code>f</code> =\n12.34. Then <code>s</code> = &quot;12.34&quot;, and <code>l</code> = 5. We call <code>loop</code> the first time\nwith <code>i</code> = 0.</p>\n<p><code>i</code> is not greater than or equal to <code>l</code>, and <code>s.[i]</code> (the\n<code>i</code><sup>th</sup> character in <code>s</code>) is not a period or <code>\'e\'</code>. So\n<code>loop (i + 1)</code> is called, ie. <code>loop 1</code>.</p>\n<p>We go through the same dance for <code>i</code> = 1, and end up calling <code>loop 2</code>.</p>\n<p>For <code>i</code> = 2, however, <code>s.[i]</code> is a period (refer to the original string,\n<code>s</code> = &quot;12.34&quot;). So this immediately returns <code>s</code>, and the function\n<code>string_of_float</code> returns &quot;12.34&quot;.</p>\n<p>What is <code>loop</code> doing? In fact it\'s checking whether the string returned\nfrom <code>format_float</code> contains a period (or <code>\'e\'</code>). Suppose that we called\n<code>string_of_float</code> with <code>12.0</code>. <code>format_float</code> would return the string\n&quot;12&quot;, but <code>string_of_float</code> must return &quot;12.&quot; or &quot;12.0&quot; (because\nfloating point constants in OCaml must contain a period to differentiate\nthem from integer constants). Hence the check.</p>\n<p>The strange use of recursion in this function is almost certainly for\nefficiency. OCaml supports for loops, so why didn\'t the authors use for\nloops? We\'ll see in the next section that OCaml\'s for loops are limited\nin a way which prevents them from being used in <code>string_of_float</code>. Here,\nhowever, is a more straightforward, but approximately twice as slow, way\nof writing <code>string_of_float</code>:</p>\n<pre><code class="language-ocaml"># let string_of_float f =\n  let s = format_float &quot;%.12g&quot; f in\n    if String.contains s \'.\' || String.contains s \'e\'\n      then s\n      else s ^ &quot;.&quot;\nLine 2, characters 11-23:\nError: Unbound value format_float\n</code></pre>\n<h2 id="using-begin--end">Using begin ... end</h2>\n<p>Here is some code from lablgtk:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">if GtkBase.Object.is_a obj cls then\n  fun _ -&gt; f obj\nelse begin\n  eprintf &quot;Glade-warning: %s expects a %s argument.\\n&quot; name cls;\n  raise Not_found\nend\n</code></pre>\n<p><code>begin</code> and <code>end</code> are what is known as <strong>syntactic sugar</strong> for open and\nclose parentheses. In the example above, all they do is group the two\nstatements in the <code>else</code>-clause together. Suppose the author had written\nthis instead:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">if GtkBase.Object.is_a obj cls then\n  fun _ -&gt; f obj\nelse\n  eprintf &quot;Glade-warning: %s expects a %s argument.\\n&quot; name cls;\n  raise Not_found\n</code></pre>\n<p>Fully bracketing and properly indenting the above expression gives:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">(if GtkBase.Object.is_a obj cls then\n   fun _ -&gt; f obj\n else\n   eprintf &quot;Glade-warning: %s expects a %s argument.\\n&quot; name cls\n);\nraise Not_found\n</code></pre>\n<p>Not what was intended at all. So the <code>begin</code> and <code>end</code> are necessary to\ngroup together multiple statements in a <code>then</code> or <code>else</code> clause of an if\nexpression. You can also use plain ordinary parentheses <code>( ... )</code> if you\nprefer (and I do prefer, because I <strong>loathe</strong> Pascal :-). Here are two\nsimple examples:</p>\n<pre><code class="language-ocaml"># if 1 = 0 then\n    print_endline &quot;THEN&quot;\n  else begin\n    print_endline &quot;ELSE&quot;;\n    failwith &quot;else clause&quot;\n  end\nException: Failure &quot;else clause&quot;.\nELSE\n# if 1 = 0 then\n    print_endline &quot;THEN&quot;\n  else (\n    print_endline &quot;ELSE&quot;;\n    failwith &quot;else clause&quot;\n  )\nException: Failure &quot;else clause&quot;.\nELSE\n</code></pre>\n<h2 id="for-loops-and-while-loops">For loops and while loops</h2>\n<p>OCaml supports a rather limited form of the familiar <code>for</code> loop:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">for variable = start_value to end_value do\n  expression\ndone\n  \nfor variable = start_value downto end_value do\n  expression\ndone\n</code></pre>\n<p>A simple but real example from lablgtk:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">for i = 1 to n_jobs () do\n  do_next_job ()\ndone\n</code></pre>\n<p>In OCaml, <code>for</code> loops are just shorthand for writing:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let i = 1 in\ndo_next_job ();\nlet i = 2 in\ndo_next_job ();\nlet i = 3 in\ndo_next_job ();\n  ...\nlet i = n_jobs () in\ndo_next_job ();\n()\n</code></pre>\n<p>OCaml doesn\'t support the concept of breaking out of a <code>for</code> loop early\ni.e. it has no <code>break</code>, <code>continue</code> or <code>last</code> statements. (You <em>could</em>\nthrow an exception and catch it outside, and this would run fast but\noften looks clumsy.)</p>\n<p>The expression inside an OCaml for loop should evaluate to <code>unit</code>\n(otherwise you\'ll get a warning), and the for loop expression as a whole\nreturns <code>unit</code>:</p>\n<pre><code class="language-ocaml"># for i = 1 to 10 do i done\nLine 1, characters 20-21:\nWarning 10: this expression should have type unit.\n- : unit = ()\n</code></pre>\n<p>Functional programmers tend to use recursion instead of explicit loops,\nand regard <strong>for</strong> loops with suspicion since it can\'t return anything,\nhence OCaml\'s relatively powerless <strong>for</strong> loop. We talk about recursion\nbelow.</p>\n<p><strong>While loops</strong> in OCaml are written:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">while boolean-condition do\n  expression\ndone\n</code></pre>\n<p>As with for loops, there is no way provided by the language to break out\nof a while loop, except by throwing an exception, and this means that\nwhile loops have fairly limited use. Again, remember that functional\nprogrammers like recursion, and so while loops are second-class citizens\nin the language.</p>\n<p>If you stop to consider while loops, you may see that they aren\'t really\nany use at all, except in conjunction with our old friend references.\nLet\'s imagine that OCaml didn\'t have references for a moment:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let quit_loop = false in\n  while not quit_loop do\n    print_string &quot;Have you had enough yet? (y/n) &quot;;\n    let str = read_line () in\n      if str.[0] = \'y\' then\n        (* how do I set quit_loop to true ?!? *)\n  done\n</code></pre>\n<p>Remember that <code>quit_loop</code> is not a real &quot;variable&quot; - the let-binding\njust makes <code>quit_loop</code> a shorthand for <code>false</code>. This means the while\nloop condition (shown in red) is always true, and the loop runs on\nforever!</p>\n<p>Luckily OCaml <em>does have</em> references, so we can write the code above if\nwe want. Don\'t get confused and think that the <code>!</code> (exclamation mark)\nmeans &quot;not&quot; as in C/Java. It\'s used here to mean &quot;dereference the\npointer&quot;, similar in fact to Forth. You\'re better off reading <code>!</code> as\n&quot;get&quot; or &quot;deref&quot;.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let quit_loop = ref false in\n  while not !quit_loop do\n    print_string &quot;Have you had enough yet? (y/n) &quot;;\n    let str = read_line () in\n      if str.[0] = \'y\' then quit_loop := true\n  done;;\n</code></pre>\n<h2 id="looping-over-lists">Looping over lists</h2>\n<p>If you want to loop over a list, don\'t be an imperative programmer and\nreach for your trusty six-shooter Mr. For Loop! OCaml has some better\nand faster ways to loop over lists, and they are all located in the\n<code>List</code> module. There are in fact dozens of good functions in <code>List</code>, but\nI\'ll only talk about the most useful ones here.</p>\n<p>First off, let\'s define a list for us to use:</p>\n<pre><code class="language-ocaml"># let my_list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\nval my_list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n</code></pre>\n<p>If you want to call a function once on every element of the list, use\n<code>List.iter</code>, like this:</p>\n<pre><code class="language-ocaml"># let f elem =\n    Printf.printf &quot;I\'m looking at element %d now\\n&quot; elem\n  in\n    List.iter f my_list\nI\'m looking at element 1 now\nI\'m looking at element 2 now\nI\'m looking at element 3 now\nI\'m looking at element 4 now\nI\'m looking at element 5 now\nI\'m looking at element 6 now\nI\'m looking at element 7 now\nI\'m looking at element 8 now\nI\'m looking at element 9 now\nI\'m looking at element 10 now\n- : unit = ()\n</code></pre>\n<p><code>List.iter</code> is in fact what you should think about using first every\ntime your cerebellum suggests you use a for loop.</p>\n<p>If you want to <em>transform</em> each element separately in the list - for\nexample, doubling each element in the list - then use <code>List.map</code>.</p>\n<pre><code class="language-ocaml"># List.map (( * ) 2) my_list\n- : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]\n</code></pre>\n<p>The function <code>List.filter</code> collects only those elements of a list which satisfy\nsome condition - e.g. returning all even numbers in a list.</p>\n<pre><code class="language-ocaml"># let is_even i =\n    i mod 2 = 0\n  in\n    List.filter is_even my_list\n- : int list = [2; 4; 6; 8; 10]\n</code></pre>\n<p>To find out if a list contains some element, use <code>List.mem</code> (short for\nmember):</p>\n<pre><code class="language-ocaml"># List.mem 12 my_list\n- : bool = false\n</code></pre>\n<p><code>List.for_all</code> and <code>List.exists</code> are the same as the &quot;forall&quot; and\n&quot;exist&quot; operators in predicate logic.</p>\n<p>For operating over two lists at the same time, there are &quot;-2&quot; variants\nof some of these functions, namely <code>iter2</code>, <code>map2</code>, <code>for_all2</code>,\n<code>exists2</code>.</p>\n<p>The <code>map</code> and <code>filter</code> functions operate on individual list elements in\nisolation. <strong>Fold</strong> is a more unusual operation that is best\nthought about as &quot;inserting an operator between each element of the\nlist&quot;. Suppose I wanted to add all the numbers in my list together. In\nhand-waving terms what I want to do is insert a plus sign between the\nelements in my list:</p>\n<pre><code class="language-ocaml"># 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10\n- : int = 55\n</code></pre>\n<p>The fold operation does this, although the exact details are a little\nbit more tricky. First of all, what happens if I try to fold an empty\nlist? In the case of summing the list it would be nice if the answer was\nzero, instead of error. However if I was trying to find the product of\nthe list, I\'d like the answer to be one instead. So I obviously have to\nprovide some sort of &quot;default&quot; argument to my fold. The second issue\ndoesn\'t arise with simple operators like <code>+</code> and <code>*</code>: what happens if\nthe operator I\'m using isn\'t associative, ie. (a <em>op</em> b) <em>op</em> c not\nequal to a <em>op</em> (b <em>op</em> c)? In that case it would matter if I started\nfrom the left hand end of the list and worked right, versus if I started\nfrom the right and worked left. For this reason there are two versions\nof fold, called <code>List.fold_left</code> (works left to right) and\n<code>List.fold_right</code> (works right to left, and is also less efficient).</p>\n<p>Let\'s use <code>List.fold_left</code> to define <code>sum</code> and <code>product</code> functions for\ninteger lists:</p>\n<pre><code class="language-ocaml"># let sum = List.fold_left ( + ) 0\nval sum : int list -&gt; int = &lt;fun&gt;\n# let product = List.fold_left ( * ) 1\nval product : int list -&gt; int = &lt;fun&gt;\n# sum my_list\n- : int = 55\n# product my_list\n- : int = 3628800\n</code></pre>\n<p>That was easy! Notice that I\'ve accidentally come up with a way to do\nmathematical factorials:</p>\n<pre><code class="language-ocaml"># let fact n = product (range 1 n)\nval fact : int -&gt; int = &lt;fun&gt;\n# fact 10\n- : int = 3628800\n</code></pre>\n<p>(Notice that this factorial function isn\'t very useful because it\noverflows the integers and gives wrong answers even for quite small\nvalues of <code>n</code>.)</p>\n<h2 id="looping-over-strings">Looping over strings</h2>\n<p>The <code>String</code> module also contains many dozens of useful string-related\nfunctions, and some of them are concerned with looping over strings.</p>\n<p><code>String.copy</code> copies a string, like <code>strdup</code>. There is also a <code>String.iter</code>\nfunction which works like <code>List.iter</code>, except over the characters of the\nstring.</p>\n<h2 id="recursion">Recursion</h2>\n<p>Now we come to a hard topic - recursion. Functional programmers are\ndefined by their love of recursive functions, and in many ways recursive\nfunctions in f.p. are the equivalent of loops in imperative programming.\nIn functional languages loops are second-class citizens, whilst\nrecursive functions get all the best support.</p>\n<p>Writing recursive functions requires a change in mindset from writing\nfor loops and while loops. So what I\'ll give you in this section will be\njust an introduction and examples.</p>\n<p>In the first example we\'re going to read the whole of a file into memory\n(into a long string). There are essentially three possible approaches to\nthis:</p>\n<h3 id="approach-1">Approach 1</h3>\n<p>Get the length of the file, and read it all in one go using the\n<code>really_input</code> method. This is the simplest, but it might not work on\nchannels which are not really files (eg. reading keyboard input) which\nis why we look at the other two approaches.</p>\n<h3 id="approach-2">Approach 2</h3>\n<p>The imperative approach, using a while loop which is broken out of using\nan exception.</p>\n<h3 id="approach-3">Approach 3</h3>\n<p>A recursive loop, breaking out of the recursion again using an\nexception.</p>\n<p>We\'re going to introduce a few new concepts here. Our second two\napproaches will use the <code>Buffer</code> module - an expandable buffer which you\ncan think of like a string onto which you can efficiently append more\ntext at the end. We\'re also going to be catching the <code>End_of_file</code>\nexception which the input functions throw when they reach the end of the\ninput. Also we\'re going to use <code>Sys.argv.(1)</code> to get the first command\nline parameter.</p>\n<pre><code class="language-ocaml">(* Read whole file: Approach 1 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let len = in_channel_length chan in\n  let result = (Bytes.create len) in\n    really_input chan result 0 len;\n    (Bytes.to_string result)\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n    printf &quot;I read %d characters from %s\\n&quot; (String.length str) filename\n</code></pre>\n<p>Approach 1 works but is not very satisfactory because <code>read_whole_chan</code>\nwon\'t work on non-file channels like keyboard input or sockets. Approach\n2 involves a while loop:</p>\n<pre><code class="language-ocaml">(* Read whole file: Approach 2 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let buf = Buffer.create 4096 in\n  try\n    while true do\n      let line = input_line chan in\n        Buffer.add_string buf line;\n        Buffer.add_char buf \'\\n\'\n    done;\n    assert false (* This is never executed\n\t                (always raises Assert_failure). *)\n  with\n    End_of_file -&gt; Buffer.contents buf\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n    printf &quot;I read %d characters from %s\\n&quot; (String.length str) filename\n</code></pre>\n<p>The key to approach 2 is to look at the central while loop. Remember\nthat I said the only way to break out of a while loop early was with an\nexception? This is exactly what we\'re doing here. Although I haven\'t\ncovered exceptions yet, you probably won\'t have any trouble\nunderstanding the <code>End_of_file</code> exception thrown in the code above by\n<code>input_line</code> when it hits the end of the file. The buffer <code>buf</code>\naccumulates the contents of the file, and when we hit the end of the\nfile we return it (<code>Buffer.contents buf</code>).</p>\n<p>One curious point about this is the apparently superfluous statement\n(<code>assert false</code>) just after the while loop. What is it for?  Remember\nthat while loops, like for loops, are just expressions, and they return\nthe <code>unit</code> object (<code>()</code>). However OCaml demands that the return type\ninside a <code>try</code> matches the return type of each caught exception. In this\ncase because <code>End_of_file</code> results in a <code>string</code>, the main body of the\n<code>try</code> must also &quot;return&quot; a string \u2014 even though because of the infinite\nwhile loop the string could never actually be returned.  <code>assert false</code>\nhas a polymorphic type, so will unify with whatever value is returned\nby the <code>with</code> branch.</p>\n<p>Here\'s our recursive version. Notice that it\'s <em>shorter</em> than approach\n2, but not so easy to understand for imperative programmers at least:</p>\n<pre><code class="language-ocaml">(* Read whole file: Approach 3 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let buf = Buffer.create 4096 in\n  let rec loop () =\n    let line = input_line chan in\n      Buffer.add_string buf line;\n      Buffer.add_char buf \'\\n\';\n      loop ()\n  in\n    try loop () with\n      End_of_file -&gt; Buffer.contents buf\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n  printf &quot;I read %d characters from %s\\n&quot; (String.length str) filename\n</code></pre>\n<p>Again we have an infinite loop - but in this case done using recursion.\n<code>loop</code> calls itself at the end of the function. The infinite recursion\nis broken when <code>input_line</code> throws an <code>End_of_file</code> exception.</p>\n<p>It looks like approach 3 might overflow the stack if you gave it a\nparticularly large file, but this is in fact not the case. Because of\ntail recursion (discussed below) the compiler will turn the recursive\n<code>loop</code> function into a real while loop (!) which runs in constant stack\nspace.</p>\n<p>In the next example we will show how recursion is great for constructing\nor examining certain types of data structures, particularly trees. Let\'s\nhave a recursive type to represent files in a filesystem:</p>\n<pre><code class="language-ocaml"># type filesystem = File of string | Directory of filesystem list\ntype filesystem = File of string | Directory of filesystem list\n</code></pre>\n<p>The <code>opendir</code> and <code>readdir</code> functions are used to open a directory and\nread elements from the directory. I\'m going to define a handy\n<code>readdir_no_ex</code> function which hides the annoying <code>End_of_file</code>\nexception that <code>readdir</code> throws when it reaches the end of the\ndirectory:</p>\n<pre><code class="language-ocaml"># #load &quot;unix.cma&quot;\n# open Unix\n# let readdir_no_ex dirh =\n  try\n    Some (readdir dirh)\n  with\n    End_of_file -&gt; None\nval readdir_no_ex : dir_handle -&gt; string option = &lt;fun&gt;\n</code></pre>\n<p>The type of <code>readdir_no_ex</code> is this. Recall our earlier discussion about\nnull pointers.</p>\n<pre><code class="language-ocaml"># readdir_no_ex\n- : dir_handle -&gt; string option = &lt;fun&gt;\n</code></pre>\n<p>I\'m also going to define a simple recursive function which I can use to\nconvert the <code>filesystem</code> type into a string for (eg) printing:</p>\n<pre><code class="language-ocaml"># let rec string_of_filesystem fs =\n  match fs with\n  | File filename -&gt; filename ^ &quot;\\n&quot;\n  | Directory fs_list -&gt;\n      List.fold_left (^) &quot;&quot; (List.map string_of_filesystem fs_list)\nval string_of_filesystem : filesystem -&gt; string = &lt;fun&gt;\n</code></pre>\n<p>Note the use of <code>fold_left</code> and <code>map</code>. The <code>map</code> is used to\n(recursively) convert each <code>filesystem</code> in the list into a <code>string</code>.\nThen the <code>fold_left (^) &quot;&quot;</code> concatenates the list together into one big\nstring. Notice also the use of pattern matching. (The library defines a\nfunction called <code>String.concat</code> which is essentially equivalent to\n<code>fold_left (^) </code>, but implemented more efficiently).</p>\n<p>Now let\'s define a function to read a directory structure, recursively,\nand return a recursive <code>filesystem</code> data structure. I\'m going to show\nthis function in steps, but I\'ll print out the entire function at the\nend of this section. First the outline of the function:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec read_directory path =\n  let dirh = opendir path in\n  let rec loop () =\n    (* ..... *) in\n  Directory (loop ())\n</code></pre>\n<p>The call to <code>opendir</code> opens up the given path and returns a <code>dir_handle</code>\nfrom which we will be able to read the names using <code>readdir_no_ex</code>\nlater. The return value of the function is going to be a\n<code>Directory fs_list</code>, so all we need to do to complete the function is to\nwrite our function <code>loop</code> which returns a list of <code>filesystem</code>s. The\ntype of <code>loop</code> will be:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">loop : unit -&gt; filesystem list\n</code></pre>\n<p>How do we define loop? Let\'s take it in steps again.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec loop () =\n  let filename = readdir_no_ex dirh in\n  (* ..... *)\n</code></pre>\n<p>First we read the next filename from the directory handle. <code>filename</code>\nhas type <code>string option</code>, in other words it could be <code>None</code> or\n<code>Some &quot;foo&quot;</code> where <code>foo</code> is the name of the next filename in the\ndirectory. We also need to ignore the <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> files (ie. the\ncurrent directory and the parent directory). We can do all this with a\nnice pattern match:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec loop () =\n  let filename = readdir_no_ex dirh in\n    match filename with\n    | None -&gt; []\n    | Some &quot;.&quot; -&gt; loop ()\n    | Some &quot;..&quot; -&gt; loop ()\n    | Some filename -&gt;\n        (* ..... *)\n</code></pre>\n<p>The <code>None</code> case is easy. Thinking recursively (!) if <code>loop</code> is called\nand we\'ve reached the end of the directory, <code>loop</code> needs to return a\nlist of entries - and there\'s no entries - so it returns the empty list\n(<code>[]</code>).</p>\n<p>For <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> we just ignore the file and call <code>loop</code> again.</p>\n<p>What do we do when <code>loop</code> reads a real filename (the <code>Some filename</code>\nmatch below)? Let <code>pathname</code> be the full path to the file. We \'stat\' the\nfile to see if it\'s really a directory. If it <em>is</em> a directory, we set\n<code>this</code> by recursively calling <code>read_directory</code> which will return\n<code>Directory something</code>. Notice that the overall result of\n<code>read_directory</code> is <code>Directory (loop ())</code>. If the file is really a file\n(not a directory) then we let <code>this</code> be <code>File pathname</code>. Then we do\nsomething clever: we return <code>this :: loop ()</code>. This is the recursive\ncall to <code>loop ()</code> to calculate the remaining directory members (a list),\nto which we prepend <code>this</code>.</p>\n<pre><code class="language-ocaml"># let rec read_directory path =\n  let dirh = opendir path in\n  let rec loop () =\n    let filename = readdir_no_ex dirh in\n      match filename with\n      | None -&gt; []\n      | Some &quot;.&quot; -&gt; loop ()\n      | Some &quot;..&quot; -&gt; loop ()\n      | Some filename -&gt;\n          let pathname = path ^ &quot;/&quot; ^ filename in\n          let stat = lstat pathname in\n          let this =\n            if stat.st_kind = S_DIR then\n              read_directory pathname\n            else\n              File pathname\n          in\n            this :: loop ()\n  in\n    Directory (loop ())\nval read_directory : string -&gt; filesystem = &lt;fun&gt;\n</code></pre>\n<p>That\'s quite a complex bit of recursion, but although this is a made-up\nexample, it\'s fairly typical of the complex patterns of recursion found\nin real-world functional programs. The two important lessons to take\naway from this are:</p>\n<ul>\n<li>\n<p>The use of recursion to build a list:</p>\n  \x3c!-- $MDX skip --\x3e\n  ```ocaml\n  let rec loop () =\n    a match or if statement\n    | base case -> []\n    | recursive case -> element :: loop ()\n  ```\n  Compare this to our previous `range` function. The pattern of recursion\n  is exactly the same:\n    \n  ```ocaml\n  # let rec range a b =\n    if a > b then []            (* Base case *)\n    else a :: range (a + 1) b     (* Recursive case *)\n  ```\n\t\n</li>\n<li>\n<p>The use of recursion to build up trees:</p>\n  \x3c!-- $MDX skip --\x3e\n  ```ocaml\n  let rec read_directory path =\n    (* blah blah *)\n    if file-is-a-directory then\n      read_directory path-to-file\n    else\n      Leaf file\n  ```\n  All that remains now to make this a working program is a little bit of\n  code to call `read_directory` and display the result:\n    \n  \x3c!-- $MDX skip --\x3e\n  ```ocaml\n  let path = Sys.argv.(1) in\n  let fs = read_directory path in\n  print_endline (string_of_filesystem fs)\n  ```\n\n</li>\n</ul>\n<h3 id="recursion-example-maximum-element-in-a-list">Recursion example: maximum element in a list</h3>\n<p>Remember the basic recursion pattern for lists:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec loop () =\n  a match or if statement\n  | base case -&gt; []\n  | recursive case -&gt; element :: loop ()\n</code></pre>\n<p>The key here is actually the use of the match / base case / recursive\ncase pattern. In this example - finding the maximum element in a list -\nwe\'re going to have two base cases and one recursive case. But before I\njump ahead to the code, let\'s just step back and think about the\nproblem. By thinking about the problem, the solution will appear &quot;as if\nby magic&quot; (I promise you :-)</p>\n<p>First of all, let\'s be clear that the maximum element of a list is just\nthe biggest one, e.g. the maximum element of the list <code>[1; 2; 3; 4; 1]</code>\nis <code>4</code>.</p>\n<p>Are there any special cases? Yes, there are. What\'s the maximum element\nof the empty list <code>[]</code>? There <em>isn\'t one</em>. If we are passed an empty\nlist, we should throw an error.</p>\n<p>What\'s the maximum element of a single element list such as <code>[4]</code>?\nThat\'s easy: it\'s just the element itself. So <code>list_max [4]</code> should\nreturn <code>4</code>, or in the general case, <code>list_max [x]</code> should return <code>x</code>.</p>\n<p>What\'s the maximum element of the general list <code>x :: remainder</code> (this is\nthe &quot;cons&quot; notation for the list, so <code>remainder</code> is the tail - also a\nlist)?</p>\n<p>Think about this for a while. Suppose you know the maximum element of\n<code>remainder</code>, which is, say, <code>y</code>. What\'s the maximum element of\n<code>x :: remainder</code>? It depends on whether <code>x &gt; y</code> or <code>x &lt;= y</code>. If <code>x</code> is\nbigger than <code>y</code>, then the overall maximum is <code>x</code>, whereas conversely if\n<code>x</code> is less than <code>y</code>, then the overall maximum is <code>y</code>.</p>\n<p>Does this really work? Consider <code>[1; 2; 3; 4; 1]</code> again. This is\n<code>1 :: [2; 3; 4; 1]</code>. Now the maximum element of the remainder,\n<code>[2; 3; 4; 1]</code>, is <code>4</code>. So now we\'re interested in <code>x = 1</code> and <code>y = 4</code>.\nThat head element <code>x = 1</code> doesn\'t matter because <code>y = 4</code> is bigger, so\nthe overall maximum of the whole list is <code>y = 4</code>.</p>\n<p>Let\'s now code those rules above up, to get a working function:</p>\n<pre><code class="language-ocaml"># let rec list_max xs =\n  match xs with\n  | [] -&gt; (* empty list: fail *)\n      failwith &quot;list_max called on empty list&quot;\n  | [x] -&gt; (* single element list: return the element *)\n      x\n  | x :: remainder -&gt; (* multiple element list: recursive case *)\n      max x (list_max remainder)\nval list_max : \'a list -&gt; \'a = &lt;fun&gt;\n</code></pre>\n<p>I\'ve added comments so you can see how the rules / special cases we\ndecided upon above really correspond to lines of code.</p>\n<p>Does it work?</p>\n<pre><code class="language-ocaml"># list_max [1; 2; 3; 4; 1]\n- : int = 4\n# list_max []\nException: Failure &quot;list_max called on empty list&quot;.\n# list_max [5; 4; 3; 2; 1]\n- : int = 5\n# list_max [5; 4; 3; 2; 1; 100]\n- : int = 100\n</code></pre>\n<p>Notice how the solution proposed is both (a) very different from the\nimperative for-loop solution, and (b) much more closely tied to the\nproblem specification. Functional programmers will tell you that this is\nbecause the functional style is much higher level than the imperative\nstyle, and therefore better and simpler. Whether you believe them is up\nto you. It\'s certainly true that it\'s much simpler to reason logically\nabout the functional version, which is useful if you wanted to formally\nprove that <code>list_max</code> is correct (&quot;correct&quot; being the mathematical way\nto say that a program is provably bug-free, useful for space shuttles,\nnuclear power plants and higher quality software in general).</p>\n<h3 id="tail-recursion">Tail recursion</h3>\n<p>Let\'s look at the <code>range</code> function again for about the twentieth time:</p>\n<pre><code class="language-ocaml"># let rec range a b =\n  if a &gt; b then []\n  else a :: range (a+1) b\nval range : int -&gt; int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>I\'m going to rewrite it slightly to make something about the structure\nof the program clearer (still the same function however):</p>\n<pre><code class="language-ocaml"># let rec range a b =\n  if a &gt; b then [] else\n    let result = range (a+1) b in\n      a :: result\nval range : int -&gt; int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Let\'s call it:</p>\n<pre><code class="language-ocaml"># List.length (range 1 10)\n- : int = 10\n# List.length (range 1 1000000)\nStack overflow during evaluation (looping recursion?).\n</code></pre>\n<p>Hmmm ... at first sight this looks like a problem with recursive\nprogramming, and hence with the whole of functional programming! If you\nwrite your code recursively instead of iteratively then you necessarily\nrun out of stack space on large inputs, right?</p>\n<p>In fact, wrong. Compilers can perform a simple optimisation on certain\ntypes of recursive functions to turn them into while loops. These\ncertain types of recursive functions therefore run in constant stack\nspace, and with the equivalent efficiency of imperative while loops.\nThese functions are called <strong>tail-recursive functions</strong>.</p>\n<p>In tail-recursive functions, the recursive call happens last of all.\nRemember our <code>loop ()</code> functions above? They all had the form:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec loop () =\n  (* do something *)\n  loop ()\n</code></pre>\n<p>Because the recursive call to <code>loop ()</code> happens as the very last thing,\n<code>loop</code> is tail-recursive and the compiler will turn the whole thing into\na while loop.</p>\n<p>Unfortunately <code>range</code> is not tail-recursive, and the longer version\nabove shows why. The recursive call to <code>range</code> doesn\'t happen as the\nvery last thing. In fact the last thing to happen is the <code>::</code> (cons)\noperation. As a result, the compiler doesn\'t turn the recursion into a\nwhile loop, and the function is not efficient in its use of stack space.</p>\n<p>The use of an accumulating argument or <code>accumulator</code> allows one to write\nfunctions such as <code>range</code> above in a tail-recursive manner, which means they\nwill be efficient and work properly on large inputs. Let\'s plan our rewritten\n<code>range</code> function which will use an accumulator argument to store the &quot;result so\nfar&quot;:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec range2 a b accum =\n  (* ... *)\n  \nlet range a b =\n  range2 a b []\n</code></pre>\n<p>The <code>accum</code> argument is going to accumulate the result. It\'s the &quot;result\nso far&quot;. We pass in the empty list (&quot;no result so far&quot;). The easy case\nis when <code>a &gt; b</code>:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec range2 a b accum =\n  if a &gt; b then accum\n  else\n    (* ... *)\n</code></pre>\n<p>If <code>a &gt; b</code> (i.e. if we\'ve reached the end of the recursion), then stop\nand return the result (<code>accum</code>).</p>\n<p>Now the trick is to write the <code>else</code>-clause and make sure that the call\nto <code>range2</code> is the very last thing that we do, so the function is\ntail-recursive:</p>\n<pre><code class="language-ocaml"># let rec range2 a b accum =\n  if a &gt; b then accum\n  else range2 (a + 1) b (a :: accum)\nval range2 : int -&gt; int -&gt; int list -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>There\'s only one slight problem with this function: it constructs the\nlist backwards! However, this is easy to rectify by redefining range as:</p>\n<pre><code class="language-ocaml"># let range a b = List.rev (range2 a b [])\nval range : int -&gt; int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>It works this time, although it\'s a bit slow to run because it really\ndoes have to construct a list with a million elements in it:</p>\n<pre><code class="language-ocaml"># List.length (range 1 1000000)\n- : int = 1000000\n</code></pre>\n<p>The following implementation is twice as fast as the previous one,\nbecause it does not need to reverse a list:</p>\n<pre><code class="language-ocaml"># let rec range2 a b accum =\n  if b &lt; a then accum\n  else range2 a (b - 1) (b :: accum)\nval range2 : int -&gt; int -&gt; int list -&gt; int list = &lt;fun&gt;\n# let range a b =\n  range2 a b []\nval range : int -&gt; int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>That was a brief overview of tail recursion, but in real world\nsituations determining if a function is tail recursive can be quite\nhard. What did we really learn here? One thing is that recursive\nfunctions have a dangerous trap for inexperienced programmers. Your\nfunction can appear to work for small inputs (during testing), but fail\ncatastrophically in the field when exposed to large inputs. This is one\nargument <em>against</em> using recursive functions, and for using explicit\nwhile loops when possible.</p>\n<h2 id="mutable-records-references-again-and-arrays">Mutable records, references (again!) and arrays</h2>\n<p>Previously we mentioned records in passing. These are like C <code>struct</code>s:</p>\n<pre><code class="language-ocaml"># type pair_of_ints = {a : int; b : int}\ntype pair_of_ints = { a : int; b : int; }\n# {a = 3; b = 5}\n- : pair_of_ints = {a = 3; b = 5}\n# {a = 3}\nLine 1, characters 1-8:\nError: Some record fields are undefined: b\n</code></pre>\n<p>One feature which I didn\'t cover: OCaml records can have mutable fields.\nNormally an expression like <code>{a = 3; b = 5}</code> is an immutable, constant\nobject. However if the record has <strong>mutable fields</strong>, then\nthere is a way to change those fields in the record. This is an\nimperative feature of OCaml, because functional languages don\'t normally\nallow mutable objects (or references or mutable arrays, which we\'ll look\nat in a moment).</p>\n<p>Here is an object defined with a mutable field. This field is used to\ncount how many times the object has been accessed. You could imagine\nthis being used in a caching scheme to decide which objects you\'d evict\nfrom memory.</p>\n<pre><code class="language-ocaml"># type name = {name : string; mutable access_count : int}\ntype name = { name : string; mutable access_count : int; }\n</code></pre>\n<p>Here is a function defined on names which prints the <code>name</code> field and\nincrements the mutable <code>access_count</code> field:</p>\n<pre><code class="language-ocaml"># let print_name name =\n  print_endline (&quot;The name is &quot; ^ name.name);\n  name.access_count &lt;- name.access_count + 1\nval print_name : name -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>Notice a strange, and very non-functional feature of <code>print_name</code>: it modifies\nits <code>access_count</code> parameter. This function is not &quot;pure&quot;. OCaml is a\nfunctional language, but not to the extent that it forces functional\nprogramming down your throat.</p>\n<p>Anyway, let\'s see <code>print_name</code> in action:</p>\n<pre><code class="language-ocaml"># let n = {name = &quot;Richard Jones&quot;; access_count = 0}\nval n : name = {name = &quot;Richard Jones&quot;; access_count = 0}\n# n\n- : name = {name = &quot;Richard Jones&quot;; access_count = 0}\n# print_name n\nThe name is Richard Jones\n- : unit = ()\n# n\n- : name = {name = &quot;Richard Jones&quot;; access_count = 1}\n# print_name n\nThe name is Richard Jones\n- : unit = ()\n# n\n- : name = {name = &quot;Richard Jones&quot;; access_count = 2}\n</code></pre>\n<p>Only fields explicitly marked as <code>mutable</code> can be assigned to using the\n<code>&lt;-</code> operator. If you try to assign to a non-mutable field, OCaml won\'t\nlet you:</p>\n<pre><code class="language-ocaml"># n.name &lt;- &quot;John Smith&quot;\nLine 1, characters 1-23:\nError: The record field name is not mutable\n</code></pre>\n<p>References, with which we should be familiar by now, are implemented\nusing records with a mutable <code>contents</code> field. Check out the definition\nin <code>Stdlib</code>:</p>\n<pre><code class="language-ocaml">type \'a ref = {mutable contents : \'a}\n</code></pre>\n<p>And look closely at what the OCaml toplevel prints out for the value of\na reference:</p>\n<pre><code class="language-ocaml"># let r = ref 100\nval r : int Stdlib.ref = {Stdlib.contents = 100}\n</code></pre>\n<p>Arrays are another sort of mutable structure provided by OCaml. In\nOCaml, plain lists are implemented as linked lists, and linked lists are\nslow for some types of operation. For example, getting the head of a\nlist, or iterating over a list to perform some operation on each element\nis reasonably fast. However, jumping to the n<sup>th</sup> element of a\nlist, or trying to randomly access a list - both are slow operations.\nThe OCaml <code>Array</code> type is a real array, so random access is fast, but\ninsertion and deletion of elements is slow. <code>Array</code>s are also mutable so\nyou can randomly change elements too.</p>\n<p>The basics of arrays are simple:</p>\n<pre><code class="language-ocaml"># let a = Array.create 10 0\nLine 1, characters 9-21:\nAlert deprecated: Stdlib.Array.create\nUse Array.make instead.\nval a : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]\n# for i = 0 to Array.length a - 1 do\n  a.(i) &lt;- i\nLine 3, characters 1-3:\nError: Syntax error\n# a\n- : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]\n</code></pre>\n<p>Notice the syntax for writing arrays: <code>[| element; element; ... |]</code></p>\n<p>The OCaml compiler was designed with heavy numerical processing in mind\n(the sort of thing that FORTRAN is traditionally used for), and so it\ncontains various optimisations specifically for arrays of numbers,\nvectors and matrices. Here is some benchmark code for doing dense matrix\nmultiplication. Notice that it uses for-loops and is generally very\nimperative in style:</p>\n<pre><code class="language-ocaml"># let size = 30\nval size : int = 30\n\n# let mkmatrix rows cols =\n  let count = ref 1\n  and last_col = cols - 1\n  and m = Array.make_matrix rows cols 0 in\n    for i = 0 to rows - 1 do\n      let mi = m.(i) in\n        for j = 0 to last_col do\n          mi.(j) &lt;- !count;\n          incr count\n        done;\n    done;\n    m\nval mkmatrix : int -&gt; int -&gt; int array array = &lt;fun&gt;\n\n# let rec inner_loop k v m1i m2 j =\n  if k &lt; 0 then v\n  else inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j\nval inner_loop : int -&gt; int -&gt; int array -&gt; int array array -&gt; int -&gt; int =\n  &lt;fun&gt;\n\n# let mmult rows cols m1 m2 m3 =\n  let last_col = cols - 1\n  and last_row = rows - 1 in\n    for i = 0 to last_row do\n      let m1i = m1.(i) and m3i = m3.(i) in\n      for j = 0 to last_col do\n        m3i.(j) &lt;- inner_loop last_row 0 m1i m2 j\n      done;\n    done\nval mmult :\n  int -&gt; int -&gt; int array array -&gt; int array array -&gt; int array array -&gt; unit =\n  &lt;fun&gt;\n\n# let () =\n  let n =\n    try int_of_string Sys.argv.(1)\n    with Invalid_argument _ -&gt; 1\n  and m1 = mkmatrix size size\n  and m2 = mkmatrix size size\n  and m3 = Array.make_matrix size size 0 in\n    for i = 1 to n - 1 do\n      mmult size size m1 m2 m3\n    done;\n    mmult size size m1 m2 m3;\n    Printf.printf &quot;%d %d %d %d\\n&quot; m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)\nException: Failure &quot;int_of_string&quot;.\n</code></pre>\n<h2 id="mutually-recursive-functions">Mutually recursive functions</h2>\n<p>Suppose I want to define two functions which call each other. This is\nactually not a very common thing to do, but it can be useful sometimes.\nHere\'s a contrived example (thanks to Ryan Tarpine): The number 0 is\neven. Other numbers greater than 0 are even if their predecessor is odd.\nHence:</p>\n<pre><code class="language-ocaml"># let rec even n =\n  match n with\n  | 0 -&gt; true\n  | x -&gt; odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n</code></pre>\n<p>The code above doesn\'t compile because we haven\'t defined the function\n<code>odd</code> yet! That\'s easy though. Zero is not odd, and other numbers\ngreater than 0 are odd if their predecessor is even. So to make this\ncomplete we need that function too:</p>\n<pre><code class="language-ocaml"># let rec even n =\n  match n with\n  | 0 -&gt; true\n  | x -&gt; odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n# let rec odd n =\n  match n with\n  | 0 -&gt; false\n  | x -&gt; even (x - 1)\nLine 4, characters 10-14:\nError: Unbound value even\n</code></pre>\n<p>The only problem is... this program doesn\'t compile. In order to compile\nthe <code>even</code> function, we already need the definition of <code>odd</code>, and to\ncompile <code>odd</code> we need the definition of <code>even</code>. So swapping the two\ndefinitions around won\'t help either.</p>\n<p>There are no &quot;forward prototypes&quot; (as seen in languages descended\nfrom C) in OCaml but there is a special syntax\nfor defining a set of two or more mutually recursive functions, like\n<code>odd</code> and <code>even</code>:</p>\n<pre><code class="language-ocaml"># let rec even n =\n  match n with\n  | 0 -&gt; true\n  | x -&gt; odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n</code></pre>\n<p>You can also\nuse similar syntax for writing mutually recursive class definitions and\nmodules.</p>\n'},tl:{hd:{title:"Modules",slug:"modules",description:"Learn about OCaml modules and how they can be used to cleanly separate distinct parts of your program\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"language",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:"\n## Basic usage\n\nIn OCaml, every piece of code is wrapped into a module. Optionally, a module\nitself can be a submodule of another module, pretty much like directories in a\nfile system - but we don't do this very often.\n\nWhen you write a program let's say using two files `amodule.ml` and\n`bmodule.ml`, each of these files automatically defines a module named\n`Amodule` and a module named `Bmodule` that provide whatever you put into the\nfiles.\n\nHere is the code that we have in our file `amodule.ml`:\n\n\x3c!-- $MDX file=examples/amodule.ml --\x3e\n```ocaml\nlet hello () = print_endline \"Hello\"\n```\n\nAnd here is what we have in `bmodule.ml`:\n\n\x3c!-- $MDX file=examples/bmodule.ml --\x3e\n```ocaml\nlet () = Amodule.hello ()\n```\n\nWe can compile the files in one command:\n\n\x3c!-- $MDX dir=examples --\x3e\n```sh\n$ ocamlopt -o hello amodule.ml bmodule.ml\n```\n\nOr, as a build system might do, one by one:\n\n\x3c!-- $MDX dir=examples --\x3e\n```sh\n$ ocamlopt -c amodule.ml\n$ ocamlopt -c bmodule.ml\n$ ocamlopt -o hello amodule.cmx bmodule.cmx\n```\n\nNow we have an executable that prints \"Hello\". As you can see, if you want to\naccess anything from a given module, use the name of the module (always\nstarting with a capital) followed by a dot and the thing that you want to use.\nIt may be a value, a type constructor, or anything else that a given module can\nprovide.\n\nLibraries, starting with the standard library, provide collections of modules.\nfor example, `List.iter` designates the `iter` function from the `List` module.\n\nIf you are using a given module heavily, you may want to make its contents\ndirectly accessible. For this, we use the `open` directive. In our example,\n`bmodule.ml` could have been written:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nopen Amodule\nlet () = hello ()\n```\n\nUsing `open` or not is a matter of personal taste. Some modules provide names\nthat are used in many other modules. This is the case of the `List` module for\ninstance. Usually, we don't do `open List`. Other modules like `Printf` provide\nnames that are normally not subject to conflicts, such as `printf`. In order to\navoid writing `Printf.printf` all over the place, it often makes sense to place\none `open Printf` at the beginning of the file:\n\n```ocaml\nopen Printf\nlet data = [\"a\"; \"beautiful\"; \"day\"]\nlet () = List.iter (printf \"%s\\n\") data\n```\n\nThere are also local `open`s:\n\n```ocaml\n# let map_3d_matrix f m =\n  let open Array in\n    map (map (map f)) m\nval map_3d_matrix :\n  ('a -> 'b) -> 'a array array array -> 'b array array array = <fun>\n# let map_3d_matrix' f =\n  Array.(map (map (map f)))\nval map_3d_matrix' :\n  ('a -> 'b) -> 'a array array array -> 'b array array array = <fun>\n```\n\n## Interfaces and signatures\n\nA module can provide a certain number of things (functions, types, submodules,\n...) to the rest of the program that is using it. If nothing special is done,\neverything which is defined in a module will be accessible from the outside. That's\noften fine in small personal programs, but there are many situations where it\nis better that a module only provides what it is meant to provide, not any of\nthe auxiliary functions and types that are used internally.\n\nFor this, we have to define a module interface, which will act as a mask over\nthe module's implementation. Just like a module derives from a .ml file, the\ncorresponding module interface or signature derives from an .mli file. It\ncontains a list of values with their type. Let's rewrite our `amodule.ml` file\nto something called `amodule2.ml`:\n\n\x3c!-- $MDX file=examples/amodule2.ml --\x3e\n```ocaml\nlet hello () = print_endline \"Hello\"\n```\n\nAs it is, `Amodule` has the following interface:\n\n```ocaml\nval message : string\n\nval hello : unit -> unit\n```\n```mdx-error\nLine 1, characters 1-21:\nError: Value declarations are only allowed in signatures\n```\n\nLet's assume that accessing the `message` value directly is none of the others\nmodules' business. We want to hide it by defining a restricted interface. This\nis our `amodule2.mli` file:\n\n\x3c!-- $MDX file=examples/amodule2.mli --\x3e\n```ocaml\nval hello : unit -> unit\n(** Displays a greeting message. *)\n```\n\n(note the double asterisk at the beginning of the comment - it is a good habit\nto document .mli files using the format supported by\n[ocamldoc](/releases/{{! get LATEST_OCAML_VERSION_MAIN !}}/htmlman/ocamldoc.html))\n\nSuch .mli files must be compiled just before the matching .ml files. They are\ncompiled using `ocamlc`, even if .ml files are compiled to native code using\n`ocamlopt`:\n\n\x3c!-- $MDX dir=examples --\x3e\n```sh\n$ ocamlc -c amodule2.mli\n$ ocamlopt -c amodule2.ml\n```\n\n## Abstract types\n\nWhat about type definitions? We saw that values such as functions can be\nexported by placing their name and their type in a .mli file, e.g.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nval hello : unit -> unit\n```\n\nBut modules often define new types. Let's define a simple record type that\nwould represent a date:\n\n```ocaml\ntype date = {day : int; month : int; year : int}\n```\n\nThere are four options when it comes to writing the .mli file:\n\n1. The type is completely omitted from the signature.\n1. The type definition is copy-pasted into the signature.\n1. The type is made abstract: only its name is given.\n1. The record fields are made read-only: `type date = private { ... }`\n\nCase 3 would look like this:\n\n```ocaml\ntype date\n```\n\nNow, users of the module can manipulate objects of type `date`, but they can't\naccess the record fields directly. They must use the functions that the module\nprovides. Let's assume the module provides three functions, one for creating a\ndate, one for computing the difference between two dates, and one that returns\nthe date in years:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\ntype date\n\nval create : ?days:int -> ?months:int -> ?years:int -> unit -> date\n\nval sub : date -> date -> date\n\nval years : date -> float\n```\n\nThe point is that only `create` and `sub` can be used to create `date` records.\nTherefore, it is not possible for the user of the module to create ill-formed\nrecords. Actually, our implementation uses a record, but we could change it and\nbe sure that it will not break any code that relies on this module! This makes\na lot of sense in a library since subsequent versions of the same library can\ncontinue to expose the same interface, while internally changing the\nimplementation, including data structures.\n\n## Submodules\n\n###  Submodule implementation\n\nWe saw that one `example.ml` file results automatically in one module\nimplementation named `Example`. Its module signature is automatically derived\nand is the broadest possible, or can be restricted by writing an `example.mli`\nfile.\n\nThat said, a given module can also be defined explicitly from within a file.\nThat makes it a submodule of the current module. Let's consider this\n`example.ml` file:\n\n```ocaml\nmodule Hello = struct\n  let message = \"Hello\"\n  let hello () = print_endline message\nend\n\nlet goodbye () = print_endline \"Goodbye\"\n\nlet hello_goodbye () =\n  Hello.hello ();\n  goodbye ()\n```\n\nFrom another file, it is clear that we now have two levels of modules.  We can\nwrite:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet () =\n  Example.Hello.hello ();\n  Example.goodbye ()\n```\n\n###  Submodule interface\n\nWe can also restrict the interface of a given submodule. It is called a module\ntype. Let's do it in our `example.ml` file:\n\n```ocaml\nmodule Hello : sig\n val hello : unit -> unit\nend\n= \nstruct\n  let message = \"Hello\"\n  let hello () = print_endline message\nend\n  \n(* At this point, Hello.message is not accessible anymore. *)\n\nlet goodbye () = print_endline \"Goodbye\"\n\nlet hello_goodbye () =\n  Hello.hello ();\n  goodbye ()\n```\n\nThe definition of the `Hello` module above is the equivalent of a\n`hello.mli`/`hello.ml` pair of files. Writing all of that in one block of code\nis not elegant so, in general, we prefer to define the module signature\nseparately:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmodule type Hello_type = sig\n val hello : unit -> unit\nend\n  \nmodule Hello : Hello_type = struct\n  ...\nend\n```\n\n`Hello_type` is a named module type, and can be reused to define other module\ninterfaces.\n\n## Practical manipulation of modules\n\n###  Displaying the interface of a module\n\nYou can use the `ocaml` toplevel to visualize the contents of an existing\nmodule, such as `List`:\n\n```ocaml\n# #show List;;\nmodule List = List\nmodule List :\n  sig\n    type 'a t = 'a list = [] | (::) of 'a * 'a list\n    val length : 'a t -> int\n    val compare_lengths : 'a t -> 'b t -> int\n    val compare_length_with : 'a t -> int -> int\n    val cons : 'a -> 'a t -> 'a t\n    val hd : 'a t -> 'a\n    val tl : 'a t -> 'a t\n    val nth : 'a t -> int -> 'a\n    val nth_opt : 'a t -> int -> 'a option\n    val rev : 'a t -> 'a t\n    val init : int -> (int -> 'a) -> 'a t\n    val append : 'a t -> 'a t -> 'a t\n    val rev_append : 'a t -> 'a t -> 'a t\n    val concat : 'a t t -> 'a t\n    val flatten : 'a t t -> 'a t\n    val iter : ('a -> unit) -> 'a t -> unit\n    val iteri : (int -> 'a -> unit) -> 'a t -> unit\n    val map : ('a -> 'b) -> 'a t -> 'b t\n    val mapi : (int -> 'a -> 'b) -> 'a t -> 'b t\n    val rev_map : ('a -> 'b) -> 'a t -> 'b t\n    val filter_map : ('a -> 'b option) -> 'a t -> 'b t\n    val concat_map : ('a -> 'b t) -> 'a t -> 'b t\n    val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b t -> 'a\n    val fold_right : ('a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val iter2 : ('a -> 'b -> unit) -> 'a t -> 'b t -> unit\n    val map2 : ('a -> 'b -> 'c) -> 'a t -> 'b t -> 'c t\n    val rev_map2 : ('a -> 'b -> 'c) -> 'a t -> 'b t -> 'c t\n    val fold_left2 : ('a -> 'b -> 'c -> 'a) -> 'a -> 'b t -> 'c t -> 'a\n    val fold_right2 : ('a -> 'b -> 'c -> 'c) -> 'a t -> 'b t -> 'c -> 'c\n    val for_all : ('a -> bool) -> 'a t -> bool\n    val exists : ('a -> bool) -> 'a t -> bool\n    val for_all2 : ('a -> 'b -> bool) -> 'a t -> 'b t -> bool\n    val exists2 : ('a -> 'b -> bool) -> 'a t -> 'b t -> bool\n    val mem : 'a -> 'a t -> bool\n    val memq : 'a -> 'a t -> bool\n    val find : ('a -> bool) -> 'a t -> 'a\n    val find_opt : ('a -> bool) -> 'a t -> 'a option\n    val find_map : ('a -> 'b option) -> 'a t -> 'b option\n    val filter : ('a -> bool) -> 'a t -> 'a t\n    val find_all : ('a -> bool) -> 'a t -> 'a t\n    val partition : ('a -> bool) -> 'a t -> 'a t * 'a t\n    val assoc : 'a -> ('a * 'b) t -> 'b\n    val assoc_opt : 'a -> ('a * 'b) t -> 'b option\n    val assq : 'a -> ('a * 'b) t -> 'b\n    val assq_opt : 'a -> ('a * 'b) t -> 'b option\n    val mem_assoc : 'a -> ('a * 'b) t -> bool\n    val mem_assq : 'a -> ('a * 'b) t -> bool\n    val remove_assoc : 'a -> ('a * 'b) t -> ('a * 'b) t\n    val remove_assq : 'a -> ('a * 'b) t -> ('a * 'b) t\n    val split : ('a * 'b) t -> 'a t * 'b t\n    val combine : 'a t -> 'b t -> ('a * 'b) t\n    val sort : ('a -> 'a -> int) -> 'a t -> 'a t\n    val stable_sort : ('a -> 'a -> int) -> 'a t -> 'a t\n    val fast_sort : ('a -> 'a -> int) -> 'a t -> 'a t\n    val sort_uniq : ('a -> 'a -> int) -> 'a t -> 'a t\n    val merge : ('a -> 'a -> int) -> 'a t -> 'a t -> 'a t\n    val to_seq : 'a t -> 'a Seq.t\n    val of_seq : 'a Seq.t -> 'a t\n  end\n```\n\nThere is online documentation for each library.\n\n###  Module inclusion\n\nLet's say we feel that a function is missing from the standard `List` module,\nbut we really want it as if it were part of it. In an `extensions.ml` file, we\ncan achieve this effect by using the `include` directive:\n\n```ocaml\n# module List = struct\n  include List\n  let rec optmap f = function\n    | [] -> []\n    | hd :: tl ->\n       match f hd with\n       | None -> optmap f tl\n       | Some x -> x :: optmap f tl\n  end\nmodule List :\n  sig\n    type 'a t = 'a list = [] | (::) of 'a * 'a list\n    val length : 'a t -> int\n    val compare_lengths : 'a t -> 'b t -> int\n    val compare_length_with : 'a t -> int -> int\n    val cons : 'a -> 'a t -> 'a t\n    val hd : 'a t -> 'a\n    val tl : 'a t -> 'a t\n    val nth : 'a t -> int -> 'a\n    val nth_opt : 'a t -> int -> 'a option\n    val rev : 'a t -> 'a t\n    val init : int -> (int -> 'a) -> 'a t\n    val append : 'a t -> 'a t -> 'a t\n    val rev_append : 'a t -> 'a t -> 'a t\n    val concat : 'a t t -> 'a t\n    val flatten : 'a t t -> 'a t\n    val iter : ('a -> unit) -> 'a t -> unit\n    val iteri : (int -> 'a -> unit) -> 'a t -> unit\n    val map : ('a -> 'b) -> 'a t -> 'b t\n    val mapi : (int -> 'a -> 'b) -> 'a t -> 'b t\n    val rev_map : ('a -> 'b) -> 'a t -> 'b t\n    val filter_map : ('a -> 'b option) -> 'a t -> 'b t\n    val concat_map : ('a -> 'b t) -> 'a t -> 'b t\n    val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b t -> 'a\n    val fold_right : ('a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val iter2 : ('a -> 'b -> unit) -> 'a t -> 'b t -> unit\n    val map2 : ('a -> 'b -> 'c) -> 'a t -> 'b t -> 'c t\n    val rev_map2 : ('a -> 'b -> 'c) -> 'a t -> 'b t -> 'c t\n    val fold_left2 : ('a -> 'b -> 'c -> 'a) -> 'a -> 'b t -> 'c t -> 'a\n    val fold_right2 : ('a -> 'b -> 'c -> 'c) -> 'a t -> 'b t -> 'c -> 'c\n    val for_all : ('a -> bool) -> 'a t -> bool\n    val exists : ('a -> bool) -> 'a t -> bool\n    val for_all2 : ('a -> 'b -> bool) -> 'a t -> 'b t -> bool\n    val exists2 : ('a -> 'b -> bool) -> 'a t -> 'b t -> bool\n    val mem : 'a -> 'a t -> bool\n    val memq : 'a -> 'a t -> bool\n    val find : ('a -> bool) -> 'a t -> 'a\n    val find_opt : ('a -> bool) -> 'a t -> 'a option\n    val find_map : ('a -> 'b option) -> 'a t -> 'b option\n    val filter : ('a -> bool) -> 'a t -> 'a t\n    val find_all : ('a -> bool) -> 'a t -> 'a t\n    val partition : ('a -> bool) -> 'a t -> 'a t * 'a t\n    val assoc : 'a -> ('a * 'b) t -> 'b\n    val assoc_opt : 'a -> ('a * 'b) t -> 'b option\n    val assq : 'a -> ('a * 'b) t -> 'b\n    val assq_opt : 'a -> ('a * 'b) t -> 'b option\n    val mem_assoc : 'a -> ('a * 'b) t -> bool\n    val mem_assq : 'a -> ('a * 'b) t -> bool\n    val remove_assoc : 'a -> ('a * 'b) t -> ('a * 'b) t\n    val remove_assq : 'a -> ('a * 'b) t -> ('a * 'b) t\n    val split : ('a * 'b) t -> 'a t * 'b t\n    val combine : 'a t -> 'b t -> ('a * 'b) t\n    val sort : ('a -> 'a -> int) -> 'a t -> 'a t\n    val stable_sort : ('a -> 'a -> int) -> 'a t -> 'a t\n    val fast_sort : ('a -> 'a -> int) -> 'a t -> 'a t\n    val sort_uniq : ('a -> 'a -> int) -> 'a t -> 'a t\n    val merge : ('a -> 'a -> int) -> 'a t -> 'a t -> 'a t\n    val to_seq : 'a t -> 'a Seq.t\n    val of_seq : 'a Seq.t -> 'a t\n    val optmap : ('a -> 'b option) -> 'a t -> 'b t\n  end\n```\n\nIt creates a module `Extensions.List` that has everything the standard `List`\nmodule has, plus a new `optmap` function. From another file, all we have to do\nto override the default `List` module is `open Extensions` at the beginning of\nthe .ml file:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nopen Extensions\n\n...\n\nList.optmap ...\n```\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#basic-usage">Basic usage</a>\n</li>\n<li><a href="#interfaces-and-signatures">Interfaces and signatures</a>\n</li>\n<li><a href="#abstract-types">Abstract types</a>\n</li>\n<li><a href="#submodules">Submodules</a>\n</li>\n<li><a href="#practical-manipulation-of-modules">Practical manipulation of modules</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:"<h2 id=\"basic-usage\">Basic usage</h2>\n<p>In OCaml, every piece of code is wrapped into a module. Optionally, a module\nitself can be a submodule of another module, pretty much like directories in a\nfile system - but we don't do this very often.</p>\n<p>When you write a program let's say using two files <code>amodule.ml</code> and\n<code>bmodule.ml</code>, each of these files automatically defines a module named\n<code>Amodule</code> and a module named <code>Bmodule</code> that provide whatever you put into the\nfiles.</p>\n<p>Here is the code that we have in our file <code>amodule.ml</code>:</p>\n\x3c!-- $MDX file=examples/amodule.ml --\x3e\n<pre><code class=\"language-ocaml\">let hello () = print_endline &quot;Hello&quot;\n</code></pre>\n<p>And here is what we have in <code>bmodule.ml</code>:</p>\n\x3c!-- $MDX file=examples/bmodule.ml --\x3e\n<pre><code class=\"language-ocaml\">let () = Amodule.hello ()\n</code></pre>\n<p>We can compile the files in one command:</p>\n\x3c!-- $MDX dir=examples --\x3e\n<pre><code class=\"language-sh\">$ ocamlopt -o hello amodule.ml bmodule.ml\n</code></pre>\n<p>Or, as a build system might do, one by one:</p>\n\x3c!-- $MDX dir=examples --\x3e\n<pre><code class=\"language-sh\">$ ocamlopt -c amodule.ml\n$ ocamlopt -c bmodule.ml\n$ ocamlopt -o hello amodule.cmx bmodule.cmx\n</code></pre>\n<p>Now we have an executable that prints &quot;Hello&quot;. As you can see, if you want to\naccess anything from a given module, use the name of the module (always\nstarting with a capital) followed by a dot and the thing that you want to use.\nIt may be a value, a type constructor, or anything else that a given module can\nprovide.</p>\n<p>Libraries, starting with the standard library, provide collections of modules.\nfor example, <code>List.iter</code> designates the <code>iter</code> function from the <code>List</code> module.</p>\n<p>If you are using a given module heavily, you may want to make its contents\ndirectly accessible. For this, we use the <code>open</code> directive. In our example,\n<code>bmodule.ml</code> could have been written:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class=\"language-ocaml\">open Amodule\nlet () = hello ()\n</code></pre>\n<p>Using <code>open</code> or not is a matter of personal taste. Some modules provide names\nthat are used in many other modules. This is the case of the <code>List</code> module for\ninstance. Usually, we don't do <code>open List</code>. Other modules like <code>Printf</code> provide\nnames that are normally not subject to conflicts, such as <code>printf</code>. In order to\navoid writing <code>Printf.printf</code> all over the place, it often makes sense to place\none <code>open Printf</code> at the beginning of the file:</p>\n<pre><code class=\"language-ocaml\">open Printf\nlet data = [&quot;a&quot;; &quot;beautiful&quot;; &quot;day&quot;]\nlet () = List.iter (printf &quot;%s\\n&quot;) data\n</code></pre>\n<p>There are also local <code>open</code>s:</p>\n<pre><code class=\"language-ocaml\"># let map_3d_matrix f m =\n  let open Array in\n    map (map (map f)) m\nval map_3d_matrix :\n  ('a -&gt; 'b) -&gt; 'a array array array -&gt; 'b array array array = &lt;fun&gt;\n# let map_3d_matrix' f =\n  Array.(map (map (map f)))\nval map_3d_matrix' :\n  ('a -&gt; 'b) -&gt; 'a array array array -&gt; 'b array array array = &lt;fun&gt;\n</code></pre>\n<h2 id=\"interfaces-and-signatures\">Interfaces and signatures</h2>\n<p>A module can provide a certain number of things (functions, types, submodules,\n...) to the rest of the program that is using it. If nothing special is done,\neverything which is defined in a module will be accessible from the outside. That's\noften fine in small personal programs, but there are many situations where it\nis better that a module only provides what it is meant to provide, not any of\nthe auxiliary functions and types that are used internally.</p>\n<p>For this, we have to define a module interface, which will act as a mask over\nthe module's implementation. Just like a module derives from a .ml file, the\ncorresponding module interface or signature derives from an .mli file. It\ncontains a list of values with their type. Let's rewrite our <code>amodule.ml</code> file\nto something called <code>amodule2.ml</code>:</p>\n\x3c!-- $MDX file=examples/amodule2.ml --\x3e\n<pre><code class=\"language-ocaml\">let hello () = print_endline &quot;Hello&quot;\n</code></pre>\n<p>As it is, <code>Amodule</code> has the following interface:</p>\n<pre><code class=\"language-ocaml\">val message : string\n\nval hello : unit -&gt; unit\n</code></pre>\n<pre><code class=\"language-mdx-error\">Line 1, characters 1-21:\nError: Value declarations are only allowed in signatures\n</code></pre>\n<p>Let's assume that accessing the <code>message</code> value directly is none of the others\nmodules' business. We want to hide it by defining a restricted interface. This\nis our <code>amodule2.mli</code> file:</p>\n\x3c!-- $MDX file=examples/amodule2.mli --\x3e\n<pre><code class=\"language-ocaml\">val hello : unit -&gt; unit\n(** Displays a greeting message. *)\n</code></pre>\n<p>(note the double asterisk at the beginning of the comment - it is a good habit\nto document .mli files using the format supported by\n[ocamldoc](/releases/{{! get LATEST_OCAML_VERSION_MAIN !}}/htmlman/ocamldoc.html))</p>\n<p>Such .mli files must be compiled just before the matching .ml files. They are\ncompiled using <code>ocamlc</code>, even if .ml files are compiled to native code using\n<code>ocamlopt</code>:</p>\n\x3c!-- $MDX dir=examples --\x3e\n<pre><code class=\"language-sh\">$ ocamlc -c amodule2.mli\n$ ocamlopt -c amodule2.ml\n</code></pre>\n<h2 id=\"abstract-types\">Abstract types</h2>\n<p>What about type definitions? We saw that values such as functions can be\nexported by placing their name and their type in a .mli file, e.g.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class=\"language-ocaml\">val hello : unit -&gt; unit\n</code></pre>\n<p>But modules often define new types. Let's define a simple record type that\nwould represent a date:</p>\n<pre><code class=\"language-ocaml\">type date = {day : int; month : int; year : int}\n</code></pre>\n<p>There are four options when it comes to writing the .mli file:</p>\n<ol>\n<li>The type is completely omitted from the signature.\n</li>\n<li>The type definition is copy-pasted into the signature.\n</li>\n<li>The type is made abstract: only its name is given.\n</li>\n<li>The record fields are made read-only: <code>type date = private { ... }</code>\n</li>\n</ol>\n<p>Case 3 would look like this:</p>\n<pre><code class=\"language-ocaml\">type date\n</code></pre>\n<p>Now, users of the module can manipulate objects of type <code>date</code>, but they can't\naccess the record fields directly. They must use the functions that the module\nprovides. Let's assume the module provides three functions, one for creating a\ndate, one for computing the difference between two dates, and one that returns\nthe date in years:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class=\"language-ocaml\">type date\n\nval create : ?days:int -&gt; ?months:int -&gt; ?years:int -&gt; unit -&gt; date\n\nval sub : date -&gt; date -&gt; date\n\nval years : date -&gt; float\n</code></pre>\n<p>The point is that only <code>create</code> and <code>sub</code> can be used to create <code>date</code> records.\nTherefore, it is not possible for the user of the module to create ill-formed\nrecords. Actually, our implementation uses a record, but we could change it and\nbe sure that it will not break any code that relies on this module! This makes\na lot of sense in a library since subsequent versions of the same library can\ncontinue to expose the same interface, while internally changing the\nimplementation, including data structures.</p>\n<h2 id=\"submodules\">Submodules</h2>\n<h3 id=\"submodule-implementation\">Submodule implementation</h3>\n<p>We saw that one <code>example.ml</code> file results automatically in one module\nimplementation named <code>Example</code>. Its module signature is automatically derived\nand is the broadest possible, or can be restricted by writing an <code>example.mli</code>\nfile.</p>\n<p>That said, a given module can also be defined explicitly from within a file.\nThat makes it a submodule of the current module. Let's consider this\n<code>example.ml</code> file:</p>\n<pre><code class=\"language-ocaml\">module Hello = struct\n  let message = &quot;Hello&quot;\n  let hello () = print_endline message\nend\n\nlet goodbye () = print_endline &quot;Goodbye&quot;\n\nlet hello_goodbye () =\n  Hello.hello ();\n  goodbye ()\n</code></pre>\n<p>From another file, it is clear that we now have two levels of modules.  We can\nwrite:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class=\"language-ocaml\">let () =\n  Example.Hello.hello ();\n  Example.goodbye ()\n</code></pre>\n<h3 id=\"submodule-interface\">Submodule interface</h3>\n<p>We can also restrict the interface of a given submodule. It is called a module\ntype. Let's do it in our <code>example.ml</code> file:</p>\n<pre><code class=\"language-ocaml\">module Hello : sig\n val hello : unit -&gt; unit\nend\n= \nstruct\n  let message = &quot;Hello&quot;\n  let hello () = print_endline message\nend\n  \n(* At this point, Hello.message is not accessible anymore. *)\n\nlet goodbye () = print_endline &quot;Goodbye&quot;\n\nlet hello_goodbye () =\n  Hello.hello ();\n  goodbye ()\n</code></pre>\n<p>The definition of the <code>Hello</code> module above is the equivalent of a\n<code>hello.mli</code>/<code>hello.ml</code> pair of files. Writing all of that in one block of code\nis not elegant so, in general, we prefer to define the module signature\nseparately:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class=\"language-ocaml\">module type Hello_type = sig\n val hello : unit -&gt; unit\nend\n  \nmodule Hello : Hello_type = struct\n  ...\nend\n</code></pre>\n<p><code>Hello_type</code> is a named module type, and can be reused to define other module\ninterfaces.</p>\n<h2 id=\"practical-manipulation-of-modules\">Practical manipulation of modules</h2>\n<h3 id=\"displaying-the-interface-of-a-module\">Displaying the interface of a module</h3>\n<p>You can use the <code>ocaml</code> toplevel to visualize the contents of an existing\nmodule, such as <code>List</code>:</p>\n<pre><code class=\"language-ocaml\"># #show List;;\nmodule List = List\nmodule List :\n  sig\n    type 'a t = 'a list = [] | (::) of 'a * 'a list\n    val length : 'a t -&gt; int\n    val compare_lengths : 'a t -&gt; 'b t -&gt; int\n    val compare_length_with : 'a t -&gt; int -&gt; int\n    val cons : 'a -&gt; 'a t -&gt; 'a t\n    val hd : 'a t -&gt; 'a\n    val tl : 'a t -&gt; 'a t\n    val nth : 'a t -&gt; int -&gt; 'a\n    val nth_opt : 'a t -&gt; int -&gt; 'a option\n    val rev : 'a t -&gt; 'a t\n    val init : int -&gt; (int -&gt; 'a) -&gt; 'a t\n    val append : 'a t -&gt; 'a t -&gt; 'a t\n    val rev_append : 'a t -&gt; 'a t -&gt; 'a t\n    val concat : 'a t t -&gt; 'a t\n    val flatten : 'a t t -&gt; 'a t\n    val iter : ('a -&gt; unit) -&gt; 'a t -&gt; unit\n    val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit\n    val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val rev_map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val filter_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b t\n    val concat_map : ('a -&gt; 'b t) -&gt; 'a t -&gt; 'b t\n    val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'a\n    val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a t -&gt; 'b -&gt; 'b\n    val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a t -&gt; 'b t -&gt; unit\n    val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t\n    val rev_map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t\n    val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'c t -&gt; 'a\n    val fold_right2 : ('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c -&gt; 'c\n    val for_all : ('a -&gt; bool) -&gt; 'a t -&gt; bool\n    val exists : ('a -&gt; bool) -&gt; 'a t -&gt; bool\n    val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool\n    val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool\n    val mem : 'a -&gt; 'a t -&gt; bool\n    val memq : 'a -&gt; 'a t -&gt; bool\n    val find : ('a -&gt; bool) -&gt; 'a t -&gt; 'a\n    val find_opt : ('a -&gt; bool) -&gt; 'a t -&gt; 'a option\n    val find_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b option\n    val filter : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t\n    val find_all : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t\n    val partition : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t * 'a t\n    val assoc : 'a -&gt; ('a * 'b) t -&gt; 'b\n    val assoc_opt : 'a -&gt; ('a * 'b) t -&gt; 'b option\n    val assq : 'a -&gt; ('a * 'b) t -&gt; 'b\n    val assq_opt : 'a -&gt; ('a * 'b) t -&gt; 'b option\n    val mem_assoc : 'a -&gt; ('a * 'b) t -&gt; bool\n    val mem_assq : 'a -&gt; ('a * 'b) t -&gt; bool\n    val remove_assoc : 'a -&gt; ('a * 'b) t -&gt; ('a * 'b) t\n    val remove_assq : 'a -&gt; ('a * 'b) t -&gt; ('a * 'b) t\n    val split : ('a * 'b) t -&gt; 'a t * 'b t\n    val combine : 'a t -&gt; 'b t -&gt; ('a * 'b) t\n    val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val stable_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val fast_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val sort_uniq : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val merge : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t -&gt; 'a t\n    val to_seq : 'a t -&gt; 'a Seq.t\n    val of_seq : 'a Seq.t -&gt; 'a t\n  end\n</code></pre>\n<p>There is online documentation for each library.</p>\n<h3 id=\"module-inclusion\">Module inclusion</h3>\n<p>Let's say we feel that a function is missing from the standard <code>List</code> module,\nbut we really want it as if it were part of it. In an <code>extensions.ml</code> file, we\ncan achieve this effect by using the <code>include</code> directive:</p>\n<pre><code class=\"language-ocaml\"># module List = struct\n  include List\n  let rec optmap f = function\n    | [] -&gt; []\n    | hd :: tl -&gt;\n       match f hd with\n       | None -&gt; optmap f tl\n       | Some x -&gt; x :: optmap f tl\n  end\nmodule List :\n  sig\n    type 'a t = 'a list = [] | (::) of 'a * 'a list\n    val length : 'a t -&gt; int\n    val compare_lengths : 'a t -&gt; 'b t -&gt; int\n    val compare_length_with : 'a t -&gt; int -&gt; int\n    val cons : 'a -&gt; 'a t -&gt; 'a t\n    val hd : 'a t -&gt; 'a\n    val tl : 'a t -&gt; 'a t\n    val nth : 'a t -&gt; int -&gt; 'a\n    val nth_opt : 'a t -&gt; int -&gt; 'a option\n    val rev : 'a t -&gt; 'a t\n    val init : int -&gt; (int -&gt; 'a) -&gt; 'a t\n    val append : 'a t -&gt; 'a t -&gt; 'a t\n    val rev_append : 'a t -&gt; 'a t -&gt; 'a t\n    val concat : 'a t t -&gt; 'a t\n    val flatten : 'a t t -&gt; 'a t\n    val iter : ('a -&gt; unit) -&gt; 'a t -&gt; unit\n    val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit\n    val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val rev_map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val filter_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b t\n    val concat_map : ('a -&gt; 'b t) -&gt; 'a t -&gt; 'b t\n    val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'a\n    val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a t -&gt; 'b -&gt; 'b\n    val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a t -&gt; 'b t -&gt; unit\n    val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t\n    val rev_map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t\n    val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'c t -&gt; 'a\n    val fold_right2 : ('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c -&gt; 'c\n    val for_all : ('a -&gt; bool) -&gt; 'a t -&gt; bool\n    val exists : ('a -&gt; bool) -&gt; 'a t -&gt; bool\n    val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool\n    val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool\n    val mem : 'a -&gt; 'a t -&gt; bool\n    val memq : 'a -&gt; 'a t -&gt; bool\n    val find : ('a -&gt; bool) -&gt; 'a t -&gt; 'a\n    val find_opt : ('a -&gt; bool) -&gt; 'a t -&gt; 'a option\n    val find_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b option\n    val filter : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t\n    val find_all : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t\n    val partition : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t * 'a t\n    val assoc : 'a -&gt; ('a * 'b) t -&gt; 'b\n    val assoc_opt : 'a -&gt; ('a * 'b) t -&gt; 'b option\n    val assq : 'a -&gt; ('a * 'b) t -&gt; 'b\n    val assq_opt : 'a -&gt; ('a * 'b) t -&gt; 'b option\n    val mem_assoc : 'a -&gt; ('a * 'b) t -&gt; bool\n    val mem_assq : 'a -&gt; ('a * 'b) t -&gt; bool\n    val remove_assoc : 'a -&gt; ('a * 'b) t -&gt; ('a * 'b) t\n    val remove_assq : 'a -&gt; ('a * 'b) t -&gt; ('a * 'b) t\n    val split : ('a * 'b) t -&gt; 'a t * 'b t\n    val combine : 'a t -&gt; 'b t -&gt; ('a * 'b) t\n    val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val stable_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val fast_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val sort_uniq : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t\n    val merge : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t -&gt; 'a t\n    val to_seq : 'a t -&gt; 'a Seq.t\n    val of_seq : 'a Seq.t -&gt; 'a t\n    val optmap : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b t\n  end\n</code></pre>\n<p>It creates a module <code>Extensions.List</code> that has everything the standard <code>List</code>\nmodule has, plus a new <code>optmap</code> function. From another file, all we have to do\nto override the default <code>List</code> module is <code>open Extensions</code> at the beginning of\nthe .ml file:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class=\"language-ocaml\">open Extensions\n\n...\n\nList.optmap ...\n</code></pre>\n"},tl:{hd:{title:"Labels",slug:"labels",description:"Provide labels to your functions arguments\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"language",tl:0},users:{hd:"Intermediate",tl:{hd:"Advanced",tl:0}},body_md:"\n## Labelled and optional arguments to functions\n\nPython has a nice syntax for writing arguments to functions. Here's\nan example (from the Python tutorial, since I'm not a Python\nprogrammer):\n\n```python\ndef ask_ok(prompt, retries=4, complaint='Yes or no, please!'):\n  # function definition omitted\n```\nHere are the ways we can call this Python function:\n\n```python\nask_ok ('Do you really want to quit?')\nask_ok ('Overwrite the file?', 2)\nask_ok (prompt='Are you sure?')\nask_ok (complaint='Please answer yes or no!', prompt='Are you sure?')\n```\n\nNotice that in Python we are allowed to name arguments when we call\nthem, or use the usual function call syntax, and we can have optional\narguments with default values.\n\nOCaml also has a way to label arguments and have optional arguments with\ndefault values.\n\nThe basic syntax is:\n\n```ocaml\n# let rec range ~first:a ~last:b =\n  if a > b then []\n  else a :: range ~first:(a + 1) ~last:b\nval range : first:int -> last:int -> int list = <fun>\n```\n\n(Notice that both `to` and `end` are reserved words in OCaml, so they\ncannot be used as labels. So you cannot have `~from/~to` or\n`~start/~end`.)\n\nThe type of our previous `range` function was:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nrange : int -> int -> int list\n```\n\nAnd the type of our new `range` function with labelled arguments is:\n\n```ocaml\n# range\n- : first:int -> last:int -> int list = <fun>\n```\n\nConfusingly, the `~` (tilde) is *not* shown in the type definition, but\nyou need to use it everywhere else.\n\nWith labelled arguments, it doesn't matter which order you give the\narguments anymore:\n\n```ocaml\n# range ~first:1 ~last:10\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range ~last:10 ~first:1\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n```\n\nThere is also a shorthand way to name the arguments, so that the label\nis the same as the variable in the function definition:\n\n```ocaml\n# let may ~f x =\n  match x with\n  | None -> ()\n  | Some x -> ignore (f x)\nval may : f:('a -> 'b) -> 'a option -> unit = <fun>\n```\n\nIt's worth spending some time working out exactly what this function\ndoes, and also working out by hand its type signature. There's a lot\ngoing on. First of all, the parameter `~f` is just shorthand for `~f:f`\n(ie. the label is `~f` and the variable used in the function is `f`).\nSecondly notice that the function takes two parameters. The second\nparameter (`x`) is unlabelled - it is permitted for a function to take a\nmixture of labelled and unlabelled arguments if you want.\n\nWhat is the type of the labelled `f` parameter? Obviously it's a\nfunction of some sort.\n\nWhat is the type of the unlabelled `x` parameter? The `match` clause\ngives us a clue. It's an `'a option`.\n\nThis tells us that `f` takes an `'a` parameter, and the return value of\n`f` is ignored, so it could be anything. The type of `f` is therefore\n`'a -> 'b`.\n\nThe `may` function as a whole returns `unit`. Notice in each case of the\n`match` the result is `()`.\n\nThus the type of the `may` function is (and you can verify this in the\nOCaml interactive toplevel if you want):\n\n```ocaml\n# may\n- : f:('a -> 'b) -> 'a option -> unit = <fun>\n```\nWhat does this function do? Running the function in the OCaml toplevel\ngives us some clues:\n\n```ocaml\n# may ~f:print_endline None\n- : unit = ()\n# may ~f:print_endline (Some \"hello\")\nhello\n- : unit = ()\n```\n\nIf the unlabelled argument is a \u201cnull pointer\u201d then `may` does nothing.\nOtherwise `may` calls the `f` function on the argument. Why is this\nuseful? We're just about to find out ...\n\n###  Optional arguments\nOptional arguments are like labelled arguments, but we use `?` instead\nof `~` in front of them. Here is an example:\n\n```ocaml\n# let rec range ?(step=1) a b =\n  if a > b then []\n  else a :: range ~step (a + step) b\nval range : ?step:int -> int -> int -> int list = <fun>\n```\n\nNote the somewhat confusing syntax, switching between `?` and `~`. We'll\ntalk about that in the next section. Here is how you call this function:\n\n```ocaml\n# range 1 10\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range 1 10 ~step:2\n- : int list = [1; 3; 5; 7; 9]\n```\n\nIn this case, `?(step=1)` fairly obviously means that `~step` is an\noptional argument which defaults to 1. We can also omit the default\nvalue and just have an optional argument. This example is modified from\nlablgtk:\n\n```ocaml\n# type window =\n  {mutable title: string;\n   mutable width: int;\n   mutable height: int}\ntype window = {\n  mutable title : string;\n  mutable width : int;\n  mutable height : int;\n}\n# let create_window () =\n  {title = \"none\"; width = 640; height = 480;}\nval create_window : unit -> window = <fun>\n# let set_title window title =\n  window.title <- title\nval set_title : window -> string -> unit = <fun>\n# let set_width window width =\n  window.width <- width\nval set_width : window -> int -> unit = <fun>\n# let set_height window height =\n  window.height <- height\nval set_height : window -> int -> unit = <fun>\n# let open_window ?title ?width ?height () =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nval open_window :\n  ?title:string -> ?width:int -> ?height:int -> unit -> window = <fun>\n```\n\nThis example is significantly complex and quite subtle, but the pattern\nused is very common in the lablgtk source code. Let's concentrate on the\nsimple `create_window` function first. This function takes a `unit` and\nreturns a `window`, initialized with default settings for title, width\nand height:\n\n```ocaml\n# create_window ()\n- : window = {title = \"none\"; width = 640; height = 480}\n```\n\nThe `set_title`, `set_width` and `set_height` functions are impure\nfunctions which modify the `window` structure, in the obvious way. For\nexample:\n\n```ocaml\n# let w = create_window () in\n  set_title w \"My Application\";\n  w\n- : window = {title = \"My Application\"; width = 640; height = 480}\n```\n\nSo far this is just the imperative \"mutable records\" which we talked\nabout in the previous chapter. Now the complex part is the `open_window`\nfunction. This function takes *4* arguments, three of them optional,\nfollowed by a required, unlabelled `unit`. Let's first see this function\nin action:\n\n```ocaml\n# open_window ~title:\"My Application\" ()\n- : window = {title = \"My Application\"; width = 640; height = 480}\n# open_window ~title:\"Clock\" ~width:128 ~height:128 ()\n- : window = {title = \"Clock\"; width = 128; height = 128}\n```\n\nIt does what you expect, but how?! The secret is in the `may` function\n(see above) and the fact that the optional parameters *don't* have\ndefaults.\n\nWhen an optional parameter doesn't have a default, then it has type\n`'a option`. The `'a` would normally be inferred by type inference, so\nin the case of `?title` above, this has type `string option`.\n\nRemember the `may` function? It takes a function and an argument, and\ncalls the function on the argument provided the argument isn't `None`.\nSo:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\n# may ~f:(set_title window) title\n```\n\nIf the optional title argument is not specified by the caller, then\n`title` = `None`, so `may` does nothing. But if we call the function\nwith, for example,\n\n```ocaml\n# open_window ~title:\"My Application\" ()\n- : window = {title = \"My Application\"; width = 640; height = 480}\n```\n\nthen `title` = `Some \"My Application\"`, and `may` therefore calls\n`set_title window \"My Application\"`.\n\nYou should make sure you fully understand this example before proceeding\nto the next section.\n\n###  \"Warning: This optional argument cannot be erased\"\nWe've just touched upon labels and optional arguments, but even this\nbrief explanation should have raised several questions. The first may be\nwhy the extra `unit` argument to `open_window`? Let's try defining this\nfunction without the extra `unit`:\n\n```ocaml\n# let open_window ?title ?width ?height =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nLine 1, characters 32-38:\nWarning 16: this optional argument cannot be erased.\nval open_window : ?title:string -> ?width:int -> ?height:int -> window =\n  <fun>\n```\n\nAlthough OCaml has compiled the function, it has generated a somewhat\ninfamous warning: \"This optional argument cannot be erased\", referring\nto the final `?height` argument. To try to show what's going on here,\nlet's call our modified `open_window` function:\n\n```ocaml\n# open_window\n- : ?title:string -> ?width:int -> ?height:int -> window = <fun>\n# open_window ~title:\"My Application\"\n- : ?width:int -> ?height:int -> window = <fun>\n```\n\nDid that work or not? No it didn't. In fact it didn't even run the\n`open_window` function at all. Instead it printed some strange type\ninformation. What's going on?\n\nRecall currying and uncurrying, and partial application of functions. If\nwe have a function `plus` defined as:\n\n```ocaml\n# let plus x y =\n  x + y\nval plus : int -> int -> int = <fun>\n```\nWe can partially apply this, for example as `plus 2` which is \"the\nfunction that adds 2 to things\":\n\n```ocaml\n# let f = plus 2\nval f : int -> int = <fun>\n# f 5\n- : int = 7\n# f 100\n- : int = 102\n```\n\nIn the `plus` example, the OCaml compiler can easily work out that\n`plus 2` doesn't have enough arguments supplied yet. It needs another\nargument before the `plus` function itself can be executed. Therefore\n`plus 2` is a function which is waiting for its extra argument to come\nalong.\n\nThings are not so clear when we add optional arguments into the mix. The\ncall to `open_window;;` above is a case in point. Does the user mean\n\"execute `open_window` now\"? Or does the user mean to supply some or all\nof the optional arguments later? Is `open_window;;` waiting for extra\narguments to come along like `plus 2`?\n\nOCaml plays it safe and doesn't execute `open_window`. Instead it treats\nit as a partial function application. The expression `open_window`\nliterally evaluates to a function value.\n\nLet's go back to the original and working definition of `open_window`\nwhere we had the extra unlabelled `unit` argument at the end:\n\n```ocaml\n# let open_window ?title ?width ?height () =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nval open_window :\n  ?title:string -> ?width:int -> ?height:int -> unit -> window = <fun>\n```\n\nIf you want to pass optional arguments to `open_window` you must do so\nbefore the final `unit`, so if you type:\n\n```ocaml\n# open_window ()\n- : window = {title = \"none\"; width = 640; height = 480}\n```\nyou must mean \"execute `open_window` now with all optional arguments\nunspecified\". Whereas if you type:\n\n```ocaml\n# open_window\n- : ?title:string -> ?width:int -> ?height:int -> unit -> window = <fun>\n```\nyou mean \"give me the functional value\" or (more usually in the\ntoplevel) \"print out the type of `open_window`\".\n\n###  More `~`shorthand\nLet's rewrite the `range` function yet again, this time using as much\nshorthand as possible for the labels:\n\n```ocaml\n# let rec range ~first ~last =\n  if first > last then []\n  else first :: range ~first:(first + 1) ~last\nval range : first:int -> last:int -> int list = <fun>\n```\n\nRecall that `~foo` on its own is short for `~foo:foo`. This applies also\nwhen calling functions as well as declaring the arguments to functions,\nhence in the above the highlighted red `~last` is short for\n`~last:last`.\n\n###  Using `?foo` in a function call\nThere's another little wrinkle concerning optional arguments. Suppose we\nwrite a function around `open_window` to open up an application:\n\n```ocaml\n# let open_application ?width ?height () =\n  open_window ~title:\"My Application\" ~width ~height\nLine 2, characters 40-45:\nError: This expression has type 'a option\n       but an expression was expected of type int\n```\n\nRecall that `~width` is shorthand for `~width:width`. The type of\n`width` is `'a option`, but `open_window ~width:` expects an `int`.\n\nOCaml provides more syntactic sugar. Writing `?width` in the function\ncall is shorthand for writing `~width:(unwrap width)` where `unwrap`\nwould be a function which would remove the \"`option` wrapper\" around\n`width` (it's not actually possible to write an `unwrap` function like\nthis, but conceptually that's the idea). So the correct way to write\nthis function is:\n\n```ocaml\n# let open_application ?width ?height () =\n  open_window ~title:\"My Application\" ?width ?height\nval open_application : ?width:int -> ?height:int -> unit -> unit -> window =\n  <fun>\n```\n\n###  When and when not to use `~` and `?`\nThe syntax for labels and optional arguments is confusing, and you may\noften wonder when to use `~foo`, when to use `?foo` and when to use\nplain `foo`. It's something of a black art which takes practice to get\nright.\n\n`?foo` is only used when declaring the arguments of a function, ie:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet f ?arg1 ... =\n```\n\nor when using the specialised \"unwrap `option` wrapper\" form for\nfunction calls:\n\n```ocaml\n# let open_application ?width ?height () =\n  open_window ~title:\"My Application\" ?width ?height\nval open_application : ?width:int -> ?height:int -> unit -> unit -> window =\n  <fun>\n```\nThe declaration `?foo` creates a variable called `foo`, so if you need\nthe value of `?foo`, use just `foo`.\n\nThe same applies to labels. Only use the `~foo` form when declaring\narguments of a function, ie:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet f ~foo:foo ... =\n```\n\nThe declaration `~foo:foo` creates a variable called simply `foo`, so if\nyou need the value just use plain `foo`.\n\nThings, however, get complicated for two reasons: first, the shorthand\nform `~foo` (equivalent to `~foo:foo`), and second, when you call a\nfunction which takes a labelled or optional argument and you use the\nshorthand form.\n\nHere is some apparently obscure code from lablgtk to demonstrate all of\nthis:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\n# let html ?border_width ?width ?height ?packing ?show () =  (* line 1 *)\n  let w = create () in\n  load_empty w;\n  Container.set w ?border_width ?width ?height;            (* line 4 *)\n  pack_return (new html w) ~packing ~show                  (* line 5 *)\n```\nOn line 1 we have the function definition. Notice there are 5 optional\narguments, and the mandatory `unit` 6<sup>th</sup> argument. Each of the\noptional arguments is going to define a variable, eg. `border_width`, of\ntype `'a option`.\n\nOn line 4 we use the special `?foo` form for passing optional arguments\nto functions which take optional arguments. `Container.set` has the\nfollowing type:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmodule Container = struct\n  let set ?border_width ?(width = -2) ?(height = -2) w =\n    (* ... *)\n```\nLine 5 uses the `~`shorthand. Writing this in long form:\n\n```ocaml\n# pack_return (new html w) ~packing:packing ~show:show\nLine 1, characters 1-12:\nError: Unbound value pack_return\n```\n\nThe `pack_return` function actually takes mandatory labelled arguments\ncalled `~packing` and `~show`, each of type `'a option`. In other words,\n`pack_return` explicitly unwraps the `option` wrapper.\n\n## More variants (\u201cpolymorphic variants\u201d)\nTry compiling the following C code:\n\n```C\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nenum lock { open, close };\n\nmain ()\n{\n  int fd, n;\n  char buffer[256];\n\n  fd = open (\"/etc/motd\", O_RDONLY);                     // line 12\n  while ((n = read (fd, buffer, sizeof buffer)) > 0)\n    write (1, buffer, n);\n  close (fd);                                            // line 15\n}\n```\nWhen I compile the code I get a whole bunch of errors including:\n\n```text\ntest.c: In function `main':\ntest.c:12: error: called object is not a function\ntest.c:15: error: called object is not a function\n```\nThis illustrates one problem with enumerated types (enums) in C. In the\nexample above, one enum statement reserves *three* symbols, namely\n`lock`, `open` and `close`. Here's another example:\n\n```C\nenum lock { open, close };\nenum door { open, close };\n```\nCompiling gives:\n\n```text\ntest.c:2: error: conflicting types for `open'\ntest.c:1: error: previous declaration of `open'\ntest.c:2: error: conflicting types for `close'\ntest.c:1: error: previous declaration of `close'\n```\nThe first enum defines the symbol `open` as something of type\n`enum lock`. You cannot reuse that symbol in another enum.\n\nThis will be familiar to most C/C++ programmers, and they won't write\nnaive code like that above. However the same issue happens with OCaml\nvariants, but OCaml provides a way to work around it.\n\nHere is some OCaml code, which actually *does* compile:\n\n```ocaml\n# type lock = Open | Close\ntype lock = Open | Close\n# type door = Open | Close\ntype door = Open | Close\n```\nAfter running those two statements, what is the type of `Open`? We can\nfind out easily enough in the toplevel:\n\n```ocaml\n# type lock = Open | Close\ntype lock = Open | Close\n# type door = Open | Close\ntype door = Open | Close\n# Open\n- : door = Open\n```\n\nOCaml uses the most recent definition for `Open`, giving it the type\n`door`. This is actually not such a serious problem because if you\naccidentally tried to use `Open` in the type context of a `lock`, then\nOCaml's wonderful type inference would immediately spot the error and\nyou wouldn't be able to compile the code.\n\nSo far, so much like C. Now I said that OCaml provides a way to work\naround the constraint that `Open` can only have one type. In other\nwords, suppose I want to use `Open` to mean either \"the `Open` of type\n`lock`\" or \"the `Open` of type `door`\" and I want OCaml to work out\nwhich one I mean.\n\nThe syntax is slightly different, but here is how we do it:\n\n```ocaml\n# type lock = [ `Open | `Close ]\ntype lock = [ `Close | `Open ]\n# type door = [ `Open | `Close ]\ntype door = [ `Close | `Open ]\n```\nNotice the syntactic differences:\n\n1. Each variant name is prefixed with `` ` `` (a back tick).\n1. You have to put square brackets (`[]`) around the alternatives.\n\nThe question naturally arises: What is the type of `` `Open``?\n\n```ocaml\n# `Open\n- : [> `Open ] = `Open\n```\n`` [> `Open] `` can be read as\n`` [ `Open | and some other possibilities which we don't know about ] ``.\n\nThe \u201c>\u201d (greater than) sign indicates that the set of possibilities is\nbigger than those listed (open-ended).\n\nThere's nothing special about `` `Open ``. *Any* back-ticked word can be\nused as a type, even one which we haven't mentioned before:\n\n```ocaml\n# `Foo\n- : [> `Foo ] = `Foo\n# `Foo 42\n- : [> `Foo of int ] = `Foo 42\n```\nLet's write a function to print the state of a `lock`:\n\n```ocaml\n# let print_lock st =\n  match st with\n  | `Open -> print_endline \"The lock is open\"\n  | `Close -> print_endline \"The lock is closed\"\nval print_lock : [< `Close | `Open ] -> unit = <fun>\n```\nTake a careful look at the type of that function. Type inference has\nworked out that the `st` argument has type `` [< `Close | `Open] ``. The\n`<` (less than) sign means that this is a __closed class__. In\nother words, this function will only work on `` `Close`` or `` `Open``\nand not on anything else.\n\n```ocaml\n# print_lock `Open\nThe lock is open\n- : unit = ()\n```\n\nNotice that `print_lock` works just as well with a `door` as with a\n`lock`! We've deliberately given up some type safety, and type inference\nis now being used to help guess what we mean, rather than enforce\ncorrect coding.\n\nThis is only an introduction to polymorphic variants. Because of the\nreduction in type safety, it is recommended that you don't use these in\nyour code. You will, however, see them in advanced OCaml code quite a\nlot precisely because advanced programmers will sometimes want to weaken\nthe type system to write advanced idioms.\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#labelled-and-optional-arguments-to-functions">Labelled and optional arguments to functions</a>\n</li>\n<li><a href="#more-variants-polymorphic-variants">More variants (\u201cpolymorphic variants\u201d)</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="labelled-and-optional-arguments-to-functions">Labelled and optional arguments to functions</h2>\n<p>Python has a nice syntax for writing arguments to functions. Here\'s\nan example (from the Python tutorial, since I\'m not a Python\nprogrammer):</p>\n<pre><code class="language-python">def ask_ok(prompt, retries=4, complaint=\'Yes or no, please!\'):\n  # function definition omitted\n</code></pre>\n<p>Here are the ways we can call this Python function:</p>\n<pre><code class="language-python">ask_ok (\'Do you really want to quit?\')\nask_ok (\'Overwrite the file?\', 2)\nask_ok (prompt=\'Are you sure?\')\nask_ok (complaint=\'Please answer yes or no!\', prompt=\'Are you sure?\')\n</code></pre>\n<p>Notice that in Python we are allowed to name arguments when we call\nthem, or use the usual function call syntax, and we can have optional\narguments with default values.</p>\n<p>OCaml also has a way to label arguments and have optional arguments with\ndefault values.</p>\n<p>The basic syntax is:</p>\n<pre><code class="language-ocaml"># let rec range ~first:a ~last:b =\n  if a &gt; b then []\n  else a :: range ~first:(a + 1) ~last:b\nval range : first:int -&gt; last:int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>(Notice that both <code>to</code> and <code>end</code> are reserved words in OCaml, so they\ncannot be used as labels. So you cannot have <code>~from/~to</code> or\n<code>~start/~end</code>.)</p>\n<p>The type of our previous <code>range</code> function was:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">range : int -&gt; int -&gt; int list\n</code></pre>\n<p>And the type of our new <code>range</code> function with labelled arguments is:</p>\n<pre><code class="language-ocaml"># range\n- : first:int -&gt; last:int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Confusingly, the <code>~</code> (tilde) is <em>not</em> shown in the type definition, but\nyou need to use it everywhere else.</p>\n<p>With labelled arguments, it doesn\'t matter which order you give the\narguments anymore:</p>\n<pre><code class="language-ocaml"># range ~first:1 ~last:10\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range ~last:10 ~first:1\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n</code></pre>\n<p>There is also a shorthand way to name the arguments, so that the label\nis the same as the variable in the function definition:</p>\n<pre><code class="language-ocaml"># let may ~f x =\n  match x with\n  | None -&gt; ()\n  | Some x -&gt; ignore (f x)\nval may : f:(\'a -&gt; \'b) -&gt; \'a option -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>It\'s worth spending some time working out exactly what this function\ndoes, and also working out by hand its type signature. There\'s a lot\ngoing on. First of all, the parameter <code>~f</code> is just shorthand for <code>~f:f</code>\n(ie. the label is <code>~f</code> and the variable used in the function is <code>f</code>).\nSecondly notice that the function takes two parameters. The second\nparameter (<code>x</code>) is unlabelled - it is permitted for a function to take a\nmixture of labelled and unlabelled arguments if you want.</p>\n<p>What is the type of the labelled <code>f</code> parameter? Obviously it\'s a\nfunction of some sort.</p>\n<p>What is the type of the unlabelled <code>x</code> parameter? The <code>match</code> clause\ngives us a clue. It\'s an <code>\'a option</code>.</p>\n<p>This tells us that <code>f</code> takes an <code>\'a</code> parameter, and the return value of\n<code>f</code> is ignored, so it could be anything. The type of <code>f</code> is therefore\n<code>\'a -&gt; \'b</code>.</p>\n<p>The <code>may</code> function as a whole returns <code>unit</code>. Notice in each case of the\n<code>match</code> the result is <code>()</code>.</p>\n<p>Thus the type of the <code>may</code> function is (and you can verify this in the\nOCaml interactive toplevel if you want):</p>\n<pre><code class="language-ocaml"># may\n- : f:(\'a -&gt; \'b) -&gt; \'a option -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>What does this function do? Running the function in the OCaml toplevel\ngives us some clues:</p>\n<pre><code class="language-ocaml"># may ~f:print_endline None\n- : unit = ()\n# may ~f:print_endline (Some &quot;hello&quot;)\nhello\n- : unit = ()\n</code></pre>\n<p>If the unlabelled argument is a \u201cnull pointer\u201d then <code>may</code> does nothing.\nOtherwise <code>may</code> calls the <code>f</code> function on the argument. Why is this\nuseful? We\'re just about to find out ...</p>\n<h3 id="optional-arguments">Optional arguments</h3>\n<p>Optional arguments are like labelled arguments, but we use <code>?</code> instead\nof <code>~</code> in front of them. Here is an example:</p>\n<pre><code class="language-ocaml"># let rec range ?(step=1) a b =\n  if a &gt; b then []\n  else a :: range ~step (a + step) b\nval range : ?step:int -&gt; int -&gt; int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Note the somewhat confusing syntax, switching between <code>?</code> and <code>~</code>. We\'ll\ntalk about that in the next section. Here is how you call this function:</p>\n<pre><code class="language-ocaml"># range 1 10\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range 1 10 ~step:2\n- : int list = [1; 3; 5; 7; 9]\n</code></pre>\n<p>In this case, <code>?(step=1)</code> fairly obviously means that <code>~step</code> is an\noptional argument which defaults to 1. We can also omit the default\nvalue and just have an optional argument. This example is modified from\nlablgtk:</p>\n<pre><code class="language-ocaml"># type window =\n  {mutable title: string;\n   mutable width: int;\n   mutable height: int}\ntype window = {\n  mutable title : string;\n  mutable width : int;\n  mutable height : int;\n}\n# let create_window () =\n  {title = &quot;none&quot;; width = 640; height = 480;}\nval create_window : unit -&gt; window = &lt;fun&gt;\n# let set_title window title =\n  window.title &lt;- title\nval set_title : window -&gt; string -&gt; unit = &lt;fun&gt;\n# let set_width window width =\n  window.width &lt;- width\nval set_width : window -&gt; int -&gt; unit = &lt;fun&gt;\n# let set_height window height =\n  window.height &lt;- height\nval set_height : window -&gt; int -&gt; unit = &lt;fun&gt;\n# let open_window ?title ?width ?height () =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nval open_window :\n  ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; unit -&gt; window = &lt;fun&gt;\n</code></pre>\n<p>This example is significantly complex and quite subtle, but the pattern\nused is very common in the lablgtk source code. Let\'s concentrate on the\nsimple <code>create_window</code> function first. This function takes a <code>unit</code> and\nreturns a <code>window</code>, initialized with default settings for title, width\nand height:</p>\n<pre><code class="language-ocaml"># create_window ()\n- : window = {title = &quot;none&quot;; width = 640; height = 480}\n</code></pre>\n<p>The <code>set_title</code>, <code>set_width</code> and <code>set_height</code> functions are impure\nfunctions which modify the <code>window</code> structure, in the obvious way. For\nexample:</p>\n<pre><code class="language-ocaml"># let w = create_window () in\n  set_title w &quot;My Application&quot;;\n  w\n- : window = {title = &quot;My Application&quot;; width = 640; height = 480}\n</code></pre>\n<p>So far this is just the imperative &quot;mutable records&quot; which we talked\nabout in the previous chapter. Now the complex part is the <code>open_window</code>\nfunction. This function takes <em>4</em> arguments, three of them optional,\nfollowed by a required, unlabelled <code>unit</code>. Let\'s first see this function\nin action:</p>\n<pre><code class="language-ocaml"># open_window ~title:&quot;My Application&quot; ()\n- : window = {title = &quot;My Application&quot;; width = 640; height = 480}\n# open_window ~title:&quot;Clock&quot; ~width:128 ~height:128 ()\n- : window = {title = &quot;Clock&quot;; width = 128; height = 128}\n</code></pre>\n<p>It does what you expect, but how?! The secret is in the <code>may</code> function\n(see above) and the fact that the optional parameters <em>don\'t</em> have\ndefaults.</p>\n<p>When an optional parameter doesn\'t have a default, then it has type\n<code>\'a option</code>. The <code>\'a</code> would normally be inferred by type inference, so\nin the case of <code>?title</code> above, this has type <code>string option</code>.</p>\n<p>Remember the <code>may</code> function? It takes a function and an argument, and\ncalls the function on the argument provided the argument isn\'t <code>None</code>.\nSo:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml"># may ~f:(set_title window) title\n</code></pre>\n<p>If the optional title argument is not specified by the caller, then\n<code>title</code> = <code>None</code>, so <code>may</code> does nothing. But if we call the function\nwith, for example,</p>\n<pre><code class="language-ocaml"># open_window ~title:&quot;My Application&quot; ()\n- : window = {title = &quot;My Application&quot;; width = 640; height = 480}\n</code></pre>\n<p>then <code>title</code> = <code>Some &quot;My Application&quot;</code>, and <code>may</code> therefore calls\n<code>set_title window &quot;My Application&quot;</code>.</p>\n<p>You should make sure you fully understand this example before proceeding\nto the next section.</p>\n<h3 id="warning-this-optional-argument-cannot-be-erased">&quot;Warning: This optional argument cannot be erased&quot;</h3>\n<p>We\'ve just touched upon labels and optional arguments, but even this\nbrief explanation should have raised several questions. The first may be\nwhy the extra <code>unit</code> argument to <code>open_window</code>? Let\'s try defining this\nfunction without the extra <code>unit</code>:</p>\n<pre><code class="language-ocaml"># let open_window ?title ?width ?height =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nLine 1, characters 32-38:\nWarning 16: this optional argument cannot be erased.\nval open_window : ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; window =\n  &lt;fun&gt;\n</code></pre>\n<p>Although OCaml has compiled the function, it has generated a somewhat\ninfamous warning: &quot;This optional argument cannot be erased&quot;, referring\nto the final <code>?height</code> argument. To try to show what\'s going on here,\nlet\'s call our modified <code>open_window</code> function:</p>\n<pre><code class="language-ocaml"># open_window\n- : ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; window = &lt;fun&gt;\n# open_window ~title:&quot;My Application&quot;\n- : ?width:int -&gt; ?height:int -&gt; window = &lt;fun&gt;\n</code></pre>\n<p>Did that work or not? No it didn\'t. In fact it didn\'t even run the\n<code>open_window</code> function at all. Instead it printed some strange type\ninformation. What\'s going on?</p>\n<p>Recall currying and uncurrying, and partial application of functions. If\nwe have a function <code>plus</code> defined as:</p>\n<pre><code class="language-ocaml"># let plus x y =\n  x + y\nval plus : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>We can partially apply this, for example as <code>plus 2</code> which is &quot;the\nfunction that adds 2 to things&quot;:</p>\n<pre><code class="language-ocaml"># let f = plus 2\nval f : int -&gt; int = &lt;fun&gt;\n# f 5\n- : int = 7\n# f 100\n- : int = 102\n</code></pre>\n<p>In the <code>plus</code> example, the OCaml compiler can easily work out that\n<code>plus 2</code> doesn\'t have enough arguments supplied yet. It needs another\nargument before the <code>plus</code> function itself can be executed. Therefore\n<code>plus 2</code> is a function which is waiting for its extra argument to come\nalong.</p>\n<p>Things are not so clear when we add optional arguments into the mix. The\ncall to <code>open_window;;</code> above is a case in point. Does the user mean\n&quot;execute <code>open_window</code> now&quot;? Or does the user mean to supply some or all\nof the optional arguments later? Is <code>open_window;;</code> waiting for extra\narguments to come along like <code>plus 2</code>?</p>\n<p>OCaml plays it safe and doesn\'t execute <code>open_window</code>. Instead it treats\nit as a partial function application. The expression <code>open_window</code>\nliterally evaluates to a function value.</p>\n<p>Let\'s go back to the original and working definition of <code>open_window</code>\nwhere we had the extra unlabelled <code>unit</code> argument at the end:</p>\n<pre><code class="language-ocaml"># let open_window ?title ?width ?height () =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nval open_window :\n  ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; unit -&gt; window = &lt;fun&gt;\n</code></pre>\n<p>If you want to pass optional arguments to <code>open_window</code> you must do so\nbefore the final <code>unit</code>, so if you type:</p>\n<pre><code class="language-ocaml"># open_window ()\n- : window = {title = &quot;none&quot;; width = 640; height = 480}\n</code></pre>\n<p>you must mean &quot;execute <code>open_window</code> now with all optional arguments\nunspecified&quot;. Whereas if you type:</p>\n<pre><code class="language-ocaml"># open_window\n- : ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; unit -&gt; window = &lt;fun&gt;\n</code></pre>\n<p>you mean &quot;give me the functional value&quot; or (more usually in the\ntoplevel) &quot;print out the type of <code>open_window</code>&quot;.</p>\n<h3 id="more-shorthand">More <code>~</code>shorthand</h3>\n<p>Let\'s rewrite the <code>range</code> function yet again, this time using as much\nshorthand as possible for the labels:</p>\n<pre><code class="language-ocaml"># let rec range ~first ~last =\n  if first &gt; last then []\n  else first :: range ~first:(first + 1) ~last\nval range : first:int -&gt; last:int -&gt; int list = &lt;fun&gt;\n</code></pre>\n<p>Recall that <code>~foo</code> on its own is short for <code>~foo:foo</code>. This applies also\nwhen calling functions as well as declaring the arguments to functions,\nhence in the above the highlighted red <code>~last</code> is short for\n<code>~last:last</code>.</p>\n<h3 id="using-foo-in-a-function-call">Using <code>?foo</code> in a function call</h3>\n<p>There\'s another little wrinkle concerning optional arguments. Suppose we\nwrite a function around <code>open_window</code> to open up an application:</p>\n<pre><code class="language-ocaml"># let open_application ?width ?height () =\n  open_window ~title:&quot;My Application&quot; ~width ~height\nLine 2, characters 40-45:\nError: This expression has type \'a option\n       but an expression was expected of type int\n</code></pre>\n<p>Recall that <code>~width</code> is shorthand for <code>~width:width</code>. The type of\n<code>width</code> is <code>\'a option</code>, but <code>open_window ~width:</code> expects an <code>int</code>.</p>\n<p>OCaml provides more syntactic sugar. Writing <code>?width</code> in the function\ncall is shorthand for writing <code>~width:(unwrap width)</code> where <code>unwrap</code>\nwould be a function which would remove the &quot;<code>option</code> wrapper&quot; around\n<code>width</code> (it\'s not actually possible to write an <code>unwrap</code> function like\nthis, but conceptually that\'s the idea). So the correct way to write\nthis function is:</p>\n<pre><code class="language-ocaml"># let open_application ?width ?height () =\n  open_window ~title:&quot;My Application&quot; ?width ?height\nval open_application : ?width:int -&gt; ?height:int -&gt; unit -&gt; unit -&gt; window =\n  &lt;fun&gt;\n</code></pre>\n<h3 id="when-and-when-not-to-use--and-">When and when not to use <code>~</code> and <code>?</code></h3>\n<p>The syntax for labels and optional arguments is confusing, and you may\noften wonder when to use <code>~foo</code>, when to use <code>?foo</code> and when to use\nplain <code>foo</code>. It\'s something of a black art which takes practice to get\nright.</p>\n<p><code>?foo</code> is only used when declaring the arguments of a function, ie:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let f ?arg1 ... =\n</code></pre>\n<p>or when using the specialised &quot;unwrap <code>option</code> wrapper&quot; form for\nfunction calls:</p>\n<pre><code class="language-ocaml"># let open_application ?width ?height () =\n  open_window ~title:&quot;My Application&quot; ?width ?height\nval open_application : ?width:int -&gt; ?height:int -&gt; unit -&gt; unit -&gt; window =\n  &lt;fun&gt;\n</code></pre>\n<p>The declaration <code>?foo</code> creates a variable called <code>foo</code>, so if you need\nthe value of <code>?foo</code>, use just <code>foo</code>.</p>\n<p>The same applies to labels. Only use the <code>~foo</code> form when declaring\narguments of a function, ie:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let f ~foo:foo ... =\n</code></pre>\n<p>The declaration <code>~foo:foo</code> creates a variable called simply <code>foo</code>, so if\nyou need the value just use plain <code>foo</code>.</p>\n<p>Things, however, get complicated for two reasons: first, the shorthand\nform <code>~foo</code> (equivalent to <code>~foo:foo</code>), and second, when you call a\nfunction which takes a labelled or optional argument and you use the\nshorthand form.</p>\n<p>Here is some apparently obscure code from lablgtk to demonstrate all of\nthis:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml"># let html ?border_width ?width ?height ?packing ?show () =  (* line 1 *)\n  let w = create () in\n  load_empty w;\n  Container.set w ?border_width ?width ?height;            (* line 4 *)\n  pack_return (new html w) ~packing ~show                  (* line 5 *)\n</code></pre>\n<p>On line 1 we have the function definition. Notice there are 5 optional\narguments, and the mandatory <code>unit</code> 6<sup>th</sup> argument. Each of the\noptional arguments is going to define a variable, eg. <code>border_width</code>, of\ntype <code>\'a option</code>.</p>\n<p>On line 4 we use the special <code>?foo</code> form for passing optional arguments\nto functions which take optional arguments. <code>Container.set</code> has the\nfollowing type:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">module Container = struct\n  let set ?border_width ?(width = -2) ?(height = -2) w =\n    (* ... *)\n</code></pre>\n<p>Line 5 uses the <code>~</code>shorthand. Writing this in long form:</p>\n<pre><code class="language-ocaml"># pack_return (new html w) ~packing:packing ~show:show\nLine 1, characters 1-12:\nError: Unbound value pack_return\n</code></pre>\n<p>The <code>pack_return</code> function actually takes mandatory labelled arguments\ncalled <code>~packing</code> and <code>~show</code>, each of type <code>\'a option</code>. In other words,\n<code>pack_return</code> explicitly unwraps the <code>option</code> wrapper.</p>\n<h2 id="more-variants-polymorphic-variants">More variants (\u201cpolymorphic variants\u201d)</h2>\n<p>Try compiling the following C code:</p>\n<pre><code class="language-C">#include &lt;stdio.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\nenum lock { open, close };\n\nmain ()\n{\n  int fd, n;\n  char buffer[256];\n\n  fd = open (&quot;/etc/motd&quot;, O_RDONLY);                     // line 12\n  while ((n = read (fd, buffer, sizeof buffer)) &gt; 0)\n    write (1, buffer, n);\n  close (fd);                                            // line 15\n}\n</code></pre>\n<p>When I compile the code I get a whole bunch of errors including:</p>\n<pre><code class="language-text">test.c: In function `main\':\ntest.c:12: error: called object is not a function\ntest.c:15: error: called object is not a function\n</code></pre>\n<p>This illustrates one problem with enumerated types (enums) in C. In the\nexample above, one enum statement reserves <em>three</em> symbols, namely\n<code>lock</code>, <code>open</code> and <code>close</code>. Here\'s another example:</p>\n<pre><code class="language-C">enum lock { open, close };\nenum door { open, close };\n</code></pre>\n<p>Compiling gives:</p>\n<pre><code class="language-text">test.c:2: error: conflicting types for `open\'\ntest.c:1: error: previous declaration of `open\'\ntest.c:2: error: conflicting types for `close\'\ntest.c:1: error: previous declaration of `close\'\n</code></pre>\n<p>The first enum defines the symbol <code>open</code> as something of type\n<code>enum lock</code>. You cannot reuse that symbol in another enum.</p>\n<p>This will be familiar to most C/C++ programmers, and they won\'t write\nnaive code like that above. However the same issue happens with OCaml\nvariants, but OCaml provides a way to work around it.</p>\n<p>Here is some OCaml code, which actually <em>does</em> compile:</p>\n<pre><code class="language-ocaml"># type lock = Open | Close\ntype lock = Open | Close\n# type door = Open | Close\ntype door = Open | Close\n</code></pre>\n<p>After running those two statements, what is the type of <code>Open</code>? We can\nfind out easily enough in the toplevel:</p>\n<pre><code class="language-ocaml"># type lock = Open | Close\ntype lock = Open | Close\n# type door = Open | Close\ntype door = Open | Close\n# Open\n- : door = Open\n</code></pre>\n<p>OCaml uses the most recent definition for <code>Open</code>, giving it the type\n<code>door</code>. This is actually not such a serious problem because if you\naccidentally tried to use <code>Open</code> in the type context of a <code>lock</code>, then\nOCaml\'s wonderful type inference would immediately spot the error and\nyou wouldn\'t be able to compile the code.</p>\n<p>So far, so much like C. Now I said that OCaml provides a way to work\naround the constraint that <code>Open</code> can only have one type. In other\nwords, suppose I want to use <code>Open</code> to mean either &quot;the <code>Open</code> of type\n<code>lock</code>&quot; or &quot;the <code>Open</code> of type <code>door</code>&quot; and I want OCaml to work out\nwhich one I mean.</p>\n<p>The syntax is slightly different, but here is how we do it:</p>\n<pre><code class="language-ocaml"># type lock = [ `Open | `Close ]\ntype lock = [ `Close | `Open ]\n# type door = [ `Open | `Close ]\ntype door = [ `Close | `Open ]\n</code></pre>\n<p>Notice the syntactic differences:</p>\n<ol>\n<li>Each variant name is prefixed with <code>`</code> (a back tick).\n</li>\n<li>You have to put square brackets (<code>[]</code>) around the alternatives.\n</li>\n</ol>\n<p>The question naturally arises: What is the type of <code> `Open</code>?</p>\n<pre><code class="language-ocaml"># `Open\n- : [&gt; `Open ] = `Open\n</code></pre>\n<p><code>[&gt; `Open]</code> can be read as\n<code>[ `Open | and some other possibilities which we don\'t know about ]</code>.</p>\n<p>The \u201c&gt;\u201d (greater than) sign indicates that the set of possibilities is\nbigger than those listed (open-ended).</p>\n<p>There\'s nothing special about <code>`Open</code>. <em>Any</em> back-ticked word can be\nused as a type, even one which we haven\'t mentioned before:</p>\n<pre><code class="language-ocaml"># `Foo\n- : [&gt; `Foo ] = `Foo\n# `Foo 42\n- : [&gt; `Foo of int ] = `Foo 42\n</code></pre>\n<p>Let\'s write a function to print the state of a <code>lock</code>:</p>\n<pre><code class="language-ocaml"># let print_lock st =\n  match st with\n  | `Open -&gt; print_endline &quot;The lock is open&quot;\n  | `Close -&gt; print_endline &quot;The lock is closed&quot;\nval print_lock : [&lt; `Close | `Open ] -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>Take a careful look at the type of that function. Type inference has\nworked out that the <code>st</code> argument has type <code>[&lt; `Close | `Open]</code>. The\n<code>&lt;</code> (less than) sign means that this is a <strong>closed class</strong>. In\nother words, this function will only work on <code> `Close</code> or <code> `Open</code>\nand not on anything else.</p>\n<pre><code class="language-ocaml"># print_lock `Open\nThe lock is open\n- : unit = ()\n</code></pre>\n<p>Notice that <code>print_lock</code> works just as well with a <code>door</code> as with a\n<code>lock</code>! We\'ve deliberately given up some type safety, and type inference\nis now being used to help guess what we mean, rather than enforce\ncorrect coding.</p>\n<p>This is only an introduction to polymorphic variants. Because of the\nreduction in type safety, it is recommended that you don\'t use these in\nyour code. You will, however, see them in advanced OCaml code quite a\nlot precisely because advanced programmers will sometimes want to weaken\nthe type system to write advanced idioms.</p>\n'},tl:{hd:{title:"Pointers in OCaml",slug:"pointers-in-ocaml",description:"Use OCaml's explicit pointers with references\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"language",tl:0},users:{hd:"Intermediate",tl:{hd:"Advanced",tl:0}},body_md:"\n## Status of pointers in OCaml\nPointers exist in OCaml, and in fact they spread all over the place.\nThey are used either implicitly (in the most cases), or explicitly (in\nthe rare occasions where implicit pointers are not more handy). The vast\nmajority of pointers usages that are found in usual programming\nlanguages simply disappear in OCaml, or more exactly, those pointers are\ntotally automatically handled by the compiler. Thus, the OCaml programmer\ncan safely ignore the existence of pointers, focusing on the semantics of their\nprogram.\n\nFor instance, lists or trees are defined without explicit pointers using\na concrete datatype definition. The underlying implementation uses\npointers, but this is hidden from the programmer since pointer\nhandling is done by the compiler.\n\nIn the rare occasions where explicit pointers are needed (the most\ncommon case is when translating into OCaml an algorithm described in a\nclassic imperative language), OCaml provides references that are\nfull-fledged pointers, even first class citizen pointers (references can\nbe passed as argument, embedded into arbitrary data structures, and\nreturned as function results).\n\n###  Explicit pointers are OCaml values of type `ref`\nYou can program directly with explicit references if you want to, but\nthis is normally a waste of time and effort.\n\nLet's examine the simple example of linked lists (integer lists to be\nsimple). This data type is defined in C (or in Pascal) using explicit\npointers, for instance:\n\n```C\n/* Cells and lists type in C */\nstruct cell {\n  int hd;\n  struct cell *tl;\n};\n\ntypedef struct cell cell, *list;\n```\n```Pascal\n{Cells and lists type in Pascal}\ntype\n list = ^cell;\n cell = record\n  hd: integer;\n  tl: cell;\n end;\n```\nWe can translate this in OCaml, using a sum type definition, without\npointers:\n\n```ocaml\n# type list = Nil | Cons of int * list\ntype list = Nil | Cons of int * list\n```\n\nCell lists are thus represented as pairs, and the recursive structure of\nlists is evident, with the two alternatives, empty list (the\n`Nil`constructor) and non empty list (the `Cons` constructor).\n\nAutomatic management of pointers and automatic memory allocation shine\nwhen allocating list values: one just writes `Cons (x, l)` to add `x` in\nfront of the list `l`. In C, you need to write this function, to\nallocate a new cell and then fill its fields. For instance:\n\n```C\n/* The empty list */\n#define nil NULL\n\n/* The constructor of lists */\nlist cons (element x, list l)\n{\n  list result;\n  result = (list) malloc (sizeof (cell));\n  result -> hd = x;\n  result -> tl = l;\n  return (result);\n}\n```\nSimilarly, in Pascal:\n\n```Pascal\n{Creating a list cell}\nfunction cons (x: integer; l: list): list;\n  var p: list;\n  begin\n    new(p);\n    p^.hd := x;\n    p^.tl := l;\n    cons := p\n  end;\n```\nWe thus see that fields of list cells in the C program have to be\nmutable, otherwise initialization is impossible. By contrast in OCaml,\nallocation and initialization are merged into a single basic operation:\nconstructor application. This way, immutable data structures are\ndefinable (those data types are often referred to as \u201cpure\u201d or\n\u201cfunctional\u201d data structures). If physical modifications are necessary\nfor other reasons than mere initialization, OCaml provides records with\nmutable fields. For instance, a list type defining lists whose elements\ncan be in place modified could be written:\n\n```ocaml\n# type list = Nil | Cons of cell\n  and cell = { mutable hd : int; tl : list }\ntype list = Nil | Cons of cell\nand cell = { mutable hd : int; tl : list; }\n```\nIf the structure of the list itself must also be modified (cells must be\nphysically removed from the list), the `tl` field would also be declared\nas mutable:\n\n```ocaml\n# type list = Nil | Cons of cell\n  and cell = { mutable hd : int; mutable tl : list }\ntype list = Nil | Cons of cell\nand cell = { mutable hd : int; mutable tl : list; }\n```\n\nPhysical assignments are still useless to allocate mutable data: you\nwrite `Cons {hd = 1; tl = l}` to add `1` to the list `l`. Physical\nassignments that remain in OCaml programs should be just those\nassignments that are mandatory to implement the algorithm at hand.\n\nVery often, pointers are used to implement physical modification of data\nstructures. In OCaml programs this means using vectors or mutable fields\nin records.\n\n**In conclusion:** You can use explicit pointers in OCaml, exactly as in C, but\nthis is not natural, since you get back the usual drawbacks and difficulties of\nexplicit pointers manipulation of classical algorithmic languages. See a more\ncomplete example below.\n\n## Defining pointers in OCaml\nThe general pointer type can be defined using the definition of a\npointer: a pointer is either null, or a pointer to an assignable memory\nlocation:\n\n```ocaml\n# type 'a pointer = Null | Pointer of 'a ref\ntype 'a pointer = Null | Pointer of 'a ref\n```\nExplicit dereferencing (or reading the pointer's designated value) and\npointer assignment (or writing to the pointer's designated memory\nlocation) are easily defined. We define dereferencing as a prefix\noperator named `!^`, and assignment as the infix `^:=`.\n\n```ocaml\n# let ( !^ ) = function\n    | Null -> invalid_arg \"Attempt to dereference the null pointer\"\n    | Pointer r -> !r\nval ( !^ ) : 'a pointer -> 'a = <fun>\n\n# let ( ^:= ) p v =\n    match p with\n     | Null -> invalid_arg \"Attempt to assign the null pointer\"\n     | Pointer r -> r := v\nval ( ^:= ) : 'a pointer -> 'a -> unit = <fun>\n```\n\nNow we define the allocation of a new pointer initialized to point to a\ngiven value:\n\n```ocaml\n# let new_pointer x = Pointer (ref x)\nval new_pointer : 'a -> 'a pointer = <fun>\n```\nFor instance, let's define and then assign a pointer to an integer:\n\n```ocaml\n# let p = new_pointer 0\nval p : int pointer = Pointer {contents = 0}\n# p ^:= 1\n- : unit = ()\n# !^p\n- : int = 1\n```\n\n## Integer Lists\nNow we can define lists using explicit pointers as in usual imperative\nlanguages:\n\n```ocaml\n# type ilist = cell pointer\n  and cell = { mutable hd : int; mutable tl : ilist }\ntype ilist = cell pointer\nand cell = { mutable hd : int; mutable tl : ilist; }\n```\nWe then define allocation of a new cell, the list constructor and its\nassociated destructors.\n\n```ocaml\n# let new_cell () = {hd = 0; tl = Null}\nval new_cell : unit -> cell = <fun>\n# let cons x l =\n    let c = new_cell () in\n    c.hd <- x;\n    c.tl <- l;\n    (new_pointer c : ilist)\nval cons : int -> ilist -> ilist = <fun>\n# let hd (l : ilist) = !^l.hd\nval hd : ilist -> int = <fun>\n# let tl (l : ilist) = !^l.tl\nval tl : ilist -> ilist = <fun>\n```\n\nWe can now write all kind of classical algorithms, based on pointers\nmanipulation, with their associated loops, their unwanted sharing\nproblems and their null pointer errors. For instance, list\nconcatenation, as often described in literature, physically modifies\nits first list argument, hooking the second list to the end of the\nfirst:\n\n```ocaml\n# let append (l1 : ilist) (l2 : ilist) =\n  let temp = ref l1 in\n  while tl !temp <> Null do\n    temp := tl !temp\n  done;\n  !^ !temp.tl <- l2\nval append : ilist -> ilist -> unit = <fun>\n\n# let l1 = cons 1 (cons 2 Null)\nval l1 : ilist =\n  Pointer\n   {contents = {hd = 1; tl = Pointer {contents = {hd = 2; tl = Null}}}}\n\n# let l2 = cons 3 Null\nval l2 : ilist = Pointer {contents = {hd = 3; tl = Null}}\n\n# append l1 l2\n- : unit = ()\n```\n\nThe lists `l1` and `l2` are effectively catenated:\n\n```ocaml\n# l1\n- : ilist =\nPointer\n {contents =\n   {hd = 1;\n    tl =\n     Pointer\n      {contents = {hd = 2; tl = Pointer {contents = {hd = 3; tl = Null}}}}}}\n```\n\nJust a nasty side effect of physical list concatenation: `l1` now\ncontains the concatenation of the two lists `l1` and `l2`, thus the list\n`l1` no longer exists: in some sense `append` *consumes* its first\nargument. In other words, the value of a list data now depends on its\nhistory, that is on the sequence of function calls that use the value.\nThis strange behaviour leads to a lot of difficulties when explicitly\nmanipulating pointers. Try for instance, the seemingly harmless:\n\n```ocaml\n# append l1 l1\n- : unit = ()\n```\n\nThen evaluate `l1`:\n\n```ocaml\n# l1\n- : ilist =\nPointer\n {contents =\n   {hd = 1;\n    tl =\n     Pointer\n      {contents = {hd = 2; tl = Pointer {contents = {hd = 3; tl = <cycle>}}}}}}\n```\n\n## Polymorphic lists\nWe can define polymorphic lists using pointers; here is a simple implementation\nof those polymorphic mutable lists:\n\n```ocaml\n# type 'a lists = 'a cell pointer\n  and 'a cell = { mutable hd : 'a pointer; mutable tl : 'a lists }\ntype 'a lists = 'a cell pointer\nand 'a cell = { mutable hd : 'a pointer; mutable tl : 'a lists; }\n# let new_cell () = {hd = Null; tl = Null}\nval new_cell : unit -> 'a cell = <fun>\n# let cons x l =\n    let c = new_cell () in\n    c.hd <- new_pointer x;\n    c.tl <- l;\n    (new_pointer c : 'a lists)\nval cons : 'a -> 'a lists -> 'a lists = <fun>\n# let hd (l : 'a lists) = !^l.hd\nval hd : 'a lists -> 'a pointer = <fun>\n# let tl (l : 'a lists) = !^l.tl\nval tl : 'a lists -> 'a lists = <fun>\n# let append (l1 : 'a lists) (l2 : 'a lists) =\n  let temp = ref l1 in\n  while tl !temp <> Null do\n    temp := tl !temp\n  done;\n  !^ !temp.tl <- l2\nval append : 'a lists -> 'a lists -> unit = <fun>\n```\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#status-of-pointers-in-ocaml">Status of pointers in OCaml</a>\n</li>\n<li><a href="#defining-pointers-in-ocaml">Defining pointers in OCaml</a>\n</li>\n<li><a href="#integer-lists">Integer Lists</a>\n</li>\n<li><a href="#polymorphic-lists">Polymorphic lists</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="status-of-pointers-in-ocaml">Status of pointers in OCaml</h2>\n<p>Pointers exist in OCaml, and in fact they spread all over the place.\nThey are used either implicitly (in the most cases), or explicitly (in\nthe rare occasions where implicit pointers are not more handy). The vast\nmajority of pointers usages that are found in usual programming\nlanguages simply disappear in OCaml, or more exactly, those pointers are\ntotally automatically handled by the compiler. Thus, the OCaml programmer\ncan safely ignore the existence of pointers, focusing on the semantics of their\nprogram.</p>\n<p>For instance, lists or trees are defined without explicit pointers using\na concrete datatype definition. The underlying implementation uses\npointers, but this is hidden from the programmer since pointer\nhandling is done by the compiler.</p>\n<p>In the rare occasions where explicit pointers are needed (the most\ncommon case is when translating into OCaml an algorithm described in a\nclassic imperative language), OCaml provides references that are\nfull-fledged pointers, even first class citizen pointers (references can\nbe passed as argument, embedded into arbitrary data structures, and\nreturned as function results).</p>\n<h3 id="explicit-pointers-are-ocaml-values-of-type-ref">Explicit pointers are OCaml values of type <code>ref</code></h3>\n<p>You can program directly with explicit references if you want to, but\nthis is normally a waste of time and effort.</p>\n<p>Let\'s examine the simple example of linked lists (integer lists to be\nsimple). This data type is defined in C (or in Pascal) using explicit\npointers, for instance:</p>\n<pre><code class="language-C">/* Cells and lists type in C */\nstruct cell {\n  int hd;\n  struct cell *tl;\n};\n\ntypedef struct cell cell, *list;\n</code></pre>\n<pre><code class="language-Pascal">{Cells and lists type in Pascal}\ntype\n list = ^cell;\n cell = record\n  hd: integer;\n  tl: cell;\n end;\n</code></pre>\n<p>We can translate this in OCaml, using a sum type definition, without\npointers:</p>\n<pre><code class="language-ocaml"># type list = Nil | Cons of int * list\ntype list = Nil | Cons of int * list\n</code></pre>\n<p>Cell lists are thus represented as pairs, and the recursive structure of\nlists is evident, with the two alternatives, empty list (the\n<code>Nil</code>constructor) and non empty list (the <code>Cons</code> constructor).</p>\n<p>Automatic management of pointers and automatic memory allocation shine\nwhen allocating list values: one just writes <code>Cons (x, l)</code> to add <code>x</code> in\nfront of the list <code>l</code>. In C, you need to write this function, to\nallocate a new cell and then fill its fields. For instance:</p>\n<pre><code class="language-C">/* The empty list */\n#define nil NULL\n\n/* The constructor of lists */\nlist cons (element x, list l)\n{\n  list result;\n  result = (list) malloc (sizeof (cell));\n  result -&gt; hd = x;\n  result -&gt; tl = l;\n  return (result);\n}\n</code></pre>\n<p>Similarly, in Pascal:</p>\n<pre><code class="language-Pascal">{Creating a list cell}\nfunction cons (x: integer; l: list): list;\n  var p: list;\n  begin\n    new(p);\n    p^.hd := x;\n    p^.tl := l;\n    cons := p\n  end;\n</code></pre>\n<p>We thus see that fields of list cells in the C program have to be\nmutable, otherwise initialization is impossible. By contrast in OCaml,\nallocation and initialization are merged into a single basic operation:\nconstructor application. This way, immutable data structures are\ndefinable (those data types are often referred to as \u201cpure\u201d or\n\u201cfunctional\u201d data structures). If physical modifications are necessary\nfor other reasons than mere initialization, OCaml provides records with\nmutable fields. For instance, a list type defining lists whose elements\ncan be in place modified could be written:</p>\n<pre><code class="language-ocaml"># type list = Nil | Cons of cell\n  and cell = { mutable hd : int; tl : list }\ntype list = Nil | Cons of cell\nand cell = { mutable hd : int; tl : list; }\n</code></pre>\n<p>If the structure of the list itself must also be modified (cells must be\nphysically removed from the list), the <code>tl</code> field would also be declared\nas mutable:</p>\n<pre><code class="language-ocaml"># type list = Nil | Cons of cell\n  and cell = { mutable hd : int; mutable tl : list }\ntype list = Nil | Cons of cell\nand cell = { mutable hd : int; mutable tl : list; }\n</code></pre>\n<p>Physical assignments are still useless to allocate mutable data: you\nwrite <code>Cons {hd = 1; tl = l}</code> to add <code>1</code> to the list <code>l</code>. Physical\nassignments that remain in OCaml programs should be just those\nassignments that are mandatory to implement the algorithm at hand.</p>\n<p>Very often, pointers are used to implement physical modification of data\nstructures. In OCaml programs this means using vectors or mutable fields\nin records.</p>\n<p><strong>In conclusion:</strong> You can use explicit pointers in OCaml, exactly as in C, but\nthis is not natural, since you get back the usual drawbacks and difficulties of\nexplicit pointers manipulation of classical algorithmic languages. See a more\ncomplete example below.</p>\n<h2 id="defining-pointers-in-ocaml">Defining pointers in OCaml</h2>\n<p>The general pointer type can be defined using the definition of a\npointer: a pointer is either null, or a pointer to an assignable memory\nlocation:</p>\n<pre><code class="language-ocaml"># type \'a pointer = Null | Pointer of \'a ref\ntype \'a pointer = Null | Pointer of \'a ref\n</code></pre>\n<p>Explicit dereferencing (or reading the pointer\'s designated value) and\npointer assignment (or writing to the pointer\'s designated memory\nlocation) are easily defined. We define dereferencing as a prefix\noperator named <code>!^</code>, and assignment as the infix <code>^:=</code>.</p>\n<pre><code class="language-ocaml"># let ( !^ ) = function\n    | Null -&gt; invalid_arg &quot;Attempt to dereference the null pointer&quot;\n    | Pointer r -&gt; !r\nval ( !^ ) : \'a pointer -&gt; \'a = &lt;fun&gt;\n\n# let ( ^:= ) p v =\n    match p with\n     | Null -&gt; invalid_arg &quot;Attempt to assign the null pointer&quot;\n     | Pointer r -&gt; r := v\nval ( ^:= ) : \'a pointer -&gt; \'a -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>Now we define the allocation of a new pointer initialized to point to a\ngiven value:</p>\n<pre><code class="language-ocaml"># let new_pointer x = Pointer (ref x)\nval new_pointer : \'a -&gt; \'a pointer = &lt;fun&gt;\n</code></pre>\n<p>For instance, let\'s define and then assign a pointer to an integer:</p>\n<pre><code class="language-ocaml"># let p = new_pointer 0\nval p : int pointer = Pointer {contents = 0}\n# p ^:= 1\n- : unit = ()\n# !^p\n- : int = 1\n</code></pre>\n<h2 id="integer-lists">Integer Lists</h2>\n<p>Now we can define lists using explicit pointers as in usual imperative\nlanguages:</p>\n<pre><code class="language-ocaml"># type ilist = cell pointer\n  and cell = { mutable hd : int; mutable tl : ilist }\ntype ilist = cell pointer\nand cell = { mutable hd : int; mutable tl : ilist; }\n</code></pre>\n<p>We then define allocation of a new cell, the list constructor and its\nassociated destructors.</p>\n<pre><code class="language-ocaml"># let new_cell () = {hd = 0; tl = Null}\nval new_cell : unit -&gt; cell = &lt;fun&gt;\n# let cons x l =\n    let c = new_cell () in\n    c.hd &lt;- x;\n    c.tl &lt;- l;\n    (new_pointer c : ilist)\nval cons : int -&gt; ilist -&gt; ilist = &lt;fun&gt;\n# let hd (l : ilist) = !^l.hd\nval hd : ilist -&gt; int = &lt;fun&gt;\n# let tl (l : ilist) = !^l.tl\nval tl : ilist -&gt; ilist = &lt;fun&gt;\n</code></pre>\n<p>We can now write all kind of classical algorithms, based on pointers\nmanipulation, with their associated loops, their unwanted sharing\nproblems and their null pointer errors. For instance, list\nconcatenation, as often described in literature, physically modifies\nits first list argument, hooking the second list to the end of the\nfirst:</p>\n<pre><code class="language-ocaml"># let append (l1 : ilist) (l2 : ilist) =\n  let temp = ref l1 in\n  while tl !temp &lt;&gt; Null do\n    temp := tl !temp\n  done;\n  !^ !temp.tl &lt;- l2\nval append : ilist -&gt; ilist -&gt; unit = &lt;fun&gt;\n\n# let l1 = cons 1 (cons 2 Null)\nval l1 : ilist =\n  Pointer\n   {contents = {hd = 1; tl = Pointer {contents = {hd = 2; tl = Null}}}}\n\n# let l2 = cons 3 Null\nval l2 : ilist = Pointer {contents = {hd = 3; tl = Null}}\n\n# append l1 l2\n- : unit = ()\n</code></pre>\n<p>The lists <code>l1</code> and <code>l2</code> are effectively catenated:</p>\n<pre><code class="language-ocaml"># l1\n- : ilist =\nPointer\n {contents =\n   {hd = 1;\n    tl =\n     Pointer\n      {contents = {hd = 2; tl = Pointer {contents = {hd = 3; tl = Null}}}}}}\n</code></pre>\n<p>Just a nasty side effect of physical list concatenation: <code>l1</code> now\ncontains the concatenation of the two lists <code>l1</code> and <code>l2</code>, thus the list\n<code>l1</code> no longer exists: in some sense <code>append</code> <em>consumes</em> its first\nargument. In other words, the value of a list data now depends on its\nhistory, that is on the sequence of function calls that use the value.\nThis strange behaviour leads to a lot of difficulties when explicitly\nmanipulating pointers. Try for instance, the seemingly harmless:</p>\n<pre><code class="language-ocaml"># append l1 l1\n- : unit = ()\n</code></pre>\n<p>Then evaluate <code>l1</code>:</p>\n<pre><code class="language-ocaml"># l1\n- : ilist =\nPointer\n {contents =\n   {hd = 1;\n    tl =\n     Pointer\n      {contents = {hd = 2; tl = Pointer {contents = {hd = 3; tl = &lt;cycle&gt;}}}}}}\n</code></pre>\n<h2 id="polymorphic-lists">Polymorphic lists</h2>\n<p>We can define polymorphic lists using pointers; here is a simple implementation\nof those polymorphic mutable lists:</p>\n<pre><code class="language-ocaml"># type \'a lists = \'a cell pointer\n  and \'a cell = { mutable hd : \'a pointer; mutable tl : \'a lists }\ntype \'a lists = \'a cell pointer\nand \'a cell = { mutable hd : \'a pointer; mutable tl : \'a lists; }\n# let new_cell () = {hd = Null; tl = Null}\nval new_cell : unit -&gt; \'a cell = &lt;fun&gt;\n# let cons x l =\n    let c = new_cell () in\n    c.hd &lt;- new_pointer x;\n    c.tl &lt;- l;\n    (new_pointer c : \'a lists)\nval cons : \'a -&gt; \'a lists -&gt; \'a lists = &lt;fun&gt;\n# let hd (l : \'a lists) = !^l.hd\nval hd : \'a lists -&gt; \'a pointer = &lt;fun&gt;\n# let tl (l : \'a lists) = !^l.tl\nval tl : \'a lists -&gt; \'a lists = &lt;fun&gt;\n# let append (l1 : \'a lists) (l2 : \'a lists) =\n  let temp = ref l1 in\n  while tl !temp &lt;&gt; Null do\n    temp := tl !temp\n  done;\n  !^ !temp.tl &lt;- l2\nval append : \'a lists -&gt; \'a lists -&gt; unit = &lt;fun&gt;\n</code></pre>\n'},tl:{hd:{title:"Null Pointers, Asserts and Warnings",slug:"null-pointers-asserts-and-warnings",description:"Handling warnings and asserting invariants for your code\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"language",tl:0},users:{hd:"Intermediate",tl:{hd:"Advanced",tl:0}},body_md:'\n## Null pointers\nSo you\'ve got a survey on your website which asks your readers for their\nnames and ages. Only problem is that for some reason a few of your\nreaders don\'t want to give you their age - they stubbornly refuse to\nfill that field in. What\'s a poor database administrator to do?\n\nAssume that the age is represented by an `int`, there are two possible\nways to solve this problem. The most common one (and the most *wrong*\none) is to assume some sort of "special" value for the age which means\nthat the age information wasn\'t collected. So if, say, age = -1 then the\ndata wasn\'t collected, otherwise the data was collected (even if it\'s\nnot valid!). This method kind of works until you start, for example,\ncalculating the mean age of visitors to your website. Since you forgot\nto take into account your special value, you conclude that the mean age\nof visitors is 7\xbd years old, and you employ web designers to remove all\nthe long words and use primary colours everywhere.\n\nThe other, correct method is to store the age in a field which has type\n"int or null". Here\'s a SQL table for storing ages:\n\n```SQL\ncreate table users\n(\n  userid serial,\n  name text not null,\n  age int             -- may be null\n);\n```\n\nIf the age data isn\'t collected, then it goes into the database as a\nspecial SQL `NULL` value. SQL ignores this automatically when you ask it\nto compute averages and so on.\n\nProgramming languages also support nulls, although they may be easier to\nuse in some than in others. In Java, any reference to\nan object can be null, so it might make sense in Java to store the\nage as an `Integer` and allow references to the age to be null. In C\npointers can, of course, be null, but if you wanted a simple integer to\nbe null, you\'d have to first box it up into an object allocated by\n`malloc` on the heap.\n\nOCaml has an elegant solution to the problem of nulls, using a simple\npolymorphic variant type defined (in `Stdlib`) as:\n\n```ocaml\ntype \'a option = None | Some of \'a\n```\n\nA "null pointer" is written `None`. The type of age in our example above\n(an `int` which can be null) is `int option` (remember: backwards like\n`int list` and `int binary_tree`).\n\n```ocaml\n# Some 3\n- : int option = Some 3\n```\n\nWhat about a list of optional ints?\n\n```ocaml\n# [None; Some 3; Some 6; None]\n- : int option list = [None; Some 3; Some 6; None]\n```\nAnd what about an optional list of ints?\n\n```ocaml\n# Some [1; 2; 3]\n- : int list option = Some [1; 2; 3]\n```\n\n## Assert, warnings, fatal errors, and printing to stderr\nThe built-in `assert` takes an expression as an argument and throws an\nexception *if* the provided expression evaluates to `false`. \nAssuming that you don\'t catch this exception (it\'s probably\nunwise to catch this exception, particularly for beginners), this\nresults in the program stopping and printing out the source file and\nline number where the error occurred. An example:\n\n```ocaml\n# assert (Sys.os_type = "Win32")\nException: Assert_failure ("//toplevel//", 1, 1).\n```\n\n(Running this on Win32, of course, won\'t throw an error).\n\nYou can also just call `assert false` to stop your program if things\njust aren\'t going well, but you\'re probably better to use ...\n\n`failwith "error message"` throws a `Failure` exception, which again\nassuming you don\'t try to catch it, will stop the program with the given\nerror message. `failwith` is often used during pattern matching, like\nthis real example:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmatch Sys.os_type with\n| "Unix" | "Cygwin" ->   (* code omitted *)\n| "Win32" ->             (* code omitted *)\n| "MacOS" ->             (* code omitted *)\n| _ -> failwith "this system is not supported"\n```\n\nNote a couple of extra pattern matching features in this example too. A\nso-called "range pattern" is used to match either `"Unix"` or\n`"Cygwin"`, and the special `_` pattern which matches "anything else".\n\nIf you want to debug your program, then you\'ll probably want to print out a\nwarning some way through your function. Here\'s an example:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nopen Graphics\n  \nlet () =\n  open_graph " 640x480";\n  for i = 12 downto 1 do\n    let radius = i * 20 in\n    prerr_endline ("radius is " ^ string_of_int radius);\n    set_color (if i mod 2 = 0 then red else yellow);\n    fill_circle 320 240 radius\n  done;\n  ignore(read_line ())\n```\n\nIf you prefer C-style `printf`\'s then try using OCaml\'s `Printf` module\ninstead:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nopen Graphics\n  \nlet () =\n  open_graph " 640x480";\n  for i = 12 downto 1 do\n    let radius = i * 20 in\n    Printf.eprintf "radius is %d\\n" radius;\n    set_color (if i mod 2 = 0 then red else yellow);\n    fill_circle 320 240 radius\n  done;\n  ignore(read_line ())\n```\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#null-pointers">Null pointers</a>\n</li>\n<li><a href="#assert-warnings-fatal-errors-and-printing-to-stderr">Assert, warnings, fatal errors, and printing to stderr</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="null-pointers">Null pointers</h2>\n<p>So you\'ve got a survey on your website which asks your readers for their\nnames and ages. Only problem is that for some reason a few of your\nreaders don\'t want to give you their age - they stubbornly refuse to\nfill that field in. What\'s a poor database administrator to do?</p>\n<p>Assume that the age is represented by an <code>int</code>, there are two possible\nways to solve this problem. The most common one (and the most <em>wrong</em>\none) is to assume some sort of &quot;special&quot; value for the age which means\nthat the age information wasn\'t collected. So if, say, age = -1 then the\ndata wasn\'t collected, otherwise the data was collected (even if it\'s\nnot valid!). This method kind of works until you start, for example,\ncalculating the mean age of visitors to your website. Since you forgot\nto take into account your special value, you conclude that the mean age\nof visitors is 7\xbd years old, and you employ web designers to remove all\nthe long words and use primary colours everywhere.</p>\n<p>The other, correct method is to store the age in a field which has type\n&quot;int or null&quot;. Here\'s a SQL table for storing ages:</p>\n<pre><code class="language-SQL">create table users\n(\n  userid serial,\n  name text not null,\n  age int             -- may be null\n);\n</code></pre>\n<p>If the age data isn\'t collected, then it goes into the database as a\nspecial SQL <code>NULL</code> value. SQL ignores this automatically when you ask it\nto compute averages and so on.</p>\n<p>Programming languages also support nulls, although they may be easier to\nuse in some than in others. In Java, any reference to\nan object can be null, so it might make sense in Java to store the\nage as an <code>Integer</code> and allow references to the age to be null. In C\npointers can, of course, be null, but if you wanted a simple integer to\nbe null, you\'d have to first box it up into an object allocated by\n<code>malloc</code> on the heap.</p>\n<p>OCaml has an elegant solution to the problem of nulls, using a simple\npolymorphic variant type defined (in <code>Stdlib</code>) as:</p>\n<pre><code class="language-ocaml">type \'a option = None | Some of \'a\n</code></pre>\n<p>A &quot;null pointer&quot; is written <code>None</code>. The type of age in our example above\n(an <code>int</code> which can be null) is <code>int option</code> (remember: backwards like\n<code>int list</code> and <code>int binary_tree</code>).</p>\n<pre><code class="language-ocaml"># Some 3\n- : int option = Some 3\n</code></pre>\n<p>What about a list of optional ints?</p>\n<pre><code class="language-ocaml"># [None; Some 3; Some 6; None]\n- : int option list = [None; Some 3; Some 6; None]\n</code></pre>\n<p>And what about an optional list of ints?</p>\n<pre><code class="language-ocaml"># Some [1; 2; 3]\n- : int list option = Some [1; 2; 3]\n</code></pre>\n<h2 id="assert-warnings-fatal-errors-and-printing-to-stderr">Assert, warnings, fatal errors, and printing to stderr</h2>\n<p>The built-in <code>assert</code> takes an expression as an argument and throws an\nexception <em>if</em> the provided expression evaluates to <code>false</code>.\nAssuming that you don\'t catch this exception (it\'s probably\nunwise to catch this exception, particularly for beginners), this\nresults in the program stopping and printing out the source file and\nline number where the error occurred. An example:</p>\n<pre><code class="language-ocaml"># assert (Sys.os_type = &quot;Win32&quot;)\nException: Assert_failure (&quot;//toplevel//&quot;, 1, 1).\n</code></pre>\n<p>(Running this on Win32, of course, won\'t throw an error).</p>\n<p>You can also just call <code>assert false</code> to stop your program if things\njust aren\'t going well, but you\'re probably better to use ...</p>\n<p><code>failwith &quot;error message&quot;</code> throws a <code>Failure</code> exception, which again\nassuming you don\'t try to catch it, will stop the program with the given\nerror message. <code>failwith</code> is often used during pattern matching, like\nthis real example:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">match Sys.os_type with\n| &quot;Unix&quot; | &quot;Cygwin&quot; -&gt;   (* code omitted *)\n| &quot;Win32&quot; -&gt;             (* code omitted *)\n| &quot;MacOS&quot; -&gt;             (* code omitted *)\n| _ -&gt; failwith &quot;this system is not supported&quot;\n</code></pre>\n<p>Note a couple of extra pattern matching features in this example too. A\nso-called &quot;range pattern&quot; is used to match either <code>&quot;Unix&quot;</code> or\n<code>&quot;Cygwin&quot;</code>, and the special <code>_</code> pattern which matches &quot;anything else&quot;.</p>\n<p>If you want to debug your program, then you\'ll probably want to print out a\nwarning some way through your function. Here\'s an example:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">open Graphics\n  \nlet () =\n  open_graph &quot; 640x480&quot;;\n  for i = 12 downto 1 do\n    let radius = i * 20 in\n    prerr_endline (&quot;radius is &quot; ^ string_of_int radius);\n    set_color (if i mod 2 = 0 then red else yellow);\n    fill_circle 320 240 radius\n  done;\n  ignore(read_line ())\n</code></pre>\n<p>If you prefer C-style <code>printf</code>\'s then try using OCaml\'s <code>Printf</code> module\ninstead:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">open Graphics\n  \nlet () =\n  open_graph &quot; 640x480&quot;;\n  for i = 12 downto 1 do\n    let radius = i * 20 in\n    Printf.eprintf &quot;radius is %d\\n&quot; radius;\n    set_color (if i mod 2 = 0 then red else yellow);\n    fill_circle 320 240 radius\n  done;\n  ignore(read_line ())\n</code></pre>\n'},tl:{hd:{title:"Functors",slug:"functors",description:"Learn about functors, modules parameterised by other modules\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"language",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:"\nFunctors are probably one of the most complex features of OCaml, but you don't\nhave to use them extensively to be a successful OCaml programmer.  Actually,\nyou may never have to define a functor yourself, but you will surely encounter\nthem in the standard library. They are the only way of using the Set and Map\nmodules, but using them is not so difficult.\n\n##  What are functors and why do we need them?\n\nA functor is a module that is parametrized by another module, just like a\nfunction is a value which is parametrized by other values, the arguments.\n\nIt allows one to parametrize a type by a value, which is not possible directly\nin OCaml without functors. For example, we can define a functor that takes an\nint n and returns a collection of array operations that work exclusively on\narrays of length n. If by mistake the programmer passes a regular array to one\nof those functions, it will result in a compilation error. If we were not using\nthis functor but the standard array type, the compiler would not be able to\ndetect the error, and we would get a runtime error at some undetermined date in\nthe future, which is much worse.\n\n##  Using an existing functor\n\nThe standard library defines a `Set` module, which provides a `Make` functor.\nThis functor takes one argument, which is a module that provides (at least) two\nthings: the type of elements, given as `t` and the comparison function given as\n`compare`. The point of the functor is to ensure that the same comparison\nfunction will always be used, even if the programmer makes a mistake.\n\nFor example, if we want to use sets of ints, we would do this:\n\n```ocaml\n# module Int_set =\n  Set.Make (struct\n              type t = int\n              let compare = compare\n            end)\nmodule Int_set :\n  sig\n    type elt = int\n    type t\n    val empty : t\n    val is_empty : t -> bool\n    val mem : int -> t -> bool\n    val add : int -> t -> t\n    val singleton : int -> t\n    val remove : int -> t -> t\n    val union : t -> t -> t\n    val inter : t -> t -> t\n    val disjoint : t -> t -> bool\n    val diff : t -> t -> t\n    val compare : t -> t -> int\n    val equal : t -> t -> bool\n    val subset : t -> t -> bool\n    val iter : (int -> unit) -> t -> unit\n    val map : (int -> int) -> t -> t\n    val fold : (int -> 'a -> 'a) -> t -> 'a -> 'a\n    val for_all : (int -> bool) -> t -> bool\n    val exists : (int -> bool) -> t -> bool\n    val filter : (int -> bool) -> t -> t\n    val partition : (int -> bool) -> t -> t * t\n    val cardinal : t -> int\n    val elements : t -> int list\n    val min_elt : t -> int\n    val min_elt_opt : t -> int option\n    val max_elt : t -> int\n    val max_elt_opt : t -> int option\n    val choose : t -> int\n    val choose_opt : t -> int option\n    val split : int -> t -> t * bool * t\n    val find : int -> t -> int\n    val find_opt : int -> t -> int option\n    val find_first : (int -> bool) -> t -> int\n    val find_first_opt : (int -> bool) -> t -> int option\n    val find_last : (int -> bool) -> t -> int\n    val find_last_opt : (int -> bool) -> t -> int option\n    val of_list : int list -> t\n    val to_seq_from : int -> t -> int Seq.t\n    val to_seq : t -> int Seq.t\n    val add_seq : int Seq.t -> t -> t\n    val of_seq : int Seq.t -> t\n  end\n```\n\nFor sets of strings, it is even easier because the standard library provides a\n`String` module with a type `t` and a function `compare`. If you were following\ncarefully, by now you must have guessed how to create a module for the\nmanipulation of sets of strings:\n\n```ocaml\n# module String_set = Set.Make (String)\nmodule String_set :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -> bool\n    val mem : elt -> t -> bool\n    val add : elt -> t -> t\n    val singleton : elt -> t\n    val remove : elt -> t -> t\n    val union : t -> t -> t\n    val inter : t -> t -> t\n    val disjoint : t -> t -> bool\n    val diff : t -> t -> t\n    val compare : t -> t -> int\n    val equal : t -> t -> bool\n    val subset : t -> t -> bool\n    val iter : (elt -> unit) -> t -> unit\n    val map : (elt -> elt) -> t -> t\n    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a\n    val for_all : (elt -> bool) -> t -> bool\n    val exists : (elt -> bool) -> t -> bool\n    val filter : (elt -> bool) -> t -> t\n    val partition : (elt -> bool) -> t -> t * t\n    val cardinal : t -> int\n    val elements : t -> elt list\n    val min_elt : t -> elt\n    val min_elt_opt : t -> elt option\n    val max_elt : t -> elt\n    val max_elt_opt : t -> elt option\n    val choose : t -> elt\n    val choose_opt : t -> elt option\n    val split : elt -> t -> t * bool * t\n    val find : elt -> t -> elt\n    val find_opt : elt -> t -> elt option\n    val find_first : (elt -> bool) -> t -> elt\n    val find_first_opt : (elt -> bool) -> t -> elt option\n    val find_last : (elt -> bool) -> t -> elt\n    val find_last_opt : (elt -> bool) -> t -> elt option\n    val of_list : elt list -> t\n    val to_seq_from : elt -> t -> elt Seq.t\n    val to_seq : t -> elt Seq.t\n    val add_seq : elt Seq.t -> t -> t\n    val of_seq : elt Seq.t -> t\n  end\n```\n\n(the parentheses are necessary)\n\n##  Defining functors\n\nA functor with one argument can be defined like this:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmodule F (X : X_type) = struct\n  ...\nend\n```\n\nwhere `X` is the module that will be passed as argument, and `X_type` is its\nsignature, which is mandatory.\n\nThe signature of the returned module itself can be constrained, using this\nsyntax:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmodule F (X : X_type) : Y_type =\nstruct\n  ...\nend\n```\n\nor by specifying this in the .mli file:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmodule F (X : X_type) : Y_type\n```\n\nOverall, the syntax of functors is hard to grasp. The best may be to look at\nthe source files\n[`set.ml`](https://github.com/ocaml/ocaml/blob/trunk/stdlib/set.ml) or\n[`map.ml`](https://github.com/ocaml/ocaml/blob/trunk/stdlib/map.ml) of the\nstandard library.\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#what-are-functors-and-why-do-we-need-them">What are functors and why do we need them?</a>\n</li>\n<li><a href="#using-an-existing-functor">Using an existing functor</a>\n</li>\n<li><a href="#defining-functors">Defining functors</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>Functors are probably one of the most complex features of OCaml, but you don\'t\nhave to use them extensively to be a successful OCaml programmer.  Actually,\nyou may never have to define a functor yourself, but you will surely encounter\nthem in the standard library. They are the only way of using the Set and Map\nmodules, but using them is not so difficult.</p>\n<h2 id="what-are-functors-and-why-do-we-need-them">What are functors and why do we need them?</h2>\n<p>A functor is a module that is parametrized by another module, just like a\nfunction is a value which is parametrized by other values, the arguments.</p>\n<p>It allows one to parametrize a type by a value, which is not possible directly\nin OCaml without functors. For example, we can define a functor that takes an\nint n and returns a collection of array operations that work exclusively on\narrays of length n. If by mistake the programmer passes a regular array to one\nof those functions, it will result in a compilation error. If we were not using\nthis functor but the standard array type, the compiler would not be able to\ndetect the error, and we would get a runtime error at some undetermined date in\nthe future, which is much worse.</p>\n<h2 id="using-an-existing-functor">Using an existing functor</h2>\n<p>The standard library defines a <code>Set</code> module, which provides a <code>Make</code> functor.\nThis functor takes one argument, which is a module that provides (at least) two\nthings: the type of elements, given as <code>t</code> and the comparison function given as\n<code>compare</code>. The point of the functor is to ensure that the same comparison\nfunction will always be used, even if the programmer makes a mistake.</p>\n<p>For example, if we want to use sets of ints, we would do this:</p>\n<pre><code class="language-ocaml"># module Int_set =\n  Set.Make (struct\n              type t = int\n              let compare = compare\n            end)\nmodule Int_set :\n  sig\n    type elt = int\n    type t\n    val empty : t\n    val is_empty : t -&gt; bool\n    val mem : int -&gt; t -&gt; bool\n    val add : int -&gt; t -&gt; t\n    val singleton : int -&gt; t\n    val remove : int -&gt; t -&gt; t\n    val union : t -&gt; t -&gt; t\n    val inter : t -&gt; t -&gt; t\n    val disjoint : t -&gt; t -&gt; bool\n    val diff : t -&gt; t -&gt; t\n    val compare : t -&gt; t -&gt; int\n    val equal : t -&gt; t -&gt; bool\n    val subset : t -&gt; t -&gt; bool\n    val iter : (int -&gt; unit) -&gt; t -&gt; unit\n    val map : (int -&gt; int) -&gt; t -&gt; t\n    val fold : (int -&gt; \'a -&gt; \'a) -&gt; t -&gt; \'a -&gt; \'a\n    val for_all : (int -&gt; bool) -&gt; t -&gt; bool\n    val exists : (int -&gt; bool) -&gt; t -&gt; bool\n    val filter : (int -&gt; bool) -&gt; t -&gt; t\n    val partition : (int -&gt; bool) -&gt; t -&gt; t * t\n    val cardinal : t -&gt; int\n    val elements : t -&gt; int list\n    val min_elt : t -&gt; int\n    val min_elt_opt : t -&gt; int option\n    val max_elt : t -&gt; int\n    val max_elt_opt : t -&gt; int option\n    val choose : t -&gt; int\n    val choose_opt : t -&gt; int option\n    val split : int -&gt; t -&gt; t * bool * t\n    val find : int -&gt; t -&gt; int\n    val find_opt : int -&gt; t -&gt; int option\n    val find_first : (int -&gt; bool) -&gt; t -&gt; int\n    val find_first_opt : (int -&gt; bool) -&gt; t -&gt; int option\n    val find_last : (int -&gt; bool) -&gt; t -&gt; int\n    val find_last_opt : (int -&gt; bool) -&gt; t -&gt; int option\n    val of_list : int list -&gt; t\n    val to_seq_from : int -&gt; t -&gt; int Seq.t\n    val to_seq : t -&gt; int Seq.t\n    val add_seq : int Seq.t -&gt; t -&gt; t\n    val of_seq : int Seq.t -&gt; t\n  end\n</code></pre>\n<p>For sets of strings, it is even easier because the standard library provides a\n<code>String</code> module with a type <code>t</code> and a function <code>compare</code>. If you were following\ncarefully, by now you must have guessed how to create a module for the\nmanipulation of sets of strings:</p>\n<pre><code class="language-ocaml"># module String_set = Set.Make (String)\nmodule String_set :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -&gt; bool\n    val mem : elt -&gt; t -&gt; bool\n    val add : elt -&gt; t -&gt; t\n    val singleton : elt -&gt; t\n    val remove : elt -&gt; t -&gt; t\n    val union : t -&gt; t -&gt; t\n    val inter : t -&gt; t -&gt; t\n    val disjoint : t -&gt; t -&gt; bool\n    val diff : t -&gt; t -&gt; t\n    val compare : t -&gt; t -&gt; int\n    val equal : t -&gt; t -&gt; bool\n    val subset : t -&gt; t -&gt; bool\n    val iter : (elt -&gt; unit) -&gt; t -&gt; unit\n    val map : (elt -&gt; elt) -&gt; t -&gt; t\n    val fold : (elt -&gt; \'a -&gt; \'a) -&gt; t -&gt; \'a -&gt; \'a\n    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool\n    val exists : (elt -&gt; bool) -&gt; t -&gt; bool\n    val filter : (elt -&gt; bool) -&gt; t -&gt; t\n    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t\n    val cardinal : t -&gt; int\n    val elements : t -&gt; elt list\n    val min_elt : t -&gt; elt\n    val min_elt_opt : t -&gt; elt option\n    val max_elt : t -&gt; elt\n    val max_elt_opt : t -&gt; elt option\n    val choose : t -&gt; elt\n    val choose_opt : t -&gt; elt option\n    val split : elt -&gt; t -&gt; t * bool * t\n    val find : elt -&gt; t -&gt; elt\n    val find_opt : elt -&gt; t -&gt; elt option\n    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt\n    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option\n    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt\n    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option\n    val of_list : elt list -&gt; t\n    val to_seq_from : elt -&gt; t -&gt; elt Seq.t\n    val to_seq : t -&gt; elt Seq.t\n    val add_seq : elt Seq.t -&gt; t -&gt; t\n    val of_seq : elt Seq.t -&gt; t\n  end\n</code></pre>\n<p>(the parentheses are necessary)</p>\n<h2 id="defining-functors">Defining functors</h2>\n<p>A functor with one argument can be defined like this:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">module F (X : X_type) = struct\n  ...\nend\n</code></pre>\n<p>where <code>X</code> is the module that will be passed as argument, and <code>X_type</code> is its\nsignature, which is mandatory.</p>\n<p>The signature of the returned module itself can be constrained, using this\nsyntax:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">module F (X : X_type) : Y_type =\nstruct\n  ...\nend\n</code></pre>\n<p>or by specifying this in the .mli file:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">module F (X : X_type) : Y_type\n</code></pre>\n<p>Overall, the syntax of functors is hard to grasp. The best may be to look at\nthe source files\n<a href="https://github.com/ocaml/ocaml/blob/trunk/stdlib/set.ml"><code>set.ml</code></a> or\n<a href="https://github.com/ocaml/ocaml/blob/trunk/stdlib/map.ml"><code>map.ml</code></a> of the\nstandard library.</p>\n'},tl:{hd:{title:"Objects",slug:"objects",description:"OCaml is an object-oriented, imperative, functional programming language\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"language",tl:0},users:{hd:"Intermediate",tl:{hd:"Advanced",tl:0}},body_md:"\n## Objects and classes\nOCaml is an object-oriented, imperative, functional programming language\n:-) It mixes all these paradigms and lets you use the most appropriate\n(or most familiar) programming paradigm for the task at hand. In this\nchapter I'm going to look at object-oriented programming in OCaml, but\nI'm also going to talk about why you might or might not want to write\nobject-oriented programs.\n\nThe classic noddy example used in text books to demonstrate\nobject-oriented programming is the stack class. This is a pretty\nterrible example in many ways, but I'm going to use it here to show the\nbasics of writing object-oriented OCaml.\n\nHere's some basic code to provide a stack of integers. The class is\nimplemented using a linked list.\n\n```ocaml\n# class stack_of_ints =\n  object (self)\n    val mutable the_list = ([] : int list)     (* instance variable *)\n    method push x =                            (* push method *)\n      the_list <- x :: the_list\n    method pop =                               (* pop method *)\n      let result = List.hd the_list in\n      the_list <- List.tl the_list;\n      result\n    method peek =                              (* peek method *)\n      List.hd the_list\n    method size =                              (* size method *)\n      List.length the_list\n  end\nclass stack_of_ints :\n  object\n    val mutable the_list : int list\n    method peek : int\n    method pop : int\n    method push : int -> unit\n    method size : int\n  end\n```\n\nThe basic pattern `class name = object (self) ... end` defines a class\ncalled `name`.\n\nThe class has one instance variable, which is mutable (not constant),\ncalled `the_list`. This is the underlying linked list. We initialize\nthis (each time a `stack_of_ints` object is created) using a bit of code\nthat you may not be familiar with. The expression `( [] : int list )`\nmeans \"an empty list, of type `int list`\". Recall that the simple empty\nlist `[]` has type `'a list`, meaning a list of any type. However we\nwant a stack of `int`, not anything else, and so in this case we want to\ntell the type inference engine that this list isn't the general \"list of\nanything\" but is in fact the narrower \"list of `int`\". The syntax\n`( expression : type )` means `expression` which is in fact of type\n`type`. This *isn't* a general type cast, because you can't use it to\noverrule the type inference engine, only to narrow a general type to\nmake it more specific. So you can't write, for example, `( 1 : float )`:\n\n```ocaml\n# (1 : float)\nLine 1, characters 2-3:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.'?\n```\n\nType safety is preserved. Back to the example ...\n\nThis class has four simple methods. `push` pushes an integer onto the\nstack. `pop` pops the top integer off the stack and returns it. Notice\nthe `<-` assignment operator used for updating our mutable instance\nvariable. It's the same `<-` assignment operator which is used for\nupdating mutable fields in records.\n\n`peek` returns the top of the stack (ie. head of the list) without\naffecting the stack, while `size` returns the number of elements in the\nstack (ie. the length of the list).\n\nLet's write some code to test stacks of ints. First let's create a new\nobject. We use the familiar `new` operator:\n\n```ocaml\n# let s = new stack_of_ints\nval s : stack_of_ints = <obj>\n```\nNow we'll push and pop some elements off the stack:\n\n```ocaml\n# for i = 1 to 10 do\n    s#push i\n  done\n- : unit = ()\n# while s#size > 0 do\n    Printf.printf \"Popped %d off the stack.\\n\" s#pop\n  done\nPopped 10 off the stack.\nPopped 9 off the stack.\nPopped 8 off the stack.\nPopped 7 off the stack.\nPopped 6 off the stack.\nPopped 5 off the stack.\nPopped 4 off the stack.\nPopped 3 off the stack.\nPopped 2 off the stack.\nPopped 1 off the stack.\n- : unit = ()\n```\nNotice the syntax. `object#method` means call `method` on `object`. This\nis the same as `object.method` or `object->method` that you will be\nfamiliar with in imperative languages.\n\nIn the OCaml toplevel we can examine the types of objects and methods in\nmore detail:\n\n```ocaml\n# let s = new stack_of_ints\nval s : stack_of_ints = <obj>\n# s#push\n- : int -> unit = <fun>\n```\n\n`s` is an opaque object. The implementation (ie. the list) is hidden\nfrom callers.\n\n###  Polymorphic classes\nA stack of integers is good, but what about a stack that can store any\ntype? (Not a single stack that can store a mixture of types, but\nmultiple stacks each storing objects of any single type). As with\n`'a list`, we can define `'a stack`:\n\n```ocaml\n# class ['a] stack =\n  object (self)\n    val mutable list = ([] : 'a list)    (* instance variable *)\n    method push x =                      (* push method *)\n      list <- x :: list\n    method pop =                         (* pop method *)\n      let result = List.hd list in\n      list <- List.tl list;\n      result\n    method peek =                        (* peek method *)\n      List.hd list\n    method size =                        (* size method *)\n      List.length list\n  end\nclass ['a] stack :\n  object\n    val mutable list : 'a list\n    method peek : 'a\n    method pop : 'a\n    method push : 'a -> unit\n    method size : int\n  end\n```\nThe `class ['a] stack` doesn't really define just one class, but a whole\n\"class of classes\", one for every possible type (ie. an infinitely large\nnumber of classes!) Let's try and use our `'a stack` class. In this\ninstance we create a stack and push a floating point number onto the\nstack. Notice the type of the stack:\n\n```ocaml\n# let s = new stack\nval s : '_weak1 stack = <obj>\n# s#push 1.0\n- : unit = ()\n# s\n- : float stack = <obj>\n```\n\nThis stack is now a `float stack`, and only floating point numbers may\nbe pushed and popped from this stack. Let's demonstrate the type-safety\nof our new `float stack`:\n\n```ocaml\n# s#push 3.0\n- : unit = ()\n# s#pop\n- : float = 3.\n# s#pop\n- : float = 1.\n# s#push \"a string\"\nLine 1, characters 8-18:\nError: This expression has type string but an expression was expected of type\n         float\n```\n\nWe can define polymorphic functions which can operate on any type of\nstack. Our first attempt is this one:\n\n```ocaml\n# let drain_stack s =\n  while s#size > 0 do\n    ignore (s#pop)\n  done\nval drain_stack : < pop : 'a; size : int; .. > -> unit = <fun>\n```\n\nNotice the type of `drain_stack`. Cleverly - perhaps *too* cleverly -\nOCaml's type inference engine has worked out that `drain_stack` works on\n*any* object which has `pop` and `size` methods! So if we defined\nanother, entirely separate class which happened to contain `pop` and\n`size` methods with suitable type signatures, then we might accidentally\ncall `drain_stack` on objects of that other type.\n\nWe can force OCaml to be more specific and only allow `drain_stack` to\nbe called on `'a stack`s by narrowing the type of the `s` argument, like\nthis:\n\n```ocaml\n# let drain_stack (s : 'a stack) =\n  while s#size > 0 do\n    ignore (s#pop)\n  done\nval drain_stack : 'a stack -> unit = <fun>\n```\n\n###  Inheritance, virtual classes, initializers\nI've noticed programmers in Java tend to overuse inheritance, possibly\nbecause it's the only reasonable way of extending code in that language.\nA much better and more general way to extend code is usually to use\nhooks (cf. Apache's module API). Nevertheless in certain narrow areas\ninheritance can be useful, and the most important of these is in writing\nGUI widget libraries.\n\nLet's consider an imaginary OCaml widget library similar to Java's\nSwing. We will define buttons and labels with the following class\nhierarchy:\n\n```\nwidget  (superclass for all widgets)\n  |\n  +----\x3e container  (any widget that can contain other widgets)\n  |        |\n  |        +----\x3e button\n  |\n  +-------------\x3e label\n```\n(Notice that a `button` is a `container` because it can contain either a\nlabel or an image, depending on what is displayed on the button).\n\n`widget` is the virtual superclass for all widgets. I want every widget\nto have a name (just a string) which is constant over the life of that\nwidget. This was my first attempt:\n\n```ocaml\n# class virtual widget name =\n  object (self)\n    method get_name =\n      name\n    method virtual repaint : unit\n  end\nLines 1-6, characters 1-6:\nError: Some type variables are unbound in this type:\n         class virtual widget :\n           'a ->\n           object method get_name : 'a method virtual repaint : unit end\n       The method get_name has type 'a where 'a is unbound\n```\nOops! I forgot that OCaml cannot infer the type of `name` so will assume\nthat it is `'a`. But that defines a polymorphic class, and I didn't\ndeclare the class as polymorphic (`class ['a] widget`). I need to narrow\nthe type of `name` like this:\n\n```ocaml\n# class virtual widget (name : string) =\n  object (self)\n    method get_name =\n      name\n    method virtual repaint : unit\n  end;;\nclass virtual widget :\n  string -> object method get_name : string method virtual repaint : unit end\n```\nNow there are several new things going on in this code. Firstly the\nclass contains an **initializer**. This is an argument to the class\n(`name`) which you can think of as exactly the equivalent of an argument\nto a constructor in, eg., Java:\n\n```java\npublic class Widget\n{\n  public Widget (String name)\n  {\n    ...\n  }\n}\n```\nIn OCaml a constructor constructs the whole class, it's not just a\nspecially named function, so we write the arguments as if they are\narguments to the class:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nclass foo arg1 arg2 ... =\n```\n\nSecondly the class contains a virtual method, and thus the whole class\nis marked as virtual. The virtual method is our `repaint` method. We\nneed to tell OCaml it's virtual (`method virtual`), *and* we need to\ntell OCaml the type of the method. Because the method doesn't contain\nany code, OCaml can't use type inference to automatically work out the\ntype for you, so you need to tell it the type. In this case the method\njust returns `unit`. If your class contains any virtual methods (even\njust inherited ones) then you need to specify the whole class as virtual\nby using `class virtual ...`.\n\nAs in C++ and Java, virtual classes cannot be directly instantiated\nusing `new`:\n\n```ocaml\n# let w = new widget \"my widget\"\nLine 1, characters 9-19:\nError: Cannot instantiate the virtual class widget\n```\n\nNow my `container` class is more interesting. It must inherit from\n`widget` and have the mechanics for storing the list of contained\nwidgets. Here is my simple implementation for `container`:\n\n```ocaml\n# class virtual container name =\n  object (self)\n    inherit widget name\n    val mutable widgets = ([] : widget list)\n    method add w =\n      widgets <- w :: widgets\n    method get_widgets =\n      widgets\n    method repaint =\n      List.iter (fun w -> w#repaint) widgets\n  end\nclass virtual container :\n  string ->\n  object\n    val mutable widgets : widget list\n    method add : widget -> unit\n    method get_name : string\n    method get_widgets : widget list\n    method repaint : unit\n  end\n```\n\nNotes:\n\n1. The `container` class is marked as virtual. It doesn't contain any\n virtual methods, but in this case I just want to prevent people\n creating containers directly.\n1. The `container` class has a `name` argument which is passed directly\n up when constructing the `widget`.\n1. `inherit widget name` means that the `container` inherits from\n `widget`, and it passes the `name` argument to the constructor for\n `widget`.\n1. My `container` contains a mutable list of widgets and methods to\n `add` a widget to this list and `get_widgets` (return the list of\n widgets).\n1. The list of widgets returned by `get_widgets` cannot be modified by\n code outside the class. The reason for this is somewhat subtle, but\n basically comes down to the fact that OCaml's linked lists are\n immutable. Let's imagine that someone wrote this code:\n\n  ```ocaml\n  # let list = container#get_widgets in\n    x :: list\n  ```\n\nWould this modify the private internal representation of my `container`\nclass, by prepending `x` to the list of widgets? No it wouldn't. The\nprivate variable `widgets` would be unaffected by this or any other\nchange attempted by the outside code. This means, for example, that you\ncould change the internal representation to use an array at some later\ndate, and no code outside the class would need to be changed.\n\nLast, but not least, we have implemented the previously virtual\n`repaint` function so that `container#repaint` will repaint all of the\ncontained widgets. Notice I use `List.iter` to iterate over the list,\nand I also use a probably unfamiliar anonymous function expression:\n\n```ocaml\n# (fun w -> w#repaint)\n- : < repaint : 'a; .. > -> 'a = <fun>\n```\nwhich defines an anonymous function with one argument `w` that just\ncalls `w#repaint` (the `repaint` method on widget `w`).\n\nIn this instance our `button` class is simple (rather unrealistically\nsimple in fact, but nevermind that):\n\n```ocaml\n# type button_state = Released | Pressed\ntype button_state = Released | Pressed\n# class button ?callback name =\n  object (self)\n    inherit container name as super\n    val mutable state = Released\n    method press =\n      state <- Pressed;\n      match callback with\n      | None -> ()\n      | Some f -> f ()\n    method release =\n      state <- Released\n    method repaint =\n      super#repaint;\n      print_endline (\"Button being repainted, state is \" ^\n                     (match state with\n                      | Pressed -> \"Pressed\"\n                      | Released -> \"Released\"))\n  end\nclass button :\n  ?callback:(unit -> unit) ->\n  string ->\n  object\n    val mutable state : button_state\n    val mutable widgets : widget list\n    method add : widget -> unit\n    method get_name : string\n    method get_widgets : widget list\n    method press : unit\n    method release : unit\n    method repaint : unit\n  end\n```\n\nNotes:\n\n1. This function has an optional argument (see the previous chapter)\n which is used to pass in the optional callback function. The\n callback is called when the button is pressed.\n1. The expression `inherit container name as super` names the\n superclass `super`. I use this in the `repaint` method:\n `super#repaint`. This expressly calls the superclass method.\n1. Pressing the button (calling `button#press` in this rather\n simplistic code) sets the state of the button to `Pressed` and calls\n the callback function, if one was defined. Notice that the\n `callback` variable is either `None` or `Some f`, in other words it\n has type `(unit -> unit) option`. Reread the previous chapter if you\n are unsure about this.\n1. Notice a strange thing about the `callback` variable. It's defined\n as an argument to the class, but any method can see and use it. In\n other words, the variable is supplied when the object is\n constructed, but persists over the lifetime of the object.\n1. The `repaint` method has been implemented. It calls the superclass\n (to repaint the container), then repaints the button, displaying the\n current state of the button.\n\nBefore defining our `label` class, let's play with the `button` class in\nthe OCaml toplevel:\n\n```ocaml\n# let b = new button ~callback:(fun () -> print_endline \"Ouch!\") \"button\"\nval b : button = <obj>\n# b#repaint\nButton being repainted, state is Released\n- : unit = ()\n# b#press\nOuch!\n- : unit = ()\n# b#repaint\nButton being repainted, state is Pressed\n- : unit = ()\n# b#release\n- : unit = ()\n```\n\nHere's our comparatively trivial `label` class:\n\n```ocaml\n# class label name text =\n  object (self)\n    inherit widget name\n    method repaint =\n      print_endline (\"Label: \" ^ text)\n  end\nclass label :\n  string ->\n  string -> object method get_name : string method repaint : unit end\n```\nLet's create a label which says \"Press me!\" and add it to the button:\n\n```ocaml\n# let l = new label \"label\" \"Press me!\"\nval l : label = <obj>\n# b#add l\n- : unit = ()\n# b#repaint\nLabel: Press me!\nButton being repainted, state is Released\n- : unit = ()\n```\n\n###  A note about `self`\nIn all the examples above we defined classes using the general pattern:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nclass name =\n  object (self)\n    (* ... *)\n  end\n```\nI didn't explain the reference to `self`. In fact this names the object,\nallowing you to call methods in the same class or pass the object to\nfunctions outside the class. In other words, it's exactly the same as\n`this` in C++/Java. You may completely omit the\n`(self)` part if you don't need to refer to yourself - indeed in all the\nexamples above we could have done exactly that. However, I would advise\nyou to leave it in there because you never know when you might modify\nthe class and require the reference to `self`. There is no penalty for\nhaving it.\n\n###  Inheritance and coercions\n\n```ocaml\n# let b = new button \"button\"\nval b : button = <obj>\n# let l = new label \"label\" \"Press me!\"\nval l : label = <obj>\n# [b; l]\nLine 1, characters 5-6:\nError: This expression has type label but an expression was expected of type\n         button\n       The first object type has no method add\n```\nI created a button `b` and a label `l` and I tried to create a list\ncontaining both, but I got an error. Yet `b` and `l` are both `widget`s,\nso why can't I put them into the same list? Perhaps OCaml can't guess\nthat I want a `widget list`? Let's try telling it:\n\n```ocaml\n# let wl = ([] : widget list)\nval wl : widget list = []\n# let wl = b :: wl\nLine 1, characters 15-17:\nError: This expression has type widget list\n       but an expression was expected of type button list\n       Type widget = < get_name : string; repaint : unit >\n       is not compatible with type\n         button =\n           < add : widget -> unit; get_name : string;\n             get_widgets : widget list; press : unit; release : unit;\n             repaint : unit >\n       The first object type has no method add\n```\n\nIt turns out that OCaml doesn't coerce subclasses to the type of the\nsuperclass by default, but you can tell it to by using the `:>`\n(coercion) operator:\n\n```ocaml\n# let wl = (b :> widget) :: wl\nval wl : widget list = [<obj>]\n# let wl = (l :> widget) :: wl\nval wl : widget list = [<obj>; <obj>]\n```\n\nThe expression `(b :> widget)` means \"coerce the button `b` to have type\n`widget`\". Type-safety is preserved because it is possible to tell\ncompletely at compile time whether the coercion will succeed.\n\nActually, coercions are somewhat more subtle than described above, and\nso I urge you to read the manual to find out the full details.\n\nThe `container#add` method defined above is actually incorrect, and\nfails if you try to add widgets of different types into a `container`. A\ncoercion would fix this.\n\nIs it possible to coerce from a superclass (eg. `widget`) to a subclass\n(eg. `button`)? The answer, perhaps surprisingly, is NO! Coercing in\nthis direction is *unsafe*. You might try to coerce a `widget` which is\nin fact a `label`, not a `button`.\n\n###  The `Oo` module and comparing objects\nThe `Oo` module contains a few useful functions for OO programming.\n\n`Oo.copy` makes a shallow copy of an object. `Oo.id object` returns a\nunique identifying number for each object (a unique number across all\nclasses).\n\n`=` and `<>` can be used to compare objects for *physical* equality (an\nobject and its copy are not physically identical). You can also use `<`\netc. which provides an ordering of objects based apparently on their\nIDs.\n\n## Objects without class\nHere we examine how to use objects pretty much like records, without\nnecessarily using classes.\n\n###  Immediate objects and object types\nObjects can be used instead of records, and have some nice properties\nthat can make them preferable to records in some cases. We saw that the\ncanonical way of creating objects is to first define a class, and use\nthis class to create individual objects. This can be cumbersome in some\nsituations since class definitions are more than a type definition and\ncannot be defined recursively with types. However, objects have a type\nthat is very analog to a record type, and it can be used in type\ndefinitions. In addition, objects can be created without a class. They\nare called *immediate objects*. Here is the definition of an immediate\nobject:\n\n```ocaml\n# let o =\n  object\n    val mutable n = 0\n    method incr = n <- n + 1\n    method get = n\n  end\nval o : < get : int; incr : unit > = <obj>\n```\n\nThis object has a type, which is defined by its public methods only.\nValues are not visible and neither are private methods (not shown).\nUnlike records, such a type does not need to be predefined explicitly,\nbut doing so can make things clearer. We can do it like this:\n\n```ocaml\n# type counter = <get : int; incr : unit>\ntype counter = < get : int; incr : unit >\n```\nCompare with an equivalent record type definition:\n\n```ocaml\n# type counter_r =\n  {get : unit -> int;\n   incr : unit -> unit}\ntype counter_r = { get : unit -> int; incr : unit -> unit; }\n```\nThe implementation of a record working like our object would be:\n\n```ocaml\n# let r =\n  let n = ref 0 in\n    {get = (fun () -> !n);\n     incr = (fun () -> incr n)}\nval r : counter_r = {get = <fun>; incr = <fun>}\n```\nIn terms of functionality, both the object and the record are similar,\nbut each solution has its own advantages:\n\n* **speed**: slightly faster field access in records\n* **field names**: it is inconvenient to manipulate records of\n different types when some fields are named identically but it's not\n a problem with objects\n* **subtyping**: it is impossible to coerce the type of a record to a\n type with less fields. That is however possible with objects, so\n objects of different kinds that share some methods can be mixed in a\n data structure where only their common methods are visible (see next\n section)\n* **type definitions**: there is no need to define an object type in\n advance, so it lightens the dependency constraints between modules\n\n###  Class types vs. just types\nBeware of the confusion between *class types* and object *types*. A\n*class type* is not a data *type*, normally referred to as *type* in the\nOCaml jargon. An object *type* is a kind of data *type*, just like a\nrecord type or a tuple.\n\nWhen a class is defined, both a *class type* and an object *type* of the\nsame name are defined:\n\n```ocaml\n# class t =\n  object\n    val x = 0\n    method get = x\n  end\nclass t : object val x : int method get : int end\n```\n\n`object val x : int method get : int end` is a class type.\n\nIn this example, `t` is also the type of objects that this class would\ncreate. Objects that derive from different classes or no class at all\n(immediate objects) can be mixed together as long as they have the same\ntype:\n\n```ocaml\n# let x = object method get = 123 end\nval x : < get : int > = <obj>\n# let l = [new t; x]\nval l : t list = [<obj>; <obj>]\n```\n\nMixing objects that share a common subtype can be done, but requires\nexplicit type coercion using the `:>` operator:\n\n```ocaml\n# let x = object method get = 123 end\nval x : < get : int > = <obj>\n# let y = object method get = 80 method special = \"hello\" end\nval y : < get : int; special : string > = <obj>\n# let l = [x; y]\nLine 1, characters 13-14:\nError: This expression has type < get : int; special : string >\n       but an expression was expected of type < get : int >\n       The second object type has no method special\n# let l = [x; (y :> t)]\nval l : t list = [<obj>; <obj>]\n```\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#objects-and-classes">Objects and classes</a>\n</li>\n<li><a href="#objects-without-class">Objects without class</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="objects-and-classes">Objects and classes</h2>\n<p>OCaml is an object-oriented, imperative, functional programming language\n:-) It mixes all these paradigms and lets you use the most appropriate\n(or most familiar) programming paradigm for the task at hand. In this\nchapter I\'m going to look at object-oriented programming in OCaml, but\nI\'m also going to talk about why you might or might not want to write\nobject-oriented programs.</p>\n<p>The classic noddy example used in text books to demonstrate\nobject-oriented programming is the stack class. This is a pretty\nterrible example in many ways, but I\'m going to use it here to show the\nbasics of writing object-oriented OCaml.</p>\n<p>Here\'s some basic code to provide a stack of integers. The class is\nimplemented using a linked list.</p>\n<pre><code class="language-ocaml"># class stack_of_ints =\n  object (self)\n    val mutable the_list = ([] : int list)     (* instance variable *)\n    method push x =                            (* push method *)\n      the_list &lt;- x :: the_list\n    method pop =                               (* pop method *)\n      let result = List.hd the_list in\n      the_list &lt;- List.tl the_list;\n      result\n    method peek =                              (* peek method *)\n      List.hd the_list\n    method size =                              (* size method *)\n      List.length the_list\n  end\nclass stack_of_ints :\n  object\n    val mutable the_list : int list\n    method peek : int\n    method pop : int\n    method push : int -&gt; unit\n    method size : int\n  end\n</code></pre>\n<p>The basic pattern <code>class name = object (self) ... end</code> defines a class\ncalled <code>name</code>.</p>\n<p>The class has one instance variable, which is mutable (not constant),\ncalled <code>the_list</code>. This is the underlying linked list. We initialize\nthis (each time a <code>stack_of_ints</code> object is created) using a bit of code\nthat you may not be familiar with. The expression <code>( [] : int list )</code>\nmeans &quot;an empty list, of type <code>int list</code>&quot;. Recall that the simple empty\nlist <code>[]</code> has type <code>\'a list</code>, meaning a list of any type. However we\nwant a stack of <code>int</code>, not anything else, and so in this case we want to\ntell the type inference engine that this list isn\'t the general &quot;list of\nanything&quot; but is in fact the narrower &quot;list of <code>int</code>&quot;. The syntax\n<code>( expression : type )</code> means <code>expression</code> which is in fact of type\n<code>type</code>. This <em>isn\'t</em> a general type cast, because you can\'t use it to\noverrule the type inference engine, only to narrow a general type to\nmake it more specific. So you can\'t write, for example, <code>( 1 : float )</code>:</p>\n<pre><code class="language-ocaml"># (1 : float)\nLine 1, characters 2-3:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.\'?\n</code></pre>\n<p>Type safety is preserved. Back to the example ...</p>\n<p>This class has four simple methods. <code>push</code> pushes an integer onto the\nstack. <code>pop</code> pops the top integer off the stack and returns it. Notice\nthe <code>&lt;-</code> assignment operator used for updating our mutable instance\nvariable. It\'s the same <code>&lt;-</code> assignment operator which is used for\nupdating mutable fields in records.</p>\n<p><code>peek</code> returns the top of the stack (ie. head of the list) without\naffecting the stack, while <code>size</code> returns the number of elements in the\nstack (ie. the length of the list).</p>\n<p>Let\'s write some code to test stacks of ints. First let\'s create a new\nobject. We use the familiar <code>new</code> operator:</p>\n<pre><code class="language-ocaml"># let s = new stack_of_ints\nval s : stack_of_ints = &lt;obj&gt;\n</code></pre>\n<p>Now we\'ll push and pop some elements off the stack:</p>\n<pre><code class="language-ocaml"># for i = 1 to 10 do\n    s#push i\n  done\n- : unit = ()\n# while s#size &gt; 0 do\n    Printf.printf &quot;Popped %d off the stack.\\n&quot; s#pop\n  done\nPopped 10 off the stack.\nPopped 9 off the stack.\nPopped 8 off the stack.\nPopped 7 off the stack.\nPopped 6 off the stack.\nPopped 5 off the stack.\nPopped 4 off the stack.\nPopped 3 off the stack.\nPopped 2 off the stack.\nPopped 1 off the stack.\n- : unit = ()\n</code></pre>\n<p>Notice the syntax. <code>object#method</code> means call <code>method</code> on <code>object</code>. This\nis the same as <code>object.method</code> or <code>object-&gt;method</code> that you will be\nfamiliar with in imperative languages.</p>\n<p>In the OCaml toplevel we can examine the types of objects and methods in\nmore detail:</p>\n<pre><code class="language-ocaml"># let s = new stack_of_ints\nval s : stack_of_ints = &lt;obj&gt;\n# s#push\n- : int -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p><code>s</code> is an opaque object. The implementation (ie. the list) is hidden\nfrom callers.</p>\n<h3 id="polymorphic-classes">Polymorphic classes</h3>\n<p>A stack of integers is good, but what about a stack that can store any\ntype? (Not a single stack that can store a mixture of types, but\nmultiple stacks each storing objects of any single type). As with\n<code>\'a list</code>, we can define <code>\'a stack</code>:</p>\n<pre><code class="language-ocaml"># class [\'a] stack =\n  object (self)\n    val mutable list = ([] : \'a list)    (* instance variable *)\n    method push x =                      (* push method *)\n      list &lt;- x :: list\n    method pop =                         (* pop method *)\n      let result = List.hd list in\n      list &lt;- List.tl list;\n      result\n    method peek =                        (* peek method *)\n      List.hd list\n    method size =                        (* size method *)\n      List.length list\n  end\nclass [\'a] stack :\n  object\n    val mutable list : \'a list\n    method peek : \'a\n    method pop : \'a\n    method push : \'a -&gt; unit\n    method size : int\n  end\n</code></pre>\n<p>The <code>class [\'a] stack</code> doesn\'t really define just one class, but a whole\n&quot;class of classes&quot;, one for every possible type (ie. an infinitely large\nnumber of classes!) Let\'s try and use our <code>\'a stack</code> class. In this\ninstance we create a stack and push a floating point number onto the\nstack. Notice the type of the stack:</p>\n<pre><code class="language-ocaml"># let s = new stack\nval s : \'_weak1 stack = &lt;obj&gt;\n# s#push 1.0\n- : unit = ()\n# s\n- : float stack = &lt;obj&gt;\n</code></pre>\n<p>This stack is now a <code>float stack</code>, and only floating point numbers may\nbe pushed and popped from this stack. Let\'s demonstrate the type-safety\nof our new <code>float stack</code>:</p>\n<pre><code class="language-ocaml"># s#push 3.0\n- : unit = ()\n# s#pop\n- : float = 3.\n# s#pop\n- : float = 1.\n# s#push &quot;a string&quot;\nLine 1, characters 8-18:\nError: This expression has type string but an expression was expected of type\n         float\n</code></pre>\n<p>We can define polymorphic functions which can operate on any type of\nstack. Our first attempt is this one:</p>\n<pre><code class="language-ocaml"># let drain_stack s =\n  while s#size &gt; 0 do\n    ignore (s#pop)\n  done\nval drain_stack : &lt; pop : \'a; size : int; .. &gt; -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>Notice the type of <code>drain_stack</code>. Cleverly - perhaps <em>too</em> cleverly -\nOCaml\'s type inference engine has worked out that <code>drain_stack</code> works on\n<em>any</em> object which has <code>pop</code> and <code>size</code> methods! So if we defined\nanother, entirely separate class which happened to contain <code>pop</code> and\n<code>size</code> methods with suitable type signatures, then we might accidentally\ncall <code>drain_stack</code> on objects of that other type.</p>\n<p>We can force OCaml to be more specific and only allow <code>drain_stack</code> to\nbe called on <code>\'a stack</code>s by narrowing the type of the <code>s</code> argument, like\nthis:</p>\n<pre><code class="language-ocaml"># let drain_stack (s : \'a stack) =\n  while s#size &gt; 0 do\n    ignore (s#pop)\n  done\nval drain_stack : \'a stack -&gt; unit = &lt;fun&gt;\n</code></pre>\n<h3 id="inheritance-virtual-classes-initializers">Inheritance, virtual classes, initializers</h3>\n<p>I\'ve noticed programmers in Java tend to overuse inheritance, possibly\nbecause it\'s the only reasonable way of extending code in that language.\nA much better and more general way to extend code is usually to use\nhooks (cf. Apache\'s module API). Nevertheless in certain narrow areas\ninheritance can be useful, and the most important of these is in writing\nGUI widget libraries.</p>\n<p>Let\'s consider an imaginary OCaml widget library similar to Java\'s\nSwing. We will define buttons and labels with the following class\nhierarchy:</p>\n<pre><code>widget  (superclass for all widgets)\n  |\n  +----&gt; container  (any widget that can contain other widgets)\n  |        |\n  |        +----&gt; button\n  |\n  +-------------&gt; label\n</code></pre>\n<p>(Notice that a <code>button</code> is a <code>container</code> because it can contain either a\nlabel or an image, depending on what is displayed on the button).</p>\n<p><code>widget</code> is the virtual superclass for all widgets. I want every widget\nto have a name (just a string) which is constant over the life of that\nwidget. This was my first attempt:</p>\n<pre><code class="language-ocaml"># class virtual widget name =\n  object (self)\n    method get_name =\n      name\n    method virtual repaint : unit\n  end\nLines 1-6, characters 1-6:\nError: Some type variables are unbound in this type:\n         class virtual widget :\n           \'a -&gt;\n           object method get_name : \'a method virtual repaint : unit end\n       The method get_name has type \'a where \'a is unbound\n</code></pre>\n<p>Oops! I forgot that OCaml cannot infer the type of <code>name</code> so will assume\nthat it is <code>\'a</code>. But that defines a polymorphic class, and I didn\'t\ndeclare the class as polymorphic (<code>class [\'a] widget</code>). I need to narrow\nthe type of <code>name</code> like this:</p>\n<pre><code class="language-ocaml"># class virtual widget (name : string) =\n  object (self)\n    method get_name =\n      name\n    method virtual repaint : unit\n  end;;\nclass virtual widget :\n  string -&gt; object method get_name : string method virtual repaint : unit end\n</code></pre>\n<p>Now there are several new things going on in this code. Firstly the\nclass contains an <strong>initializer</strong>. This is an argument to the class\n(<code>name</code>) which you can think of as exactly the equivalent of an argument\nto a constructor in, eg., Java:</p>\n<pre><code class="language-java">public class Widget\n{\n  public Widget (String name)\n  {\n    ...\n  }\n}\n</code></pre>\n<p>In OCaml a constructor constructs the whole class, it\'s not just a\nspecially named function, so we write the arguments as if they are\narguments to the class:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">class foo arg1 arg2 ... =\n</code></pre>\n<p>Secondly the class contains a virtual method, and thus the whole class\nis marked as virtual. The virtual method is our <code>repaint</code> method. We\nneed to tell OCaml it\'s virtual (<code>method virtual</code>), <em>and</em> we need to\ntell OCaml the type of the method. Because the method doesn\'t contain\nany code, OCaml can\'t use type inference to automatically work out the\ntype for you, so you need to tell it the type. In this case the method\njust returns <code>unit</code>. If your class contains any virtual methods (even\njust inherited ones) then you need to specify the whole class as virtual\nby using <code>class virtual ...</code>.</p>\n<p>As in C++ and Java, virtual classes cannot be directly instantiated\nusing <code>new</code>:</p>\n<pre><code class="language-ocaml"># let w = new widget &quot;my widget&quot;\nLine 1, characters 9-19:\nError: Cannot instantiate the virtual class widget\n</code></pre>\n<p>Now my <code>container</code> class is more interesting. It must inherit from\n<code>widget</code> and have the mechanics for storing the list of contained\nwidgets. Here is my simple implementation for <code>container</code>:</p>\n<pre><code class="language-ocaml"># class virtual container name =\n  object (self)\n    inherit widget name\n    val mutable widgets = ([] : widget list)\n    method add w =\n      widgets &lt;- w :: widgets\n    method get_widgets =\n      widgets\n    method repaint =\n      List.iter (fun w -&gt; w#repaint) widgets\n  end\nclass virtual container :\n  string -&gt;\n  object\n    val mutable widgets : widget list\n    method add : widget -&gt; unit\n    method get_name : string\n    method get_widgets : widget list\n    method repaint : unit\n  end\n</code></pre>\n<p>Notes:</p>\n<ol>\n<li>The <code>container</code> class is marked as virtual. It doesn\'t contain any\nvirtual methods, but in this case I just want to prevent people\ncreating containers directly.\n</li>\n<li>The <code>container</code> class has a <code>name</code> argument which is passed directly\nup when constructing the <code>widget</code>.\n</li>\n<li><code>inherit widget name</code> means that the <code>container</code> inherits from\n<code>widget</code>, and it passes the <code>name</code> argument to the constructor for\n<code>widget</code>.\n</li>\n<li>My <code>container</code> contains a mutable list of widgets and methods to\n<code>add</code> a widget to this list and <code>get_widgets</code> (return the list of\nwidgets).\n</li>\n<li>The list of widgets returned by <code>get_widgets</code> cannot be modified by\ncode outside the class. The reason for this is somewhat subtle, but\nbasically comes down to the fact that OCaml\'s linked lists are\nimmutable. Let\'s imagine that someone wrote this code:\n</li>\n</ol>\n<pre><code class="language-ocaml"># let list = container#get_widgets in\n  x :: list\n</code></pre>\n<p>Would this modify the private internal representation of my <code>container</code>\nclass, by prepending <code>x</code> to the list of widgets? No it wouldn\'t. The\nprivate variable <code>widgets</code> would be unaffected by this or any other\nchange attempted by the outside code. This means, for example, that you\ncould change the internal representation to use an array at some later\ndate, and no code outside the class would need to be changed.</p>\n<p>Last, but not least, we have implemented the previously virtual\n<code>repaint</code> function so that <code>container#repaint</code> will repaint all of the\ncontained widgets. Notice I use <code>List.iter</code> to iterate over the list,\nand I also use a probably unfamiliar anonymous function expression:</p>\n<pre><code class="language-ocaml"># (fun w -&gt; w#repaint)\n- : &lt; repaint : \'a; .. &gt; -&gt; \'a = &lt;fun&gt;\n</code></pre>\n<p>which defines an anonymous function with one argument <code>w</code> that just\ncalls <code>w#repaint</code> (the <code>repaint</code> method on widget <code>w</code>).</p>\n<p>In this instance our <code>button</code> class is simple (rather unrealistically\nsimple in fact, but nevermind that):</p>\n<pre><code class="language-ocaml"># type button_state = Released | Pressed\ntype button_state = Released | Pressed\n# class button ?callback name =\n  object (self)\n    inherit container name as super\n    val mutable state = Released\n    method press =\n      state &lt;- Pressed;\n      match callback with\n      | None -&gt; ()\n      | Some f -&gt; f ()\n    method release =\n      state &lt;- Released\n    method repaint =\n      super#repaint;\n      print_endline (&quot;Button being repainted, state is &quot; ^\n                     (match state with\n                      | Pressed -&gt; &quot;Pressed&quot;\n                      | Released -&gt; &quot;Released&quot;))\n  end\nclass button :\n  ?callback:(unit -&gt; unit) -&gt;\n  string -&gt;\n  object\n    val mutable state : button_state\n    val mutable widgets : widget list\n    method add : widget -&gt; unit\n    method get_name : string\n    method get_widgets : widget list\n    method press : unit\n    method release : unit\n    method repaint : unit\n  end\n</code></pre>\n<p>Notes:</p>\n<ol>\n<li>This function has an optional argument (see the previous chapter)\nwhich is used to pass in the optional callback function. The\ncallback is called when the button is pressed.\n</li>\n<li>The expression <code>inherit container name as super</code> names the\nsuperclass <code>super</code>. I use this in the <code>repaint</code> method:\n<code>super#repaint</code>. This expressly calls the superclass method.\n</li>\n<li>Pressing the button (calling <code>button#press</code> in this rather\nsimplistic code) sets the state of the button to <code>Pressed</code> and calls\nthe callback function, if one was defined. Notice that the\n<code>callback</code> variable is either <code>None</code> or <code>Some f</code>, in other words it\nhas type <code>(unit -&gt; unit) option</code>. Reread the previous chapter if you\nare unsure about this.\n</li>\n<li>Notice a strange thing about the <code>callback</code> variable. It\'s defined\nas an argument to the class, but any method can see and use it. In\nother words, the variable is supplied when the object is\nconstructed, but persists over the lifetime of the object.\n</li>\n<li>The <code>repaint</code> method has been implemented. It calls the superclass\n(to repaint the container), then repaints the button, displaying the\ncurrent state of the button.\n</li>\n</ol>\n<p>Before defining our <code>label</code> class, let\'s play with the <code>button</code> class in\nthe OCaml toplevel:</p>\n<pre><code class="language-ocaml"># let b = new button ~callback:(fun () -&gt; print_endline &quot;Ouch!&quot;) &quot;button&quot;\nval b : button = &lt;obj&gt;\n# b#repaint\nButton being repainted, state is Released\n- : unit = ()\n# b#press\nOuch!\n- : unit = ()\n# b#repaint\nButton being repainted, state is Pressed\n- : unit = ()\n# b#release\n- : unit = ()\n</code></pre>\n<p>Here\'s our comparatively trivial <code>label</code> class:</p>\n<pre><code class="language-ocaml"># class label name text =\n  object (self)\n    inherit widget name\n    method repaint =\n      print_endline (&quot;Label: &quot; ^ text)\n  end\nclass label :\n  string -&gt;\n  string -&gt; object method get_name : string method repaint : unit end\n</code></pre>\n<p>Let\'s create a label which says &quot;Press me!&quot; and add it to the button:</p>\n<pre><code class="language-ocaml"># let l = new label &quot;label&quot; &quot;Press me!&quot;\nval l : label = &lt;obj&gt;\n# b#add l\n- : unit = ()\n# b#repaint\nLabel: Press me!\nButton being repainted, state is Released\n- : unit = ()\n</code></pre>\n<h3 id="a-note-about-self">A note about <code>self</code></h3>\n<p>In all the examples above we defined classes using the general pattern:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">class name =\n  object (self)\n    (* ... *)\n  end\n</code></pre>\n<p>I didn\'t explain the reference to <code>self</code>. In fact this names the object,\nallowing you to call methods in the same class or pass the object to\nfunctions outside the class. In other words, it\'s exactly the same as\n<code>this</code> in C++/Java. You may completely omit the\n<code>(self)</code> part if you don\'t need to refer to yourself - indeed in all the\nexamples above we could have done exactly that. However, I would advise\nyou to leave it in there because you never know when you might modify\nthe class and require the reference to <code>self</code>. There is no penalty for\nhaving it.</p>\n<h3 id="inheritance-and-coercions">Inheritance and coercions</h3>\n<pre><code class="language-ocaml"># let b = new button &quot;button&quot;\nval b : button = &lt;obj&gt;\n# let l = new label &quot;label&quot; &quot;Press me!&quot;\nval l : label = &lt;obj&gt;\n# [b; l]\nLine 1, characters 5-6:\nError: This expression has type label but an expression was expected of type\n         button\n       The first object type has no method add\n</code></pre>\n<p>I created a button <code>b</code> and a label <code>l</code> and I tried to create a list\ncontaining both, but I got an error. Yet <code>b</code> and <code>l</code> are both <code>widget</code>s,\nso why can\'t I put them into the same list? Perhaps OCaml can\'t guess\nthat I want a <code>widget list</code>? Let\'s try telling it:</p>\n<pre><code class="language-ocaml"># let wl = ([] : widget list)\nval wl : widget list = []\n# let wl = b :: wl\nLine 1, characters 15-17:\nError: This expression has type widget list\n       but an expression was expected of type button list\n       Type widget = &lt; get_name : string; repaint : unit &gt;\n       is not compatible with type\n         button =\n           &lt; add : widget -&gt; unit; get_name : string;\n             get_widgets : widget list; press : unit; release : unit;\n             repaint : unit &gt;\n       The first object type has no method add\n</code></pre>\n<p>It turns out that OCaml doesn\'t coerce subclasses to the type of the\nsuperclass by default, but you can tell it to by using the <code>:&gt;</code>\n(coercion) operator:</p>\n<pre><code class="language-ocaml"># let wl = (b :&gt; widget) :: wl\nval wl : widget list = [&lt;obj&gt;]\n# let wl = (l :&gt; widget) :: wl\nval wl : widget list = [&lt;obj&gt;; &lt;obj&gt;]\n</code></pre>\n<p>The expression <code>(b :&gt; widget)</code> means &quot;coerce the button <code>b</code> to have type\n<code>widget</code>&quot;. Type-safety is preserved because it is possible to tell\ncompletely at compile time whether the coercion will succeed.</p>\n<p>Actually, coercions are somewhat more subtle than described above, and\nso I urge you to read the manual to find out the full details.</p>\n<p>The <code>container#add</code> method defined above is actually incorrect, and\nfails if you try to add widgets of different types into a <code>container</code>. A\ncoercion would fix this.</p>\n<p>Is it possible to coerce from a superclass (eg. <code>widget</code>) to a subclass\n(eg. <code>button</code>)? The answer, perhaps surprisingly, is NO! Coercing in\nthis direction is <em>unsafe</em>. You might try to coerce a <code>widget</code> which is\nin fact a <code>label</code>, not a <code>button</code>.</p>\n<h3 id="the-oo-module-and-comparing-objects">The <code>Oo</code> module and comparing objects</h3>\n<p>The <code>Oo</code> module contains a few useful functions for OO programming.</p>\n<p><code>Oo.copy</code> makes a shallow copy of an object. <code>Oo.id object</code> returns a\nunique identifying number for each object (a unique number across all\nclasses).</p>\n<p><code>=</code> and <code>&lt;&gt;</code> can be used to compare objects for <em>physical</em> equality (an\nobject and its copy are not physically identical). You can also use <code>&lt;</code>\netc. which provides an ordering of objects based apparently on their\nIDs.</p>\n<h2 id="objects-without-class">Objects without class</h2>\n<p>Here we examine how to use objects pretty much like records, without\nnecessarily using classes.</p>\n<h3 id="immediate-objects-and-object-types">Immediate objects and object types</h3>\n<p>Objects can be used instead of records, and have some nice properties\nthat can make them preferable to records in some cases. We saw that the\ncanonical way of creating objects is to first define a class, and use\nthis class to create individual objects. This can be cumbersome in some\nsituations since class definitions are more than a type definition and\ncannot be defined recursively with types. However, objects have a type\nthat is very analog to a record type, and it can be used in type\ndefinitions. In addition, objects can be created without a class. They\nare called <em>immediate objects</em>. Here is the definition of an immediate\nobject:</p>\n<pre><code class="language-ocaml"># let o =\n  object\n    val mutable n = 0\n    method incr = n &lt;- n + 1\n    method get = n\n  end\nval o : &lt; get : int; incr : unit &gt; = &lt;obj&gt;\n</code></pre>\n<p>This object has a type, which is defined by its public methods only.\nValues are not visible and neither are private methods (not shown).\nUnlike records, such a type does not need to be predefined explicitly,\nbut doing so can make things clearer. We can do it like this:</p>\n<pre><code class="language-ocaml"># type counter = &lt;get : int; incr : unit&gt;\ntype counter = &lt; get : int; incr : unit &gt;\n</code></pre>\n<p>Compare with an equivalent record type definition:</p>\n<pre><code class="language-ocaml"># type counter_r =\n  {get : unit -&gt; int;\n   incr : unit -&gt; unit}\ntype counter_r = { get : unit -&gt; int; incr : unit -&gt; unit; }\n</code></pre>\n<p>The implementation of a record working like our object would be:</p>\n<pre><code class="language-ocaml"># let r =\n  let n = ref 0 in\n    {get = (fun () -&gt; !n);\n     incr = (fun () -&gt; incr n)}\nval r : counter_r = {get = &lt;fun&gt;; incr = &lt;fun&gt;}\n</code></pre>\n<p>In terms of functionality, both the object and the record are similar,\nbut each solution has its own advantages:</p>\n<ul>\n<li><strong>speed</strong>: slightly faster field access in records\n</li>\n<li><strong>field names</strong>: it is inconvenient to manipulate records of\ndifferent types when some fields are named identically but it\'s not\na problem with objects\n</li>\n<li><strong>subtyping</strong>: it is impossible to coerce the type of a record to a\ntype with less fields. That is however possible with objects, so\nobjects of different kinds that share some methods can be mixed in a\ndata structure where only their common methods are visible (see next\nsection)\n</li>\n<li><strong>type definitions</strong>: there is no need to define an object type in\nadvance, so it lightens the dependency constraints between modules\n</li>\n</ul>\n<h3 id="class-types-vs-just-types">Class types vs. just types</h3>\n<p>Beware of the confusion between <em>class types</em> and object <em>types</em>. A\n<em>class type</em> is not a data <em>type</em>, normally referred to as <em>type</em> in the\nOCaml jargon. An object <em>type</em> is a kind of data <em>type</em>, just like a\nrecord type or a tuple.</p>\n<p>When a class is defined, both a <em>class type</em> and an object <em>type</em> of the\nsame name are defined:</p>\n<pre><code class="language-ocaml"># class t =\n  object\n    val x = 0\n    method get = x\n  end\nclass t : object val x : int method get : int end\n</code></pre>\n<p><code>object val x : int method get : int end</code> is a class type.</p>\n<p>In this example, <code>t</code> is also the type of objects that this class would\ncreate. Objects that derive from different classes or no class at all\n(immediate objects) can be mixed together as long as they have the same\ntype:</p>\n<pre><code class="language-ocaml"># let x = object method get = 123 end\nval x : &lt; get : int &gt; = &lt;obj&gt;\n# let l = [new t; x]\nval l : t list = [&lt;obj&gt;; &lt;obj&gt;]\n</code></pre>\n<p>Mixing objects that share a common subtype can be done, but requires\nexplicit type coercion using the <code>:&gt;</code> operator:</p>\n<pre><code class="language-ocaml"># let x = object method get = 123 end\nval x : &lt; get : int &gt; = &lt;obj&gt;\n# let y = object method get = 80 method special = &quot;hello&quot; end\nval y : &lt; get : int; special : string &gt; = &lt;obj&gt;\n# let l = [x; y]\nLine 1, characters 13-14:\nError: This expression has type &lt; get : int; special : string &gt;\n       but an expression was expected of type &lt; get : int &gt;\n       The second object type has no method special\n# let l = [x; (y :&gt; t)]\nval l : t list = [&lt;obj&gt;; &lt;obj&gt;]\n</code></pre>\n'},tl:{hd:{title:"Error Handling",slug:"error-handling",description:"Discover the different ways you can manage errors in your OCaml programs\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"errors",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:"\n## Exceptions\n\nOne way of handling errors in OCaml is exceptions. The\nstandard library relies heavily upon them.\n\nExceptions belong to the type `exn` (an extensible sum type):\n\n```ocaml\nexception Foo of string\n\nlet i_will_fail () =\n  raise (Foo \"Oh no!\")\n```\n\nHere, we add a variant `Foo` to the type `exn`, and create a function\nthat will raise this exception. Now, how do we handle exceptions?\nThe construct is `try ... with ...`:\n\n```ocaml\nlet safe_inverse n =\n  try Some (1 / n) with\n    Division_by_zero -> None\n\nlet safe_list_find p l =\n  try Some (List.find p l) with\n    Not_found -> None\n```\n\nWe can try those functions:\n\n```ocaml\n# 1 / 0;;\nException: Division_by_zero.\n# safe_inverse 2;;\n- : int option = Some 0\n# safe_inverse 0;;\n- : int option = None\n# List.find (fun x -> x mod 2 = 0) [1; 3; 5]\nException: Not_found.\n# safe_list_find (fun x -> x mod 2 = 0) [1; 3; 4; 5]\n- : int option = Some 4\n# safe_list_find (fun x -> x mod 2 = 0) [1; 3; 5]\n- : int option = None\n```\n\nThe biggest issue with exceptions is that they do not appear in types.\nOne has to read the documentation to see that, indeed, `Map.S.find`\nor `List.hd` are not total functions, and that they might fail.\n\nIt is considered good practice nowadays, when a function can fail in\ncases that are not bugs (i.e., not `assert false`, but network failures,\nkeys not present, etc.)\nto return a more explicit type such as `'a option` or `('a, 'b) result`.\nA relatively common idiom is to have such a safe version of the function,\nsay, `val foo : a -> b option`, and an exception raising\nversion `val foo_exn : a -> b`.\n\n### Documentation\n\nFunctions that can raise exceptions should be documented like this:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nval foo : a -> b\n(** foo does this and that, here is how it works, etc.\n    @raise Invalid_argument if [a] doesn't satisfy ...\n    @raise Sys_error if filesystem is not happy *)\n```\n\n### Stacktraces\n\nTo get a stacktrace when a unhandled exception makes your program crash, you\nneed to compile the program in \"debug\" mode (with `-g` when calling\n`ocamlc`, or `-tag 'debug'` when calling `ocamlbuild`).\nThen:\n\n```\nOCAMLRUNPARAM=b ./myprogram [args]\n```\n\nAnd you will get a stacktrace. Alternatively, you can call, from within the program,\n\n```ocaml\nlet () = Printexc.record_backtrace true\n```\n\n### Printing\n\nTo print an exception, the module `Printexc` comes in handy. For instance,\nthe following function `notify_user : (unit -> 'a) -> 'a` can be used\nto call a function and, if it fails, print the exception on `stderr`.\nIf stacktraces are enabled, this function will also display it.\n\n```ocaml\nlet notify_user f =\n  try f () with e ->\n    let msg = Printexc.to_string e\n    and stack = Printexc.get_backtrace () in\n      Printf.eprintf \"there was an error: %s%s\\n\" msg stack;\n      raise e\n```\n\nOCaml knows how to print its built-in exception, but you can also tell it\nhow to print your own exceptions:\n\n```ocaml\nexception Foo of int\n\nlet () =\n  Printexc.register_printer\n    (function\n      | Foo i -> Some (Printf.sprintf \"Foo(%d)\" i)\n      | _ -> None (* for other exceptions *)\n    )\n```\n\nEach printer should take care of the exceptions it knows about, returning\n`Some <printed exception>`, and return `None` otherwise (let the other printers\ndo the job!).\n\n## Result type\n\nThe Stdlib module contains the following type:\n\n```ocaml\ntype ('a, 'b) result =\n  | Ok of 'a\n  | Error of 'b\n```\n\nA value `Ok x` means that the computation succeeded with `x`, and\na value `Error e` means that it failed.\nPattern matching can be used to deal with both cases, as with any\nother sum type. The advantage here is that a function `a -> b` that\nfails can be modified so its type is `a -> (b, error) result`,\nwhich makes the failure explicit.\nThe error case `e` in `Error e` can be of any type\n(the `'b` type variable), but a few possible choices\nare:\n\n- `exn`, in which case the result type just makes exceptions explicit.\n- `string`, where the error case is a message that indicates what failed.\n- `string lazy_t`, a more elaborate form of error message that is only evaluated\n  if printing is required.\n- some polymorphic variant, with one case per\n  possible error. This is very accurate (each error can be dealt with\n  explicitly and occurs in the type) but the use of polymorphic variants\n  sometimes make error messages hard to read.\n\nFor easy combination of functions that can fail, many alternative standard\nlibraries provide useful combinators on the `result` type: `map`, `>>=`, etc.\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#exceptions">Exceptions</a>\n</li>\n<li><a href="#result-type">Result type</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="exceptions">Exceptions</h2>\n<p>One way of handling errors in OCaml is exceptions. The\nstandard library relies heavily upon them.</p>\n<p>Exceptions belong to the type <code>exn</code> (an extensible sum type):</p>\n<pre><code class="language-ocaml">exception Foo of string\n\nlet i_will_fail () =\n  raise (Foo &quot;Oh no!&quot;)\n</code></pre>\n<p>Here, we add a variant <code>Foo</code> to the type <code>exn</code>, and create a function\nthat will raise this exception. Now, how do we handle exceptions?\nThe construct is <code>try ... with ...</code>:</p>\n<pre><code class="language-ocaml">let safe_inverse n =\n  try Some (1 / n) with\n    Division_by_zero -&gt; None\n\nlet safe_list_find p l =\n  try Some (List.find p l) with\n    Not_found -&gt; None\n</code></pre>\n<p>We can try those functions:</p>\n<pre><code class="language-ocaml"># 1 / 0;;\nException: Division_by_zero.\n# safe_inverse 2;;\n- : int option = Some 0\n# safe_inverse 0;;\n- : int option = None\n# List.find (fun x -&gt; x mod 2 = 0) [1; 3; 5]\nException: Not_found.\n# safe_list_find (fun x -&gt; x mod 2 = 0) [1; 3; 4; 5]\n- : int option = Some 4\n# safe_list_find (fun x -&gt; x mod 2 = 0) [1; 3; 5]\n- : int option = None\n</code></pre>\n<p>The biggest issue with exceptions is that they do not appear in types.\nOne has to read the documentation to see that, indeed, <code>Map.S.find</code>\nor <code>List.hd</code> are not total functions, and that they might fail.</p>\n<p>It is considered good practice nowadays, when a function can fail in\ncases that are not bugs (i.e., not <code>assert false</code>, but network failures,\nkeys not present, etc.)\nto return a more explicit type such as <code>\'a option</code> or <code>(\'a, \'b) result</code>.\nA relatively common idiom is to have such a safe version of the function,\nsay, <code>val foo : a -&gt; b option</code>, and an exception raising\nversion <code>val foo_exn : a -&gt; b</code>.</p>\n<h3 id="documentation">Documentation</h3>\n<p>Functions that can raise exceptions should be documented like this:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">val foo : a -&gt; b\n(** foo does this and that, here is how it works, etc.\n    @raise Invalid_argument if [a] doesn\'t satisfy ...\n    @raise Sys_error if filesystem is not happy *)\n</code></pre>\n<h3 id="stacktraces">Stacktraces</h3>\n<p>To get a stacktrace when a unhandled exception makes your program crash, you\nneed to compile the program in &quot;debug&quot; mode (with <code>-g</code> when calling\n<code>ocamlc</code>, or <code>-tag \'debug\'</code> when calling <code>ocamlbuild</code>).\nThen:</p>\n<pre><code>OCAMLRUNPARAM=b ./myprogram [args]\n</code></pre>\n<p>And you will get a stacktrace. Alternatively, you can call, from within the program,</p>\n<pre><code class="language-ocaml">let () = Printexc.record_backtrace true\n</code></pre>\n<h3 id="printing">Printing</h3>\n<p>To print an exception, the module <code>Printexc</code> comes in handy. For instance,\nthe following function <code>notify_user : (unit -&gt; \'a) -&gt; \'a</code> can be used\nto call a function and, if it fails, print the exception on <code>stderr</code>.\nIf stacktraces are enabled, this function will also display it.</p>\n<pre><code class="language-ocaml">let notify_user f =\n  try f () with e -&gt;\n    let msg = Printexc.to_string e\n    and stack = Printexc.get_backtrace () in\n      Printf.eprintf &quot;there was an error: %s%s\\n&quot; msg stack;\n      raise e\n</code></pre>\n<p>OCaml knows how to print its built-in exception, but you can also tell it\nhow to print your own exceptions:</p>\n<pre><code class="language-ocaml">exception Foo of int\n\nlet () =\n  Printexc.register_printer\n    (function\n      | Foo i -&gt; Some (Printf.sprintf &quot;Foo(%d)&quot; i)\n      | _ -&gt; None (* for other exceptions *)\n    )\n</code></pre>\n<p>Each printer should take care of the exceptions it knows about, returning\n<code>Some &lt;printed exception&gt;</code>, and return <code>None</code> otherwise (let the other printers\ndo the job!).</p>\n<h2 id="result-type">Result type</h2>\n<p>The Stdlib module contains the following type:</p>\n<pre><code class="language-ocaml">type (\'a, \'b) result =\n  | Ok of \'a\n  | Error of \'b\n</code></pre>\n<p>A value <code>Ok x</code> means that the computation succeeded with <code>x</code>, and\na value <code>Error e</code> means that it failed.\nPattern matching can be used to deal with both cases, as with any\nother sum type. The advantage here is that a function <code>a -&gt; b</code> that\nfails can be modified so its type is <code>a -&gt; (b, error) result</code>,\nwhich makes the failure explicit.\nThe error case <code>e</code> in <code>Error e</code> can be of any type\n(the <code>\'b</code> type variable), but a few possible choices\nare:</p>\n<ul>\n<li><code>exn</code>, in which case the result type just makes exceptions explicit.\n</li>\n<li><code>string</code>, where the error case is a message that indicates what failed.\n</li>\n<li><code>string lazy_t</code>, a more elaborate form of error message that is only evaluated\nif printing is required.\n</li>\n<li>some polymorphic variant, with one case per\npossible error. This is very accurate (each error can be dealt with\nexplicitly and occurs in the type) but the use of polymorphic variants\nsometimes make error messages hard to read.\n</li>\n</ul>\n<p>For easy combination of functions that can fail, many alternative standard\nlibraries provide useful combinators on the <code>result</code> type: <code>map</code>, <code>&gt;&gt;=</code>, etc.</p>\n'},tl:{hd:{title:"Common Error Messages",slug:"common-error-messages",description:"Understand the most common error messages the OCaml compiler can throw at you\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"errors",tl:{hd:"debugging",tl:0}},users:{hd:"Beginner",tl:0},body_md:'\nThis page gives a list of quick explanations for some error or warning\nmessages that are emitted by the OCaml compilers. Longer explanations\nare usually given in dedicated sections of this tutorial.\n\n## Type errors\n###  This expression has type ... but is here used with type ...\nWhen the type of an object is not compatible with the context in which\nit is used, it is frequent to obtain this kind of message:\n\n```ocaml\n# 1 + 2.5\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n```\n"This expression has type *X* but is here used with type *Y*" means that\nif the contents of the expression is isolated (2.5), its type is\ninferred as *X* (float). But the context, i.e. everything which is\naround (1 + ...) tells that the gap expects an expression of type *Y*\n(int) which is not compatible with *X*.\n\nMore disturbing is the following message:\n\n```text\nThis expression has type my_type but is here used with type my_type\n```\nThis error happens often while testing some type definitions using the\ninteractive toplevel.  In OCaml, it is perfectly legal\nto define a type with a name\nthat is already taken by another type. Consider the following session:\n\n```ocaml\n# type my_type = A | B\ntype my_type = A | B\n# let a = A\nval a : my_type = A\n# type my_type = A | B\ntype my_type = A | B\n# let b = B\nval b : my_type = B\n# a = b\nLine 1, characters 5-6:\nError: This expression has type my_type/1\n       but an expression was expected of type my_type/2\n       Hint: The type my_type has been defined multiple times in this\n         toplevel session. Some toplevel values still refer to old versions\n         of this type. Did you try to redefine them?\n```\nFor the compiler, the second definition of my_type is totally\nindependent from the first definition. So we have defined two types\nwhich have the same name. Since "a" was defined earlier, it belongs to\nthe first type while "b" belongs to the second type. In this example,\nredefining "a" after the last definition of my_type solves the problem.\nThis kind of problem should not happen in real programs unless you use\nthe same name for the same type in the same module, which is highly\ndiscouraged.\n\n###  Warning: This optional argument cannot be erased\nFunctions with optional arguments must have at least one non-labelled\nargument. For instance, this is not OK:\n\n```ocaml\n# let f ?(x = 0) ?(y = 0) = print_int (x + y)\nLine 1, characters 18-23:\nWarning 16: this optional argument cannot be erased.\nval f : ?x:int -> ?y:int -> unit = <fun>\n```\nThe solution is simply to add one argument of type unit, like this:\n\n```ocaml\n# let f ?(x = 0) ?(y = 0) () = print_int (x + y)\nval f : ?x:int -> ?y:int -> unit -> unit = <fun>\n```\nSee the [Labels](labels.html "Labels") section for more details on\nfunctions with labelled arguments.\n\n###  The type of this expression... contains type variables that cannot be generalized\nThis happens in some cases when the full type of an object is not known\nby the compiler when it reaches the end of the compilation unit (file)\nbut for some reason it cannot remain polymorphic. Example:\n\n```ocaml env=ref\n# let x = ref None\nval x : \'_weak1 option ref = {contents = None}\n```\ntriggers the following message during the compilation:\n\n```text\nThe type of this expression, \'_a option ref,\ncontains type variables that cannot be generalized\n```\n\nSolution: help the compiler with a type annotation, like for instance:\n\n```ocaml env=ref\n# let x : string option ref = ref None\nval x : string option ref = {contents = None}\n```\nor:\n\n```ocaml env=ref\n# let x = ref (None : string option)\nval x : string option ref = {contents = None}\n```\n\nData of type `\'_weak<n>` may be allowed temporarily, for instance during a\ntoplevel session. It means that the given object has an unknown type,\nbut it cannot be any type: it is not polymorphic data. In the toplevel,\nour example gives these results:\n\n```ocaml env=ref\n# let x = ref None\nval x : \'_weak2 option ref = {contents = None}\n```\n\nThe compiler tells us that the type of x is not fully known yet. But by\nusing `x` later, the compiler can infer the type of `x`:\n\n```ocaml env=ref\n# x := Some 0\n- : unit = ()\n```\nNow `x` has a known type:\n\n```ocaml env=ref\n# x\n- : int option ref = {contents = Some 0}\n```\n\n## Pattern matching warnings and errors\n###  This pattern is unused\nThis warning should be considered as an error, since there is no reason\nto intentionally keep such code. It may happen when the programmer\nintroduced a catch-all pattern unintentionally such as in the following\nsituation:\n\n```ocaml\n# let test_member x tup =\n  match tup with\n  | (y, _) | (_, y) when y = x -> true\n  | _ -> false\nLine 3, characters 14-20:\nWarning 12: this sub-pattern is unused.\nLine 3, characters 5-20:\nWarning 57: Ambiguous or-pattern variables under guard;\nvariable y may match different arguments. (See manual section 9.5)\nval test_member : \'a -> \'a * \'a -> bool = <fun>\n```\nObviously, the programmer had a misconception of what OCaml\'s pattern\nmatching is about. Remember the following:\n\n* the tree of cases is traversed linearly, from left to right. There\n is *no backtracking* as in regexp matching.\n* a guard ("when" clause) is not part of a pattern. It is simply a\n condition which is evaluated at most once and is used as a last\n resort to jump to the next match case.\n* lowercase identifiers (bindings such as "y" above) are just names,\n so they will always match.\n\nIn our example, it is now clear that only the first item of the pair\nwill ever be tested. This leads to the following results:\n\n```ocaml\n# test_member 1 (1, 0)\n- : bool = true\n# test_member 1 (0, 1)\n- : bool = false\n```\n###  This pattern-matching is not exhaustive\nOCaml\'s pattern matching can check whether a set of patterns is\nexhaustive or not, based on the *type* only. So in the following\nexample, the compiler doesn\'t know what range of ints the "mod" operator\nwould return:\n\n```ocamltop\nlet is_even x =\n  match x mod 2 with\n  | 0 -> true\n  | 1 | -1 -> false\n```\nA short solution without pattern matching would be:\n\n```ocaml\n# let is_even x = x mod 2 = 0\nval is_even : int -> bool = <fun>\n```\nIn general, that kind of simplification is not possible and the best\nsolution is to add a catch-all case which should never be reached:\n\n```ocaml\n# let is_even x =\n  match x mod 2 with\n  | 0 -> true\n  | 1 | -1 -> false\n  | _ -> assert false\nval is_even : int -> bool = <fun>\n```\n\n## Problems recompiling valid programs\n###  x.cmi is not a compiled interface\nWhen recompiling some old program or compiling a program from an\nexternal source that was not cleaned properly, it is possible to get\nthis error message:\n\n```text\nsome_module.cmi is not a compiled interface\n```\n\nIt means that some_module.cmi is not valid according to the *current\nversion* of the OCaml compiler. Most of the time, removing the old\ncompiled files (*.cmi, *.cmo, *.cmx, ...) and recompiling is\nsufficient to solve this problem.\n\t\n###  Warning: Illegal backslash escape in string\nRecent versions of OCaml warn you against unprotected backslashes in\nstrings since they should be doubled. Such a message may be displayed\nwhen compiling an older program, and can be turned off with the `-w x`\noption.\n\n```ocaml\n# "\\e\\n" (* bad practice *)\nFile "_none_", line 1, characters 1-3:\nWarning 14: illegal backslash escape in string.\n- : string = "\\\\e\\n"\n# "\\\\e\\n" (* good practice *)\n- : string = "\\\\e\\n"\n```\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#type-errors">Type errors</a>\n</li>\n<li><a href="#pattern-matching-warnings-and-errors">Pattern matching warnings and errors</a>\n</li>\n<li><a href="#problems-recompiling-valid-programs">Problems recompiling valid programs</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>This page gives a list of quick explanations for some error or warning\nmessages that are emitted by the OCaml compilers. Longer explanations\nare usually given in dedicated sections of this tutorial.</p>\n<h2 id="type-errors">Type errors</h2>\n<h3 id="this-expression-has-type--but-is-here-used-with-type-">This expression has type ... but is here used with type ...</h3>\n<p>When the type of an object is not compatible with the context in which\nit is used, it is frequent to obtain this kind of message:</p>\n<pre><code class="language-ocaml"># 1 + 2.5\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n</code></pre>\n<p>&quot;This expression has type <em>X</em> but is here used with type <em>Y</em>&quot; means that\nif the contents of the expression is isolated (2.5), its type is\ninferred as <em>X</em> (float). But the context, i.e. everything which is\naround (1 + ...) tells that the gap expects an expression of type <em>Y</em>\n(int) which is not compatible with <em>X</em>.</p>\n<p>More disturbing is the following message:</p>\n<pre><code class="language-text">This expression has type my_type but is here used with type my_type\n</code></pre>\n<p>This error happens often while testing some type definitions using the\ninteractive toplevel.  In OCaml, it is perfectly legal\nto define a type with a name\nthat is already taken by another type. Consider the following session:</p>\n<pre><code class="language-ocaml"># type my_type = A | B\ntype my_type = A | B\n# let a = A\nval a : my_type = A\n# type my_type = A | B\ntype my_type = A | B\n# let b = B\nval b : my_type = B\n# a = b\nLine 1, characters 5-6:\nError: This expression has type my_type/1\n       but an expression was expected of type my_type/2\n       Hint: The type my_type has been defined multiple times in this\n         toplevel session. Some toplevel values still refer to old versions\n         of this type. Did you try to redefine them?\n</code></pre>\n<p>For the compiler, the second definition of my_type is totally\nindependent from the first definition. So we have defined two types\nwhich have the same name. Since &quot;a&quot; was defined earlier, it belongs to\nthe first type while &quot;b&quot; belongs to the second type. In this example,\nredefining &quot;a&quot; after the last definition of my_type solves the problem.\nThis kind of problem should not happen in real programs unless you use\nthe same name for the same type in the same module, which is highly\ndiscouraged.</p>\n<h3 id="warning-this-optional-argument-cannot-be-erased">Warning: This optional argument cannot be erased</h3>\n<p>Functions with optional arguments must have at least one non-labelled\nargument. For instance, this is not OK:</p>\n<pre><code class="language-ocaml"># let f ?(x = 0) ?(y = 0) = print_int (x + y)\nLine 1, characters 18-23:\nWarning 16: this optional argument cannot be erased.\nval f : ?x:int -&gt; ?y:int -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>The solution is simply to add one argument of type unit, like this:</p>\n<pre><code class="language-ocaml"># let f ?(x = 0) ?(y = 0) () = print_int (x + y)\nval f : ?x:int -&gt; ?y:int -&gt; unit -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>See the <a href="labels.html" title="Labels">Labels</a> section for more details on\nfunctions with labelled arguments.</p>\n<h3 id="the-type-of-this-expression-contains-type-variables-that-cannot-be-generalized">The type of this expression... contains type variables that cannot be generalized</h3>\n<p>This happens in some cases when the full type of an object is not known\nby the compiler when it reaches the end of the compilation unit (file)\nbut for some reason it cannot remain polymorphic. Example:</p>\n<pre><code class="language-ocaml"># let x = ref None\nval x : \'_weak1 option ref = {contents = None}\n</code></pre>\n<p>triggers the following message during the compilation:</p>\n<pre><code class="language-text">The type of this expression, \'_a option ref,\ncontains type variables that cannot be generalized\n</code></pre>\n<p>Solution: help the compiler with a type annotation, like for instance:</p>\n<pre><code class="language-ocaml"># let x : string option ref = ref None\nval x : string option ref = {contents = None}\n</code></pre>\n<p>or:</p>\n<pre><code class="language-ocaml"># let x = ref (None : string option)\nval x : string option ref = {contents = None}\n</code></pre>\n<p>Data of type <code>\'_weak&lt;n&gt;</code> may be allowed temporarily, for instance during a\ntoplevel session. It means that the given object has an unknown type,\nbut it cannot be any type: it is not polymorphic data. In the toplevel,\nour example gives these results:</p>\n<pre><code class="language-ocaml"># let x = ref None\nval x : \'_weak2 option ref = {contents = None}\n</code></pre>\n<p>The compiler tells us that the type of x is not fully known yet. But by\nusing <code>x</code> later, the compiler can infer the type of <code>x</code>:</p>\n<pre><code class="language-ocaml"># x := Some 0\n- : unit = ()\n</code></pre>\n<p>Now <code>x</code> has a known type:</p>\n<pre><code class="language-ocaml"># x\n- : int option ref = {contents = Some 0}\n</code></pre>\n<h2 id="pattern-matching-warnings-and-errors">Pattern matching warnings and errors</h2>\n<h3 id="this-pattern-is-unused">This pattern is unused</h3>\n<p>This warning should be considered as an error, since there is no reason\nto intentionally keep such code. It may happen when the programmer\nintroduced a catch-all pattern unintentionally such as in the following\nsituation:</p>\n<pre><code class="language-ocaml"># let test_member x tup =\n  match tup with\n  | (y, _) | (_, y) when y = x -&gt; true\n  | _ -&gt; false\nLine 3, characters 14-20:\nWarning 12: this sub-pattern is unused.\nLine 3, characters 5-20:\nWarning 57: Ambiguous or-pattern variables under guard;\nvariable y may match different arguments. (See manual section 9.5)\nval test_member : \'a -&gt; \'a * \'a -&gt; bool = &lt;fun&gt;\n</code></pre>\n<p>Obviously, the programmer had a misconception of what OCaml\'s pattern\nmatching is about. Remember the following:</p>\n<ul>\n<li>the tree of cases is traversed linearly, from left to right. There\nis <em>no backtracking</em> as in regexp matching.\n</li>\n<li>a guard (&quot;when&quot; clause) is not part of a pattern. It is simply a\ncondition which is evaluated at most once and is used as a last\nresort to jump to the next match case.\n</li>\n<li>lowercase identifiers (bindings such as &quot;y&quot; above) are just names,\nso they will always match.\n</li>\n</ul>\n<p>In our example, it is now clear that only the first item of the pair\nwill ever be tested. This leads to the following results:</p>\n<pre><code class="language-ocaml"># test_member 1 (1, 0)\n- : bool = true\n# test_member 1 (0, 1)\n- : bool = false\n</code></pre>\n<h3 id="this-pattern-matching-is-not-exhaustive">This pattern-matching is not exhaustive</h3>\n<p>OCaml\'s pattern matching can check whether a set of patterns is\nexhaustive or not, based on the <em>type</em> only. So in the following\nexample, the compiler doesn\'t know what range of ints the &quot;mod&quot; operator\nwould return:</p>\n<pre><code class="language-ocamltop">let is_even x =\n  match x mod 2 with\n  | 0 -&gt; true\n  | 1 | -1 -&gt; false\n</code></pre>\n<p>A short solution without pattern matching would be:</p>\n<pre><code class="language-ocaml"># let is_even x = x mod 2 = 0\nval is_even : int -&gt; bool = &lt;fun&gt;\n</code></pre>\n<p>In general, that kind of simplification is not possible and the best\nsolution is to add a catch-all case which should never be reached:</p>\n<pre><code class="language-ocaml"># let is_even x =\n  match x mod 2 with\n  | 0 -&gt; true\n  | 1 | -1 -&gt; false\n  | _ -&gt; assert false\nval is_even : int -&gt; bool = &lt;fun&gt;\n</code></pre>\n<h2 id="problems-recompiling-valid-programs">Problems recompiling valid programs</h2>\n<h3 id="xcmi-is-not-a-compiled-interface">x.cmi is not a compiled interface</h3>\n<p>When recompiling some old program or compiling a program from an\nexternal source that was not cleaned properly, it is possible to get\nthis error message:</p>\n<pre><code class="language-text">some_module.cmi is not a compiled interface\n</code></pre>\n<p>It means that some_module.cmi is not valid according to the <em>current\nversion</em> of the OCaml compiler. Most of the time, removing the old\ncompiled files (*.cmi, *.cmo, *.cmx, ...) and recompiling is\nsufficient to solve this problem.</p>\n<h3 id="warning-illegal-backslash-escape-in-string">Warning: Illegal backslash escape in string</h3>\n<p>Recent versions of OCaml warn you against unprotected backslashes in\nstrings since they should be doubled. Such a message may be displayed\nwhen compiling an older program, and can be turned off with the <code>-w x</code>\noption.</p>\n<pre><code class="language-ocaml"># &quot;\\e\\n&quot; (* bad practice *)\nFile &quot;_none_&quot;, line 1, characters 1-3:\nWarning 14: illegal backslash escape in string.\n- : string = &quot;\\\\e\\n&quot;\n# &quot;\\\\e\\n&quot; (* good practice *)\n- : string = &quot;\\\\e\\n&quot;\n</code></pre>\n'},tl:{hd:{title:"Debug",slug:"debug",description:"Learn to build custom types and write function to process this data\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"debugging",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:'\nThis tutorial presents two techniques for debugging OCaml programs:\n\n* [Tracing functions calls](#Tracingfunctionscallsinthetoplevel),\n  which works in the interactive toplevel.\n* The [OCaml debugger](#The-OCaml-debugger), which allows analysing programs\n  compiled with `ocamlc`.\n\n## Tracing functions calls in the toplevel\n\nThe simplest way to debug programs in the toplevel is to follow the function\ncalls, by \u201ctracing\u201d the faulty function:\n\n```ocaml\n# let rec fib x = if x <= 1 then 1 else fib (x - 1) + fib (x - 2)\nval fib : int -> int = <fun>\n# #trace fib\nfib is now traced.\n# fib 3\nfib <-- 3\nfib <-- 1\nfib --\x3e 1\nfib <-- 2\nfib <-- 0\nfib --\x3e 1\nfib <-- 1\nfib --\x3e 1\nfib --\x3e 2\nfib --\x3e 3\n- : int = 3\n# #untrace fib\nfib is no longer traced.\n```\n\n###  Polymorphic functions\n\nA difficulty with polymorphic functions is that the output of the trace system\nis not very informative in case of polymorphic arguments and/or results.\nConsider a sorting algorithm (say bubble sort):\n\n```ocaml\n# let exchange i j v =\n  let aux = v.(i) in\n    v.(i) <- v.(j);\n    v.(j) <- aux\nval exchange : int -> int -> \'a array -> unit = <fun>\n# let one_pass_vect fin v =\n  for j = 1 to fin do\n    if v.(j - 1) > v.(j) then exchange (j - 1) j v\n  done\nval one_pass_vect : int -> \'a array -> unit = <fun>\n# let bubble_sort_vect v =\n  for i = Array.length v - 1 downto 0 do\n    one_pass_vect i v\n  done\nval bubble_sort_vect : \'a array -> unit = <fun>\n# let q = [|18; 3; 1|]\nval q : int array = [|18; 3; 1|]\n# #trace one_pass_vect\none_pass_vect is now traced.\n# bubble_sort_vect q\none_pass_vect <-- 2\none_pass_vect --\x3e <fun>\none_pass_vect* <-- [|<poly>; <poly>; <poly>|]\none_pass_vect* --\x3e ()\none_pass_vect <-- 1\none_pass_vect --\x3e <fun>\none_pass_vect* <-- [|<poly>; <poly>; <poly>|]\none_pass_vect* --\x3e ()\none_pass_vect <-- 0\none_pass_vect --\x3e <fun>\none_pass_vect* <-- [|<poly>; <poly>; <poly>|]\none_pass_vect* --\x3e ()\n- : unit = ()\n```\n\nThe function `one_pass_vect` being polymorphic, its vector argument is printed\nas a vector containing polymorphic values, `[|<poly>; <poly>; <poly>|]`, and\nthus we cannot properly follow the computation.\n\nA simple way to overcome this problem is to define a monomorphic version of the\nfaulty function. This is fairly easy using a *type constraint*.  Generally\nspeaking, this allows a proper understanding of the error in the definition of\nthe polymorphic function. Once this has been corrected, you just have to\nsuppress the type constraint to revert to a polymorphic version of the\nfunction.\n\nFor our sorting routine, a single type constraint on the argument of the\n`exchange` function warranties a monomorphic typing, that allows a proper trace\nof function calls:\n\n```ocaml\n# let exchange i j (v : int array) =    (* notice the type constraint *)\n  let aux = v.(i) in\n    v.(i) <- v.(j);\n    v.(j) <- aux\nval exchange : int -> int -> int array -> unit = <fun>\n# let one_pass_vect fin v =\n  for j = 1 to fin do\n    if v.(j - 1) > v.(j) then exchange (j - 1) j v\n  done\nval one_pass_vect : int -> int array -> unit = <fun>\n# let bubble_sort_vect v =\n  for i = Array.length v - 1 downto 0 do\n    one_pass_vect i v\n  done\nval bubble_sort_vect : int array -> unit = <fun>\n# let q = [| 18; 3; 1 |]\nval q : int array = [|18; 3; 1|]\n# #trace one_pass_vect\none_pass_vect is now traced.\n# bubble_sort_vect q\none_pass_vect <-- 2\none_pass_vect --\x3e <fun>\none_pass_vect* <-- [|18; 3; 1|]\none_pass_vect* --\x3e ()\none_pass_vect <-- 1\none_pass_vect --\x3e <fun>\none_pass_vect* <-- [|3; 1; 18|]\none_pass_vect* --\x3e ()\none_pass_vect <-- 0\none_pass_vect --\x3e <fun>\none_pass_vect* <-- [|1; 3; 18|]\none_pass_vect* --\x3e ()\n- : unit = ()\n```\n\n###  Limitations\n\nTo keep track of assignments to data structures and mutable variables in a\nprogram, the trace facility is not powerful enough. You need an extra mechanism\nto stop the program in any place and ask for internal values: that is a\nsymbolic debugger with its stepping feature.\n\nStepping a functional program has a meaning which is a bit weird to define and\nunderstand. Let me say that we use the notion of *runtime events* that happen\nfor instance when a parameter is passed to a function or when entering a\npattern matching, or selecting a clause in a pttern matching. Computation\nprogress is taken into account by these events, independently of the\ninstructions executed on the hardware.\n\nAlthough this is difficult to implement, there exists such a debugger for OCaml\nunder Unix: `ocamldebug`. Its use is illustrated in the next section.\n\nIn fact, for complex programs, it is likely the case that the programmer will\nuse explicit printing to find the bugs, since this methodology allows the\nreduction of the trace material: only useful data are printed and special\npurpose formats are more suited to get the relevant information, than what can\nbe output automatically by the generic pretty-printer used by the trace\nmechanism.\n\n## The OCaml debugger\n\nWe now give a quick tutorial for the OCaml debugger (`ocamldebug`).  Before\nstarting, please note that `ocamldebug` does not work under native Windows\nports of OCaml (but it runs under the Cygwin port).\n\n###  Launching the debugger\n\nConsider the following obviously wrong program written in the file\n`uncaught.ml`:\n\n```ocaml\n(* file uncaught.ml *)\nlet l = ref []\nlet find_address name = List.assoc name !l\nlet add_address name address = l := (name, address) :: ! l\n\nlet () =\n  add_address "IRIA" "Rocquencourt";;\n  print_string (find_address "INRIA"); print_newline ();;\n```\n```mdx-error\nval l : (string * string) list ref = {contents = [("IRIA", "Rocquencourt")]}\nval find_address : string -> string = <fun>\nval add_address : string -> string -> unit = <fun>\nException: Not_found.\n```\n\nAt runtime, the program raises an uncaught exception `Not_found`.  Suppose we\nwant to find where and why this exception has been raised, we can proceed as\nfollows. First, we compile the program in debug mode:\n\n```\nocamlc -g uncaught.ml\n```\n\nWe launch the debugger:\n\n```\nocamldebug a.out\n```\n\nThen the debugger answers with a banner and a prompt:\n\n```\nOCaml Debugger version 4.12.0\n\n(ocd)\n```\n\n###  Finding the cause of a spurious exception\n\nType `r` (for *run*); you get\n\n```\n(ocd) r\nLoading program... done.\nTime : 12\nProgram end.\nUncaught exception: Not_found\n(ocd)\n```\n\nSelf explanatory, isn\'t it? So, you want to step backward to set the program\ncounter before the time the exception is raised; hence type in `b` as\n*backstep*, and you get\n\n```\n(ocd) b\nTime : 11 - pc : 15500 - module List\n143     [] -> <|b|>raise Not_found\n```\n\nThe debugger tells you that you are in module `List`, inside a pattern matching\non a list that already chose the `[]` case and is about to execute `raise\nNot_found`, since the program is stopped just before this expression (as\nwitnessed by the `<|b|>` mark).\n\nBut, as you know, you want the debugger to tell you which procedure calls the\none from `List`, and also who calls the procedure that calls the one from\n`List`; hence, you want a backtrace of the execution stack:\n\n```\n(ocd) bt\n#0  Pc : 15500  List char 3562\n#1  Pc : 19128  Uncaught char 221\n```\n\nSo the last function called is from module `List` at character 3562, that is:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec assoc x = function\n  | [] -> raise Not_found\n          ^\n  | (a,b)::l -> if a = x then b else assoc x l\n```\n\nThe function that calls it is in module `Uncaught`, file `uncaught.ml` char\n221:\n\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nprint_string (find_address "INRIA"); print_newline ();;\n                                  ^\n```\n\nTo sum up: if you\'re developing a program you can compile it with the `-g`\noption, to be ready to debug the program if necessary. Hence, to find a\nspurious exception you just need to type `ocamldebug a.out`, then `r`, `b`, and\n`bt` gives you the backtrace.\n\n###  Getting help and info in the debugger\n\nTo get more info about the current status of the debugger you can ask it\ndirectly at the toplevel prompt of the debugger; for instance:\n\n```\n(ocd) info breakpoints\nNo breakpoint.\n\n(ocd) help break\n  1      15396  in List, character 3539\nbreak : Set breakpoint at specified line or function.\nSyntax: break function-name\nbreak @ [module] linenum\nbreak @ [module] # characternum\n```\n\n###  Setting break points\n\nLet\'s set up a breakpoint and rerun the entire program from the\nbeginning (`(g)oto 0` then `(r)un`):\n\n```\n(ocd) break @Uncaught 9\nBreakpoint 3 at 19112 : file Uncaught, line 9 column 34\n\n(ocd) g 0\nTime : 0\nBeginning of program.\n\n(ocd) r\nTime : 6 - pc : 19112 - module Uncaught\nBreakpoint : 1\n9 add "IRIA" "Rocquencourt"<|a|>;;\n```\n\nThen, we can step and find what happens when `find_address` is about to be\ncalled\n\n```\n(ocd) s\nTime : 7 - pc : 19012 - module Uncaught\n5 let find_address name = <|b|>List.assoc name !l;;\n\n(ocd) p name\nname : string = "INRIA"\n\n(ocd) p !l\n$1 : (string * string) list = ["IRIA", "Rocquencourt"]\n(ocd)\n```\n\nNow we can guess why `List.assoc` will fail to find "INRIA" in the list...\n\n###  Using the debugger under Emacs\n\nUnder Emacs you call the debugger using `ESC-x` `ocamldebug a.out`. Then Emacs\nwill send you directly to the file and character reported by the debugger, and\nyou can step back and forth using `ESC-b` and `ESC-s`, you can set up break\npoints using `CTRL-X space`, and so on...\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#tracing-functions-calls-in-the-toplevel">Tracing functions calls in the toplevel</a>\n</li>\n<li><a href="#the-ocaml-debugger">The OCaml debugger</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>This tutorial presents two techniques for debugging OCaml programs:</p>\n<ul>\n<li><a href="#Tracingfunctionscallsinthetoplevel">Tracing functions calls</a>,\nwhich works in the interactive toplevel.\n</li>\n<li>The <a href="#The-OCaml-debugger">OCaml debugger</a>, which allows analysing programs\ncompiled with <code>ocamlc</code>.\n</li>\n</ul>\n<h2 id="tracing-functions-calls-in-the-toplevel">Tracing functions calls in the toplevel</h2>\n<p>The simplest way to debug programs in the toplevel is to follow the function\ncalls, by \u201ctracing\u201d the faulty function:</p>\n<pre><code class="language-ocaml"># let rec fib x = if x &lt;= 1 then 1 else fib (x - 1) + fib (x - 2)\nval fib : int -&gt; int = &lt;fun&gt;\n# #trace fib\nfib is now traced.\n# fib 3\nfib &lt;-- 3\nfib &lt;-- 1\nfib --&gt; 1\nfib &lt;-- 2\nfib &lt;-- 0\nfib --&gt; 1\nfib &lt;-- 1\nfib --&gt; 1\nfib --&gt; 2\nfib --&gt; 3\n- : int = 3\n# #untrace fib\nfib is no longer traced.\n</code></pre>\n<h3 id="polymorphic-functions">Polymorphic functions</h3>\n<p>A difficulty with polymorphic functions is that the output of the trace system\nis not very informative in case of polymorphic arguments and/or results.\nConsider a sorting algorithm (say bubble sort):</p>\n<pre><code class="language-ocaml"># let exchange i j v =\n  let aux = v.(i) in\n    v.(i) &lt;- v.(j);\n    v.(j) &lt;- aux\nval exchange : int -&gt; int -&gt; \'a array -&gt; unit = &lt;fun&gt;\n# let one_pass_vect fin v =\n  for j = 1 to fin do\n    if v.(j - 1) &gt; v.(j) then exchange (j - 1) j v\n  done\nval one_pass_vect : int -&gt; \'a array -&gt; unit = &lt;fun&gt;\n# let bubble_sort_vect v =\n  for i = Array.length v - 1 downto 0 do\n    one_pass_vect i v\n  done\nval bubble_sort_vect : \'a array -&gt; unit = &lt;fun&gt;\n# let q = [|18; 3; 1|]\nval q : int array = [|18; 3; 1|]\n# #trace one_pass_vect\none_pass_vect is now traced.\n# bubble_sort_vect q\none_pass_vect &lt;-- 2\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]\none_pass_vect* --&gt; ()\none_pass_vect &lt;-- 1\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]\none_pass_vect* --&gt; ()\none_pass_vect &lt;-- 0\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]\none_pass_vect* --&gt; ()\n- : unit = ()\n</code></pre>\n<p>The function <code>one_pass_vect</code> being polymorphic, its vector argument is printed\nas a vector containing polymorphic values, <code>[|&lt;poly&gt;; &lt;poly&gt;; &lt;poly&gt;|]</code>, and\nthus we cannot properly follow the computation.</p>\n<p>A simple way to overcome this problem is to define a monomorphic version of the\nfaulty function. This is fairly easy using a <em>type constraint</em>.  Generally\nspeaking, this allows a proper understanding of the error in the definition of\nthe polymorphic function. Once this has been corrected, you just have to\nsuppress the type constraint to revert to a polymorphic version of the\nfunction.</p>\n<p>For our sorting routine, a single type constraint on the argument of the\n<code>exchange</code> function warranties a monomorphic typing, that allows a proper trace\nof function calls:</p>\n<pre><code class="language-ocaml"># let exchange i j (v : int array) =    (* notice the type constraint *)\n  let aux = v.(i) in\n    v.(i) &lt;- v.(j);\n    v.(j) &lt;- aux\nval exchange : int -&gt; int -&gt; int array -&gt; unit = &lt;fun&gt;\n# let one_pass_vect fin v =\n  for j = 1 to fin do\n    if v.(j - 1) &gt; v.(j) then exchange (j - 1) j v\n  done\nval one_pass_vect : int -&gt; int array -&gt; unit = &lt;fun&gt;\n# let bubble_sort_vect v =\n  for i = Array.length v - 1 downto 0 do\n    one_pass_vect i v\n  done\nval bubble_sort_vect : int array -&gt; unit = &lt;fun&gt;\n# let q = [| 18; 3; 1 |]\nval q : int array = [|18; 3; 1|]\n# #trace one_pass_vect\none_pass_vect is now traced.\n# bubble_sort_vect q\none_pass_vect &lt;-- 2\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|18; 3; 1|]\none_pass_vect* --&gt; ()\none_pass_vect &lt;-- 1\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|3; 1; 18|]\none_pass_vect* --&gt; ()\none_pass_vect &lt;-- 0\none_pass_vect --&gt; &lt;fun&gt;\none_pass_vect* &lt;-- [|1; 3; 18|]\none_pass_vect* --&gt; ()\n- : unit = ()\n</code></pre>\n<h3 id="limitations">Limitations</h3>\n<p>To keep track of assignments to data structures and mutable variables in a\nprogram, the trace facility is not powerful enough. You need an extra mechanism\nto stop the program in any place and ask for internal values: that is a\nsymbolic debugger with its stepping feature.</p>\n<p>Stepping a functional program has a meaning which is a bit weird to define and\nunderstand. Let me say that we use the notion of <em>runtime events</em> that happen\nfor instance when a parameter is passed to a function or when entering a\npattern matching, or selecting a clause in a pttern matching. Computation\nprogress is taken into account by these events, independently of the\ninstructions executed on the hardware.</p>\n<p>Although this is difficult to implement, there exists such a debugger for OCaml\nunder Unix: <code>ocamldebug</code>. Its use is illustrated in the next section.</p>\n<p>In fact, for complex programs, it is likely the case that the programmer will\nuse explicit printing to find the bugs, since this methodology allows the\nreduction of the trace material: only useful data are printed and special\npurpose formats are more suited to get the relevant information, than what can\nbe output automatically by the generic pretty-printer used by the trace\nmechanism.</p>\n<h2 id="the-ocaml-debugger">The OCaml debugger</h2>\n<p>We now give a quick tutorial for the OCaml debugger (<code>ocamldebug</code>).  Before\nstarting, please note that <code>ocamldebug</code> does not work under native Windows\nports of OCaml (but it runs under the Cygwin port).</p>\n<h3 id="launching-the-debugger">Launching the debugger</h3>\n<p>Consider the following obviously wrong program written in the file\n<code>uncaught.ml</code>:</p>\n<pre><code class="language-ocaml">(* file uncaught.ml *)\nlet l = ref []\nlet find_address name = List.assoc name !l\nlet add_address name address = l := (name, address) :: ! l\n\nlet () =\n  add_address &quot;IRIA&quot; &quot;Rocquencourt&quot;;;\n  print_string (find_address &quot;INRIA&quot;); print_newline ();;\n</code></pre>\n<pre><code class="language-mdx-error">val l : (string * string) list ref = {contents = [(&quot;IRIA&quot;, &quot;Rocquencourt&quot;)]}\nval find_address : string -&gt; string = &lt;fun&gt;\nval add_address : string -&gt; string -&gt; unit = &lt;fun&gt;\nException: Not_found.\n</code></pre>\n<p>At runtime, the program raises an uncaught exception <code>Not_found</code>.  Suppose we\nwant to find where and why this exception has been raised, we can proceed as\nfollows. First, we compile the program in debug mode:</p>\n<pre><code>ocamlc -g uncaught.ml\n</code></pre>\n<p>We launch the debugger:</p>\n<pre><code>ocamldebug a.out\n</code></pre>\n<p>Then the debugger answers with a banner and a prompt:</p>\n<pre><code>OCaml Debugger version 4.12.0\n\n(ocd)\n</code></pre>\n<h3 id="finding-the-cause-of-a-spurious-exception">Finding the cause of a spurious exception</h3>\n<p>Type <code>r</code> (for <em>run</em>); you get</p>\n<pre><code>(ocd) r\nLoading program... done.\nTime : 12\nProgram end.\nUncaught exception: Not_found\n(ocd)\n</code></pre>\n<p>Self explanatory, isn\'t it? So, you want to step backward to set the program\ncounter before the time the exception is raised; hence type in <code>b</code> as\n<em>backstep</em>, and you get</p>\n<pre><code>(ocd) b\nTime : 11 - pc : 15500 - module List\n143     [] -&gt; &lt;|b|&gt;raise Not_found\n</code></pre>\n<p>The debugger tells you that you are in module <code>List</code>, inside a pattern matching\non a list that already chose the <code>[]</code> case and is about to execute <code>raise Not_found</code>, since the program is stopped just before this expression (as\nwitnessed by the <code>&lt;|b|&gt;</code> mark).</p>\n<p>But, as you know, you want the debugger to tell you which procedure calls the\none from <code>List</code>, and also who calls the procedure that calls the one from\n<code>List</code>; hence, you want a backtrace of the execution stack:</p>\n<pre><code>(ocd) bt\n#0  Pc : 15500  List char 3562\n#1  Pc : 19128  Uncaught char 221\n</code></pre>\n<p>So the last function called is from module <code>List</code> at character 3562, that is:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec assoc x = function\n  | [] -&gt; raise Not_found\n          ^\n  | (a,b)::l -&gt; if a = x then b else assoc x l\n</code></pre>\n<p>The function that calls it is in module <code>Uncaught</code>, file <code>uncaught.ml</code> char\n221:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">print_string (find_address &quot;INRIA&quot;); print_newline ();;\n                                  ^\n</code></pre>\n<p>To sum up: if you\'re developing a program you can compile it with the <code>-g</code>\noption, to be ready to debug the program if necessary. Hence, to find a\nspurious exception you just need to type <code>ocamldebug a.out</code>, then <code>r</code>, <code>b</code>, and\n<code>bt</code> gives you the backtrace.</p>\n<h3 id="getting-help-and-info-in-the-debugger">Getting help and info in the debugger</h3>\n<p>To get more info about the current status of the debugger you can ask it\ndirectly at the toplevel prompt of the debugger; for instance:</p>\n<pre><code>(ocd) info breakpoints\nNo breakpoint.\n\n(ocd) help break\n  1      15396  in List, character 3539\nbreak : Set breakpoint at specified line or function.\nSyntax: break function-name\nbreak @ [module] linenum\nbreak @ [module] # characternum\n</code></pre>\n<h3 id="setting-break-points">Setting break points</h3>\n<p>Let\'s set up a breakpoint and rerun the entire program from the\nbeginning (<code>(g)oto 0</code> then <code>(r)un</code>):</p>\n<pre><code>(ocd) break @Uncaught 9\nBreakpoint 3 at 19112 : file Uncaught, line 9 column 34\n\n(ocd) g 0\nTime : 0\nBeginning of program.\n\n(ocd) r\nTime : 6 - pc : 19112 - module Uncaught\nBreakpoint : 1\n9 add &quot;IRIA&quot; &quot;Rocquencourt&quot;&lt;|a|&gt;;;\n</code></pre>\n<p>Then, we can step and find what happens when <code>find_address</code> is about to be\ncalled</p>\n<pre><code>(ocd) s\nTime : 7 - pc : 19012 - module Uncaught\n5 let find_address name = &lt;|b|&gt;List.assoc name !l;;\n\n(ocd) p name\nname : string = &quot;INRIA&quot;\n\n(ocd) p !l\n$1 : (string * string) list = [&quot;IRIA&quot;, &quot;Rocquencourt&quot;]\n(ocd)\n</code></pre>\n<p>Now we can guess why <code>List.assoc</code> will fail to find &quot;INRIA&quot; in the list...</p>\n<h3 id="using-the-debugger-under-emacs">Using the debugger under Emacs</h3>\n<p>Under Emacs you call the debugger using <code>ESC-x</code> <code>ocamldebug a.out</code>. Then Emacs\nwill send you directly to the file and character reported by the debugger, and\nyou can step back and forth using <code>ESC-b</code> and <code>ESC-s</code>, you can set up break\npoints using <code>CTRL-X space</code>, and so on...</p>\n'},tl:{hd:{title:"Map",slug:"map",description:"Create a mapping using the standard library's Map module\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"stdlib",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:"\n## Module Map\n\nMap creates a \"mapping\". For instance, let's say I have some data that is\nusers and their associated passwords. I could with the Map module create\na mapping from user names to their passwords. The mapping module not\nonly does this but it does it fairly efficiently. It also does this in a\nfunctional way. In the example below I am going to do a mapping from\nstrings to strings. However, it is possible to do mappings with all\ndifferent types of data.\n\nTo create a Map I can do:\n\n```ocaml\n# module MyUsers = Map.Make(String)\nmodule MyUsers :\n  sig\n    type key = string\n    type 'a t = 'a Map.Make(String).t\n    val empty : 'a t\n    val is_empty : 'a t -> bool\n    val mem : key -> 'a t -> bool\n    val add : key -> 'a -> 'a t -> 'a t\n    val update : key -> ('a option -> 'a option) -> 'a t -> 'a t\n    val singleton : key -> 'a -> 'a t\n    val remove : key -> 'a t -> 'a t\n    val merge :\n      (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t\n    val union : (key -> 'a -> 'a -> 'a option) -> 'a t -> 'a t -> 'a t\n    val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int\n    val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool\n    val iter : (key -> 'a -> unit) -> 'a t -> unit\n    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val for_all : (key -> 'a -> bool) -> 'a t -> bool\n    val exists : (key -> 'a -> bool) -> 'a t -> bool\n    val filter : (key -> 'a -> bool) -> 'a t -> 'a t\n    val partition : (key -> 'a -> bool) -> 'a t -> 'a t * 'a t\n    val cardinal : 'a t -> int\n    val bindings : 'a t -> (key * 'a) list\n    val min_binding : 'a t -> key * 'a\n    val min_binding_opt : 'a t -> (key * 'a) option\n    val max_binding : 'a t -> key * 'a\n    val max_binding_opt : 'a t -> (key * 'a) option\n    val choose : 'a t -> key * 'a\n    val choose_opt : 'a t -> (key * 'a) option\n    val split : key -> 'a t -> 'a t * 'a option * 'a t\n    val find : key -> 'a t -> 'a\n    val find_opt : key -> 'a t -> 'a option\n    val find_first : (key -> bool) -> 'a t -> key * 'a\n    val find_first_opt : (key -> bool) -> 'a t -> (key * 'a) option\n    val find_last : (key -> bool) -> 'a t -> key * 'a\n    val find_last_opt : (key -> bool) -> 'a t -> (key * 'a) option\n    val map : ('a -> 'b) -> 'a t -> 'b t\n    val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t\n    val to_seq : 'a t -> (key * 'a) Seq.t\n    val to_seq_from : key -> 'a t -> (key * 'a) Seq.t\n    val add_seq : (key * 'a) Seq.t -> 'a t -> 'a t\n    val of_seq : (key * 'a) Seq.t -> 'a t\n  end\n```\n\nOK, we have created the module `MyUsers`.  Now, let's start putting\nsomething into it.  Where do we start?  Well, let's create an empty\nmap to begin with:\n\n```ocaml\n# let m = MyUsers.empty\nval m : 'a MyUsers.t = <abstr>\n```\n\nHummm. An empty map is kind of boring, so let's add some data.\n\n```ocaml\n# let m = MyUsers.add \"fred\" \"sugarplums\" m\nval m : string MyUsers.t = <abstr>\n```\n\nWe have now created a new map\u2014again called `m`, thus masking the previous\none\u2014by adding\n\"fred\" and his password \"sugarplums\" to our previous empty map.\nThere is a fairly important point to make here. Once we have added the\nstring \"sugarplums\" we have fixed the types of mappings that we can do.\nThis means our mapping in our module `MyUsers` is from strings _to strings_.\nIf we want a mapping from strings to integers or a mapping from integers\nto whatever we will have to create a different mapping.\n\nLet's add in some additional data just for kicks.\n\n```ocaml\n# let m = MyUsers.add \"tom\" \"ilovelucy\" m\nval m : string MyUsers.t = <abstr>\n# let m = MyUsers.add \"mark\" \"ocamlrules\" m\nval m : string MyUsers.t = <abstr>\n# let m = MyUsers.add \"pete\" \"linux\" m\nval m : string MyUsers.t = <abstr>\n```\n\nNow that we have some data inside of our map, wouldn't it be nice\nto be able to view that data at some point? Let's begin by creating a\nsimple print function.\n\n```ocaml\n# let print_user key password =\n  print_string(key ^ \" \" ^ password ^ \"\\n\")\nval print_user : string -> string -> unit = <fun>\n```\n\nWe have here a function that will take two strings, a key, and a password,\nand print them out nicely, including a new line character at the end.\nAll we need to do is to have this function applied to our mapping. Here\nis what that would look like.\n\n```ocaml\n# MyUsers.iter print_user m\nfred sugarplums\nmark ocamlrules\npete linux\ntom ilovelucy\n- : unit = ()\n```\nThe reason we put our data into a mapping however is probably so we can\nquickly find the data. Let's actually show how to do a find.\n\n```ocaml\n# MyUsers.find \"fred\" m\n- : string = \"sugarplums\"\n```\n\nThis should quickly and efficiently return Fred's password: \"sugarplums\".\n\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#module-map">Module Map</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:"<h2 id=\"module-map\">Module Map</h2>\n<p>Map creates a &quot;mapping&quot;. For instance, let's say I have some data that is\nusers and their associated passwords. I could with the Map module create\na mapping from user names to their passwords. The mapping module not\nonly does this but it does it fairly efficiently. It also does this in a\nfunctional way. In the example below I am going to do a mapping from\nstrings to strings. However, it is possible to do mappings with all\ndifferent types of data.</p>\n<p>To create a Map I can do:</p>\n<pre><code class=\"language-ocaml\"># module MyUsers = Map.Make(String)\nmodule MyUsers :\n  sig\n    type key = string\n    type 'a t = 'a Map.Make(String).t\n    val empty : 'a t\n    val is_empty : 'a t -&gt; bool\n    val mem : key -&gt; 'a t -&gt; bool\n    val add : key -&gt; 'a -&gt; 'a t -&gt; 'a t\n    val update : key -&gt; ('a option -&gt; 'a option) -&gt; 'a t -&gt; 'a t\n    val singleton : key -&gt; 'a -&gt; 'a t\n    val remove : key -&gt; 'a t -&gt; 'a t\n    val merge :\n      (key -&gt; 'a option -&gt; 'b option -&gt; 'c option) -&gt; 'a t -&gt; 'b t -&gt; 'c t\n    val union : (key -&gt; 'a -&gt; 'a -&gt; 'a option) -&gt; 'a t -&gt; 'a t -&gt; 'a t\n    val compare : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t -&gt; int\n    val equal : ('a -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t -&gt; bool\n    val iter : (key -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit\n    val fold : (key -&gt; 'a -&gt; 'b -&gt; 'b) -&gt; 'a t -&gt; 'b -&gt; 'b\n    val for_all : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; bool\n    val exists : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; bool\n    val filter : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t\n    val partition : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t * 'a t\n    val cardinal : 'a t -&gt; int\n    val bindings : 'a t -&gt; (key * 'a) list\n    val min_binding : 'a t -&gt; key * 'a\n    val min_binding_opt : 'a t -&gt; (key * 'a) option\n    val max_binding : 'a t -&gt; key * 'a\n    val max_binding_opt : 'a t -&gt; (key * 'a) option\n    val choose : 'a t -&gt; key * 'a\n    val choose_opt : 'a t -&gt; (key * 'a) option\n    val split : key -&gt; 'a t -&gt; 'a t * 'a option * 'a t\n    val find : key -&gt; 'a t -&gt; 'a\n    val find_opt : key -&gt; 'a t -&gt; 'a option\n    val find_first : (key -&gt; bool) -&gt; 'a t -&gt; key * 'a\n    val find_first_opt : (key -&gt; bool) -&gt; 'a t -&gt; (key * 'a) option\n    val find_last : (key -&gt; bool) -&gt; 'a t -&gt; key * 'a\n    val find_last_opt : (key -&gt; bool) -&gt; 'a t -&gt; (key * 'a) option\n    val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val mapi : (key -&gt; 'a -&gt; 'b) -&gt; 'a t -&gt; 'b t\n    val to_seq : 'a t -&gt; (key * 'a) Seq.t\n    val to_seq_from : key -&gt; 'a t -&gt; (key * 'a) Seq.t\n    val add_seq : (key * 'a) Seq.t -&gt; 'a t -&gt; 'a t\n    val of_seq : (key * 'a) Seq.t -&gt; 'a t\n  end\n</code></pre>\n<p>OK, we have created the module <code>MyUsers</code>.  Now, let's start putting\nsomething into it.  Where do we start?  Well, let's create an empty\nmap to begin with:</p>\n<pre><code class=\"language-ocaml\"># let m = MyUsers.empty\nval m : 'a MyUsers.t = &lt;abstr&gt;\n</code></pre>\n<p>Hummm. An empty map is kind of boring, so let's add some data.</p>\n<pre><code class=\"language-ocaml\"># let m = MyUsers.add &quot;fred&quot; &quot;sugarplums&quot; m\nval m : string MyUsers.t = &lt;abstr&gt;\n</code></pre>\n<p>We have now created a new map\u2014again called <code>m</code>, thus masking the previous\none\u2014by adding\n&quot;fred&quot; and his password &quot;sugarplums&quot; to our previous empty map.\nThere is a fairly important point to make here. Once we have added the\nstring &quot;sugarplums&quot; we have fixed the types of mappings that we can do.\nThis means our mapping in our module <code>MyUsers</code> is from strings <em>to strings</em>.\nIf we want a mapping from strings to integers or a mapping from integers\nto whatever we will have to create a different mapping.</p>\n<p>Let's add in some additional data just for kicks.</p>\n<pre><code class=\"language-ocaml\"># let m = MyUsers.add &quot;tom&quot; &quot;ilovelucy&quot; m\nval m : string MyUsers.t = &lt;abstr&gt;\n# let m = MyUsers.add &quot;mark&quot; &quot;ocamlrules&quot; m\nval m : string MyUsers.t = &lt;abstr&gt;\n# let m = MyUsers.add &quot;pete&quot; &quot;linux&quot; m\nval m : string MyUsers.t = &lt;abstr&gt;\n</code></pre>\n<p>Now that we have some data inside of our map, wouldn't it be nice\nto be able to view that data at some point? Let's begin by creating a\nsimple print function.</p>\n<pre><code class=\"language-ocaml\"># let print_user key password =\n  print_string(key ^ &quot; &quot; ^ password ^ &quot;\\n&quot;)\nval print_user : string -&gt; string -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>We have here a function that will take two strings, a key, and a password,\nand print them out nicely, including a new line character at the end.\nAll we need to do is to have this function applied to our mapping. Here\nis what that would look like.</p>\n<pre><code class=\"language-ocaml\"># MyUsers.iter print_user m\nfred sugarplums\nmark ocamlrules\npete linux\ntom ilovelucy\n- : unit = ()\n</code></pre>\n<p>The reason we put our data into a mapping however is probably so we can\nquickly find the data. Let's actually show how to do a find.</p>\n<pre><code class=\"language-ocaml\"># MyUsers.find &quot;fred&quot; m\n- : string = &quot;sugarplums&quot;\n</code></pre>\n<p>This should quickly and efficiently return Fred's password: &quot;sugarplums&quot;.</p>\n"},tl:{hd:{title:"Sets",slug:"sets",description:"The standard library's Set module\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"stdlib",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:'\n## Module Set\nTo make a set of strings:\n\n```ocaml\n# module SS = Set.Make(String)\nmodule SS :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -> bool\n    val mem : elt -> t -> bool\n    val add : elt -> t -> t\n    val singleton : elt -> t\n    val remove : elt -> t -> t\n    val union : t -> t -> t\n    val inter : t -> t -> t\n    val disjoint : t -> t -> bool\n    val diff : t -> t -> t\n    val compare : t -> t -> int\n    val equal : t -> t -> bool\n    val subset : t -> t -> bool\n    val iter : (elt -> unit) -> t -> unit\n    val map : (elt -> elt) -> t -> t\n    val fold : (elt -> \'a -> \'a) -> t -> \'a -> \'a\n    val for_all : (elt -> bool) -> t -> bool\n    val exists : (elt -> bool) -> t -> bool\n    val filter : (elt -> bool) -> t -> t\n    val partition : (elt -> bool) -> t -> t * t\n    val cardinal : t -> int\n    val elements : t -> elt list\n    val min_elt : t -> elt\n    val min_elt_opt : t -> elt option\n    val max_elt : t -> elt\n    val max_elt_opt : t -> elt option\n    val choose : t -> elt\n    val choose_opt : t -> elt option\n    val split : elt -> t -> t * bool * t\n    val find : elt -> t -> elt\n    val find_opt : elt -> t -> elt option\n    val find_first : (elt -> bool) -> t -> elt\n    val find_first_opt : (elt -> bool) -> t -> elt option\n    val find_last : (elt -> bool) -> t -> elt\n    val find_last_opt : (elt -> bool) -> t -> elt option\n    val of_list : elt list -> t\n    val to_seq_from : elt -> t -> elt Seq.t\n    val to_seq : t -> elt Seq.t\n    val add_seq : elt Seq.t -> t -> t\n    val of_seq : elt Seq.t -> t\n  end\n```\n\nTo create a set you need to start somewhere so here is the empty set:\n\n```ocaml\n# let s = SS.empty\nval s : SS.t = <abstr>\n```\n\nAlternatively if we know an element to start with we can create a set\nlike\n\n```ocaml\n# let s = SS.singleton "hello"\nval s : SS.t = <abstr>\n```\n\nTo add some elements to the set we can do.\n\n```ocaml\n# let s =\n  List.fold_right SS.add ["hello"; "world"; "community"; "manager";\n                          "stuff"; "blue"; "green"] s\nval s : SS.t = <abstr>\n```\n\nNow if we are playing around with sets we will probably want to see what\nis in the set that we have created. To do this we can write a function\nthat will print the set out.\n\n```ocaml\n# let print_set s = \n   SS.iter print_endline s\nval print_set : SS.t -> unit = <fun>\n```\n\nIf we want to remove a specific element of a set there is a remove\nfunction. However if we want to remove several elements at once we could\nthink of it as doing a \'filter\'. Let\'s filter out all words that are\nlonger than 5 characters.\n\nThis can be written as:\n\n```ocaml\n# let my_filter str =\n  String.length str <= 5\nval my_filter : string -> bool = <fun>\n# let s2 = SS.filter my_filter s\nval s2 : SS.t = <abstr>\n```\n\nor using an anonymous function:\n\n```ocaml\n# let s2 = SS.filter (fun str -> String.length str <= 5) s\nval s2 : SS.t = <abstr>\n```\n\nIf we want to check and see if an element is in the set it might look\nlike this.\n\n```ocaml\n# SS.mem "hello" s2\n- : bool = true\n```\n\nThe Set module also provides the set theoretic operations union,\nintersection and difference. For example, the difference of the original\nset and the set with short strings (\u2264 5 characters) is the set of long\nstrings:\n\n```ocaml\n# print_set (SS.diff s s2)\ncommunity\nmanager\n- : unit = ()\n```\n\nNote that the Set module provides a purely functional data structure:\nremoving an element from a set does not alter that set but, rather,\nreturns a new set that is very similar to (and shares much of its\ninternals with) the original set.\n\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#module-set">Module Set</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="module-set">Module Set</h2>\n<p>To make a set of strings:</p>\n<pre><code class="language-ocaml"># module SS = Set.Make(String)\nmodule SS :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -&gt; bool\n    val mem : elt -&gt; t -&gt; bool\n    val add : elt -&gt; t -&gt; t\n    val singleton : elt -&gt; t\n    val remove : elt -&gt; t -&gt; t\n    val union : t -&gt; t -&gt; t\n    val inter : t -&gt; t -&gt; t\n    val disjoint : t -&gt; t -&gt; bool\n    val diff : t -&gt; t -&gt; t\n    val compare : t -&gt; t -&gt; int\n    val equal : t -&gt; t -&gt; bool\n    val subset : t -&gt; t -&gt; bool\n    val iter : (elt -&gt; unit) -&gt; t -&gt; unit\n    val map : (elt -&gt; elt) -&gt; t -&gt; t\n    val fold : (elt -&gt; \'a -&gt; \'a) -&gt; t -&gt; \'a -&gt; \'a\n    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool\n    val exists : (elt -&gt; bool) -&gt; t -&gt; bool\n    val filter : (elt -&gt; bool) -&gt; t -&gt; t\n    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t\n    val cardinal : t -&gt; int\n    val elements : t -&gt; elt list\n    val min_elt : t -&gt; elt\n    val min_elt_opt : t -&gt; elt option\n    val max_elt : t -&gt; elt\n    val max_elt_opt : t -&gt; elt option\n    val choose : t -&gt; elt\n    val choose_opt : t -&gt; elt option\n    val split : elt -&gt; t -&gt; t * bool * t\n    val find : elt -&gt; t -&gt; elt\n    val find_opt : elt -&gt; t -&gt; elt option\n    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt\n    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option\n    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt\n    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option\n    val of_list : elt list -&gt; t\n    val to_seq_from : elt -&gt; t -&gt; elt Seq.t\n    val to_seq : t -&gt; elt Seq.t\n    val add_seq : elt Seq.t -&gt; t -&gt; t\n    val of_seq : elt Seq.t -&gt; t\n  end\n</code></pre>\n<p>To create a set you need to start somewhere so here is the empty set:</p>\n<pre><code class="language-ocaml"># let s = SS.empty\nval s : SS.t = &lt;abstr&gt;\n</code></pre>\n<p>Alternatively if we know an element to start with we can create a set\nlike</p>\n<pre><code class="language-ocaml"># let s = SS.singleton &quot;hello&quot;\nval s : SS.t = &lt;abstr&gt;\n</code></pre>\n<p>To add some elements to the set we can do.</p>\n<pre><code class="language-ocaml"># let s =\n  List.fold_right SS.add [&quot;hello&quot;; &quot;world&quot;; &quot;community&quot;; &quot;manager&quot;;\n                          &quot;stuff&quot;; &quot;blue&quot;; &quot;green&quot;] s\nval s : SS.t = &lt;abstr&gt;\n</code></pre>\n<p>Now if we are playing around with sets we will probably want to see what\nis in the set that we have created. To do this we can write a function\nthat will print the set out.</p>\n<pre><code class="language-ocaml"># let print_set s = \n   SS.iter print_endline s\nval print_set : SS.t -&gt; unit = &lt;fun&gt;\n</code></pre>\n<p>If we want to remove a specific element of a set there is a remove\nfunction. However if we want to remove several elements at once we could\nthink of it as doing a \'filter\'. Let\'s filter out all words that are\nlonger than 5 characters.</p>\n<p>This can be written as:</p>\n<pre><code class="language-ocaml"># let my_filter str =\n  String.length str &lt;= 5\nval my_filter : string -&gt; bool = &lt;fun&gt;\n# let s2 = SS.filter my_filter s\nval s2 : SS.t = &lt;abstr&gt;\n</code></pre>\n<p>or using an anonymous function:</p>\n<pre><code class="language-ocaml"># let s2 = SS.filter (fun str -&gt; String.length str &lt;= 5) s\nval s2 : SS.t = &lt;abstr&gt;\n</code></pre>\n<p>If we want to check and see if an element is in the set it might look\nlike this.</p>\n<pre><code class="language-ocaml"># SS.mem &quot;hello&quot; s2\n- : bool = true\n</code></pre>\n<p>The Set module also provides the set theoretic operations union,\nintersection and difference. For example, the difference of the original\nset and the set with short strings (\u2264 5 characters) is the set of long\nstrings:</p>\n<pre><code class="language-ocaml"># print_set (SS.diff s s2)\ncommunity\nmanager\n- : unit = ()\n</code></pre>\n<p>Note that the Set module provides a purely functional data structure:\nremoving an element from a set does not alter that set but, rather,\nreturns a new set that is very similar to (and shares much of its\ninternals with) the original set.</p>\n'},tl:{hd:{title:"Hashtables",slug:"hashtables",description:"Discover efficient and mutable lookup tables with OCaml's Hashtbl module\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"stdlib",tl:0},users:{hd:"Intermediate",tl:{hd:"Advanced",tl:0}},body_md:'\n## Module Hashtbl\n\nThe Hashtbl module implements an efficient, mutable lookup table. To\ncreate a hash table we could write:\n\n```ocaml\n# let my_hash = Hashtbl.create 123456\nval my_hash : (\'_weak1, \'_weak2) Hashtbl.t = <abstr>\n```\nThe 123456 is the initial size of the hashtbl. This initial number is\njust your best guess as to the amount of data that you will be putting\ninto the hash table. The hash table can grow if you under-estimate the\nsize so don\'t worry about it too much. The type of my_hash is:\n\n```ocaml\n# my_hash\n- : (\'_weak1, \'_weak2) Hashtbl.t = <abstr>\n```\n\nThe `\'_weak1` and `\'_weak2` correspond to the key and value types, respectively.\nThere are no concrete types (e.g., `int` or `float * string`) filled in in\nthose slots because the type of the key and value are not yet\ndetermined. The underscore indicates that the key and data types, once\nchosen, will be fixed. In other words, you can\'t sometimes use a given\nhashtable with ints for keys, and then later use a string as a key in\nthat same hashtable.\n\nLets add some data to `my_hash`. Lets say I am working on a cross word\nsolving program and I want to find all words that start with a certain\nletter. First I need to enter the data into `my_hash`.\n\nNote that a hashtable is modified by in-place updates, so, unlike a map,\nanother hash table is _not_ created every time you change the table. Thus,\nthe code `let my_hash = Hashtbl.add my_hash ...` wouldn\'t make any\nsense. Instead, we would write something like this:\n\n```ocaml\n# Hashtbl.add my_hash "h" "hello";\n  Hashtbl.add my_hash "h" "hi";\n  Hashtbl.add my_hash "h" "hug";\n  Hashtbl.add my_hash "h" "hard";\n  Hashtbl.add my_hash "w" "wimp";\n  Hashtbl.add my_hash "w" "world";\n  Hashtbl.add my_hash "w" "wine"\n- : unit = ()\n```\n\nIf we want to find one element in `my_hash` that has an `"h"` in it then we\nwould write: \n\n```ocaml\n# Hashtbl.find my_hash "h"\n- : string = "hard"\n```\n\nNotice how it returns just one element? That element\nwas the last one entered in with the value of `"h"`.\n\nWhat we probably want is all the elements that start with `"h"`. To do\nthis we want to *find all* of them. What better name for this than\n`find_all`?\n\n```ocaml\n# Hashtbl.find_all my_hash "h"\n- : string list = ["hard"; "hug"; "hi"; "hello"]\n```\n\nreturns `["hard"; "hug"; "hi"; "hello"]`.\n\nIf you remove a key, its previous value becomes again the default one\nassociated to the key.\n\n```ocaml\n# Hashtbl.remove my_hash "h";;\n- : unit = ()\n# Hashtbl.find my_hash "h";;\n- : string = "hug"\n```\n\nThis behavior is interesting for the above example or when, say, the\nkeys represent variables that can be temporarily masked by a local\nvariables of the same name.\n\nIn other contexts, one may prefer new values to *replace* the previous\nones.  In this case, one uses `Hashtbl.replace`:\n\n```ocaml\n# Hashtbl.replace my_hash "t" "try";\n  Hashtbl.replace my_hash "t" "test";\n  Hashtbl.find_all my_hash "t"\n- : string list = ["test"]\n\n# Hashtbl.remove my_hash "t";\n  Hashtbl.find my_hash "t"\nException: Not_found.\n```\n\nTo find out whether there is an\nentry in `my_hash` for a letter we would do:\n\n```ocaml\n# Hashtbl.mem my_hash "h"\n- : bool = true\n```\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#module-hashtbl">Module Hashtbl</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="module-hashtbl">Module Hashtbl</h2>\n<p>The Hashtbl module implements an efficient, mutable lookup table. To\ncreate a hash table we could write:</p>\n<pre><code class="language-ocaml"># let my_hash = Hashtbl.create 123456\nval my_hash : (\'_weak1, \'_weak2) Hashtbl.t = &lt;abstr&gt;\n</code></pre>\n<p>The 123456 is the initial size of the hashtbl. This initial number is\njust your best guess as to the amount of data that you will be putting\ninto the hash table. The hash table can grow if you under-estimate the\nsize so don\'t worry about it too much. The type of my_hash is:</p>\n<pre><code class="language-ocaml"># my_hash\n- : (\'_weak1, \'_weak2) Hashtbl.t = &lt;abstr&gt;\n</code></pre>\n<p>The <code>\'_weak1</code> and <code>\'_weak2</code> correspond to the key and value types, respectively.\nThere are no concrete types (e.g., <code>int</code> or <code>float * string</code>) filled in in\nthose slots because the type of the key and value are not yet\ndetermined. The underscore indicates that the key and data types, once\nchosen, will be fixed. In other words, you can\'t sometimes use a given\nhashtable with ints for keys, and then later use a string as a key in\nthat same hashtable.</p>\n<p>Lets add some data to <code>my_hash</code>. Lets say I am working on a cross word\nsolving program and I want to find all words that start with a certain\nletter. First I need to enter the data into <code>my_hash</code>.</p>\n<p>Note that a hashtable is modified by in-place updates, so, unlike a map,\nanother hash table is <em>not</em> created every time you change the table. Thus,\nthe code <code>let my_hash = Hashtbl.add my_hash ...</code> wouldn\'t make any\nsense. Instead, we would write something like this:</p>\n<pre><code class="language-ocaml"># Hashtbl.add my_hash &quot;h&quot; &quot;hello&quot;;\n  Hashtbl.add my_hash &quot;h&quot; &quot;hi&quot;;\n  Hashtbl.add my_hash &quot;h&quot; &quot;hug&quot;;\n  Hashtbl.add my_hash &quot;h&quot; &quot;hard&quot;;\n  Hashtbl.add my_hash &quot;w&quot; &quot;wimp&quot;;\n  Hashtbl.add my_hash &quot;w&quot; &quot;world&quot;;\n  Hashtbl.add my_hash &quot;w&quot; &quot;wine&quot;\n- : unit = ()\n</code></pre>\n<p>If we want to find one element in <code>my_hash</code> that has an <code>&quot;h&quot;</code> in it then we\nwould write:</p>\n<pre><code class="language-ocaml"># Hashtbl.find my_hash &quot;h&quot;\n- : string = &quot;hard&quot;\n</code></pre>\n<p>Notice how it returns just one element? That element\nwas the last one entered in with the value of <code>&quot;h&quot;</code>.</p>\n<p>What we probably want is all the elements that start with <code>&quot;h&quot;</code>. To do\nthis we want to <em>find all</em> of them. What better name for this than\n<code>find_all</code>?</p>\n<pre><code class="language-ocaml"># Hashtbl.find_all my_hash &quot;h&quot;\n- : string list = [&quot;hard&quot;; &quot;hug&quot;; &quot;hi&quot;; &quot;hello&quot;]\n</code></pre>\n<p>returns <code>[&quot;hard&quot;; &quot;hug&quot;; &quot;hi&quot;; &quot;hello&quot;]</code>.</p>\n<p>If you remove a key, its previous value becomes again the default one\nassociated to the key.</p>\n<pre><code class="language-ocaml"># Hashtbl.remove my_hash &quot;h&quot;;;\n- : unit = ()\n# Hashtbl.find my_hash &quot;h&quot;;;\n- : string = &quot;hug&quot;\n</code></pre>\n<p>This behavior is interesting for the above example or when, say, the\nkeys represent variables that can be temporarily masked by a local\nvariables of the same name.</p>\n<p>In other contexts, one may prefer new values to <em>replace</em> the previous\nones.  In this case, one uses <code>Hashtbl.replace</code>:</p>\n<pre><code class="language-ocaml"># Hashtbl.replace my_hash &quot;t&quot; &quot;try&quot;;\n  Hashtbl.replace my_hash &quot;t&quot; &quot;test&quot;;\n  Hashtbl.find_all my_hash &quot;t&quot;\n- : string list = [&quot;test&quot;]\n\n# Hashtbl.remove my_hash &quot;t&quot;;\n  Hashtbl.find my_hash &quot;t&quot;\nException: Not_found.\n</code></pre>\n<p>To find out whether there is an\nentry in <code>my_hash</code> for a letter we would do:</p>\n<pre><code class="language-ocaml"># Hashtbl.mem my_hash &quot;h&quot;\n- : bool = true\n</code></pre>\n'},tl:{hd:{title:"Streams",slug:"streams",description:"Streams offer an abstraction over consuming items from sequences\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"stdlib",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:"\nSuppose you need to process each line of a text file. One way to do this\nis to read the file in as a single large string and use something like\n`Str.split` to turn it into a list. This works when the file is small,\nbut because the entire file is loaded into memory, it does not scale\nwell when the file is large.\n\nMore commonly, the `input_line` function can be used to read one line at\na time from a channel. This typically looks like:\n\n```ocaml\nlet in_channel = open_in \"lines.txt\" in\ntry\n  while true do\n    let line = input_line in_channel in\n    (* do something with line *)\n  done\nwith End_of_file ->\n  close_in in_channel\n```\n```mdx-error\nLine 6, characters 5-9:\nError: Syntax error\n```\n\nThe above code is efficient with memory, but it can be inconvenient in\nother ways. Since `input_line` only works with the `in_channel` type, it\ncannot be reused in cases where the text is already in memory. The\n`End_of_file` exception can be raised at any point during iteration, and\nit is the programmer's responsibility to ensure that the file is closed\nappropriately. In fact, if there is any other exception in the above\nexample, the file will not be closed at all. Altogether, there is a lot\ngoing on: channels, I/O, exceptions, and files.\n\nStreams offer an abstraction over one part of this process: reading\nitems from a sequence. They don't assume anything about files or\nchannels, and they replace the `End_of_file` exception with a more\nstructured approach to dealing with the end of input. Here is a function\nthat builds a stream of lines from an input channel:\n\n```ocaml\n# let line_stream_of_channel channel =\n  Stream.from\n    (fun _ ->\n       try Some (input_line channel) with End_of_file -> None)\nval line_stream_of_channel : in_channel -> string Stream.t = <fun>\n```\nThe \"Stream.from\" function builds a stream from a callback function.\nThis function is passed the current stream count (starting with 0) as an\nargument and is expected to return an `'a option`. If the option has a\nvalue (`Some x`), that value will be the next item in the stream. If it\nhas no value (`None`), this indicates that the stream is empty and no\nfurther reads will be attempted. Since the option is polymorphic,\n`Stream.from` can construct streams of any type. These streams have a\ntype of `'a Stream.t`.\n\nWith this simple function, we can now easily construct line streams from\nany input channel:\n\n```ocaml\n# let in_channel = open_in \"019_streams.md\"\nval in_channel : in_channel = <abstr>\n# let lines = line_stream_of_channel in_channel\nval lines : string Stream.t = <abstr>\n```\n\nThis variable `lines` is a stream of strings, one string per line. We\ncan now begin reading lines from it by passing it to `Stream.next`:\n\n```ocaml\n# Stream.next lines\n- : string = \"---\"\n# Stream.next lines\n- : string = \"title: Streams\"\n# Stream.next lines\n- : string = \"description: >\"\n# Stream.next lines\n- : string =\n\"  Streams offer an abstraction over consuming items from sequences\"\n# while true do ignore(Stream.next lines) done\nException: Stdlib.Stream.Failure.\n```\n\nAs you can see, `Stream.next` either returns the next item in the stream\nor raises a `Stream.Failure` exception indicating that the stream is\nempty. Likewise, with a little help from the `Stream.of_list`\nconstructor and the `Str` regular expression module, we could build a\nstream of lines from a string in memory:\n\n```ocaml\n# #load \"str.cma\"\n# let line_stream_of_string string =\n  Stream.of_list (Str.split (Str.regexp \"\\n\") string)\nval line_stream_of_string : string -> string Stream.t = <fun>\n```\nand these streams could be used exactly the same way:\n\n```ocaml\n# let lines = line_stream_of_string \"hello\\nstream\\nworld\"\nval lines : string Stream.t = <abstr>\n# Stream.next lines\n- : string = \"hello\"\n# Stream.next lines\n- : string = \"stream\"\n# Stream.next lines\n- : string = \"world\"\n# Stream.next lines\nException: Stdlib.Stream.Failure.\n```\n\nSince both cases raise `Stream.Failure` on an empty stream, there is no\nneed to worry about catching `End_of_file` in the case of file I/O. This\nunified interface makes it much easier to write functions that can\nreceive data from multiple sources.\n\nThe `Stream.iter` function automates the common task of performing an\noperation for each item. With it, we can rewrite the original example as\nfollows:\n\n```ocaml\nlet in_channel = open_in \"019_streams.md\" in\ntry\n  Stream.iter\n    (fun line ->\n       (* do something with line *)\n       print_endline line)\n    (line_stream_of_channel in_channel);\n  close_in in_channel\nwith e ->\n  close_in in_channel;\n  raise e\n```\n\nNote how much easier it is to handle I/O exceptions properly, since we\ncan deal with them independently from the end-of-file condition. This\nseparation of concerns allows us to decompose this into simpler and more\nreusable functions:\n\n```ocaml\n# let process_line line =\n  print_endline line\nval process_line : string -> unit = <fun>\n\n# let process_lines lines =\n  Stream.iter process_line lines\nval process_lines : string Stream.t -> unit = <fun>\n\n# let process_file filename =\n  let in_channel = open_in filename in\n  try\n    process_lines (line_stream_of_channel in_channel);\n    close_in in_channel\n  with e ->\n    close_in in_channel;\n    raise e\nval process_file : string -> unit = <fun>\n\n# let process_string string =\n  process_lines (line_stream_of_string string)\nval process_string : string -> unit = <fun>\n```\n\n## Constructing streams\nIn the above examples, we saw two methods for constructing streams:\n\n* Stream.from, which builds a stream from a callback function\n* Stream.of_list, which builds a stream from a list in memory\n\nThe `Stream` module provides a few other stream builders:\n\n* Stream.of_string, which builds a character stream from a string\n* Stream.of_channel, which builds a character stream from a channel\n\n`Stream.from` is the most general, and it can be used to produce streams\nof any type. It is not limited to I/O and can even produce infinite\nsequences. Here are a few simple stream builders defined with\n`Stream.from`:\n\n```ocaml\n# let empty_stream () = Stream.from (fun _ -> None)\nval empty_stream : unit -> 'a Stream.t = <fun>\n# let const_stream k = Stream.from (fun _ -> Some k)\nval const_stream : 'a -> 'a Stream.t = <fun>\n# let count_stream i = Stream.from (fun j -> Some (i + j))\nval count_stream : int -> int Stream.t = <fun>\n```\n\n## Deconstructing streams\nWe already saw the `Stream.next` function, which retrieves a single item\nfrom a stream. There is another way to work with streams that is often\npreferable: `Stream.peek` and `Stream.junk`. When used together, these\nfunctions allow you to see what the next item would be. This feature,\nknown as \"look ahead\", is very useful when writing parsers. Even if you\ndon't need to look ahead, the peek/junk protocol may be nicer to work\nwith because it uses options instead of exceptions:\n\n```ocaml\n# let lines = line_stream_of_string \"hello\\nworld\"\nval lines : string Stream.t = <abstr>\n# Stream.peek lines\n- : string option = Some \"hello\"\n# Stream.peek lines\n- : string option = Some \"hello\"\n# Stream.junk lines\n- : unit = ()\n# Stream.peek lines\n- : string option = Some \"world\"\n# Stream.junk lines\n- : unit = ()\n# Stream.peek lines\n- : string option = None\n```\n\nAs you can see, it is necessary to call `Stream.junk` to advance to the\nnext item. `Stream.peek` will always give you either the next item or\n`None`, and it will never fail. Likewise, `Stream.junk` always succeeds\n(even if the stream is empty).\n\n## A more complex `Stream.from` example\nHere is a function that converts a line stream into a paragraph stream.\nAs such, it is both a stream consumer and a stream producer.\n\n```ocaml\n# let paragraphs lines =\n  let rec next para_lines i =\n    match Stream.peek lines, para_lines with\n    | None, [] -> None\n    | Some \"\", [] ->\n        Stream.junk lines;\n        next para_lines i\n    | Some \"\", _ | None, _ ->\n        Some (String.concat \"\\n\" (List.rev para_lines))\n    | Some line, _ ->\n        Stream.junk lines;\n        next (line :: para_lines) i in\n  Stream.from (next [])\nval paragraphs : string Stream.t -> string Stream.t = <fun>\n```\n\nThis function uses an extra parameter to `next` (the `Stream.from`\ncallback) called `para_lines` in order to collect the lines for each\nparagraph. Paragraphs are delimited by any number of blank lines.\n\nEach time `next` is called, a `match` expression tests two values: the\nnext line in the stream, and the contents of `para_lines`. Four cases\nare handled:\n\n1. If the end of the stream is reached and no lines have been\n collected, the paragraph stream ends as well.\n1. If the next line is blank and no lines have been collected, the\n blank is ignored and `next` is called recursively to keep looking\n for a non-blank line.\n1. If a blank line or end of stream is reached and lines **have** been\n collected, the paragraph is returned by concatenating `para_lines`\n to a single string.\n1. Finally, if a non-blank line has been reached, the line is collected\n by recursively calling `para_lines`.\n\nHappily, we can rely on the OCaml compiler's exhaustiveness checking to\nensure that we are handling all possible cases.\n\nWith this new tool, we can now work just as easily with paragraphs as we\ncould before with lines:\n\n```ocaml\n(* Print each paragraph, followed by a separator. *)\nlet lines = line_stream_of_channel in_channel in\nStream.iter\n  (fun para ->\n     print_endline para;\n     print_endline \"--\")\n  (paragraphs lines)\n```\nFunctions like `paragraphs` that produce and consume streams can be\ncomposed together in a manner very similar to UNIX pipes and filters.\n\n## Stream combinators\nJust like lists and arrays, common iteration patterns such as `map`,\n`filter`, and `fold` can be very useful. The `Stream` module does not\nprovide such functions, but they can be built easily using\n`Stream.from`:\n\n```ocaml\n# let stream_map f stream =\n  let rec next i =\n    try Some (f (Stream.next stream))\n    with Stream.Failure -> None in\n  Stream.from next\nval stream_map : ('a -> 'b) -> 'a Stream.t -> 'b Stream.t = <fun>\n\n# let stream_filter p stream =\n  let rec next i =\n    try\n      let value = Stream.next stream in\n      if p value then Some value else next i\n    with Stream.Failure -> None in\n  Stream.from next\nval stream_filter : ('a -> bool) -> 'a Stream.t -> 'a Stream.t = <fun>\n\n# let stream_fold f stream init =\n  let result = ref init in\n  Stream.iter\n    (fun x -> result := f x !result)\n    stream;\n  !result\nval stream_fold : ('a -> 'b -> 'b) -> 'a Stream.t -> 'b -> 'b = <fun>\n```\nFor example, here is a stream of leap years starting with 2000:\n\n```ocaml\n# let is_leap year =\n  year mod 4 = 0 && (year mod 100 <> 0 || year mod 400 = 0)\nval is_leap : int -> bool = <fun>\n# let leap_years = stream_filter is_leap (count_stream 2000)\nval leap_years : int Stream.t = <abstr>\n```\n\nWe can use the `Stream.npeek` function to look ahead by more than one\nitem. In this case, we'll peek at the next 30 items to make sure that\nthe year 2100 is not a leap year (since it's divisible by 100 but not\n400!):\n\n```ocaml\n# Stream.npeek 30 leap_years\n- : int list =\n[2000; 2004; 2008; 2012; 2016; 2020; 2024; 2028; 2032; 2036; 2040; 2044;\n 2048; 2052; 2056; 2060; 2064; 2068; 2072; 2076; 2080; 2084; 2088; 2092;\n 2096; 2104; 2108; 2112; 2116; 2120]\n```\n\nNote that we must be careful not to use `Stream.iter` on an infinite\nstream like `leap_years`. This applies to `stream_fold`, as well as any\nfunction that attempts to consume the entire stream.\n\n```ocaml\n# stream_fold (+) (Stream.of_list [1; 2; 3]) 0\n- : int = 6\n```\n\n`stream_fold (+) (count_stream 0) 0` runs forever.\n\n## Other useful stream builders\nThe previously defined `const_stream` function builds a stream that\nrepeats a single value. It is also useful to build a stream that repeats\na sequence of values. The following function does just that:\n\n```ocaml\n# let cycle items =\n  let buf = ref [] in\n  let rec next i =\n    if !buf = [] then buf := items;\n    match !buf with\n      | h :: t -> (buf := t; Some h)\n      | [] -> None in\n  Stream.from next\nval cycle : 'a list -> 'a Stream.t = <fun>\n```\n\nOne common task that can benefit from this kind of stream is the\ngeneration of alternating background colors for HTML. By using `cycle`\nwith `stream_combine`, explained in the next section, an infinite stream\nof background colors can be combined with a finite stream of data to\nproduce a sequence of HTML blocks:\n\n```ocaml\n# let stream_combine stream1 stream2 =\n  let rec next i =\n    try Some (Stream.next stream1, Stream.next stream2)\n    with Stream.Failure -> None in\n  Stream.from next\nval stream_combine : 'a Stream.t -> 'b Stream.t -> ('a * 'b) Stream.t = <fun>\n# Stream.iter print_endline\n  (stream_map\n     (fun (bg, s) ->\n        Printf.sprintf \"<div style='background: %s'>%s</div>\" bg s)\n     (stream_combine\n        (cycle [\"#eee\"; \"#fff\"])\n        (Stream.of_list [\"hello\"; \"html\"; \"world\"])))\n<div style='background: #eee'>hello</div>\n<div style='background: #fff'>html</div>\n<div style='background: #eee'>world</div>\n- : unit = ()\n```\nHere is a simple `range` function that produces a sequence of integers:\n\n```ocaml\n# let range ?(start=0) ?(stop=0) ?(step=1) () =\n  let in_range = if step < 0 then (>) else (<) in\n  let current = ref start in\n  let rec next i =\n    if in_range !current stop\n    then let result = !current in (current := !current + step;\n                                   Some result)\n    else None in\n  Stream.from next\nval range : ?start:int -> ?stop:int -> ?step:int -> unit -> int Stream.t =\n  <fun>\n```\n\nThis works just like Python's `xrange` built-in function, providing an\neasy way to produce an assortment of lazy integer sequences by\nspecifying combinations of `start`, `stop`, or `step` values:\n\n```ocaml\n# Stream.npeek 10 (range ~start:5 ~stop:10 ())\n- : int list = [5; 6; 7; 8; 9]\n# Stream.npeek 10 (range ~stop:10 ~step:2 ())\n- : int list = [0; 2; 4; 6; 8]\n# Stream.npeek 10 (range ~start:10 ~step:(-1) ())\n- : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]\n# Stream.npeek 10 (range ~start:10 ~stop:5 ~step:(-1) ())\n- : int list = [10; 9; 8; 7; 6]\n```\n\n## Combining streams\nThere are several ways to combine streams. One is to produce a stream of\nstreams and then concatenate them into a single stream. The following\nfunction works just like `List.concat`, but instead of turning a list of\nlists into a list, it turns a stream of streams into a stream:\n\n```ocaml\n# let stream_concat streams =\n  let current_stream = ref None in\n  let rec next i =\n    try\n      let stream =\n        match !current_stream with\n        | Some stream -> stream\n        | None ->\n           let stream = Stream.next streams in\n           current_stream := Some stream;\n           stream in\n      try Some (Stream.next stream)\n      with Stream.Failure -> (current_stream := None; next i)\n    with Stream.Failure -> None in\n  Stream.from next\nval stream_concat : 'a Stream.t Stream.t -> 'a Stream.t = <fun>\n```\nHere is a sequence of ranges which are themselves derived from a range,\nconcatenated with `stream_concat` to produce a flattened `int Stream.t`.\n\n```ocaml\n# Stream.npeek 10\n  (stream_concat\n     (stream_map\n        (fun i -> range ~stop:i ())\n        (range ~stop:5 ())))\n- : int list = [0; 0; 1; 0; 1; 2; 0; 1; 2; 3]\n```\n\nAnother way to combine streams is to iterate through them in a pairwise\nfashion:\n\n```ocaml\n# let stream_combine stream1 stream2 =\n  let rec next i =\n    try Some (Stream.next stream1, Stream.next stream2)\n    with Stream.Failure -> None in\n  Stream.from next\nval stream_combine : 'a Stream.t -> 'b Stream.t -> ('a * 'b) Stream.t = <fun>\n```\nThis is useful, for instance, if you have a stream of keys and a stream\nof corresponding values. Iterating through key value pairs is then as\nsimple as:\n\n```ocaml\nStream.iter\n  (fun (key, value) ->\n     (* do something with 'key' and 'value' *)\n     ())\n  (stream_combine key_stream value_stream)\n```\n```mdx-error\nLine 5, characters 21-31:\nError: Unbound value key_stream\n```\nSince `stream_combine` stops as soon as either of its input streams runs\nout, it can be used to combine an infinite stream with a finite one.\nThis provides a neat way to add indexes to a sequence:\n\n```ocaml\n# let items = [\"this\"; \"is\"; \"a\"; \"test\"]\nval items : string list = [\"this\"; \"is\"; \"a\"; \"test\"]\n# Stream.iter\n  (fun (index, value) ->\n     Printf.printf \"%d. %s\\n%!\" index value)\n  (stream_combine (count_stream 1) (Stream.of_list items))\n1. this\n2. is\n3. a\n4. test\n- : unit = ()\n```\n\n## Copying streams\nStreams are destructive; once you discard an item in a stream, it is no\nlonger available unless you save a copy somewhere. What if you want to\nuse the same stream more than once? One way is to create a \"tee\". The\nfollowing function creates two output streams from one input stream,\nintelligently queueing unseen values until they have been produced by\nboth streams:\n\n```ocaml\n# let stream_tee stream =\n  let next self other i =\n    try\n      if Queue.is_empty self\n      then\n        let value = Stream.next stream in\n        Queue.add value other;\n        Some value\n      else\n        Some (Queue.take self)\n    with Stream.Failure -> None in\n  let q1 = Queue.create () in\n  let q2 = Queue.create () in\n  (Stream.from (next q1 q2), Stream.from (next q2 q1))\nval stream_tee : 'a Stream.t -> 'a Stream.t * 'a Stream.t = <fun>\n```\nHere is an example of a stream tee in action:\n\n```ocaml\n# let letters = Stream.of_list ['a'; 'b'; 'c'; 'd'; 'e']\nval letters : char Stream.t = <abstr>\n# let s1, s2 = stream_tee letters\nval s1 : char Stream.t = <abstr>\nval s2 : char Stream.t = <abstr>\n# Stream.next s1\n- : char = 'a'\n# Stream.next s1\n- : char = 'b'\n# Stream.next s2\n- : char = 'a'\n# Stream.next s1\n- : char = 'c'\n# Stream.next s2\n- : char = 'b'\n# Stream.next s2\n- : char = 'c'\n```\n\nAgain, since streams are destructive, you probably want to leave the\noriginal stream alone or you will lose items from the copied streams:\n\n```ocaml\n# Stream.next letters\n- : char = 'd'\n# Stream.next s1\n- : char = 'e'\n# Stream.next s2\n- : char = 'e'\n```\n\n## Converting streams\nHere are a few functions for converting between streams and lists,\narrays, and hash tables. These probably belong in the standard library,\nbut they are simple to define anyhow. Again, beware of infinite streams,\nwhich will cause these functions to hang.\n\n```ocaml\n# let stream_of_list = Stream.of_list\nval stream_of_list : 'a list -> 'a Stream.t = <fun>\n# let list_of_stream stream =\n  let result = ref [] in\n  Stream.iter (fun value -> result := value :: !result) stream;\n  List.rev !result\nval list_of_stream : 'a Stream.t -> 'a list = <fun>\n# let stream_of_array array =\n  Stream.of_list (Array.to_list array)\nval stream_of_array : 'a array -> 'a Stream.t = <fun>\n# let array_of_stream stream =\n  Array.of_list (list_of_stream stream)\nval array_of_stream : 'a Stream.t -> 'a array = <fun>\n# let stream_of_hash hash =\n  let result = ref [] in\n  Hashtbl.iter\n    (fun key value -> result := (key, value) :: !result)\n    hash;\n  Stream.of_list !result\nval stream_of_hash : ('a, 'b) Hashtbl.t -> ('a * 'b) Stream.t = <fun>\n# let hash_of_stream stream =\n  let result = Hashtbl.create 0 in\n  Stream.iter\n    (fun (key, value) -> Hashtbl.replace result key value)\n    stream;\n  result\nval hash_of_stream : ('a * 'b) Stream.t -> ('a, 'b) Hashtbl.t = <fun>\n```\n\nWhat if you want to convert arbitrary data types to streams? Well, if the\ndata type defines an `iter` function, and you don't mind using threads,\nyou can use a producer-consumer arrangement to invert control:\n\n```ocaml\n# #directory \"+threads\";;\n# #load \"threads.cma\";;\n# let elements iter coll =\n  let channel = Event.new_channel () in\n  let producer () =\n    let () =\n      iter (fun x -> Event.sync (Event.send channel (Some x))) coll in\n    Event.sync (Event.send channel None) in\n  let consumer i =\n    Event.sync (Event.receive channel) in\n  ignore (Thread.create producer ());\n  Stream.from consumer\nval elements : (('a -> unit) -> 'b -> unit) -> 'b -> 'a Stream.t = <fun>\n```\n\nNow it is possible to build a stream from an `iter` function and a\ncorresponding value:\n\n```ocaml\n# module StringSet = Set.Make(String)\nmodule StringSet :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -> bool\n    val mem : elt -> t -> bool\n    val add : elt -> t -> t\n    val singleton : elt -> t\n    val remove : elt -> t -> t\n    val union : t -> t -> t\n    val inter : t -> t -> t\n    val disjoint : t -> t -> bool\n    val diff : t -> t -> t\n    val compare : t -> t -> int\n    val equal : t -> t -> bool\n    val subset : t -> t -> bool\n    val iter : (elt -> unit) -> t -> unit\n    val map : (elt -> elt) -> t -> t\n    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a\n    val for_all : (elt -> bool) -> t -> bool\n    val exists : (elt -> bool) -> t -> bool\n    val filter : (elt -> bool) -> t -> t\n    val partition : (elt -> bool) -> t -> t * t\n    val cardinal : t -> int\n    val elements : t -> elt list\n    val min_elt : t -> elt\n    val min_elt_opt : t -> elt option\n    val max_elt : t -> elt\n    val max_elt_opt : t -> elt option\n    val choose : t -> elt\n    val choose_opt : t -> elt option\n    val split : elt -> t -> t * bool * t\n    val find : elt -> t -> elt\n    val find_opt : elt -> t -> elt option\n    val find_first : (elt -> bool) -> t -> elt\n    val find_first_opt : (elt -> bool) -> t -> elt option\n    val find_last : (elt -> bool) -> t -> elt\n    val find_last_opt : (elt -> bool) -> t -> elt option\n    val of_list : elt list -> t\n    val to_seq_from : elt -> t -> elt Seq.t\n    val to_seq : t -> elt Seq.t\n    val add_seq : elt Seq.t -> t -> t\n    val of_seq : elt Seq.t -> t\n  end\n# let set = StringSet.empty\nval set : StringSet.t = <abstr>\n# let set = StringSet.add \"here\" set\nval set : StringSet.t = <abstr>\n# let set = StringSet.add \"are\" set\nval set : StringSet.t = <abstr>\n# let set = StringSet.add \"some\" set\nval set : StringSet.t = <abstr>\n# let set = StringSet.add \"values\" set\nval set : StringSet.t = <abstr>\n# let stream = elements StringSet.iter set\nval stream : string Stream.t = <abstr>\n# Stream.iter print_endline stream\nare\nhere\nsome\nvalues\n- : unit = ()\n```\n\nSome data types, like Hashtbl and Map, provide an `iter` function that\niterates through key-value pairs. Here's a function for those, too:\n\n```ocaml\n# let items iter coll =\n  let channel = Event.new_channel () in\n  let producer () =\n    let () =\n      iter (fun k v ->\n              Event.sync (Event.send channel (Some (k, v)))) coll in\n    Event.sync (Event.send channel None) in\n  let consumer i =\n    Event.sync (Event.receive channel) in\n  ignore (Thread.create producer ());\n  Stream.from consumer\nval items : (('a -> 'b -> unit) -> 'c -> unit) -> 'c -> ('a * 'b) Stream.t =\n  <fun>\n```\n\nIf we want just the keys, or just the values, it is simple to transform\nthe output of `items` using `stream_map`:\n\n```ocaml\n# let keys iter coll = stream_map (fun (k, v) -> k) (items iter coll)\nval keys : (('a -> 'b -> unit) -> 'c -> unit) -> 'c -> 'a Stream.t = <fun>\n# let values iter coll = stream_map (fun (k, v) -> v) (items iter coll)\nval values : (('a -> 'b -> unit) -> 'c -> unit) -> 'c -> 'b Stream.t = <fun>\n```\n\nKeep in mind that these techniques spawn producer threads which carry a\nfew risks: they only terminate when they have finished iterating, and\nany change to the original data structure while iterating may produce\nunexpected results.\n\n## Other built-in Stream functions\nThere are a few other documented methods in the `Stream` module:\n\n* Stream.empty, which raises `Stream.Failure` unless a stream is empty\n* Stream.count, which returns the stream count (number of discarded\n elements)\n\nIn addition, there are a few undocumented functions: `iapp`, `icons`,\n`ising`, `lapp`, `lcons`, `lsing`, `sempty`, `slazy`, and `dump`. They\nare visible in the interface with the caveat: \"For system use only, not\nfor the casual user\".\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#constructing-streams">Constructing streams</a>\n</li>\n<li><a href="#deconstructing-streams">Deconstructing streams</a>\n</li>\n<li><a href="#a-more-complex-streamfrom-example">A more complex <code>Stream.from</code> example</a>\n</li>\n<li><a href="#stream-combinators">Stream combinators</a>\n</li>\n<li><a href="#other-useful-stream-builders">Other useful stream builders</a>\n</li>\n<li><a href="#combining-streams">Combining streams</a>\n</li>\n<li><a href="#copying-streams">Copying streams</a>\n</li>\n<li><a href="#converting-streams">Converting streams</a>\n</li>\n<li><a href="#other-built-in-stream-functions">Other built-in Stream functions</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:"<p>Suppose you need to process each line of a text file. One way to do this\nis to read the file in as a single large string and use something like\n<code>Str.split</code> to turn it into a list. This works when the file is small,\nbut because the entire file is loaded into memory, it does not scale\nwell when the file is large.</p>\n<p>More commonly, the <code>input_line</code> function can be used to read one line at\na time from a channel. This typically looks like:</p>\n<pre><code class=\"language-ocaml\">let in_channel = open_in &quot;lines.txt&quot; in\ntry\n  while true do\n    let line = input_line in_channel in\n    (* do something with line *)\n  done\nwith End_of_file -&gt;\n  close_in in_channel\n</code></pre>\n<pre><code class=\"language-mdx-error\">Line 6, characters 5-9:\nError: Syntax error\n</code></pre>\n<p>The above code is efficient with memory, but it can be inconvenient in\nother ways. Since <code>input_line</code> only works with the <code>in_channel</code> type, it\ncannot be reused in cases where the text is already in memory. The\n<code>End_of_file</code> exception can be raised at any point during iteration, and\nit is the programmer's responsibility to ensure that the file is closed\nappropriately. In fact, if there is any other exception in the above\nexample, the file will not be closed at all. Altogether, there is a lot\ngoing on: channels, I/O, exceptions, and files.</p>\n<p>Streams offer an abstraction over one part of this process: reading\nitems from a sequence. They don't assume anything about files or\nchannels, and they replace the <code>End_of_file</code> exception with a more\nstructured approach to dealing with the end of input. Here is a function\nthat builds a stream of lines from an input channel:</p>\n<pre><code class=\"language-ocaml\"># let line_stream_of_channel channel =\n  Stream.from\n    (fun _ -&gt;\n       try Some (input_line channel) with End_of_file -&gt; None)\nval line_stream_of_channel : in_channel -&gt; string Stream.t = &lt;fun&gt;\n</code></pre>\n<p>The &quot;Stream.from&quot; function builds a stream from a callback function.\nThis function is passed the current stream count (starting with 0) as an\nargument and is expected to return an <code>'a option</code>. If the option has a\nvalue (<code>Some x</code>), that value will be the next item in the stream. If it\nhas no value (<code>None</code>), this indicates that the stream is empty and no\nfurther reads will be attempted. Since the option is polymorphic,\n<code>Stream.from</code> can construct streams of any type. These streams have a\ntype of <code>'a Stream.t</code>.</p>\n<p>With this simple function, we can now easily construct line streams from\nany input channel:</p>\n<pre><code class=\"language-ocaml\"># let in_channel = open_in &quot;019_streams.md&quot;\nval in_channel : in_channel = &lt;abstr&gt;\n# let lines = line_stream_of_channel in_channel\nval lines : string Stream.t = &lt;abstr&gt;\n</code></pre>\n<p>This variable <code>lines</code> is a stream of strings, one string per line. We\ncan now begin reading lines from it by passing it to <code>Stream.next</code>:</p>\n<pre><code class=\"language-ocaml\"># Stream.next lines\n- : string = &quot;---&quot;\n# Stream.next lines\n- : string = &quot;title: Streams&quot;\n# Stream.next lines\n- : string = &quot;description: &gt;&quot;\n# Stream.next lines\n- : string =\n&quot;  Streams offer an abstraction over consuming items from sequences&quot;\n# while true do ignore(Stream.next lines) done\nException: Stdlib.Stream.Failure.\n</code></pre>\n<p>As you can see, <code>Stream.next</code> either returns the next item in the stream\nor raises a <code>Stream.Failure</code> exception indicating that the stream is\nempty. Likewise, with a little help from the <code>Stream.of_list</code>\nconstructor and the <code>Str</code> regular expression module, we could build a\nstream of lines from a string in memory:</p>\n<pre><code class=\"language-ocaml\"># #load &quot;str.cma&quot;\n# let line_stream_of_string string =\n  Stream.of_list (Str.split (Str.regexp &quot;\\n&quot;) string)\nval line_stream_of_string : string -&gt; string Stream.t = &lt;fun&gt;\n</code></pre>\n<p>and these streams could be used exactly the same way:</p>\n<pre><code class=\"language-ocaml\"># let lines = line_stream_of_string &quot;hello\\nstream\\nworld&quot;\nval lines : string Stream.t = &lt;abstr&gt;\n# Stream.next lines\n- : string = &quot;hello&quot;\n# Stream.next lines\n- : string = &quot;stream&quot;\n# Stream.next lines\n- : string = &quot;world&quot;\n# Stream.next lines\nException: Stdlib.Stream.Failure.\n</code></pre>\n<p>Since both cases raise <code>Stream.Failure</code> on an empty stream, there is no\nneed to worry about catching <code>End_of_file</code> in the case of file I/O. This\nunified interface makes it much easier to write functions that can\nreceive data from multiple sources.</p>\n<p>The <code>Stream.iter</code> function automates the common task of performing an\noperation for each item. With it, we can rewrite the original example as\nfollows:</p>\n<pre><code class=\"language-ocaml\">let in_channel = open_in &quot;019_streams.md&quot; in\ntry\n  Stream.iter\n    (fun line -&gt;\n       (* do something with line *)\n       print_endline line)\n    (line_stream_of_channel in_channel);\n  close_in in_channel\nwith e -&gt;\n  close_in in_channel;\n  raise e\n</code></pre>\n<p>Note how much easier it is to handle I/O exceptions properly, since we\ncan deal with them independently from the end-of-file condition. This\nseparation of concerns allows us to decompose this into simpler and more\nreusable functions:</p>\n<pre><code class=\"language-ocaml\"># let process_line line =\n  print_endline line\nval process_line : string -&gt; unit = &lt;fun&gt;\n\n# let process_lines lines =\n  Stream.iter process_line lines\nval process_lines : string Stream.t -&gt; unit = &lt;fun&gt;\n\n# let process_file filename =\n  let in_channel = open_in filename in\n  try\n    process_lines (line_stream_of_channel in_channel);\n    close_in in_channel\n  with e -&gt;\n    close_in in_channel;\n    raise e\nval process_file : string -&gt; unit = &lt;fun&gt;\n\n# let process_string string =\n  process_lines (line_stream_of_string string)\nval process_string : string -&gt; unit = &lt;fun&gt;\n</code></pre>\n<h2 id=\"constructing-streams\">Constructing streams</h2>\n<p>In the above examples, we saw two methods for constructing streams:</p>\n<ul>\n<li>Stream.from, which builds a stream from a callback function\n</li>\n<li>Stream.of_list, which builds a stream from a list in memory\n</li>\n</ul>\n<p>The <code>Stream</code> module provides a few other stream builders:</p>\n<ul>\n<li>Stream.of_string, which builds a character stream from a string\n</li>\n<li>Stream.of_channel, which builds a character stream from a channel\n</li>\n</ul>\n<p><code>Stream.from</code> is the most general, and it can be used to produce streams\nof any type. It is not limited to I/O and can even produce infinite\nsequences. Here are a few simple stream builders defined with\n<code>Stream.from</code>:</p>\n<pre><code class=\"language-ocaml\"># let empty_stream () = Stream.from (fun _ -&gt; None)\nval empty_stream : unit -&gt; 'a Stream.t = &lt;fun&gt;\n# let const_stream k = Stream.from (fun _ -&gt; Some k)\nval const_stream : 'a -&gt; 'a Stream.t = &lt;fun&gt;\n# let count_stream i = Stream.from (fun j -&gt; Some (i + j))\nval count_stream : int -&gt; int Stream.t = &lt;fun&gt;\n</code></pre>\n<h2 id=\"deconstructing-streams\">Deconstructing streams</h2>\n<p>We already saw the <code>Stream.next</code> function, which retrieves a single item\nfrom a stream. There is another way to work with streams that is often\npreferable: <code>Stream.peek</code> and <code>Stream.junk</code>. When used together, these\nfunctions allow you to see what the next item would be. This feature,\nknown as &quot;look ahead&quot;, is very useful when writing parsers. Even if you\ndon't need to look ahead, the peek/junk protocol may be nicer to work\nwith because it uses options instead of exceptions:</p>\n<pre><code class=\"language-ocaml\"># let lines = line_stream_of_string &quot;hello\\nworld&quot;\nval lines : string Stream.t = &lt;abstr&gt;\n# Stream.peek lines\n- : string option = Some &quot;hello&quot;\n# Stream.peek lines\n- : string option = Some &quot;hello&quot;\n# Stream.junk lines\n- : unit = ()\n# Stream.peek lines\n- : string option = Some &quot;world&quot;\n# Stream.junk lines\n- : unit = ()\n# Stream.peek lines\n- : string option = None\n</code></pre>\n<p>As you can see, it is necessary to call <code>Stream.junk</code> to advance to the\nnext item. <code>Stream.peek</code> will always give you either the next item or\n<code>None</code>, and it will never fail. Likewise, <code>Stream.junk</code> always succeeds\n(even if the stream is empty).</p>\n<h2 id=\"a-more-complex-streamfrom-example\">A more complex <code>Stream.from</code> example</h2>\n<p>Here is a function that converts a line stream into a paragraph stream.\nAs such, it is both a stream consumer and a stream producer.</p>\n<pre><code class=\"language-ocaml\"># let paragraphs lines =\n  let rec next para_lines i =\n    match Stream.peek lines, para_lines with\n    | None, [] -&gt; None\n    | Some &quot;&quot;, [] -&gt;\n        Stream.junk lines;\n        next para_lines i\n    | Some &quot;&quot;, _ | None, _ -&gt;\n        Some (String.concat &quot;\\n&quot; (List.rev para_lines))\n    | Some line, _ -&gt;\n        Stream.junk lines;\n        next (line :: para_lines) i in\n  Stream.from (next [])\nval paragraphs : string Stream.t -&gt; string Stream.t = &lt;fun&gt;\n</code></pre>\n<p>This function uses an extra parameter to <code>next</code> (the <code>Stream.from</code>\ncallback) called <code>para_lines</code> in order to collect the lines for each\nparagraph. Paragraphs are delimited by any number of blank lines.</p>\n<p>Each time <code>next</code> is called, a <code>match</code> expression tests two values: the\nnext line in the stream, and the contents of <code>para_lines</code>. Four cases\nare handled:</p>\n<ol>\n<li>If the end of the stream is reached and no lines have been\ncollected, the paragraph stream ends as well.\n</li>\n<li>If the next line is blank and no lines have been collected, the\nblank is ignored and <code>next</code> is called recursively to keep looking\nfor a non-blank line.\n</li>\n<li>If a blank line or end of stream is reached and lines <strong>have</strong> been\ncollected, the paragraph is returned by concatenating <code>para_lines</code>\nto a single string.\n</li>\n<li>Finally, if a non-blank line has been reached, the line is collected\nby recursively calling <code>para_lines</code>.\n</li>\n</ol>\n<p>Happily, we can rely on the OCaml compiler's exhaustiveness checking to\nensure that we are handling all possible cases.</p>\n<p>With this new tool, we can now work just as easily with paragraphs as we\ncould before with lines:</p>\n<pre><code class=\"language-ocaml\">(* Print each paragraph, followed by a separator. *)\nlet lines = line_stream_of_channel in_channel in\nStream.iter\n  (fun para -&gt;\n     print_endline para;\n     print_endline &quot;--&quot;)\n  (paragraphs lines)\n</code></pre>\n<p>Functions like <code>paragraphs</code> that produce and consume streams can be\ncomposed together in a manner very similar to UNIX pipes and filters.</p>\n<h2 id=\"stream-combinators\">Stream combinators</h2>\n<p>Just like lists and arrays, common iteration patterns such as <code>map</code>,\n<code>filter</code>, and <code>fold</code> can be very useful. The <code>Stream</code> module does not\nprovide such functions, but they can be built easily using\n<code>Stream.from</code>:</p>\n<pre><code class=\"language-ocaml\"># let stream_map f stream =\n  let rec next i =\n    try Some (f (Stream.next stream))\n    with Stream.Failure -&gt; None in\n  Stream.from next\nval stream_map : ('a -&gt; 'b) -&gt; 'a Stream.t -&gt; 'b Stream.t = &lt;fun&gt;\n\n# let stream_filter p stream =\n  let rec next i =\n    try\n      let value = Stream.next stream in\n      if p value then Some value else next i\n    with Stream.Failure -&gt; None in\n  Stream.from next\nval stream_filter : ('a -&gt; bool) -&gt; 'a Stream.t -&gt; 'a Stream.t = &lt;fun&gt;\n\n# let stream_fold f stream init =\n  let result = ref init in\n  Stream.iter\n    (fun x -&gt; result := f x !result)\n    stream;\n  !result\nval stream_fold : ('a -&gt; 'b -&gt; 'b) -&gt; 'a Stream.t -&gt; 'b -&gt; 'b = &lt;fun&gt;\n</code></pre>\n<p>For example, here is a stream of leap years starting with 2000:</p>\n<pre><code class=\"language-ocaml\"># let is_leap year =\n  year mod 4 = 0 &amp;&amp; (year mod 100 &lt;&gt; 0 || year mod 400 = 0)\nval is_leap : int -&gt; bool = &lt;fun&gt;\n# let leap_years = stream_filter is_leap (count_stream 2000)\nval leap_years : int Stream.t = &lt;abstr&gt;\n</code></pre>\n<p>We can use the <code>Stream.npeek</code> function to look ahead by more than one\nitem. In this case, we'll peek at the next 30 items to make sure that\nthe year 2100 is not a leap year (since it's divisible by 100 but not\n400!):</p>\n<pre><code class=\"language-ocaml\"># Stream.npeek 30 leap_years\n- : int list =\n[2000; 2004; 2008; 2012; 2016; 2020; 2024; 2028; 2032; 2036; 2040; 2044;\n 2048; 2052; 2056; 2060; 2064; 2068; 2072; 2076; 2080; 2084; 2088; 2092;\n 2096; 2104; 2108; 2112; 2116; 2120]\n</code></pre>\n<p>Note that we must be careful not to use <code>Stream.iter</code> on an infinite\nstream like <code>leap_years</code>. This applies to <code>stream_fold</code>, as well as any\nfunction that attempts to consume the entire stream.</p>\n<pre><code class=\"language-ocaml\"># stream_fold (+) (Stream.of_list [1; 2; 3]) 0\n- : int = 6\n</code></pre>\n<p><code>stream_fold (+) (count_stream 0) 0</code> runs forever.</p>\n<h2 id=\"other-useful-stream-builders\">Other useful stream builders</h2>\n<p>The previously defined <code>const_stream</code> function builds a stream that\nrepeats a single value. It is also useful to build a stream that repeats\na sequence of values. The following function does just that:</p>\n<pre><code class=\"language-ocaml\"># let cycle items =\n  let buf = ref [] in\n  let rec next i =\n    if !buf = [] then buf := items;\n    match !buf with\n      | h :: t -&gt; (buf := t; Some h)\n      | [] -&gt; None in\n  Stream.from next\nval cycle : 'a list -&gt; 'a Stream.t = &lt;fun&gt;\n</code></pre>\n<p>One common task that can benefit from this kind of stream is the\ngeneration of alternating background colors for HTML. By using <code>cycle</code>\nwith <code>stream_combine</code>, explained in the next section, an infinite stream\nof background colors can be combined with a finite stream of data to\nproduce a sequence of HTML blocks:</p>\n<pre><code class=\"language-ocaml\"># let stream_combine stream1 stream2 =\n  let rec next i =\n    try Some (Stream.next stream1, Stream.next stream2)\n    with Stream.Failure -&gt; None in\n  Stream.from next\nval stream_combine : 'a Stream.t -&gt; 'b Stream.t -&gt; ('a * 'b) Stream.t = &lt;fun&gt;\n# Stream.iter print_endline\n  (stream_map\n     (fun (bg, s) -&gt;\n        Printf.sprintf &quot;&lt;div style='background: %s'&gt;%s&lt;/div&gt;&quot; bg s)\n     (stream_combine\n        (cycle [&quot;#eee&quot;; &quot;#fff&quot;])\n        (Stream.of_list [&quot;hello&quot;; &quot;html&quot;; &quot;world&quot;])))\n&lt;div style='background: #eee'&gt;hello&lt;/div&gt;\n&lt;div style='background: #fff'&gt;html&lt;/div&gt;\n&lt;div style='background: #eee'&gt;world&lt;/div&gt;\n- : unit = ()\n</code></pre>\n<p>Here is a simple <code>range</code> function that produces a sequence of integers:</p>\n<pre><code class=\"language-ocaml\"># let range ?(start=0) ?(stop=0) ?(step=1) () =\n  let in_range = if step &lt; 0 then (&gt;) else (&lt;) in\n  let current = ref start in\n  let rec next i =\n    if in_range !current stop\n    then let result = !current in (current := !current + step;\n                                   Some result)\n    else None in\n  Stream.from next\nval range : ?start:int -&gt; ?stop:int -&gt; ?step:int -&gt; unit -&gt; int Stream.t =\n  &lt;fun&gt;\n</code></pre>\n<p>This works just like Python's <code>xrange</code> built-in function, providing an\neasy way to produce an assortment of lazy integer sequences by\nspecifying combinations of <code>start</code>, <code>stop</code>, or <code>step</code> values:</p>\n<pre><code class=\"language-ocaml\"># Stream.npeek 10 (range ~start:5 ~stop:10 ())\n- : int list = [5; 6; 7; 8; 9]\n# Stream.npeek 10 (range ~stop:10 ~step:2 ())\n- : int list = [0; 2; 4; 6; 8]\n# Stream.npeek 10 (range ~start:10 ~step:(-1) ())\n- : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]\n# Stream.npeek 10 (range ~start:10 ~stop:5 ~step:(-1) ())\n- : int list = [10; 9; 8; 7; 6]\n</code></pre>\n<h2 id=\"combining-streams\">Combining streams</h2>\n<p>There are several ways to combine streams. One is to produce a stream of\nstreams and then concatenate them into a single stream. The following\nfunction works just like <code>List.concat</code>, but instead of turning a list of\nlists into a list, it turns a stream of streams into a stream:</p>\n<pre><code class=\"language-ocaml\"># let stream_concat streams =\n  let current_stream = ref None in\n  let rec next i =\n    try\n      let stream =\n        match !current_stream with\n        | Some stream -&gt; stream\n        | None -&gt;\n           let stream = Stream.next streams in\n           current_stream := Some stream;\n           stream in\n      try Some (Stream.next stream)\n      with Stream.Failure -&gt; (current_stream := None; next i)\n    with Stream.Failure -&gt; None in\n  Stream.from next\nval stream_concat : 'a Stream.t Stream.t -&gt; 'a Stream.t = &lt;fun&gt;\n</code></pre>\n<p>Here is a sequence of ranges which are themselves derived from a range,\nconcatenated with <code>stream_concat</code> to produce a flattened <code>int Stream.t</code>.</p>\n<pre><code class=\"language-ocaml\"># Stream.npeek 10\n  (stream_concat\n     (stream_map\n        (fun i -&gt; range ~stop:i ())\n        (range ~stop:5 ())))\n- : int list = [0; 0; 1; 0; 1; 2; 0; 1; 2; 3]\n</code></pre>\n<p>Another way to combine streams is to iterate through them in a pairwise\nfashion:</p>\n<pre><code class=\"language-ocaml\"># let stream_combine stream1 stream2 =\n  let rec next i =\n    try Some (Stream.next stream1, Stream.next stream2)\n    with Stream.Failure -&gt; None in\n  Stream.from next\nval stream_combine : 'a Stream.t -&gt; 'b Stream.t -&gt; ('a * 'b) Stream.t = &lt;fun&gt;\n</code></pre>\n<p>This is useful, for instance, if you have a stream of keys and a stream\nof corresponding values. Iterating through key value pairs is then as\nsimple as:</p>\n<pre><code class=\"language-ocaml\">Stream.iter\n  (fun (key, value) -&gt;\n     (* do something with 'key' and 'value' *)\n     ())\n  (stream_combine key_stream value_stream)\n</code></pre>\n<pre><code class=\"language-mdx-error\">Line 5, characters 21-31:\nError: Unbound value key_stream\n</code></pre>\n<p>Since <code>stream_combine</code> stops as soon as either of its input streams runs\nout, it can be used to combine an infinite stream with a finite one.\nThis provides a neat way to add indexes to a sequence:</p>\n<pre><code class=\"language-ocaml\"># let items = [&quot;this&quot;; &quot;is&quot;; &quot;a&quot;; &quot;test&quot;]\nval items : string list = [&quot;this&quot;; &quot;is&quot;; &quot;a&quot;; &quot;test&quot;]\n# Stream.iter\n  (fun (index, value) -&gt;\n     Printf.printf &quot;%d. %s\\n%!&quot; index value)\n  (stream_combine (count_stream 1) (Stream.of_list items))\n1. this\n2. is\n3. a\n4. test\n- : unit = ()\n</code></pre>\n<h2 id=\"copying-streams\">Copying streams</h2>\n<p>Streams are destructive; once you discard an item in a stream, it is no\nlonger available unless you save a copy somewhere. What if you want to\nuse the same stream more than once? One way is to create a &quot;tee&quot;. The\nfollowing function creates two output streams from one input stream,\nintelligently queueing unseen values until they have been produced by\nboth streams:</p>\n<pre><code class=\"language-ocaml\"># let stream_tee stream =\n  let next self other i =\n    try\n      if Queue.is_empty self\n      then\n        let value = Stream.next stream in\n        Queue.add value other;\n        Some value\n      else\n        Some (Queue.take self)\n    with Stream.Failure -&gt; None in\n  let q1 = Queue.create () in\n  let q2 = Queue.create () in\n  (Stream.from (next q1 q2), Stream.from (next q2 q1))\nval stream_tee : 'a Stream.t -&gt; 'a Stream.t * 'a Stream.t = &lt;fun&gt;\n</code></pre>\n<p>Here is an example of a stream tee in action:</p>\n<pre><code class=\"language-ocaml\"># let letters = Stream.of_list ['a'; 'b'; 'c'; 'd'; 'e']\nval letters : char Stream.t = &lt;abstr&gt;\n# let s1, s2 = stream_tee letters\nval s1 : char Stream.t = &lt;abstr&gt;\nval s2 : char Stream.t = &lt;abstr&gt;\n# Stream.next s1\n- : char = 'a'\n# Stream.next s1\n- : char = 'b'\n# Stream.next s2\n- : char = 'a'\n# Stream.next s1\n- : char = 'c'\n# Stream.next s2\n- : char = 'b'\n# Stream.next s2\n- : char = 'c'\n</code></pre>\n<p>Again, since streams are destructive, you probably want to leave the\noriginal stream alone or you will lose items from the copied streams:</p>\n<pre><code class=\"language-ocaml\"># Stream.next letters\n- : char = 'd'\n# Stream.next s1\n- : char = 'e'\n# Stream.next s2\n- : char = 'e'\n</code></pre>\n<h2 id=\"converting-streams\">Converting streams</h2>\n<p>Here are a few functions for converting between streams and lists,\narrays, and hash tables. These probably belong in the standard library,\nbut they are simple to define anyhow. Again, beware of infinite streams,\nwhich will cause these functions to hang.</p>\n<pre><code class=\"language-ocaml\"># let stream_of_list = Stream.of_list\nval stream_of_list : 'a list -&gt; 'a Stream.t = &lt;fun&gt;\n# let list_of_stream stream =\n  let result = ref [] in\n  Stream.iter (fun value -&gt; result := value :: !result) stream;\n  List.rev !result\nval list_of_stream : 'a Stream.t -&gt; 'a list = &lt;fun&gt;\n# let stream_of_array array =\n  Stream.of_list (Array.to_list array)\nval stream_of_array : 'a array -&gt; 'a Stream.t = &lt;fun&gt;\n# let array_of_stream stream =\n  Array.of_list (list_of_stream stream)\nval array_of_stream : 'a Stream.t -&gt; 'a array = &lt;fun&gt;\n# let stream_of_hash hash =\n  let result = ref [] in\n  Hashtbl.iter\n    (fun key value -&gt; result := (key, value) :: !result)\n    hash;\n  Stream.of_list !result\nval stream_of_hash : ('a, 'b) Hashtbl.t -&gt; ('a * 'b) Stream.t = &lt;fun&gt;\n# let hash_of_stream stream =\n  let result = Hashtbl.create 0 in\n  Stream.iter\n    (fun (key, value) -&gt; Hashtbl.replace result key value)\n    stream;\n  result\nval hash_of_stream : ('a * 'b) Stream.t -&gt; ('a, 'b) Hashtbl.t = &lt;fun&gt;\n</code></pre>\n<p>What if you want to convert arbitrary data types to streams? Well, if the\ndata type defines an <code>iter</code> function, and you don't mind using threads,\nyou can use a producer-consumer arrangement to invert control:</p>\n<pre><code class=\"language-ocaml\"># #directory &quot;+threads&quot;;;\n# #load &quot;threads.cma&quot;;;\n# let elements iter coll =\n  let channel = Event.new_channel () in\n  let producer () =\n    let () =\n      iter (fun x -&gt; Event.sync (Event.send channel (Some x))) coll in\n    Event.sync (Event.send channel None) in\n  let consumer i =\n    Event.sync (Event.receive channel) in\n  ignore (Thread.create producer ());\n  Stream.from consumer\nval elements : (('a -&gt; unit) -&gt; 'b -&gt; unit) -&gt; 'b -&gt; 'a Stream.t = &lt;fun&gt;\n</code></pre>\n<p>Now it is possible to build a stream from an <code>iter</code> function and a\ncorresponding value:</p>\n<pre><code class=\"language-ocaml\"># module StringSet = Set.Make(String)\nmodule StringSet :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -&gt; bool\n    val mem : elt -&gt; t -&gt; bool\n    val add : elt -&gt; t -&gt; t\n    val singleton : elt -&gt; t\n    val remove : elt -&gt; t -&gt; t\n    val union : t -&gt; t -&gt; t\n    val inter : t -&gt; t -&gt; t\n    val disjoint : t -&gt; t -&gt; bool\n    val diff : t -&gt; t -&gt; t\n    val compare : t -&gt; t -&gt; int\n    val equal : t -&gt; t -&gt; bool\n    val subset : t -&gt; t -&gt; bool\n    val iter : (elt -&gt; unit) -&gt; t -&gt; unit\n    val map : (elt -&gt; elt) -&gt; t -&gt; t\n    val fold : (elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a\n    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool\n    val exists : (elt -&gt; bool) -&gt; t -&gt; bool\n    val filter : (elt -&gt; bool) -&gt; t -&gt; t\n    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t\n    val cardinal : t -&gt; int\n    val elements : t -&gt; elt list\n    val min_elt : t -&gt; elt\n    val min_elt_opt : t -&gt; elt option\n    val max_elt : t -&gt; elt\n    val max_elt_opt : t -&gt; elt option\n    val choose : t -&gt; elt\n    val choose_opt : t -&gt; elt option\n    val split : elt -&gt; t -&gt; t * bool * t\n    val find : elt -&gt; t -&gt; elt\n    val find_opt : elt -&gt; t -&gt; elt option\n    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt\n    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option\n    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt\n    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option\n    val of_list : elt list -&gt; t\n    val to_seq_from : elt -&gt; t -&gt; elt Seq.t\n    val to_seq : t -&gt; elt Seq.t\n    val add_seq : elt Seq.t -&gt; t -&gt; t\n    val of_seq : elt Seq.t -&gt; t\n  end\n# let set = StringSet.empty\nval set : StringSet.t = &lt;abstr&gt;\n# let set = StringSet.add &quot;here&quot; set\nval set : StringSet.t = &lt;abstr&gt;\n# let set = StringSet.add &quot;are&quot; set\nval set : StringSet.t = &lt;abstr&gt;\n# let set = StringSet.add &quot;some&quot; set\nval set : StringSet.t = &lt;abstr&gt;\n# let set = StringSet.add &quot;values&quot; set\nval set : StringSet.t = &lt;abstr&gt;\n# let stream = elements StringSet.iter set\nval stream : string Stream.t = &lt;abstr&gt;\n# Stream.iter print_endline stream\nare\nhere\nsome\nvalues\n- : unit = ()\n</code></pre>\n<p>Some data types, like Hashtbl and Map, provide an <code>iter</code> function that\niterates through key-value pairs. Here's a function for those, too:</p>\n<pre><code class=\"language-ocaml\"># let items iter coll =\n  let channel = Event.new_channel () in\n  let producer () =\n    let () =\n      iter (fun k v -&gt;\n              Event.sync (Event.send channel (Some (k, v)))) coll in\n    Event.sync (Event.send channel None) in\n  let consumer i =\n    Event.sync (Event.receive channel) in\n  ignore (Thread.create producer ());\n  Stream.from consumer\nval items : (('a -&gt; 'b -&gt; unit) -&gt; 'c -&gt; unit) -&gt; 'c -&gt; ('a * 'b) Stream.t =\n  &lt;fun&gt;\n</code></pre>\n<p>If we want just the keys, or just the values, it is simple to transform\nthe output of <code>items</code> using <code>stream_map</code>:</p>\n<pre><code class=\"language-ocaml\"># let keys iter coll = stream_map (fun (k, v) -&gt; k) (items iter coll)\nval keys : (('a -&gt; 'b -&gt; unit) -&gt; 'c -&gt; unit) -&gt; 'c -&gt; 'a Stream.t = &lt;fun&gt;\n# let values iter coll = stream_map (fun (k, v) -&gt; v) (items iter coll)\nval values : (('a -&gt; 'b -&gt; unit) -&gt; 'c -&gt; unit) -&gt; 'c -&gt; 'b Stream.t = &lt;fun&gt;\n</code></pre>\n<p>Keep in mind that these techniques spawn producer threads which carry a\nfew risks: they only terminate when they have finished iterating, and\nany change to the original data structure while iterating may produce\nunexpected results.</p>\n<h2 id=\"other-built-in-stream-functions\">Other built-in Stream functions</h2>\n<p>There are a few other documented methods in the <code>Stream</code> module:</p>\n<ul>\n<li>Stream.empty, which raises <code>Stream.Failure</code> unless a stream is empty\n</li>\n<li>Stream.count, which returns the stream count (number of discarded\nelements)\n</li>\n</ul>\n<p>In addition, there are a few undocumented functions: <code>iapp</code>, <code>icons</code>,\n<code>ising</code>, <code>lapp</code>, <code>lcons</code>, <code>lsing</code>, <code>sempty</code>, <code>slazy</code>, and <code>dump</code>. They\nare visible in the interface with the caveat: &quot;For system use only, not\nfor the casual user&quot;.</p>\n"},tl:{hd:{title:"Format",slug:"format",description:"The Format module of Caml Light and OCaml's standard libraries provides pretty-printing facilities to get a fancy display for printing routines\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"stdlib",tl:{hd:"common",tl:0}},users:{hd:"Intermediate",tl:0},body_md:'\nThe `Format` module of Caml Light and OCaml\'s standard libraries\nprovides pretty-printing facilities to get a fancy display for printing\nroutines. This module implements a \u201cpretty-printing engine\u201d that is\nintended to break lines in a nice way (let\'s say \u201cautomatically when it\nis necessary\u201d).\n\n## Principles\nLine breaking is based on three concepts:\n\n* **boxes**: a box is a logical pretty-printing unit, which defines a\n behaviour of the pretty-printing engine to display the material\n inside the box.\n* **break hints**: a break hint is a directive to the pretty-printing\n engine that proposes to break the line here, if it is necessary to\n properly print the rest of the material. Otherwise, the\n pretty-printing engine never break lines (except \u201cin case of\n emergency\u201d to avoid very bad output). In short, a break hint tells\n the pretty printer that a line break here may be appropriate.\n* **Indentation rules**: When a line break occurs, the pretty-printing\n engines fixes the indentation (or amount of leading spaces) of the\n new line using indentation rules, as follows:\n    * A box can state the extra indentation of every new line opened\n in its scope. This extra indentation is named **box breaking\n indentation**.\n    * A break hint can also set the additional indentation of the new\n line it may fire. This extra indentation is named **hint\n breaking indentation**.\n    * If break hint `bh` fires a new line within box `b`, then the\n indentation of the new line is simply the sum of: the current\n indentation of box `b` `+` the additional box breaking\n indentation, as defined by box `b` `+` the additional hint\n breaking indentation, as defined by break hint `bh`.\n\n## Boxes\nThere are 4 types of boxes. (The most often used is the \u201chov\u201d box type,\nso skip the rest at first reading).\n\n* **horizontal box** (*h* box, as obtained by the `open_hbox`\n procedure): within this box, break hints do not lead to line breaks.\n* **vertical box** (*v* box, as obtained by the `open_vbox`\n procedure): within this box, every break hint lead to a new line.\n* **vertical/horizontal box** (*hv* box, as obtained by the\n `open_hvbox` procedure): if it is possible, the entire box is\n written on a single line; otherwise, every break hint within the box\n leads to a new line.\n* **vertical or horizontal box** (*hov* box, as obtained by the\n open_box or open_hovbox procedures): within this box, break hints\n are used to cut the line when there is no more room on the line.\n There are two kinds of \u201chov\u201d boxes, you can find the details\n [below](#Refinementonhovboxes). In first approximation, let me consider these\n two kinds of \u201chov\u201d boxes as equivalent and obtained by calling the\n `open_box` procedure.\n\nLet me give an example. Suppose we can write 10 chars before the right\nmargin (that indicates no more room). We represent any char as a `-`\nsign; characters `[` and `]` indicates the opening and closing of a box\nand `b` stands for a break hint given to the pretty-printing engine.\n\nThe output "--b--b--" is displayed like this (the b symbol stands for\nthe value of the break that is explained below):\n\n* within a \u201ch\u201d box:\n\n    ```text\n    --b--b--\n    ```\n\n* within a \u201cv\u201d box:\n\n    ```text\n    --b\n    --b\n    --\n    ```\n\n* within a \u201chv\u201d box:\n\n    If there is enough room to print the box on the line:\n\n    ```text\n    --b--b--\n    ```\n    But "---b---b---" that cannot fit on the line is written\n\n    ```text\n    ---b\n    ---b\n    ---\n    ```\n\n* within a \u201chov\u201d box:\n\n    If there is enough room to print the box on the line:\n\n    ```text\n    --b--b--\n    ```\n    But if "---b---b---" cannot fit on the line, it is written as\n\n    ```text\n    ---b---b\n    ---\n    ```\n    The first break hint does not lead to a new line, since there is\n    enough room on the line. The second one leads to a new line since\n    there is no more room to print the material following it. If the\n    room left on the line were even shorter, the first break hint may\n    lead to a new line and "---b---b---" is written as:\n\n    ```text\n    ---b\n    ---b\n    ---\n    ```\n\n\n## Printing spaces\nBreak hints are also used to output spaces (if the line is not split\nwhen the break is encountered, otherwise the new line indicates properly\nthe separation between printing items). You output a break hint using\n`print_break sp indent`, and this `sp` integer is used to print \u201csp\u201d\nspaces. Thus `print_break sp ...` may be thought as: print `sp` spaces\nor output a new line.\n\nFor instance, if b is `break 1 0` in the output "--b--b--", we get\n\n* within a \u201ch\u201d box:\n\n    ```text\n    -- -- --\n    ```\n\n* within a \u201cv\u201d box:\n\n    ```text\n    --\n    --\n    --\n    ```\n\n* within a \u201chv\u201d box:\n\n    ```text\n    -- -- --\n    ```\n    or, according to the remaining room on the line:\n\n    ```text\n    --\n    --\n    --\n    ```\n\n* and similarly for \u201chov\u201d boxes.\n\nGenerally speaking, a printing routine using "format", should not\ndirectly output white spaces: the routine should use break hints\ninstead. (For instance `print_space ()` that is a convenient\nabbreviation for `print_break 1 0` and outputs a single space or break\nthe line.)\n\n\n## Indentation of new lines\nThe user gets 2 ways to fix the indentation of new lines:\n\n* **when defining the box**: when you open a box, you can fix the\n indentation added to each new line opened within that box.<br />\n For instance: `open_hovbox 1` opens a \u201chov\u201d box with new lines\n indented 1 more than the initial indentation of the box. With output\n "---[--b--b--b--", we get:\n\n    ```text\n    ---[--b--b\n         --b--\n    ```\n    with `open_hovbox 2`, we get\n\n    ```text\n    ---[--b--b\n          --b--\n    ```\n    Note: the `[` sign in the display is not visible on the screen, it\n    is just there to materialise the aperture of the pretty-printing\n    box. Last \u201cscreen\u201d stands for:\n\n    ```text\n    -----b--b\n         --b--\n    ```\n\n* **when defining the break that makes the new line**. As said above,\n you output a break hint using `print_break     sp           indent`.\n The `indent` integer is used to fix the additional indentation of\n the new line. Namely, it is added to the default indentation offset\n of the box where the break occurs.<br />\n For instance, if `[` stands for the opening of a \u201chov\u201d box with 1\n as extra indentation (as obtained by `open_hovbox 1`), and b is\n `print_break       1       2`, then from output "---[--b--b--b--",\n we get:\n\n    ```text\n    ---[-- --\n          --\n          --\n    ```\n\n\n## Refinement on \u201chov\u201d boxes\n###  Packing and structural \u201chov\u201d boxes\n\nThe \u201chov\u201d box type is refined into two categories.\n\n* **the vertical or horizontal *packing* box** (as obtained by the\n open_hovbox procedure): break hints are used to cut the line when\n there is no more room on the line; no new line occurs if there is\n enough room on the line.\n* **vertical or horizontal *structural* box** (as obtained by the\n open_box procedure): similar to the \u201chov\u201d packing box, the break\n hints are used to cut the line when there is no more room on the\n line; in addition, break hints that can show the box structure lead\n to new lines even if there is enough room on the current line.\n\n###  Differences between a packing and a structural \u201chov\u201d box\nThe difference between a packing and a structural \u201chov\u201d box is shown by\na routine that closes boxes and parentheses at the end of printing: with\npacking boxes, the closure of boxes and parentheses do not lead to new\nlines if there is enough room on the line, whereas with structural boxes\neach break hint will lead to a new line. For instance, when printing\n`[(---[(----[(---b)]b)]b)]`, where `b` is a break hint without extra\nindentation (`print_cut ()`). If `[` means opening of a packing \u201chov\u201d\nbox (open_hovbox), `[(---[(----[(---b)]b)]b)]` is printed as follows:\n\n```text\n(---\n (----\n  (---)))\n```\nIf we replace the packing boxes by structural boxes (open_box), each\nbreak hint that precedes a closing parenthesis can show the boxes\nstructure, if it leads to a new line; hence `[(---[(----[(---b)]b)]b)]`\nis printed like this:\n\n```text\n(---\n (----\n  (---\n  )\n )\n)\n```\n\n## Practical advice\n\nWhen writing a pretty-printing routine, follow these simple rules:\n\n1. Boxes must be opened and closed consistently (`open_*` and\n `close_box` must be nested like parentheses).\n1. Never hesitate to open a box.\n1. Output many break hints, otherwise the pretty-printer is in a bad\n situation where it tries to do its best, which is always \u201cworse than\n your bad\u201d.\n1. Do not try to force spacing using explicit spaces in the character\n strings. For each space you want in the output emit a break hint\n (`print_space ()`), unless you explicitly don\'t want the line to be\n broken here. For instance, imagine you want to pretty print an OCaml\n definition, more precisely a `let rec ident =     expression` value\n definition. You will probably treat the first three spaces as\n \u201cunbreakable spaces\u201d and write them directly in the string constants\n for keywords, and print `"let rec "` before the identifier, and\n similarly write ` =` to get an unbreakable space after the\n identifier; in contrast, the space after the `=` sign is certainly a\n break hint, since breaking the line after `=` is a usual (and\n elegant) way to indent the expression part of a definition. In\n short, it is often necessary to print unbreakable spaces; however,\n most of the time a space should be considered a break hint.\n1. Do not try to force new lines, let the pretty-printer do it for you:\n that\'s its only job. In particular, do not use `force_newline`: this\n procedure effectively leads to a newline, but it also as the\n unfortunate side effect to partially reinitialise the\n pretty-printing engine, so that the rest of the printing material is\n noticeably messed up.\n1. Never put newline characters directly in the strings to be printed:\n pretty printing engine will consider this newline character as any\n other character written on the current line and this will completely\n mess up the output. Instead of new line characters use line break\n hints: if those break hints must always result in new lines, it just\n means that the surrounding box must be a vertical box!\n1. End your main program by a `print_newline ()` call, that flushes the\n pretty-printer tables (hence the output). (Note that the top-level\n loop of the interactive system does it as well, just before a new\n input.)\n\n## Printing to `stdout`: using `printf`\nThe `format` module provides a general printing facility \u201c\xe0 la\u201d\n`printf`. In addition to the usual conversion facility provided by\n`printf`, you can write pretty-printing indications directly inside the\nformat string (opening and closing boxes, indicating breaking hints,\netc).\n\nPretty-printing annotations are introduced by the `@` symbol, directly\ninto the string format. Almost any function of the `format` module can\nbe called from within a `printf` format string. For instance\n\n* \u201c`@[`\u201d open a box (`open_box     0`). You may precise the type as an\n extra argument. For instance `@[<hov n>` is equivalent to\n `open_hovbox       n`.\n* \u201c`@]`\u201d close a box (`close_box       ()`).\n* \u201c`@` \u201d output a breakable space (`print_space ()`).\n* \u201c`@,`\u201d output a break hint (`print_cut       ()`).\n* \u201c`@;<n m>`\u201d emit a \u201cfull\u201d break hint (`print_break n m`).\n* \u201c`@.`\u201d end the pretty-printing, closing all the boxes still opened\n (`print_newline ()`).\n\nFor instance\n\n```ocaml\n# Format.printf "@[<1>%s@ =@ %d@ %s@]@." "Prix TTC" 100 "Euros"\nPrix TTC = 100 Euros\n- : unit = ()\n```\n\n## A concrete example\n\nLet me give a full example: the shortest non trivial example you could\nimagine, that is the \u03bb-calculus. :)\n\nThus the problem is to pretty-print the values of a concrete data type\nthat models a language of expressions that defines functions and their\napplications to arguments.\n\nFirst, I give the abstract syntax of lambda-terms (we illustrate it in\nthe [interactive system](../description.html#Interactivity)):\n\n```ocaml\n# type lambda =\n  | Lambda of string * lambda\n  | Var of string\n  | Apply of lambda * lambda\ntype lambda =\n    Lambda of string * lambda\n  | Var of string\n  | Apply of lambda * lambda\n```\nI use the format library to print the lambda-terms:\n\n```ocaml\nopen Format\nlet ident = print_string\nlet kwd = print_string\n\nlet rec print_exp0 = function\n  | Var s ->  ident s\n  | lam -> open_hovbox 1; kwd "("; print_lambda lam; kwd ")"; close_box ()\nand print_app = function\n  | e -> open_hovbox 2; print_other_applications e; close_box ()\nand print_other_applications f =\n  match f with\n  | Apply (f, arg) -> print_app f; print_space (); print_exp0 arg\n  | f -> print_exp0 f\nand print_lambda = function\n  | Lambda (s, lam) ->\n      open_hovbox 1;\n      kwd "\\\\"; ident s; kwd "."; print_space(); print_lambda lam;\n      close_box()\n  | e -> print_app e\n```\nIn Caml Light, replace the first line by:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\n#open "format";;\n```\n\n###  Most general pretty-printing: using `fprintf`\n\nWe use the `fprintf` function to write the most versatile version of the\npretty-printing functions for lambda-terms. Now, the functions get an\nextra argument, namely a pretty-printing formatter (the `ppf` argument)\nwhere printing will occur. This way the printing routines are more\ngeneral, since they can print on any formatter defined in the program\n(either printing to a file, or to `stdout`, to `stderr`, or even to a\nstring). Furthermore, the pretty-printing functions are now\ncompositional, since they may be used in conjunction with the special\n`%a` conversion, that prints a `fprintf` argument with a user\'s supplied\nfunction (these user\'s supplied functions also have a formatter as first\nargument).\n\nUsing `fprintf`, the lambda-terms printing routines can be written as\nfollows:\n\n```ocaml\nopen Format\n\nlet ident ppf s = fprintf ppf "%s" s\nlet kwd ppf s = fprintf ppf "%s" s\n\nlet rec pr_exp0 ppf = function\n  | Var s -> fprintf ppf "%a" ident s\n  | lam -> fprintf ppf "@[<1>(%a)@]" pr_lambda lam\nand pr_app ppf e =\n  fprintf ppf "@[<2>%a@]" pr_other_applications e\nand pr_other_applications ppf f =\n  match f with\n  | Apply (f, arg) -> fprintf ppf "%a@ %a" pr_app f pr_exp0 arg\n  | f -> pr_exp0 ppf f\nand pr_lambda ppf = function\n  | Lambda (s, lam) ->\n     fprintf ppf "@[<1>%a%a%a@ %a@]"\n             kwd "\\\\" ident s kwd "." pr_lambda lam\n  | e -> pr_app ppf e\n```\n\nGiven those general printing routines, procedures to print to `stdout`\nor `stderr` is just a matter of partial application:\n\n```ocaml\nlet print_lambda = pr_lambda std_formatter\nlet eprint_lambda = pr_lambda err_formatter\n```\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#principles">Principles</a>\n</li>\n<li><a href="#boxes">Boxes</a>\n</li>\n<li><a href="#printing-spaces">Printing spaces</a>\n</li>\n<li><a href="#indentation-of-new-lines">Indentation of new lines</a>\n</li>\n<li><a href="#refinement-on-hov-boxes">Refinement on \u201chov\u201d boxes</a>\n</li>\n<li><a href="#practical-advice">Practical advice</a>\n</li>\n<li><a href="#printing-to-stdout-using-printf">Printing to <code>stdout</code>: using <code>printf</code></a>\n</li>\n<li><a href="#a-concrete-example">A concrete example</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>The <code>Format</code> module of Caml Light and OCaml\'s standard libraries\nprovides pretty-printing facilities to get a fancy display for printing\nroutines. This module implements a \u201cpretty-printing engine\u201d that is\nintended to break lines in a nice way (let\'s say \u201cautomatically when it\nis necessary\u201d).</p>\n<h2 id="principles">Principles</h2>\n<p>Line breaking is based on three concepts:</p>\n<ul>\n<li><strong>boxes</strong>: a box is a logical pretty-printing unit, which defines a\nbehaviour of the pretty-printing engine to display the material\ninside the box.\n</li>\n<li><strong>break hints</strong>: a break hint is a directive to the pretty-printing\nengine that proposes to break the line here, if it is necessary to\nproperly print the rest of the material. Otherwise, the\npretty-printing engine never break lines (except \u201cin case of\nemergency\u201d to avoid very bad output). In short, a break hint tells\nthe pretty printer that a line break here may be appropriate.\n</li>\n<li><strong>Indentation rules</strong>: When a line break occurs, the pretty-printing\nengines fixes the indentation (or amount of leading spaces) of the\nnew line using indentation rules, as follows:\n<ul>\n<li>A box can state the extra indentation of every new line opened\nin its scope. This extra indentation is named <strong>box breaking\nindentation</strong>.\n</li>\n<li>A break hint can also set the additional indentation of the new\nline it may fire. This extra indentation is named <strong>hint\nbreaking indentation</strong>.\n</li>\n<li>If break hint <code>bh</code> fires a new line within box <code>b</code>, then the\nindentation of the new line is simply the sum of: the current\nindentation of box <code>b</code> <code>+</code> the additional box breaking\nindentation, as defined by box <code>b</code> <code>+</code> the additional hint\nbreaking indentation, as defined by break hint <code>bh</code>.\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="boxes">Boxes</h2>\n<p>There are 4 types of boxes. (The most often used is the \u201chov\u201d box type,\nso skip the rest at first reading).</p>\n<ul>\n<li><strong>horizontal box</strong> (<em>h</em> box, as obtained by the <code>open_hbox</code>\nprocedure): within this box, break hints do not lead to line breaks.\n</li>\n<li><strong>vertical box</strong> (<em>v</em> box, as obtained by the <code>open_vbox</code>\nprocedure): within this box, every break hint lead to a new line.\n</li>\n<li><strong>vertical/horizontal box</strong> (<em>hv</em> box, as obtained by the\n<code>open_hvbox</code> procedure): if it is possible, the entire box is\nwritten on a single line; otherwise, every break hint within the box\nleads to a new line.\n</li>\n<li><strong>vertical or horizontal box</strong> (<em>hov</em> box, as obtained by the\nopen_box or open_hovbox procedures): within this box, break hints\nare used to cut the line when there is no more room on the line.\nThere are two kinds of \u201chov\u201d boxes, you can find the details\n<a href="#Refinementonhovboxes">below</a>. In first approximation, let me consider these\ntwo kinds of \u201chov\u201d boxes as equivalent and obtained by calling the\n<code>open_box</code> procedure.\n</li>\n</ul>\n<p>Let me give an example. Suppose we can write 10 chars before the right\nmargin (that indicates no more room). We represent any char as a <code>-</code>\nsign; characters <code>[</code> and <code>]</code> indicates the opening and closing of a box\nand <code>b</code> stands for a break hint given to the pretty-printing engine.</p>\n<p>The output &quot;--b--b--&quot; is displayed like this (the b symbol stands for\nthe value of the break that is explained below):</p>\n<ul>\n<li>\n<p>within a \u201ch\u201d box:</p>\n<pre><code class="language-text">--b--b--\n</code></pre>\n</li>\n<li>\n<p>within a \u201cv\u201d box:</p>\n<pre><code class="language-text">--b\n--b\n--\n</code></pre>\n</li>\n<li>\n<p>within a \u201chv\u201d box:</p>\n<p>If there is enough room to print the box on the line:</p>\n<pre><code class="language-text">--b--b--\n</code></pre>\n<p>But &quot;---b---b---&quot; that cannot fit on the line is written</p>\n<pre><code class="language-text">---b\n---b\n---\n</code></pre>\n</li>\n<li>\n<p>within a \u201chov\u201d box:</p>\n<p>If there is enough room to print the box on the line:</p>\n<pre><code class="language-text">--b--b--\n</code></pre>\n<p>But if &quot;---b---b---&quot; cannot fit on the line, it is written as</p>\n<pre><code class="language-text">---b---b\n---\n</code></pre>\n<p>The first break hint does not lead to a new line, since there is\nenough room on the line. The second one leads to a new line since\nthere is no more room to print the material following it. If the\nroom left on the line were even shorter, the first break hint may\nlead to a new line and &quot;---b---b---&quot; is written as:</p>\n<pre><code class="language-text">---b\n---b\n---\n</code></pre>\n</li>\n</ul>\n<h2 id="printing-spaces">Printing spaces</h2>\n<p>Break hints are also used to output spaces (if the line is not split\nwhen the break is encountered, otherwise the new line indicates properly\nthe separation between printing items). You output a break hint using\n<code>print_break sp indent</code>, and this <code>sp</code> integer is used to print \u201csp\u201d\nspaces. Thus <code>print_break sp ...</code> may be thought as: print <code>sp</code> spaces\nor output a new line.</p>\n<p>For instance, if b is <code>break 1 0</code> in the output &quot;--b--b--&quot;, we get</p>\n<ul>\n<li>\n<p>within a \u201ch\u201d box:</p>\n<pre><code class="language-text">-- -- --\n</code></pre>\n</li>\n<li>\n<p>within a \u201cv\u201d box:</p>\n<pre><code class="language-text">--\n--\n--\n</code></pre>\n</li>\n<li>\n<p>within a \u201chv\u201d box:</p>\n<pre><code class="language-text">-- -- --\n</code></pre>\n<p>or, according to the remaining room on the line:</p>\n<pre><code class="language-text">--\n--\n--\n</code></pre>\n</li>\n<li>\n<p>and similarly for \u201chov\u201d boxes.</p>\n</li>\n</ul>\n<p>Generally speaking, a printing routine using &quot;format&quot;, should not\ndirectly output white spaces: the routine should use break hints\ninstead. (For instance <code>print_space ()</code> that is a convenient\nabbreviation for <code>print_break 1 0</code> and outputs a single space or break\nthe line.)</p>\n<h2 id="indentation-of-new-lines">Indentation of new lines</h2>\n<p>The user gets 2 ways to fix the indentation of new lines:</p>\n<ul>\n<li>\n<p><strong>when defining the box</strong>: when you open a box, you can fix the\nindentation added to each new line opened within that box.<br />\nFor instance: <code>open_hovbox 1</code> opens a \u201chov\u201d box with new lines\nindented 1 more than the initial indentation of the box. With output\n&quot;---[--b--b--b--&quot;, we get:</p>\n<pre><code class="language-text">---[--b--b\n     --b--\n</code></pre>\n<p>with <code>open_hovbox 2</code>, we get</p>\n<pre><code class="language-text">---[--b--b\n      --b--\n</code></pre>\n<p>Note: the <code>[</code> sign in the display is not visible on the screen, it\nis just there to materialise the aperture of the pretty-printing\nbox. Last \u201cscreen\u201d stands for:</p>\n<pre><code class="language-text">-----b--b\n     --b--\n</code></pre>\n</li>\n<li>\n<p><strong>when defining the break that makes the new line</strong>. As said above,\nyou output a break hint using <code>print_break     sp           indent</code>.\nThe <code>indent</code> integer is used to fix the additional indentation of\nthe new line. Namely, it is added to the default indentation offset\nof the box where the break occurs.<br />\nFor instance, if <code>[</code> stands for the opening of a \u201chov\u201d box with 1\nas extra indentation (as obtained by <code>open_hovbox 1</code>), and b is\n<code>print_break       1       2</code>, then from output &quot;---[--b--b--b--&quot;,\nwe get:</p>\n<pre><code class="language-text">---[-- --\n      --\n      --\n</code></pre>\n</li>\n</ul>\n<h2 id="refinement-on-hov-boxes">Refinement on \u201chov\u201d boxes</h2>\n<h3 id="packing-and-structural-hov-boxes">Packing and structural \u201chov\u201d boxes</h3>\n<p>The \u201chov\u201d box type is refined into two categories.</p>\n<ul>\n<li><strong>the vertical or horizontal <em>packing</em> box</strong> (as obtained by the\nopen_hovbox procedure): break hints are used to cut the line when\nthere is no more room on the line; no new line occurs if there is\nenough room on the line.\n</li>\n<li><strong>vertical or horizontal <em>structural</em> box</strong> (as obtained by the\nopen_box procedure): similar to the \u201chov\u201d packing box, the break\nhints are used to cut the line when there is no more room on the\nline; in addition, break hints that can show the box structure lead\nto new lines even if there is enough room on the current line.\n</li>\n</ul>\n<h3 id="differences-between-a-packing-and-a-structural-hov-box">Differences between a packing and a structural \u201chov\u201d box</h3>\n<p>The difference between a packing and a structural \u201chov\u201d box is shown by\na routine that closes boxes and parentheses at the end of printing: with\npacking boxes, the closure of boxes and parentheses do not lead to new\nlines if there is enough room on the line, whereas with structural boxes\neach break hint will lead to a new line. For instance, when printing\n<code>[(---[(----[(---b)]b)]b)]</code>, where <code>b</code> is a break hint without extra\nindentation (<code>print_cut ()</code>). If <code>[</code> means opening of a packing \u201chov\u201d\nbox (open_hovbox), <code>[(---[(----[(---b)]b)]b)]</code> is printed as follows:</p>\n<pre><code class="language-text">(---\n (----\n  (---)))\n</code></pre>\n<p>If we replace the packing boxes by structural boxes (open_box), each\nbreak hint that precedes a closing parenthesis can show the boxes\nstructure, if it leads to a new line; hence <code>[(---[(----[(---b)]b)]b)]</code>\nis printed like this:</p>\n<pre><code class="language-text">(---\n (----\n  (---\n  )\n )\n)\n</code></pre>\n<h2 id="practical-advice">Practical advice</h2>\n<p>When writing a pretty-printing routine, follow these simple rules:</p>\n<ol>\n<li>Boxes must be opened and closed consistently (<code>open_*</code> and\n<code>close_box</code> must be nested like parentheses).\n</li>\n<li>Never hesitate to open a box.\n</li>\n<li>Output many break hints, otherwise the pretty-printer is in a bad\nsituation where it tries to do its best, which is always \u201cworse than\nyour bad\u201d.\n</li>\n<li>Do not try to force spacing using explicit spaces in the character\nstrings. For each space you want in the output emit a break hint\n(<code>print_space ()</code>), unless you explicitly don\'t want the line to be\nbroken here. For instance, imagine you want to pretty print an OCaml\ndefinition, more precisely a <code>let rec ident =     expression</code> value\ndefinition. You will probably treat the first three spaces as\n\u201cunbreakable spaces\u201d and write them directly in the string constants\nfor keywords, and print <code>&quot;let rec &quot;</code> before the identifier, and\nsimilarly write <code> =</code> to get an unbreakable space after the\nidentifier; in contrast, the space after the <code>=</code> sign is certainly a\nbreak hint, since breaking the line after <code>=</code> is a usual (and\nelegant) way to indent the expression part of a definition. In\nshort, it is often necessary to print unbreakable spaces; however,\nmost of the time a space should be considered a break hint.\n</li>\n<li>Do not try to force new lines, let the pretty-printer do it for you:\nthat\'s its only job. In particular, do not use <code>force_newline</code>: this\nprocedure effectively leads to a newline, but it also as the\nunfortunate side effect to partially reinitialise the\npretty-printing engine, so that the rest of the printing material is\nnoticeably messed up.\n</li>\n<li>Never put newline characters directly in the strings to be printed:\npretty printing engine will consider this newline character as any\nother character written on the current line and this will completely\nmess up the output. Instead of new line characters use line break\nhints: if those break hints must always result in new lines, it just\nmeans that the surrounding box must be a vertical box!\n</li>\n<li>End your main program by a <code>print_newline ()</code> call, that flushes the\npretty-printer tables (hence the output). (Note that the top-level\nloop of the interactive system does it as well, just before a new\ninput.)\n</li>\n</ol>\n<h2 id="printing-to-stdout-using-printf">Printing to <code>stdout</code>: using <code>printf</code></h2>\n<p>The <code>format</code> module provides a general printing facility \u201c\xe0 la\u201d\n<code>printf</code>. In addition to the usual conversion facility provided by\n<code>printf</code>, you can write pretty-printing indications directly inside the\nformat string (opening and closing boxes, indicating breaking hints,\netc).</p>\n<p>Pretty-printing annotations are introduced by the <code>@</code> symbol, directly\ninto the string format. Almost any function of the <code>format</code> module can\nbe called from within a <code>printf</code> format string. For instance</p>\n<ul>\n<li>\u201c<code>@[</code>\u201d open a box (<code>open_box     0</code>). You may precise the type as an\nextra argument. For instance <code>@[&lt;hov n&gt;</code> is equivalent to\n<code>open_hovbox       n</code>.\n</li>\n<li>\u201c<code>@]</code>\u201d close a box (<code>close_box       ()</code>).\n</li>\n<li>\u201c<code>@</code> \u201d output a breakable space (<code>print_space ()</code>).\n</li>\n<li>\u201c<code>@,</code>\u201d output a break hint (<code>print_cut       ()</code>).\n</li>\n<li>\u201c<code>@;&lt;n m&gt;</code>\u201d emit a \u201cfull\u201d break hint (<code>print_break n m</code>).\n</li>\n<li>\u201c<code>@.</code>\u201d end the pretty-printing, closing all the boxes still opened\n(<code>print_newline ()</code>).\n</li>\n</ul>\n<p>For instance</p>\n<pre><code class="language-ocaml"># Format.printf &quot;@[&lt;1&gt;%s@ =@ %d@ %s@]@.&quot; &quot;Prix TTC&quot; 100 &quot;Euros&quot;\nPrix TTC = 100 Euros\n- : unit = ()\n</code></pre>\n<h2 id="a-concrete-example">A concrete example</h2>\n<p>Let me give a full example: the shortest non trivial example you could\nimagine, that is the \u03bb-calculus. :)</p>\n<p>Thus the problem is to pretty-print the values of a concrete data type\nthat models a language of expressions that defines functions and their\napplications to arguments.</p>\n<p>First, I give the abstract syntax of lambda-terms (we illustrate it in\nthe <a href="../description.html#Interactivity">interactive system</a>):</p>\n<pre><code class="language-ocaml"># type lambda =\n  | Lambda of string * lambda\n  | Var of string\n  | Apply of lambda * lambda\ntype lambda =\n    Lambda of string * lambda\n  | Var of string\n  | Apply of lambda * lambda\n</code></pre>\n<p>I use the format library to print the lambda-terms:</p>\n<pre><code class="language-ocaml">open Format\nlet ident = print_string\nlet kwd = print_string\n\nlet rec print_exp0 = function\n  | Var s -&gt;  ident s\n  | lam -&gt; open_hovbox 1; kwd &quot;(&quot;; print_lambda lam; kwd &quot;)&quot;; close_box ()\nand print_app = function\n  | e -&gt; open_hovbox 2; print_other_applications e; close_box ()\nand print_other_applications f =\n  match f with\n  | Apply (f, arg) -&gt; print_app f; print_space (); print_exp0 arg\n  | f -&gt; print_exp0 f\nand print_lambda = function\n  | Lambda (s, lam) -&gt;\n      open_hovbox 1;\n      kwd &quot;\\\\&quot;; ident s; kwd &quot;.&quot;; print_space(); print_lambda lam;\n      close_box()\n  | e -&gt; print_app e\n</code></pre>\n<p>In Caml Light, replace the first line by:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">#open &quot;format&quot;;;\n</code></pre>\n<h3 id="most-general-pretty-printing-using-fprintf">Most general pretty-printing: using <code>fprintf</code></h3>\n<p>We use the <code>fprintf</code> function to write the most versatile version of the\npretty-printing functions for lambda-terms. Now, the functions get an\nextra argument, namely a pretty-printing formatter (the <code>ppf</code> argument)\nwhere printing will occur. This way the printing routines are more\ngeneral, since they can print on any formatter defined in the program\n(either printing to a file, or to <code>stdout</code>, to <code>stderr</code>, or even to a\nstring). Furthermore, the pretty-printing functions are now\ncompositional, since they may be used in conjunction with the special\n<code>%a</code> conversion, that prints a <code>fprintf</code> argument with a user\'s supplied\nfunction (these user\'s supplied functions also have a formatter as first\nargument).</p>\n<p>Using <code>fprintf</code>, the lambda-terms printing routines can be written as\nfollows:</p>\n<pre><code class="language-ocaml">open Format\n\nlet ident ppf s = fprintf ppf &quot;%s&quot; s\nlet kwd ppf s = fprintf ppf &quot;%s&quot; s\n\nlet rec pr_exp0 ppf = function\n  | Var s -&gt; fprintf ppf &quot;%a&quot; ident s\n  | lam -&gt; fprintf ppf &quot;@[&lt;1&gt;(%a)@]&quot; pr_lambda lam\nand pr_app ppf e =\n  fprintf ppf &quot;@[&lt;2&gt;%a@]&quot; pr_other_applications e\nand pr_other_applications ppf f =\n  match f with\n  | Apply (f, arg) -&gt; fprintf ppf &quot;%a@ %a&quot; pr_app f pr_exp0 arg\n  | f -&gt; pr_exp0 ppf f\nand pr_lambda ppf = function\n  | Lambda (s, lam) -&gt;\n     fprintf ppf &quot;@[&lt;1&gt;%a%a%a@ %a@]&quot;\n             kwd &quot;\\\\&quot; ident s kwd &quot;.&quot; pr_lambda lam\n  | e -&gt; pr_app ppf e\n</code></pre>\n<p>Given those general printing routines, procedures to print to <code>stdout</code>\nor <code>stderr</code> is just a matter of partial application:</p>\n<pre><code class="language-ocaml">let print_lambda = pr_lambda std_formatter\nlet eprint_lambda = pr_lambda err_formatter\n</code></pre>\n'},tl:{hd:{title:"Calling C Libraries",slug:"calling-c-libraries",description:"Cross the divide and call C code from your OCaml program\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"interoperability",tl:0},users:{hd:"Advanced",tl:0},body_md:'\n## MiniGtk\nWhile the structure of lablgtk outlined in [Introduction to\nGtk](introduction_to_gtk.html "Introduction to Gtk") seems perhaps\nover-complex, it\'s worth considering exactly why the author chose two\nlayers. To appreciate this, you really need to get your hands dirty and\nlook at other ways that a Gtk wrapper might have been written.\n\nTo this end I played around with something I call\n<dfn>MiniGtk</dfn>, intended as a simple Gtk wrapper. All MiniGtk is\ncapable of is opening a window with a label, but after writing MiniGtk I\nhad renewed respect for the author of lablgtk!\n\nMiniGtk is also a good tutorial for people who want to write OCaml\nbindings around their favorite C library. If you\'ve ever tried to write\nbindings for Python or Java, you\'ll find doing the same for OCaml is\nsurprisingly easy, although you do have to worry a bit about the garbage\ncollector.\n\nLet\'s talk first about how MiniGtk is structured: rather than using a\ntwo layered approach as with lablgtk, I wanted to implement MiniGtk\nusing a single (object-oriented) layer. This means that MiniGtk consists\nof a bunch of class definitions. Methods in those classes pretty much\ndirectly translate into calls to the C `libgtk-1.2.so` library.\n\nI also wanted to rationalise the module naming scheme for Gtk. So there\nis exactly one top-level module called (surprise!) `Gtk` and all classes\nare inside this module. A test program looks like this:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet win = new Gtk.window ~title:"My window" ();;\nlet lbl = new Gtk.label ~text:"Hello" ();;\nwin#add lbl;;\n\nlet () =\n  Gtk.main ()\n```\nI defined a single abstract type to cover all `GtkObject`s (and\n"subclasses" of this C structure). In the `Gtk` module you\'ll find this\ntype definition:\n\n```ocaml\ntype obj\n```\n\nAs discussed in the last chapter, this defines an abstract type of which\nit is impossible to create any instances. In OCaml, at least. Certain C\nfunctions are going to create instances of this type. For instance, the\nfunction which creates new labels (ie. `GtkLabel` structures) is defined\nthis way:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nexternal gtk_label_new : string -> obj = "gtk_label_new_c"\n```\n\nThis strange function definition defines an <dfn>external\nfunction</dfn>, one coming from C. The C function is called\n`gtk_label_new_c`, and it takes a string and returns one of our abstract\n`obj` types.\n\nOCaml doesn\'t quite let you call *any* C function yet. You need to write\na little C wrapper around the library\'s function to translate to and\nfrom OCaml\'s internal types and C types. `gtk_label_new_c` (note the\nadditional `_c`) is my wrapper around the real Gtk C function called\n`gtk_label_new`. Here it is. I\'ll explain more about it later.\n\n```C\nCAMLprim value\ngtk_label_new_c (value str)\n{\n  CAMLparam1 (str);\n  CAMLreturn (wrap (GTK_OBJECT (\n    gtk_label_new (String_val (str)))));\n }\n```\nBefore explaining this function further, I\'m going to take a step back\nand look at the hierarchy of our Gtk classes. I\'ve chosen to reflect the\nactual Gtk widget hierarchy as closely as possible. All Gtk widgets are\nderived from a virtual base class called `GtkObject`. In fact from this\nclass is derived `GtkWidget` and the whole variety of Gtk widgets are\nderived from this. So we define our own `GtkObject` equivalent class\nlike this (note that `object` is a reserved word in OCaml).\n\n```ocaml\ntype obj\n\nclass virtual gtk_object (obj : obj) =\nobject (self)\n  val obj = obj\n  method obj = obj\nend\n```\n\n`type obj` defines our abstract object type, and `class gtk_object`\ntakes one of these "things" as a parameter to its constructor. Recall\nfrom above that this parameter is actually the C `GtkObject` structure\n(in fact it\'s a specially wrapped pointer to this structure).\n\nYou can\'t create `gtk_object` instances directly because it\'s a virtual\nclass, but if you could you\'d have to construct them like this:\n`new gtk_object obj`. What would you pass as that `obj` parameter? You\'d\npass the return value of, for instance, `gtk_label_new` (go back and\nhave a look at how that `external` function was typed). This is shown\nbelow:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\n(* Example code, not really part of MiniGtk! *)\nclass label text =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit gtk_object obj\n  end\n```\n\nOf course the real `label` class doesn\'t inherit directly from\n`gtk_object` as shown above, but in principle this is how it works.\n\nFollowing the Gtk class hierarchy the only class derived directly from\n`gtk_object` is our `widget` class, defined like this:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nexternal gtk_widget_show : obj -> unit = "gtk_widget_show_c"\nexternal gtk_widget_show_all : obj -> unit = "gtk_widget_show_all_c"\n\nclass virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    method show = gtk_widget_show obj\n    method show_all = gtk_widget_show_all obj\n    initializer if show <> Some false then self#show\n  end\n```\nThis class is considerably more complex. Let\'s look at the\ninitialization code first:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nclass virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    initializer\n      if show <> Some false then self#show\n  end\n```\n\nThe `initializer` section may well be new to you. This is code which\nruns when an object is being created - the equivalent of a constructor\nin other languages. In this case we check the boolean optional `show`\nargument and unless the user specified it explicitly as `false` we\nautomatically call the `#show` method. (All Gtk widgets need to be\n"shown" after being created unless you want a widget to be created but\nhidden).\n\nThe actual definition of the methods happens with the help of a couple\nof external functions. These are basically direct calls to the C library\n(well, in fact there\'s a tiny bit of wrapper code, but that\'s not\nfunctionally important).\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nmethod show = gtk_widget_show obj\nmethod show_all = gtk_widget_show_all obj\n```\n\nNotice that we pass the underlying `GtkObject` to both C library calls.\nThis makes sense because these functions are prototyped as\n`void gtk_widget_show (GtkWidget *);` in C (`GtkWidget` and `GtkObject`\nare safely used interchangeably in this context).\n\nI want to describe the `label` class (the real one this time!), but in\nbetween `widget` and `label` is `misc`, a generic class which describes\na large class of miscellaneous widgets. This class just adds padding and\nalignment around a widget such as a label. Here is its definition:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet may f x =\n  match x with\n  | None -> ()\n  | Some x -> f x\n\nexternal gtk_misc_set_alignment :\n  obj -> float * float -> unit = "gtk_misc_set_alignment_c"\nexternal gtk_misc_set_padding :\n  obj -> int * int -> unit = "gtk_misc_set_padding_c"\n\nclass virtual misc ?alignment ?padding ?show obj =\n  object (self)\n    inherit widget ?show obj\n    method set_alignment = gtk_misc_set_alignment obj\n    method set_padding = gtk_misc_set_padding obj\n    initializer\n      may (gtk_misc_set_alignment obj) alignment;\n      may (gtk_misc_set_padding obj) padding\n  end\n```\n\nWe start with a helper function called\n`may : (\'a -> unit) -> \'a option -> unit` which invokes its first\nargument on the contents of its second unless the second argument is\n`None`. This trick (stolen from lablgtk of course) is very useful when\ndealing with optional arguments as we\'ll see.\n\nThe methods in `misc` should be straightforward. What is tricky is the\ninitialization code. First notice that we take optional `alignment` and\n`padding` arguments to the constructor, and we pass the optional `show`\nand mandatory `obj` arguments directly up to `widget`. What do we do\nwith the optional `alignment` and `padding`? The initializer uses these:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\ninitializer\n  may (gtk_misc_set_alignment obj) alignment;\n  may (gtk_misc_set_padding obj) padding \n```\n\nIt\'s that tricky `may` function in action. *If* the user gave an\n`alignment` argument, then this will set the alignment on the object by\ncalling `gtk_misc_set_alignment obj the_alignment`. But more commonly\nthe user will omit the `alignment` argument, in which case `alignment`\nis `None` and this does nothing. (In effect we get Gtk\'s default\nalignment, whatever that is). A similar thing happens with the\n`padding`. Note there is a certain simplicity and elegance in the way\nthis is done.\n\nNow we can finally get to the `label` class, which is derived directly\nfrom `misc`:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nexternal gtk_label_new :\n    string -> obj  = "gtk_label_new_c"\nexternal gtk_label_set_text :\n    obj -> string -> unit = "gtk_label_set_text_c"\nexternal gtk_label_set_justify :\n    obj -> Justification.t -> unit = "gtk_label_set_justify_c"\nexternal gtk_label_set_pattern :\n    obj -> string -> unit = "gtk_label_set_pattern_c"\nexternal gtk_label_set_line_wrap :\n    obj -> bool -> unit = "gtk_label_set_line_wrap_c"\n\nclass label ~text\n  ?justify ?pattern ?line_wrap ?alignment\n  ?padding ?show () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ?alignment ?padding ?show obj\n    method set_text = gtk_label_set_text obj\n    method set_justify = gtk_label_set_justify obj\n    method set_pattern = gtk_label_set_pattern obj\n    method set_line_wrap = gtk_label_set_line_wrap obj\n    initializer\n      may (gtk_label_set_justify obj) justify;\n      may (gtk_label_set_pattern obj) pattern;\n      may (gtk_label_set_line_wrap obj) line_wrap\n  end\n```\nAlthough this class is bigger than the ones we\'ve looked at up til now,\nit\'s really more of the same idea, *except* that this class isn\'t\nvirtual. You can create instances of this class which means it finally\nhas to call `gtk_..._new`. This is the initialization code (we discussed\nthis pattern above):\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nclass label ~text ... () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ... obj\n  end\n```\n(Pop quiz: what happens if we need to define a class which is both a\nbase class from which other classes can be derived, and is also a\nnon-virtual class of which the user should be allowed to create\ninstances?)\n\n####  Wrapping calls to C libraries\nNow we\'ll look in more detail at actually wrapping up calls to C library\nfunctions. Here\'s a simple example:\n\n```C\n/* external gtk_label_set_text :\n     obj -> string -> unit\n       = "gtk_label_set_text_c" */\n\nCAMLprim value\ngtk_label_set_text_c (value obj, value str)\n{\n  CAMLparam2 (obj, str);\n  gtk_label_set_text (unwrap (GtkLabel, obj),\n    String_val (str));\n  CAMLreturn (Val_unit);\n}\n```\nComparing the OCaml prototype for the external function call (in the\ncomment) with the definition of the function we can see two things:\n\n* The C function that OCaml calls is named `"gtk_label_set_text_c"`.\n* Two arguments are passed (`value obj` and `value str`) and a unit is\n returned.\n\nValues are OCaml\'s internal representation of all sorts of things from\nsimple integers through to strings and even objects. I\'m not going to go\ninto any great detail about the `value` type because it is more than\nadequately covered in the OCaml manual. To use `value` you need to just\nknow what macros are available to convert between a `value` and some C\ntype. The macros look like this:\n\n<dl> <dt>`String_val (val)`</dt> <dd> Convert from a `value`\nwhich is known to be a string to a C string (ie. `char *`). </dd>\n<dt>`Val_unit`</dt> <dd> The OCaml unit `()` as a `value`. </dd>\n<dt>`Int_val (val)`</dt> <dd> Convert from a `value` which\nis known to be an integer to a C `int`. </dd>\n<dt>`Val_int (i)`</dt> <dd> Convert from a C integer `i` into an\ninteger `value`. </dd> <dt>`Bool_val (val)`</dt> <dd> Convert\nfrom a `value` which is known to be a boolean to a C boolean (ie. an\n`int`). </dd> <dt>`Val_bool (i)`</dt> <dd> Convert from a C\ninteger `i` into a boolean `value`. </dd> </dl>\n\nYou can guess the others or consult the manual. Note that there is no\nstraightforward conversion from C `char *` to a value. This involves\nallocating memory, which is somewhat more complicated.\n\nIn `gtk_label_set_text_c` above, the `external` definition, plus strong\ntyping and type inference, has already ensured that the arguments are of\nthe correct type, so to convert `value str` to a C `char *` we called\n`String_val (str)`.\n\nThe other parts of the function are a bit stranger. To ensure that the\ngarbage collector "knows" that your C function is still using `obj` and\n`str` while the C function is running (remember that the garbage\ncollector might be triggered within your C function by a number of\nevents - a callback to OCaml or using one of OCaml\'s allocation\nfunctions), you need to frame the function to add code to tell the\ngarbage collector about the "roots" that you\'re using. And tell the\ngarbage collector when you finish using those roots too, of course. This\nis done by framing the function within `CAMLparamN` ... `CAMLreturn`.\nHence:\n\n```C\nCAMLparam2 (obj, str);\n...\nCAMLreturn (Val_unit); \n```\n\n`CAMLparam2` is a macro saying that you\'re using two `value` parameters.\n(There is another macro for annotating local `value` variables too). You\nneed to use `CAMLreturn` instead of plain `return` which tells the GC\nyou\'ve finished with those roots. It might be instructive to examine\nwhat code is inlined when you write `CAMLparam2 (obj, str)`. This is the\ngenerated code (with the author\'s version of OCaml, so it might vary\nbetween implementations slightly):\n\n```C\nstruct caml__roots_block *caml__frame\n    = local_roots;\nstruct caml__roots_block caml__roots_obj;\n\ncaml__roots_obj.next = local_roots;\nlocal_roots = &caml__roots_obj;\ncaml__roots_obj.nitems = 1;\ncaml__roots_obj.ntables = 2;\ncaml__roots_obj.tables [0] = &obj;\ncaml__roots_obj.tables [1] = &str; \n```\nAnd for `CAMLreturn (foo)`:\n\n```C\nlocal_roots = caml__frame;\nreturn (foo); \n```\n\nIf you follow the code closely you\'ll see that `local_roots` is\nobviously a linked list of `caml__roots_block` structures. One (or more)\nof these structures is pushed onto the linked list when we enter the\nfunction, and all of these are popped back off when we leave, thus\nrestoring `local_roots` to its previous state when we leave the\nfunction. (*If* you remembered to call `CAMLreturn` instead of `return`\nof course - otherwise `local_roots` will end up pointing at\nuninitialised data on the stack with "hilarious" consequences).\n\nEach `caml__roots_block` structure has space for up to five `value`s\n(you can have multiple blocks, so this isn\'t a limitation). When the GC\nruns we can infer that it must walk through the linked list, starting at\n`local_roots`, and treat each `value` as a root for garbage collection\npurposes. The consequences of *not* declaring a `value` parameter or\nlocal `value` variable in this way would be that the garbage collector\nmight treat that variable as unreachable memory and thus reclaim it\nwhile your function is running!\n\nFinally there is the mysterious `unwrap` macro. This is one I wrote\nmyself, or rather, this is one I mostly copied from lablgtk. There are\ntwo related functions, called `wrap` and `unwrap` and as you might\npossibly have guessed, they wrap and unwrap `GtkObject`s in OCaml\n`value`s. These functions establish the somewhat magical relationship\nbetween `GtkObject` and our opaque, mysterious `obj` type which we\ndefined for OCaml (see the very first part of this chapter to remind\nyourself).\n\nThe problem is how do we wrap up (and hide) the C `GtkObject` structure\nin a way that we can pass it around as an opaque "thing" (`obj`) through\nour OCaml code, and hopefully pass it back later to a C function which\ncan unwrap it and retrieve the same `GtkObject` back again?\n\nIn order for it to get passed to OCaml code at all, we must somehow\nconvert it to a `value`. Luckily we can quite easily use the C API to\ncreate `value` blocks which the OCaml garbage collector *won\'t* examine\ntoo closely ......\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#minigtk">MiniGtk</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="minigtk">MiniGtk</h2>\n<p>While the structure of lablgtk outlined in <a href="introduction_to_gtk.html" title="Introduction to Gtk">Introduction to\nGtk</a> seems perhaps\nover-complex, it\'s worth considering exactly why the author chose two\nlayers. To appreciate this, you really need to get your hands dirty and\nlook at other ways that a Gtk wrapper might have been written.</p>\n<p>To this end I played around with something I call\n<dfn>MiniGtk</dfn>, intended as a simple Gtk wrapper. All MiniGtk is\ncapable of is opening a window with a label, but after writing MiniGtk I\nhad renewed respect for the author of lablgtk!</p>\n<p>MiniGtk is also a good tutorial for people who want to write OCaml\nbindings around their favorite C library. If you\'ve ever tried to write\nbindings for Python or Java, you\'ll find doing the same for OCaml is\nsurprisingly easy, although you do have to worry a bit about the garbage\ncollector.</p>\n<p>Let\'s talk first about how MiniGtk is structured: rather than using a\ntwo layered approach as with lablgtk, I wanted to implement MiniGtk\nusing a single (object-oriented) layer. This means that MiniGtk consists\nof a bunch of class definitions. Methods in those classes pretty much\ndirectly translate into calls to the C <code>libgtk-1.2.so</code> library.</p>\n<p>I also wanted to rationalise the module naming scheme for Gtk. So there\nis exactly one top-level module called (surprise!) <code>Gtk</code> and all classes\nare inside this module. A test program looks like this:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let win = new Gtk.window ~title:&quot;My window&quot; ();;\nlet lbl = new Gtk.label ~text:&quot;Hello&quot; ();;\nwin#add lbl;;\n\nlet () =\n  Gtk.main ()\n</code></pre>\n<p>I defined a single abstract type to cover all <code>GtkObject</code>s (and\n&quot;subclasses&quot; of this C structure). In the <code>Gtk</code> module you\'ll find this\ntype definition:</p>\n<pre><code class="language-ocaml">type obj\n</code></pre>\n<p>As discussed in the last chapter, this defines an abstract type of which\nit is impossible to create any instances. In OCaml, at least. Certain C\nfunctions are going to create instances of this type. For instance, the\nfunction which creates new labels (ie. <code>GtkLabel</code> structures) is defined\nthis way:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">external gtk_label_new : string -&gt; obj = &quot;gtk_label_new_c&quot;\n</code></pre>\n<p>This strange function definition defines an <dfn>external\nfunction</dfn>, one coming from C. The C function is called\n<code>gtk_label_new_c</code>, and it takes a string and returns one of our abstract\n<code>obj</code> types.</p>\n<p>OCaml doesn\'t quite let you call <em>any</em> C function yet. You need to write\na little C wrapper around the library\'s function to translate to and\nfrom OCaml\'s internal types and C types. <code>gtk_label_new_c</code> (note the\nadditional <code>_c</code>) is my wrapper around the real Gtk C function called\n<code>gtk_label_new</code>. Here it is. I\'ll explain more about it later.</p>\n<pre><code class="language-C">CAMLprim value\ngtk_label_new_c (value str)\n{\n  CAMLparam1 (str);\n  CAMLreturn (wrap (GTK_OBJECT (\n    gtk_label_new (String_val (str)))));\n }\n</code></pre>\n<p>Before explaining this function further, I\'m going to take a step back\nand look at the hierarchy of our Gtk classes. I\'ve chosen to reflect the\nactual Gtk widget hierarchy as closely as possible. All Gtk widgets are\nderived from a virtual base class called <code>GtkObject</code>. In fact from this\nclass is derived <code>GtkWidget</code> and the whole variety of Gtk widgets are\nderived from this. So we define our own <code>GtkObject</code> equivalent class\nlike this (note that <code>object</code> is a reserved word in OCaml).</p>\n<pre><code class="language-ocaml">type obj\n\nclass virtual gtk_object (obj : obj) =\nobject (self)\n  val obj = obj\n  method obj = obj\nend\n</code></pre>\n<p><code>type obj</code> defines our abstract object type, and <code>class gtk_object</code>\ntakes one of these &quot;things&quot; as a parameter to its constructor. Recall\nfrom above that this parameter is actually the C <code>GtkObject</code> structure\n(in fact it\'s a specially wrapped pointer to this structure).</p>\n<p>You can\'t create <code>gtk_object</code> instances directly because it\'s a virtual\nclass, but if you could you\'d have to construct them like this:\n<code>new gtk_object obj</code>. What would you pass as that <code>obj</code> parameter? You\'d\npass the return value of, for instance, <code>gtk_label_new</code> (go back and\nhave a look at how that <code>external</code> function was typed). This is shown\nbelow:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">(* Example code, not really part of MiniGtk! *)\nclass label text =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit gtk_object obj\n  end\n</code></pre>\n<p>Of course the real <code>label</code> class doesn\'t inherit directly from\n<code>gtk_object</code> as shown above, but in principle this is how it works.</p>\n<p>Following the Gtk class hierarchy the only class derived directly from\n<code>gtk_object</code> is our <code>widget</code> class, defined like this:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">external gtk_widget_show : obj -&gt; unit = &quot;gtk_widget_show_c&quot;\nexternal gtk_widget_show_all : obj -&gt; unit = &quot;gtk_widget_show_all_c&quot;\n\nclass virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    method show = gtk_widget_show obj\n    method show_all = gtk_widget_show_all obj\n    initializer if show &lt;&gt; Some false then self#show\n  end\n</code></pre>\n<p>This class is considerably more complex. Let\'s look at the\ninitialization code first:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">class virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    initializer\n      if show &lt;&gt; Some false then self#show\n  end\n</code></pre>\n<p>The <code>initializer</code> section may well be new to you. This is code which\nruns when an object is being created - the equivalent of a constructor\nin other languages. In this case we check the boolean optional <code>show</code>\nargument and unless the user specified it explicitly as <code>false</code> we\nautomatically call the <code>#show</code> method. (All Gtk widgets need to be\n&quot;shown&quot; after being created unless you want a widget to be created but\nhidden).</p>\n<p>The actual definition of the methods happens with the help of a couple\nof external functions. These are basically direct calls to the C library\n(well, in fact there\'s a tiny bit of wrapper code, but that\'s not\nfunctionally important).</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">method show = gtk_widget_show obj\nmethod show_all = gtk_widget_show_all obj\n</code></pre>\n<p>Notice that we pass the underlying <code>GtkObject</code> to both C library calls.\nThis makes sense because these functions are prototyped as\n<code>void gtk_widget_show (GtkWidget *);</code> in C (<code>GtkWidget</code> and <code>GtkObject</code>\nare safely used interchangeably in this context).</p>\n<p>I want to describe the <code>label</code> class (the real one this time!), but in\nbetween <code>widget</code> and <code>label</code> is <code>misc</code>, a generic class which describes\na large class of miscellaneous widgets. This class just adds padding and\nalignment around a widget such as a label. Here is its definition:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let may f x =\n  match x with\n  | None -&gt; ()\n  | Some x -&gt; f x\n\nexternal gtk_misc_set_alignment :\n  obj -&gt; float * float -&gt; unit = &quot;gtk_misc_set_alignment_c&quot;\nexternal gtk_misc_set_padding :\n  obj -&gt; int * int -&gt; unit = &quot;gtk_misc_set_padding_c&quot;\n\nclass virtual misc ?alignment ?padding ?show obj =\n  object (self)\n    inherit widget ?show obj\n    method set_alignment = gtk_misc_set_alignment obj\n    method set_padding = gtk_misc_set_padding obj\n    initializer\n      may (gtk_misc_set_alignment obj) alignment;\n      may (gtk_misc_set_padding obj) padding\n  end\n</code></pre>\n<p>We start with a helper function called\n<code>may : (\'a -&gt; unit) -&gt; \'a option -&gt; unit</code> which invokes its first\nargument on the contents of its second unless the second argument is\n<code>None</code>. This trick (stolen from lablgtk of course) is very useful when\ndealing with optional arguments as we\'ll see.</p>\n<p>The methods in <code>misc</code> should be straightforward. What is tricky is the\ninitialization code. First notice that we take optional <code>alignment</code> and\n<code>padding</code> arguments to the constructor, and we pass the optional <code>show</code>\nand mandatory <code>obj</code> arguments directly up to <code>widget</code>. What do we do\nwith the optional <code>alignment</code> and <code>padding</code>? The initializer uses these:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">initializer\n  may (gtk_misc_set_alignment obj) alignment;\n  may (gtk_misc_set_padding obj) padding \n</code></pre>\n<p>It\'s that tricky <code>may</code> function in action. <em>If</em> the user gave an\n<code>alignment</code> argument, then this will set the alignment on the object by\ncalling <code>gtk_misc_set_alignment obj the_alignment</code>. But more commonly\nthe user will omit the <code>alignment</code> argument, in which case <code>alignment</code>\nis <code>None</code> and this does nothing. (In effect we get Gtk\'s default\nalignment, whatever that is). A similar thing happens with the\n<code>padding</code>. Note there is a certain simplicity and elegance in the way\nthis is done.</p>\n<p>Now we can finally get to the <code>label</code> class, which is derived directly\nfrom <code>misc</code>:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">external gtk_label_new :\n    string -&gt; obj  = &quot;gtk_label_new_c&quot;\nexternal gtk_label_set_text :\n    obj -&gt; string -&gt; unit = &quot;gtk_label_set_text_c&quot;\nexternal gtk_label_set_justify :\n    obj -&gt; Justification.t -&gt; unit = &quot;gtk_label_set_justify_c&quot;\nexternal gtk_label_set_pattern :\n    obj -&gt; string -&gt; unit = &quot;gtk_label_set_pattern_c&quot;\nexternal gtk_label_set_line_wrap :\n    obj -&gt; bool -&gt; unit = &quot;gtk_label_set_line_wrap_c&quot;\n\nclass label ~text\n  ?justify ?pattern ?line_wrap ?alignment\n  ?padding ?show () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ?alignment ?padding ?show obj\n    method set_text = gtk_label_set_text obj\n    method set_justify = gtk_label_set_justify obj\n    method set_pattern = gtk_label_set_pattern obj\n    method set_line_wrap = gtk_label_set_line_wrap obj\n    initializer\n      may (gtk_label_set_justify obj) justify;\n      may (gtk_label_set_pattern obj) pattern;\n      may (gtk_label_set_line_wrap obj) line_wrap\n  end\n</code></pre>\n<p>Although this class is bigger than the ones we\'ve looked at up til now,\nit\'s really more of the same idea, <em>except</em> that this class isn\'t\nvirtual. You can create instances of this class which means it finally\nhas to call <code>gtk_..._new</code>. This is the initialization code (we discussed\nthis pattern above):</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">class label ~text ... () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ... obj\n  end\n</code></pre>\n<p>(Pop quiz: what happens if we need to define a class which is both a\nbase class from which other classes can be derived, and is also a\nnon-virtual class of which the user should be allowed to create\ninstances?)</p>\n<h4 id="wrapping-calls-to-c-libraries">Wrapping calls to C libraries</h4>\n<p>Now we\'ll look in more detail at actually wrapping up calls to C library\nfunctions. Here\'s a simple example:</p>\n<pre><code class="language-C">/* external gtk_label_set_text :\n     obj -&gt; string -&gt; unit\n       = &quot;gtk_label_set_text_c&quot; */\n\nCAMLprim value\ngtk_label_set_text_c (value obj, value str)\n{\n  CAMLparam2 (obj, str);\n  gtk_label_set_text (unwrap (GtkLabel, obj),\n    String_val (str));\n  CAMLreturn (Val_unit);\n}\n</code></pre>\n<p>Comparing the OCaml prototype for the external function call (in the\ncomment) with the definition of the function we can see two things:</p>\n<ul>\n<li>The C function that OCaml calls is named <code>&quot;gtk_label_set_text_c&quot;</code>.\n</li>\n<li>Two arguments are passed (<code>value obj</code> and <code>value str</code>) and a unit is\nreturned.\n</li>\n</ul>\n<p>Values are OCaml\'s internal representation of all sorts of things from\nsimple integers through to strings and even objects. I\'m not going to go\ninto any great detail about the <code>value</code> type because it is more than\nadequately covered in the OCaml manual. To use <code>value</code> you need to just\nknow what macros are available to convert between a <code>value</code> and some C\ntype. The macros look like this:</p>\n<dl> <dt>`String_val (val)`</dt> <dd> Convert from a `value`\nwhich is known to be a string to a C string (ie. `char *`). </dd>\n<dt>`Val_unit`</dt> <dd> The OCaml unit `()` as a `value`. </dd>\n<dt>`Int_val (val)`</dt> <dd> Convert from a `value` which\nis known to be an integer to a C `int`. </dd>\n<dt>`Val_int (i)`</dt> <dd> Convert from a C integer `i` into an\ninteger `value`. </dd> <dt>`Bool_val (val)`</dt> <dd> Convert\nfrom a `value` which is known to be a boolean to a C boolean (ie. an\n`int`). </dd> <dt>`Val_bool (i)`</dt> <dd> Convert from a C\ninteger `i` into a boolean `value`. </dd> </dl>\n<p>You can guess the others or consult the manual. Note that there is no\nstraightforward conversion from C <code>char *</code> to a value. This involves\nallocating memory, which is somewhat more complicated.</p>\n<p>In <code>gtk_label_set_text_c</code> above, the <code>external</code> definition, plus strong\ntyping and type inference, has already ensured that the arguments are of\nthe correct type, so to convert <code>value str</code> to a C <code>char *</code> we called\n<code>String_val (str)</code>.</p>\n<p>The other parts of the function are a bit stranger. To ensure that the\ngarbage collector &quot;knows&quot; that your C function is still using <code>obj</code> and\n<code>str</code> while the C function is running (remember that the garbage\ncollector might be triggered within your C function by a number of\nevents - a callback to OCaml or using one of OCaml\'s allocation\nfunctions), you need to frame the function to add code to tell the\ngarbage collector about the &quot;roots&quot; that you\'re using. And tell the\ngarbage collector when you finish using those roots too, of course. This\nis done by framing the function within <code>CAMLparamN</code> ... <code>CAMLreturn</code>.\nHence:</p>\n<pre><code class="language-C">CAMLparam2 (obj, str);\n...\nCAMLreturn (Val_unit); \n</code></pre>\n<p><code>CAMLparam2</code> is a macro saying that you\'re using two <code>value</code> parameters.\n(There is another macro for annotating local <code>value</code> variables too). You\nneed to use <code>CAMLreturn</code> instead of plain <code>return</code> which tells the GC\nyou\'ve finished with those roots. It might be instructive to examine\nwhat code is inlined when you write <code>CAMLparam2 (obj, str)</code>. This is the\ngenerated code (with the author\'s version of OCaml, so it might vary\nbetween implementations slightly):</p>\n<pre><code class="language-C">struct caml__roots_block *caml__frame\n    = local_roots;\nstruct caml__roots_block caml__roots_obj;\n\ncaml__roots_obj.next = local_roots;\nlocal_roots = &amp;caml__roots_obj;\ncaml__roots_obj.nitems = 1;\ncaml__roots_obj.ntables = 2;\ncaml__roots_obj.tables [0] = &amp;obj;\ncaml__roots_obj.tables [1] = &amp;str; \n</code></pre>\n<p>And for <code>CAMLreturn (foo)</code>:</p>\n<pre><code class="language-C">local_roots = caml__frame;\nreturn (foo); \n</code></pre>\n<p>If you follow the code closely you\'ll see that <code>local_roots</code> is\nobviously a linked list of <code>caml__roots_block</code> structures. One (or more)\nof these structures is pushed onto the linked list when we enter the\nfunction, and all of these are popped back off when we leave, thus\nrestoring <code>local_roots</code> to its previous state when we leave the\nfunction. (<em>If</em> you remembered to call <code>CAMLreturn</code> instead of <code>return</code>\nof course - otherwise <code>local_roots</code> will end up pointing at\nuninitialised data on the stack with &quot;hilarious&quot; consequences).</p>\n<p>Each <code>caml__roots_block</code> structure has space for up to five <code>value</code>s\n(you can have multiple blocks, so this isn\'t a limitation). When the GC\nruns we can infer that it must walk through the linked list, starting at\n<code>local_roots</code>, and treat each <code>value</code> as a root for garbage collection\npurposes. The consequences of <em>not</em> declaring a <code>value</code> parameter or\nlocal <code>value</code> variable in this way would be that the garbage collector\nmight treat that variable as unreachable memory and thus reclaim it\nwhile your function is running!</p>\n<p>Finally there is the mysterious <code>unwrap</code> macro. This is one I wrote\nmyself, or rather, this is one I mostly copied from lablgtk. There are\ntwo related functions, called <code>wrap</code> and <code>unwrap</code> and as you might\npossibly have guessed, they wrap and unwrap <code>GtkObject</code>s in OCaml\n<code>value</code>s. These functions establish the somewhat magical relationship\nbetween <code>GtkObject</code> and our opaque, mysterious <code>obj</code> type which we\ndefined for OCaml (see the very first part of this chapter to remind\nyourself).</p>\n<p>The problem is how do we wrap up (and hide) the C <code>GtkObject</code> structure\nin a way that we can pass it around as an opaque &quot;thing&quot; (<code>obj</code>) through\nour OCaml code, and hopefully pass it back later to a C function which\ncan unwrap it and retrieve the same <code>GtkObject</code> back again?</p>\n<p>In order for it to get passed to OCaml code at all, we must somehow\nconvert it to a <code>value</code>. Luckily we can quite easily use the C API to\ncreate <code>value</code> blocks which the OCaml garbage collector <em>won\'t</em> examine\ntoo closely ......</p>\n'},tl:{hd:{title:"Calling Fortran Libraries",slug:"calling-fortran-libraries",description:"Cross the divide and call Fortran code from your OCaml program\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"interoperability",tl:0},users:{hd:"Advanced",tl:0},body_md:"\nFortran isn't a language the many people write new code in but it still\nis in extensive use in the scientific communities. Many, many libraries\nexist for doing numerical calculation that will never be written in C or\nC++. It is quite possible though to call Fortran routines from OCaml as\nthey are normally compiled into the same object format, with minimal\nname mangling, as C programs.\n\nThis tutorial will step by step through the process of compiling an\ninterface module for a fortran function. The steps that are involved\nhere are the same steps as for wrapping a C function with a few\nconsiderations that have to be taken into account for Fortran.\n\nThe Fortran function is contained in a file called func.f and has the\nfollowing signature\n\n`subroutine gtd6(integer iyd, real sec, real alt, real lat, real lon, real dens(8), real temp(2))`\n\nThe `iyd`, `sec`, `alt`, `lat`, and `lon` parameters are input\nparameters while `dens` and `temp` are output parameters.\n\nAll of the examples below use the GNU Fortran 77 compiler (g77). None of\nthese have been tested with the GNU fortran 90 compiler (gfort) and will\nnot be until it has proven itself through some time.\n\n###  Step 1: Compile the Fortran routine\nWhere C/C++ have only one category of subroutine (the function), Fortran\nhas two: the function and the subroutine. The function is the equivalent\nto a non-void C function in that it takes parameters and always returns\na value. The subroutine is equivalent to a void C function.\n\nWhen g77 compiles a fortran function it creates a named function that\nhas an underscore appended. If the fortran name for the function\ncontains any underscores then the compiled function name will have two\nunderscores appended. The generated function can be called by this name.\nSubroutines will be converted into a C function that returns an int.\n\nTo compile the funcs.f file into an object file, one can use the\nfollowing:\n\n`prompt> g77 -c funcs.f`\n\nWhich will generate the file 'funcs.o'. You can then see the names of\nthe compiled functions by executing\n\n`prompt> nm funcs.o`\n\nIn this output you will see a line that has the following\n\n` T gtd6_ `\n\nThis shows that the function gtd6_ has been created and is in the\nobject file.\n\nFortran has support for both integer and real types and those are the\nnames that they go by. In our case we have only real and integer types.\nReals are equivalent to C doubles and integers are equivalent to C\nlongs. In addition, Fortran passes everything by reference so the\ncorresponding C prototype for our gtd6 function is\n\n` int gtd6_(integer *iyd, real* sec, real* alt, real* glat, real* glong, real* dens, real* temp);`\n\nNote that its up to the caller to know that `dens` and `temp` are\nactually arrays. Failure to pass an array will cause a segmentation\nviolation since the gtd6_ function is using them as arrays (yet another\nreason OCaml shines).\n\n###  Step 2: Create the C wrapper\nBecause OCaml's foreign function interface is C based, it is necessary\nto create a C wrapper. To avoid difficulties in passing back arrays of\nvalues, we are going to simply create a function that will return the\nsecond element of the temperature array as computed by the function and\nignore the other return values (this is a very frequent use of the\nfunction). This function will be in the source file wrapper.c.\n\n```C\nCAMLprim value gtd6_t (value iydV, value secVal, value altVal, value latVal, value lonVal) {\n   CAMLparam5( iydV, secVal, altVal, latVal, lonVal );\n   long iyd = Long_val( iydV );\n   float    sec = Double_val( secVal );\n   float    alt = Double_val( altVal );\n   float    lat = Double_val( latVal );\n   float    lon = Double_val( lonVal );\n\n   gtd6_(&iyd, &sec, &alt, &glat, &glon, d, t);\n   CAMLreturn( caml_copy_double( t[1] ) );\n}\n```\nA few points of interest\n\n1. The file must include the OCaml header files `alloc.h`, `memory.h`,\n and `mlvalue.h`.\n1. The function first calls the CAMLparam5 macro. This is required at\n the start of any function that uses the CAML types.\n1. The function uses the Double_val and Long_val macros to extract\n the C types from the OCaml value object.\n1. All of the values are passed by reference to the gtd6_ routine as\n required by the prototype.\n1. The function uses the copy_caml_double function and the CAMLreturn\n macro to create a new value containing the return value and to\n return it respectively.\n\n###  Step 3: Compile the shared library.\nNow having the two source files funcs.f and wrapper.c we need to create\na shared library that can be loaded by OCaml. Its easier to do this as a\nmultistep process, so here are the commands:\n\n`prompt> g77 -c funcs.f`\n\n`prompt> cc -I<ocaml include path> -c wrapper.c `\n\n`prompt> cc -shared -o wrapper.so wrapper.o funcs.o -lg2c`\n\nThis will create a shared object library called wrapper.so containing\nthe fortran function and the wrapper function. The -lg2c option is\nrequired to provide the implementations of the built in fortran\nfunctions that are used.\n\n###  Step 4: Now to OCaml\nNow in an OCaml file (gtd6.ml) we have to define the external reference\nto the function and a function to call it.\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nexternal temp : int -> float -> float -> float -> float -> float = \"gtd6_t\"\n\nlet () =\n  print_double (temp 1 2.0 3.0 4.0 5.0);\n  print_newline ()\n```\nThis tells OCaml that the temp function takes 5 parameters and returns a\nsingle floating point and calls the C function gtd6_t.\n\nAt this point, the steps that are given are to compile this into\nbytecode. I don't yet have much experience compiling to native so I'll\nlet some else help out (or wait until I learn how to do it).\n\n```\nprompt> ocamlc -c gtd6.ml prompt> ocamlc -o test gtd6.cmo wrapper.so\n```\nAnd voila, we've called the fortran function from OCaml.\n",toc_html:"",body_html:'<p>Fortran isn\'t a language the many people write new code in but it still\nis in extensive use in the scientific communities. Many, many libraries\nexist for doing numerical calculation that will never be written in C or\nC++. It is quite possible though to call Fortran routines from OCaml as\nthey are normally compiled into the same object format, with minimal\nname mangling, as C programs.</p>\n<p>This tutorial will step by step through the process of compiling an\ninterface module for a fortran function. The steps that are involved\nhere are the same steps as for wrapping a C function with a few\nconsiderations that have to be taken into account for Fortran.</p>\n<p>The Fortran function is contained in a file called func.f and has the\nfollowing signature</p>\n<p><code>subroutine gtd6(integer iyd, real sec, real alt, real lat, real lon, real dens(8), real temp(2))</code></p>\n<p>The <code>iyd</code>, <code>sec</code>, <code>alt</code>, <code>lat</code>, and <code>lon</code> parameters are input\nparameters while <code>dens</code> and <code>temp</code> are output parameters.</p>\n<p>All of the examples below use the GNU Fortran 77 compiler (g77). None of\nthese have been tested with the GNU fortran 90 compiler (gfort) and will\nnot be until it has proven itself through some time.</p>\n<h3 id="step-1-compile-the-fortran-routine">Step 1: Compile the Fortran routine</h3>\n<p>Where C/C++ have only one category of subroutine (the function), Fortran\nhas two: the function and the subroutine. The function is the equivalent\nto a non-void C function in that it takes parameters and always returns\na value. The subroutine is equivalent to a void C function.</p>\n<p>When g77 compiles a fortran function it creates a named function that\nhas an underscore appended. If the fortran name for the function\ncontains any underscores then the compiled function name will have two\nunderscores appended. The generated function can be called by this name.\nSubroutines will be converted into a C function that returns an int.</p>\n<p>To compile the funcs.f file into an object file, one can use the\nfollowing:</p>\n<p><code>prompt&gt; g77 -c funcs.f</code></p>\n<p>Which will generate the file \'funcs.o\'. You can then see the names of\nthe compiled functions by executing</p>\n<p><code>prompt&gt; nm funcs.o</code></p>\n<p>In this output you will see a line that has the following</p>\n<p><code>T gtd6_</code></p>\n<p>This shows that the function gtd6_ has been created and is in the\nobject file.</p>\n<p>Fortran has support for both integer and real types and those are the\nnames that they go by. In our case we have only real and integer types.\nReals are equivalent to C doubles and integers are equivalent to C\nlongs. In addition, Fortran passes everything by reference so the\ncorresponding C prototype for our gtd6 function is</p>\n<p><code> int gtd6_(integer *iyd, real* sec, real* alt, real* glat, real* glong, real* dens, real* temp);</code></p>\n<p>Note that its up to the caller to know that <code>dens</code> and <code>temp</code> are\nactually arrays. Failure to pass an array will cause a segmentation\nviolation since the gtd6_ function is using them as arrays (yet another\nreason OCaml shines).</p>\n<h3 id="step-2-create-the-c-wrapper">Step 2: Create the C wrapper</h3>\n<p>Because OCaml\'s foreign function interface is C based, it is necessary\nto create a C wrapper. To avoid difficulties in passing back arrays of\nvalues, we are going to simply create a function that will return the\nsecond element of the temperature array as computed by the function and\nignore the other return values (this is a very frequent use of the\nfunction). This function will be in the source file wrapper.c.</p>\n<pre><code class="language-C">CAMLprim value gtd6_t (value iydV, value secVal, value altVal, value latVal, value lonVal) {\n   CAMLparam5( iydV, secVal, altVal, latVal, lonVal );\n   long iyd = Long_val( iydV );\n   float    sec = Double_val( secVal );\n   float    alt = Double_val( altVal );\n   float    lat = Double_val( latVal );\n   float    lon = Double_val( lonVal );\n\n   gtd6_(&amp;iyd, &amp;sec, &amp;alt, &amp;glat, &amp;glon, d, t);\n   CAMLreturn( caml_copy_double( t[1] ) );\n}\n</code></pre>\n<p>A few points of interest</p>\n<ol>\n<li>The file must include the OCaml header files <code>alloc.h</code>, <code>memory.h</code>,\nand <code>mlvalue.h</code>.\n</li>\n<li>The function first calls the CAMLparam5 macro. This is required at\nthe start of any function that uses the CAML types.\n</li>\n<li>The function uses the Double_val and Long_val macros to extract\nthe C types from the OCaml value object.\n</li>\n<li>All of the values are passed by reference to the gtd6_ routine as\nrequired by the prototype.\n</li>\n<li>The function uses the copy_caml_double function and the CAMLreturn\nmacro to create a new value containing the return value and to\nreturn it respectively.\n</li>\n</ol>\n<h3 id="step-3-compile-the-shared-library">Step 3: Compile the shared library.</h3>\n<p>Now having the two source files funcs.f and wrapper.c we need to create\na shared library that can be loaded by OCaml. Its easier to do this as a\nmultistep process, so here are the commands:</p>\n<p><code>prompt&gt; g77 -c funcs.f</code></p>\n<p><code>prompt&gt; cc -I&lt;ocaml include path&gt; -c wrapper.c </code></p>\n<p><code>prompt&gt; cc -shared -o wrapper.so wrapper.o funcs.o -lg2c</code></p>\n<p>This will create a shared object library called wrapper.so containing\nthe fortran function and the wrapper function. The -lg2c option is\nrequired to provide the implementations of the built in fortran\nfunctions that are used.</p>\n<h3 id="step-4-now-to-ocaml">Step 4: Now to OCaml</h3>\n<p>Now in an OCaml file (gtd6.ml) we have to define the external reference\nto the function and a function to call it.</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">external temp : int -&gt; float -&gt; float -&gt; float -&gt; float -&gt; float = &quot;gtd6_t&quot;\n\nlet () =\n  print_double (temp 1 2.0 3.0 4.0 5.0);\n  print_newline ()\n</code></pre>\n<p>This tells OCaml that the temp function takes 5 parameters and returns a\nsingle floating point and calls the C function gtd6_t.</p>\n<p>At this point, the steps that are given are to compile this into\nbytecode. I don\'t yet have much experience compiling to native so I\'ll\nlet some else help out (or wait until I learn how to do it).</p>\n<pre><code>prompt&gt; ocamlc -c gtd6.ml prompt&gt; ocamlc -o test gtd6.cmo wrapper.so\n</code></pre>\n<p>And voila, we\'ve called the fortran function from OCaml.</p>\n'},tl:{hd:{title:"Command-line Arguments",slug:"command-line-arguments",description:"The Arg module that comes with the compiler can help you write command line interfaces\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"common",tl:0},users:{hd:"Intermediate",tl:0},body_md:'\nIn this tutorial we learn how to read command line arguments directly, using\nOCaml\'s `Sys.argv` array, and then how to do so more easily using the standard\nlibrary\'s `Arg` module.\n\n## Sys.argv\n\nLike in C and many other languages, the arguments that are passed to a given\nprogram on the command line are stored in an array. Following tradition, this\narray is named `argv`. It is found in the `Sys` module of the standard library,\ntherefore its full name is `Sys.argv`. The number of arguments including the\nname of the program itself is simply the length of the array. It is obtained\nusing the `Array.length` function.\n\nThe following program displays the arguments with their position in `Sys.argv`:\n\n\x3c!-- $MDX file=examples/args.ml --\x3e\n```ocaml\nlet () =\n  for i = 0 to Array.length Sys.argv - 1 do\n    Printf.printf "[%i] %s\\n" i Sys.argv.(i)\n  done\n```\n\nIf you save the program above as `args.ml`, and run `ocaml args.ml arg1 arg2\narg3`, here is what you get:\n\n\x3c!-- $MDX dir=examples --\x3e\n```sh\n$ ocaml args.ml arg1 arg2 arg3\n[0] args.ml\n[1] arg1\n[2] arg2\n[3] arg3\n```\n\nNote that `ocaml` launched a subprocess that actually runs the program where\nargv is `args.ml arg1 arg2 arg3`. You can also compile your program using\n`ocamlopt -o args args.ml`, and then running `./args arg1 arg2 arg3` and you\nwill get:\n\n\x3c!-- $MDX dir=examples --\x3e\n```sh\n$ ocamlopt -o args args.ml\n$ ./args arg1 arg2 arg3\n[0] ./args\n[1] arg1\n[2] arg2\n[3] arg3\n```\n\n## Using the Arg module\n\nThe OCaml standard library has a module for writing command line interfaces, so\nwe do not have to use `Sys.argv` directly. We shall consider the example from\nthe OCaml documentation, a program for appending files.\n\nFirst, we set up the usage message to be printed in the case of a malformed\ncommand line, or when help is requested:\n\n\x3c!-- $MDX file=examples/append.ml,part=0 --\x3e\n```ocaml\nlet usage_msg = "append [-verbose] <file1> [<file2>] ... -o <output>"\n```\n\nNow, we create some references to hold the information gathered from the\ncommand line. The `Arg` module will fill these in for us as the command line is\nread.\n\n\x3c!-- $MDX file=examples/append.ml,part=1 --\x3e\n```ocaml\nlet verbose = ref false\n\nlet input_files = ref []\n\nlet output_file = ref ""\n```\n\nWe have a boolean reference for the `-verbose` flag with a default value of\n`false`. Then we have a reference to a list which will hold the names of all\nthe input files. Finally, we have a string reference into which the single\noutput file name specified by `-o` will be placed.\n\nWe will need a function to handle the anonymous inputs, that is to say the ones\nwith no flag before them. In this case these are our input file names. Our\nfunction simply adds the file name to the reference defined earlier.\n\n\x3c!-- $MDX file=examples/append.ml,part=2 --\x3e\n```ocaml\nlet anon_fun filename = input_files := filename :: !input_files\n```\n\nFinally we build the list of command line flag specifcations. Each is a tuple\nof the flag name, the action to be taken when it is encountered, and the help\nstring.\n\n\x3c!-- $MDX file=examples/append.ml,part=3 --\x3e\n```ocaml\nlet speclist =\n  [\n    ("-verbose", Arg.Set verbose, "Output debug information");\n    ("-o", Arg.Set_string output_file, "Set output file name");\n  ]\n```\n\nWe have two kinds of action here: the `Arg.Set` action which sets a boolean\nreference, and the `Arg.Set_string` action which sets a string reference. Our\n`input_files` reference will of course be updated by the `anon_fun` function\nalready defined.\n\nWe can now call `Arg.parse`, giving it our specification list, anonymous\nfunction, and usage message. Once it returns, the references will be filled\nwith all the information required to append our files.\n\n\x3c!-- $MDX file=examples/append.ml,part=4 --\x3e\n```ocaml\nlet () = Arg.parse speclist anon_fun usage_msg\n\n(* Main functionality here *)\n```\n\nLet\'s save our program as `append.ml` and compile it with `ocamlopt -o append\nappend.ml` and try it out:\n\n\x3c!-- $MDX dir=examples --\x3e\n```sh\n$ ocamlopt -o append append.ml\n$ ./append -verbose one.txt two.txt -o three.txt\n$ ./append one.txt two.txt\n$ ./append -quiet\n./append: unknown option \'-quiet\'.\nappend [-verbose] <file1> [<file2>] ... -o <output>\n  -verbose Output debug information\n  -o Set output file name\n  -help  Display this list of options\n  --help  Display this list of options\n[2]\n$ ./append -help\nappend [-verbose] <file1> [<file2>] ... -o <output>\n  -verbose Output debug information\n  -o Set output file name\n  -help  Display this list of options\n  --help  Display this list of options\n```\n\nHere is the whole program:\n\n```ocaml\nlet usage_msg = "append [-verbose] <file1> [<file2>] ... -o <output>"\n\nlet verbose = ref false\n\nlet input_files = ref []\n\nlet output_file = ref ""\n\nlet anon_fun filename =\n  input_files := filename :: !input_files\n\nlet speclist =\n  [("-verbose", Arg.Set verbose, "Output debug information");\n   ("-o", Arg.Set_string output_file, "Set output file name")]\n\nlet () =\n  Arg.parse speclist anon_fun usage_msg;\n  (* Main functionality here *)\n```\n\nThe `Arg` module has many more actions than just `Set` and `Set_string`, and\nsome lower-level function for parsing more complicated command lines.\n\n## Other tools for parsing command-line options\n\nThere are libraries with facilities different from or more extensive than the\nbuilt-in `Arg` module:\n\n* [Cmdliner](https://erratique.ch/software/cmdliner/doc/Cmdliner) is a modern\n  interface for command line processing, which also generates UNIX man pages\n  automatically.\n\n* [Clap](https://opam.ocaml.org/packages/clap/) is an imperative command line\n  parser.\n\n* [Minicli](https://opam.ocaml.org/packages/minicli/) has good support for\n  rejecting malformed command lines which others might sliently accept.\n\n* [Getopt](https://opam.ocaml.org/packages/getopt/) for OCaml is similar to\n  [GNU getopt](https://www.gnu.org/software/libc/manual/html_node/Getopt.html).\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#sysargv">Sys.argv</a>\n</li>\n<li><a href="#using-the-arg-module">Using the Arg module</a>\n</li>\n<li><a href="#other-tools-for-parsing-command-line-options">Other tools for parsing command-line options</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>In this tutorial we learn how to read command line arguments directly, using\nOCaml\'s <code>Sys.argv</code> array, and then how to do so more easily using the standard\nlibrary\'s <code>Arg</code> module.</p>\n<h2 id="sysargv">Sys.argv</h2>\n<p>Like in C and many other languages, the arguments that are passed to a given\nprogram on the command line are stored in an array. Following tradition, this\narray is named <code>argv</code>. It is found in the <code>Sys</code> module of the standard library,\ntherefore its full name is <code>Sys.argv</code>. The number of arguments including the\nname of the program itself is simply the length of the array. It is obtained\nusing the <code>Array.length</code> function.</p>\n<p>The following program displays the arguments with their position in <code>Sys.argv</code>:</p>\n\x3c!-- $MDX file=examples/args.ml --\x3e\n<pre><code class="language-ocaml">let () =\n  for i = 0 to Array.length Sys.argv - 1 do\n    Printf.printf &quot;[%i] %s\\n&quot; i Sys.argv.(i)\n  done\n</code></pre>\n<p>If you save the program above as <code>args.ml</code>, and run <code>ocaml args.ml arg1 arg2 arg3</code>, here is what you get:</p>\n\x3c!-- $MDX dir=examples --\x3e\n<pre><code class="language-sh">$ ocaml args.ml arg1 arg2 arg3\n[0] args.ml\n[1] arg1\n[2] arg2\n[3] arg3\n</code></pre>\n<p>Note that <code>ocaml</code> launched a subprocess that actually runs the program where\nargv is <code>args.ml arg1 arg2 arg3</code>. You can also compile your program using\n<code>ocamlopt -o args args.ml</code>, and then running <code>./args arg1 arg2 arg3</code> and you\nwill get:</p>\n\x3c!-- $MDX dir=examples --\x3e\n<pre><code class="language-sh">$ ocamlopt -o args args.ml\n$ ./args arg1 arg2 arg3\n[0] ./args\n[1] arg1\n[2] arg2\n[3] arg3\n</code></pre>\n<h2 id="using-the-arg-module">Using the Arg module</h2>\n<p>The OCaml standard library has a module for writing command line interfaces, so\nwe do not have to use <code>Sys.argv</code> directly. We shall consider the example from\nthe OCaml documentation, a program for appending files.</p>\n<p>First, we set up the usage message to be printed in the case of a malformed\ncommand line, or when help is requested:</p>\n\x3c!-- $MDX file=examples/append.ml,part=0 --\x3e\n<pre><code class="language-ocaml">let usage_msg = &quot;append [-verbose] &lt;file1&gt; [&lt;file2&gt;] ... -o &lt;output&gt;&quot;\n</code></pre>\n<p>Now, we create some references to hold the information gathered from the\ncommand line. The <code>Arg</code> module will fill these in for us as the command line is\nread.</p>\n\x3c!-- $MDX file=examples/append.ml,part=1 --\x3e\n<pre><code class="language-ocaml">let verbose = ref false\n\nlet input_files = ref []\n\nlet output_file = ref &quot;&quot;\n</code></pre>\n<p>We have a boolean reference for the <code>-verbose</code> flag with a default value of\n<code>false</code>. Then we have a reference to a list which will hold the names of all\nthe input files. Finally, we have a string reference into which the single\noutput file name specified by <code>-o</code> will be placed.</p>\n<p>We will need a function to handle the anonymous inputs, that is to say the ones\nwith no flag before them. In this case these are our input file names. Our\nfunction simply adds the file name to the reference defined earlier.</p>\n\x3c!-- $MDX file=examples/append.ml,part=2 --\x3e\n<pre><code class="language-ocaml">let anon_fun filename = input_files := filename :: !input_files\n</code></pre>\n<p>Finally we build the list of command line flag specifcations. Each is a tuple\nof the flag name, the action to be taken when it is encountered, and the help\nstring.</p>\n\x3c!-- $MDX file=examples/append.ml,part=3 --\x3e\n<pre><code class="language-ocaml">let speclist =\n  [\n    (&quot;-verbose&quot;, Arg.Set verbose, &quot;Output debug information&quot;);\n    (&quot;-o&quot;, Arg.Set_string output_file, &quot;Set output file name&quot;);\n  ]\n</code></pre>\n<p>We have two kinds of action here: the <code>Arg.Set</code> action which sets a boolean\nreference, and the <code>Arg.Set_string</code> action which sets a string reference. Our\n<code>input_files</code> reference will of course be updated by the <code>anon_fun</code> function\nalready defined.</p>\n<p>We can now call <code>Arg.parse</code>, giving it our specification list, anonymous\nfunction, and usage message. Once it returns, the references will be filled\nwith all the information required to append our files.</p>\n\x3c!-- $MDX file=examples/append.ml,part=4 --\x3e\n<pre><code class="language-ocaml">let () = Arg.parse speclist anon_fun usage_msg\n\n(* Main functionality here *)\n</code></pre>\n<p>Let\'s save our program as <code>append.ml</code> and compile it with <code>ocamlopt -o append append.ml</code> and try it out:</p>\n\x3c!-- $MDX dir=examples --\x3e\n<pre><code class="language-sh">$ ocamlopt -o append append.ml\n$ ./append -verbose one.txt two.txt -o three.txt\n$ ./append one.txt two.txt\n$ ./append -quiet\n./append: unknown option \'-quiet\'.\nappend [-verbose] &lt;file1&gt; [&lt;file2&gt;] ... -o &lt;output&gt;\n  -verbose Output debug information\n  -o Set output file name\n  -help  Display this list of options\n  --help  Display this list of options\n[2]\n$ ./append -help\nappend [-verbose] &lt;file1&gt; [&lt;file2&gt;] ... -o &lt;output&gt;\n  -verbose Output debug information\n  -o Set output file name\n  -help  Display this list of options\n  --help  Display this list of options\n</code></pre>\n<p>Here is the whole program:</p>\n<pre><code class="language-ocaml">let usage_msg = &quot;append [-verbose] &lt;file1&gt; [&lt;file2&gt;] ... -o &lt;output&gt;&quot;\n\nlet verbose = ref false\n\nlet input_files = ref []\n\nlet output_file = ref &quot;&quot;\n\nlet anon_fun filename =\n  input_files := filename :: !input_files\n\nlet speclist =\n  [(&quot;-verbose&quot;, Arg.Set verbose, &quot;Output debug information&quot;);\n   (&quot;-o&quot;, Arg.Set_string output_file, &quot;Set output file name&quot;)]\n\nlet () =\n  Arg.parse speclist anon_fun usage_msg;\n  (* Main functionality here *)\n</code></pre>\n<p>The <code>Arg</code> module has many more actions than just <code>Set</code> and <code>Set_string</code>, and\nsome lower-level function for parsing more complicated command lines.</p>\n<h2 id="other-tools-for-parsing-command-line-options">Other tools for parsing command-line options</h2>\n<p>There are libraries with facilities different from or more extensive than the\nbuilt-in <code>Arg</code> module:</p>\n<ul>\n<li>\n<p><a href="https://erratique.ch/software/cmdliner/doc/Cmdliner">Cmdliner</a> is a modern\ninterface for command line processing, which also generates UNIX man pages\nautomatically.</p>\n</li>\n<li>\n<p><a href="https://opam.ocaml.org/packages/clap/">Clap</a> is an imperative command line\nparser.</p>\n</li>\n<li>\n<p><a href="https://opam.ocaml.org/packages/minicli/">Minicli</a> has good support for\nrejecting malformed command lines which others might sliently accept.</p>\n</li>\n<li>\n<p><a href="https://opam.ocaml.org/packages/getopt/">Getopt</a> for OCaml is similar to\n<a href="https://www.gnu.org/software/libc/manual/html_node/Getopt.html">GNU getopt</a>.</p>\n</li>\n</ul>\n'},tl:{hd:{title:"File Manipulation",slug:"file-manipulation",description:"A guide to basic file manipulation in OCaml with the standard library\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"common",tl:0},users:{hd:"Beginner",tl:{hd:"Intermediate",tl:0}},body_md:'\nThis is a guide to basic file manipulation in OCaml using only the\nstandard library.\n\n\x3c!-- TODO: links to new API locations --\x3e\nOfficial documentation for the modules of interest:\nthe core library including the initially opened module Stdlib and Printf.\n\n## Buffered channels\nThe normal way of opening a file in OCaml returns a **channel**. There\nare two kinds of channels:\n\n* channels that write to a file: type `out_channel`\n* channels that read from a file: type `in_channel`\n\n###  Writing\nFor writing into a file, you would do this:\n\n1. Open the file to obtain an `out_channel`\n1. Write to the channel\n1. If you want to force writing to the physical device, you must flush\n the channel, otherwise writing will not take place immediately.\n1. When you are done, you can close the channel. This flushes the\n channel automatically.\n\nCommonly used functions: `open_out`, `open_out_bin`, `flush`,\n`close_out`, `close_out_noerr`\n\nStandard `out_channel`s: `stdout`, `stderr`\n\n###  Reading\nFor reading data from a file you would do this:\n\n1. Open the file to obtain an `in_channel`\n1. Read characters from the channel. Reading consumes the channel, so\n if you read a character, the channel will point to the next\n character in the file.\n1. When there are no more characters to read, the `End_of_file`\n exception is raised. Often, this is where you want to close the\n channel.\n\nCommonly used functions: `open_in`, `open_in_bin`, `close_in`,\n`close_in_noerr`\n\nStandard `in_channel`: `stdin`\n\n###  Seeking\nWhenever you write or read something to or from a channel, the current\nposition changes to the next character after what you just wrote or\nread. Occasionally, you may want to skip to a particular position in the\nfile, or restart reading from the beginning. This is possible for\nchannels that point to regular files, use `seek_in` or `seek_out`.\n\n###  Gotchas\n* Don\'t forget to flush your `out_channel`s if you want to actually\n write something. This is particularly important if you are writing\n to non-files such as the standard output (`stdout`) or a socket.\n* Don\'t forget to close any unused channel, because operating systems\n have a limit on the number of files that can be opened\n simultaneously. You must catch any exception that would occur during\n the file manipulation, close the corresponding channel, and re-raise\n the exception.\n* The `Unix` module provides access to non-buffered file descriptors\n among other things. It provides standard file descriptors that have\n the same name as the corresponding standard channels: `stdin`,\n `stdout` and `stderr`. Therefore if you do `open Unix`, you may get\n type errors. If you want to be sure that you are using the `stdout`\n channel and not the `stdout` file descriptor, you can prepend it\n with the module name where it comes from: `Stdlib.stdout`. *Note\n that most things that don\'t seem to belong to any module actually\n belong to the `Stdlib` module, which is automatically opened.*\n* `open_out` and `open_out_bin` truncate the given file if it already\n exists! Use `open_out_gen` if you want an alternate behavior.\n\n###  Example\n\n\x3c!-- $MDX file=examples/file_manip.ml --\x3e\n```ocaml\nlet file = "example.dat"\n\nlet message = "Hello!"\n\nlet () =\n  (* Write message to file *)\n  let oc = open_out file in\n  (* create or truncate file, return channel *)\n  Printf.fprintf oc "%s\\n" message;\n  (* write something *)\n  close_out oc;\n\n  (* flush and close the channel *)\n\n  (* Read file and display the first line *)\n  let ic = open_in file in\n  try\n    let line = input_line ic in\n    (* read line, discard \\n *)\n    print_endline line;\n    (* write the result to stdout *)\n    flush stdout;\n    (* write on the underlying device now *)\n    close_in ic\n    (* close the input channel *)\n  with e ->\n    (* some unexpected exception occurs *)\n    close_in_noerr ic;\n    (* emergency closing *)\n    raise e\n\n(* exit with error: files are closed but channels are not flushed *)\n\n(* normal exit: all channels are flushed and closed *)\n```\n\nWe can compile and run this example: \n\n\x3c!-- $MDX dir=examples --\x3e\n```sh\n$ ocamlopt -o file_manip file_manip.ml\n$ ./file_manip\nHello!\n```\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#buffered-channels">Buffered channels</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>This is a guide to basic file manipulation in OCaml using only the\nstandard library.</p>\n\x3c!-- TODO: links to new API locations --\x3e\n<p>Official documentation for the modules of interest:\nthe core library including the initially opened module Stdlib and Printf.</p>\n<h2 id="buffered-channels">Buffered channels</h2>\n<p>The normal way of opening a file in OCaml returns a <strong>channel</strong>. There\nare two kinds of channels:</p>\n<ul>\n<li>channels that write to a file: type <code>out_channel</code>\n</li>\n<li>channels that read from a file: type <code>in_channel</code>\n</li>\n</ul>\n<h3 id="writing">Writing</h3>\n<p>For writing into a file, you would do this:</p>\n<ol>\n<li>Open the file to obtain an <code>out_channel</code>\n</li>\n<li>Write to the channel\n</li>\n<li>If you want to force writing to the physical device, you must flush\nthe channel, otherwise writing will not take place immediately.\n</li>\n<li>When you are done, you can close the channel. This flushes the\nchannel automatically.\n</li>\n</ol>\n<p>Commonly used functions: <code>open_out</code>, <code>open_out_bin</code>, <code>flush</code>,\n<code>close_out</code>, <code>close_out_noerr</code></p>\n<p>Standard <code>out_channel</code>s: <code>stdout</code>, <code>stderr</code></p>\n<h3 id="reading">Reading</h3>\n<p>For reading data from a file you would do this:</p>\n<ol>\n<li>Open the file to obtain an <code>in_channel</code>\n</li>\n<li>Read characters from the channel. Reading consumes the channel, so\nif you read a character, the channel will point to the next\ncharacter in the file.\n</li>\n<li>When there are no more characters to read, the <code>End_of_file</code>\nexception is raised. Often, this is where you want to close the\nchannel.\n</li>\n</ol>\n<p>Commonly used functions: <code>open_in</code>, <code>open_in_bin</code>, <code>close_in</code>,\n<code>close_in_noerr</code></p>\n<p>Standard <code>in_channel</code>: <code>stdin</code></p>\n<h3 id="seeking">Seeking</h3>\n<p>Whenever you write or read something to or from a channel, the current\nposition changes to the next character after what you just wrote or\nread. Occasionally, you may want to skip to a particular position in the\nfile, or restart reading from the beginning. This is possible for\nchannels that point to regular files, use <code>seek_in</code> or <code>seek_out</code>.</p>\n<h3 id="gotchas">Gotchas</h3>\n<ul>\n<li>Don\'t forget to flush your <code>out_channel</code>s if you want to actually\nwrite something. This is particularly important if you are writing\nto non-files such as the standard output (<code>stdout</code>) or a socket.\n</li>\n<li>Don\'t forget to close any unused channel, because operating systems\nhave a limit on the number of files that can be opened\nsimultaneously. You must catch any exception that would occur during\nthe file manipulation, close the corresponding channel, and re-raise\nthe exception.\n</li>\n<li>The <code>Unix</code> module provides access to non-buffered file descriptors\namong other things. It provides standard file descriptors that have\nthe same name as the corresponding standard channels: <code>stdin</code>,\n<code>stdout</code> and <code>stderr</code>. Therefore if you do <code>open Unix</code>, you may get\ntype errors. If you want to be sure that you are using the <code>stdout</code>\nchannel and not the <code>stdout</code> file descriptor, you can prepend it\nwith the module name where it comes from: <code>Stdlib.stdout</code>. <em>Note\nthat most things that don\'t seem to belong to any module actually\nbelong to the <code>Stdlib</code> module, which is automatically opened.</em>\n</li>\n<li><code>open_out</code> and <code>open_out_bin</code> truncate the given file if it already\nexists! Use <code>open_out_gen</code> if you want an alternate behavior.\n</li>\n</ul>\n<h3 id="example">Example</h3>\n\x3c!-- $MDX file=examples/file_manip.ml --\x3e\n<pre><code class="language-ocaml">let file = &quot;example.dat&quot;\n\nlet message = &quot;Hello!&quot;\n\nlet () =\n  (* Write message to file *)\n  let oc = open_out file in\n  (* create or truncate file, return channel *)\n  Printf.fprintf oc &quot;%s\\n&quot; message;\n  (* write something *)\n  close_out oc;\n\n  (* flush and close the channel *)\n\n  (* Read file and display the first line *)\n  let ic = open_in file in\n  try\n    let line = input_line ic in\n    (* read line, discard \\n *)\n    print_endline line;\n    (* write the result to stdout *)\n    flush stdout;\n    (* write on the underlying device now *)\n    close_in ic\n    (* close the input channel *)\n  with e -&gt;\n    (* some unexpected exception occurs *)\n    close_in_noerr ic;\n    (* emergency closing *)\n    raise e\n\n(* exit with error: files are closed but channels are not flushed *)\n\n(* normal exit: all channels are flushed and closed *)\n</code></pre>\n<p>We can compile and run this example:</p>\n\x3c!-- $MDX dir=examples --\x3e\n<pre><code class="language-sh">$ ocamlopt -o file_manip file_manip.ml\n$ ./file_manip\nHello!\n</code></pre>\n'},tl:{hd:{title:"Garbage Collection",slug:"garbage-collection",description:"OCaml is a garbage collected language meaning you don't have to worry about allocating and freeing memory\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"advanced",tl:0},users:{hd:"Intermediate",tl:{hd:"Advanced",tl:0}},body_md:"\n## Garbage collection, reference counting, explicit allocation\n\nAs with all modern languages, OCaml provides a garbage collector so that\nyou don't need to explicitly allocate and free memory as in C/C++.\n\nThe OCaml garbage collector is a modern hybrid generational/incremental\ncollector which outperforms hand-allocation in most cases.\n\nWhy would garbage collection be faster than explicit memory allocation\nas in C? It's often assumed that calling `free` costs nothing. In fact\n`free` is an expensive operation which involves navigating over the\ncomplex data structures used by the memory allocator. If your program\ncalls `free` intermittently, then all of that code and data needs to be\nloaded into the cache, displacing your program code and data, each time\nyou `free` a single memory allocation. A collection strategy which frees\nmultiple memory areas in one go (such as either a pool allocator or a\nGC) pays this penalty only once for multiple allocations (thus the cost\nper allocation is much reduced).\n\nGCs also move memory areas around and compact the heap. This makes\nallocation easier, hence faster, and a smart GC can be written to\ninteract well with the L1 and L2 caches.\n\nOf course none of this precludes writing a very fast hand-allocator, but\nit's considerably harder work than most programmers realise.\n\nOCaml's garbage collector has two heaps, the **minor heap** and the\n**major heap**. This recognises a general principle: Most objects are\nsmall and allocated frequently and then immediately freed. These objects\ngo into the minor heap first, which is GCed frequently. Only some\nobjects are long lasting. These objects get promoted from the minor heap\nto the major heap after some time, and the major heap is only collected\ninfrequently.\n\nThe OCaml GC is synchronous. It doesn't run in a separate thread, and it\ncan only get called during an allocation request.\n\n###  GC vs. reference counting\nPython has a form of garbage collection, but it uses a simple scheme\ncalled **reference counting**. Simply put, each Python object keeps a\ncount of the number of other objects pointing (referencing) itself. When\nthe count falls to zero, nothing is pointing at this object, and so the\nobject can be freed.\n\nReference counting is not considered as serious garbage collection by\ncomputer scientists, yet it has one big practical advantage over full\ngarbage collectors. With reference counting, you can avoid many explicit\ncalls to `close`/`closedir` in code. Whereas in OCaml\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet read_file filename =\n  let chan = open_in filename in\n  (* read from chan *) in\nList.iter read_file files\n```\n\nCalls to `read_file` open the file but don't close it. Because OCaml\nuses a full garbage collector `chan` isn't collected until some time\nlater when the minor heap becomes full. In addition, **OCaml will not\nclose the channel when it collects the handle's memory**. So this\nprogram would eventually run out of file descriptors.\n\nYou need to be aware of this when writing OCaml code which uses files or\ndirectories or any other heavyweight object with complex finalisation.\n\nTo be fair to full garbage collection, I should mention the\ndisadvantages of reference counting schemes:\n\n* Each object needs to store a reference count. In other words there's\n a word overhead for every object. Programs use more memory, and are\n consequently slower because they are more likely to fill up the\n cache or spill into swap.\n* Reference counting is expensive - every time you manipulate pointers\n to an object you need to update and check the reference count.\n Pointer manipulation is frequent, so this slows your program and\n bloats the code size of compiled code.\n* They cannot collect so-called circular, or self-referential\n structures. I've programmed in many languages in many years and\n can't recall ever having created one of these.\n* Graph algorithms, of course, violate the previous assumption.\n\n## The Gc module\nThe `Gc` module contains some useful functions for querying and calling\nthe garbage collector from OCaml programs.\n\nHere is a program which runs and then prints out GC statistics just\nbefore quitting:\n\n\x3c!-- TODO: Probably write a GC example without dependencies --\x3e\n\n\x3c!-- $MDX file=examples/gc.ml --\x3e\n```ocaml\nlet rec iterate r x_init i =\n  if i = 1 then x_init\n  else\n    let x = iterate r x_init (i - 1) in\n    r *. x *. (1.0 -. x)\n\nlet () =\n  Random.self_init ();\n  Graphics.open_graph \" 640x480\";\n  for x = 0 to 640 do\n    let r = 4.0 *. float_of_int x /. 640.0 in\n    for i = 0 to 39 do\n      let x_init = Random.float 1.0 in\n      let x_final = iterate r x_init 500 in\n      let y = int_of_float (x_final *. 480.) in\n      Graphics.plot x y\n    done\n  done;\n  Gc.print_stat stdout\n```\n\nHere is what it printed out for me:\n\n```\nminor_words: 115926165     # Total number of words allocated\npromoted_words: 31217      # Promoted from minor -> major\nmajor_words: 31902         # Large objects allocated in major directly\nminor_collections: 3538    # Number of minor heap collections\nmajor_collections: 39      # Number of major heap collections\nheap_words: 63488          # Size of the heap, in words = approx. 256K\nheap_chunks: 1\ntop_heap_words: 63488\nlive_words: 2694\nlive_blocks: 733\nfree_words: 60794\nfree_blocks: 4\nlargest_free: 31586\nfragments: 0\ncompactions: 0\n```\n\nWe can see that minor heap collections are approximately 100 times more\nfrequent than major heap collections (in this example, not necessarily\nin general). Over the lifetime of the program, an astonishing 440 MB of\nmemory was allocated, although of course most of that would have been\nimmediately freed in a minor collection. Only about 128K was promoted to\nlong-term storage on the major heap, and about another 128K consisted of\nlarge objects which would have been allocated directly onto the major\nheap.\n\nWe can instruct the GC to print out debugging messages when one of\nseveral events happen (eg. on every major collection). Try adding the\nfollowing code to the example above near the beginning:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\n# Gc.set {(Gc.get ()) with Gc.verbose = 0x01}\n```\n\n(We haven't seen the `{ expression with field = value }` form before,\nbut it should be mostly obvious what it does). The above code anyway\ncauses the GC to print a message at the start of every major collection.\n\n## Finalisation and the Weak module\nWe can write a function called a **finaliser** which is called when an\nobject is about to be freed by the GC.\n\nThe `Weak` module lets us create so-called weak pointers. A **weak\npointer** is best defined by comparing it to a \"normal pointer\". When we\nhave an ordinary OCaml object, we reference that object through a name\n(eg. `let name = ... in`) or through another object. The garbage\ncollector sees that we have a reference to that object and won't collect\nit. That's what you might call a \"normal pointer\". If, however, you hold\na weak pointer or weak reference to an object, then you hint to the\ngarbage collector that it may collect the object at any time. (Not\nnecessarily that it *will* collect the object). Some time later, when\nyou come to examine the object, you can either turn your weak pointer\ninto a normal pointer, or else you can be informed that the GC did\nactually collect the object.\n\nFinalisation and weak pointers can be used together to implement an\nin-memory object database cache. Let's imagine that we have a very large\nnumber of large user records in a file on disk. This is far too much\ndata to be loaded into memory all at once, and anyway other programs\nmight access the data on the disk, so we need to lock individual records\nwhen we hold copies of them in memory.\n\nThe *public* interface to our \"in-memory object database cache\" is going\nto be just two functions:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\ntype record = {mutable name : string; mutable address : string}\nval get_record : int -> record\nval sync_records : unit -> unit\n```\n\nThe `get_record` call is the only call that most programs will need to\nmake. It gets the n<sup>th</sup> record either out of the cache or from\ndisk and returns it. The program can then read and/or update the\n`record.name` and `record.address` fields. The program then just\nliterally forgets about the record! Behind the scenes, finalisation is\ngoing to write the record back out to disk at some later point in time.\n\nThe `sync_records` function can also be called by user programs. This\nfunction synchronises the disk copy and in-memory copies of all records.\n\nOCaml doesn't currently run finalisers at exit. However you can easily\nforce it to by adding the following command to your code. This command\ncauses a full major GC cycle on exit:\n\n\x3c!-- $MDX skip --\x3e\n```ocaml\nat_exit Gc.full_major\n```\n\nOur code is also going to implement a cache of recently accessed records\nusing the `Weak` module. The advantage of using the `Weak` module rather\nthan hand-rolling our own code is two-fold: Firstly the garbage\ncollector has a global view of memory requirements for the whole\nprogram, and so is in a better position to decide when to shrink the\ncache. Secondly our code will be much simpler.\n\nFor our example, we're going to use a very simple format for the file of\nusers' records. The file is just a list of user records, each user\nrecord having a fixed size of 256 bytes. Each user record has just two\nfields (padded with spaces if necessary), the name field (64 bytes) and\nthe address field (192 bytes). Before a record can be loaded into\nmemory, the program must acquire an exclusive lock on the record. After\nthe in-memory copy is written back out to the file, the program must\nrelease the lock. Here is some code to define the on-disk format and\nsome low-level functions to read, write, lock and unlock records:\n\n\n\x3c!-- $MDX file=examples/objcache.ml,part=0 --\x3e\n```ocaml\n(* In-memory format. *)\ntype record = { mutable name : string; mutable address : string }\n\n(* On-disk format. *)\nlet record_size = 256\n\nlet name_size = 64\n\nlet addr_size = 192\n\n(* Low-level load/save records to file. *)\nlet seek_record n fd = ignore (Unix.lseek fd (n * record_size) Unix.SEEK_SET)\n\nlet write_record record n fd =\n  seek_record n fd;\n  ignore (Unix.write fd (Bytes.of_string record.name) 0 name_size);\n  ignore (Unix.write fd (Bytes.of_string record.address) 0 addr_size)\n\nlet read_record record n fd =\n  seek_record n fd;\n  ignore (Unix.read fd (Bytes.of_string record.name) 0 name_size);\n  ignore (Unix.read fd (Bytes.of_string record.address) 0 addr_size)\n\n(* Lock/unlock the nth record in a file. *)\nlet lock_record n fd =\n  seek_record n fd;\n  Unix.lockf fd Unix.F_LOCK record_size\n\nlet unlock_record n fd =\n  seek_record n fd;\n  Unix.lockf fd Unix.F_ULOCK record_size\n```\n\nWe also need a function to create new, empty in-memory `record` objects:\n\n\x3c!-- $MDX file=examples/objcache.ml,part=1 --\x3e\n```ocaml\n(* Create a new, empty record. *)\nlet new_record () =\n  { name = String.make name_size ' '; address = String.make addr_size ' ' }\n```\n\n\nBecause this is a really simple program, we're going to fix the number\nof records in advance:\n\n\x3c!-- $MDX file=examples/objcache.ml,part=2 --\x3e\n```ocaml\n(* Total number of records. *)\nlet nr_records = 10000\n\n(* On-disk file. *)\nlet diskfile = Unix.openfile \"users.bin\" [ Unix.O_RDWR; Unix.O_CREAT ] 0o666\n```\n\nDownload [users.bin.gz](users.bin.gz) and decompress it before\nrunning the program.\n\nOur cache of records is very simple:\n\n\x3c!-- $MDX file=examples/objcache.ml,part=3 --\x3e\n```ocaml\n(* Cache of records. *)\nlet cache = Weak.create nr_records\n```\n\nThe `get_record` function is very short and basically composed of two\nhalves. We grab the record from the cache. If the cache gives us `None`,\nthen that either means that we haven't loaded this record from the cache\nyet, or else it has been written out to disk (finalised) and dropped\nfrom the cache. If the cache gives us `Some record` then we just return\n`record` (this promotes the weak pointer to the record to a normal\npointer).\n\n\n\x3c!-- $MDX file=examples/objcache.ml,part=4 --\x3e\n```ocaml\n(* The finaliser function. *)\nlet finaliser n record =\n  printf \"*** objcache: finalising record %d\\n%!\" n;\n  write_record record n diskfile;\n  unlock_record n diskfile\n\n(* Get a record from the cache or off disk. *)\nlet get_record n =\n  match Weak.get cache n with\n  | Some record ->\n      printf \"*** objcache: fetching record %d from memory cache\\n%!\" n;\n      record\n  | None ->\n      printf \"*** objcache: loading record %d from disk\\n%!\" n;\n      let record = new_record () in\n      Gc.finalise (finaliser n) record;\n      lock_record n diskfile;\n      read_record record n diskfile;\n      Weak.set cache n (Some record);\n      record\n```\n\nThe `sync_records` function is even easier. First of all it empties the\ncache by replacing all the weak pointers with `None`. This now means\nthat the garbage collector *can* collect and finalise all of those\nrecords. But it doesn't necessarily mean that the GC *will* collect the\nrecords straightaway (in fact it's not likely that it will), so to force\nthe GC to collect the records immediately, we also invoke a major cycle:\n\n\nFinally we have some test code. I won't reproduce the test code, but you\ncan download the complete program and test code\n[objcache.ml](objcache.ml), and compile it with:\n\n\x3c!-- $MDX dir=examples --\x3e\n```sh\n$ ocamlc unix.cma objcache.ml -o objcache\n```\n\n## Exercises\nHere are some ways to extend the example above, in approximately\nincreasing order of difficulty:\n\n1. Implement the record as an **object**, and allow it to transparently\n pad/unpad strings. You will need to provide methods to set and get\n the name and address fields (four public methods in all). Hide as\n much of the implementation (file access, locking) code in the class\n as possible.\n1. Extend the program so that it acquires a **read lock** on getting\n the record, but upgrades this to a **write lock** just before the\n user updates any field.\n1. Support a **variable number of records** and add a function to\n create a new record (in the file). [Tip: OCaml has support for weak\n hashtables.]\n1. Add support for **variable-length records**.\n1. Make the underlying file representation a **DBM-style hash**.\n1. Provide a general-purpose cache fronting a \"users\" table in your\n choice of **relational database** (with locking).\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#garbage-collection-reference-counting-explicit-allocation">Garbage collection, reference counting, explicit allocation</a>\n</li>\n<li><a href="#the-gc-module">The Gc module</a>\n</li>\n<li><a href="#finalisation-and-the-weak-module">Finalisation and the Weak module</a>\n</li>\n<li><a href="#exercises">Exercises</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="garbage-collection-reference-counting-explicit-allocation">Garbage collection, reference counting, explicit allocation</h2>\n<p>As with all modern languages, OCaml provides a garbage collector so that\nyou don\'t need to explicitly allocate and free memory as in C/C++.</p>\n<p>The OCaml garbage collector is a modern hybrid generational/incremental\ncollector which outperforms hand-allocation in most cases.</p>\n<p>Why would garbage collection be faster than explicit memory allocation\nas in C? It\'s often assumed that calling <code>free</code> costs nothing. In fact\n<code>free</code> is an expensive operation which involves navigating over the\ncomplex data structures used by the memory allocator. If your program\ncalls <code>free</code> intermittently, then all of that code and data needs to be\nloaded into the cache, displacing your program code and data, each time\nyou <code>free</code> a single memory allocation. A collection strategy which frees\nmultiple memory areas in one go (such as either a pool allocator or a\nGC) pays this penalty only once for multiple allocations (thus the cost\nper allocation is much reduced).</p>\n<p>GCs also move memory areas around and compact the heap. This makes\nallocation easier, hence faster, and a smart GC can be written to\ninteract well with the L1 and L2 caches.</p>\n<p>Of course none of this precludes writing a very fast hand-allocator, but\nit\'s considerably harder work than most programmers realise.</p>\n<p>OCaml\'s garbage collector has two heaps, the <strong>minor heap</strong> and the\n<strong>major heap</strong>. This recognises a general principle: Most objects are\nsmall and allocated frequently and then immediately freed. These objects\ngo into the minor heap first, which is GCed frequently. Only some\nobjects are long lasting. These objects get promoted from the minor heap\nto the major heap after some time, and the major heap is only collected\ninfrequently.</p>\n<p>The OCaml GC is synchronous. It doesn\'t run in a separate thread, and it\ncan only get called during an allocation request.</p>\n<h3 id="gc-vs-reference-counting">GC vs. reference counting</h3>\n<p>Python has a form of garbage collection, but it uses a simple scheme\ncalled <strong>reference counting</strong>. Simply put, each Python object keeps a\ncount of the number of other objects pointing (referencing) itself. When\nthe count falls to zero, nothing is pointing at this object, and so the\nobject can be freed.</p>\n<p>Reference counting is not considered as serious garbage collection by\ncomputer scientists, yet it has one big practical advantage over full\ngarbage collectors. With reference counting, you can avoid many explicit\ncalls to <code>close</code>/<code>closedir</code> in code. Whereas in OCaml</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let read_file filename =\n  let chan = open_in filename in\n  (* read from chan *) in\nList.iter read_file files\n</code></pre>\n<p>Calls to <code>read_file</code> open the file but don\'t close it. Because OCaml\nuses a full garbage collector <code>chan</code> isn\'t collected until some time\nlater when the minor heap becomes full. In addition, <strong>OCaml will not\nclose the channel when it collects the handle\'s memory</strong>. So this\nprogram would eventually run out of file descriptors.</p>\n<p>You need to be aware of this when writing OCaml code which uses files or\ndirectories or any other heavyweight object with complex finalisation.</p>\n<p>To be fair to full garbage collection, I should mention the\ndisadvantages of reference counting schemes:</p>\n<ul>\n<li>Each object needs to store a reference count. In other words there\'s\na word overhead for every object. Programs use more memory, and are\nconsequently slower because they are more likely to fill up the\ncache or spill into swap.\n</li>\n<li>Reference counting is expensive - every time you manipulate pointers\nto an object you need to update and check the reference count.\nPointer manipulation is frequent, so this slows your program and\nbloats the code size of compiled code.\n</li>\n<li>They cannot collect so-called circular, or self-referential\nstructures. I\'ve programmed in many languages in many years and\ncan\'t recall ever having created one of these.\n</li>\n<li>Graph algorithms, of course, violate the previous assumption.\n</li>\n</ul>\n<h2 id="the-gc-module">The Gc module</h2>\n<p>The <code>Gc</code> module contains some useful functions for querying and calling\nthe garbage collector from OCaml programs.</p>\n<p>Here is a program which runs and then prints out GC statistics just\nbefore quitting:</p>\n\x3c!-- TODO: Probably write a GC example without dependencies --\x3e\n\x3c!-- $MDX file=examples/gc.ml --\x3e\n<pre><code class="language-ocaml">let rec iterate r x_init i =\n  if i = 1 then x_init\n  else\n    let x = iterate r x_init (i - 1) in\n    r *. x *. (1.0 -. x)\n\nlet () =\n  Random.self_init ();\n  Graphics.open_graph &quot; 640x480&quot;;\n  for x = 0 to 640 do\n    let r = 4.0 *. float_of_int x /. 640.0 in\n    for i = 0 to 39 do\n      let x_init = Random.float 1.0 in\n      let x_final = iterate r x_init 500 in\n      let y = int_of_float (x_final *. 480.) in\n      Graphics.plot x y\n    done\n  done;\n  Gc.print_stat stdout\n</code></pre>\n<p>Here is what it printed out for me:</p>\n<pre><code>minor_words: 115926165     # Total number of words allocated\npromoted_words: 31217      # Promoted from minor -&gt; major\nmajor_words: 31902         # Large objects allocated in major directly\nminor_collections: 3538    # Number of minor heap collections\nmajor_collections: 39      # Number of major heap collections\nheap_words: 63488          # Size of the heap, in words = approx. 256K\nheap_chunks: 1\ntop_heap_words: 63488\nlive_words: 2694\nlive_blocks: 733\nfree_words: 60794\nfree_blocks: 4\nlargest_free: 31586\nfragments: 0\ncompactions: 0\n</code></pre>\n<p>We can see that minor heap collections are approximately 100 times more\nfrequent than major heap collections (in this example, not necessarily\nin general). Over the lifetime of the program, an astonishing 440 MB of\nmemory was allocated, although of course most of that would have been\nimmediately freed in a minor collection. Only about 128K was promoted to\nlong-term storage on the major heap, and about another 128K consisted of\nlarge objects which would have been allocated directly onto the major\nheap.</p>\n<p>We can instruct the GC to print out debugging messages when one of\nseveral events happen (eg. on every major collection). Try adding the\nfollowing code to the example above near the beginning:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml"># Gc.set {(Gc.get ()) with Gc.verbose = 0x01}\n</code></pre>\n<p>(We haven\'t seen the <code>{ expression with field = value }</code> form before,\nbut it should be mostly obvious what it does). The above code anyway\ncauses the GC to print a message at the start of every major collection.</p>\n<h2 id="finalisation-and-the-weak-module">Finalisation and the Weak module</h2>\n<p>We can write a function called a <strong>finaliser</strong> which is called when an\nobject is about to be freed by the GC.</p>\n<p>The <code>Weak</code> module lets us create so-called weak pointers. A <strong>weak\npointer</strong> is best defined by comparing it to a &quot;normal pointer&quot;. When we\nhave an ordinary OCaml object, we reference that object through a name\n(eg. <code>let name = ... in</code>) or through another object. The garbage\ncollector sees that we have a reference to that object and won\'t collect\nit. That\'s what you might call a &quot;normal pointer&quot;. If, however, you hold\na weak pointer or weak reference to an object, then you hint to the\ngarbage collector that it may collect the object at any time. (Not\nnecessarily that it <em>will</em> collect the object). Some time later, when\nyou come to examine the object, you can either turn your weak pointer\ninto a normal pointer, or else you can be informed that the GC did\nactually collect the object.</p>\n<p>Finalisation and weak pointers can be used together to implement an\nin-memory object database cache. Let\'s imagine that we have a very large\nnumber of large user records in a file on disk. This is far too much\ndata to be loaded into memory all at once, and anyway other programs\nmight access the data on the disk, so we need to lock individual records\nwhen we hold copies of them in memory.</p>\n<p>The <em>public</em> interface to our &quot;in-memory object database cache&quot; is going\nto be just two functions:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">type record = {mutable name : string; mutable address : string}\nval get_record : int -&gt; record\nval sync_records : unit -&gt; unit\n</code></pre>\n<p>The <code>get_record</code> call is the only call that most programs will need to\nmake. It gets the n<sup>th</sup> record either out of the cache or from\ndisk and returns it. The program can then read and/or update the\n<code>record.name</code> and <code>record.address</code> fields. The program then just\nliterally forgets about the record! Behind the scenes, finalisation is\ngoing to write the record back out to disk at some later point in time.</p>\n<p>The <code>sync_records</code> function can also be called by user programs. This\nfunction synchronises the disk copy and in-memory copies of all records.</p>\n<p>OCaml doesn\'t currently run finalisers at exit. However you can easily\nforce it to by adding the following command to your code. This command\ncauses a full major GC cycle on exit:</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">at_exit Gc.full_major\n</code></pre>\n<p>Our code is also going to implement a cache of recently accessed records\nusing the <code>Weak</code> module. The advantage of using the <code>Weak</code> module rather\nthan hand-rolling our own code is two-fold: Firstly the garbage\ncollector has a global view of memory requirements for the whole\nprogram, and so is in a better position to decide when to shrink the\ncache. Secondly our code will be much simpler.</p>\n<p>For our example, we\'re going to use a very simple format for the file of\nusers\' records. The file is just a list of user records, each user\nrecord having a fixed size of 256 bytes. Each user record has just two\nfields (padded with spaces if necessary), the name field (64 bytes) and\nthe address field (192 bytes). Before a record can be loaded into\nmemory, the program must acquire an exclusive lock on the record. After\nthe in-memory copy is written back out to the file, the program must\nrelease the lock. Here is some code to define the on-disk format and\nsome low-level functions to read, write, lock and unlock records:</p>\n\x3c!-- $MDX file=examples/objcache.ml,part=0 --\x3e\n<pre><code class="language-ocaml">(* In-memory format. *)\ntype record = { mutable name : string; mutable address : string }\n\n(* On-disk format. *)\nlet record_size = 256\n\nlet name_size = 64\n\nlet addr_size = 192\n\n(* Low-level load/save records to file. *)\nlet seek_record n fd = ignore (Unix.lseek fd (n * record_size) Unix.SEEK_SET)\n\nlet write_record record n fd =\n  seek_record n fd;\n  ignore (Unix.write fd (Bytes.of_string record.name) 0 name_size);\n  ignore (Unix.write fd (Bytes.of_string record.address) 0 addr_size)\n\nlet read_record record n fd =\n  seek_record n fd;\n  ignore (Unix.read fd (Bytes.of_string record.name) 0 name_size);\n  ignore (Unix.read fd (Bytes.of_string record.address) 0 addr_size)\n\n(* Lock/unlock the nth record in a file. *)\nlet lock_record n fd =\n  seek_record n fd;\n  Unix.lockf fd Unix.F_LOCK record_size\n\nlet unlock_record n fd =\n  seek_record n fd;\n  Unix.lockf fd Unix.F_ULOCK record_size\n</code></pre>\n<p>We also need a function to create new, empty in-memory <code>record</code> objects:</p>\n\x3c!-- $MDX file=examples/objcache.ml,part=1 --\x3e\n<pre><code class="language-ocaml">(* Create a new, empty record. *)\nlet new_record () =\n  { name = String.make name_size \' \'; address = String.make addr_size \' \' }\n</code></pre>\n<p>Because this is a really simple program, we\'re going to fix the number\nof records in advance:</p>\n\x3c!-- $MDX file=examples/objcache.ml,part=2 --\x3e\n<pre><code class="language-ocaml">(* Total number of records. *)\nlet nr_records = 10000\n\n(* On-disk file. *)\nlet diskfile = Unix.openfile &quot;users.bin&quot; [ Unix.O_RDWR; Unix.O_CREAT ] 0o666\n</code></pre>\n<p>Download <a href="users.bin.gz">users.bin.gz</a> and decompress it before\nrunning the program.</p>\n<p>Our cache of records is very simple:</p>\n\x3c!-- $MDX file=examples/objcache.ml,part=3 --\x3e\n<pre><code class="language-ocaml">(* Cache of records. *)\nlet cache = Weak.create nr_records\n</code></pre>\n<p>The <code>get_record</code> function is very short and basically composed of two\nhalves. We grab the record from the cache. If the cache gives us <code>None</code>,\nthen that either means that we haven\'t loaded this record from the cache\nyet, or else it has been written out to disk (finalised) and dropped\nfrom the cache. If the cache gives us <code>Some record</code> then we just return\n<code>record</code> (this promotes the weak pointer to the record to a normal\npointer).</p>\n\x3c!-- $MDX file=examples/objcache.ml,part=4 --\x3e\n<pre><code class="language-ocaml">(* The finaliser function. *)\nlet finaliser n record =\n  printf &quot;*** objcache: finalising record %d\\n%!&quot; n;\n  write_record record n diskfile;\n  unlock_record n diskfile\n\n(* Get a record from the cache or off disk. *)\nlet get_record n =\n  match Weak.get cache n with\n  | Some record -&gt;\n      printf &quot;*** objcache: fetching record %d from memory cache\\n%!&quot; n;\n      record\n  | None -&gt;\n      printf &quot;*** objcache: loading record %d from disk\\n%!&quot; n;\n      let record = new_record () in\n      Gc.finalise (finaliser n) record;\n      lock_record n diskfile;\n      read_record record n diskfile;\n      Weak.set cache n (Some record);\n      record\n</code></pre>\n<p>The <code>sync_records</code> function is even easier. First of all it empties the\ncache by replacing all the weak pointers with <code>None</code>. This now means\nthat the garbage collector <em>can</em> collect and finalise all of those\nrecords. But it doesn\'t necessarily mean that the GC <em>will</em> collect the\nrecords straightaway (in fact it\'s not likely that it will), so to force\nthe GC to collect the records immediately, we also invoke a major cycle:</p>\n<p>Finally we have some test code. I won\'t reproduce the test code, but you\ncan download the complete program and test code\n<a href="objcache.ml">objcache.ml</a>, and compile it with:</p>\n\x3c!-- $MDX dir=examples --\x3e\n<pre><code class="language-sh">$ ocamlc unix.cma objcache.ml -o objcache\n</code></pre>\n<h2 id="exercises">Exercises</h2>\n<p>Here are some ways to extend the example above, in approximately\nincreasing order of difficulty:</p>\n<ol>\n<li>Implement the record as an <strong>object</strong>, and allow it to transparently\npad/unpad strings. You will need to provide methods to set and get\nthe name and address fields (four public methods in all). Hide as\nmuch of the implementation (file access, locking) code in the class\nas possible.\n</li>\n<li>Extend the program so that it acquires a <strong>read lock</strong> on getting\nthe record, but upgrades this to a <strong>write lock</strong> just before the\nuser updates any field.\n</li>\n<li>Support a <strong>variable number of records</strong> and add a function to\ncreate a new record (in the file). [Tip: OCaml has support for weak\nhashtables.]\n</li>\n<li>Add support for <strong>variable-length records</strong>.\n</li>\n<li>Make the underlying file representation a <strong>DBM-style hash</strong>.\n</li>\n<li>Provide a general-purpose cache fronting a &quot;users&quot; table in your\nchoice of <strong>relational database</strong> (with locking).\n</li>\n</ol>\n'},tl:{hd:{title:"Performance and Profiling",slug:"performance-and-profiling",description:"Understand how to profile your OCaml code to analyse its performance and produce faster programs\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"advanced",tl:0},users:{hd:"Intermediate",tl:{hd:"Advanced",tl:0}},body_md:"\n## Speed\nWhy is OCaml fast? Indeed, step back and ask *is OCaml fast?* How can we\nmake programs faster? In this chapter we'll look at what actually\nhappens when you compile your OCaml programs down to machine code. This\nwill help in understanding why OCaml is not just a great language for\nprogramming, but is also a very fast language indeed. And it'll help you\nto help the compiler write better machine code for you. It's also (I\nbelieve anyway) a good thing for programmers to have some idea of what\nhappens between you typing `ocamlopt` and getting a binary you can run.\n\nBut you will need to know some assembler to get the most out of this\nsection. Don't be afraid! I'll help you out by translating the assembler\ninto a C-like pseudocode (after all C is just a portable assembly\nlanguage).\n\n###  Basics of assembly language\nThe examples I give in this chapter are all compiled on an x86 Linux\nmachine. The x86 is, of course, a 32 bit machine, so an x86 \"word\" is 4\nbytes (= 32 bits) long. At this level OCaml deals mostly with word-sized\nobjects, so you'll need to remember to multiply by four to get the size\nin bytes.\n\nTo refresh your memory, the x86 has only a small number of general\npurpose registers, each of which can store one word. The Linux assembler\nputs `%` in front of register names. The registers are: `%eax`, `%ebx`,\n`%ecx`, `%edx`, `%esi`, `%edi`, `%ebp` (special register used for stack\nframes), and `%esp` (the stack pointer).\n\nThe Linux assembler (in common with other Unix assemblers, but opposite\nto MS-derived assemblers) writes moves to and from registers/memory as:\n\n```assembly\nmovl from, to\n```\n\nSo `movl %ebx, %eax` means \"copy the contents of register `%ebx` into\nregister `%eax`\" (not the other way round).\n\nAlmost all of the assembly language that we will look at is going to be\ndominated not by machine code instructions like `movl` but by what are\nknown as **assembler directives**. These directives begin\nwith a . (period) and they literally *direct* the assembler to do\nsomething. Here are the common ones for the Linux assembler:\n\n#### .text\n\n**Text** is the Unix way of saying \"program code\". The **text segment**\nsimply means the part of the executable where program code is stored.\nThe `.text` directive switches the assembler so it starts writing into\nthe text segment.\n\n#### .data\n\nSimilarly, the `.data` directive switches the assembler so it starts\nwriting into the data segment (part) of the executable.\n\n```assembly\n  .globl foo\nfoo:\n```\nThis declares a global symbol called `foo`. It means the address of the\nnext thing to come can be named `foo`. Writing just `foo:` without the\npreceding `.globl` directive declares a local symbol (local to just the\ncurrent file).\n\n```assembly\n.long 12345\n.byte 9\n.ascii \"hello\"\n.space 4\n```\n`.long` writes a word (4 bytes) to the current segment. `.byte` writes a\nsingle byte. `.ascii` writes a string of bytes (NOT nul-terminated).\n`.space` writes the given number of zero bytes. Normally you use these\nin the data segment.\n\n###  The \"hello, world\" program\nEnough assembler. Put the following program into a file called\n`smallest.ml`:\n\n```ocaml\nprint_string \"hello, world\\n\"\n```\nAnd compile it to a native code executable using:\n\n```shell\nocamlopt -S smallest.ml -o smallest\n```\n\nThe `-S` (capital S) tells the compiler to leave the assembly language\nfile (called `smallest.s` - lowercase s) instead of deleting it.\n\nHere are the edited highlights of the `smallest.s` file with my comments\nadded. First of all the data segment:\n\n```assembly\n    .data\n    .long   4348                     ; header for string\n    .globl  Smallest__1\nlest__1:\n    .ascii  \"hello, world\\12\"        ; string\n    .space  2                        ; padding ..\n    .byte   2                        ;  .. after string\n```\nNext up the text (program code) segment:\n\n```assembly\n    .text\n    .globl  Smallest__entry          ; entry point to the program\nlest__entry:\n\n    ; this is equivalent to the C pseudo-code:\n    ; Pervasives.output_string (stdout, &Smallest__1)\n\n    movl    $Smallest__1, %ebx\n    movl    Pervasives + 92, %eax    ; Pervasives + 92 == stdout\n    call    Pervasives__output_string_212\n\n    ; return 1\n\n    movl    $1, %eax\n    ret\n```\n\nIn C everything has to be inside a function. Think about how you can't\njust write `printf (\"hello, world\\n\");` in C, but instead you have to\nput it inside `main () { ... }`. In OCaml you are allowed to have\ncommands at the top level, not inside a function. But when we translate\nthis into assembly language, where do we put those commands? There needs\nto be some way to call those commands from outside, so they need to be\nlabelled in some way. As you can see from the code snippet, OCaml solves\nthis by taking the filename (`smallest.ml`), capitalizing it and adding\n`__entry`, thus making up a symbol called `Smallest__entry` to refer to\nthe top level commands in this file.\n\nNow look at the code that OCaml has generated. The original code said\n`print_string \"hello, world\\n\"`, but OCaml has instead compiled the\nequivalent of `Pervasives.output_string stdout \"hello, world\\n\"`. Why?\nIf you look into `pervasives.ml` you'll see why:\n\n```ocaml\nlet print_string s = output_string stdout s\n```\n\nOCaml has *inlined* this function. **Inlining** - taking a function and\nexpanding it from its definition - is sometimes a performance win,\nbecause it avoids the overhead of an extra function call, and it can\nlead to more opportunities for the optimizer to do its thing. Sometimes\ninlining is not good, because it can lead to code bloating, and thus\ndestroys the good work done by the processor cache (and besides function\ncalls are actually not very expensive at all on modern processors).\nOCaml will inline simple calls like this, because they are essentially\nrisk free, almost always leading to a small performance gain.\n\nWhat else can we notice about this? The calling convention seems to be\nthat the first two arguments are passed in the `%eax` and `%ebx`\nregisters respectively. Other arguments are probably passed on the\nstack, but we'll see about that later.\n\nC programs have a simple convention for storing strings, known as\n**ASCIIZ**. This just means that the string is stored in ASCII, followed\nby a trailing NUL (`\\0`) character. OCaml stores strings in a different\nway, as we can see from the data segment above. This string is stored\nlike this:\n\n```\n4 byte header: 4348\nthe string:    h e l l o , SP w o r l d \\n\npadding:       \\0 \\0 \\002\n```\n\nFirstly the padding brings the total length of the string up to a whole\nnumber of words (4 words, 16 bytes in this example). The padding is\ncarefully designed so that you can work out the actual length of the\nstring in bytes, provided that you know the total number of *words*\nallocated to the string. The encoding for this is unambiguous (which you\ncan prove to yourself).\n\nOne nice feature of having strings with an explicit length is that you\ncan represent strings containing ASCII NUL (`\\0`) characters in them,\nsomething which is difficult to do in C. However, the flip side is that\nyou need to be aware of this if you pass an OCaml string to some C\nnative code: if it contains ASCII NUL, then the C `str*` functions will\nfail on it.\n\nSecondly we have the header. Every boxed (allocated) object in OCaml has\na header which tells the garbage collector about how large the object is\nin words, and something about what the object contains. Writing the\nnumber 4348 in binary:\n\n```\nlength of the object in words:  0000 0000 0000 0000 0001 00 (4 words)\ncolor (used by GC):             00\ntag:                            1111 1100 (String_tag)\n```\nSee `/usr/include/caml/mlvalues.h` for more information about\nthe format of heap allocated objects in OCaml.\n\nOne unusual thing is that the code passes a pointer to the start of the\nstring (ie. the word immediately after the header) to\n`Pervasives.output_string`. This means that `output_string` must\nsubtract 4 from the pointer to get at the header to determine the length\nof the string.\n\nWhat have I missed out from this simple example? Well, the text segment\nabove is not the whole story. It would be really nice if OCaml\ntranslated that simple hello world program into just the five lines of\nassembler shown above. But there is the question of what actually calls\n`Smallest__entry` in the real program. For this OCaml includes a whole\nload of bootstrapping code which does things like starting up the\ngarbage collector, allocating and initializing memory, calling\ninitializers in libraries and so on. OCaml links all of this code\nstatically to the final executable, which is why the program I end up\nwith (on Linux) weighs in at a portly 95,442 bytes. Nevertheless the\nstart-up time for the program is still unmeasurably small (under a\nmillisecond), compared to several seconds for starting up a reasonable\nJava program and a second or so for a Perl script.\n\n###  Tail recursion\nWe mentioned in chapter 6 that OCaml can turn tail-recursive function\ncalls into simple loops. Is this actually true? Let's look at what\nsimple tail recursion compiles to:\n\n\x3c!-- do not execute this code!! --\x3e\n\x3c!-- $MDX skip --\x3e\n```ocaml\nlet rec loop () =\n  print_string \"I go on forever ...\";\n  loop ()\n  \nlet () = loop ()\n```\n\nThe file is called `tail.ml`, so following OCaml's usual procedure for\nnaming functions, our function will be called `Tail__loop_nnn` (where\n`nnn` is some unique number which OCaml appends to distinguish\nidentically named functions from one another).\n\nHere is the assembler for just the `loop` function defined above:\n\n```assembly\n        .text\n        .globl  Tail__loop_56\nTail__loop_56:\n.L100:\n        ; Print the string\n        movl    $Tail__2, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n.L101:\n        ; The following movl is in fact obsolete:\n        movl    $1, %eax\n        ; Jump back to the .L100 label above (ie. loop forever)\n        jmp     .L100\n```\n\nSo that's pretty conclusive. Calling `Tail__loop_56` will first print\nthe string, and then jump back to the top, then print the string, and\njump back, and so on forever. It's a simple loop, *not* a recursive\nfunction call, so it doesn't use any stack space.\n\n###  Digression: Where are the types?\nOCaml is statically typed as we've said before on many occasions, so at\ncompile time, OCaml knows that the type of `loop` is `unit -> unit`. It\nknows that the type of `\"hello, world\\n\"` is `string`. It doesn't make\nany attempt to communicate this fact to the `output_string` function.\n`output_string` is expecting a `channel` and a `string` as arguments,\nand indeed that's what it gets. What would happen if we passed, say, an\n`int` instead of a `string`?\n\nThis is essentially an impossible condition. Because OCaml knows the\ntypes at compile time, it doesn't need to deal with types or check types\nat run time. There is no way, in pure OCaml, to \"trick\" the compiler\ninto generating a call to `Pervasives.output_string stdout 1`. Such an\nerror would be flagged at compile time, by type inference, and so could\nnever be compiled.\n\nThe upshot is that by the time we have compiled OCaml code to assembler\ntype information mostly isn't required, certainly in the cases we've\nlooked at above where the type is fully known at compile time, and there\nis no polymorphism going on.\n\nFully knowing all your types at compile time is a major performance win\nbecause it totally avoids any dynamic type checking at run time. Compare\nthis to a Java method invocation for example: `obj.method ()`. This is\nan expensive operation because you need to find the concrete class that\n`obj` is an instance of, and then look up the method, and you need to do\nall of this potentially *every* time you call any method. Casting\nobjects is another case where you need to do a considerable amount of\nwork at run time in Java. None of this is allowed with OCaml's static\ntypes.\n\n###  Polymorphic types\nAs you might have guessed from the discussion above, polymorphism, which\nis where the compiler *doesn't* have a fully known type for a function\nat compile time, might have an impact on performance. Suppose we require\na function to work out the maximum of two integers. Our first attempt\nis:\n\n```ocaml\n# let max a b =\n  if a > b then a else b\nval max : 'a -> 'a -> 'a = <fun>\n```\n\nSimple enough, but recall that the \\> (greater than) operator in OCaml\nis polymorphic. It has type `'a -> 'a -> bool`, and this means that the\n`max` function we defined above is going to be polymorphic:\n\n```ocaml\n# let max a b =\n  if a > b then a else b\nval max : 'a -> 'a -> 'a = <fun>\n```\n\nThis is indeed reflected in the code that OCaml generates for this\nfunction, which is pretty complex:\n\n```assembly\n        .text\n        .globl  Max__max_56\nMax__max_56:\n\n        ; Reserve two words of stack space.\n\n        subl    $8, %esp\n\n        ; Save the first and second arguments (a and b) on the stack.\n\n        movl    %eax, 4(%esp)\n        movl    %ebx, 0(%esp)\n\n        ; Call the C \"greaterthan\" function (in the OCaml library).\n\n        pushl   %ebx\n        pushl   %eax\n        movl    $greaterthan, %eax\n        call    caml_c_call\n.L102:\n        addl    $8, %esp\n\n        ; If the C \"greaterthan\" function returned 1, jump to .L100\n\n        cmpl    $1, %eax\n        je      .L100\n\n        ; Returned 0, so get argument a which we previously saved on\n        ; the stack and return it.\n\n        movl    4(%esp), %eax\n        addl    $8, %esp\n        ret\n\n        ; Returned 1, so get argument b which we previously saved on\n        ; the stack and return it.\n\n.L100:\n        movl    0(%esp), %eax\n        addl    $8, %esp\n        ret\n```\n\nBasically the \\> operation is done by calling a C function from the\nOCaml library. This is obviously not going to be very efficient, nothing\nlike as efficient as if we could generate some quick inline assembly\nlanguage for doing the \\>.\n\nThis is not a complete dead loss by any means. All we need to do is to\nhint to the OCaml compiler that the arguments are in fact integers. Then\nOCaml will generate a specialised version of `max` which only works on\n`int` arguments:\n\n```ocaml\n# let max (a : int) (b : int) =\n  if a > b then a else b\nval max : int -> int -> int = <fun>\n```\nHere is the assembly code generated for this function:\n\n```assembly\n        .text\n        .globl  Max_int__max_56\nMax_int__max_56:\n\n        ; Single assembly instruction \"cmpl\" for performing the > op.\n        cmpl    %ebx, %eax\n\n        ; If %ebx > %eax, jump to .L100\n        jle     .L100\n        ; Just return argument a.\n        ret\n        ; Return argument b.\n\n.L100:\n        movl    %ebx, %eax\n        ret\n```\nThat's just 5 lines of assembler, and is about as simple as you can make\nit.\n\nWhat about this code:\n\n```ocaml\n# let max a b =\n  if a > b then a else b\nval max : 'a -> 'a -> 'a = <fun>\n# let () = print_int (max 2 3)\n3\n```\n\nIs OCaml going to be smart enough to inline the `max` function and\nspecialise it to work on integers? Disappointingly the answer is no.\nOCaml still has to generate the external `Max.max` symbol (because this\nis a module, and so that function might be called from outside the\nmodule), and it doesn't inline the function.\n\nHere's another variation:\n\n```ocaml\n# let max a b =\n  if a > b then a else b in\n  print_int (max 2 3)\n3\n- : unit = ()\n```\n\nDisappointingly although the definition of `max` in this code is local\n(it can't be called from outside the module), OCaml still doesn't\nspecialise the function.\n\nLesson: if you have a function which is unintentionally polymorphic then\nyou can help the compiler by specifying types for one or more of the\narguments.\n\n###  The representation of integers, tag bits, heap-allocated values\nThere are a number of peculiarities about integers in OCaml. One of\nthese is that integers are 31 bit entities, not 32 bit entities. What\nhappens to the \"missing\" bit?\n\nWrite this to `int.ml`:\n\n```ocaml\nprint_int 3\n```\n\nand compile with `ocamlopt -S int.ml -o int` to generate assembly\nlanguage in `int.s`. Recall from the discussion above that we are\nexpecting OCaml to inline the `print_int` function as\n`output_string (string_of_int 3)`, and examining the assembly language\noutput we can see that this is exactly what OCaml does:\n\n```assembly\n        .text\n        .globl  Int__entry\nInt__entry:\n\n        ; Call Pervasives.string_of_int (3)\n\n        movl    $7, %eax\n        call    Pervasives__string_of_int_152\n\n        ; Call Pervasives.output_string (stdout, result_of_previous)\n\n        movl    %eax, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n```\n\nThe important code is shown in red. It shows two things: Firstly the\ninteger is unboxed (not allocated on the heap), but is instead passed\ndirectly to the function in the register `%eax`. This is fast. But\nsecondly we see that the number being passed is 7, not 3.\n\nThis is a consequence of the representation of integers in OCaml. The\nbottom bit of the integer is used as a tag - we'll see what for next.\nThe top 31 bits are the actual integer. The binary representation of 7\nis 111, so the bottom tag bit is 1 and the top 31 bits form the number\n11 in binary = 3. To get from the OCaml representation to the integer,\ndivide by two and round down.\n\nWhy the tag bit at all? This bit is used to distinguish between integers\nand pointers to structures on the heap, and the distinction is only\nnecessary if we are calling a polymorphic function. In the case above,\nwhere we are calling `string_of_int`, the argument can only ever be an\n`int` and so the tag bit would never be consulted. Nevertheless, to\navoid having two internal representations for integers, all integers in\nOCaml carry around the tag bit.\n\nA bit of background about pointers is required to understand why the tag\nbit is really necessary, and why it is where it is.\n\nIn the world of RISC chips like the Sparc, MIPS and Alpha, pointers have\nto be word-aligned. So on the older 32 bit Sparc, for example, it's not\npossible to create and use a pointer which isn't aligned to a multiple\nof 4 (bytes). Trying to use one generates a processor exception, which\nmeans basically your program segfaults. The reason for this is just to\nsimplify memory access. It's just a lot simpler to design the memory\nsubsystem of a CPU if you only need to worry about word-aligned access.\n\nFor historical reasons (because the x86 is derived from an 8 bit chip),\nthe x86 has supported unaligned memory access, although if you align all\nmemory accesses to multiples of 4, then things go faster.\n\nNevertheless, all pointers in OCaml are aligned - ie. multiples of 4 for\n32 bit processors, and multiples of 8 for 64 bit processors. This means\nthat the bottom bit of any pointer in OCaml will always be zero.\n\nSo you can see that by looking at the bottom bit of a register, you can\nimmediately tell if it stores a pointer (\"tag\" bit is zero), or an\ninteger (tag bit set to one).\n\nRemember our polymorphic \\> function which caused us so much trouble in\nthe previous section? We looked at the assembler and found out that\nOCaml compiles a call to a C function called `greaterthan` whenever it\nsees the polymorphic form of \\>. This function takes two arguments, in\nregisters `%eax` and `%ebx`. But `greaterthan` can be called with\nintegers, floats, strings, opaque objects ... How does it know what\n`%eax` and `%ebx` point to?\n\nIt uses the following decision tree:\n\n* **Tag bit is one:** compare the two integers and return.\n* **Tag bit is zero:** `%eax` and `%ebx` must point at two\n heap-allocated memory blocks. Look at the header word of the memory\n blocks, specifically the bottom 8 bits of the header word, which tag\n the content of the block.\n     * **String_tag:** Compare two strings.\n     * **Double_tag:** Compare two floats.\n     * etc.\n\nNote that because \\> has type `'a -> 'a -> bool`, both arguments must\nhave the same type. The compiler should enforce this at compile time. I\nwould assume that `greaterthan` probably contains code to sanity-check\nthis at run time however.\n\n###  Floats\nFloats are, by default, boxed (allocated on the heap). Save this as\n`float.ml` and compile it with `ocamlopt -S float.ml -o float`:\n\n```ocamltop\nprint_float 3.0\n```\nThe number is not passed directly to `string_of_float` in the `%eax`\nregister as happened above with ints. Instead, it is created statically\nin the data segment:\n\n```assembly\n        .data\n        .long   2301\n        .globl  Float__1\nFloat__1:\n        .double 3.0\n```\nand a pointer to the float is passed in `%eax` instead:\n\n```assembly\n        movl    $Float__1, %eax\n        call    Pervasives__string_of_float_157\n```\nNote the structure of the floating point number: it has a header (2301),\nfollowed by the 8 byte (2 word) representation of the number itself. The\nheader can be decoded by writing it as binary:\n\n```\nLength of the object in words:  0000 0000 0000 0000 0000 10 (8 bytes)\nColor:                          00\nTag:                            1111 1101 (Double_tag)\n```\n`string_of_float` isn't polymorphic, but suppose we have a polymorphic\nfunction `foo : 'a -> unit` taking one polymorphic argument. If we call\n`foo` with `%eax` containing 7, then this is equivalent to `foo 3`,\nwhereas if we call `foo` with `%eax` containing a pointer to `Float__1`\nabove, then this is equivalent to `foo 3.0`.\n\n###  Arrays\nI mentioned earlier that one of OCaml's targets was numerical computing.\nNumerical computing does a lot of work on vectors and matrices, which\nare essentially arrays of floats. As a special hack to make this go\nfaster, OCaml implements **arrays of unboxed floats**. This\nmeans that in the special case where we have an object of type\n`float array` (array of floats), OCaml stores them the same way as in C:\n\n```C\ndouble array[10];\n```\n... instead of having an array of pointers to ten separately allocated\nfloats on the heap.\n\nLet's see this in practice:\n\n```ocaml\nlet a = Array.create 10 0.0;;\nfor i = 0 to 9 do\n  a.(i) <- float_of_int i\ndone\n```\n\nI'm going to compile this code with the `-unsafe` option to remove\nbounds checking (simplifying the code for our exposition here). The\nfirst line, which creates the array, is compiled to a simple C call:\n\n```assembly\n        pushl   $Arrayfloats__1     ; Boxed float 0.0\n        pushl   $21                 ; The integer 10\n        movl    $make_vect, %eax    ; Address of the C function to call\n        call    caml_c_call\n    ; ...\n        movl    %eax, Arrayfloats   ; Store the resulting pointer to the\n                                    ; array at this place on the heap.\n```\nThe loop is compiled to this relatively simple assembly language:\n\n```assembly\n        movl    $1, %eax            ; Let %eax = 0. %eax is going to store i.\n        cmpl    $19, %eax           ; If %eax > 9, then jump out of the\n        jg      .L100               ;   loop (to label .L100 at the end).\n\n.L101:                              ; This is the start of the loop body.\n        movl    Arrayfloats, %ecx   ; Address of the array to %ecx.\n\n        movl    %eax, %ebx          ; Copy i to %ebx.\n        sarl    $1, %ebx            ; Remove the tag bit from %ebx by\n                                    ;   shifting it right 1 place. So %ebx\n                                    ;   now contains the real integer i.\n\n        pushl   %ebx                ; Convert %ebx to a float.\n        fildl   (%esp)\n        addl    $4, %esp\n\n        fstpl   -4(%ecx, %eax, 4)   ; Store the float in the array at the ith\n                                ; position.\n\n        addl    $2, %eax            ; i := i + 1\n        cmpl    $19, %eax           ; If i <= 9, loop around again.\n        jle     .L101\n.L100:\n```\nThe important statement is the one which stores the float into the\narray. It is:\n\n```assembly\n        fstpl   -4(%ecx, %eax, 4)\n```\nThe assembler syntax is rather complex, but the bracketed expression\n`-4(%ecx, %eax, 4)` means \"at the address `%ecx + 4*%eax - 4`\". Recall\nthat `%eax` is the OCaml representation of i, complete with tag bit, so\nit is essentially equal to `i*2+1`, so let's substitute that and\nmultiply it out:\n\n```assembly\n  %ecx + 4*%eax - 4\n= %ecx + 4*(i*2+1) - 4\n= %ecx + 4*i*2 + 4 - 4\n= %ecx + 8*i\n```\n(Each float in the array is 8 bytes long.)\n\nSo arrays of floats are unboxed, as expected.\n\n###  Partially applied functions and closures\nHow does OCaml compile functions which are only partially applied? Let's\ncompile this code:\n\n```ocaml\nArray.map ((+) 2) [|1; 2; 3; 4; 5|]\n```\n\nIf you recall the syntax, `[| ... |]` declares an array (in this case an\n`int array`), and `((+) 2)` is a closure - \"the function which adds 2 to\nthings\".\n\nCompiling this code reveals some interesting new features. Firstly the\ncode which allocates the array:\n\n```assembly\n        movl    $24, %eax           ; Allocate 5 * 4 + 4 = 24 bytes of memory.\n        call    caml_alloc\n\n        leal    4(%eax), %eax       ; Let %eax point to 4 bytes into the\n                                    ;   allocated memory.\n```\nAll heap allocations have the same format: 4 byte header + data. In this\ncase the data is 5 integers, so we allocate 4 bytes for the header plus\n5 * 4 bytes for the data. We update the pointer to point at the first\ndata word, ie. 4 bytes into the allocated memory block.\n\nNext OCaml generates code to initialize the array:\n\n```assembly\n        movl    $5120, -4(%eax)\n        movl    $3, (%eax)\n        movl    $5, 4(%eax)\n        movl    $7, 8(%eax)\n        movl    $9, 12(%eax)\n        movl    $11, 16(%eax)\n```\nThe header word is 5120, which if you write it in binary means a block\ncontaining 5 words, with tag zero. The tag of zero means it's a\n\"structured block\" a.k.a. an array. We also copy the numbers 1, 2, 3, 4\nand 5 to the appropriate places in the array. Notice the OCaml\nrepresentation of integers is used. Because this is a structured block,\nthe garbage collector will scan each word in this block, and the GC\nneeds to be able to distinguish between integers and pointers to other\nheap-allocated blocks (the GC does not have access to type information\nabout this array).\n\nNext the closure `((+) 2)` is created. The closure is represented by\nthis block allocated in the data segment:\n\n```assembly\n        .data\n        .long   3319\n        .globl  Closure__1\nClosure__1:\n        .long   caml_curry2\n        .long   5\n        .long   Closure__fun_58\n```\nThe header is 3319, indicating a `Closure_tag` with length 3 words. The\n3 words in the block are the address of the function `caml_curry2`, the\ninteger number 2 and the address of this function:\n\n```assembly\n        .text\n        .globl  Closure__fun_58\nClosure__fun_58:\n\n        ; The function takes two arguments, %eax and %ebx.\n        ; This line causes the function to return %eax + %ebx - 1.\n\n        lea     -1(%eax, %ebx), %eax\n        ret\n```\nWhat does this function do? On the face of it, it adds the two\narguments, and subtracts one. But remember that `%eax` and `%ebx` are in\nthe OCaml representation for integers. Let's represent them as:\n\n* `%eax = 2 * a + 1`\n* `%ebx = 2 * b + 1`\n\nwhere `a` and `b` are the actual integer arguments. So this function\nreturns:\n\n```\n%eax + %ebx - 1\n= 2 * a + 1 + 2 * b + 1 - 1\n= 2 * a + 2 * b + 1\n= 2 * (a + b) + 1\n```\nIn other words, this function returns the OCaml integer representation\nof the sum `a + b`. This function is `(+)`!\n\n(It's actually more subtle than this - to perform the mathematics\nquickly, OCaml uses the x86 addressing hardware in a way that probably\nwasn't intended by the designers of the x86.)\n\nSo back to our closure - we won't go into the details of the\n`caml_curry2` function, but just say that this closure is the argument\n`2` applied to the function `(+)`, waiting for a second argument. Just\nas expected.\n\nThe actual call to the `Array.map` function is quite difficult to\nunderstand, but the main points for our examination of OCaml is that the\ncode:\n\n* Does call `Array.map` with an explicit closure.\n* Does not attempt to inline the call and turn it into a loop.\n\nCalling `Array.map` in this way is undoubtedly slower than writing a\nloop over the array by hand. The overhead is mainly in the fact that the\nclosure must be evaluated for each element of the array, and that isn't\nas fast as inlining the closure as a function (if this optimization were\neven possible). However, if you had a more substantial closure than just\n`((+) 2)`, the overhead would be reduced. The FP version also saves\nexpensive *programmer* time versus writing the imperative loop.\n\n## Profiling\nThere are two types of profiling that you can do on OCaml programs:\n\n1. Get execution counts for bytecode.\n1. Get real profiling for native code.\n\nThe `ocamlcp` and `ocamlprof` programs perform profiling on bytecode.\nHere is an example:\n\n\x3c!-- $MDX file=examples/gc.ml --\x3e\n```ocaml\nlet rec iterate r x_init i =\n  if i = 1 then x_init\n  else\n    let x = iterate r x_init (i - 1) in\n    r *. x *. (1.0 -. x)\n\nlet () =\n  Random.self_init ();\n  Graphics.open_graph \" 640x480\";\n  for x = 0 to 640 do\n    let r = 4.0 *. float_of_int x /. 640.0 in\n    for i = 0 to 39 do\n      let x_init = Random.float 1.0 in\n      let x_final = iterate r x_init 500 in\n      let y = int_of_float (x_final *. 480.) in\n      Graphics.plot x y\n    done\n  done;\n  Gc.print_stat stdout\n```\n\nAnd can be run and compiled with \n\n\x3c!-- $MDX skip --\x3e\n```\n$ ocamlcp -p a graphics.cma graphtest.ml -o graphtest\n$ ./graphtest\n$ ocamlprof graphtest.ml\n```\n\nThe comments `(* nnn *)` are added by `ocamlprof`, showing how many\ntimes each part of the code was called.\n\nProfiling native code is done using your operating system's native\nsupport for profiling. In the case of Linux, we use `gprof`. An alternative\nis [perf](https://en.wikipedia.org/wiki/Perf_(Linux)), as explained below.\n\nWe compile it using the `-p` option to `ocamlopt` which tells the\ncompiler to include profiling information for `gprof`:\n\nAfter running the program as normal, the profiling code dumps out a file\n`gmon.out` which we can interpret with `gprof`:\n\n```\n$ gprof ./a.out\nFlat profile:\n  \nEach sample counts as 0.01 seconds.\n  %   cumulative   self              self     total\n time   seconds   seconds    calls   s/call   s/call  name\n 10.86      0.57     0.57     2109     0.00     0.00  sweep_slice\n  9.71      1.08     0.51     1113     0.00     0.00  mark_slice\n  7.24      1.46     0.38  4569034     0.00     0.00  Sieve__code_begin\n  6.86      1.82     0.36  9171515     0.00     0.00  Stream__set_data_140\n  6.57      2.17     0.34 12741964     0.00     0.00  fl_merge_block\n  6.29      2.50     0.33  4575034     0.00     0.00  Stream__peek_154\n  5.81      2.80     0.30 12561656     0.00     0.00  alloc_shr\n  5.71      3.10     0.30     3222     0.00     0.00  oldify_mopup\n  4.57      3.34     0.24 12561656     0.00     0.00  allocate_block\n  4.57      3.58     0.24  9171515     0.00     0.00  modify\n  4.38      3.81     0.23  8387342     0.00     0.00  oldify_one\n  3.81      4.01     0.20 12561658     0.00     0.00  fl_allocate\n  3.81      4.21     0.20  4569034     0.00     0.00  Sieve__filter_56\n  3.62      4.40     0.19     6444     0.00     0.00  empty_minor_heap\n  3.24      4.57     0.17     3222     0.00     0.00  oldify_local_roots\n  2.29      4.69     0.12  4599482     0.00     0.00  Stream__slazy_221\n  2.10      4.80     0.11  4597215     0.00     0.00  darken\n  1.90      4.90     0.10  4596481     0.00     0.00  Stream__fun_345\n  1.52      4.98     0.08  4575034     0.00     0.00  Stream__icons_207\n  1.52      5.06     0.08  4575034     0.00     0.00  Stream__junk_165\n  1.14      5.12     0.06     1112     0.00     0.00  do_local_roots\n  \n[ etc. ]\n```\n\n### Using perf on Linux\n\nAssuming perf is installed and your program is compiled into\nnative code with `-g` (or ocamlbuild tag `debug`), you just need to type\n\n\x3c!-- $MDX skip --\x3e\n```sh\nperf record --call-graph=dwarf -- ./foo.native a b c d\nperf report\n```\n\nThe first command launches `foo.native` with arguments `a b c d` and\nrecords profiling information in `perf.data`; the second command\nstarts an interactive program to explore the call graph. The option\n`--call-graph=dwarf` makes perf aware of the calling convention of\nOCaml (with old versions of `perf`, enabling frame pointers in OCaml\nmight help; opam provides suitable compiler switches, such as `4.02.1+fp`).\n\n## Summary\nIn summary here are some tips for getting the best performance out of\nyour programs:\n\n1. Write your program as simply as possible. If it takes too long to\n run, profile it to find out where it's spending its time and\n concentrate optimizations on just those areas.\n1. Check for unintentional polymorphism, and add type hints for the\n compiler.\n1. Closures are slower than simple function calls, but add to\n maintainability and readability.\n1. As a last resort, rewrite hotspots in your program in C (but first\n check the assembly language produced by the OCaml compiler to see if\n you can do better than it).\n1. Performance might depend on external factors (speed of your database\n queries? speed of the network?). If so then no amount of\n optimization will help you.\n\n###  Further reading\nYou can find out more about how OCaml represents different types by\nreading the (\"Interfacing C with OCaml\") chapter in the OCaml manual and also\nlooking at the `mlvalues.h` header file.\n\n\x3c!--###  Java dynamic dispatch\n**There are some serious mistakes in the last paragraph:**\n\n* Dynamic method dispatch itself is seldom a performance problem. In\n languages without multiple inheritance (e.g. Java) this is usually\n done via one step of pointer indirection. Objects in OCaml are also\n dynamically dispatched. Since this is the point with polymorphism in\n an OO setting.\n\n* Dynamic method dispatch often hinders a compiler to inline function\n and this hits the performance.\n\n* In Java is a dynamic type check (aka cast) much more expensive than\n a dynamic method dispatch. --\x3e\n",toc_html:'<ul>\n<li><ul>\n<li><a href="#speed">Speed</a>\n</li>\n<li><a href="#profiling">Profiling</a>\n</li>\n<li><a href="#summary">Summary</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<h2 id="speed">Speed</h2>\n<p>Why is OCaml fast? Indeed, step back and ask <em>is OCaml fast?</em> How can we\nmake programs faster? In this chapter we\'ll look at what actually\nhappens when you compile your OCaml programs down to machine code. This\nwill help in understanding why OCaml is not just a great language for\nprogramming, but is also a very fast language indeed. And it\'ll help you\nto help the compiler write better machine code for you. It\'s also (I\nbelieve anyway) a good thing for programmers to have some idea of what\nhappens between you typing <code>ocamlopt</code> and getting a binary you can run.</p>\n<p>But you will need to know some assembler to get the most out of this\nsection. Don\'t be afraid! I\'ll help you out by translating the assembler\ninto a C-like pseudocode (after all C is just a portable assembly\nlanguage).</p>\n<h3 id="basics-of-assembly-language">Basics of assembly language</h3>\n<p>The examples I give in this chapter are all compiled on an x86 Linux\nmachine. The x86 is, of course, a 32 bit machine, so an x86 &quot;word&quot; is 4\nbytes (= 32 bits) long. At this level OCaml deals mostly with word-sized\nobjects, so you\'ll need to remember to multiply by four to get the size\nin bytes.</p>\n<p>To refresh your memory, the x86 has only a small number of general\npurpose registers, each of which can store one word. The Linux assembler\nputs <code>%</code> in front of register names. The registers are: <code>%eax</code>, <code>%ebx</code>,\n<code>%ecx</code>, <code>%edx</code>, <code>%esi</code>, <code>%edi</code>, <code>%ebp</code> (special register used for stack\nframes), and <code>%esp</code> (the stack pointer).</p>\n<p>The Linux assembler (in common with other Unix assemblers, but opposite\nto MS-derived assemblers) writes moves to and from registers/memory as:</p>\n<pre><code class="language-assembly">movl from, to\n</code></pre>\n<p>So <code>movl %ebx, %eax</code> means &quot;copy the contents of register <code>%ebx</code> into\nregister <code>%eax</code>&quot; (not the other way round).</p>\n<p>Almost all of the assembly language that we will look at is going to be\ndominated not by machine code instructions like <code>movl</code> but by what are\nknown as <strong>assembler directives</strong>. These directives begin\nwith a . (period) and they literally <em>direct</em> the assembler to do\nsomething. Here are the common ones for the Linux assembler:</p>\n<h4 id="text">.text</h4>\n<p><strong>Text</strong> is the Unix way of saying &quot;program code&quot;. The <strong>text segment</strong>\nsimply means the part of the executable where program code is stored.\nThe <code>.text</code> directive switches the assembler so it starts writing into\nthe text segment.</p>\n<h4 id="data">.data</h4>\n<p>Similarly, the <code>.data</code> directive switches the assembler so it starts\nwriting into the data segment (part) of the executable.</p>\n<pre><code class="language-assembly">  .globl foo\nfoo:\n</code></pre>\n<p>This declares a global symbol called <code>foo</code>. It means the address of the\nnext thing to come can be named <code>foo</code>. Writing just <code>foo:</code> without the\npreceding <code>.globl</code> directive declares a local symbol (local to just the\ncurrent file).</p>\n<pre><code class="language-assembly">.long 12345\n.byte 9\n.ascii &quot;hello&quot;\n.space 4\n</code></pre>\n<p><code>.long</code> writes a word (4 bytes) to the current segment. <code>.byte</code> writes a\nsingle byte. <code>.ascii</code> writes a string of bytes (NOT nul-terminated).\n<code>.space</code> writes the given number of zero bytes. Normally you use these\nin the data segment.</p>\n<h3 id="the-hello-world-program">The &quot;hello, world&quot; program</h3>\n<p>Enough assembler. Put the following program into a file called\n<code>smallest.ml</code>:</p>\n<pre><code class="language-ocaml">print_string &quot;hello, world\\n&quot;\n</code></pre>\n<p>And compile it to a native code executable using:</p>\n<pre><code class="language-shell">ocamlopt -S smallest.ml -o smallest\n</code></pre>\n<p>The <code>-S</code> (capital S) tells the compiler to leave the assembly language\nfile (called <code>smallest.s</code> - lowercase s) instead of deleting it.</p>\n<p>Here are the edited highlights of the <code>smallest.s</code> file with my comments\nadded. First of all the data segment:</p>\n<pre><code class="language-assembly">    .data\n    .long   4348                     ; header for string\n    .globl  Smallest__1\nlest__1:\n    .ascii  &quot;hello, world\\12&quot;        ; string\n    .space  2                        ; padding ..\n    .byte   2                        ;  .. after string\n</code></pre>\n<p>Next up the text (program code) segment:</p>\n<pre><code class="language-assembly">    .text\n    .globl  Smallest__entry          ; entry point to the program\nlest__entry:\n\n    ; this is equivalent to the C pseudo-code:\n    ; Pervasives.output_string (stdout, &amp;Smallest__1)\n\n    movl    $Smallest__1, %ebx\n    movl    Pervasives + 92, %eax    ; Pervasives + 92 == stdout\n    call    Pervasives__output_string_212\n\n    ; return 1\n\n    movl    $1, %eax\n    ret\n</code></pre>\n<p>In C everything has to be inside a function. Think about how you can\'t\njust write <code>printf (&quot;hello, world\\n&quot;);</code> in C, but instead you have to\nput it inside <code>main () { ... }</code>. In OCaml you are allowed to have\ncommands at the top level, not inside a function. But when we translate\nthis into assembly language, where do we put those commands? There needs\nto be some way to call those commands from outside, so they need to be\nlabelled in some way. As you can see from the code snippet, OCaml solves\nthis by taking the filename (<code>smallest.ml</code>), capitalizing it and adding\n<code>__entry</code>, thus making up a symbol called <code>Smallest__entry</code> to refer to\nthe top level commands in this file.</p>\n<p>Now look at the code that OCaml has generated. The original code said\n<code>print_string &quot;hello, world\\n&quot;</code>, but OCaml has instead compiled the\nequivalent of <code>Pervasives.output_string stdout &quot;hello, world\\n&quot;</code>. Why?\nIf you look into <code>pervasives.ml</code> you\'ll see why:</p>\n<pre><code class="language-ocaml">let print_string s = output_string stdout s\n</code></pre>\n<p>OCaml has <em>inlined</em> this function. <strong>Inlining</strong> - taking a function and\nexpanding it from its definition - is sometimes a performance win,\nbecause it avoids the overhead of an extra function call, and it can\nlead to more opportunities for the optimizer to do its thing. Sometimes\ninlining is not good, because it can lead to code bloating, and thus\ndestroys the good work done by the processor cache (and besides function\ncalls are actually not very expensive at all on modern processors).\nOCaml will inline simple calls like this, because they are essentially\nrisk free, almost always leading to a small performance gain.</p>\n<p>What else can we notice about this? The calling convention seems to be\nthat the first two arguments are passed in the <code>%eax</code> and <code>%ebx</code>\nregisters respectively. Other arguments are probably passed on the\nstack, but we\'ll see about that later.</p>\n<p>C programs have a simple convention for storing strings, known as\n<strong>ASCIIZ</strong>. This just means that the string is stored in ASCII, followed\nby a trailing NUL (<code>\\0</code>) character. OCaml stores strings in a different\nway, as we can see from the data segment above. This string is stored\nlike this:</p>\n<pre><code>4 byte header: 4348\nthe string:    h e l l o , SP w o r l d \\n\npadding:       \\0 \\0 \\002\n</code></pre>\n<p>Firstly the padding brings the total length of the string up to a whole\nnumber of words (4 words, 16 bytes in this example). The padding is\ncarefully designed so that you can work out the actual length of the\nstring in bytes, provided that you know the total number of <em>words</em>\nallocated to the string. The encoding for this is unambiguous (which you\ncan prove to yourself).</p>\n<p>One nice feature of having strings with an explicit length is that you\ncan represent strings containing ASCII NUL (<code>\\0</code>) characters in them,\nsomething which is difficult to do in C. However, the flip side is that\nyou need to be aware of this if you pass an OCaml string to some C\nnative code: if it contains ASCII NUL, then the C <code>str*</code> functions will\nfail on it.</p>\n<p>Secondly we have the header. Every boxed (allocated) object in OCaml has\na header which tells the garbage collector about how large the object is\nin words, and something about what the object contains. Writing the\nnumber 4348 in binary:</p>\n<pre><code>length of the object in words:  0000 0000 0000 0000 0001 00 (4 words)\ncolor (used by GC):             00\ntag:                            1111 1100 (String_tag)\n</code></pre>\n<p>See <code>/usr/include/caml/mlvalues.h</code> for more information about\nthe format of heap allocated objects in OCaml.</p>\n<p>One unusual thing is that the code passes a pointer to the start of the\nstring (ie. the word immediately after the header) to\n<code>Pervasives.output_string</code>. This means that <code>output_string</code> must\nsubtract 4 from the pointer to get at the header to determine the length\nof the string.</p>\n<p>What have I missed out from this simple example? Well, the text segment\nabove is not the whole story. It would be really nice if OCaml\ntranslated that simple hello world program into just the five lines of\nassembler shown above. But there is the question of what actually calls\n<code>Smallest__entry</code> in the real program. For this OCaml includes a whole\nload of bootstrapping code which does things like starting up the\ngarbage collector, allocating and initializing memory, calling\ninitializers in libraries and so on. OCaml links all of this code\nstatically to the final executable, which is why the program I end up\nwith (on Linux) weighs in at a portly 95,442 bytes. Nevertheless the\nstart-up time for the program is still unmeasurably small (under a\nmillisecond), compared to several seconds for starting up a reasonable\nJava program and a second or so for a Perl script.</p>\n<h3 id="tail-recursion">Tail recursion</h3>\n<p>We mentioned in chapter 6 that OCaml can turn tail-recursive function\ncalls into simple loops. Is this actually true? Let\'s look at what\nsimple tail recursion compiles to:</p>\n\x3c!-- do not execute this code!! --\x3e\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-ocaml">let rec loop () =\n  print_string &quot;I go on forever ...&quot;;\n  loop ()\n  \nlet () = loop ()\n</code></pre>\n<p>The file is called <code>tail.ml</code>, so following OCaml\'s usual procedure for\nnaming functions, our function will be called <code>Tail__loop_nnn</code> (where\n<code>nnn</code> is some unique number which OCaml appends to distinguish\nidentically named functions from one another).</p>\n<p>Here is the assembler for just the <code>loop</code> function defined above:</p>\n<pre><code class="language-assembly">        .text\n        .globl  Tail__loop_56\nTail__loop_56:\n.L100:\n        ; Print the string\n        movl    $Tail__2, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n.L101:\n        ; The following movl is in fact obsolete:\n        movl    $1, %eax\n        ; Jump back to the .L100 label above (ie. loop forever)\n        jmp     .L100\n</code></pre>\n<p>So that\'s pretty conclusive. Calling <code>Tail__loop_56</code> will first print\nthe string, and then jump back to the top, then print the string, and\njump back, and so on forever. It\'s a simple loop, <em>not</em> a recursive\nfunction call, so it doesn\'t use any stack space.</p>\n<h3 id="digression-where-are-the-types">Digression: Where are the types?</h3>\n<p>OCaml is statically typed as we\'ve said before on many occasions, so at\ncompile time, OCaml knows that the type of <code>loop</code> is <code>unit -&gt; unit</code>. It\nknows that the type of <code>&quot;hello, world\\n&quot;</code> is <code>string</code>. It doesn\'t make\nany attempt to communicate this fact to the <code>output_string</code> function.\n<code>output_string</code> is expecting a <code>channel</code> and a <code>string</code> as arguments,\nand indeed that\'s what it gets. What would happen if we passed, say, an\n<code>int</code> instead of a <code>string</code>?</p>\n<p>This is essentially an impossible condition. Because OCaml knows the\ntypes at compile time, it doesn\'t need to deal with types or check types\nat run time. There is no way, in pure OCaml, to &quot;trick&quot; the compiler\ninto generating a call to <code>Pervasives.output_string stdout 1</code>. Such an\nerror would be flagged at compile time, by type inference, and so could\nnever be compiled.</p>\n<p>The upshot is that by the time we have compiled OCaml code to assembler\ntype information mostly isn\'t required, certainly in the cases we\'ve\nlooked at above where the type is fully known at compile time, and there\nis no polymorphism going on.</p>\n<p>Fully knowing all your types at compile time is a major performance win\nbecause it totally avoids any dynamic type checking at run time. Compare\nthis to a Java method invocation for example: <code>obj.method ()</code>. This is\nan expensive operation because you need to find the concrete class that\n<code>obj</code> is an instance of, and then look up the method, and you need to do\nall of this potentially <em>every</em> time you call any method. Casting\nobjects is another case where you need to do a considerable amount of\nwork at run time in Java. None of this is allowed with OCaml\'s static\ntypes.</p>\n<h3 id="polymorphic-types">Polymorphic types</h3>\n<p>As you might have guessed from the discussion above, polymorphism, which\nis where the compiler <em>doesn\'t</em> have a fully known type for a function\nat compile time, might have an impact on performance. Suppose we require\na function to work out the maximum of two integers. Our first attempt\nis:</p>\n<pre><code class="language-ocaml"># let max a b =\n  if a &gt; b then a else b\nval max : \'a -&gt; \'a -&gt; \'a = &lt;fun&gt;\n</code></pre>\n<p>Simple enough, but recall that the &gt; (greater than) operator in OCaml\nis polymorphic. It has type <code>\'a -&gt; \'a -&gt; bool</code>, and this means that the\n<code>max</code> function we defined above is going to be polymorphic:</p>\n<pre><code class="language-ocaml"># let max a b =\n  if a &gt; b then a else b\nval max : \'a -&gt; \'a -&gt; \'a = &lt;fun&gt;\n</code></pre>\n<p>This is indeed reflected in the code that OCaml generates for this\nfunction, which is pretty complex:</p>\n<pre><code class="language-assembly">        .text\n        .globl  Max__max_56\nMax__max_56:\n\n        ; Reserve two words of stack space.\n\n        subl    $8, %esp\n\n        ; Save the first and second arguments (a and b) on the stack.\n\n        movl    %eax, 4(%esp)\n        movl    %ebx, 0(%esp)\n\n        ; Call the C &quot;greaterthan&quot; function (in the OCaml library).\n\n        pushl   %ebx\n        pushl   %eax\n        movl    $greaterthan, %eax\n        call    caml_c_call\n.L102:\n        addl    $8, %esp\n\n        ; If the C &quot;greaterthan&quot; function returned 1, jump to .L100\n\n        cmpl    $1, %eax\n        je      .L100\n\n        ; Returned 0, so get argument a which we previously saved on\n        ; the stack and return it.\n\n        movl    4(%esp), %eax\n        addl    $8, %esp\n        ret\n\n        ; Returned 1, so get argument b which we previously saved on\n        ; the stack and return it.\n\n.L100:\n        movl    0(%esp), %eax\n        addl    $8, %esp\n        ret\n</code></pre>\n<p>Basically the &gt; operation is done by calling a C function from the\nOCaml library. This is obviously not going to be very efficient, nothing\nlike as efficient as if we could generate some quick inline assembly\nlanguage for doing the &gt;.</p>\n<p>This is not a complete dead loss by any means. All we need to do is to\nhint to the OCaml compiler that the arguments are in fact integers. Then\nOCaml will generate a specialised version of <code>max</code> which only works on\n<code>int</code> arguments:</p>\n<pre><code class="language-ocaml"># let max (a : int) (b : int) =\n  if a &gt; b then a else b\nval max : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre>\n<p>Here is the assembly code generated for this function:</p>\n<pre><code class="language-assembly">        .text\n        .globl  Max_int__max_56\nMax_int__max_56:\n\n        ; Single assembly instruction &quot;cmpl&quot; for performing the &gt; op.\n        cmpl    %ebx, %eax\n\n        ; If %ebx &gt; %eax, jump to .L100\n        jle     .L100\n        ; Just return argument a.\n        ret\n        ; Return argument b.\n\n.L100:\n        movl    %ebx, %eax\n        ret\n</code></pre>\n<p>That\'s just 5 lines of assembler, and is about as simple as you can make\nit.</p>\n<p>What about this code:</p>\n<pre><code class="language-ocaml"># let max a b =\n  if a &gt; b then a else b\nval max : \'a -&gt; \'a -&gt; \'a = &lt;fun&gt;\n# let () = print_int (max 2 3)\n3\n</code></pre>\n<p>Is OCaml going to be smart enough to inline the <code>max</code> function and\nspecialise it to work on integers? Disappointingly the answer is no.\nOCaml still has to generate the external <code>Max.max</code> symbol (because this\nis a module, and so that function might be called from outside the\nmodule), and it doesn\'t inline the function.</p>\n<p>Here\'s another variation:</p>\n<pre><code class="language-ocaml"># let max a b =\n  if a &gt; b then a else b in\n  print_int (max 2 3)\n3\n- : unit = ()\n</code></pre>\n<p>Disappointingly although the definition of <code>max</code> in this code is local\n(it can\'t be called from outside the module), OCaml still doesn\'t\nspecialise the function.</p>\n<p>Lesson: if you have a function which is unintentionally polymorphic then\nyou can help the compiler by specifying types for one or more of the\narguments.</p>\n<h3 id="the-representation-of-integers-tag-bits-heap-allocated-values">The representation of integers, tag bits, heap-allocated values</h3>\n<p>There are a number of peculiarities about integers in OCaml. One of\nthese is that integers are 31 bit entities, not 32 bit entities. What\nhappens to the &quot;missing&quot; bit?</p>\n<p>Write this to <code>int.ml</code>:</p>\n<pre><code class="language-ocaml">print_int 3\n</code></pre>\n<p>and compile with <code>ocamlopt -S int.ml -o int</code> to generate assembly\nlanguage in <code>int.s</code>. Recall from the discussion above that we are\nexpecting OCaml to inline the <code>print_int</code> function as\n<code>output_string (string_of_int 3)</code>, and examining the assembly language\noutput we can see that this is exactly what OCaml does:</p>\n<pre><code class="language-assembly">        .text\n        .globl  Int__entry\nInt__entry:\n\n        ; Call Pervasives.string_of_int (3)\n\n        movl    $7, %eax\n        call    Pervasives__string_of_int_152\n\n        ; Call Pervasives.output_string (stdout, result_of_previous)\n\n        movl    %eax, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n</code></pre>\n<p>The important code is shown in red. It shows two things: Firstly the\ninteger is unboxed (not allocated on the heap), but is instead passed\ndirectly to the function in the register <code>%eax</code>. This is fast. But\nsecondly we see that the number being passed is 7, not 3.</p>\n<p>This is a consequence of the representation of integers in OCaml. The\nbottom bit of the integer is used as a tag - we\'ll see what for next.\nThe top 31 bits are the actual integer. The binary representation of 7\nis 111, so the bottom tag bit is 1 and the top 31 bits form the number\n11 in binary = 3. To get from the OCaml representation to the integer,\ndivide by two and round down.</p>\n<p>Why the tag bit at all? This bit is used to distinguish between integers\nand pointers to structures on the heap, and the distinction is only\nnecessary if we are calling a polymorphic function. In the case above,\nwhere we are calling <code>string_of_int</code>, the argument can only ever be an\n<code>int</code> and so the tag bit would never be consulted. Nevertheless, to\navoid having two internal representations for integers, all integers in\nOCaml carry around the tag bit.</p>\n<p>A bit of background about pointers is required to understand why the tag\nbit is really necessary, and why it is where it is.</p>\n<p>In the world of RISC chips like the Sparc, MIPS and Alpha, pointers have\nto be word-aligned. So on the older 32 bit Sparc, for example, it\'s not\npossible to create and use a pointer which isn\'t aligned to a multiple\nof 4 (bytes). Trying to use one generates a processor exception, which\nmeans basically your program segfaults. The reason for this is just to\nsimplify memory access. It\'s just a lot simpler to design the memory\nsubsystem of a CPU if you only need to worry about word-aligned access.</p>\n<p>For historical reasons (because the x86 is derived from an 8 bit chip),\nthe x86 has supported unaligned memory access, although if you align all\nmemory accesses to multiples of 4, then things go faster.</p>\n<p>Nevertheless, all pointers in OCaml are aligned - ie. multiples of 4 for\n32 bit processors, and multiples of 8 for 64 bit processors. This means\nthat the bottom bit of any pointer in OCaml will always be zero.</p>\n<p>So you can see that by looking at the bottom bit of a register, you can\nimmediately tell if it stores a pointer (&quot;tag&quot; bit is zero), or an\ninteger (tag bit set to one).</p>\n<p>Remember our polymorphic &gt; function which caused us so much trouble in\nthe previous section? We looked at the assembler and found out that\nOCaml compiles a call to a C function called <code>greaterthan</code> whenever it\nsees the polymorphic form of &gt;. This function takes two arguments, in\nregisters <code>%eax</code> and <code>%ebx</code>. But <code>greaterthan</code> can be called with\nintegers, floats, strings, opaque objects ... How does it know what\n<code>%eax</code> and <code>%ebx</code> point to?</p>\n<p>It uses the following decision tree:</p>\n<ul>\n<li><strong>Tag bit is one:</strong> compare the two integers and return.\n</li>\n<li><strong>Tag bit is zero:</strong> <code>%eax</code> and <code>%ebx</code> must point at two\nheap-allocated memory blocks. Look at the header word of the memory\nblocks, specifically the bottom 8 bits of the header word, which tag\nthe content of the block.\n<ul>\n<li><strong>String_tag:</strong> Compare two strings.\n</li>\n<li><strong>Double_tag:</strong> Compare two floats.\n</li>\n<li>etc.\n</li>\n</ul>\n</li>\n</ul>\n<p>Note that because &gt; has type <code>\'a -&gt; \'a -&gt; bool</code>, both arguments must\nhave the same type. The compiler should enforce this at compile time. I\nwould assume that <code>greaterthan</code> probably contains code to sanity-check\nthis at run time however.</p>\n<h3 id="floats">Floats</h3>\n<p>Floats are, by default, boxed (allocated on the heap). Save this as\n<code>float.ml</code> and compile it with <code>ocamlopt -S float.ml -o float</code>:</p>\n<pre><code class="language-ocamltop">print_float 3.0\n</code></pre>\n<p>The number is not passed directly to <code>string_of_float</code> in the <code>%eax</code>\nregister as happened above with ints. Instead, it is created statically\nin the data segment:</p>\n<pre><code class="language-assembly">        .data\n        .long   2301\n        .globl  Float__1\nFloat__1:\n        .double 3.0\n</code></pre>\n<p>and a pointer to the float is passed in <code>%eax</code> instead:</p>\n<pre><code class="language-assembly">        movl    $Float__1, %eax\n        call    Pervasives__string_of_float_157\n</code></pre>\n<p>Note the structure of the floating point number: it has a header (2301),\nfollowed by the 8 byte (2 word) representation of the number itself. The\nheader can be decoded by writing it as binary:</p>\n<pre><code>Length of the object in words:  0000 0000 0000 0000 0000 10 (8 bytes)\nColor:                          00\nTag:                            1111 1101 (Double_tag)\n</code></pre>\n<p><code>string_of_float</code> isn\'t polymorphic, but suppose we have a polymorphic\nfunction <code>foo : \'a -&gt; unit</code> taking one polymorphic argument. If we call\n<code>foo</code> with <code>%eax</code> containing 7, then this is equivalent to <code>foo 3</code>,\nwhereas if we call <code>foo</code> with <code>%eax</code> containing a pointer to <code>Float__1</code>\nabove, then this is equivalent to <code>foo 3.0</code>.</p>\n<h3 id="arrays">Arrays</h3>\n<p>I mentioned earlier that one of OCaml\'s targets was numerical computing.\nNumerical computing does a lot of work on vectors and matrices, which\nare essentially arrays of floats. As a special hack to make this go\nfaster, OCaml implements <strong>arrays of unboxed floats</strong>. This\nmeans that in the special case where we have an object of type\n<code>float array</code> (array of floats), OCaml stores them the same way as in C:</p>\n<pre><code class="language-C">double array[10];\n</code></pre>\n<p>... instead of having an array of pointers to ten separately allocated\nfloats on the heap.</p>\n<p>Let\'s see this in practice:</p>\n<pre><code class="language-ocaml">let a = Array.create 10 0.0;;\nfor i = 0 to 9 do\n  a.(i) &lt;- float_of_int i\ndone\n</code></pre>\n<p>I\'m going to compile this code with the <code>-unsafe</code> option to remove\nbounds checking (simplifying the code for our exposition here). The\nfirst line, which creates the array, is compiled to a simple C call:</p>\n<pre><code class="language-assembly">        pushl   $Arrayfloats__1     ; Boxed float 0.0\n        pushl   $21                 ; The integer 10\n        movl    $make_vect, %eax    ; Address of the C function to call\n        call    caml_c_call\n    ; ...\n        movl    %eax, Arrayfloats   ; Store the resulting pointer to the\n                                    ; array at this place on the heap.\n</code></pre>\n<p>The loop is compiled to this relatively simple assembly language:</p>\n<pre><code class="language-assembly">        movl    $1, %eax            ; Let %eax = 0. %eax is going to store i.\n        cmpl    $19, %eax           ; If %eax &gt; 9, then jump out of the\n        jg      .L100               ;   loop (to label .L100 at the end).\n\n.L101:                              ; This is the start of the loop body.\n        movl    Arrayfloats, %ecx   ; Address of the array to %ecx.\n\n        movl    %eax, %ebx          ; Copy i to %ebx.\n        sarl    $1, %ebx            ; Remove the tag bit from %ebx by\n                                    ;   shifting it right 1 place. So %ebx\n                                    ;   now contains the real integer i.\n\n        pushl   %ebx                ; Convert %ebx to a float.\n        fildl   (%esp)\n        addl    $4, %esp\n\n        fstpl   -4(%ecx, %eax, 4)   ; Store the float in the array at the ith\n                                ; position.\n\n        addl    $2, %eax            ; i := i + 1\n        cmpl    $19, %eax           ; If i &lt;= 9, loop around again.\n        jle     .L101\n.L100:\n</code></pre>\n<p>The important statement is the one which stores the float into the\narray. It is:</p>\n<pre><code class="language-assembly">        fstpl   -4(%ecx, %eax, 4)\n</code></pre>\n<p>The assembler syntax is rather complex, but the bracketed expression\n<code>-4(%ecx, %eax, 4)</code> means &quot;at the address <code>%ecx + 4*%eax - 4</code>&quot;. Recall\nthat <code>%eax</code> is the OCaml representation of i, complete with tag bit, so\nit is essentially equal to <code>i*2+1</code>, so let\'s substitute that and\nmultiply it out:</p>\n<pre><code class="language-assembly">  %ecx + 4*%eax - 4\n= %ecx + 4*(i*2+1) - 4\n= %ecx + 4*i*2 + 4 - 4\n= %ecx + 8*i\n</code></pre>\n<p>(Each float in the array is 8 bytes long.)</p>\n<p>So arrays of floats are unboxed, as expected.</p>\n<h3 id="partially-applied-functions-and-closures">Partially applied functions and closures</h3>\n<p>How does OCaml compile functions which are only partially applied? Let\'s\ncompile this code:</p>\n<pre><code class="language-ocaml">Array.map ((+) 2) [|1; 2; 3; 4; 5|]\n</code></pre>\n<p>If you recall the syntax, <code>[| ... |]</code> declares an array (in this case an\n<code>int array</code>), and <code>((+) 2)</code> is a closure - &quot;the function which adds 2 to\nthings&quot;.</p>\n<p>Compiling this code reveals some interesting new features. Firstly the\ncode which allocates the array:</p>\n<pre><code class="language-assembly">        movl    $24, %eax           ; Allocate 5 * 4 + 4 = 24 bytes of memory.\n        call    caml_alloc\n\n        leal    4(%eax), %eax       ; Let %eax point to 4 bytes into the\n                                    ;   allocated memory.\n</code></pre>\n<p>All heap allocations have the same format: 4 byte header + data. In this\ncase the data is 5 integers, so we allocate 4 bytes for the header plus\n5 * 4 bytes for the data. We update the pointer to point at the first\ndata word, ie. 4 bytes into the allocated memory block.</p>\n<p>Next OCaml generates code to initialize the array:</p>\n<pre><code class="language-assembly">        movl    $5120, -4(%eax)\n        movl    $3, (%eax)\n        movl    $5, 4(%eax)\n        movl    $7, 8(%eax)\n        movl    $9, 12(%eax)\n        movl    $11, 16(%eax)\n</code></pre>\n<p>The header word is 5120, which if you write it in binary means a block\ncontaining 5 words, with tag zero. The tag of zero means it\'s a\n&quot;structured block&quot; a.k.a. an array. We also copy the numbers 1, 2, 3, 4\nand 5 to the appropriate places in the array. Notice the OCaml\nrepresentation of integers is used. Because this is a structured block,\nthe garbage collector will scan each word in this block, and the GC\nneeds to be able to distinguish between integers and pointers to other\nheap-allocated blocks (the GC does not have access to type information\nabout this array).</p>\n<p>Next the closure <code>((+) 2)</code> is created. The closure is represented by\nthis block allocated in the data segment:</p>\n<pre><code class="language-assembly">        .data\n        .long   3319\n        .globl  Closure__1\nClosure__1:\n        .long   caml_curry2\n        .long   5\n        .long   Closure__fun_58\n</code></pre>\n<p>The header is 3319, indicating a <code>Closure_tag</code> with length 3 words. The\n3 words in the block are the address of the function <code>caml_curry2</code>, the\ninteger number 2 and the address of this function:</p>\n<pre><code class="language-assembly">        .text\n        .globl  Closure__fun_58\nClosure__fun_58:\n\n        ; The function takes two arguments, %eax and %ebx.\n        ; This line causes the function to return %eax + %ebx - 1.\n\n        lea     -1(%eax, %ebx), %eax\n        ret\n</code></pre>\n<p>What does this function do? On the face of it, it adds the two\narguments, and subtracts one. But remember that <code>%eax</code> and <code>%ebx</code> are in\nthe OCaml representation for integers. Let\'s represent them as:</p>\n<ul>\n<li><code>%eax = 2 * a + 1</code>\n</li>\n<li><code>%ebx = 2 * b + 1</code>\n</li>\n</ul>\n<p>where <code>a</code> and <code>b</code> are the actual integer arguments. So this function\nreturns:</p>\n<pre><code>%eax + %ebx - 1\n= 2 * a + 1 + 2 * b + 1 - 1\n= 2 * a + 2 * b + 1\n= 2 * (a + b) + 1\n</code></pre>\n<p>In other words, this function returns the OCaml integer representation\nof the sum <code>a + b</code>. This function is <code>(+)</code>!</p>\n<p>(It\'s actually more subtle than this - to perform the mathematics\nquickly, OCaml uses the x86 addressing hardware in a way that probably\nwasn\'t intended by the designers of the x86.)</p>\n<p>So back to our closure - we won\'t go into the details of the\n<code>caml_curry2</code> function, but just say that this closure is the argument\n<code>2</code> applied to the function <code>(+)</code>, waiting for a second argument. Just\nas expected.</p>\n<p>The actual call to the <code>Array.map</code> function is quite difficult to\nunderstand, but the main points for our examination of OCaml is that the\ncode:</p>\n<ul>\n<li>Does call <code>Array.map</code> with an explicit closure.\n</li>\n<li>Does not attempt to inline the call and turn it into a loop.\n</li>\n</ul>\n<p>Calling <code>Array.map</code> in this way is undoubtedly slower than writing a\nloop over the array by hand. The overhead is mainly in the fact that the\nclosure must be evaluated for each element of the array, and that isn\'t\nas fast as inlining the closure as a function (if this optimization were\neven possible). However, if you had a more substantial closure than just\n<code>((+) 2)</code>, the overhead would be reduced. The FP version also saves\nexpensive <em>programmer</em> time versus writing the imperative loop.</p>\n<h2 id="profiling">Profiling</h2>\n<p>There are two types of profiling that you can do on OCaml programs:</p>\n<ol>\n<li>Get execution counts for bytecode.\n</li>\n<li>Get real profiling for native code.\n</li>\n</ol>\n<p>The <code>ocamlcp</code> and <code>ocamlprof</code> programs perform profiling on bytecode.\nHere is an example:</p>\n\x3c!-- $MDX file=examples/gc.ml --\x3e\n<pre><code class="language-ocaml">let rec iterate r x_init i =\n  if i = 1 then x_init\n  else\n    let x = iterate r x_init (i - 1) in\n    r *. x *. (1.0 -. x)\n\nlet () =\n  Random.self_init ();\n  Graphics.open_graph &quot; 640x480&quot;;\n  for x = 0 to 640 do\n    let r = 4.0 *. float_of_int x /. 640.0 in\n    for i = 0 to 39 do\n      let x_init = Random.float 1.0 in\n      let x_final = iterate r x_init 500 in\n      let y = int_of_float (x_final *. 480.) in\n      Graphics.plot x y\n    done\n  done;\n  Gc.print_stat stdout\n</code></pre>\n<p>And can be run and compiled with</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code>$ ocamlcp -p a graphics.cma graphtest.ml -o graphtest\n$ ./graphtest\n$ ocamlprof graphtest.ml\n</code></pre>\n<p>The comments <code>(* nnn *)</code> are added by <code>ocamlprof</code>, showing how many\ntimes each part of the code was called.</p>\n<p>Profiling native code is done using your operating system\'s native\nsupport for profiling. In the case of Linux, we use <code>gprof</code>. An alternative\nis <a href="https://en.wikipedia.org/wiki/Perf_(Linux)">perf</a>, as explained below.</p>\n<p>We compile it using the <code>-p</code> option to <code>ocamlopt</code> which tells the\ncompiler to include profiling information for <code>gprof</code>:</p>\n<p>After running the program as normal, the profiling code dumps out a file\n<code>gmon.out</code> which we can interpret with <code>gprof</code>:</p>\n<pre><code>$ gprof ./a.out\nFlat profile:\n  \nEach sample counts as 0.01 seconds.\n  %   cumulative   self              self     total\n time   seconds   seconds    calls   s/call   s/call  name\n 10.86      0.57     0.57     2109     0.00     0.00  sweep_slice\n  9.71      1.08     0.51     1113     0.00     0.00  mark_slice\n  7.24      1.46     0.38  4569034     0.00     0.00  Sieve__code_begin\n  6.86      1.82     0.36  9171515     0.00     0.00  Stream__set_data_140\n  6.57      2.17     0.34 12741964     0.00     0.00  fl_merge_block\n  6.29      2.50     0.33  4575034     0.00     0.00  Stream__peek_154\n  5.81      2.80     0.30 12561656     0.00     0.00  alloc_shr\n  5.71      3.10     0.30     3222     0.00     0.00  oldify_mopup\n  4.57      3.34     0.24 12561656     0.00     0.00  allocate_block\n  4.57      3.58     0.24  9171515     0.00     0.00  modify\n  4.38      3.81     0.23  8387342     0.00     0.00  oldify_one\n  3.81      4.01     0.20 12561658     0.00     0.00  fl_allocate\n  3.81      4.21     0.20  4569034     0.00     0.00  Sieve__filter_56\n  3.62      4.40     0.19     6444     0.00     0.00  empty_minor_heap\n  3.24      4.57     0.17     3222     0.00     0.00  oldify_local_roots\n  2.29      4.69     0.12  4599482     0.00     0.00  Stream__slazy_221\n  2.10      4.80     0.11  4597215     0.00     0.00  darken\n  1.90      4.90     0.10  4596481     0.00     0.00  Stream__fun_345\n  1.52      4.98     0.08  4575034     0.00     0.00  Stream__icons_207\n  1.52      5.06     0.08  4575034     0.00     0.00  Stream__junk_165\n  1.14      5.12     0.06     1112     0.00     0.00  do_local_roots\n  \n[ etc. ]\n</code></pre>\n<h3 id="using-perf-on-linux">Using perf on Linux</h3>\n<p>Assuming perf is installed and your program is compiled into\nnative code with <code>-g</code> (or ocamlbuild tag <code>debug</code>), you just need to type</p>\n\x3c!-- $MDX skip --\x3e\n<pre><code class="language-sh">perf record --call-graph=dwarf -- ./foo.native a b c d\nperf report\n</code></pre>\n<p>The first command launches <code>foo.native</code> with arguments <code>a b c d</code> and\nrecords profiling information in <code>perf.data</code>; the second command\nstarts an interactive program to explore the call graph. The option\n<code>--call-graph=dwarf</code> makes perf aware of the calling convention of\nOCaml (with old versions of <code>perf</code>, enabling frame pointers in OCaml\nmight help; opam provides suitable compiler switches, such as <code>4.02.1+fp</code>).</p>\n<h2 id="summary">Summary</h2>\n<p>In summary here are some tips for getting the best performance out of\nyour programs:</p>\n<ol>\n<li>Write your program as simply as possible. If it takes too long to\nrun, profile it to find out where it\'s spending its time and\nconcentrate optimizations on just those areas.\n</li>\n<li>Check for unintentional polymorphism, and add type hints for the\ncompiler.\n</li>\n<li>Closures are slower than simple function calls, but add to\nmaintainability and readability.\n</li>\n<li>As a last resort, rewrite hotspots in your program in C (but first\ncheck the assembly language produced by the OCaml compiler to see if\nyou can do better than it).\n</li>\n<li>Performance might depend on external factors (speed of your database\nqueries? speed of the network?). If so then no amount of\noptimization will help you.\n</li>\n</ol>\n<h3 id="further-reading">Further reading</h3>\n<p>You can find out more about how OCaml represents different types by\nreading the (&quot;Interfacing C with OCaml&quot;) chapter in the OCaml manual and also\nlooking at the <code>mlvalues.h</code> header file.</p>\n\x3c!--###  Java dynamic dispatch\n**There are some serious mistakes in the last paragraph:**\n\n* Dynamic method dispatch itself is seldom a performance problem. In\n languages without multiple inheritance (e.g. Java) this is usually\n done via one step of pointer indirection. Objects in OCaml are also\n dynamically dispatched. Since this is the point with polymorphism in\n an OO setting.\n\n* Dynamic method dispatch often hinders a compiler to inline function\n and this hits the performance.\n\n* In Java is a dynamic type check (aka cast) much more expensive than\n a dynamic method dispatch. --\x3e\n'},tl:{hd:{title:"Comparison of Standard Containers",slug:"comparison-of-standard-containers",description:"A comparison of some core data-structures including lists, queues and arrays\n",date:"2021-05-27T21:07:30-00:00",tags:{hd:"language",tl:0},users:{hd:"Intermediate",tl:0},body_md:'\nThis is a rough comparison of the different container types that are\nprovided by the OCaml language or by the OCaml standard library. In each\ncase, n is the number of valid elements in the container.\n\nNote that the big-O cost given for some operations reflects the current\nimplementation but is not guaranteed by the official documentation.\nHopefully it will not become worse. Anyway, if you want more details,\nyou should read the documentation about each of the modules. Often, it\nis also instructive to read the corresponding implementation.\n\n## Lists: immutable singly-linked lists\nAdding an element always creates a new list l from an element x and list\ntl. tl remains unchanged, but it is not copied either.\n\n* "adding" an element: O(1), cons operator `::`\n* length: O(n), function `List.length`\n* accessing cell `i`: O(i)\n* finding an element: O(n)\n\nWell-suited for: IO, pattern-matching\n\nNot very efficient for: random access, indexed elements\n\n## Arrays: mutable vectors\nArrays are mutable data structures with a fixed length and random access.\n\n* "adding" an element (by creating a new array): O(n)\n* length: O(1), function `Array.length`\n* accessing cell `i`: O(1)\n* finding an element: O(n)\n\nWell-suited for sets of elements of known size, access by numeric index,\nin-place modification. Basic arrays have a fixed length.\n\n## Strings: immutable vectors\nStrings are very similar to arrays but are immutable. Strings are\nspecialized for storing chars (bytes) and have some convenient syntax.\nStrings have a fixed length. For extensible strings, the standard Buffer\nmodule can be used (see below).\n\n* "adding" an element (by creating a new string): O(n)\n* length: O(1)\n* accessing character `i`: O(1)\n* finding an element: O(n)\n\n## Set and Map: immutable trees\nLike lists, these are immutable and they may share some subtrees. They\nare a good solution for keeping older versions of sets of items.\n\n* "adding" an element: O(log n)\n* returning the number of elements: O(n)\n* finding an element: O(log n)\n\nSets and maps are very useful in compilation and meta-programming, but\nin other situations hash tables are often more appropriate (see below).\n\n## Hashtbl: automatically growing hash tables\nOcaml hash tables are mutable data structures, which are a good solution\nfor storing (key, data) pairs in one single place.\n\n* adding an element: O(1) if the initial size of the table is larger\n than the number of elements it contains; O(log n) on average if n\n elements have been added in a table which is initially much smaller\n than n.\n* returning the number of elements: O(1)\n* finding an element: O(1)\n\n## Buffer: extensible strings\nBuffers provide an efficient way to accumulate a sequence of bytes in a\nsingle place. They are mutable.\n\n* adding a char: O(1) if the buffer is big enough, or O(log n) on\n average if the initial size of the buffer was much smaller than the\n number of bytes n.\n* adding a string of k chars: O(k * "adding a char")\n* length: O(1)\n* accessing cell `i`: O(1)\n\n## Queue\nOCaml queues are mutable first-in-first-out (FIFO) data structures.\n\n* adding an element: O(1)\n* taking an element: O(1)\n* length: O(1)\n\n## Stack\nOCaml stacks are mutable last-in-first-out (LIFO) data structures. They\nare just like lists, except that they are mutable, i.e. adding an\nelement doesn\'t create a new stack but simply adds it to the stack.\n\n* adding an element: O(1)\n* taking an element: O(1)\n* length: O(1)\n',toc_html:'<ul>\n<li><ul>\n<li><a href="#lists-immutable-singly-linked-lists">Lists: immutable singly-linked lists</a>\n</li>\n<li><a href="#arrays-mutable-vectors">Arrays: mutable vectors</a>\n</li>\n<li><a href="#strings-immutable-vectors">Strings: immutable vectors</a>\n</li>\n<li><a href="#set-and-map-immutable-trees">Set and Map: immutable trees</a>\n</li>\n<li><a href="#hashtbl-automatically-growing-hash-tables">Hashtbl: automatically growing hash tables</a>\n</li>\n<li><a href="#buffer-extensible-strings">Buffer: extensible strings</a>\n</li>\n<li><a href="#queue">Queue</a>\n</li>\n<li><a href="#stack">Stack</a>\n</li>\n</ul>\n</li>\n</ul>\n',body_html:'<p>This is a rough comparison of the different container types that are\nprovided by the OCaml language or by the OCaml standard library. In each\ncase, n is the number of valid elements in the container.</p>\n<p>Note that the big-O cost given for some operations reflects the current\nimplementation but is not guaranteed by the official documentation.\nHopefully it will not become worse. Anyway, if you want more details,\nyou should read the documentation about each of the modules. Often, it\nis also instructive to read the corresponding implementation.</p>\n<h2 id="lists-immutable-singly-linked-lists">Lists: immutable singly-linked lists</h2>\n<p>Adding an element always creates a new list l from an element x and list\ntl. tl remains unchanged, but it is not copied either.</p>\n<ul>\n<li>&quot;adding&quot; an element: O(1), cons operator <code>::</code>\n</li>\n<li>length: O(n), function <code>List.length</code>\n</li>\n<li>accessing cell <code>i</code>: O(i)\n</li>\n<li>finding an element: O(n)\n</li>\n</ul>\n<p>Well-suited for: IO, pattern-matching</p>\n<p>Not very efficient for: random access, indexed elements</p>\n<h2 id="arrays-mutable-vectors">Arrays: mutable vectors</h2>\n<p>Arrays are mutable data structures with a fixed length and random access.</p>\n<ul>\n<li>&quot;adding&quot; an element (by creating a new array): O(n)\n</li>\n<li>length: O(1), function <code>Array.length</code>\n</li>\n<li>accessing cell <code>i</code>: O(1)\n</li>\n<li>finding an element: O(n)\n</li>\n</ul>\n<p>Well-suited for sets of elements of known size, access by numeric index,\nin-place modification. Basic arrays have a fixed length.</p>\n<h2 id="strings-immutable-vectors">Strings: immutable vectors</h2>\n<p>Strings are very similar to arrays but are immutable. Strings are\nspecialized for storing chars (bytes) and have some convenient syntax.\nStrings have a fixed length. For extensible strings, the standard Buffer\nmodule can be used (see below).</p>\n<ul>\n<li>&quot;adding&quot; an element (by creating a new string): O(n)\n</li>\n<li>length: O(1)\n</li>\n<li>accessing character <code>i</code>: O(1)\n</li>\n<li>finding an element: O(n)\n</li>\n</ul>\n<h2 id="set-and-map-immutable-trees">Set and Map: immutable trees</h2>\n<p>Like lists, these are immutable and they may share some subtrees. They\nare a good solution for keeping older versions of sets of items.</p>\n<ul>\n<li>&quot;adding&quot; an element: O(log n)\n</li>\n<li>returning the number of elements: O(n)\n</li>\n<li>finding an element: O(log n)\n</li>\n</ul>\n<p>Sets and maps are very useful in compilation and meta-programming, but\nin other situations hash tables are often more appropriate (see below).</p>\n<h2 id="hashtbl-automatically-growing-hash-tables">Hashtbl: automatically growing hash tables</h2>\n<p>Ocaml hash tables are mutable data structures, which are a good solution\nfor storing (key, data) pairs in one single place.</p>\n<ul>\n<li>adding an element: O(1) if the initial size of the table is larger\nthan the number of elements it contains; O(log n) on average if n\nelements have been added in a table which is initially much smaller\nthan n.\n</li>\n<li>returning the number of elements: O(1)\n</li>\n<li>finding an element: O(1)\n</li>\n</ul>\n<h2 id="buffer-extensible-strings">Buffer: extensible strings</h2>\n<p>Buffers provide an efficient way to accumulate a sequence of bytes in a\nsingle place. They are mutable.</p>\n<ul>\n<li>adding a char: O(1) if the buffer is big enough, or O(log n) on\naverage if the initial size of the buffer was much smaller than the\nnumber of bytes n.\n</li>\n<li>adding a string of k chars: O(k * &quot;adding a char&quot;)\n</li>\n<li>length: O(1)\n</li>\n<li>accessing cell <code>i</code>: O(1)\n</li>\n</ul>\n<h2 id="queue">Queue</h2>\n<p>OCaml queues are mutable first-in-first-out (FIFO) data structures.</p>\n<ul>\n<li>adding an element: O(1)\n</li>\n<li>taking an element: O(1)\n</li>\n<li>length: O(1)\n</li>\n</ul>\n<h2 id="stack">Stack</h2>\n<p>OCaml stacks are mutable last-in-first-out (LIFO) data structures. They\nare just like lists, except that they are mutable, i.e. adding an\nelement doesn\'t create a new stack but simply adds it to the stack.</p>\n<ul>\n<li>adding an element: O(1)\n</li>\n<li>taking an element: O(1)\n</li>\n<li>length: O(1)\n</li>\n</ul>\n'},tl:0}}}}}}}}}}}}}}}}}}}}}}}}}}}},h={hd:{name:"Aesthetic Integration",slug:"aesthetic-integration",description:"Aesthetic Integration (AI) is a financial technology startup based in the City of London\n",image:"/users/aesthetic-integration.png",site:"https://www.aestheticintegration.com",locations:{hd:"United Kingdom",tl:0},consortium:!0,body_md:"\nAesthetic Integration (AI) is a financial technology startup based in the City of London. AI's patent-pending formal verification technology is revolutionising the safety, stability and transparency of global financial markets.\n",body_html:"<p>Aesthetic Integration (AI) is a financial technology startup based in the City of London. AI's patent-pending formal verification technology is revolutionising the safety, stability and transparency of global financial markets.</p>\n"},tl:{hd:{name:"Ahrefs",slug:"ahrefs",description:"Ahrefs develops custom distributed petabyte-scale storage and runs an internet-wide crawler to collect the index of the whole Web\n",image:"/users/ahrefs.png",site:"https://www.ahrefs.com",locations:{hd:"Singapore",tl:{hd:"United States",tl:0}},consortium:!0,body_md:"\nAhrefs develops custom distributed petabyte-scale storage and runs an internet-wide crawler to collect the index of the whole Web. On top of that the company is building various analytical services for end-users. OCaml is the main language of the Ahrefs backend, which is currently processing up to 6 billion pages a day. Ahrefs is a multinational team with roots from Ukraine and offices in Singapore and San Francisco.\n",body_html:"<p>Ahrefs develops custom distributed petabyte-scale storage and runs an internet-wide crawler to collect the index of the whole Web. On top of that the company is building various analytical services for end-users. OCaml is the main language of the Ahrefs backend, which is currently processing up to 6 billion pages a day. Ahrefs is a multinational team with roots from Ukraine and offices in Singapore and San Francisco.</p>\n"},tl:{hd:{name:"American Museum of Natural History",slug:"american-museum-of-natural-history",description:"The Computational Sciences Department at the AMNH has been using OCaml for almost a decade in their software package POY for phylogenetic inference\n",image:"/users/amnh.png",site:"https://www.amnh.org/our-research/computational-sciences",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nThe Computational Sciences Department at the AMNH has been using OCaml for almost a decade in their software package [POY](https://github.com/amnh/poy5) for phylogenetic inference. See [AMNH's GitHub page](https://github.com/AMNH) for more projects.\n",body_html:'<p>The Computational Sciences Department at the AMNH has been using OCaml for almost a decade in their software package <a href="https://github.com/amnh/poy5">POY</a> for phylogenetic inference. See <a href="https://github.com/AMNH">AMNH\'s GitHub page</a> for more projects.</p>\n'},tl:{hd:{name:"ANSSI",slug:"anssi",description:"The ANSSI core missions are: to detect and react to cyber attacks, to prevent threats, to provide advice and support to governmental entities and operators of critical infrastructure, and to keep companies and the general public informed about information security threats\n",image:"/users/anssi.png",site:"https://www.ssi.gouv.fr/",locations:{hd:"France",tl:0},consortium:!1,body_md:"\nThe ANSSI core missions are: to detect and react to cyber attacks, to prevent threats, to provide advice and support to governmental entities and operators of critical infrastructure, and to keep companies and the general public informed about information security threats. See [ANSII's GitHub page](https://github.com/anssi-fr) for some of its OCaml software.\n",body_html:'<p>The ANSSI core missions are: to detect and react to cyber attacks, to prevent threats, to provide advice and support to governmental entities and operators of critical infrastructure, and to keep companies and the general public informed about information security threats. See <a href="https://github.com/anssi-fr">ANSII\'s GitHub page</a> for some of its OCaml software.</p>\n'},tl:{hd:{name:"Arena",slug:"arena",description:"Arena helps organizations hire the right people.\n",image:"/users/arena.jpg",site:"https://www.arena.io",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nArena helps organizations hire the right people. We do that by applying big data and predictive analytics to the hiring process. This results in less turnover for our clients and less discrimination for individuals. We use OCaml for all of our backend development.",body_html:"<p>Arena helps organizations hire the right people. We do that by applying big data and predictive analytics to the hiring process. This results in less turnover for our clients and less discrimination for individuals. We use OCaml for all of our backend development.</p>\n"},tl:{hd:{name:"Be Sport",slug:"be-sport",description:"Be Sport's mission is to enhance the value that sport brings to our lives with appropriate use of digital and social media innovations\n",image:"/users/besport.png",site:"https://besport.com/",locations:{hd:"France",tl:0},consortium:!0,body_md:"\nBe Sport's mission is to enhance the value that sport brings to our lives with appropriate use of digital and social media innovations.\n           \nBe Sport is a 100% [OCaml](//ocaml.org/) and [OCsigen](https://ocsigen.org) project, leveraged as the only building blocks to develop the platform. \n",body_html:'<p>Be Sport\'s mission is to enhance the value that sport brings to our lives with appropriate use of digital and social media innovations.</p>\n<p>Be Sport is a 100% <a href="//ocaml.org/">OCaml</a> and <a href="https://ocsigen.org">OCsigen</a> project, leveraged as the only building blocks to develop the platform.</p>\n'},tl:{hd:{name:"Bloomberg L.P.",slug:"bloomberg-lp",description:"Bloomberg, the global business and financial information and news leader, gives influential decision makers a critical edge by connecting them to a dynamic network of information, people and ideas\n",image:"/users/bloomberg.jpg",site:"https://www.bloomberg.com",locations:{hd:"United States",tl:0},consortium:!0,body_md:"\nBloomberg, the global business and financial information and news leader, gives influential decision makers a critical edge by connecting them to a dynamic network of information, people and ideas. Bloomberg employs OCaml in an advanced financial derivatives risk management application delivered through its Bloomberg Professional service.",body_html:"<p>Bloomberg, the global business and financial information and news leader, gives influential decision makers a critical edge by connecting them to a dynamic network of information, people and ideas. Bloomberg employs OCaml in an advanced financial derivatives risk management application delivered through its Bloomberg Professional service.</p>\n"},tl:{hd:{name:"CACAOWEB",slug:"cacaoweb",description:"Cacaoweb is developing an application platform of a new kind. It runs on top of our peer-to-peer network, which happens to be one of the largest in the world\n",image:"/users/cacaoweb.png",site:"https://cacaoweb.org/",locations:{hd:"United Kingdom",tl:{hd:"Hong Kong",tl:0}},consortium:!1,body_md:"\nCacaoweb is developing an application platform of a new kind. It runs on top of our peer-to-peer network, which happens to be one of the largest in the world. The capabilities of the platform are diverse and range from multimedia streaming to social communication, offline storage or data synchronisation. We design and implement massively distributed data stores, programming languages, runtime systems and parallel computation frameworks.\n",body_html:"<p>Cacaoweb is developing an application platform of a new kind. It runs on top of our peer-to-peer network, which happens to be one of the largest in the world. The capabilities of the platform are diverse and range from multimedia streaming to social communication, offline storage or data synchronisation. We design and implement massively distributed data stores, programming languages, runtime systems and parallel computation frameworks.</p>\n"},tl:{hd:{name:"CEA",slug:"cea",description:"CEA is a French state company, member of the OCaml Consortium.\n",image:"/users/cea.png",site:"https://cea.fr/",locations:{hd:"France",tl:0},consortium:!0,body_md:"\nCEA is a French state company, member of the OCaml Consortium. It uses OCaml mainly to develop a platform dedicated to source-code analysis of C software, called [Frama-C](https://frama-c.com).\n",body_html:'<p>CEA is a French state company, member of the OCaml Consortium. It uses OCaml mainly to develop a platform dedicated to source-code analysis of C software, called <a href="https://frama-c.com">Frama-C</a>.</p>\n'},tl:{hd:{name:"Citrix",slug:"citrix",description:"Citrix uses OCaml in XenServer, a world-class server virtualization system.\n",image:"/users/citrix.png",site:"https://www.citrix.com",locations:{hd:"United Kingdom",tl:0},consortium:!0,body_md:"\nCitrix uses OCaml in XenServer, a world-class server virtualization system. Most components of XenServer are released as open source. The open-source XenServer toolstack components implemented in OCaml are bundled in the [XS-opam](https://github.com/xapi-project/xs-opam) repository on GitHub.\n",body_html:'<p>Citrix uses OCaml in XenServer, a world-class server virtualization system. Most components of XenServer are released as open source. The open-source XenServer toolstack components implemented in OCaml are bundled in the <a href="https://github.com/xapi-project/xs-opam">XS-opam</a> repository on GitHub.</p>\n'},tl:{hd:{name:"Coherent Graphics Ltd",slug:"coherent-graphics-ltd",description:"Coherent Graphics is a developer of both server tools and desktop software for the processing of PDF documents\n",image:"/users/coherent.png",site:"https://www.coherentpdf.com/",locations:{hd:"United Kingdom",tl:0},consortium:!1,body_md:"\nCoherent Graphics is a developer of both server tools and desktop software for the processing of PDF documents. We use OCaml as a general-purpose high level language, chosen for its expressiveness and speed.\n",body_html:"<p>Coherent Graphics is a developer of both server tools and desktop software for the processing of PDF documents. We use OCaml as a general-purpose high level language, chosen for its expressiveness and speed.</p>\n"},tl:{hd:{name:"Cryptosense",slug:"cryptosense",description:"Cryptosense creates security analysis software with a particular focus on cryptographic systems\n",image:"/users/cryptosense.png",site:"https://www.cryptosense.com/",locations:{hd:"France",tl:0},consortium:!1,body_md:"\nBased in Paris, France, Cryptosense creates security analysis software with a particular focus on cryptographic systems. A spin-off of the institute for computer science research (Inria), Cryptosense\u2019s founders combine more than 40 years experience in research and industry. Cryptosense provides its solutions to an international client\xe8le in particular in the financial, industrial and government sectors.\n",body_html:"<p>Based in Paris, France, Cryptosense creates security analysis software with a particular focus on cryptographic systems. A spin-off of the institute for computer science research (Inria), Cryptosense\u2019s founders combine more than 40 years experience in research and industry. Cryptosense provides its solutions to an international client\xe8le in particular in the financial, industrial and government sectors.</p>\n"},tl:{hd:{name:"Dassault Syst\xe8mes",slug:"dassault-systmes",description:"Dassault Syst\xe8mes, the 3DEXPERIENCE Company, provides businesses and people with virtual universes to imagine sustainable innovations.\n",image:"/users/dassault.png",site:"https://www.3ds.com/fr/",locations:{hd:"France",tl:0},consortium:!1,body_md:"\nDassault Syst\xe8mes, the 3DEXPERIENCE Company, provides businesses and people with virtual universes to imagine sustainable innovations.\n",body_html:"<p>Dassault Syst\xe8mes, the 3DEXPERIENCE Company, provides businesses and people with virtual universes to imagine sustainable innovations.</p>\n"},tl:{hd:{name:"Dernier Cri",slug:"dernier-cri",description:"Dernier Cri is a French company based in Lille and Paris using functional programming to develop web and mobile applications.\n",image:"/users/derniercri.png",site:"https://derniercri.io",locations:{hd:"France",tl:0},consortium:!1,body_md:"\nDernier Cri is a French company based in Lille and Paris using functional programming to develop web and mobile applications. OCaml is principally used to develop internal tools.\n",body_html:"<p>Dernier Cri is a French company based in Lille and Paris using functional programming to develop web and mobile applications. OCaml is principally used to develop internal tools.</p>\n"},tl:{hd:{name:"Digirati dba Hostnet",slug:"digirati-dba-hostnet",description:"Digirati dba Hostnet is a web hosting company.\n",image:"/users/hostnet.gif",site:"https://www.hostnet.com.br/",locations:{hd:"Brazil",tl:0},consortium:!1,body_md:"\nDigirati dba Hostnet is a web hosting company. We use OCaml mostly for internal systems programming and infrastructure services. We have also contributed to the community by releasing a few open source [OCaml libraries](https://github.com/andrenth).\n",body_html:'<p>Digirati dba Hostnet is a web hosting company. We use OCaml mostly for internal systems programming and infrastructure services. We have also contributed to the community by releasing a few open source <a href="https://github.com/andrenth">OCaml libraries</a>.</p>\n'},tl:{hd:{name:"Docker, Inc.",slug:"docker-inc",description:"Docker provides an integrated technology suite that enables development and IT operations teams to build, ship, and run distributed applications anywhere\n",image:"/users/docker.png",site:"https://www.docker.com",locations:{hd:"United States",tl:0},consortium:!0,body_md:"\nDocker provides an integrated technology suite that enables development and IT operations teams to build, ship, and run distributed applications anywhere. Their native [applications for Mac and Windows](https://blog.docker.com/2016/03/docker-for-mac-windows-beta/), use OCaml code taken from the [MirageOS](https://mirage.io) library operating system project. ",body_html:'<p>Docker provides an integrated technology suite that enables development and IT operations teams to build, ship, and run distributed applications anywhere. Their native <a href="https://blog.docker.com/2016/03/docker-for-mac-windows-beta/">applications for Mac and Windows</a>, use OCaml code taken from the <a href="https://mirage.io">MirageOS</a> library operating system project.</p>\n'},tl:{hd:{name:"Esterel Technologies",slug:"esterel-technologies",description:"Esterel Technologies is a leading provider of critical systems and software development solutions for the aerospace, defense, rail transportation, nuclear, and industrial and automotive domains\n",image:"/users/esterel.jpg",site:"https://www.esterel-technologies.com/",locations:{hd:"France",tl:0},consortium:!0,body_md:"\nEsterel Technologies is a leading provider of critical systems and software development solutions for the aerospace, defense, rail transportation, nuclear, and industrial and automotive domains.\n",body_html:"<p>Esterel Technologies is a leading provider of critical systems and software development solutions for the aerospace, defense, rail transportation, nuclear, and industrial and automotive domains.</p>\n"},tl:{hd:{name:"Facebook",slug:"facebook",description:"Facebook has built a number of major development tools using OCaml",image:"/users/facebook.png",site:"https://www.facebook.com/",locations:{hd:"United States",tl:0},consortium:!0,body_md:"\nFacebook has built a number of major development tools using OCaml. [Hack](https://hacklang.org) is a compiler for a variant of PHP that aims to reconcile the fast development cycle of PHP with the discipline provided by static typing. [Flow](https://flowtype.org) is a similar project that provides static type checking for Javascript.  Both systems are highly responsive, parallel programs that can incorporate source code changes in real time. [Pfff](https://github.com/facebook/pfff/wiki/Main) is a set of tools for code analysis, visualizations, and style-preserving source transformations, written in OCaml, but supporting many languages.",body_html:'<p>Facebook has built a number of major development tools using OCaml. <a href="https://hacklang.org">Hack</a> is a compiler for a variant of PHP that aims to reconcile the fast development cycle of PHP with the discipline provided by static typing. <a href="https://flowtype.org">Flow</a> is a similar project that provides static type checking for Javascript.  Both systems are highly responsive, parallel programs that can incorporate source code changes in real time. <a href="https://github.com/facebook/pfff/wiki/Main">Pfff</a> is a set of tools for code analysis, visualizations, and style-preserving source transformations, written in OCaml, but supporting many languages.</p>\n'},tl:{hd:{name:"Fasoo",slug:"fasoo",description:"Fasoo uses OCaml to develop a static analysis tool.\n",image:"/users/fasoo.png",site:"https://www.fasoo.com",locations:{hd:"Korea",tl:0},consortium:!1,body_md:"\nFasoo uses OCaml to develop a static analysis tool.\n",body_html:"<p>Fasoo uses OCaml to develop a static analysis tool.</p>\n"},tl:{hd:{name:"Flying Frog Consultancy",slug:"flying-frog-consultancy",description:"Flying Frog Consultancy Ltd. consult and write books and software on the use of OCaml in the context of scientific computing.\n",image:"/users/flying-frog.png",site:"https://www.ffconsultancy.com",locations:{hd:"United Kingdom",tl:0},consortium:!1,body_md:"\nFlying Frog Consultancy Ltd. consult and write books and software on the use of OCaml in the context of scientific computing. OCaml excels in the niche of intrinsically complicated programs between large-scale, array-based programs written in languages such as HPF and small-scale, graphical programs written in languages such as Mathematica.\n",body_html:"<p>Flying Frog Consultancy Ltd. consult and write books and software on the use of OCaml in the context of scientific computing. OCaml excels in the niche of intrinsically complicated programs between large-scale, array-based programs written in languages such as HPF and small-scale, graphical programs written in languages such as Mathematica.</p>\n"},tl:{hd:{name:"ForAllSecure",slug:"forallsecure",description:"ForAllSecure's mission is to test the world's software and provide actionable information to our customers.\n",image:"/users/forallsecure.svg",site:"https://forallsecure.com",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nForAllSecure's mission is to test the world's software and provide actionable information to our customers. We have started with Linux. Our mission with Linux is to test all programs in current distributions, such as Debian, Ubuntu, and Red Hat. With time, we will cover other platforms, such as Mac, Windows, and mobile. In the meantime, we promise to do one thing well.\n",body_html:"<p>ForAllSecure's mission is to test the world's software and provide actionable information to our customers. We have started with Linux. Our mission with Linux is to test all programs in current distributions, such as Debian, Ubuntu, and Red Hat. With time, we will cover other platforms, such as Mac, Windows, and mobile. In the meantime, we promise to do one thing well.</p>\n"},tl:{hd:{name:"Framtidsforum",slug:"framtidsforum",description:"Framtidsforum I&M sells ExcelEverywhere, which creates web pages that look and function the same as your MS Excel spreadsheet\n",image:void 0,site:"https://www.exceleverywhere.com",locations:{hd:"Sweden",tl:0},consortium:!1,body_md:"\nFramtidsforum I&M sells ExcelEverywhere, which creates web pages that look and function the same as your MS Excel spreadsheet. JavaScript is used for calculation. Supports 140 Excel-functions. Typically used for expense report, survey, order forms, reservation forms, employment application, financial advisor, ROI. There are also versions that generate ASP, ASP.NET and JSP/Java code. The compiler is written using OCaml.\n",body_html:"<p>Framtidsforum I&amp;M sells ExcelEverywhere, which creates web pages that look and function the same as your MS Excel spreadsheet. JavaScript is used for calculation. Supports 140 Excel-functions. Typically used for expense report, survey, order forms, reservation forms, employment application, financial advisor, ROI. There are also versions that generate ASP, ASP.NET and JSP/Java code. The compiler is written using OCaml.</p>\n"},tl:{hd:{name:"Galois",slug:"galois",description:"Galois has developed a domain specific declarative language for cryptographic algorithms.\n",image:"/users/galois.png",site:"https://www.galois.com",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nGalois has developed a domain specific declarative language for cryptographic algorithms. One of our research compilers is written in OCaml and makes very extensive use of camlp4.\n",body_html:"<p>Galois has developed a domain specific declarative language for cryptographic algorithms. One of our research compilers is written in OCaml and makes very extensive use of camlp4.</p>\n"},tl:{hd:{name:"Incubaid",slug:"incubaid",description:"Incubaid has developed Arakoon, a distributed key-value store that guarantees consistency above anything else.\n",image:"/users/Incubaid.png",site:"https://incubaid.com",locations:{hd:"Belgium",tl:0},consortium:!1,body_md:'\nIncubaid has developed <a href="https://github.com/Incubaid/arakoon">Arakoon</a>, a distributed key-value store that guarantees consistency above anything else. We created Arakoon due to a lack of existing solutions fitting our requirements, and is available as Open Source software.\n\n',body_html:'<p>Incubaid has developed <a href="https://github.com/Incubaid/arakoon">Arakoon</a>, a distributed key-value store that guarantees consistency above anything else. We created Arakoon due to a lack of existing solutions fitting our requirements, and is available as Open Source software.</p>\n'},tl:{hd:{name:"Issuu",slug:"issuu",description:"Issuu is a digital publishing platform delivering exceptional reading experiences of magazines, catalogues, and newspapers\n",image:"/users/issuu.gif",site:"https://issuu.com",locations:{hd:"Denmark",tl:0},consortium:!1,body_md:"\nIssuu is a digital publishing platform delivering exceptional reading experiences of magazines, catalogues, and newspapers. Each month Issuu serves over 6 billion page views and 60 million users through their worldwide network. OCaml is used as part of the server-side systems, platforms, and web applications. The backend team is relatively small and the simplicity and scalability of both systems and processes are of vital importance.\n",body_html:"<p>Issuu is a digital publishing platform delivering exceptional reading experiences of magazines, catalogues, and newspapers. Each month Issuu serves over 6 billion page views and 60 million users through their worldwide network. OCaml is used as part of the server-side systems, platforms, and web applications. The backend team is relatively small and the simplicity and scalability of both systems and processes are of vital importance.</p>\n"},tl:{hd:{name:"Jane Street",slug:"jane-street",description:"Jane Street is a quantitative trading firm that operates around the clock and around the globe\n",image:"/users/jane-street.jpg",site:"https://janestreet.com",locations:{hd:"United States",tl:{hd:"United Kingdom",tl:{hd:"Hong Kong",tl:0}}},consortium:!0,body_md:"\nJane Street is a quantitative trading firm that operates around the clock and around the globe. They bring a deep understanding of markets, a scientific approach, and innovative technology to bear on the problem of trading profitably in the world's highly competitive financial markets. They're the largest commercial user of OCaml, using it for everything from research tools to trading systems to systems infrastructure to accounting systems. Jane Street has over 400 OCaml programmers and over 15 million lines of OCaml, powering a technology platform that trades billions of dollars every day. Half a million lines of their code are released [open source](https://opensource.janestreet.com), and they've created key parts of the open-source OCaml ecosystem, like [Dune](https://dune.build). You can learn more by checking out their [tech blog](https://blog.janestreet.com).\n",body_html:'<p>Jane Street is a quantitative trading firm that operates around the clock and around the globe. They bring a deep understanding of markets, a scientific approach, and innovative technology to bear on the problem of trading profitably in the world\'s highly competitive financial markets. They\'re the largest commercial user of OCaml, using it for everything from research tools to trading systems to systems infrastructure to accounting systems. Jane Street has over 400 OCaml programmers and over 15 million lines of OCaml, powering a technology platform that trades billions of dollars every day. Half a million lines of their code are released <a href="https://opensource.janestreet.com">open source</a>, and they\'ve created key parts of the open-source OCaml ecosystem, like <a href="https://dune.build">Dune</a>. You can learn more by checking out their <a href="https://blog.janestreet.com">tech blog</a>.</p>\n'},tl:{hd:{name:"Kernelize",slug:"kernelize",description:"Kernelyze has developed a novel approximation of two-variable functions that achieves the smallest possible worst-case error among all rank-n approximations.\n",image:"/users/kernelyze-llc-logo.png",site:"https://kernelyze.com/",locations:{hd:"United States",tl:0},consortium:!0,body_md:"\n\nKernelyze has developed a novel approximation of two-variable functions\nthat achieves the smallest possible worst-case error among all rank-n\napproximations.",body_html:"<p>Kernelyze has developed a novel approximation of two-variable functions\nthat achieves the smallest possible worst-case error among all rank-n\napproximations.</p>\n"},tl:{hd:{name:"Kong",slug:"kong",description:"Kong makes it easy to distribute, monetize, manage and consume cloud APIs.\n",image:"/users/mashape.png",site:"https://www.konghq.com",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nKong makes it easy to distribute, monetize, manage and consume cloud APIs. Mashape is building a world-class marketplace for cloud APIs driven by a passionate community of developers from all over the world as well as enterprise API management and analytics products. We use OCaml in our [APIAnalytics](https://apianalytics.com) product \u2014 as part of a mission-critical, lightweight HTTP proxy.\n",body_html:'<p>Kong makes it easy to distribute, monetize, manage and consume cloud APIs. Mashape is building a world-class marketplace for cloud APIs driven by a passionate community of developers from all over the world as well as enterprise API management and analytics products. We use OCaml in our <a href="https://apianalytics.com">APIAnalytics</a> product \u2014 as part of a mission-critical, lightweight HTTP proxy.</p>\n'},tl:{hd:{name:"LexiFi",slug:"lexifi",description:"LexiFi is an innovative provider of software applications and infrastructure technology for the capital markets industry.\n",image:"/users/lexifi.png",site:"https://www.janestreet.com",locations:{hd:"France",tl:0},consortium:!0,body_md:"\nLexiFi is an innovative provider of software applications and infrastructure technology for the capital markets industry. LexiFi Apropos is powered by an original formalism for describing financial contracts, the result of a long-term research and development effort.",body_html:"<p>LexiFi is an innovative provider of software applications and infrastructure technology for the capital markets industry. LexiFi Apropos is powered by an original formalism for describing financial contracts, the result of a long-term research and development effort.</p>\n"},tl:{hd:{name:"Matrix Lead",slug:"matrix-lead",description:"Matrix Lead provides professionals and companies with leading technologies and solutions for spreadsheets. \n",image:"/users/matrixlead.png",site:"https://www.matrixlead.com",locations:{hd:"France",tl:{hd:"China",tl:0}},consortium:!1,body_md:"\nMatrix Lead provides professionals and companies with leading technologies and solutions for spreadsheets. We create a range of software to help users better build, verify, optimize and manage their spreadsheets. Our flagship product [10 Studio](https://www.10studio.tech) is a Microsoft Excel add-in that combines our several advanced tools, such as formula editor and spreadsheet verificator. The kernel of our tools is an analyzer that analyzes different properties of spreadsheets (including formulas and VBA macros) especially by abstract interpretation-based static analysis. It was initially developed in the Antiques team of Inria and written in OCaml. Then, we wrap web or .NET languages around the analyzer to make ready-to-use tools.\n",body_html:'<p>Matrix Lead provides professionals and companies with leading technologies and solutions for spreadsheets. We create a range of software to help users better build, verify, optimize and manage their spreadsheets. Our flagship product <a href="https://www.10studio.tech">10 Studio</a> is a Microsoft Excel add-in that combines our several advanced tools, such as formula editor and spreadsheet verificator. The kernel of our tools is an analyzer that analyzes different properties of spreadsheets (including formulas and VBA macros) especially by abstract interpretation-based static analysis. It was initially developed in the Antiques team of Inria and written in OCaml. Then, we wrap web or .NET languages around the analyzer to make ready-to-use tools.</p>\n'},tl:{hd:{name:"MEDIT",slug:"medit",description:"MEDIT develops SuMo, an advanced bioinformatic system, for the analysis of protein 3D structures and the identification of drug-design targets. \n",image:"/users/medit.jpg",site:"https://www.medit-pharma.com/",locations:{hd:"France",tl:0},consortium:!1,body_md:'\nMEDIT develops [SuMo, an advanced bioinformatic system]("https://mjambon.com/") for the analysis of protein 3D structures and the identification of drug-design targets. SuMo is written entirely in OCaml and provides interfaces to several commercial molecular-modeling packages.\n',body_html:'<p>MEDIT develops <a href="%22https://mjambon.com/%22">SuMo, an advanced bioinformatic system</a> for the analysis of protein 3D structures and the identification of drug-design targets. SuMo is written entirely in OCaml and provides interfaces to several commercial molecular-modeling packages.</p>\n'},tl:{hd:{name:"Microsoft",slug:"microsoft",description:"Facebook has built a number of major development tools using OCaml\n",image:"/users/microsoft.png",site:"https://www.microsoft.com",locations:{hd:"United States",tl:0},consortium:!0,body_md:"\n",body_html:""},tl:{hd:{name:"Mount Sinai",slug:"mount-sinai",description:"The Hammer Lab at Mount Sinai develops and uses Ketrew for managing complex bioinformatics workflows.\n",image:"/users/mount-sinai.png",site:"https://www.mountsinai.org",locations:{hd:"United States",tl:0},consortium:!1,body_md:'\nThe [Hammer Lab]("https://www.hammerlab.org") at Mount Sinai develops and uses [Ketrew]("https://github.com/hammerlab/ketrew") for managing complex bioinformatics workflows. Ketrew includes an embedded domain-specific language to simplify the specification of workflows and an engine for the execution of workflows. Ketrew can be run as a command-line application or as a service.\n',body_html:'<p>The <a href="%22https://www.hammerlab.org%22">Hammer Lab</a> at Mount Sinai develops and uses <a href="%22https://github.com/hammerlab/ketrew%22">Ketrew</a> for managing complex bioinformatics workflows. Ketrew includes an embedded domain-specific language to simplify the specification of workflows and an engine for the execution of workflows. Ketrew can be run as a command-line application or as a service.</p>\n'},tl:{hd:{name:"Mr. Number",slug:"mr-number",description:"Mr. Number started as a Silicon Valley startup and developed the Mr. Number app for call blocking, later acquired by WhitePages.\n",image:"/users/mrnumber.jpg",site:"https://mrnumber.com/",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nMr. Number started as a Silicon Valley startup and developed the Mr. Number app for call blocking, later [acquired by WhitePages](https://allthingsd.com/20130601/whitepages-scoops-up-mr-number-an-android-app-for-blocking-unwanted-calls/). OCaml is used on the server-side as the glue between the various third-party components and services.</p>\n",body_html:'<p>Mr. Number started as a Silicon Valley startup and developed the Mr. Number app for call blocking, later <a href="https://allthingsd.com/20130601/whitepages-scoops-up-mr-number-an-android-app-for-blocking-unwanted-calls/">acquired by WhitePages</a>. OCaml is used on the server-side as the glue between the various third-party components and services.</p></p>\n'},tl:{hd:{name:"MyLife",slug:"mylife",description:"MyLife has developed a powerful people search tool that will empower those in need to find anyone, regardless of years past and the life that was built in between.\n",image:"/users/mylife.jpg",site:"https://www.mylife.com/",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nMyLife has developed a powerful people search tool that will empower those in need to find anyone, regardless of years past and the life that was built in between.",body_html:"<p>MyLife has developed a powerful people search tool that will empower those in need to find anyone, regardless of years past and the life that was built in between.</p>\n"},tl:{hd:{name:"Narrow Gate Logic",slug:"narrow-gate-logic",description:"Narrow Gate Logic is a company using the OCaml language in business and non-business applications.\n",image:"/users/nglogic.png",site:"https://nglogic.com",locations:{hd:"Poland",tl:0},consortium:!1,body_md:"\nNarrow Gate Logic is a company using the OCaml language in business and non-business applications.\n",body_html:"<p>Narrow Gate Logic is a company using the OCaml language in business and non-business applications.</p>\n"},tl:{hd:{name:"Nomadic Labs",slug:"nomadic-labs",description:"Nomadic Labs houses a team focused on Research and Development. Our core competencies are in programming language theory and practice, distributed systems, and formal verification.\n",image:"/users/nomadic-labs.png",site:"https://www.nomadic-labs.com",locations:{hd:"Paris, France",tl:0},consortium:!1,body_md:"\nNomadic Labs houses a team focused on Research and Development. Our\ncore competencies are in programming language theory and practice,\ndistributed systems, and formal verification. Nomadic Labs focuses on\ncontributing to the development of the Tezos core software, including\nthe smart-contract language, Michelson.\n\nTezos infrastructure is entirely implemented in OCaml. It strongly\nrelies on OCaml efficiency and expressivity. For instance, Michelson\nsmart contracts are represented using OCaml GADTs to prevent many\nruntime errors from happening. Safety and correctness are critical for a\nblockchain and we are glad that the OCaml type system allows for a\nform of a lightweight formal method that can be used on a daily basis.\n",body_html:"<p>Nomadic Labs houses a team focused on Research and Development. Our\ncore competencies are in programming language theory and practice,\ndistributed systems, and formal verification. Nomadic Labs focuses on\ncontributing to the development of the Tezos core software, including\nthe smart-contract language, Michelson.</p>\n<p>Tezos infrastructure is entirely implemented in OCaml. It strongly\nrelies on OCaml efficiency and expressivity. For instance, Michelson\nsmart contracts are represented using OCaml GADTs to prevent many\nruntime errors from happening. Safety and correctness are critical for a\nblockchain and we are glad that the OCaml type system allows for a\nform of a lightweight formal method that can be used on a daily basis.</p>\n"},tl:{hd:{name:"OCamlPro",slug:"ocamlpro",description:"OCamlPro develops and maintains a development environment for the OCaml language.\n",image:"/users/ocamlpro.png",site:"https://www.ocamlpro.com",locations:{hd:"France",tl:0},consortium:!0,body_md:"\nOCamlPro develops and maintains a development environment for the OCaml language. They provide services for companies deciding to use OCaml. Among these services: trainings, necessary expertise, tools and libraries long-term support, and specific developments to their applicative domains.",body_html:"<p>OCamlPro develops and maintains a development environment for the OCaml language. They provide services for companies deciding to use OCaml. Among these services: trainings, necessary expertise, tools and libraries long-term support, and specific developments to their applicative domains.</p>\n"},tl:{hd:{name:"PRUDENT Technologies and Consulting, Inc.",slug:"prudent-technologies-and-consulting-inc",description:"Prudent Consulting offers IT solutions to large and mid-sized organizations by combining industry experience and technology expertise to help our customers achieve business goals with speed, agility, and great impact.\n",image:"/users/prudent.jpg",site:"https://www.prudentconsulting.com",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nPrudent Consulting offers IT solutions to large and mid-sized organizations by combining industry experience and technology expertise to help our customers achieve business goals with speed, agility, and great impact.\n",body_html:"<p>Prudent Consulting offers IT solutions to large and mid-sized organizations by combining industry experience and technology expertise to help our customers achieve business goals with speed, agility, and great impact.</p>\n"},tl:{hd:{name:"Psellos",slug:"psellos",description:"Psellos is a small group of computer scientists who became intrigued by the idea of coding iOS apps in OCaml.\n",image:"/users/psellos.png",site:"https://www.psellos.com",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nPsellos is a small group of computer scientists who became intrigued by the idea of coding iOS apps in OCaml. It has worked out better than we expected (you can buy our apps in the iTunes App Store), and at least one other company sells apps built with our tools. Our most recent iOS cross compiler is derived from OCaml 4.00.0.",body_html:"<p>Psellos is a small group of computer scientists who became intrigued by the idea of coding iOS apps in OCaml. It has worked out better than we expected (you can buy our apps in the iTunes App Store), and at least one other company sells apps built with our tools. Our most recent iOS cross compiler is derived from OCaml 4.00.0.</p>\n"},tl:{hd:{name:"Sakhalin",slug:"sakhalin",description:"Sakhalin develops marine charting apps for Apple iPads and iPhones.\n",image:void 0,site:"https://www.seaiq.com",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nSakhalin develops marine charting apps for Apple iPads and iPhones. The full-featured apps display marine charts, GPS and onboard sensor data, Automatic Identification System, weather data, anchor monitoring, etc. The apps have a wide range of users, from occasional recreational boaters to professional river/harbor pilots that board large freighters. They are free to download and try (with a paid upgrade to enable all features). They are written almost entirely in Ocaml with a minor amount of glue to interface with IOS APIs. Ocaml was chosen because it\n\n 1. enables the rapid development of extremely reliable and high-performance software,\n 2. is a mature stable platform\n 3. has a wide range of libraries. \n \nIt was made possible by the great work done by Psellos in porting OCaml to the Apple iOS platform. Feel free to contact Sakhalin if you have any questions about using OCaml on iOS.",body_html:"<p>Sakhalin develops marine charting apps for Apple iPads and iPhones. The full-featured apps display marine charts, GPS and onboard sensor data, Automatic Identification System, weather data, anchor monitoring, etc. The apps have a wide range of users, from occasional recreational boaters to professional river/harbor pilots that board large freighters. They are free to download and try (with a paid upgrade to enable all features). They are written almost entirely in Ocaml with a minor amount of glue to interface with IOS APIs. Ocaml was chosen because it</p>\n<ol>\n<li>enables the rapid development of extremely reliable and high-performance software,\n</li>\n<li>is a mature stable platform\n</li>\n<li>has a wide range of libraries.\n</li>\n</ol>\n<p>It was made possible by the great work done by Psellos in porting OCaml to the Apple iOS platform. Feel free to contact Sakhalin if you have any questions about using OCaml on iOS.</p>\n"},tl:{hd:{name:"Shiro Games",slug:"shiro-games",description:"Shiro Games is developing games using Haxe, a language built with a compiler written in OCaml.\n",image:"/users/shirogames.png",site:"https://www.shirogames.com",locations:{hd:"France",tl:0},consortium:!1,body_md:"\nShiro Games is developing games using [Haxe](https://haxe.org/), a language built with a compiler written in OCaml.",body_html:'<p>Shiro Games is developing games using <a href="https://haxe.org/">Haxe</a>, a language built with a compiler written in OCaml.</p>\n'},tl:{hd:{name:"SimCorp",slug:"simcorp",description:"Multi-asset platform to support investment decision-making and innovation.\n",image:"/users/simcorp.png",site:"https://www.simcorp.com/",locations:{hd:"United States",tl:0},consortium:!0,body_md:"\nMulti-asset platform to support investment decision-making and innovation.\n",body_html:"<p>Multi-asset platform to support investment decision-making and innovation.</p>\n"},tl:{hd:{name:"Sleekersoft",slug:"sleekersoft",description:"Specialises in functional programming software development, consultation, and training.\n",image:"/users/sleekersoft.png",site:"https://www.sleekersoft.com",locations:{hd:"Australia",tl:0},consortium:!1,body_md:"\nShiro Games is developing games using [Haxe](https://haxe.org/), a language built with a compiler written in OCaml.",body_html:'<p>Shiro Games is developing games using <a href="https://haxe.org/">Haxe</a>, a language built with a compiler written in OCaml.</p>\n'},tl:{hd:{name:"Solvuu",slug:"solvuu",description:"Solvuu's software allows users to store big and small data sets, share the data with collaborators, execute computationally intensive algorithms and workflows, and visualize results.\n",image:"/users/solvuu.jpg",site:"https://www.solvuu.com",locations:{hd:"United States",tl:0},consortium:!1,body_md:"\nSolvuu's software allows users to store big and small data sets, share the data with collaborators, execute computationally intensive algorithms and workflows, and visualize results. Its initial focus is on genomics data, which has important implications for healthcare, agriculture, and fundamental research. Virtually all of Solvuu's software stack is implemented in OCaml.\n",body_html:"<p>Solvuu's software allows users to store big and small data sets, share the data with collaborators, execute computationally intensive algorithms and workflows, and visualize results. Its initial focus is on genomics data, which has important implications for healthcare, agriculture, and fundamental research. Virtually all of Solvuu's software stack is implemented in OCaml.</p>\n"},tl:{hd:{name:"Studio Associato 4Sigma",slug:"studio-associato-4sigma",description:"4Sigma is a small firm making websites and some interesting web applications.\n",image:"/users/4sigma.png",site:"https://www.4sigma.it",locations:{hd:"Italy",tl:0},consortium:!1,body_md:"\n4Sigma is a small firm making websites and some interesting web applications. OCaml is not the main language used but it is used here and there, particularly in a small server that is a key component of a service we offer our customers.",body_html:"<p>4Sigma is a small firm making websites and some interesting web applications. OCaml is not the main language used but it is used here and there, particularly in a small server that is a key component of a service we offer our customers.</p>\n"},tl:{hd:{name:"Tarides",slug:"tarides",description:"Tarides builds and maintains open-source infrastructure tools in OCaml like MirageOS, Irmin and OCaml developer tools.\n",image:"/users/tarides.png",site:"https://www.tarides.com",locations:{hd:"France",tl:0},consortium:!1,body_md:'\nWe are building and maintaining open-source infrastructure tools in OCaml:\n\n - [MirageOS](https://mirage.io), the most advanced unikernel project, where we build sandboxes, network and storage protocol implementations as libraries, so we can link them to our applications to run them without the need of an underlying operating system.\n - [Irmin]("https://irmin.org"), a Git-like datastore, which allows us to create fully auditable distributed systems which can work offline and be synced when needed.\n - OCaml development tools (build system, code linters, documentation generators, etc), to make us more efficient. \n  \nTarides was founded in early 2018 and is mainly based in Paris, France (remote work is possible).\n\n',body_html:'<p>We are building and maintaining open-source infrastructure tools in OCaml:</p>\n<ul>\n<li><a href="https://mirage.io">MirageOS</a>, the most advanced unikernel project, where we build sandboxes, network and storage protocol implementations as libraries, so we can link them to our applications to run them without the need of an underlying operating system.\n</li>\n<li><a href="%22https://irmin.org%22">Irmin</a>, a Git-like datastore, which allows us to create fully auditable distributed systems which can work offline and be synced when needed.\n</li>\n<li>OCaml development tools (build system, code linters, documentation generators, etc), to make us more efficient.\n</li>\n</ul>\n<p>Tarides was founded in early 2018 and is mainly based in Paris, France (remote work is possible).</p>\n'},tl:{hd:{name:"TrustInSoft",slug:"trustinsoft",description:"TrustInSoft is a company that changes the rules in cybersecurity. TrustInSoft is the software publisher of the software analysis Frama-C platform. \n",image:"/users/trustinsoft.png",site:"https://trust-in-soft.com",locations:{hd:"France",tl:0},consortium:!1,body_md:"\nTrustInSoft is a company that changes the rules in cybersecurity. TrustInSoft is the software publisher of the software analysis [Frama-C](https://frama-c.com) platform. Our motto is simple: make the formal methods accessible to the majority of software developers.",body_html:'<p>TrustInSoft is a company that changes the rules in cybersecurity. TrustInSoft is the software publisher of the software analysis <a href="https://frama-c.com">Frama-C</a> platform. Our motto is simple: make the formal methods accessible to the majority of software developers.</p>\n'},tl:{hd:{name:"Wolfram MathCore",slug:"wolfram-mathcore",description:"Wolfram MathCore uses OCaml to implement its SystemModeler kernel.\n",image:"/users/wolfram-mathcore.gif",site:"https://www.wolframmathcore.com",locations:{hd:"Sweden",tl:0},consortium:!1,body_md:"\nWolfram MathCore uses OCaml to implement its SystemModeler kernel. The kernel's main function is to translate models defined in the Modelica language into executable simulation code. This involves parsing and transforming Modelica code, mathematical processing of equations, code generation of C/C++ simulation code, and numerical runtime computations.\n",body_html:"<p>Wolfram MathCore uses OCaml to implement its SystemModeler kernel. The kernel's main function is to translate models defined in the Modelica language into executable simulation code. This involves parsing and transforming Modelica code, mathematical processing of equations, code generation of C/C++ simulation code, and numerical runtime computations.</p>\n"},tl:{hd:{name:"Zeo Agency",slug:"zeo-agency",description:"Zeo is a digital marketing company focused on helping companies to do better in SEO.\n",image:void 0,site:"https://www.zeo.org",locations:{hd:"London, United Kingdom",tl:0},consortium:!1,body_md:"\nZeo is a digital marketing company focused on helping companies to do better in SEO. Due to the nature of our business, we manage billions of lines in our database & create insights by using this data. To utilize our needs effectively, we use OCaml in our data crawling & processing part.\n",body_html:"<p>Zeo is a digital marketing company focused on helping companies to do better in SEO. Due to the nature of our business, we manage billions of lines in our database &amp; create insights by using this data. To utilize our needs effectively, we use OCaml in our data crawling &amp; processing part.</p>\n"},tl:0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},u={hd:{name:"Universidade da Beira Interior",slug:"universidade-da-beira-interior",description:"The University of Beira Interior is a public university located in the city of Covilh\xe3, Portugal.\n",url:"https://www.ubi.pt/en/",logo:"/academic_institution/beira.jpg",continent:"Europe",courses:{hd:{name:"Certified Programming",acronym:void 0,online_resource:"https://www.di.ubi.pt/~desousa/PC/pc.html"},tl:{hd:{name:"Computation Theory",acronym:void 0,online_resource:"https://www.di.ubi.pt/~desousa/TC/tcomp.html"},tl:{hd:{name:"Computational Logic",acronym:void 0,online_resource:"https://www.di.ubi.pt/~desousa/LC/lc.html"},tl:{hd:{name:"Functional Programming, Algorithms and Data-structures",acronym:void 0,online_resource:"https://www.di.ubi.pt/~desousa/PF/pf.html"},tl:{hd:{name:"Programming Languages and Compilers Design",acronym:void 0,online_resource:"https://www.di.ubi.pt/~desousa/DLPC/dlpc.html"},tl:{hd:{name:"Proof and Programming Theory",acronym:void 0,online_resource:"https://www.di.ubi.pt/~desousa/TPP/tpp.html"},tl:{hd:{name:"Software Reliability and Security",acronym:void 0,online_resource:"https://www.di.ubi.pt/~desousa/CF/confia.html"},tl:0}}}}}}},location:{lat:40.2779,long:7.509},body_md:"",body_html:""},tl:{hd:{name:"University of Birmingham",slug:"university-of-birmingham",description:"The University of Birmingham is a public research university located in Edgbaston, Birmingham, United Kingdom. It received its royal charter in 1900 as a successor to Queen's College, Birmingham, and Mason Science College, making it the first English civic or 'red brick' university to receive its own royal charter.\n",url:"https://www.birmingham.ac.uk/index.aspx",logo:"/academic_institution/Birmingham.jpg",continent:"Europe",courses:{hd:{name:"Foundations of Computer Science",acronym:"FOCS1112",online_resource:"https://sites.google.com/site/focs1112/"},tl:0},location:{lat:52.4508,long:1.9305},body_md:"\n",body_html:""},tl:{hd:{name:"Boston College",slug:"boston-college",description:"Boston College is a private, Jesuit research university in Chestnut Hill, Massachusetts. Founded in 1863, the university has more than 9,300 full-time undergraduates and nearly 5,000 graduate students. \n",url:"https://www.bc.edu/",logo:"/academic_institution/boston.png",continent:"North America",courses:{hd:{name:"Computer Science I",acronym:"CS1101",online_resource:"https://www.cs.bc.edu/~muller/teaching/cs1101/s16/"},tl:0},location:{lat:42.3355,long:71.1685},body_md:"\n",body_html:""},tl:{hd:{name:"University of Cambridge",slug:"university-of-cambridge",description:"The University of Cambridge is a collegiate research university in Cambridge, United Kingdom. \n",url:"https://www.cam.ac.uk/",logo:"/academic_institution/cambridge.jpg",continent:"Europe",courses:{hd:{name:"Advanced Functional Programming",acronym:"L28",online_resource:"https://www.cl.cam.ac.uk/teaching/1415/L28/"},tl:0},location:{lat:52.2043,long:.1149},body_md:"",body_html:""},tl:{hd:{name:"ISAE/Supa\xe9ro",slug:"isaesuparo",description:"The Institut sup\xe9rieur de l'a\xe9ronautique et de l'espace is a French engineering school, founded in 1909. It was the world's first dedicated aerospace engineering school.\n",url:"https://www.isae-supaero.fr/en/",logo:void 0,continent:"Europe",courses:{hd:{name:"Functional programming and introduction to type systems",acronym:void 0,online_resource:void 0},tl:0},location:{lat:43.5659,long:1.4746},body_md:"",body_html:""},tl:{hd:{name:"Aix-Marseille University",slug:"aix-marseille-university",description:"Aix-Marseille University is a public research university located in the region of Provence, southern France. \n",url:"https://www.univ-amu.fr/en",logo:"/academic_institution/aix.jpg",continent:"Europe",courses:{hd:{name:"Functional Programming",acronym:void 0,online_resource:void 0},tl:0},location:{lat:43.3048,long:5.3774},body_md:"",body_html:""},tl:{hd:{name:"Aarhus University",slug:"aarhus-university",description:"Aarhus University (Danish: Aarhus Universitet, abbreviated AU) is the largest and second oldest research university in Denmark.The university belongs to the Coimbra Group, the Guild, and Utrecht Network of European universities and is a member of the European University Association.\n",url:"https://international.au.dk/",logo:"/academic_institution/arhus.png",continent:"Europe",courses:{hd:{name:"The compilation course (along with Java)",acronym:void 0,online_resource:"https://kursuskatalog.au.dk/en/course/100489/Compilation"},tl:0},location:{lat:56.1681,long:10.203},body_md:"\n",body_html:""},tl:{hd:{name:"Brown University",slug:"brown-university",description:"Brown University is a private Ivy League research university in Providence, Rhode Island. \n",url:"https://www.brown.edu/",logo:"/academic_institution/brown.png",continent:"North America",courses:{hd:{name:"An Integrated introducion (along with Racket, Scala and Java)",acronym:"CS 17/18",online_resource:"https://cs17-spring2021.github.io/"},tl:0},location:{lat:41.8268,long:71.4025},body_md:"",body_html:""},tl:{hd:{name:"California Institute of Technology",slug:"california-institute-of-technology",description:"The California Institute of Technology is a private research university in Pasadena, California. \n",url:"https://www.caltech.edu/",logo:"/academic_institution/caltech.png",continent:"North America",courses:{hd:{name:"Fundamentals of Computer Programming",acronym:void 0,online_resource:"https://users.cms.caltech.edu/~mvanier/"},tl:0},location:{lat:34.1377,long:118.1253},body_md:"",body_html:""},tl:{hd:{name:"Columbia University",slug:"columbia-university",description:"Columbia University is a private Ivy League research university in New York City. \n",url:"https://www.columbia.edu/",logo:"/academic_institution/columbia.png",continent:"North America",courses:{hd:{name:"Programming Languages and Translators",acronym:void 0,online_resource:"https://www1.cs.columbia.edu/~sedwards/classes/2014/w4115-fall/index.html"},tl:0},location:{lat:40.8075,long:73.9626},body_md:"\n",body_html:""},tl:{hd:{name:"Cornell University",slug:"cornell-university",description:"Cornell University is a private, statutory, Ivy League and land-grant research university in Ithaca, New York. \n",url:"https://www.cornell.edu/",logo:"/academic_institution/cornell.png",continent:"North America",courses:{hd:{name:"Data Structures and Functional Programming",acronym:"CS 3110",online_resource:"https://www.cs.cornell.edu/courses/cs3110/2016fa/"},tl:0},location:{lat:42.4534,long:76.4735},body_md:"",body_html:""},tl:{hd:{name:"University Pierre & Marie Curie",slug:"university-pierre--marie-curie",description:"Pierre and Marie Curie University, titled as UPMC from 2007 to 2017 and also known as Paris 6, was a public research university in Paris, France, from 1971 to 2017. The university was located on the Jussieu Campus in the Latin Quarter of the 5th arrondissement of Paris, France. \n",url:"https://www.sorbonne-universite.fr/",logo:"/academic_institution/curie.jpg",continent:"Europe",courses:{hd:{name:"Types and static analysis",acronym:"5I555",online_resource:"https://www-apr.lip6.fr/~chaillou/Public/enseignement/2014-2015/tas/"},tl:{hd:{name:"Models of programming and languages interoperability",acronym:"LI332",online_resource:"https://www-licence.ufr-info-p6.jussieu.fr/lmd/licence/2014/ue/LI332-2014oct/"},tl:0}},location:{lat:48.8471,long:2.3575},body_md:"\n",body_html:""},tl:{hd:{name:"Epita",slug:"epita",description:"The \xc9cole Pour l'Informatique et les Techniques Avanc\xe9es, more commonly known as EPITA, is a private French grande \xe9cole specialized in the field of computer science and software engineering created in 1984 by Patrice Dumoucel. \n",url:"https://www.epita.fr/",logo:void 0,continent:"Europe",courses:{hd:{name:"Introduction to Algorithms (Year 1 & 2)",acronym:void 0,online_resource:void 0},tl:0},location:{lat:48.8157,long:2.3628},body_md:"",body_html:""},tl:{hd:{name:"Harvard University",slug:"harvard-university",description:"Harvard University is a private Ivy League research university in Cambridge, Massachusetts. higher education academy. \n",url:"https://www.harvard.edu/",logo:"/academic_institution/harvard.png",continent:"North America",courses:{hd:{name:"Principles of Programming Language Compilation",acronym:"CS153",online_resource:void 0},tl:{hd:{name:"Introduction to Computer Science II- Abstraction & Design",acronym:"CS51",online_resource:void 0},tl:0}},location:{lat:42.377,long:71.1167},body_md:"\n",body_html:""},tl:{hd:{name:"Indian Institute of Technology, Delhi",slug:"indian-institute-of-technology-delhi",description:"Indian Institute of Technology Delhi is a public technical and research university located in Hauz Khas in South Delhi, Delhi, India. \n",url:"https://home.iitd.ac.in/",logo:"/academic_institution/iitd.png",continent:"Asia",courses:{hd:{name:"Introduction to Computers and Programming (along with Pascal and Java)",acronym:"CSL 101",online_resource:"https://www.cse.iitd.ac.in/~ssen/csl101/details.html"},tl:0},location:{lat:28.5457,long:77.1928},body_md:"",body_html:""},tl:{hd:{name:"University of Illinois at Urbana-Champaign",slug:"university-of-illinois-at-urbana-champaign",description:"The University of Illinois Urbana-Champaign is a public land-grant research university in Illinois in the twin cities of Champaign and Urbana.\n",url:"https://illinois.edu/",logo:"/academic_institution/illinois.jpeg",continent:"North America",courses:{hd:{name:"Programming Languages and Compilers",acronym:"CS 421",online_resource:"https://courses.engr.illinois.edu/cs421/fa2014/"},tl:0},location:{lat:40.102,long:88.2272},body_md:"\n",body_html:""},tl:{hd:{name:"University of Innsbruck",slug:"university-of-innsbruck",description:"The University of Innsbruck is a public university in Innsbruck, the capital of the Austrian federal state of Tyrol, founded in 1669. \n",url:"https://www.uibk.ac.at/index.html.en",logo:"/academic_institution/university-of-innsbruck-logo.jpg",continent:"Europe",courses:{hd:{name:"Programming in OCAML",acronym:"SS 06",online_resource:"https://cl-informatik.uibk.ac.at/teaching/ss06/ocaml/schedule.php"},tl:0},location:{lat:47.2692,long:11.4041},body_md:"",body_html:""},tl:{hd:{name:"University of California, Los Angeles",slug:"university-of-california-los-angeles",description:"The University of California, Los Angeles is a public land-grant research university in Los Angeles, California.\n",url:"https://www.ucla.edu/",logo:"/academic_institution/ucla.jpg",continent:"North America",courses:{hd:{name:"Programming Languages (along with Python and Java)",acronym:"CS 131",online_resource:"https://web.cs.ucla.edu/classes/winter18/cs131/"},tl:0},location:{lat:34.0689,long:118.4452},body_md:"",body_html:""},tl:{hd:{name:"University of Maryland",slug:"university-of-maryland",description:"The University of Maryland, College Park is a public land-grant research university in College Park, Maryland.\n",url:"https://www.umd.edu/",logo:"/academic_institution/maryland.gif",continent:"North America",courses:{hd:{name:"Organization of Programming Languages-(along with Ruby, Prolog, Java)",acronym:"CMSC 330",online_resource:"https://www.cs.umd.edu/class/fall2014/cmsc330/"},tl:0},location:{lat:38.9869,long:76.9426},body_md:"",body_html:""},tl:{hd:{name:"University of Massachusetts",slug:"university-of-massachusetts",description:"The University of Massachusetts is the five-campus public university system and the only public research system in the Commonwealth of Massachusetts. \n",url:"https://www.massachusetts.edu/",logo:void 0,continent:"North America",courses:{hd:{name:"Programming Languages",acronym:"CS691F",online_resource:"https://people.cs.umass.edu/~arjun/courses/cs691f/"},tl:0},location:void 0,body_md:"",body_html:""},tl:{hd:{name:"McGill University",slug:"mcgill-university",description:"McGill University is a public research university located in Montreal, Quebec, Canada.\n",url:"https://www.mcgill.ca/",logo:"/academic_institution/mcgill_logo.png",continent:"North America",courses:{hd:{name:"Programming Languages and Paradigms",acronym:"COMP 302",online_resource:"https://www.cs.mcgill.ca/~bpientka/cs302/"},tl:0},location:{lat:45.5048,long:73.5772},body_md:"\n\n\n",body_html:""},tl:{hd:{name:"Universit\xe9 Paris-Diderot",slug:"universit-paris-diderot",description:"Paris Diderot University, also known as Paris 7, was a French university located in Paris, France. It was one of the seven universities of the Paris public higher education academy. \n",url:"https://u-paris.fr/en/",logo:void 0,continent:"Europe",courses:{hd:{name:"Advanced Functional Programming",acronym:"PFAV",online_resource:"https://www.dicosmo.org/CourseNotes/pfav/"},tl:{hd:{name:"Functional Programming",acronym:"PF5",online_resource:"https://www.irif.fr/~treinen/teaching/pf5/"},tl:0}},location:{lat:48.8276,long:2.3822},body_md:"",body_html:""},tl:{hd:{name:"University of Pennsylvania",slug:"university-of-pennsylvania",description:"The University of Pennsylvania is a private Ivy League research university in Philadelphia, Pennsylvania.\n",url:"https://www.upenn.edu/",logo:"/academic_institution/penn.png",continent:"North America",courses:{hd:{name:"Compilers",acronym:"CIS341",online_resource:"https://www.cis.upenn.edu/~cis341/current/"},tl:{hd:{name:"Programming Languages and Techniques I",acronym:"CIS120",online_resource:"https://www.seas.upenn.edu/~cis120/current/"},tl:0}},location:{lat:39.9522,long:75.1932},body_md:"",body_html:""},tl:{hd:{name:"Princeton University",slug:"princeton-university",description:"Princeton University is a private Ivy League research university in Princeton, New Jersey. \n",url:"https://www.princeton.edu/",logo:"/academic_institution/princeton.png",continent:"North America",courses:{hd:{name:"Functional Programming",acronym:"COS 326",online_resource:"https://www.cs.princeton.edu/courses/archive/fall14/cos326//"},tl:0},location:{lat:40.3431,long:74.6551},body_md:"",body_html:""},tl:{hd:{name:"University of Rennes 1",slug:"university-of-rennes-1",description:"The University of Rennes 1 is a public university located in the city of Rennes, France. It is under the Academy of Rennes. \n",url:"https://international.univ-rennes1.fr/en/welcome-universite-de-rennes-1",logo:"/academic_institution/reness.png",continent:"Europe",courses:{hd:{name:"Compilation",acronym:"COMP",online_resource:void 0},tl:{hd:{name:"Semantics",acronym:"SEM",online_resource:void 0},tl:{hd:{name:"Programming 2",acronym:"PRG2",online_resource:void 0},tl:0}}},location:{lat:48.1159,long:1.673},body_md:"",body_html:""},tl:{hd:{name:"Rice University",slug:"rice-university",description:"William Marsh Rice University, commonly known as Rice University, is a private research university in Houston, Texas. \n",url:"https://www.rice.edu/",logo:"/academic_institution/rice.jpg",continent:"North America",courses:{hd:{name:"Principles of Programming Languages",acronym:"COMP 311",online_resource:"https://www.cs.rice.edu/~javaplt/311/info.html"},tl:0},location:{lat:29.7174,long:95.4018},body_md:"",body_html:""},tl:{hd:{name:"University of California, San Diego",slug:"university-of-california-san-diego",description:"The University of California, San Diego(UC San Diego or, colloquially, UCSD) is a public land-grant research university in San Diego, California.\n",url:"https://ucsd.edu/",logo:"/academic_institution/ucsd_logo.png",continent:"North America",courses:{hd:{name:"Programming Languages Principles and Paradigms (along with Python and Prolog)",acronym:"CSE130-a",online_resource:"https://cseweb.ucsd.edu/classes/wi14/cse130-a/"},tl:0},location:{lat:32.8801,long:117.234},body_md:"",body_html:""},tl:{hd:{name:"University of Minnesota Twin Cities",slug:"university-of-minnesota-twin-cities",description:"The University of Minnesota, Twin Cities is a public land-grant research university in the Twin Cities of Minneapolis and Saint Paul, Minnesota. \n",url:"https://twin-cities.umn.edu/",logo:void 0,continent:"North America",courses:{hd:{name:"Advanced Programming Principles",acronym:"CSCI 2041",online_resource:"https://www-users.cs.umn.edu/~kauffman/2041/syllabus.html"},tl:0},location:{lat:44.974,long:93.2277},body_md:"",body_html:""},tl:{hd:{name:"University of Massachusetts Amherst",slug:"university-of-massachusetts-amherst",description:"The University of Massachusetts Amherst is a public land-grant research university in Amherst, Massachusetts. \n",url:"https://www.umass.edu/",logo:"/academic_institution/umas.jpeg",continent:"North America",courses:{hd:{name:"University of Massachusetts Amherst",acronym:"CMPSCI 631",online_resource:"https://people.cs.umass.edu/~arjun/main/teaching/631/"},tl:0},location:{lat:42.3868,long:72.5301},body_md:"",body_html:""},tl:{hd:{name:"University of Virginia",slug:"university-of-virginia",description:"The University of Virginia is a public research university in Charlottesville, Virginia. \n",url:"https://www.virginia.edu/",logo:"/academic_institution/virginia.png",continent:"North America",courses:{hd:{name:"Programming Languages",acronym:"CS 4610",online_resource:void 0},tl:0},location:{lat:38.0336,long:78.508},body_md:"",body_html:""},tl:{hd:{name:"University of Wroc\u0142aw",slug:"university-of-wrocaw",description:"The University of Wroc\u0142aw is a public research university located in Wroc\u0142aw, Poland. \n",url:"https://uni.wroc.pl/en/",logo:"/academic_institution/wroclaw.jpg",continent:"Europe",courses:{hd:{name:"Functional Programming",acronym:void 0,online_resource:"https://ii.uni.wroc.pl/~lukstafi/pmwiki/index.php?n=Functional.Functional"},tl:0},location:{lat:51.114,long:17.0345},body_md:"",body_html:""},tl:0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}};var m={all:u,get_by_slug:function(e){return o.cc((function(n){return s.Dg(e,n.slug)}),u)}};var g={all:i,get_by_slug:function(e){return o.cc((function(n){return s.Dg(e,n.slug)}),i)}};var f={all:l,get_by_slug:function(e){return o.cc((function(n){return s.Dg(e,n.slug)}),l)}};var b={all:h,get_by_slug:function(e){return o.cc((function(n){return s.Dg(e,n.slug)}),h)}};var y={all:c,get_by_slug:function(e){return o.cc((function(n){return s.Dg(e,n.slug)}),c)}};var w={all:p,get_by_slug:function(e){return o.cc((function(n){return s.Dg(e,n.slug)}),p)}};var v={all:r,get_by_slug:function(e){return o.cc((function(n){return s.Dg(e,n.slug)}),r)}};var k={kind_of_string:function(e){switch(e){case"conference":return(0,a.Z)({TAG:0,_0:"Conference"},Symbol.for("name"),"Ok");case"lecture":return(0,a.Z)({TAG:0,_0:"Lecture"},Symbol.for("name"),"Ok");case"mooc":return(0,a.Z)({TAG:0,_0:"Mooc"},Symbol.for("name"),"Ok");default:return(0,a.Z)({TAG:1,_0:{NAME:"Msg",VAL:"Unknown proficiency type: "+e}},Symbol.for("name"),"Error")}},kind_to_string:function(e){return"Mooc"===e?"mooc":"Conference"===e?"conference":"lecture"},all:d,get_by_slug:function(e){return o.cc((function(n){return s.Dg(e,n.slug)}),d)}}}}]);