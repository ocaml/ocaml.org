<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/59c64e8e0cd4b887f80a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/59c64e8e0cd4b887f80a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-43375c3d74aa814440ba.js" defer=""></script><script src="/_next/static/chunks/framework-56721e7fe9e004cd9e49.js" defer=""></script><script src="/_next/static/chunks/main-ff11dfa7b9d2932d51f3.js" defer=""></script><script src="/_next/static/chunks/pages/_app-07487d06e9f25472007b.js" defer=""></script><script src="/_next/static/chunks/940-69f823f49742ab32bc63.js" defer=""></script><script src="/_next/static/chunks/908-08eeb7bba98263e14afe.js" defer=""></script><script src="/_next/static/chunks/340-511850500c84fa1dce46.js" defer=""></script><script src="/_next/static/chunks/891-1bbf9c7984e84793c141.js" defer=""></script><script src="/_next/static/chunks/pages/%5Blang%5D/resources/tutorials-b254c3acc5a3ba5b33f5.js" defer=""></script><script src="/_next/static/5vwEGiEdVvGQoOBpMUVkF/_buildManifest.js" defer=""></script><script src="/_next/static/5vwEGiEdVvGQoOBpMUVkF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-white"><div class="pb-0  bg-yellowdark"><div class="max-w-7xl mx-auto"><div class="flex flex-col md:flex-row items-center text-center text-white"><div class="w-full md:w-3/12 font-bold text-2xl">OCaml.org v3</div><div class="w-full md:w-8/12"><div class="h-4 relative rounded-full overflow-hidden ring-8 ring-white m-8"><div class="w-full h-full bg-white absolute"></div><div class="h-full rounded-full bg-yellowdark absolute" style="width:30%"></div></div></div><div class="w-full md:w-1/12 font-bold text-2xl">30%</div></div><div class="flex flex-col items-center"><button class="inline-flex items-center pt-0 pb-1.5 border border-transparent text-xs font-medium rounded shadow-sm text-white bg-yellowdark focus:outline-none" type="button">See more v</button></div><div class="hidden"><div class="flex flex-col"><div class="-my-2 overflow-x-auto sm:-mx-6 lg:-mx-8"><div class="py-2 align-middle inline-block min-w-full sm:px-6 lg:px-8"><div class="shadow overflow-hidden border-b border-gray-200 sm:rounded-lg"><table class="table-auto min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" scope="col">version</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" scope="col">description</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" scope="col">period</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" scope="col">completion</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" scope="col">results</th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.1</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Select technologies</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Nov - Jan 2020</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">100%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Selected NextJS as static site generator, ReScript as implementation language, FlowMapp as sitemap tool, Figma for design, Tailwind for CSS.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.2</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Implement most important layouts</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Feb - Apr 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">100%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">The 10 most important pages have been designed and implemented.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900"></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Design information architecture</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Aug 2020 - Jun 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">60%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"> Sitemap is complete, 8 user personas and some journeys have been defined.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.3</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Implement all 40 distinct layouts</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Jun 30, 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">25%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">A quarter of the 40 distinct pages have been implemented.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900"></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Port 40 most important pages</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Aug 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">10%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Some work started.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.4</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Implement OCaml Manual</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Jul - Aug 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">0%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Not started.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.5</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Integrate docs.ocaml.org</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Jul 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">0%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Pending completion of the separate docs.ocaml.org project.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900"></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Implement multilingual site framework</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Aug 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">10%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Some work started.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900"></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Finalize site design</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Jan - Aug 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">50%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Half of the 40 pages needing a distinct design have been designed.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.6</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Go live on ocaml.org, replacing old site</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Aug 1, 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">30%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">One-third of the work has been done.</td></tr></tbody></table></div></div></div></div></div></div></div><div class="relative shadow"><div class="relative font-roboto"><div class="max-w-7xl mx-auto px-4 sm:px-6 "><div class="flex justify-between items-center md:justify-start py-6 md:space-x-10 "><div class="flex justify-start "><a class="" href="/"><img class="h-8 w-auto sm:h-10" alt="" src="/static/logo1.jpeg"/></a></div><nav class="hidden md:flex space-x-10 "><div class="relative"><button aria-expanded="false" class="text-gray-500  pl-2 group bg-white rounded-md inline-flex items-center text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orangedark" type="button"><span>Principles</span><svg aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" fill-rule="evenodd"></path></svg></button><div class="absolute z-10 left-1/2 transform -translate-x-1/4 mt-3 px-2 w-screen max-w-sm sm:px-0  hidden "><div class="rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 overflow-hidden"><div class="relative grid gap-6 bg-white px-5 py-6 sm:gap-6 sm:p-8"><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/principles/whatisocaml/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 12.7 15.9" xmlns="http://www.w3.org/2000/svg"><path d="m9.01 1.23a0.676 0.676 0 0 0-0.658 0.52 7.02 7.02 0 0 0-0.185 1.41 0.338 0.338 0 0 1-0.674 0.0292 6.26 6.26 0 0 0-0.304-1.33 0.81 0.81 0 0 0-1.56 0.118 3.15 3.15 0 0 1-1.26 1.98 0.495 0.495 0 0 1-0.564 9e-3 1.49 1.49 0 0 1-0.459-0.492 0.495 0.495 0 0 1 0.023-0.531 1.22 1.22 0 0 0 0.141-0.266 0.295 0.295 0 0 0-0.374-0.383 0.987 0.987 0 0 0-0.183 0.0867 0.819 0.819 0 0 0-1.21-0.24 1.36 1.36 0 0 1-0.767 0.395 0.516 0.516 0 0 0 0.0788 1.03h0.42a0.789 0.789 0 0 0 0.507 0.259 2.67 2.67 0 0 0 2.32 2.59 0.471 0.471 0 0 0 0.328-0.0783 1.81 1.81 0 0 0 0.438 1.11 3.97 3.97 0 0 1 1.15 2.78 0.202 0.202 0 0 1-0.11 0.18 2.56 2.56 0 0 0-0.682 0.506 0.325 0.325 0 0 0 0.234 0.55h1.43a0.468 0.468 0 0 0 0.0934-0.784 0.202 0.202 0 0 1-0.0744-0.156v-1.43a1.5 1.5 0 0 0-0.15-1.08v-0.591a2.43 2.43 0 0 0 1.68 0.0748 3.43 3.43 0 0 0 1.4-0.668 1.78 1.78 0 0 0 0.228 0.465 2.84 2.84 0 0 1 0.408 2.9 0.202 0.202 0 0 1-0.115 0.11 2.56 2.56 0 0 0-0.934 0.617 0.325 0.325 0 0 0 0.234 0.55h1.43a0.468 0.468 0 0 0 0.122-0.759 0.202 0.202 0 0 1-0.0558-0.197 4.7 4.7 0 0 1 0.706-1.51 0.383 0.383 0 0 0 0.0598-0.309 6.18 6.18 0 0 1 0.035-2.97 1.06 1.06 0 0 0-0.45-1.16l-0.486-0.315a1.08 1.08 0 0 1-0.453-0.618 5.11 5.11 0 0 0-1.26-2.19 0.676 0.676 0 0 0-0.485-0.205zm-0.00227 0.181a0.495 0.495 0 0 1 0.355 0.15 4.93 4.93 0 0 1 1.21 2.11 1.26 1.26 0 0 0 0.529 0.721l0.486 0.315a0.882 0.882 0 0 1 0.374 0.962 6.36 6.36 0 0 0-0.0358 3.06 0.202 0.202 0 0 1-0.0319 0.163 4.88 4.88 0 0 0-0.733 1.57 0.383 0.383 0 0 0 0.105 0.374 0.287 0.287 0 0 1-0.0429 0.447h-1.38a0.143 0.143 0 0 1-0.103-0.243 2.38 2.38 0 0 1 0.868-0.574 0.383 0.383 0 0 0 0.216-0.208 3.02 3.02 0 0 0-0.429-3.08 1.6 1.6 0 0 1-0.218-1.33 0.0906 0.0906 0 0 0-0.174-0.0491 1.78 1.78 0 0 0-0.0319 0.83 3.25 3.25 0 0 1-1.39 0.686 2.25 2.25 0 0 1-1.63-0.0978v-0.624a0.0906 0.0906 0 0 0-0.181 0v1.46a1.32 1.32 0 0 1 0.15 1.01v1.46a0.383 0.383 0 0 0 0.14 0.297 0.287 0.287 0 0 1-0.0248 0.462h-1.38a0.143 0.143 0 0 1-0.103-0.243 2.38 2.38 0 0 1 0.634-0.47 0.383 0.383 0 0 0 0.209-0.343 4.15 4.15 0 0 0-1.19-2.9 1.62 1.62 0 0 1-0.308-1.57 0.0907 0.0907 0 1 0-0.172-0.058 1.81 1.81 0 0 0-0.073 0.298 0.29 0.29 0 0 1-0.324 0.243 2.48 2.48 0 0 1-2.16-2.42 0.789 0.789 0 0 0 0.404-0.176 0.0907 0.0907 0 0 0-0.116-0.139 0.608 0.608 0 0 1-0.888-0.123h-0.508a0.335 0.335 0 0 1-0.0505-0.667 1.54 1.54 0 0 0 0.86-0.438 0.638 0.638 0 0 1 0.942 0.212 0.987 0.987 0 0 0-0.0894 0.0907 0.0909 0.0909 0 1 0 0.138 0.119 0.805 0.805 0 0 1 0.342-0.234 0.114 0.114 0 0 1 0.144 0.148 1.04 1.04 0 0 1-0.119 0.227 0.676 0.676 0 0 0-0.031 0.725 1.68 1.68 0 0 0 0.515 0.551 0.676 0.676 0 0 0 0.772-0.0116 3.33 3.33 0 0 0 1.33-2.1 0.629 0.629 0 0 1 1.21-0.0912 6.08 6.08 0 0 1 0.295 1.29 0.52 0.52 0 0 0 1.04-0.0451 6.84 6.84 0 0 1 0.18-1.37 0.495 0.495 0 0 1 0.482-0.381z" stroke-width=".289"></path><path d="m2.16 2.76a0.128 0.128 0 1 0-0.256 0 0.128 0.128 0 1 0 0.256 0z" stroke-width=".2"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Why OCaml</p></dt><dd class="ml-10 text-sm text-gray-500">Find out about OCaml&#x27;s history and how it became what it is today.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/principles/users/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg class="stroke-0" version="1.1" viewBox="0 0 60 75" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M6,55h48c0.6,0,1-0.4,1-1V33c0-0.3-0.1-0.5-0.3-0.7l-9-8.4L44,5.9c0-0.1,0-0.1,0-0.2c0-0.1,0-0.1,0-0.2  c0-0.1-0.1-0.1-0.1-0.2c0,0-0.1-0.1-0.1-0.1c-0.1-0.1-0.1-0.1-0.2-0.1c0,0-0.1-0.1-0.1-0.1C43.3,5,43.1,5,43,5h-6  c-0.1,0-0.3,0-0.4,0.1c0,0-0.1,0-0.1,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0-0.1,0.1-0.1,0.1c0,0.1-0.1,0.1-0.1,0.2c0,0.1,0,0.1,0,0.2  c0,0.1,0,0.1,0,0.2l-1.3,20.8l-8-7.4c-0.3-0.3-0.7-0.3-1.1-0.2C25.2,19.2,25,19.6,25,20v10.7L12.7,19.3c-0.3-0.3-0.7-0.3-1.1-0.2  C11.2,19.2,11,19.6,11,20v12H6c-0.6,0-1,0.4-1,1v21C5,54.6,5.4,55,6,55z M42,7v1h-4V7H42z M37.8,10h4.6l1.1,11.9l-2.8-2.6  c-0.3-0.3-0.7-0.3-1.1-0.2C39.2,19.2,39,19.6,39,20v10.7l-2.4-2.2L37.8,10z M7,34h5c0.6,0,1-0.4,1-1V22.3l12.3,11.4  c0.3,0.3,0.7,0.3,1.1,0.2c0.4-0.2,0.6-0.5,0.6-0.9V22.3l12.3,11.4c0.3,0.3,0.7,0.3,1.1,0.2c0.4-0.2,0.6-0.5,0.6-0.9V22.3l3.1,2.9  c0,0,0,0,0,0l8.9,8.3V53H7V34z"></path><path d="M16,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C17,38.4,16.6,38,16,38z M15,42h-2v-2h2V42z"></path><path d="M24,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C25,38.4,24.6,38,24,38z M23,42h-2v-2h2V42z"></path><path d="M32,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C33,38.4,32.6,38,32,38z M31,42h-2v-2h2V42z"></path><path d="M40,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C41,38.4,40.6,38,40,38z M39,42h-2v-2h2V42z"></path><path d="M48,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C49,38.4,48.6,38,48,38z M47,42h-2v-2h2V42z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Industrial Users</p></dt><dd class="ml-10 text-sm text-gray-500">Discover the organisations that use OCaml to accomplish their goals.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/principles/academic/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg class="stroke-2" version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g transform="translate(0,-952.36218)"><path d="M 47.25 23 A 1.0001 1.0001 0 0 0 47.125 23.0625 L 5.625 39.0625 A 1.0001 1.0001 0 0 0 5.625 40.90625 L 21.1875 46.90625 A 1.0001 1.0001 0 0 0 21.1875 47 L 21.1875 63.4375 A 1.0001 1.0001 0 0 0 21.8125 64.34375 L 47.09375 74.90625 A 1.0001 1.0001 0 0 0 47.84375 74.90625 L 73.15625 64.34375 A 1.0001 1.0001 0 0 0 73.75 63.4375 L 73.75 47 A 1.0001 1.0001 0 0 0 73.75 46.9375 L 80.875 44.1875 A 1.0040202 1.0040202 0 0 0 80.15625 42.3125 L 47.46875 54.9375 L 8.75 40 L 47.5 25.03125 L 87.9375 40.65625 L 87.9375 65.09375 C 85.072141 65.568778 82.875 68.037767 82.875 71 C 82.875 74.2988 85.600803 77 88.9375 77 C 92.274197 77 95 74.2988 95 71 C 95 68.037767 92.802859 65.568778 89.9375 65.09375 L 89.9375 40 A 1.0001 1.0001 0 0 0 89.3125 39.0625 L 47.84375 23.0625 A 1.0001 1.0001 0 0 0 47.25 23 z M 23.1875 47.6875 L 47.125 56.90625 A 1.0001 1.0001 0 0 0 47.84375 56.90625 L 71.75 47.6875 L 71.75 62.75 L 47.46875 72.90625 L 23.1875 62.75 L 23.1875 47.6875 z M 88.9375 66.96875 C 91.187128 66.96875 92.96875 68.7759 92.96875 71 C 92.96875 73.2241 91.187128 75 88.9375 75 C 86.687872 75 84.875 73.2241 84.875 71 C 84.875 68.7759 86.687872 66.96875 88.9375 66.96875 z " transform="translate(0,952.36218)"></path></g></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Academic Excellence</p></dt><dd class="ml-10 text-sm text-gray-500">Learn about the academics that research programming language technology.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/principles/successes/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 160 200" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M151.305,149.32l-35.11-68.89c-0.6-1.17-1.8-1.91-3.12-1.91s-2.52,0.74-3.12,1.91l-11.98,23.5l3.93,7.71l11.17-21.92  l29.4,57.69h-22.34h-2.801L66.999,48.66v-8.949h42.25c1.933,0,3.5-1.567,3.5-3.5V9.09c0-1.933-1.567-3.5-3.5-3.5h-45.75  c-1.933,0-3.5,1.567-3.5,3.5v13.824v13.297V48.66L8.69,149.321c-0.553,1.085-0.502,2.38,0.134,3.418  c0.636,1.039,1.767,1.672,2.984,1.672h103.381c0.001,0,0.002,0,0.003,0h4.863h28.14c1.21,0,2.34-0.63,2.98-1.67  C151.815,151.7,151.865,150.41,151.305,149.32z M66.999,22.914V12.59h38.75v20.122h-38.75V22.914z M63.499,57.207l10.873,21.332  c-5.251-0.709-10.46,2.09-12.683,7.08c-0.751,1.687-2.234,2.781-4.067,3.003c-1.829,0.221-3.533-0.488-4.665-1.947l-2.703-3.484  L63.499,57.207z M17.52,147.41l29.221-57.328l0.685,0.883c2.329,3.002,5.817,4.696,9.543,4.695c0.494,0,0.993-0.029,1.493-0.09  c4.273-0.517,7.87-3.172,9.622-7.104c1.063-2.386,3.744-3.588,6.231-2.8l4.402,1.396l30.76,60.347H17.52z"></path><path d="M90.023,15.97l-5.161,5.71l-2.427-1.948c-1.075-0.864-2.649-0.692-3.514,0.384c-0.865,1.077-0.692,2.65,0.384,3.514  l4.265,3.424c0.461,0.37,1.014,0.551,1.564,0.551c0.684,0,1.364-0.279,1.855-0.824l6.742-7.46c0.926-1.024,0.846-2.605-0.178-3.531  C92.529,14.866,90.948,14.947,90.023,15.97z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Success Stories</p></dt><dd class="ml-10 text-sm text-gray-500">Read about the things that have been achieved using OCaml.</dd></a></div></div></div></div><div class="relative"><button aria-expanded="false" class="text-gray-500 pl-2 group bg-white rounded-md inline-flex items-center text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orangedark" type="button"><span>Resources</span><svg aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" fill-rule="evenodd"></path></svg></button><div class="absolute z-10 left-1/2 transform -translate-x-1/3 mt-3 px-2 w-screen max-w-sm sm:px-0  hidden "><div class="rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 overflow-hidden"><div class="relative grid gap-6 bg-white px-5 py-6 sm:gap-6 sm:p-8"><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/resources/language/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M10.7,22.2c0.4,0.2,0.9,0.2,1.4,0c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1  c0.7,0,1.3-0.4,1.6-1.1c0.4-0.9,0-1.9-0.9-2.3c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3C10,21.7,10.3,22,10.7,22.2z"></path><path d="M57.2,20.2c-0.4,0.2-0.8,0.5-0.9,1s-0.2,0.9,0,1.4c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.6-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1c0.4-0.9-0.1-1.9-1-2.3C74.1,13,57.9,19.9,57.2,20.2z"></path><path d="M42.6,31.4c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0  C25.7,28,41,34.6,41.2,34.6c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.9,32.8,43.5,31.8,42.6,31.4z"></path><path d="M89,30.1c-14.6-5.9-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.9,0.4,1.9-0.1,2.3-1C90.4,31.5,89.9,30.5,89,30.1z"></path><path d="M42.6,42.9c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.4,0.9,1.4,1.3,2.3,1  c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.9,44.3,43.5,43.3,42.6,42.9z"></path><path d="M89,41.6c-14.6-5.9-30.8,1-31.5,1.3c-0.4,0.2-0.8,0.5-0.9,1c-0.2,0.4-0.2,0.9,0,1.4  c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1c0.2-0.1,15.5-6.6,28.7-1.2c0.9,0.4,1.9-0.1,2.3-1C90.4,43,89.9,42,89,41.6z"></path><path d="M42.5,54.4c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0  c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.8,55.8,43.4,54.8,42.5,54.4z"></path><path d="M88.9,53.1c-14.6-6-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1C90.2,54.5,89.8,53.5,88.9,53.1z"></path><path d="M41.8,69.1c0.7,0,1.3-0.4,1.6-1.1c0.4-0.9,0-1.9-0.9-2.3c-0.7-0.3-16.9-7.2-31.5-1.3  c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0c13.2-5.4,28.6,1.2,28.7,1.2C41.3,69,41.5,69.1,41.8,69.1z"></path><path d="M88.9,64.4c-14.6-6-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1C90.2,65.8,89.8,64.7,88.9,64.4z"></path><path d="M97.9,12.1c0-0.8-0.5-1.6-1.3-1.9C72-0.3,54.9,10.1,50,13.8C45,10.1,27.9-0.3,3.3,10.2  c-0.8,0.3-1.3,1.1-1.3,1.9v78.6c0,0.7,0.4,1.4,1,1.8c0.3,0.2,0.7,0.3,1.1,0.3c0.3,0,0.6-0.1,0.9-0.2c0.2-0.1,17.1-7.8,43.5-0.2l0,0  l3,0l0.1,0c17.3-7,39.3-0.9,43.6,0.4c0.6,0.2,1.3,0.1,1.8-0.3c0.5-0.4,0.8-1,0.8-1.7L97.9,12.1z M93.8,87.8V88  c-7.7-2.1-15.2-3.1-22.4-3.1c-1.2,0-2.4,0-3.6,0.1C76.2,83.3,84.9,84.3,93.8,87.8z M93.8,83.4c-20.6-7.6-35.7-0.5-41.7,3.3l0-69.3  c3.2-2.5,19-13,41.7-3.9L93.8,83.4z M34.5,85.4C22.3,84,13.2,85.6,7.9,87.2c6.1-2.2,11.7-3.1,16.5-3.1  C28.3,84.1,31.7,84.6,34.5,85.4z M6.2,13.4c23.1-9.2,38.6,1.5,41.7,4l0,69.3C43.9,84.1,35.7,80,24.3,80c-5.4,0-11.4,0.9-18.1,3.4  L6.2,13.4z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Language</p></dt><dd class="ml-10 text-sm text-gray-500">Read through the OCaml tutorial, official manual and books.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/packages/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M85.8,35.6l11.2-13c0.5-0.5,0.6-1.3,0.4-2c-0.2-0.7-0.7-1.2-1.4-1.5L63.1,8.3c-0.8-0.3-1.7,0-2.3,0.6L50,21.5L39.2,9    c-0.6-0.7-1.5-0.9-2.3-0.6L4,19.1c-0.7,0.2-1.2,0.8-1.4,1.5c-0.2,0.7,0,1.4,0.4,2l11.2,13L3,48.6c-0.5,0.5-0.6,1.3-0.4,2    c0.2,0.7,0.7,1.2,1.4,1.5l10.9,3.6v23.2c0,0.9,0.6,1.8,1.5,2.1l32.9,10.8c0.2,0.1,0.5,0.1,0.7,0.1c0.2,0,0.5,0,0.7-0.1l32.9-10.8    c0.9-0.3,1.5-1.1,1.5-2.1V55.7l11-3.6c0.7-0.2,1.2-0.8,1.4-1.5c0.2-0.7,0-1.4-0.4-2L85.8,35.6z M24,35.6l26-8.5l26,8.5l-26,8.5    L24,35.6z M63.1,12.9l28.5,9.3l-9.4,10.9l-28.5-9.3L63.1,12.9z M36.9,12.9l9.4,10.9l-28.5,9.3L8.4,22.2L36.9,12.9z M17.8,38.1    l28.5,9.3l-9.4,10.9L8.4,49L17.8,38.1z M19.2,77.2V57.1l17.6,5.8c0.2,0.1,0.4,0.1,0.7,0.1c0.6,0,1.2-0.3,1.6-0.7l8.6-10v34.4    L19.2,77.2z M80.7,77.2l-28.6,9.4V52.2l8.6,10c0.4,0.5,1,0.7,1.6,0.7c0.2,0,0.5,0,0.7-0.1l17.6-5.8V77.2z M63.1,58.3l-9.4-10.9    l28.5-9.3L91.6,49L63.1,58.3z"></path></g></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Packages</p></dt><dd class="ml-10 text-sm text-gray-500">Browse the third-party packages published in the OCaml ecosystem.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/resources/applications/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M85.32,15.63H78.65a1.5,1.5,0,0,0-1.5,1.5v3.53H73.36a5.5,5.5,0,0,0-10.57,0h-7.9a5.5,5.5,0,0,0-10.57,0H36.11a5.5,5.5,0,0,0-10.57,0H22.85V17.13a1.5,1.5,0,0,0-1.5-1.5H14.68a1.5,1.5,0,0,0-1.5,1.5V82.87a1.5,1.5,0,0,0,1.5,1.5h6.67a1.5,1.5,0,0,0,1.5-1.5V74.63h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,9.29-2.27H54.79a5.49,5.49,0,0,0,9.29,2.27,5.49,5.49,0,0,0,9.28-2.27h3.79v8.24a1.5,1.5,0,0,0,1.5,1.5h6.67a1.5,1.5,0,0,0,1.5-1.5V17.13A1.5,1.5,0,0,0,85.32,15.63Zm-25.22,39a5.5,5.5,0,0,0-9.29-2.26,5.48,5.48,0,0,0-8,0,5.49,5.49,0,0,0-8,0,5.49,5.49,0,0,0-9.28,2.26H22.85v-14h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,8,0,5.49,5.49,0,0,0,9.28-2.27H62.79a5.49,5.49,0,0,0,10.57,0h3.79v14Zm-2.79,1.5a2.5,2.5,0,1,1-2.5-2.49A2.5,2.5,0,0,1,57.31,56.14Zm-8,0a2.5,2.5,0,1,1-2.49-2.49A2.5,2.5,0,0,1,49.31,56.14Zm-8,0a2.5,2.5,0,1,1-2.5-2.49A2.5,2.5,0,0,1,41.32,56.14Zm-8,0a2.5,2.5,0,1,1-2.49-2.49A2.5,2.5,0,0,1,33.32,56.14Zm-5-17a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,28.33,39.15Zm8,0a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,36.32,39.15Zm8,0a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,44.32,39.15Zm21.26,0a2.5,2.5,0,1,1,2.49,2.5A2.5,2.5,0,0,1,65.58,39.15Zm2.49-19.48a2.5,2.5,0,1,1-2.49,2.49A2.5,2.5,0,0,1,68.07,19.67Zm-18.47,0a2.5,2.5,0,1,1-2.5,2.49A2.5,2.5,0,0,1,49.6,19.67Zm-18.77,0a2.5,2.5,0,1,1-2.5,2.49A2.5,2.5,0,0,1,30.83,19.67Zm-5.29,4a5.49,5.49,0,0,0,10.57,0h8.21a5.49,5.49,0,0,0,10.57,0h7.9a5.49,5.49,0,0,0,10.57,0h3.79v14H73.36a5.5,5.5,0,0,0-10.57,0H52.1a5.49,5.49,0,0,0-9.28-2.26,5.49,5.49,0,0,0-8,0,5.49,5.49,0,0,0-9.28,2.26H22.85v-14ZM19.85,81.37H16.18V18.63h3.67Zm11-5.74a2.5,2.5,0,1,1,2.49-2.5A2.5,2.5,0,0,1,30.83,75.63Zm8,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,38.82,75.63Zm21.26,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,60.08,75.63Zm8,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,68.07,75.63Zm5.29-4a5.49,5.49,0,0,0-9.28-2.26,5.5,5.5,0,0,0-9.29,2.26H44.11a5.5,5.5,0,0,0-9.29-2.26,5.49,5.49,0,0,0-9.28,2.26H22.85v-14h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,8,0,5.48,5.48,0,0,0,8,0,5.49,5.49,0,0,0,9.29-2.27H77.15v14Zm10.46,9.74H80.15V18.63h3.67Z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Applications</p></dt><dd class="ml-10 text-sm text-gray-500">Learn techniques for building tools and applications in OCaml.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/resources/bestpractices/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M7,51h28.7c3.3,0,6.6-1.4,8.8-3.9L61.2,29H76c6.6,0,9-3.8,9-7c0-1.1-0.2-2.1-0.7-3H88c3.9,0,7-3.1,7-7s-3.1-7-7-7H45  c-0.1,0-0.1,0-0.2,0c0,0-0.1,0-0.2,0s-0.1,0-0.2,0c-0.1,0-0.1,0-0.2,0.1c0,0-0.1,0-0.2,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0,0,0,0,0  L22.3,21H7c-1.1,0-2,0.9-2,2v26C5,50.1,5.9,51,7,51z M76,25H64.5c0.5-1.1,0.8-2.4,0.7-3.7c-0.1-0.8-0.3-1.6-0.6-2.3H78  c1.7,0,3,1.3,3,3C81,24.7,77.5,25,76,25z M19,25h4c0.2,0,0.4,0,0.5-0.1c0,0,0.1,0,0.1,0c0.2-0.1,0.3-0.1,0.5-0.2c0,0,0,0,0,0L45.7,9  H88c1.7,0,3,1.3,3,3c0,1.6-1.3,3-3,3H58c-0.1,0-0.3,0-0.4,0c-1.8,0.2-3.5,1-4.7,2.3L34.9,36.9c-0.7,0.8-0.7,2.1,0.1,2.8  s2.1,0.7,2.8-0.1l18-19.5c1.1-1.2,2.9-1.4,4.2-0.5c0.7,0.5,1.1,1.3,1.2,2.1c0.1,0.8-0.2,1.7-0.8,2.3L41.6,44.4  c-1.5,1.6-3.7,2.6-5.9,2.6H19V25z M9,25h6v22H9V25z M93,49H64.3c-3.3,0-6.6,1.4-8.8,3.9L38.8,71H24c-6.6,0-9,3.8-9,7  c0,1.1,0.2,2.1,0.7,3H12c-3.9,0-7,3.1-7,7s3.1,7,7,7h43c0,0,0,0,0,0c0.2,0,0.4,0,0.5-0.1c0,0,0.1,0,0.1,0c0.2-0.1,0.3-0.1,0.5-0.2  c0,0,0,0,0,0L77.7,79H93c1.1,0,2-0.9,2-2V51C95,49.9,94.1,49,93,49z M24,75h11.5c-0.5,1.1-0.8,2.4-0.7,3.7c0.1,0.8,0.3,1.6,0.6,2.3  H22c-1.7,0-3-1.4-3-3C19,75.3,22.5,75,24,75z M81,75h-4c-0.1,0-0.2,0-0.3,0c0,0-0.1,0-0.1,0c-0.1,0-0.2,0-0.2,0.1c0,0-0.1,0-0.2,0.1  s-0.1,0-0.2,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0,0,0,0,0L54.3,91H12c-1.7,0-3-1.4-3-3c0-1.7,1.3-3,3-3h30c0.1,0,0.3,0,0.4,0  c1.8-0.2,3.5-0.9,4.7-2.3l17.9-19.5c0.7-0.8,0.7-2.1-0.1-2.8c-0.8-0.7-2.1-0.7-2.8,0.1l-18,19.5c-1.1,1.2-2.9,1.5-4.2,0.5  c-0.7-0.5-1.1-1.3-1.2-2.1c-0.1-0.9,0.2-1.7,0.8-2.3l18.8-20.4c1.5-1.6,3.7-2.6,5.9-2.6H81V75z M91,75h-6V53h6V75z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Best Practices</p></dt><dd class="ml-10 text-sm text-gray-500">Adopt the best known methods for development from the OCaml community.</dd></a></div></div></div></div><div class="relative"><button aria-expanded="false" class="text-gray-500  pl-2 group bg-white rounded-md inline-flex items-center text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orangedark" type="button"><span>Community</span><svg aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" fill-rule="evenodd"></path></svg></button><div class="absolute z-10 left-1/2 transform -translate-x-1/2 mt-3 px-2 w-screen max-w-sm sm:px-0  hidden "><div class="rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 overflow-hidden"><div class="relative grid gap-6 bg-white px-5 py-6 sm:gap-6 sm:p-8"><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/community/opportunities/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 1024 1280" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M512,300.4c-31,0-60-14.7-81.7-41.3c-20.6-25.2-32-58-32-92.1c0-34.5,11.8-63.3,34.1-83.4c20.1-18.2,48.4-28.2,79.6-28.2   c31.2,0,59.5,10,79.6,28.2c22.3,20.1,34.1,49,34.1,83.4c0,34.2-11.4,66.9-32,92.1C572,285.7,543,300.4,512,300.4z M512,95.4   c-17.3,0-73.7,5.2-73.7,71.6c0,24.6,8.4,49,23,66.8c14,17.1,32,26.6,50.7,26.6c18.7,0,36.7-9.4,50.7-26.6   c14.6-17.9,23-42.2,23-66.8C585.7,100.6,529.3,95.4,512,95.4z"></path><rect height="44.4" width="40" x="383.9" y="470.9"></rect><path d="M338.4,515.4h-40v-83.6c0-35,20.6-66.7,52.6-80.9l100-44.4c10.4-4.6,22.4-1.5,29.2,7.5l31.9,41.7l32.4-41.7   c6.8-9,18.8-12,29.2-7.4l99.4,44.3c31.9,14.2,52.5,45.9,52.5,80.9v83.6h-40v-83.6c0-19.2-11.3-36.6-28.7-44.3l-88.2-39.3   l-56.8,73.1l-55.9-73.1l-88.7,39.4c-17.5,7.8-28.8,25.2-28.8,44.3V515.4z"></path><rect height="44.4" width="40" x="600.1" y="470.9"></rect><rect height="126.9" width="40" x="492" y="388.4"></rect><path d="M819.5,784.5c-3.3,0-6.7-0.6-9.9-2c-9.6-4-15.9-13.3-15.9-23.7v-51.2h-75.1c-13,0-23.6-10.6-23.6-23.6V583.8   c0-13,10.6-23.6,23.6-23.6h75.1V509c0-10.5,6.2-19.8,15.9-23.8c9.7-4,20.7-1.8,28.1,5.6l124.9,124.9c10,10,10,26.4,0,36.4   L837.6,776.9C832.7,781.9,826.1,784.5,819.5,784.5z M735,667.6h98.7v56.7l90.5-90.5l-90.5-90.5v56.8H735V667.6z"></path><path d="M512,968.6c-6.6,0-13.2-2.5-18.2-7.5l-125-124.9c-7.3-7.3-9.5-18.2-5.7-27.7c3.9-9.6,13.1-16,23.5-16.2l0.4,0h51.2v-75.1   c0-13,10.6-23.6,23.6-23.6h100.3c13,0,23.6,10.6,23.6,23.6v75.1H637c10.4,0,19.7,6.2,23.7,15.9c4,9.7,1.8,20.7-5.6,28.1L530.2,961   C525.2,966.1,518.6,968.6,512,968.6z M421.5,832.2l90.5,90.5l90.5-90.5h-56.7v-98.7h-67.5v98.7H421.5z"></path><path d="M204.5,784.5c-6.7,0-13.3-2.6-18.2-7.6L61.5,652c-10-10-10-26.4,0-36.4l124.9-124.9c7.4-7.4,18.4-9.6,28.1-5.6   c9.7,4,15.9,13.3,15.9,23.8v51.2h75.1c13,0,23.6,10.6,23.6,23.6V684c0,13-10.6,23.6-23.6,23.6h-75.1v51.2   c0,10.4-6.2,19.7-15.9,23.7C211.2,783.9,207.9,784.5,204.5,784.5z M99.8,633.8l90.5,90.5v-56.7H289v-67.4h-98.7v-56.8L99.8,633.8z"></path></g></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Opportunities</p></dt><dd class="ml-10 text-sm text-gray-500">Explore vacancies in projects and companies and see where you could fit in.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/community/blog/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g transform="translate(0,-952.36218)"><path d="M 17.78125 15 A 2.0002 2.0002 0 0 0 15.96875 17 L 15.96875 25.3125 L 8 25.3125 A 2.0002 2.0002 0 0 0 6 27.3125 L 6 83 A 2.0002 2.0002 0 0 0 8 85 L 92 85 A 2.0002 2.0002 0 1 0 92 81 L 10 81 L 10 29.3125 L 15.96875 29.3125 L 15.96875 74.75 A 2.0002 2.0002 0 1 0 19.96875 74.75 L 19.96875 19 L 89.84375 19 L 89.84375 73.96875 A 2.0002 2.0002 0 1 0 93.84375 73.96875 L 93.84375 17 A 2.0002 2.0002 0 0 0 91.84375 15 L 17.96875 15 A 2.0002 2.0002 0 0 0 17.78125 15 z M 28.75 26.34375 A 2.0002 2.0002 0 0 0 26.96875 28.34375 L 26.96875 51.03125 A 2.0002 2.0002 0 0 0 28.96875 53.03125 L 52.90625 53.03125 A 2.0002 2.0002 0 0 0 54.90625 51.03125 L 54.90625 28.34375 A 2.0002 2.0002 0 0 0 52.90625 26.34375 L 28.96875 26.34375 A 2.0002 2.0002 0 0 0 28.75 26.34375 z M 63.6875 26.34375 A 2.0029885 2.0029885 0 1 0 63.90625 30.34375 L 81.84375 30.34375 A 2.0002 2.0002 0 1 0 81.84375 26.34375 L 63.90625 26.34375 A 2.0002 2.0002 0 0 0 63.6875 26.34375 z M 30.96875 30.34375 L 50.90625 30.34375 L 50.90625 49.03125 L 30.96875 49.03125 L 30.96875 30.34375 z M 63.6875 37.6875 A 2.0029885 2.0029885 0 1 0 63.90625 41.6875 L 81.84375 41.6875 A 2.0002 2.0002 0 1 0 81.84375 37.6875 L 63.90625 37.6875 A 2.0002 2.0002 0 0 0 63.6875 37.6875 z M 63.6875 49.03125 A 2.0029885 2.0029885 0 1 0 63.90625 53.03125 L 81.84375 53.03125 A 2.0002 2.0002 0 1 0 81.84375 49.03125 L 63.90625 49.03125 A 2.0002 2.0002 0 0 0 63.6875 49.03125 z M 27.75 60.375 A 2.0029885 2.0029885 0 1 0 27.96875 64.375 L 81.84375 64.375 A 2.0002 2.0002 0 1 0 81.84375 60.375 L 27.96875 60.375 A 2.0002 2.0002 0 0 0 27.75 60.375 z M 27.75 71.71875 A 2.0029885 2.0029885 0 1 0 27.96875 75.71875 L 81.6875 75.71875 A 2.0002 2.0002 0 1 0 81.6875 71.71875 L 27.96875 71.71875 A 2.0002 2.0002 0 0 0 27.75 71.71875 z " transform="translate(0,952.36218)"></path></g></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">News</p></dt><dd class="ml-10 text-sm text-gray-500">Catch up on the latest news from the OCaml sphere!</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/community/aroundweb/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg viewBox="0 0 64 80" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M32,9A23,23,0,1,0,55,32,23.0259,23.0259,0,0,0,32,9Zm0,44A21,21,0,1,1,53,32,21.0239,21.0239,0,0,1,32,53ZM63,32A30.99,30.99,0,0,1,10.3,54.124,29.6168,29.6168,0,0,1,8,51.6027V55a1,1,0,0,1-2,0V49a1,1,0,0,1,1-1h6a1,1,0,0,1,0,2H9.2789a27.8374,27.8374,0,0,0,2.4174,2.6929A28.99,28.99,0,0,0,61,32a28.617,28.617,0,0,0-2.86-12.5645,1,1,0,1,1,1.8008-.871A30.6112,30.6112,0,0,1,63,32ZM5.86,44.5645a1,1,0,0,1-1.8008.871A30.6112,30.6112,0,0,1,1,32,30.99,30.99,0,0,1,53.7,9.876,29.6168,29.6168,0,0,1,56,12.3973V9a1,1,0,0,1,2,0v6a1,1,0,0,1-1,1H51a1,1,0,0,1,0-2h3.7211a27.8374,27.8374,0,0,0-2.4174-2.6929A28.99,28.99,0,0,0,3,32,28.617,28.617,0,0,0,5.86,44.5645ZM43.1411,20.1112a23.1406,23.1406,0,0,0,2.1978-1.3661,1,1,0,0,0-1.1582-1.63c-.5694.4049-1.16.7679-1.76,1.1113A22.1893,22.1893,0,0,0,40.02,13.8438,1,1,0,1,0,38.4,15.0166,20.1638,20.1638,0,0,1,40.6245,19.14,20.8665,20.8665,0,0,1,33,20.9617V13a1,1,0,0,0-2,0v7.9617A20.866,20.866,0,0,1,23.3755,19.14,20.1638,20.1638,0,0,1,25.6,15.0166a1,1,0,1,0-1.6191-1.1728,22.1893,22.1893,0,0,0-2.4013,4.3827c-.6-.3434-1.19-.7064-1.76-1.1113a1,1,0,0,0-1.1582,1.63,23.1406,23.1406,0,0,0,2.1978,1.3661A36.8955,36.8955,0,0,0,19.0317,31H13a1,1,0,0,0,0,2h6.0317a36.8955,36.8955,0,0,0,1.8272,10.8888,23.1406,23.1406,0,0,0-2.1978,1.3661,1,1,0,0,0,1.1582,1.63c.5694-.4049,1.16-.7679,1.76-1.1113a22.193,22.193,0,0,0,2.4013,4.3828A1,1,0,1,0,25.6,48.9834a20.1636,20.1636,0,0,1-2.224-4.1233A20.866,20.866,0,0,1,31,43.0383V51a1,1,0,0,0,2,0V43.0383A20.8665,20.8665,0,0,1,40.6245,44.86,20.1638,20.1638,0,0,1,38.4,48.9834,1,1,0,1,0,40.02,50.1563a22.193,22.193,0,0,0,2.4013-4.3828c.6.3434,1.1905.7064,1.76,1.1113a1,1,0,0,0,1.1582-1.63,23.1406,23.1406,0,0,0-2.1978-1.3661A36.8955,36.8955,0,0,0,44.9683,33H51a1,1,0,0,0,0-2H44.9683A36.8955,36.8955,0,0,0,43.1411,20.1112Zm-1.8222.9086A35.3906,35.3906,0,0,1,42.9679,31H33V22.9617A22.855,22.855,0,0,0,41.3189,21.02Zm-18.6378,0A22.855,22.855,0,0,0,31,22.9617V31H21.0321A35.3906,35.3906,0,0,1,22.6811,21.02Zm0,21.96A35.3906,35.3906,0,0,1,21.0321,33H31v8.0383A22.855,22.855,0,0,0,22.6811,42.98Zm18.6378,0A22.855,22.855,0,0,0,33,41.0383V33h9.9679A35.3906,35.3906,0,0,1,41.3189,42.98Z"></path></g></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Around the Web</p></dt><dd class="ml-10 text-sm text-gray-500">A bit of everything, this page encapsulates OCaml&#x27;s presence online, blogposts, videos, and mailing lists all live here.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/resources/archive/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg viewBox="0 0 32 40" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M28,3H4A3,3,0,0,0,1,6V8a3,3,0,0,0,2,2.816V26a3,3,0,0,0,3,3H26a3,3,0,0,0,3-3V10.816A3,3,0,0,0,31,8V6A3,3,0,0,0,28,3ZM27,26a1,1,0,0,1-1,1H6a1,1,0,0,1-1-1V11H27ZM29,8a1,1,0,0,1-1,1H4A1,1,0,0,1,3,8V6A1,1,0,0,1,4,5H28a1,1,0,0,1,1,1Z"></path><path d="M13,17h6a1,1,0,0,0,0-2H13a1,1,0,0,0,0,2Z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Archive</p></dt><dd class="ml-10 text-sm text-gray-500">Can&#x27;t find what you&#x27;re looking for? Try searching the Archive.</dd></a></div></div></div></div></nav><div class="flex-1 flex items-center justify-center px-2 md:justify-end "><div class="max-w-lg w-full md:max-w-xs"><label class="sr-only" for="search">Search ocaml.org</label><form id="searchform" action="https://duckduckgo.com/" method="get"><input type="hidden" name="sites" value="ocaml.org"/><div class="relative"><div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"><svg aria-hidden="true" class="h-5 w-5 text-gray-400" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" fill-rule="evenodd"></path></svg></div><input type="search" class="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md leading-5 bg-white placeholder-gray-500 focus:outline-none focus:placeholder-gray-400 focus:ring-1 focus:ring-orangedark focus:border-orangedarker sm:text-sm" id="search" name="q" placeholder="Search ocaml.org"/></div></form></div></div><div class="-mr-2 -my-2 md:hidden "><button class="bg-white rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500" type="button"><span class="sr-only">Open menu</span><svg aria-hidden="true" class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 6h16M4 12h16M4 18h16" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></button></div></div></div><div class="absolute top-0 inset-x-0 p-2 transition transform origin-top-right md:hidden z-10  hidden "><div class="rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 bg-white divide-y-2 divide-gray-50"><div class="pt-5 pb-6 px-5"><div class="flex items-center justify-between"><div><img class="h-8 w-auto sm:h-10" alt="" src="/static/logo1.jpeg"/></div><div class="-mr-2"><button class="bg-white rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500" type="button"><span class="sr-only"> Close menu </span><svg aria-hidden="true" class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></button></div></div><div class="mt-6"><nav class="grid gap-y-2"><h3 class="ml-6 mt-2 px-3 font-semibold text-gray-400 uppercase">Principles</h3><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/principles/whatisocaml/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 12.7 15.9" xmlns="http://www.w3.org/2000/svg"><path d="m9.01 1.23a0.676 0.676 0 0 0-0.658 0.52 7.02 7.02 0 0 0-0.185 1.41 0.338 0.338 0 0 1-0.674 0.0292 6.26 6.26 0 0 0-0.304-1.33 0.81 0.81 0 0 0-1.56 0.118 3.15 3.15 0 0 1-1.26 1.98 0.495 0.495 0 0 1-0.564 9e-3 1.49 1.49 0 0 1-0.459-0.492 0.495 0.495 0 0 1 0.023-0.531 1.22 1.22 0 0 0 0.141-0.266 0.295 0.295 0 0 0-0.374-0.383 0.987 0.987 0 0 0-0.183 0.0867 0.819 0.819 0 0 0-1.21-0.24 1.36 1.36 0 0 1-0.767 0.395 0.516 0.516 0 0 0 0.0788 1.03h0.42a0.789 0.789 0 0 0 0.507 0.259 2.67 2.67 0 0 0 2.32 2.59 0.471 0.471 0 0 0 0.328-0.0783 1.81 1.81 0 0 0 0.438 1.11 3.97 3.97 0 0 1 1.15 2.78 0.202 0.202 0 0 1-0.11 0.18 2.56 2.56 0 0 0-0.682 0.506 0.325 0.325 0 0 0 0.234 0.55h1.43a0.468 0.468 0 0 0 0.0934-0.784 0.202 0.202 0 0 1-0.0744-0.156v-1.43a1.5 1.5 0 0 0-0.15-1.08v-0.591a2.43 2.43 0 0 0 1.68 0.0748 3.43 3.43 0 0 0 1.4-0.668 1.78 1.78 0 0 0 0.228 0.465 2.84 2.84 0 0 1 0.408 2.9 0.202 0.202 0 0 1-0.115 0.11 2.56 2.56 0 0 0-0.934 0.617 0.325 0.325 0 0 0 0.234 0.55h1.43a0.468 0.468 0 0 0 0.122-0.759 0.202 0.202 0 0 1-0.0558-0.197 4.7 4.7 0 0 1 0.706-1.51 0.383 0.383 0 0 0 0.0598-0.309 6.18 6.18 0 0 1 0.035-2.97 1.06 1.06 0 0 0-0.45-1.16l-0.486-0.315a1.08 1.08 0 0 1-0.453-0.618 5.11 5.11 0 0 0-1.26-2.19 0.676 0.676 0 0 0-0.485-0.205zm-0.00227 0.181a0.495 0.495 0 0 1 0.355 0.15 4.93 4.93 0 0 1 1.21 2.11 1.26 1.26 0 0 0 0.529 0.721l0.486 0.315a0.882 0.882 0 0 1 0.374 0.962 6.36 6.36 0 0 0-0.0358 3.06 0.202 0.202 0 0 1-0.0319 0.163 4.88 4.88 0 0 0-0.733 1.57 0.383 0.383 0 0 0 0.105 0.374 0.287 0.287 0 0 1-0.0429 0.447h-1.38a0.143 0.143 0 0 1-0.103-0.243 2.38 2.38 0 0 1 0.868-0.574 0.383 0.383 0 0 0 0.216-0.208 3.02 3.02 0 0 0-0.429-3.08 1.6 1.6 0 0 1-0.218-1.33 0.0906 0.0906 0 0 0-0.174-0.0491 1.78 1.78 0 0 0-0.0319 0.83 3.25 3.25 0 0 1-1.39 0.686 2.25 2.25 0 0 1-1.63-0.0978v-0.624a0.0906 0.0906 0 0 0-0.181 0v1.46a1.32 1.32 0 0 1 0.15 1.01v1.46a0.383 0.383 0 0 0 0.14 0.297 0.287 0.287 0 0 1-0.0248 0.462h-1.38a0.143 0.143 0 0 1-0.103-0.243 2.38 2.38 0 0 1 0.634-0.47 0.383 0.383 0 0 0 0.209-0.343 4.15 4.15 0 0 0-1.19-2.9 1.62 1.62 0 0 1-0.308-1.57 0.0907 0.0907 0 1 0-0.172-0.058 1.81 1.81 0 0 0-0.073 0.298 0.29 0.29 0 0 1-0.324 0.243 2.48 2.48 0 0 1-2.16-2.42 0.789 0.789 0 0 0 0.404-0.176 0.0907 0.0907 0 0 0-0.116-0.139 0.608 0.608 0 0 1-0.888-0.123h-0.508a0.335 0.335 0 0 1-0.0505-0.667 1.54 1.54 0 0 0 0.86-0.438 0.638 0.638 0 0 1 0.942 0.212 0.987 0.987 0 0 0-0.0894 0.0907 0.0909 0.0909 0 1 0 0.138 0.119 0.805 0.805 0 0 1 0.342-0.234 0.114 0.114 0 0 1 0.144 0.148 1.04 1.04 0 0 1-0.119 0.227 0.676 0.676 0 0 0-0.031 0.725 1.68 1.68 0 0 0 0.515 0.551 0.676 0.676 0 0 0 0.772-0.0116 3.33 3.33 0 0 0 1.33-2.1 0.629 0.629 0 0 1 1.21-0.0912 6.08 6.08 0 0 1 0.295 1.29 0.52 0.52 0 0 0 1.04-0.0451 6.84 6.84 0 0 1 0.18-1.37 0.495 0.495 0 0 1 0.482-0.381z" stroke-width=".289"></path><path d="m2.16 2.76a0.128 0.128 0 1 0-0.256 0 0.128 0.128 0 1 0 0.256 0z" stroke-width=".2"></path></svg></span><span class="font-bold">Why OCaml</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/principles/users/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg class="stroke-0" version="1.1" viewBox="0 0 60 75" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M6,55h48c0.6,0,1-0.4,1-1V33c0-0.3-0.1-0.5-0.3-0.7l-9-8.4L44,5.9c0-0.1,0-0.1,0-0.2c0-0.1,0-0.1,0-0.2  c0-0.1-0.1-0.1-0.1-0.2c0,0-0.1-0.1-0.1-0.1c-0.1-0.1-0.1-0.1-0.2-0.1c0,0-0.1-0.1-0.1-0.1C43.3,5,43.1,5,43,5h-6  c-0.1,0-0.3,0-0.4,0.1c0,0-0.1,0-0.1,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0-0.1,0.1-0.1,0.1c0,0.1-0.1,0.1-0.1,0.2c0,0.1,0,0.1,0,0.2  c0,0.1,0,0.1,0,0.2l-1.3,20.8l-8-7.4c-0.3-0.3-0.7-0.3-1.1-0.2C25.2,19.2,25,19.6,25,20v10.7L12.7,19.3c-0.3-0.3-0.7-0.3-1.1-0.2  C11.2,19.2,11,19.6,11,20v12H6c-0.6,0-1,0.4-1,1v21C5,54.6,5.4,55,6,55z M42,7v1h-4V7H42z M37.8,10h4.6l1.1,11.9l-2.8-2.6  c-0.3-0.3-0.7-0.3-1.1-0.2C39.2,19.2,39,19.6,39,20v10.7l-2.4-2.2L37.8,10z M7,34h5c0.6,0,1-0.4,1-1V22.3l12.3,11.4  c0.3,0.3,0.7,0.3,1.1,0.2c0.4-0.2,0.6-0.5,0.6-0.9V22.3l12.3,11.4c0.3,0.3,0.7,0.3,1.1,0.2c0.4-0.2,0.6-0.5,0.6-0.9V22.3l3.1,2.9  c0,0,0,0,0,0l8.9,8.3V53H7V34z"></path><path d="M16,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C17,38.4,16.6,38,16,38z M15,42h-2v-2h2V42z"></path><path d="M24,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C25,38.4,24.6,38,24,38z M23,42h-2v-2h2V42z"></path><path d="M32,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C33,38.4,32.6,38,32,38z M31,42h-2v-2h2V42z"></path><path d="M40,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C41,38.4,40.6,38,40,38z M39,42h-2v-2h2V42z"></path><path d="M48,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C49,38.4,48.6,38,48,38z M47,42h-2v-2h2V42z"></path></svg></span><span class="font-bold">Industrial Users</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/principles/academic/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg class="stroke-2" version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g transform="translate(0,-952.36218)"><path d="M 47.25 23 A 1.0001 1.0001 0 0 0 47.125 23.0625 L 5.625 39.0625 A 1.0001 1.0001 0 0 0 5.625 40.90625 L 21.1875 46.90625 A 1.0001 1.0001 0 0 0 21.1875 47 L 21.1875 63.4375 A 1.0001 1.0001 0 0 0 21.8125 64.34375 L 47.09375 74.90625 A 1.0001 1.0001 0 0 0 47.84375 74.90625 L 73.15625 64.34375 A 1.0001 1.0001 0 0 0 73.75 63.4375 L 73.75 47 A 1.0001 1.0001 0 0 0 73.75 46.9375 L 80.875 44.1875 A 1.0040202 1.0040202 0 0 0 80.15625 42.3125 L 47.46875 54.9375 L 8.75 40 L 47.5 25.03125 L 87.9375 40.65625 L 87.9375 65.09375 C 85.072141 65.568778 82.875 68.037767 82.875 71 C 82.875 74.2988 85.600803 77 88.9375 77 C 92.274197 77 95 74.2988 95 71 C 95 68.037767 92.802859 65.568778 89.9375 65.09375 L 89.9375 40 A 1.0001 1.0001 0 0 0 89.3125 39.0625 L 47.84375 23.0625 A 1.0001 1.0001 0 0 0 47.25 23 z M 23.1875 47.6875 L 47.125 56.90625 A 1.0001 1.0001 0 0 0 47.84375 56.90625 L 71.75 47.6875 L 71.75 62.75 L 47.46875 72.90625 L 23.1875 62.75 L 23.1875 47.6875 z M 88.9375 66.96875 C 91.187128 66.96875 92.96875 68.7759 92.96875 71 C 92.96875 73.2241 91.187128 75 88.9375 75 C 86.687872 75 84.875 73.2241 84.875 71 C 84.875 68.7759 86.687872 66.96875 88.9375 66.96875 z " transform="translate(0,952.36218)"></path></g></svg></span><span class="font-bold">Academic Excellence</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/principles/successes/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 160 200" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M151.305,149.32l-35.11-68.89c-0.6-1.17-1.8-1.91-3.12-1.91s-2.52,0.74-3.12,1.91l-11.98,23.5l3.93,7.71l11.17-21.92  l29.4,57.69h-22.34h-2.801L66.999,48.66v-8.949h42.25c1.933,0,3.5-1.567,3.5-3.5V9.09c0-1.933-1.567-3.5-3.5-3.5h-45.75  c-1.933,0-3.5,1.567-3.5,3.5v13.824v13.297V48.66L8.69,149.321c-0.553,1.085-0.502,2.38,0.134,3.418  c0.636,1.039,1.767,1.672,2.984,1.672h103.381c0.001,0,0.002,0,0.003,0h4.863h28.14c1.21,0,2.34-0.63,2.98-1.67  C151.815,151.7,151.865,150.41,151.305,149.32z M66.999,22.914V12.59h38.75v20.122h-38.75V22.914z M63.499,57.207l10.873,21.332  c-5.251-0.709-10.46,2.09-12.683,7.08c-0.751,1.687-2.234,2.781-4.067,3.003c-1.829,0.221-3.533-0.488-4.665-1.947l-2.703-3.484  L63.499,57.207z M17.52,147.41l29.221-57.328l0.685,0.883c2.329,3.002,5.817,4.696,9.543,4.695c0.494,0,0.993-0.029,1.493-0.09  c4.273-0.517,7.87-3.172,9.622-7.104c1.063-2.386,3.744-3.588,6.231-2.8l4.402,1.396l30.76,60.347H17.52z"></path><path d="M90.023,15.97l-5.161,5.71l-2.427-1.948c-1.075-0.864-2.649-0.692-3.514,0.384c-0.865,1.077-0.692,2.65,0.384,3.514  l4.265,3.424c0.461,0.37,1.014,0.551,1.564,0.551c0.684,0,1.364-0.279,1.855-0.824l6.742-7.46c0.926-1.024,0.846-2.605-0.178-3.531  C92.529,14.866,90.948,14.947,90.023,15.97z"></path></svg></span><span class="font-bold">Success Stories</span></a><h3 class="ml-6 mt-2 px-3 font-semibold text-gray-400 uppercase">Resources</h3><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/resources/language/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M10.7,22.2c0.4,0.2,0.9,0.2,1.4,0c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1  c0.7,0,1.3-0.4,1.6-1.1c0.4-0.9,0-1.9-0.9-2.3c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3C10,21.7,10.3,22,10.7,22.2z"></path><path d="M57.2,20.2c-0.4,0.2-0.8,0.5-0.9,1s-0.2,0.9,0,1.4c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.6-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1c0.4-0.9-0.1-1.9-1-2.3C74.1,13,57.9,19.9,57.2,20.2z"></path><path d="M42.6,31.4c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0  C25.7,28,41,34.6,41.2,34.6c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.9,32.8,43.5,31.8,42.6,31.4z"></path><path d="M89,30.1c-14.6-5.9-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.9,0.4,1.9-0.1,2.3-1C90.4,31.5,89.9,30.5,89,30.1z"></path><path d="M42.6,42.9c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.4,0.9,1.4,1.3,2.3,1  c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.9,44.3,43.5,43.3,42.6,42.9z"></path><path d="M89,41.6c-14.6-5.9-30.8,1-31.5,1.3c-0.4,0.2-0.8,0.5-0.9,1c-0.2,0.4-0.2,0.9,0,1.4  c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1c0.2-0.1,15.5-6.6,28.7-1.2c0.9,0.4,1.9-0.1,2.3-1C90.4,43,89.9,42,89,41.6z"></path><path d="M42.5,54.4c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0  c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.8,55.8,43.4,54.8,42.5,54.4z"></path><path d="M88.9,53.1c-14.6-6-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1C90.2,54.5,89.8,53.5,88.9,53.1z"></path><path d="M41.8,69.1c0.7,0,1.3-0.4,1.6-1.1c0.4-0.9,0-1.9-0.9-2.3c-0.7-0.3-16.9-7.2-31.5-1.3  c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0c13.2-5.4,28.6,1.2,28.7,1.2C41.3,69,41.5,69.1,41.8,69.1z"></path><path d="M88.9,64.4c-14.6-6-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1C90.2,65.8,89.8,64.7,88.9,64.4z"></path><path d="M97.9,12.1c0-0.8-0.5-1.6-1.3-1.9C72-0.3,54.9,10.1,50,13.8C45,10.1,27.9-0.3,3.3,10.2  c-0.8,0.3-1.3,1.1-1.3,1.9v78.6c0,0.7,0.4,1.4,1,1.8c0.3,0.2,0.7,0.3,1.1,0.3c0.3,0,0.6-0.1,0.9-0.2c0.2-0.1,17.1-7.8,43.5-0.2l0,0  l3,0l0.1,0c17.3-7,39.3-0.9,43.6,0.4c0.6,0.2,1.3,0.1,1.8-0.3c0.5-0.4,0.8-1,0.8-1.7L97.9,12.1z M93.8,87.8V88  c-7.7-2.1-15.2-3.1-22.4-3.1c-1.2,0-2.4,0-3.6,0.1C76.2,83.3,84.9,84.3,93.8,87.8z M93.8,83.4c-20.6-7.6-35.7-0.5-41.7,3.3l0-69.3  c3.2-2.5,19-13,41.7-3.9L93.8,83.4z M34.5,85.4C22.3,84,13.2,85.6,7.9,87.2c6.1-2.2,11.7-3.1,16.5-3.1  C28.3,84.1,31.7,84.6,34.5,85.4z M6.2,13.4c23.1-9.2,38.6,1.5,41.7,4l0,69.3C43.9,84.1,35.7,80,24.3,80c-5.4,0-11.4,0.9-18.1,3.4  L6.2,13.4z"></path></svg></span><span class="font-bold">Language</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/packages/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M85.8,35.6l11.2-13c0.5-0.5,0.6-1.3,0.4-2c-0.2-0.7-0.7-1.2-1.4-1.5L63.1,8.3c-0.8-0.3-1.7,0-2.3,0.6L50,21.5L39.2,9    c-0.6-0.7-1.5-0.9-2.3-0.6L4,19.1c-0.7,0.2-1.2,0.8-1.4,1.5c-0.2,0.7,0,1.4,0.4,2l11.2,13L3,48.6c-0.5,0.5-0.6,1.3-0.4,2    c0.2,0.7,0.7,1.2,1.4,1.5l10.9,3.6v23.2c0,0.9,0.6,1.8,1.5,2.1l32.9,10.8c0.2,0.1,0.5,0.1,0.7,0.1c0.2,0,0.5,0,0.7-0.1l32.9-10.8    c0.9-0.3,1.5-1.1,1.5-2.1V55.7l11-3.6c0.7-0.2,1.2-0.8,1.4-1.5c0.2-0.7,0-1.4-0.4-2L85.8,35.6z M24,35.6l26-8.5l26,8.5l-26,8.5    L24,35.6z M63.1,12.9l28.5,9.3l-9.4,10.9l-28.5-9.3L63.1,12.9z M36.9,12.9l9.4,10.9l-28.5,9.3L8.4,22.2L36.9,12.9z M17.8,38.1    l28.5,9.3l-9.4,10.9L8.4,49L17.8,38.1z M19.2,77.2V57.1l17.6,5.8c0.2,0.1,0.4,0.1,0.7,0.1c0.6,0,1.2-0.3,1.6-0.7l8.6-10v34.4    L19.2,77.2z M80.7,77.2l-28.6,9.4V52.2l8.6,10c0.4,0.5,1,0.7,1.6,0.7c0.2,0,0.5,0,0.7-0.1l17.6-5.8V77.2z M63.1,58.3l-9.4-10.9    l28.5-9.3L91.6,49L63.1,58.3z"></path></g></svg></span><span class="font-bold">Packages</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/resources/applications/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M85.32,15.63H78.65a1.5,1.5,0,0,0-1.5,1.5v3.53H73.36a5.5,5.5,0,0,0-10.57,0h-7.9a5.5,5.5,0,0,0-10.57,0H36.11a5.5,5.5,0,0,0-10.57,0H22.85V17.13a1.5,1.5,0,0,0-1.5-1.5H14.68a1.5,1.5,0,0,0-1.5,1.5V82.87a1.5,1.5,0,0,0,1.5,1.5h6.67a1.5,1.5,0,0,0,1.5-1.5V74.63h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,9.29-2.27H54.79a5.49,5.49,0,0,0,9.29,2.27,5.49,5.49,0,0,0,9.28-2.27h3.79v8.24a1.5,1.5,0,0,0,1.5,1.5h6.67a1.5,1.5,0,0,0,1.5-1.5V17.13A1.5,1.5,0,0,0,85.32,15.63Zm-25.22,39a5.5,5.5,0,0,0-9.29-2.26,5.48,5.48,0,0,0-8,0,5.49,5.49,0,0,0-8,0,5.49,5.49,0,0,0-9.28,2.26H22.85v-14h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,8,0,5.49,5.49,0,0,0,9.28-2.27H62.79a5.49,5.49,0,0,0,10.57,0h3.79v14Zm-2.79,1.5a2.5,2.5,0,1,1-2.5-2.49A2.5,2.5,0,0,1,57.31,56.14Zm-8,0a2.5,2.5,0,1,1-2.49-2.49A2.5,2.5,0,0,1,49.31,56.14Zm-8,0a2.5,2.5,0,1,1-2.5-2.49A2.5,2.5,0,0,1,41.32,56.14Zm-8,0a2.5,2.5,0,1,1-2.49-2.49A2.5,2.5,0,0,1,33.32,56.14Zm-5-17a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,28.33,39.15Zm8,0a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,36.32,39.15Zm8,0a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,44.32,39.15Zm21.26,0a2.5,2.5,0,1,1,2.49,2.5A2.5,2.5,0,0,1,65.58,39.15Zm2.49-19.48a2.5,2.5,0,1,1-2.49,2.49A2.5,2.5,0,0,1,68.07,19.67Zm-18.47,0a2.5,2.5,0,1,1-2.5,2.49A2.5,2.5,0,0,1,49.6,19.67Zm-18.77,0a2.5,2.5,0,1,1-2.5,2.49A2.5,2.5,0,0,1,30.83,19.67Zm-5.29,4a5.49,5.49,0,0,0,10.57,0h8.21a5.49,5.49,0,0,0,10.57,0h7.9a5.49,5.49,0,0,0,10.57,0h3.79v14H73.36a5.5,5.5,0,0,0-10.57,0H52.1a5.49,5.49,0,0,0-9.28-2.26,5.49,5.49,0,0,0-8,0,5.49,5.49,0,0,0-9.28,2.26H22.85v-14ZM19.85,81.37H16.18V18.63h3.67Zm11-5.74a2.5,2.5,0,1,1,2.49-2.5A2.5,2.5,0,0,1,30.83,75.63Zm8,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,38.82,75.63Zm21.26,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,60.08,75.63Zm8,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,68.07,75.63Zm5.29-4a5.49,5.49,0,0,0-9.28-2.26,5.5,5.5,0,0,0-9.29,2.26H44.11a5.5,5.5,0,0,0-9.29-2.26,5.49,5.49,0,0,0-9.28,2.26H22.85v-14h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,8,0,5.48,5.48,0,0,0,8,0,5.49,5.49,0,0,0,9.29-2.27H77.15v14Zm10.46,9.74H80.15V18.63h3.67Z"></path></svg></span><span class="font-bold">Applications</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/resources/bestpractices/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M7,51h28.7c3.3,0,6.6-1.4,8.8-3.9L61.2,29H76c6.6,0,9-3.8,9-7c0-1.1-0.2-2.1-0.7-3H88c3.9,0,7-3.1,7-7s-3.1-7-7-7H45  c-0.1,0-0.1,0-0.2,0c0,0-0.1,0-0.2,0s-0.1,0-0.2,0c-0.1,0-0.1,0-0.2,0.1c0,0-0.1,0-0.2,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0,0,0,0,0  L22.3,21H7c-1.1,0-2,0.9-2,2v26C5,50.1,5.9,51,7,51z M76,25H64.5c0.5-1.1,0.8-2.4,0.7-3.7c-0.1-0.8-0.3-1.6-0.6-2.3H78  c1.7,0,3,1.3,3,3C81,24.7,77.5,25,76,25z M19,25h4c0.2,0,0.4,0,0.5-0.1c0,0,0.1,0,0.1,0c0.2-0.1,0.3-0.1,0.5-0.2c0,0,0,0,0,0L45.7,9  H88c1.7,0,3,1.3,3,3c0,1.6-1.3,3-3,3H58c-0.1,0-0.3,0-0.4,0c-1.8,0.2-3.5,1-4.7,2.3L34.9,36.9c-0.7,0.8-0.7,2.1,0.1,2.8  s2.1,0.7,2.8-0.1l18-19.5c1.1-1.2,2.9-1.4,4.2-0.5c0.7,0.5,1.1,1.3,1.2,2.1c0.1,0.8-0.2,1.7-0.8,2.3L41.6,44.4  c-1.5,1.6-3.7,2.6-5.9,2.6H19V25z M9,25h6v22H9V25z M93,49H64.3c-3.3,0-6.6,1.4-8.8,3.9L38.8,71H24c-6.6,0-9,3.8-9,7  c0,1.1,0.2,2.1,0.7,3H12c-3.9,0-7,3.1-7,7s3.1,7,7,7h43c0,0,0,0,0,0c0.2,0,0.4,0,0.5-0.1c0,0,0.1,0,0.1,0c0.2-0.1,0.3-0.1,0.5-0.2  c0,0,0,0,0,0L77.7,79H93c1.1,0,2-0.9,2-2V51C95,49.9,94.1,49,93,49z M24,75h11.5c-0.5,1.1-0.8,2.4-0.7,3.7c0.1,0.8,0.3,1.6,0.6,2.3  H22c-1.7,0-3-1.4-3-3C19,75.3,22.5,75,24,75z M81,75h-4c-0.1,0-0.2,0-0.3,0c0,0-0.1,0-0.1,0c-0.1,0-0.2,0-0.2,0.1c0,0-0.1,0-0.2,0.1  s-0.1,0-0.2,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0,0,0,0,0L54.3,91H12c-1.7,0-3-1.4-3-3c0-1.7,1.3-3,3-3h30c0.1,0,0.3,0,0.4,0  c1.8-0.2,3.5-0.9,4.7-2.3l17.9-19.5c0.7-0.8,0.7-2.1-0.1-2.8c-0.8-0.7-2.1-0.7-2.8,0.1l-18,19.5c-1.1,1.2-2.9,1.5-4.2,0.5  c-0.7-0.5-1.1-1.3-1.2-2.1c-0.1-0.9,0.2-1.7,0.8-2.3l18.8-20.4c1.5-1.6,3.7-2.6,5.9-2.6H81V75z M91,75h-6V53h6V75z"></path></svg></span><span class="font-bold">Best Practices</span></a><h3 class="ml-6 mt-2 px-3 font-semibold text-gray-400 uppercase">Community</h3><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/community/opportunities/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 1024 1280" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M512,300.4c-31,0-60-14.7-81.7-41.3c-20.6-25.2-32-58-32-92.1c0-34.5,11.8-63.3,34.1-83.4c20.1-18.2,48.4-28.2,79.6-28.2   c31.2,0,59.5,10,79.6,28.2c22.3,20.1,34.1,49,34.1,83.4c0,34.2-11.4,66.9-32,92.1C572,285.7,543,300.4,512,300.4z M512,95.4   c-17.3,0-73.7,5.2-73.7,71.6c0,24.6,8.4,49,23,66.8c14,17.1,32,26.6,50.7,26.6c18.7,0,36.7-9.4,50.7-26.6   c14.6-17.9,23-42.2,23-66.8C585.7,100.6,529.3,95.4,512,95.4z"></path><rect height="44.4" width="40" x="383.9" y="470.9"></rect><path d="M338.4,515.4h-40v-83.6c0-35,20.6-66.7,52.6-80.9l100-44.4c10.4-4.6,22.4-1.5,29.2,7.5l31.9,41.7l32.4-41.7   c6.8-9,18.8-12,29.2-7.4l99.4,44.3c31.9,14.2,52.5,45.9,52.5,80.9v83.6h-40v-83.6c0-19.2-11.3-36.6-28.7-44.3l-88.2-39.3   l-56.8,73.1l-55.9-73.1l-88.7,39.4c-17.5,7.8-28.8,25.2-28.8,44.3V515.4z"></path><rect height="44.4" width="40" x="600.1" y="470.9"></rect><rect height="126.9" width="40" x="492" y="388.4"></rect><path d="M819.5,784.5c-3.3,0-6.7-0.6-9.9-2c-9.6-4-15.9-13.3-15.9-23.7v-51.2h-75.1c-13,0-23.6-10.6-23.6-23.6V583.8   c0-13,10.6-23.6,23.6-23.6h75.1V509c0-10.5,6.2-19.8,15.9-23.8c9.7-4,20.7-1.8,28.1,5.6l124.9,124.9c10,10,10,26.4,0,36.4   L837.6,776.9C832.7,781.9,826.1,784.5,819.5,784.5z M735,667.6h98.7v56.7l90.5-90.5l-90.5-90.5v56.8H735V667.6z"></path><path d="M512,968.6c-6.6,0-13.2-2.5-18.2-7.5l-125-124.9c-7.3-7.3-9.5-18.2-5.7-27.7c3.9-9.6,13.1-16,23.5-16.2l0.4,0h51.2v-75.1   c0-13,10.6-23.6,23.6-23.6h100.3c13,0,23.6,10.6,23.6,23.6v75.1H637c10.4,0,19.7,6.2,23.7,15.9c4,9.7,1.8,20.7-5.6,28.1L530.2,961   C525.2,966.1,518.6,968.6,512,968.6z M421.5,832.2l90.5,90.5l90.5-90.5h-56.7v-98.7h-67.5v98.7H421.5z"></path><path d="M204.5,784.5c-6.7,0-13.3-2.6-18.2-7.6L61.5,652c-10-10-10-26.4,0-36.4l124.9-124.9c7.4-7.4,18.4-9.6,28.1-5.6   c9.7,4,15.9,13.3,15.9,23.8v51.2h75.1c13,0,23.6,10.6,23.6,23.6V684c0,13-10.6,23.6-23.6,23.6h-75.1v51.2   c0,10.4-6.2,19.7-15.9,23.7C211.2,783.9,207.9,784.5,204.5,784.5z M99.8,633.8l90.5,90.5v-56.7H289v-67.4h-98.7v-56.8L99.8,633.8z"></path></g></svg></span><span class="font-bold">Opportunities</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/community/blog/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g transform="translate(0,-952.36218)"><path d="M 17.78125 15 A 2.0002 2.0002 0 0 0 15.96875 17 L 15.96875 25.3125 L 8 25.3125 A 2.0002 2.0002 0 0 0 6 27.3125 L 6 83 A 2.0002 2.0002 0 0 0 8 85 L 92 85 A 2.0002 2.0002 0 1 0 92 81 L 10 81 L 10 29.3125 L 15.96875 29.3125 L 15.96875 74.75 A 2.0002 2.0002 0 1 0 19.96875 74.75 L 19.96875 19 L 89.84375 19 L 89.84375 73.96875 A 2.0002 2.0002 0 1 0 93.84375 73.96875 L 93.84375 17 A 2.0002 2.0002 0 0 0 91.84375 15 L 17.96875 15 A 2.0002 2.0002 0 0 0 17.78125 15 z M 28.75 26.34375 A 2.0002 2.0002 0 0 0 26.96875 28.34375 L 26.96875 51.03125 A 2.0002 2.0002 0 0 0 28.96875 53.03125 L 52.90625 53.03125 A 2.0002 2.0002 0 0 0 54.90625 51.03125 L 54.90625 28.34375 A 2.0002 2.0002 0 0 0 52.90625 26.34375 L 28.96875 26.34375 A 2.0002 2.0002 0 0 0 28.75 26.34375 z M 63.6875 26.34375 A 2.0029885 2.0029885 0 1 0 63.90625 30.34375 L 81.84375 30.34375 A 2.0002 2.0002 0 1 0 81.84375 26.34375 L 63.90625 26.34375 A 2.0002 2.0002 0 0 0 63.6875 26.34375 z M 30.96875 30.34375 L 50.90625 30.34375 L 50.90625 49.03125 L 30.96875 49.03125 L 30.96875 30.34375 z M 63.6875 37.6875 A 2.0029885 2.0029885 0 1 0 63.90625 41.6875 L 81.84375 41.6875 A 2.0002 2.0002 0 1 0 81.84375 37.6875 L 63.90625 37.6875 A 2.0002 2.0002 0 0 0 63.6875 37.6875 z M 63.6875 49.03125 A 2.0029885 2.0029885 0 1 0 63.90625 53.03125 L 81.84375 53.03125 A 2.0002 2.0002 0 1 0 81.84375 49.03125 L 63.90625 49.03125 A 2.0002 2.0002 0 0 0 63.6875 49.03125 z M 27.75 60.375 A 2.0029885 2.0029885 0 1 0 27.96875 64.375 L 81.84375 64.375 A 2.0002 2.0002 0 1 0 81.84375 60.375 L 27.96875 60.375 A 2.0002 2.0002 0 0 0 27.75 60.375 z M 27.75 71.71875 A 2.0029885 2.0029885 0 1 0 27.96875 75.71875 L 81.6875 75.71875 A 2.0002 2.0002 0 1 0 81.6875 71.71875 L 27.96875 71.71875 A 2.0002 2.0002 0 0 0 27.75 71.71875 z " transform="translate(0,952.36218)"></path></g></svg></span><span class="font-bold">News</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/community/aroundweb/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg viewBox="0 0 64 80" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M32,9A23,23,0,1,0,55,32,23.0259,23.0259,0,0,0,32,9Zm0,44A21,21,0,1,1,53,32,21.0239,21.0239,0,0,1,32,53ZM63,32A30.99,30.99,0,0,1,10.3,54.124,29.6168,29.6168,0,0,1,8,51.6027V55a1,1,0,0,1-2,0V49a1,1,0,0,1,1-1h6a1,1,0,0,1,0,2H9.2789a27.8374,27.8374,0,0,0,2.4174,2.6929A28.99,28.99,0,0,0,61,32a28.617,28.617,0,0,0-2.86-12.5645,1,1,0,1,1,1.8008-.871A30.6112,30.6112,0,0,1,63,32ZM5.86,44.5645a1,1,0,0,1-1.8008.871A30.6112,30.6112,0,0,1,1,32,30.99,30.99,0,0,1,53.7,9.876,29.6168,29.6168,0,0,1,56,12.3973V9a1,1,0,0,1,2,0v6a1,1,0,0,1-1,1H51a1,1,0,0,1,0-2h3.7211a27.8374,27.8374,0,0,0-2.4174-2.6929A28.99,28.99,0,0,0,3,32,28.617,28.617,0,0,0,5.86,44.5645ZM43.1411,20.1112a23.1406,23.1406,0,0,0,2.1978-1.3661,1,1,0,0,0-1.1582-1.63c-.5694.4049-1.16.7679-1.76,1.1113A22.1893,22.1893,0,0,0,40.02,13.8438,1,1,0,1,0,38.4,15.0166,20.1638,20.1638,0,0,1,40.6245,19.14,20.8665,20.8665,0,0,1,33,20.9617V13a1,1,0,0,0-2,0v7.9617A20.866,20.866,0,0,1,23.3755,19.14,20.1638,20.1638,0,0,1,25.6,15.0166a1,1,0,1,0-1.6191-1.1728,22.1893,22.1893,0,0,0-2.4013,4.3827c-.6-.3434-1.19-.7064-1.76-1.1113a1,1,0,0,0-1.1582,1.63,23.1406,23.1406,0,0,0,2.1978,1.3661A36.8955,36.8955,0,0,0,19.0317,31H13a1,1,0,0,0,0,2h6.0317a36.8955,36.8955,0,0,0,1.8272,10.8888,23.1406,23.1406,0,0,0-2.1978,1.3661,1,1,0,0,0,1.1582,1.63c.5694-.4049,1.16-.7679,1.76-1.1113a22.193,22.193,0,0,0,2.4013,4.3828A1,1,0,1,0,25.6,48.9834a20.1636,20.1636,0,0,1-2.224-4.1233A20.866,20.866,0,0,1,31,43.0383V51a1,1,0,0,0,2,0V43.0383A20.8665,20.8665,0,0,1,40.6245,44.86,20.1638,20.1638,0,0,1,38.4,48.9834,1,1,0,1,0,40.02,50.1563a22.193,22.193,0,0,0,2.4013-4.3828c.6.3434,1.1905.7064,1.76,1.1113a1,1,0,0,0,1.1582-1.63,23.1406,23.1406,0,0,0-2.1978-1.3661A36.8955,36.8955,0,0,0,44.9683,33H51a1,1,0,0,0,0-2H44.9683A36.8955,36.8955,0,0,0,43.1411,20.1112Zm-1.8222.9086A35.3906,35.3906,0,0,1,42.9679,31H33V22.9617A22.855,22.855,0,0,0,41.3189,21.02Zm-18.6378,0A22.855,22.855,0,0,0,31,22.9617V31H21.0321A35.3906,35.3906,0,0,1,22.6811,21.02Zm0,21.96A35.3906,35.3906,0,0,1,21.0321,33H31v8.0383A22.855,22.855,0,0,0,22.6811,42.98Zm18.6378,0A22.855,22.855,0,0,0,33,41.0383V33h9.9679A35.3906,35.3906,0,0,1,41.3189,42.98Z"></path></g></svg></span><span class="font-bold">Around the Web</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/resources/archive/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg viewBox="0 0 32 40" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M28,3H4A3,3,0,0,0,1,6V8a3,3,0,0,0,2,2.816V26a3,3,0,0,0,3,3H26a3,3,0,0,0,3-3V10.816A3,3,0,0,0,31,8V6A3,3,0,0,0,28,3ZM27,26a1,1,0,0,1-1,1H6a1,1,0,0,1-1-1V11H27ZM29,8a1,1,0,0,1-1,1H4A1,1,0,0,1,3,8V6A1,1,0,0,1,4,5H28a1,1,0,0,1,1,1Z"></path><path d="M13,17h6a1,1,0,0,0,0-2H13a1,1,0,0,0,0,2Z"></path></svg></span><span class="font-bold">Archive</span></a></nav></div></div></div></div></div></div><main class="relative bg-graylight pb-1"><div class="relative bg-indigo-600"><div class="max-w-7xl mx-auto py-3 px-3 sm:px-6 lg:px-8"><div class="pr-16 sm:text-center sm:px-16"><p class="font-medium text-white"><span class="">Future page</span></p></div></div></div><div class="max-w-7xl mx-auto"><div class=" mx-auto py-16 px-4 sm:py-24 sm:px-6 lg:px-8"><div class="text-center"><h1 class=" text-4xl font-extrabold text-gray-900 sm:text-5xl sm:tracking-tight lg:text-6xl">Tutorials</h1><p class="max-w-xl mt-5 mx-auto text-xl text-gray-500"></p></div></div><div class="pb-8"><div class="grid grid-cols-1 lg:grid-cols-2 gap-x-28 gap-y-4 px-8"><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Up and Running with OCaml</h2><p>Help you install OCaml, the Dune build system, and support for your favourite text editor or IDE.
</p></div><a class="text-orangedark" href="/en/resources/up-and-running-with-ocaml/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>A First Hour with OCaml</h2><p>Discover the OCaml programming language in this longer tutorial that takes you from absolute beginner to someone who is able to write programs in OCaml.
</p></div><a class="text-orangedark" href="/en/resources/a-first-hour-with-ocaml/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>OCaml Programming Guidelines</h2><p>Opinionated guidelines for writing OCaml code
</p></div><a class="text-orangedark" href="/en/resources/ocaml-programming-guidelines/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Compiling OCaml Projects</h2><p>An introduction to the OCaml compiler tools for building OCaml projects as well as the most common build tools
</p></div><a class="text-orangedark" href="/en/resources/compiling-ocaml-projects/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Data Types and Matching</h2><p>Learn to build custom types and write function to process this data
</p></div><a class="text-orangedark" href="/en/resources/data-types-and-matching/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Functional Programming</h2><p>A guide to functional programming in OCaml
</p></div><a class="text-orangedark" href="/en/resources/functional-programming/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>If Statements, Loops and Recursions</h2><p>Learn basic control-flow and recusion in OCaml
</p></div><a class="text-orangedark" href="/en/resources/if-statements-loops-and-recursions/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Modules</h2><p>Learn about OCaml modules and how they can be used to cleanly separate distinct parts of your program
</p></div><a class="text-orangedark" href="/en/resources/modules/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Labels</h2><p>Provide labels to your functions arguments
</p></div><a class="text-orangedark" href="/en/resources/labels/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Pointers in OCaml</h2><p>Use OCaml&#x27;s explicit pointers with references
</p></div><a class="text-orangedark" href="/en/resources/pointers-in-ocaml/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Null Pointers, Asserts and Warnings</h2><p>Handling warnings and asserting invariants for your code
</p></div><a class="text-orangedark" href="/en/resources/null-pointers-asserts-and-warnings/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Functors</h2><p>Learn about functors, modules parameterised by other modules
</p></div><a class="text-orangedark" href="/en/resources/functors/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Objects</h2><p>OCaml is an object-oriented, imperative, functional programming language
</p></div><a class="text-orangedark" href="/en/resources/objects/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Error Handling</h2><p>Discover the different ways you can manage errors in your OCaml programs
</p></div><a class="text-orangedark" href="/en/resources/error-handling/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Common Error Messages</h2><p>Understand the most common error messages the OCaml compiler can throw at you
</p></div><a class="text-orangedark" href="/en/resources/common-error-messages/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Debug</h2><p>Learn to build custom types and write function to process this data
</p></div><a class="text-orangedark" href="/en/resources/debug/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Map</h2><p>Create a mapping using the standard library&#x27;s Map module
</p></div><a class="text-orangedark" href="/en/resources/map/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Sets</h2><p>The standard library&#x27;s Set module
</p></div><a class="text-orangedark" href="/en/resources/sets/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Hashtables</h2><p>Discover efficient and mutable lookup tables with OCaml&#x27;s Hashtbl module
</p></div><a class="text-orangedark" href="/en/resources/hashtables/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Streams</h2><p>Streams offer an abstraction over consuming items from sequences
</p></div><a class="text-orangedark" href="/en/resources/streams/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Format</h2><p>The Format module of Caml Light and OCaml&#x27;s standard libraries provides pretty-printing facilities to get a fancy display for printing routines
</p></div><a class="text-orangedark" href="/en/resources/format/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Calling C Libraries</h2><p>Cross the divide and call C code from your OCaml program
</p></div><a class="text-orangedark" href="/en/resources/calling-c-libraries/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Calling Fortran Libraries</h2><p>Cross the divide and call Fortran code from your OCaml program
</p></div><a class="text-orangedark" href="/en/resources/calling-fortran-libraries/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Command-line Arguments</h2><p>The Arg module that comes with the compiler can help you write command line interfaces
</p></div><a class="text-orangedark" href="/en/resources/command-line-arguments/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>File Manipulation</h2><p>A guide to basic file manipulation in OCaml with the standard library
</p></div><a class="text-orangedark" href="/en/resources/file-manipulation/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Garbage Collection</h2><p>OCaml is a garbage collected language meaning you don&#x27;t have to worry about allocating and freeing memory
</p></div><a class="text-orangedark" href="/en/resources/garbage-collection/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Performance and Profiling</h2><p>Understand how to profile your OCaml code to analyse its performance and produce faster programs
</p></div><a class="text-orangedark" href="/en/resources/performance-and-profiling/">Read more...</a></div><div class="py-4 px-4 bg-white rounded-lg"><div class="prose"><h2>Comparison of Standard Containers</h2><p>A comparison of some core data-structures including lists, queues and arrays
</p></div><a class="text-orangedark" href="/en/resources/comparison-of-standard-containers/">Read more...</a></div></div></div></div></main><div class="relative"><footer aria-labelledby="footerHeading" class="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8"><h2 class="sr-only" id="footerHeading">Footer</h2><div class="xl:grid xl:grid-cols-3 xl:gap-8"><div class="space-y-8 xl:col-span-1"><img class="h-10" alt="OCaml" src="/static/ocaml-logo.jpeg"/><p class="text-gray-500 text-base ">Innovation. Community. Security.</p><div class="flex space-x-6"><a aria-label="Discourse" class="text-gray-400 hover:text-gray-500" href="https://discuss.ocaml.org" target="_blank"><img aria-hidden="true" class="h-6 w-6" alt="" src="/static/discourselogo.png"/></a><a aria-label="GitHub" class="text-gray-400 hover:text-gray-500" href="https://sourcegraph.com/search?q=repo:ocaml/ocaml%24+or+repo:janestreet/base+or+repo:gitlab.com/tezos/tezos%24+or+repo:c-cube/ocaml-containers+or+repo:ocaml-batteries-team/batteries-included+or+repo:mirage/mirage%24+or+repo:ocsigen/lwt+or+repo:janestreet/async%24&amp;patternType=literal" target="_blank"><svg aria-hidden="true" class="h-6 w-6" fill="currentColor" viewBox="0 0 24 24"><path clip-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" fill-rule="evenodd"></path></svg></a><a aria-label="Twitter" class="text-gray-400 hover:text-gray-500" href="https://fosstodon.org/tags/ocaml" target="_blank"><svg aria-hidden="true" class="h-6 w-6" fill="currentColor" viewBox="0 0 24 24"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg></a></div></div><div class="grid grid-cols-2 gap-8 mt-12 xl:mt-0 xl:col-span-2"><div class="md:grid md:grid-cols-2 md:gap-8"><div class=""><h3 class="text-sm font-semibold text-gray-400 tracking-wider uppercase">Principles</h3><ul class="mt-4 space-y-4"><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/principles/whatisocaml/">Why OCaml</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/principles/users/">Industrial Users</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/principles/academic/">Academic Excellence</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/principles/successes/">Success Stories</a></li></ul></div><div class="mt-12 md:mt-0"><h3 class="text-sm font-semibold text-gray-400 tracking-wider uppercase">Resources</h3><ul class="mt-4 space-y-4"><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/resources/language/">Language</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/packages/">Packages</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/resources/applications/">Applications</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/resources/bestpractices/">Best Practices</a></li></ul></div></div><div class="md:grid md:grid-cols-2 md:gap-8"><div class=""><h3 class="text-sm font-semibold text-gray-400 tracking-wider uppercase">Community</h3><ul class="mt-4 space-y-4"><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/community/opportunities/">Opportunities</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/community/blog/">News</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/community/aroundweb/">Around the Web</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/resources/archive/">Archive</a></li></ul></div><div class="mt-12 md:mt-0"><h3 class="text-sm font-semibold text-gray-400 tracking-wider uppercase">Legal</h3><ul class="mt-4 space-y-4"><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/legal/privacy/">Privacy</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/legal/terms/">Terms</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/legal/carbonfootprint/">Carbon Footprint</a></li></ul></div></div></div></div><p class="text-gray-500 text-base mt-10">Thank you to our <a class="text-orangedark underline" href="/en/legal/carbonfootprint/#hostingproviders">Hosting Providers</a></p></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"content":{"title":"Tutorials","pageDescription":"","tutorials":[{"title":"Up and Running with OCaml","slug":"up-and-running-with-ocaml","description":"Help you install OCaml, the Dune build system, and support for your favourite text editor or IDE.\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"getting-started","tl":0},"users":{"hd":"Beginner","tl":0},"body_md":"\nThis page will help you install OCaml, the Dune build system, and support for\nyour favourite text editor or IDE. These instructions work on Windows, Unix\nsystems like Linux, and macOS.\n\n## Installing OCaml\n\nThere are two procedures: one for Unix-like systems, and one for Windows.\n\n### For Linux and macOS\n\nWe will install OCaml using opam, the OCaml package manager.  We will also use\nopam when we wish to install third-party OCaml libraries.\n\n**For macOS**\n\n```\n# Homebrew\nbrew install opam\n\n# MacPort\nport install opam\n```\n\n**For Linux** the preferred way is to use your system's package manager on\nLinux (e.g `apt-get install opam` or similar). [Details of all installation\nmethods.](https://opam.ocaml.org/doc/Install.html)\n\nThen, we install an OCaml compiler:\n\n```\n# environment setup\nopam init\neval `opam env`\n\n# install given version of the compiler\nopam switch create 4.11.1\neval `opam env`\n```\n\nNow, OCaml is up and running:\n\n```\n$ which ocaml\n/Users/frank/.opam/4.11.1/bin/ocaml\n\n$ ocaml -version\nThe OCaml toplevel, version 4.11.1\n```\n\n**For either Linux or macOS** as an alternative, a binary distribution of opam is\navailable:\n\n```\nsh \u003c(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)\n```\n\n### For Windows\n\nWe use the [OCaml for Windows](https://fdopen.github.io/opam-repository-mingw/)\ninstaller which comes in 32bit and 64bit versions. This installer gives you\nopam and OCaml installations all in one go. It is used from within a Cygwin\nenvironment, but the executables produced have no dependency on Cygwin at all.\n\n## The OCaml top level\n\nOCaml comes with two compilers: for native code, and for byte code. We shall\nuse one of those in a moment. But first, let's use OCaml's top level (sometimes\nknown as a REPL in other languages):\n\n```\n$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n\n```\n\nWe typed the phrase `1 + 2 * 3` and then signalled to OCaml that we had\nfinished by typing `;;` followed by the Enter key. OCaml calculated the\nresult, `7` and its type `int` and showed them to us. We exit by running the\nbuilt-in `exit` function with exit code 0:\n\n```\n$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n# exit 0;;\n$\n```\n\nThere are two ways to improve your experience with the OCaml top level: you can\ninstall the popular [`rlwrap`](https://github.com/hanslub42/rlwrap) on your\nsystem and invoke `rlwrap ocaml` instead of `ocaml` to get line-editing\nfacilities inside the OCaml top level, or you can install the alternative top\nlevel `utop` using opam:\n\n```\n$ opam install utop\n```\n\nWe run it by typing `utop` instead of `ocaml`. You can read more about\n[utop](https://github.com/ocaml-community/utop).\n\n## Installing the Dune build system\n\nDune is a build system for OCaml. It takes care of all the low level details of\nOCaml compilation. We install it with opam:\n\n```\n$ opam install dune\nThe following actions will be performed:\n  - install dune 2.7.1\n\n\u003c\u003e\u003c\u003e Gathering sources \u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\n[default] https://opam.ocaml.org/2.0.7/archives/dune.2.7.1+opam.tar.gz\ndownloaded\n\n\u003c\u003e\u003c\u003e Processing actions \u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\n-\u003e installed dune.2.7.1\nDone.\n```\n\n## A first project\n\nLet's begin the simplest project with Dune and OCaml. We create a new directory\nand ask `dune` to initialise a new project:\n\n```\n$ mkdir helloworld\n$ cd helloworld/\n$ dune init exe helloworld\nSuccess: initialized executable component named helloworld\n```\n\nBuilding our program is as simple as typing `dune build`:\n\n```\n$ dune build\nInfo: Creating file dune-project with this contents:\n| (lang dune 2.7)\nDone: 8/11 (jobs: 1)\n```\n\nWhen we change our program, we type `dune build` again to make a new\nexecutable. We can run the executable with `dune exec` (it's called\n`helloworld.exe` even when we're not using Windows):\n\n```\n$ dune exec ./helloworld.exe\nHello, World!        \n```\n\nLet's look at the contents of our new directory. Dune has added the\n`helloworld.ml` file, which is our OCaml program. It has also added our `dune`\nfile, which tells dune how to build the program, and a `_build` subdirectory,\nwhich is dune's working space.\n\n```\n$ ls\n_build\t\tdune\t\thelloworld.ml\n```\n\nThe `helloworld.exe` executable is stored inside the `_build/default` subdirectory, so\nit's easier to run with `dune exec`. To ship the executable, we can just copy\nit from inside `_build/default` to somewhere else.\n\nHere is the contents of the automatically-generated `dune` file. When we want\nto add components to your project, such as third-party libraries, we edit this\nfile.\n\n```\n(executable\n (name helloworld))\n```\n\n## Editor support for OCaml\n\nFor **Visual Studio Code**, and other editors support the Language Server\nProtocol, the OCaml language server can be installed with opam:\n\n```\n$ opam install ocaml-lsp-server\n```\n\nNow, we install the OCaml Platform Visual Studio Code extension from the Visual\nStudio Marketplace.\n\nUpon first loading an OCaml source file, you may be prompted to select the\ntoolchain in use: pick OCaml the version of OCaml you are using, e.g. 4.11.1\nfrom the list. Now, help is available by hovering over symbols in your program:\n\n![Visual Studio Code](/tutorials/vscode.png \"\")\n\n**On Windows**, we must launch Visual Studio Code from within the Cygwin window,\nrather than by clicking on its icon (otherwise, the language server will not be\nfound):\n\n```\n$ /cygdrive/c/Users/Frank\\ Smith/AppData/Local/Programs/Microsoft\\ VS\\ Code/Code.exe\n```\n\n**For Vim and Emacs**, install the [Merlin](https://github.com/ocaml/merlin)\nsystem using opam:\n\n```\n$ opam install merlin\n```\n\nThe installation procedure will print instructions on how to link Merlin with\nyour editor.\n\n**On Windows**, when using Vim, the default cygwin Vim will not work with\nMerlin. You will need install Vim separately. In addition to the usual\ninstructions printed when installing Merlin, you may need to set the PATH in\nVim:\n\n```\nlet $PATH .= \";\".substitute(system('opam config var bin'),'\\n$','','''')\n```\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#installing-ocaml\"\u003eInstalling OCaml\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-ocaml-top-level\"\u003eThe OCaml top level\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#installing-the-dune-build-system\"\u003eInstalling the Dune build system\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#a-first-project\"\u003eA first project\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#editor-support-for-ocaml\"\u003eEditor support for OCaml\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eThis page will help you install OCaml, the Dune build system, and support for\nyour favourite text editor or IDE. These instructions work on Windows, Unix\nsystems like Linux, and macOS.\u003c/p\u003e\n\u003ch2 id=\"installing-ocaml\"\u003eInstalling OCaml\u003c/h2\u003e\n\u003cp\u003eThere are two procedures: one for Unix-like systems, and one for Windows.\u003c/p\u003e\n\u003ch3 id=\"for-linux-and-macos\"\u003eFor Linux and macOS\u003c/h3\u003e\n\u003cp\u003eWe will install OCaml using opam, the OCaml package manager.  We will also use\nopam when we wish to install third-party OCaml libraries.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFor macOS\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Homebrew\nbrew install opam\n\n# MacPort\nport install opam\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eFor Linux\u003c/strong\u003e the preferred way is to use your system's package manager on\nLinux (e.g \u003ccode\u003eapt-get install opam\u003c/code\u003e or similar). \u003ca href=\"https://opam.ocaml.org/doc/Install.html\"\u003eDetails of all installation\nmethods.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eThen, we install an OCaml compiler:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# environment setup\nopam init\neval `opam env`\n\n# install given version of the compiler\nopam switch create 4.11.1\neval `opam env`\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, OCaml is up and running:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ which ocaml\n/Users/frank/.opam/4.11.1/bin/ocaml\n\n$ ocaml -version\nThe OCaml toplevel, version 4.11.1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eFor either Linux or macOS\u003c/strong\u003e as an alternative, a binary distribution of opam is\navailable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esh \u0026lt;(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"for-windows\"\u003eFor Windows\u003c/h3\u003e\n\u003cp\u003eWe use the \u003ca href=\"https://fdopen.github.io/opam-repository-mingw/\"\u003eOCaml for Windows\u003c/a\u003e\ninstaller which comes in 32bit and 64bit versions. This installer gives you\nopam and OCaml installations all in one go. It is used from within a Cygwin\nenvironment, but the executables produced have no dependency on Cygwin at all.\u003c/p\u003e\n\u003ch2 id=\"the-ocaml-top-level\"\u003eThe OCaml top level\u003c/h2\u003e\n\u003cp\u003eOCaml comes with two compilers: for native code, and for byte code. We shall\nuse one of those in a moment. But first, let's use OCaml's top level (sometimes\nknown as a REPL in other languages):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe typed the phrase \u003ccode\u003e1 + 2 * 3\u003c/code\u003e and then signalled to OCaml that we had\nfinished by typing \u003ccode\u003e;;\u003c/code\u003e followed by the Enter key. OCaml calculated the\nresult, \u003ccode\u003e7\u003c/code\u003e and its type \u003ccode\u003eint\u003c/code\u003e and showed them to us. We exit by running the\nbuilt-in \u003ccode\u003eexit\u003c/code\u003e function with exit code 0:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ocaml\n        OCaml version 4.11.1\n\n# 1 + 2 * 3;;\n- : int = 7\n# exit 0;;\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are two ways to improve your experience with the OCaml top level: you can\ninstall the popular \u003ca href=\"https://github.com/hanslub42/rlwrap\"\u003e\u003ccode\u003erlwrap\u003c/code\u003e\u003c/a\u003e on your\nsystem and invoke \u003ccode\u003erlwrap ocaml\u003c/code\u003e instead of \u003ccode\u003eocaml\u003c/code\u003e to get line-editing\nfacilities inside the OCaml top level, or you can install the alternative top\nlevel \u003ccode\u003eutop\u003c/code\u003e using opam:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ opam install utop\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe run it by typing \u003ccode\u003eutop\u003c/code\u003e instead of \u003ccode\u003eocaml\u003c/code\u003e. You can read more about\n\u003ca href=\"https://github.com/ocaml-community/utop\"\u003eutop\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"installing-the-dune-build-system\"\u003eInstalling the Dune build system\u003c/h2\u003e\n\u003cp\u003eDune is a build system for OCaml. It takes care of all the low level details of\nOCaml compilation. We install it with opam:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ opam install dune\nThe following actions will be performed:\n  - install dune 2.7.1\n\n\u0026lt;\u0026gt;\u0026lt;\u0026gt; Gathering sources \u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\n[default] https://opam.ocaml.org/2.0.7/archives/dune.2.7.1+opam.tar.gz\ndownloaded\n\n\u0026lt;\u0026gt;\u0026lt;\u0026gt; Processing actions \u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\u0026lt;\u0026gt;\n-\u0026gt; installed dune.2.7.1\nDone.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"a-first-project\"\u003eA first project\u003c/h2\u003e\n\u003cp\u003eLet's begin the simplest project with Dune and OCaml. We create a new directory\nand ask \u003ccode\u003edune\u003c/code\u003e to initialise a new project:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mkdir helloworld\n$ cd helloworld/\n$ dune init exe helloworld\nSuccess: initialized executable component named helloworld\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBuilding our program is as simple as typing \u003ccode\u003edune build\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ dune build\nInfo: Creating file dune-project with this contents:\n| (lang dune 2.7)\nDone: 8/11 (jobs: 1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen we change our program, we type \u003ccode\u003edune build\u003c/code\u003e again to make a new\nexecutable. We can run the executable with \u003ccode\u003edune exec\u003c/code\u003e (it's called\n\u003ccode\u003ehelloworld.exe\u003c/code\u003e even when we're not using Windows):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ dune exec ./helloworld.exe\nHello, World!        \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's look at the contents of our new directory. Dune has added the\n\u003ccode\u003ehelloworld.ml\u003c/code\u003e file, which is our OCaml program. It has also added our \u003ccode\u003edune\u003c/code\u003e\nfile, which tells dune how to build the program, and a \u003ccode\u003e_build\u003c/code\u003e subdirectory,\nwhich is dune's working space.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ls\n_build\t\tdune\t\thelloworld.ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ehelloworld.exe\u003c/code\u003e executable is stored inside the \u003ccode\u003e_build/default\u003c/code\u003e subdirectory, so\nit's easier to run with \u003ccode\u003edune exec\u003c/code\u003e. To ship the executable, we can just copy\nit from inside \u003ccode\u003e_build/default\u003c/code\u003e to somewhere else.\u003c/p\u003e\n\u003cp\u003eHere is the contents of the automatically-generated \u003ccode\u003edune\u003c/code\u003e file. When we want\nto add components to your project, such as third-party libraries, we edit this\nfile.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(executable\n (name helloworld))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"editor-support-for-ocaml\"\u003eEditor support for OCaml\u003c/h2\u003e\n\u003cp\u003eFor \u003cstrong\u003eVisual Studio Code\u003c/strong\u003e, and other editors support the Language Server\nProtocol, the OCaml language server can be installed with opam:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ opam install ocaml-lsp-server\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, we install the OCaml Platform Visual Studio Code extension from the Visual\nStudio Marketplace.\u003c/p\u003e\n\u003cp\u003eUpon first loading an OCaml source file, you may be prompted to select the\ntoolchain in use: pick OCaml the version of OCaml you are using, e.g. 4.11.1\nfrom the list. Now, help is available by hovering over symbols in your program:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tutorials/vscode.png\" alt=\"Visual Studio Code\" title=\"\" /\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eOn Windows\u003c/strong\u003e, we must launch Visual Studio Code from within the Cygwin window,\nrather than by clicking on its icon (otherwise, the language server will not be\nfound):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ /cygdrive/c/Users/Frank\\ Smith/AppData/Local/Programs/Microsoft\\ VS\\ Code/Code.exe\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eFor Vim and Emacs\u003c/strong\u003e, install the \u003ca href=\"https://github.com/ocaml/merlin\"\u003eMerlin\u003c/a\u003e\nsystem using opam:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ opam install merlin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe installation procedure will print instructions on how to link Merlin with\nyour editor.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eOn Windows\u003c/strong\u003e, when using Vim, the default cygwin Vim will not work with\nMerlin. You will need install Vim separately. In addition to the usual\ninstructions printed when installing Merlin, you may need to set the PATH in\nVim:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet $PATH .= \u0026quot;;\u0026quot;.substitute(system('opam config var bin'),'\\n$','','''')\n\u003c/code\u003e\u003c/pre\u003e\n"},{"title":"A First Hour with OCaml","slug":"a-first-hour-with-ocaml","description":"Discover the OCaml programming language in this longer tutorial that takes you from absolute beginner to someone who is able to write programs in OCaml.\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"getting-started","tl":0},"users":{"hd":"Beginner","tl":0},"body_md":"\nYou may follow along with this tutorial with just a basic OCaml installation,\nas described in [Up and Running](up_and_running.html).\n\nAlternatively, you may follow almost all of it by running OCaml in your browser\nusing [TryOCaml](https://try.ocamlpro.com), with no installation required!!!\n\n## Running OCaml code\n\nThe easiest way to get started is to run an interactive session in\nyour browser thanks to [TryOCaml](https://try.ocamlpro.com).\n\nTo install OCaml on your computer, see the [Install](/docs/install.html) documentation.\n\nTo quickly try small OCaml expressions, you can use an interactive\ntoplevel, or REPL (ReadEvalPrint Loop). The `ocaml` command provides\na very basic toplevel (you should install `rlwrap` through your system\npackage manager and run `rlwrap ocaml` to get history navigation).\n\nThe recommended alternative REPL [utop](https://github.com/diml/utop) may be\ninstalled through [OPAM](/docs/install.html#OPAM) or your system package\nmanager. It has the same basic interface but is much more convenient to use\n(history navigation, auto-completion, etc.).\n\nUse `;;` to indicate that you've finished entering each expression and prompt OCaml to evaluate it. Here is what running `ocaml` looks like:\n\n```console\n$ ocaml\n        OCaml version OCaml version 4.12.0\n\n# 1 + 1;;\n- : int = 2\n```\n\nThis is how running the same code looks when using `utop`:\n\n```console\n\n        Welcome to utop version 2.7.0 (using OCaml version 4.12.0)!      \n            \n\nType #utop_help for help about using utop.\n\n( 10:12:16 )\u003c command 0 \u003e\nutop # 1 + 1;;\n- : int = 2\n```\n\n## Comments\n\nOCaml comments are delimited by `(*` and `*)`, like this:\n\n```ocaml\n(* This is a single-line comment. *)\n\n(* This is a\n   multi-line\n   comment.\n*)\n```\n\nIn other words, the commenting convention is very similar to original C\n(`/* ... */`). There is no single-line comment syntax (like\n`# ...` in Python or `// ...` in C99/C++/Java).\n\nOCaml counts nested `(* ... *)` blocks, and this allows you to comment\nout regions of code very easily:\n\n```ocaml\n(* This code is broken ...\n\n(* Primality test. *)\nlet is_prime n =\n  (* note to self: ask about this on the mailing lists *) XXX\n\n*)\n```\n\n## Calling functions\n\nLet's say you've written a function  we'll call it `repeated`  which\ntakes a string `s` and a number `n`, and returns a new string which\ncontains original `s` repeated `n` times.\n\nIn most C-derived languages a call to this function will look like this:\n\n```C\nrepeated (\"hello\", 3)  /* this is C code */\n```\n\nThis means \"call the function `repeated` with two arguments, first\nargument the string hello and second argument the number 3\".\n\nOCaml, in common with other functional languages, writes and brackets\nfunction calls differently, and this is the cause of many mistakes. Here\nis the same function call in OCaml:\n\n```ocaml\nlet repeated a b = a ^ (Int.to_string b);;\nrepeated \"hello\" 3  (* this is OCaml code *)\n```\n\nNote  **no** brackets, and **no** comma between the arguments.\n\nThe syntax `repeated (\"hello\", 3)` **is** meaningful in OCaml. It means\n\"call the function `repeated` with ONE argument, that argument being a\n'pair' structure of two elements\". Of course that would be a mistake,\nbecause the `repeated` function is expecting two arguments, not one, and\nthe first argument should be a string, not a pair. But let's not worry\nabout pairs (\"tuples\") just yet. Instead, just remember that it's a\nmistake to put the brackets and commas in around function call\narguments.\n\nLet's have another function  `prompt_string`  which takes a string to\nprompt and returns the string entered by the user. We want to pass this\nstring into `repeated`. Here are the C and OCaml versions:\n\n```C\n/* C code: */\nrepeated (prompt_string (\"Name please: \"), 3)\n```\n\n```ocaml\nlet prompt_string p = \"\";;\n(* OCaml code: *)\nrepeated (prompt_string \"Name please: \") 3\n```\n\nTake a careful look at the bracketing and the missing comma. In the\nOCaml version, the brackets enclose the first argument of repeated\nbecause that argument is the result of another function call. In general\nthe rule is: \"bracket around the whole function call  don't put\nbrackets around the arguments to a function call\". Here are some more\nexamples:\n\n```ocaml\nlet f a b c = \"\";;\nlet g a = \"\";;\nlet f2 a = \"\";;\nlet g2 a b = \"\";;\nf 5 (g \"hello\") 3;;    (* f has three arguments, g has one argument *)\nf2 (g2 3 4)            (* f2 has one argument, g2 has two arguments *)\n```\n\n```ocaml\n# repeated (\"hello\", 3)     (* OCaml will spot the mistake *)\nLine 1, characters 10-22:\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n```\n\n## Defining a function\n\nWe all know how to define a function (or static method, in Java)\nin our existing languages. How do we do it in OCaml?\n\nThe OCaml syntax is pleasantly concise. Here's a function which takes\ntwo floating point numbers and calculates the average:\n\n```ocaml\nlet average a b =\n  (a +. b) /. 2.0\n```\n\nType this into the OCaml interactive toplevel (on Unix, type the command `ocaml`\nfrom the shell) and you'll see this:\n\n```ocaml\n# let average a b =\n    (a +. b) /. 2.0;;\nval average : float -\u003e float -\u003e float = \u003cfun\u003e\n```\n\nIf you look at the function definition closely, and also at what OCaml\nprints back at you, you'll have a number of questions:\n\n* What are those periods in `+.` and `/.` for?\n* What does `float -\u003e float -\u003e float` mean?\n\nI'll answer those questions in the next sections, but first I want to go\nand define the same function in C (the Java definition would be fairly\nsimilar to C), and hopefully that should raise even more questions.\nHere's our C version of `average`:\n\n```C\ndouble average (double a, double b)\n{\n  return (a + b) / 2;\n}\n```\n\nNow look at our much shorter OCaml definition above. Hopefully you'll be\nasking:\n\n* Why don't we have to define the types of `a` and `b` in the OCaml\n  version? How does OCaml know what the types are (indeed, *does*\n  OCaml know what the types are, or is OCaml completely dynamically\n  typed?).\n* In C, the `2` is implicitly converted into a `double`, can't OCaml\n  do the same thing?\n* What is the OCaml way to write `return`?\n\nOK, let's get some answers.\n\n* OCaml is a strongly *statically typed* language (in other words,\n  there's nothing dynamic going on between int, float and string).\n* OCaml uses *type inference* to work out the types, so you don't have\n  to.  If you use the OCaml interactive toplevel as above, then OCaml\n  will tell you\n  its inferred type for your function.\n* OCaml doesn't do any implicit casting. If you want a float, you have\n  to write `2.0` because `2` is an integer. OCaml does **no automatic\n  conversion** between int, float, string or any other type.\n* As a side-effect of type inference in OCaml, functions (including\n  operators) can't have overloaded definitions. OCaml defines `+` as\n  the *integer* addition function. To add floats, use `+.` (note the\n  trailing period). Similarly, use `-.`, `*.`, `/.` for other float\n  operations.\n* OCaml doesn't have a `return` keyword  the last expression in a\n  function becomes the result of the function automatically.\n\nWe will present more details in the following sections and chapters.\n\n## Basic types\n\nThe basic types in OCaml are:\n\n```text\nOCaml type  Range\n\nint         31-bit signed int (roughly +/- 1 billion) on 32-bit\n            processors, or 63-bit signed int on 64-bit processors\nfloat       IEEE double-precision floating point, equivalent to C's double\nbool        A boolean, written either 'true' or 'false'\nchar        An 8-bit character\nstring      A string\nunit        Written as ()\n```\n\nOCaml uses one of the bits in an `int` internally in order to be able to\nautomatically manage the memory use (garbage collection). This is why\nthe basic `int` is 31 bits, not 32 bits (63 bits if you're using a 64\nbit platform). In practice this isn't an issue except in a few\nspecialised cases. For example if you're counting things in a loop, then\nOCaml limits you to counting up to 1 billion instead of 2 billion. However if you need to do things\nsuch as processing 32 bit types (eg. you're writing crypto code or a\nnetwork stack), OCaml provides a `nativeint` type which matches the\nnative integer type for your platform.\n\nOCaml doesn't have a basic unsigned integer type, but you can get the\nsame effect using `nativeint`. OCaml doesn't have built-in single-precision \nfloating point numbers.\n\nOCaml provides a `char` type which is used for characters, written `'x'`\nfor example. Unfortunately the `char` type does not support Unicode or\nUTF-8, There are [comprehensive Unicode libraries](https://github.com/yoriyuki/Camomile)\nwhich provide this functionality.\n\nStrings are not just lists of characters. They have their own, more\nefficient internal representation. Strings are immutable.\n\nThe `unit` type is sort of like `void` in C, but we'll talk about it\nmore below.\n\n## Implicit vs. explicit casts\n\nIn C-derived languages ints get promoted to floats in certain\ncircumstances. For example if you write `1 + 2.5` then the first\nargument (which is an integer) is promoted to a floating point number,\nand the result is also a floating point number. It's as if you had\nwritten `((double) 1) + 2.5`, but all done implicitly.\n\nOCaml never does implicit casts like this. In OCaml, `1 + 2.5` is a type\nerror. The `+` operator in OCaml requires two ints as arguments, and\nhere we're giving it an int and a float, so it reports this error:\n\n```ocaml\n# 1 + 2.5;;\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n```\n\nTo add two floats together you need to use a different operator, `+.`\n(note the trailing period).\n\nOCaml doesn't promote ints to floats automatically so this is also an\nerror:\n\n```ocaml\n# 1 +. 2.5\nLine 1, characters 1-2:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.'?\n```\n\nHere OCaml is now complaining about the first argument.\n\nWhat if you actually want to add an integer and a floating point number\ntogether? (Say they are stored as `i` and `f`). In OCaml you need to\nexplicitly cast:\n\n```ocaml\nlet i = 1;;\nlet f = 2.0;;\nfloat_of_int i +. f\n```\n\n`float_of_int` is a function which takes an `int` and returns a `float`.\nThere are a whole load of these functions, called such things as\n`int_of_float`, `char_of_int`, `int_of_char`, `string_of_int` and so on,\nand they mostly do what you expect.\n\nSince converting an `int` to a `float` is a particularly common\noperation, the `float_of_int` function has a shorter alias: the above\nexample could simply have been written\n\n```ocaml\nfloat i +. f\n```\n\n(Note that it is perfectly valid in OCaml for a type and a\nfunction to have the same name.)\n\n### Is implicit or explicit casting better?\n\nYou might think that these explicit casts are ugly, time-consuming even,\nand you have a point, but there are at least two arguments in their\nfavour. Firstly, OCaml needs this explicit casting to be able to do type\ninference (see below), and type inference is such a wonderful\ntime-saving feature that it easily offsets the extra keyboarding of\nexplicit casts. Secondly, if you've spent time debugging C programs\nyou'll know that (a) implicit casts cause errors which are hard to find,\nand (b) much of the time you're sitting there trying to work out where\nthe implicit casts happen. Making the casts explicit helps you in\ndebugging. Thirdly, some casts (particularly int \u003c-\u003e float) are\nactually very expensive operations. You do yourself no favours by hiding\nthem.\n\n## Ordinary functions and recursive functions\n\nUnlike in C-derived languages, a function isn't recursive unless you\nexplicitly say so by using `let rec` instead of just `let`. Here's an\nexample of a recursive function:\n\n```ocaml\n# let rec range a b =\n    if a \u003e b then []\n    else a :: range (a + 1) b\nval range : int -\u003e int -\u003e int list = \u003cfun\u003e\n```\n\nNotice that `range` calls itself.\n\nThe only difference between `let` and `let rec` is in the scoping of the\nfunction name. If the above function had been defined with just `let`,\nthen the call to `range` would have tried to look for an existing\n(previously defined) function called `range`, not the\ncurrently-being-defined function. Using `let` (without `rec`) allows you\nto re-define a value in terms of the previous definition. For example:\n\n```ocaml\n# let positive_sum a b = \n    let a = max a 0\n    and b = max b 0 in\n    a + b\nval positive_sum : int -\u003e int -\u003e int = \u003cfun\u003e\n```\n\nThis redefinition hides the previous \"bindings\" of `a` and `b` from the\nfunction definition. In some situations coders prefer this pattern to\nusing a new variable name (`let a_pos = max a 0`) as it makes the old\nbinding inaccessible, so that only the latest values of `a` and `b` are\naccessible.\n\nThere is no performance difference between functions defined using `let`\nand functions defined using `let rec`, so if you prefer you could always\nuse the `let rec` form and get the same semantics as C-like languages.\n\n## Types of functions\n\nBecause of type inference you will rarely if ever need to explicitly\nwrite down the type of your functions. However, OCaml often prints out\nwhat it thinks are the types of your functions, so you need to know the\nsyntax for this. For a function `f` which takes arguments `arg1`,\n`arg2`, ... `argn`, and returns type `rettype`, the compiler will print:\n\n```\nf : arg1 -\u003e arg2 -\u003e ... -\u003e argn -\u003e rettype\n```\n\nThe arrow syntax looks strange now, but when we come to so-called\n\"currying\" later you'll see why it was chosen. For now I'll just give\nyou some examples.\n\nOur function `repeated` which takes a string and an integer and returns\na string has type:\n\n```ocaml\n# repeated\n- : string -\u003e int -\u003e string = \u003cfun\u003e\n```\n\nOur function `average` which takes two floats and returns a float has\ntype:\n\n```ocaml\n# average\n- : float -\u003e float -\u003e float = \u003cfun\u003e\n```\n\nThe OCaml standard `int_of_char` casting function:\n\n```ocaml\n# int_of_char\n- : char -\u003e int = \u003cfun\u003e\n```\n\nIf a function returns nothing (`void` for C and Java programmers), then\nwe write that it returns the `unit` type. Here, for instance, is the\nOCaml equivalent of C's *[fputc(3)](https://pubs.opengroup.org/onlinepubs/009695399/functions/fputc.html)*:\n\n```ocaml\n# output_char\n- : out_channel -\u003e char -\u003e unit = \u003cfun\u003e\n```\n\n### Polymorphic functions\n\nNow for something a bit stranger. What about a function which takes\n*anything* as an argument? Here's an odd function which takes an\nargument, but just ignores it and always returns 3:\n\n```ocaml\nlet give_me_a_three x = 3\n```\n\nWhat is the type of this function? In OCaml we use a special placeholder\nto mean \"any type you fancy\". It's a single quote character followed by\na letter. The type of the above function would normally be written:\n\n```ocaml\n# give_me_a_three\n- : 'a -\u003e int = \u003cfun\u003e\n```\n\nwhere `'a` (pronounced alpha) really does mean any type. You can, for example, call this\nfunction as `give_me_a_three \"foo\"` or `give_me_a_three 2.0` and both\nare quite valid expressions in OCaml.\n\nIt won't be clear yet why polymorphic functions are useful, but they are\nvery useful and very common, and so we'll discuss them later on. (Hint:\npolymorphism is kind of like templates in C++ or generics in Java).\n\n## Type inference\n\nSo the theme of this tutorial is that functional languages have many\nreally cool features, and OCaml is a language which has all of these\nreally cool features stuffed into it at once, thus making it a very\npractical language for real programmers to use. But the odd thing is\nthat most of these cool features have nothing to do with \"functional\nprogramming\" at all. In fact, I've come to the first really cool\nfeature, and I still haven't talked about why functional programming is\ncalled \"functional\". Anyway, here's the first really cool feature: type\ninference.\n\nSimply put: you don't need to declare the types of your functions and\nvariables, because OCaml will just figure them out for you!\n\nIn addition OCaml goes on to check all your types match up (even across\ndifferent files).\n\nBut OCaml is also a practical language, and for this reason it contains\nbackdoors into the type system allowing you to bypass this checking on\nthe rare occasions that it is sensible to do this. Only gurus will\nprobably need to bypass the type checking.\n\nLet's go back to the `average` function which we typed into the OCaml\ninteractive toplevel:\n\n```ocaml\n# let average a b =\n    (a +. b) /. 2.0\nval average : float -\u003e float -\u003e float = \u003cfun\u003e\n```\n\nOCaml worked out all on its own that the function takes\ntwo `float` arguments and returns a `float`!\n\nHow did it do this? Firstly it looks at where `a` and `b` are used,\nnamely in the expression `(a +. b)`. Now, `+.` is itself a function\nwhich always takes two `float` arguments, so by simple deduction, `a`\nand `b` must both also have type `float`.\n\nSecondly, the `/.` function returns a `float`, and this is the same as\nthe return value of the `average` function, so `average` must return a\n`float`. The conclusion is that `average` has this type signature:\n\n```ocaml\n# average\n- : float -\u003e float -\u003e float = \u003cfun\u003e\n```\n\nType inference is obviously easy for such a short program, but it works\neven for large programs, and it's a major time-saving feature because it\nremoves a whole class of errors which cause segfaults,\n`NullPointerException`s and `ClassCastException`s in other languages (or\nimportant but often ignored runtime warnings).\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#running-ocaml-code\"\u003eRunning OCaml code\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#comments\"\u003eComments\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#calling-functions\"\u003eCalling functions\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defining-a-function\"\u003eDefining a function\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#basic-types\"\u003eBasic types\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#implicit-vs-explicit-casts\"\u003eImplicit vs. explicit casts\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ordinary-functions-and-recursive-functions\"\u003eOrdinary functions and recursive functions\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#types-of-functions\"\u003eTypes of functions\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#type-inference\"\u003eType inference\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eYou may follow along with this tutorial with just a basic OCaml installation,\nas described in \u003ca href=\"up_and_running.html\"\u003eUp and Running\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAlternatively, you may follow almost all of it by running OCaml in your browser\nusing \u003ca href=\"https://try.ocamlpro.com\"\u003eTryOCaml\u003c/a\u003e, with no installation required!!!\u003c/p\u003e\n\u003ch2 id=\"running-ocaml-code\"\u003eRunning OCaml code\u003c/h2\u003e\n\u003cp\u003eThe easiest way to get started is to run an interactive session in\nyour browser thanks to \u003ca href=\"https://try.ocamlpro.com\"\u003eTryOCaml\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTo install OCaml on your computer, see the \u003ca href=\"/docs/install.html\"\u003eInstall\u003c/a\u003e documentation.\u003c/p\u003e\n\u003cp\u003eTo quickly try small OCaml expressions, you can use an interactive\ntoplevel, or REPL (ReadEvalPrint Loop). The \u003ccode\u003eocaml\u003c/code\u003e command provides\na very basic toplevel (you should install \u003ccode\u003erlwrap\u003c/code\u003e through your system\npackage manager and run \u003ccode\u003erlwrap ocaml\u003c/code\u003e to get history navigation).\u003c/p\u003e\n\u003cp\u003eThe recommended alternative REPL \u003ca href=\"https://github.com/diml/utop\"\u003eutop\u003c/a\u003e may be\ninstalled through \u003ca href=\"/docs/install.html#OPAM\"\u003eOPAM\u003c/a\u003e or your system package\nmanager. It has the same basic interface but is much more convenient to use\n(history navigation, auto-completion, etc.).\u003c/p\u003e\n\u003cp\u003eUse \u003ccode\u003e;;\u003c/code\u003e to indicate that you've finished entering each expression and prompt OCaml to evaluate it. Here is what running \u003ccode\u003eocaml\u003c/code\u003e looks like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-console\"\u003e$ ocaml\n        OCaml version OCaml version 4.12.0\n\n# 1 + 1;;\n- : int = 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is how running the same code looks when using \u003ccode\u003eutop\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-console\"\u003e\n        Welcome to utop version 2.7.0 (using OCaml version 4.12.0)!      \n            \n\nType #utop_help for help about using utop.\n\n( 10:12:16 )\u0026lt; command 0 \u0026gt;\nutop # 1 + 1;;\n- : int = 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"comments\"\u003eComments\u003c/h2\u003e\n\u003cp\u003eOCaml comments are delimited by \u003ccode\u003e(*\u003c/code\u003e and \u003ccode\u003e*)\u003c/code\u003e, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* This is a single-line comment. *)\n\n(* This is a\n   multi-line\n   comment.\n*)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn other words, the commenting convention is very similar to original C\n(\u003ccode\u003e/* ... */\u003c/code\u003e). There is no single-line comment syntax (like\n\u003ccode\u003e# ...\u003c/code\u003e in Python or \u003ccode\u003e// ...\u003c/code\u003e in C99/C++/Java).\u003c/p\u003e\n\u003cp\u003eOCaml counts nested \u003ccode\u003e(* ... *)\u003c/code\u003e blocks, and this allows you to comment\nout regions of code very easily:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* This code is broken ...\n\n(* Primality test. *)\nlet is_prime n =\n  (* note to self: ask about this on the mailing lists *) XXX\n\n*)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"calling-functions\"\u003eCalling functions\u003c/h2\u003e\n\u003cp\u003eLet's say you've written a function  we'll call it \u003ccode\u003erepeated\u003c/code\u003e  which\ntakes a string \u003ccode\u003es\u003c/code\u003e and a number \u003ccode\u003en\u003c/code\u003e, and returns a new string which\ncontains original \u003ccode\u003es\u003c/code\u003e repeated \u003ccode\u003en\u003c/code\u003e times.\u003c/p\u003e\n\u003cp\u003eIn most C-derived languages a call to this function will look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003erepeated (\u0026quot;hello\u0026quot;, 3)  /* this is C code */\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis means \u0026quot;call the function \u003ccode\u003erepeated\u003c/code\u003e with two arguments, first\nargument the string hello and second argument the number 3\u0026quot;.\u003c/p\u003e\n\u003cp\u003eOCaml, in common with other functional languages, writes and brackets\nfunction calls differently, and this is the cause of many mistakes. Here\nis the same function call in OCaml:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet repeated a b = a ^ (Int.to_string b);;\nrepeated \u0026quot;hello\u0026quot; 3  (* this is OCaml code *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote  \u003cstrong\u003eno\u003c/strong\u003e brackets, and \u003cstrong\u003eno\u003c/strong\u003e comma between the arguments.\u003c/p\u003e\n\u003cp\u003eThe syntax \u003ccode\u003erepeated (\u0026quot;hello\u0026quot;, 3)\u003c/code\u003e \u003cstrong\u003eis\u003c/strong\u003e meaningful in OCaml. It means\n\u0026quot;call the function \u003ccode\u003erepeated\u003c/code\u003e with ONE argument, that argument being a\n'pair' structure of two elements\u0026quot;. Of course that would be a mistake,\nbecause the \u003ccode\u003erepeated\u003c/code\u003e function is expecting two arguments, not one, and\nthe first argument should be a string, not a pair. But let's not worry\nabout pairs (\u0026quot;tuples\u0026quot;) just yet. Instead, just remember that it's a\nmistake to put the brackets and commas in around function call\narguments.\u003c/p\u003e\n\u003cp\u003eLet's have another function  \u003ccode\u003eprompt_string\u003c/code\u003e  which takes a string to\nprompt and returns the string entered by the user. We want to pass this\nstring into \u003ccode\u003erepeated\u003c/code\u003e. Here are the C and OCaml versions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003e/* C code: */\nrepeated (prompt_string (\u0026quot;Name please: \u0026quot;), 3)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet prompt_string p = \u0026quot;\u0026quot;;;\n(* OCaml code: *)\nrepeated (prompt_string \u0026quot;Name please: \u0026quot;) 3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTake a careful look at the bracketing and the missing comma. In the\nOCaml version, the brackets enclose the first argument of repeated\nbecause that argument is the result of another function call. In general\nthe rule is: \u0026quot;bracket around the whole function call  don't put\nbrackets around the arguments to a function call\u0026quot;. Here are some more\nexamples:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet f a b c = \u0026quot;\u0026quot;;;\nlet g a = \u0026quot;\u0026quot;;;\nlet f2 a = \u0026quot;\u0026quot;;;\nlet g2 a b = \u0026quot;\u0026quot;;;\nf 5 (g \u0026quot;hello\u0026quot;) 3;;    (* f has three arguments, g has one argument *)\nf2 (g2 3 4)            (* f2 has one argument, g2 has two arguments *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# repeated (\u0026quot;hello\u0026quot;, 3)     (* OCaml will spot the mistake *)\nLine 1, characters 10-22:\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"defining-a-function\"\u003eDefining a function\u003c/h2\u003e\n\u003cp\u003eWe all know how to define a function (or static method, in Java)\nin our existing languages. How do we do it in OCaml?\u003c/p\u003e\n\u003cp\u003eThe OCaml syntax is pleasantly concise. Here's a function which takes\ntwo floating point numbers and calculates the average:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet average a b =\n  (a +. b) /. 2.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eType this into the OCaml interactive toplevel (on Unix, type the command \u003ccode\u003eocaml\u003c/code\u003e\nfrom the shell) and you'll see this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let average a b =\n    (a +. b) /. 2.0;;\nval average : float -\u0026gt; float -\u0026gt; float = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you look at the function definition closely, and also at what OCaml\nprints back at you, you'll have a number of questions:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhat are those periods in \u003ccode\u003e+.\u003c/code\u003e and \u003ccode\u003e/.\u003c/code\u003e for?\n\u003c/li\u003e\n\u003cli\u003eWhat does \u003ccode\u003efloat -\u0026gt; float -\u0026gt; float\u003c/code\u003e mean?\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI'll answer those questions in the next sections, but first I want to go\nand define the same function in C (the Java definition would be fairly\nsimilar to C), and hopefully that should raise even more questions.\nHere's our C version of \u003ccode\u003eaverage\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003edouble average (double a, double b)\n{\n  return (a + b) / 2;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow look at our much shorter OCaml definition above. Hopefully you'll be\nasking:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhy don't we have to define the types of \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e in the OCaml\nversion? How does OCaml know what the types are (indeed, \u003cem\u003edoes\u003c/em\u003e\nOCaml know what the types are, or is OCaml completely dynamically\ntyped?).\n\u003c/li\u003e\n\u003cli\u003eIn C, the \u003ccode\u003e2\u003c/code\u003e is implicitly converted into a \u003ccode\u003edouble\u003c/code\u003e, can't OCaml\ndo the same thing?\n\u003c/li\u003e\n\u003cli\u003eWhat is the OCaml way to write \u003ccode\u003ereturn\u003c/code\u003e?\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOK, let's get some answers.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOCaml is a strongly \u003cem\u003estatically typed\u003c/em\u003e language (in other words,\nthere's nothing dynamic going on between int, float and string).\n\u003c/li\u003e\n\u003cli\u003eOCaml uses \u003cem\u003etype inference\u003c/em\u003e to work out the types, so you don't have\nto.  If you use the OCaml interactive toplevel as above, then OCaml\nwill tell you\nits inferred type for your function.\n\u003c/li\u003e\n\u003cli\u003eOCaml doesn't do any implicit casting. If you want a float, you have\nto write \u003ccode\u003e2.0\u003c/code\u003e because \u003ccode\u003e2\u003c/code\u003e is an integer. OCaml does \u003cstrong\u003eno automatic\nconversion\u003c/strong\u003e between int, float, string or any other type.\n\u003c/li\u003e\n\u003cli\u003eAs a side-effect of type inference in OCaml, functions (including\noperators) can't have overloaded definitions. OCaml defines \u003ccode\u003e+\u003c/code\u003e as\nthe \u003cem\u003einteger\u003c/em\u003e addition function. To add floats, use \u003ccode\u003e+.\u003c/code\u003e (note the\ntrailing period). Similarly, use \u003ccode\u003e-.\u003c/code\u003e, \u003ccode\u003e*.\u003c/code\u003e, \u003ccode\u003e/.\u003c/code\u003e for other float\noperations.\n\u003c/li\u003e\n\u003cli\u003eOCaml doesn't have a \u003ccode\u003ereturn\u003c/code\u003e keyword  the last expression in a\nfunction becomes the result of the function automatically.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe will present more details in the following sections and chapters.\u003c/p\u003e\n\u003ch2 id=\"basic-types\"\u003eBasic types\u003c/h2\u003e\n\u003cp\u003eThe basic types in OCaml are:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003eOCaml type  Range\n\nint         31-bit signed int (roughly +/- 1 billion) on 32-bit\n            processors, or 63-bit signed int on 64-bit processors\nfloat       IEEE double-precision floating point, equivalent to C's double\nbool        A boolean, written either 'true' or 'false'\nchar        An 8-bit character\nstring      A string\nunit        Written as ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOCaml uses one of the bits in an \u003ccode\u003eint\u003c/code\u003e internally in order to be able to\nautomatically manage the memory use (garbage collection). This is why\nthe basic \u003ccode\u003eint\u003c/code\u003e is 31 bits, not 32 bits (63 bits if you're using a 64\nbit platform). In practice this isn't an issue except in a few\nspecialised cases. For example if you're counting things in a loop, then\nOCaml limits you to counting up to 1 billion instead of 2 billion. However if you need to do things\nsuch as processing 32 bit types (eg. you're writing crypto code or a\nnetwork stack), OCaml provides a \u003ccode\u003enativeint\u003c/code\u003e type which matches the\nnative integer type for your platform.\u003c/p\u003e\n\u003cp\u003eOCaml doesn't have a basic unsigned integer type, but you can get the\nsame effect using \u003ccode\u003enativeint\u003c/code\u003e. OCaml doesn't have built-in single-precision\nfloating point numbers.\u003c/p\u003e\n\u003cp\u003eOCaml provides a \u003ccode\u003echar\u003c/code\u003e type which is used for characters, written \u003ccode\u003e'x'\u003c/code\u003e\nfor example. Unfortunately the \u003ccode\u003echar\u003c/code\u003e type does not support Unicode or\nUTF-8, There are \u003ca href=\"https://github.com/yoriyuki/Camomile\"\u003ecomprehensive Unicode libraries\u003c/a\u003e\nwhich provide this functionality.\u003c/p\u003e\n\u003cp\u003eStrings are not just lists of characters. They have their own, more\nefficient internal representation. Strings are immutable.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eunit\u003c/code\u003e type is sort of like \u003ccode\u003evoid\u003c/code\u003e in C, but we'll talk about it\nmore below.\u003c/p\u003e\n\u003ch2 id=\"implicit-vs-explicit-casts\"\u003eImplicit vs. explicit casts\u003c/h2\u003e\n\u003cp\u003eIn C-derived languages ints get promoted to floats in certain\ncircumstances. For example if you write \u003ccode\u003e1 + 2.5\u003c/code\u003e then the first\nargument (which is an integer) is promoted to a floating point number,\nand the result is also a floating point number. It's as if you had\nwritten \u003ccode\u003e((double) 1) + 2.5\u003c/code\u003e, but all done implicitly.\u003c/p\u003e\n\u003cp\u003eOCaml never does implicit casts like this. In OCaml, \u003ccode\u003e1 + 2.5\u003c/code\u003e is a type\nerror. The \u003ccode\u003e+\u003c/code\u003e operator in OCaml requires two ints as arguments, and\nhere we're giving it an int and a float, so it reports this error:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# 1 + 2.5;;\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo add two floats together you need to use a different operator, \u003ccode\u003e+.\u003c/code\u003e\n(note the trailing period).\u003c/p\u003e\n\u003cp\u003eOCaml doesn't promote ints to floats automatically so this is also an\nerror:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# 1 +. 2.5\nLine 1, characters 1-2:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.'?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere OCaml is now complaining about the first argument.\u003c/p\u003e\n\u003cp\u003eWhat if you actually want to add an integer and a floating point number\ntogether? (Say they are stored as \u003ccode\u003ei\u003c/code\u003e and \u003ccode\u003ef\u003c/code\u003e). In OCaml you need to\nexplicitly cast:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet i = 1;;\nlet f = 2.0;;\nfloat_of_int i +. f\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efloat_of_int\u003c/code\u003e is a function which takes an \u003ccode\u003eint\u003c/code\u003e and returns a \u003ccode\u003efloat\u003c/code\u003e.\nThere are a whole load of these functions, called such things as\n\u003ccode\u003eint_of_float\u003c/code\u003e, \u003ccode\u003echar_of_int\u003c/code\u003e, \u003ccode\u003eint_of_char\u003c/code\u003e, \u003ccode\u003estring_of_int\u003c/code\u003e and so on,\nand they mostly do what you expect.\u003c/p\u003e\n\u003cp\u003eSince converting an \u003ccode\u003eint\u003c/code\u003e to a \u003ccode\u003efloat\u003c/code\u003e is a particularly common\noperation, the \u003ccode\u003efloat_of_int\u003c/code\u003e function has a shorter alias: the above\nexample could simply have been written\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003efloat i +. f\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Note that it is perfectly valid in OCaml for a type and a\nfunction to have the same name.)\u003c/p\u003e\n\u003ch3 id=\"is-implicit-or-explicit-casting-better\"\u003eIs implicit or explicit casting better?\u003c/h3\u003e\n\u003cp\u003eYou might think that these explicit casts are ugly, time-consuming even,\nand you have a point, but there are at least two arguments in their\nfavour. Firstly, OCaml needs this explicit casting to be able to do type\ninference (see below), and type inference is such a wonderful\ntime-saving feature that it easily offsets the extra keyboarding of\nexplicit casts. Secondly, if you've spent time debugging C programs\nyou'll know that (a) implicit casts cause errors which are hard to find,\nand (b) much of the time you're sitting there trying to work out where\nthe implicit casts happen. Making the casts explicit helps you in\ndebugging. Thirdly, some casts (particularly int \u0026lt;-\u0026gt; float) are\nactually very expensive operations. You do yourself no favours by hiding\nthem.\u003c/p\u003e\n\u003ch2 id=\"ordinary-functions-and-recursive-functions\"\u003eOrdinary functions and recursive functions\u003c/h2\u003e\n\u003cp\u003eUnlike in C-derived languages, a function isn't recursive unless you\nexplicitly say so by using \u003ccode\u003elet rec\u003c/code\u003e instead of just \u003ccode\u003elet\u003c/code\u003e. Here's an\nexample of a recursive function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range a b =\n    if a \u0026gt; b then []\n    else a :: range (a + 1) b\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that \u003ccode\u003erange\u003c/code\u003e calls itself.\u003c/p\u003e\n\u003cp\u003eThe only difference between \u003ccode\u003elet\u003c/code\u003e and \u003ccode\u003elet rec\u003c/code\u003e is in the scoping of the\nfunction name. If the above function had been defined with just \u003ccode\u003elet\u003c/code\u003e,\nthen the call to \u003ccode\u003erange\u003c/code\u003e would have tried to look for an existing\n(previously defined) function called \u003ccode\u003erange\u003c/code\u003e, not the\ncurrently-being-defined function. Using \u003ccode\u003elet\u003c/code\u003e (without \u003ccode\u003erec\u003c/code\u003e) allows you\nto re-define a value in terms of the previous definition. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let positive_sum a b = \n    let a = max a 0\n    and b = max b 0 in\n    a + b\nval positive_sum : int -\u0026gt; int -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis redefinition hides the previous \u0026quot;bindings\u0026quot; of \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e from the\nfunction definition. In some situations coders prefer this pattern to\nusing a new variable name (\u003ccode\u003elet a_pos = max a 0\u003c/code\u003e) as it makes the old\nbinding inaccessible, so that only the latest values of \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e are\naccessible.\u003c/p\u003e\n\u003cp\u003eThere is no performance difference between functions defined using \u003ccode\u003elet\u003c/code\u003e\nand functions defined using \u003ccode\u003elet rec\u003c/code\u003e, so if you prefer you could always\nuse the \u003ccode\u003elet rec\u003c/code\u003e form and get the same semantics as C-like languages.\u003c/p\u003e\n\u003ch2 id=\"types-of-functions\"\u003eTypes of functions\u003c/h2\u003e\n\u003cp\u003eBecause of type inference you will rarely if ever need to explicitly\nwrite down the type of your functions. However, OCaml often prints out\nwhat it thinks are the types of your functions, so you need to know the\nsyntax for this. For a function \u003ccode\u003ef\u003c/code\u003e which takes arguments \u003ccode\u003earg1\u003c/code\u003e,\n\u003ccode\u003earg2\u003c/code\u003e, ... \u003ccode\u003eargn\u003c/code\u003e, and returns type \u003ccode\u003erettype\u003c/code\u003e, the compiler will print:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ef : arg1 -\u0026gt; arg2 -\u0026gt; ... -\u0026gt; argn -\u0026gt; rettype\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe arrow syntax looks strange now, but when we come to so-called\n\u0026quot;currying\u0026quot; later you'll see why it was chosen. For now I'll just give\nyou some examples.\u003c/p\u003e\n\u003cp\u003eOur function \u003ccode\u003erepeated\u003c/code\u003e which takes a string and an integer and returns\na string has type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# repeated\n- : string -\u0026gt; int -\u0026gt; string = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOur function \u003ccode\u003eaverage\u003c/code\u003e which takes two floats and returns a float has\ntype:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# average\n- : float -\u0026gt; float -\u0026gt; float = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe OCaml standard \u003ccode\u003eint_of_char\u003c/code\u003e casting function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# int_of_char\n- : char -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf a function returns nothing (\u003ccode\u003evoid\u003c/code\u003e for C and Java programmers), then\nwe write that it returns the \u003ccode\u003eunit\u003c/code\u003e type. Here, for instance, is the\nOCaml equivalent of C's \u003cem\u003e\u003ca href=\"https://pubs.opengroup.org/onlinepubs/009695399/functions/fputc.html\"\u003efputc(3)\u003c/a\u003e\u003c/em\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# output_char\n- : out_channel -\u0026gt; char -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"polymorphic-functions\"\u003ePolymorphic functions\u003c/h3\u003e\n\u003cp\u003eNow for something a bit stranger. What about a function which takes\n\u003cem\u003eanything\u003c/em\u003e as an argument? Here's an odd function which takes an\nargument, but just ignores it and always returns 3:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet give_me_a_three x = 3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat is the type of this function? In OCaml we use a special placeholder\nto mean \u0026quot;any type you fancy\u0026quot;. It's a single quote character followed by\na letter. The type of the above function would normally be written:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# give_me_a_three\n- : 'a -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere \u003ccode\u003e'a\u003c/code\u003e (pronounced alpha) really does mean any type. You can, for example, call this\nfunction as \u003ccode\u003egive_me_a_three \u0026quot;foo\u0026quot;\u003c/code\u003e or \u003ccode\u003egive_me_a_three 2.0\u003c/code\u003e and both\nare quite valid expressions in OCaml.\u003c/p\u003e\n\u003cp\u003eIt won't be clear yet why polymorphic functions are useful, but they are\nvery useful and very common, and so we'll discuss them later on. (Hint:\npolymorphism is kind of like templates in C++ or generics in Java).\u003c/p\u003e\n\u003ch2 id=\"type-inference\"\u003eType inference\u003c/h2\u003e\n\u003cp\u003eSo the theme of this tutorial is that functional languages have many\nreally cool features, and OCaml is a language which has all of these\nreally cool features stuffed into it at once, thus making it a very\npractical language for real programmers to use. But the odd thing is\nthat most of these cool features have nothing to do with \u0026quot;functional\nprogramming\u0026quot; at all. In fact, I've come to the first really cool\nfeature, and I still haven't talked about why functional programming is\ncalled \u0026quot;functional\u0026quot;. Anyway, here's the first really cool feature: type\ninference.\u003c/p\u003e\n\u003cp\u003eSimply put: you don't need to declare the types of your functions and\nvariables, because OCaml will just figure them out for you!\u003c/p\u003e\n\u003cp\u003eIn addition OCaml goes on to check all your types match up (even across\ndifferent files).\u003c/p\u003e\n\u003cp\u003eBut OCaml is also a practical language, and for this reason it contains\nbackdoors into the type system allowing you to bypass this checking on\nthe rare occasions that it is sensible to do this. Only gurus will\nprobably need to bypass the type checking.\u003c/p\u003e\n\u003cp\u003eLet's go back to the \u003ccode\u003eaverage\u003c/code\u003e function which we typed into the OCaml\ninteractive toplevel:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let average a b =\n    (a +. b) /. 2.0\nval average : float -\u0026gt; float -\u0026gt; float = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOCaml worked out all on its own that the function takes\ntwo \u003ccode\u003efloat\u003c/code\u003e arguments and returns a \u003ccode\u003efloat\u003c/code\u003e!\u003c/p\u003e\n\u003cp\u003eHow did it do this? Firstly it looks at where \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e are used,\nnamely in the expression \u003ccode\u003e(a +. b)\u003c/code\u003e. Now, \u003ccode\u003e+.\u003c/code\u003e is itself a function\nwhich always takes two \u003ccode\u003efloat\u003c/code\u003e arguments, so by simple deduction, \u003ccode\u003ea\u003c/code\u003e\nand \u003ccode\u003eb\u003c/code\u003e must both also have type \u003ccode\u003efloat\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSecondly, the \u003ccode\u003e/.\u003c/code\u003e function returns a \u003ccode\u003efloat\u003c/code\u003e, and this is the same as\nthe return value of the \u003ccode\u003eaverage\u003c/code\u003e function, so \u003ccode\u003eaverage\u003c/code\u003e must return a\n\u003ccode\u003efloat\u003c/code\u003e. The conclusion is that \u003ccode\u003eaverage\u003c/code\u003e has this type signature:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# average\n- : float -\u0026gt; float -\u0026gt; float = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eType inference is obviously easy for such a short program, but it works\neven for large programs, and it's a major time-saving feature because it\nremoves a whole class of errors which cause segfaults,\n\u003ccode\u003eNullPointerException\u003c/code\u003es and \u003ccode\u003eClassCastException\u003c/code\u003es in other languages (or\nimportant but often ignored runtime warnings).\u003c/p\u003e\n"},{"title":"OCaml Programming Guidelines","slug":"ocaml-programming-guidelines","description":"Opinionated guidelines for writing OCaml code\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"getting-started","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":{"hd":"Advanced","tl":0}}},"body_md":"\nThis is a set of reasonable guidelines for formatting OCaml\nprogramsguidelines which reflect the consensus among veteran OCaml\nprogrammers. Nevertheless, all detailed notifications of possible errors\nor omissions will be noted with pleasure. To send your comments using\n[GitHub issues](https://github.com/ocaml/ocaml.org/issues?state=open).\n\u003cbr /\u003e\nOriginal translation from French: [Ruchira\nDatta](mailto:datta@math.berkeley.edu).\n\nThanks to all those who have already participated in the critique of\nthis page: Daniel de Rauglaudre, Luc Maranget, Jacques Garrigue, Damien\nDoligez, Xavier Leroy, Bruno Verlyck, Bruno Petazzoni, Francois Maltey,\nBasile Starynkevitch, Toby Moth, Pierre Lescanne.\n\n## General guidelines to write programs\n###  Be simple and readable\nThe time you spend typing the programs is negligible compared to the\ntime spent reading them. That's the reason why you save a lot of time if\nyou work hard to optimize readability.\n\nAll the time you are \"wasting\" to get a simpler program today, will\nreturn a hundred times in the future during the uncountably many\nmodifications and readings of the program (starting with the first\ndebugging).\n\n\u003e \n\u003e **Writing programs law**: A program is written once, modified ten\n\u003e times, and read 100 times. So simplify its writing, always keep future\n\u003e modifications in mind, and never jeopardize readability.\n\u003e \n\n## Program formatting guidelines\n###  Lexical conventions\n\u003e \n\u003e **Pseudo spaces law**: never hesitate to separate words of your\n\u003e programs with spaces; the space bar is the easiest key to find on the\n\u003e keyboard, press it as often as necessary!\n\u003e \n\n####  Delimiters\nA space should always follow a delimiter symbol, and spaces should\nsurround operator symbols. It has been a great step forward in\ntypography to separate words by spaces to make written texts easier to\nread. Do the same in your programs if you want them to be readable.\n\n####  How to write pairs\nA tuple is parenthesized and the commas therein (delimiters) are each\nfollowed by a space: `(1, 2)`, `let   triplet = (x, y, z)`...\n\n* **Commonly accepted exceptions**:\n    * **Definition of the components of a pair**: In place of\n `let (x, y) =       ...`, you can write `let x, y = ...`.\n\n\u003e **Justification**: The point is to define several values\n\u003e simultaneously, not to construct a tuple. Moreover, the\n\u003e pattern is set off nicely between `let` and `=`.\n\n- **Matching several values simultaneously**: It's okay to omit\n  parentheses around n-tuples when matching several values\n  simultaneously.\n\n        match x, y with\n        | 1, _ -\u003e ...\n        | x, 1 -\u003e ...\n        | x, y -\u003e ...\n\n  \u003e **Justification**: The point is to match several values in\n  \u003e parallel, not to construct a tuple. Moreover, the expressions\n  \u003e being matched are set off by `match` and `with`, while the\n  \u003e patterns are set off nicely by `|` and `-\u003e`.\n\n\n####  How to write lists\nWrite `x :: l` with spaces around the `::` (since `::` is an infix\noperator, hence surrounded by spaces) and `[1; 2; 3]` (since `;` is a\ndelimiter, hence followed by a space).\n\n####  How to write operator symbols\nBe careful to keep operator symbols well separated by spaces: not only\nwill your formulas be more readable, but you will avoid confusion with\nmulti-character operators. (Obvious exceptions to this rule: the symbols\n`!` and `.` are not separated from their arguments.)\u003cbr /\u003e\nExample: write `x + 1` or `x + !y`.\n\n \n\u003e **Justification**: If you left out the spaces then `x+1` would be\n\u003e understood, but `x+!y` would change its meaning since `+!` would\n\u003e be interpreted as a multi-character operator.\n\u003e \n\u003e **Criticism**: The absence of spaces around an operator improves the\n\u003e readability of formulas when you use it to reflect the relative\n\u003e precedences of operators. For example `x*y + 2*z` makes it very\n\u003e obvious that multiplication takes precedence over addition.\n\u003e \n\u003e **Response**: This is a bad idea, a chimera, because nothing in the\n\u003e language ensures that the spaces properly reflect the meaning of the\n\u003e formula. For example `x * z-1` means `(x * z) - 1`, and not\n\u003e `x * (z - 1)` as the proposed interpretation of spaces would seem to\n\u003e suggest. Besides, the problem of multi-character symbols would keep\n\u003e you from using this convention in a uniform way: you couldn't leave\n\u003e out the spaces around the multiplication to write `x*!y + 2*!z`.\n\u003e Finally, this playing with the spaces is a subtle and flimsy\n\u003e convention, a subliminal message which is difficult to grasp on\n\u003e reading. If you want to make the precedences obvious, use the\n\u003e expressive means brought to you by the language: write parentheses.\n\u003e \n\u003e **Additional justification**: Systematically surrounding operators\n\u003e with spaces simplify the treatment of infix operators which are no\n\u003e more a complex particular case; in effect, whereas you can write `(+)`\n\u003e without spaces, you evidently cannot write `(*)` since `(*` is read as\n\u003e the beginning of a comment. You must write at least one space as in\n\u003e `( *)`, although an extra space after `*` is definitively preferable\n\u003e if you want to avoid that `*)` could be read, in some contexts, as the\n\u003e end of a comment. All those difficulties are easily avoided if you\n\u003e adopt the simple rule proposed here: keep operator symbols well\n\u003e separated by spaces.\u003cbr /\u003e\n\u003e In fact you will quickly feel that this rule is not so difficult to\n\u003e follow: the space bar is the greatest and best situated key of the\n\u003e keyboard, it is the easiest to enter and you cannot miss it!\n\n\n####  How to write long character strings\nIndent long character strings with the convention in force at that line\nplus an indication of string continuation at the end of each line (a `\\`\ncharacter at the end of the line that omits white spaces on the\nbeginning of next line):\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet universal_declaration =\n  \"-1- Programs are born and remain free and equal under the law;\\n\\\n   distinctions can only be based on the common good.\" in\n  ...\n```\n\n## Indentation of programs\n\u003e \n\u003e **Landin's pseudo law**: Treat the indentation of your programs as if\n\u003e it determines the meaning of your programs.\n\u003e \n\nI would add to this law: carefully treat the indentation of programs\nbecause in some cases it really gives the meaning of the program!\n\nThe indentation of programs is an art which excites many strong\nopinions. Here several indentation styles are given which are drawn from\nexperience and which have not been severely criticized.\n\nWhen a justification for the adopted style has seemed obvious to me, I\nhave indicated it. On the other hand, criticisms are also noted.\n\nSo each time, you have to choose between the different styles\nsuggested.\u003cbr /\u003e\n The only absolute rule is the first below.\n\n###  Consistency of indentation\nChoose a generally accepted style of indentation, then use it\nsystematically throughout the whole application.\n\n###  Width of the page\nThe page is 80 columns wide.\n\n\u003e **Justification**: This width makes it possible to read the code on\n\u003e all displays and to print it in a legible font on a standard sheet.\n \n\n###  Height of the page\nA function should always fit within one screenful (of about 70 lines),\nor in exceptional cases two, at the very most three. To go beyond this\nis unreasonable.\n\n \n\u003e **Justification**: When a function goes beyond one screenful, it's\n\u003e time to divide it into subproblems and handle them independently.\n\u003e Beyond a screenful, one gets lost in the code. The indentation is not\n\u003e readable and is difficult to keep correct.\n\n\n###  How much to indent\nThe change in indentation between successive lines of the program is\ngenerally 1 or 2 spaces. Pick an amount to indent and stick with it\nthroughout the program.\n\n###  Using tab stops\nUsing the tab character (ASCII character 9) is absolutely *not*\nrecommended.\n\n\n\u003e **Justification**: Between one display and another, the indentation of\n\u003e the program changes completely; it can also become completely wrong,\n\u003e if the programmer used both tabulations and spaces to indent the\n\u003e program.\n\u003e \n\u003e **Criticism**: The purpose of using tabulations is just to allow the\n\u003e readers of the program to indent more or less by changing the tabs\n\u003e stops. The overall indentation remains correct and the reader is glad\n\u003e to easily customize the indentation amount.\n\u003e \n\u003e **Answer**: It seems almost impossible to use this method since you\n\u003e should always use tabulations to indent, which is hard and unnatural.\n \n\n###  How to indent global `let ... ;;` definitions\nThe body of a function defined globally in a module is generally\nindented normally. However, it's okay to treat this case specially to\nset off the definition better.\n\nWith a regular indentation of 1 or 2 spaces:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet f x = function\n  | C -\u003e\n  | D -\u003e\n  ...\n\nlet g x =\n  let tmp =\n    match x with\n    | C -\u003e 1\n    | x -\u003e 0 in\n  tmp + 1\n```\n\u003e \n\u003e **Justification**: No exception to the amount of indentation.\n\u003e \n\nOther conventions are acceptable, for example:\n\n* The body is left-justified in the case of pattern-matching.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet f x = function\n| C -\u003e\n| D -\u003e\n...\n```\n\u003e \n\u003e **Justification**: The vertical bars separating the patterns stop\n\u003e when the definition is done, so it's still easy to pass on to the\n\u003e following definition.\n\u003e \n\u003e **Criticism**: An unpleasant exception to the normal indentation.\n\u003e \n\n\n* The body is justified just under the name of the defined function.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet f x =\n    let tmp = ... in\n    try g x with\n    | Not_found -\u003e\n    ...\n```\n\u003e \n\u003e **Justification**: The first line of the definition is set off\n\u003e nicely, so it's easier to pass from definition to definition.\n\u003e \n\u003e **Criticism**: You run into the right margin too quickly.\n\u003e \n\n\n###  How to indent `let ... in` constructs\nThe expression following a definition introduced by `let` is indented to\nthe same level as the keyword `let`, and the keyword `in` which\nintroduces it is written at the end of the line:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet expr1 = ... in\nexpr1 + expr1\n```\n\nIn the case of a series of `let` definitions, the preceding rule implies\nthat these definitions should be placed at the same indentation level:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet expr1 = ... in\nlet n = ... in\n...\n```\n\u003e \n\u003e **Justification**: It is suggested that a series of let ... in\n\u003e constructs is analogous to a set of assumptions in a mathematical\n\u003e text, whence the same indentation level for all the assumptions.\n\u003e \n\nVariation: some write the keyword `in` alone on one line to set apart\nthe final expression of the computation:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet e1 = ... in\nlet e2 = ... in\nlet new_expr =\n  let e1' = derive_expression e1\n  and e2' = derive_expression e2 in\n  Add_expression e1' e2'\nin\nMult_expression (new_expr, new_expr)\n```\n\u003e \n\u003e **Criticism**: Lack of consistency.\n\u003e \n\n###  How to indent `if ... then   ... else ... `\n####  Multiple branches\nWrite conditions with multiple branches at the same level of\nindentation:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nif cond1 ...\nif cond2 ...\nif cond3 ...\n```\n\u003e \n\u003e **Justification**: Analogous treatment to pattern-matching clauses,\n\u003e all aligned to the same tab stop.\n\u003e \n\nIf the sizes of the conditions and the expressions allow, write for\nexample:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nif cond1 then e1 else\nif cond2 then e2 else\nif cond3 then e3 else\ne4\n\n```\nIf expressions in the branches of multiple conditions have to be\nenclosed (when they include statements for instance), write:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nif cond then begin\n    e1\n  end else\nif cond2 then begin\n    e2\n  end else\nif cond3 then ...\n```\nSome suggest another method for multiple conditionals, starting each\nline by the keyword `else`:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nif cond1 ...\nelse if cond2 ...\nelse if cond3 ...\n```\n\u003e \n\u003e **Justification**: `elsif` is a keyword in many languages, so use\n\u003e indentation and `else if` to bring it to mind. Moreover, you do not\n\u003e have to look to the end of line to know whether the condition is\n\u003e continued or another test is performed.\n\u003e \n\u003e **Criticism**: Lack of consistency in the treatment of all the\n\u003e conditions. Why a special case for the first condition?\n\u003e \n\nYet again, choose your style and use it systematically.\n\n####  Single branches\nSeveral styles are possible for single branches, according to the size\nof the expressions in question and especially the presence of `begin`\n`end` or `(` `)` delimiters for these expressions.\n\nIn the case of delimiting the branches of a conditional, several styles\nare used:\n\n\u003e `(` at end of line:\n\u003e \n\u003e ```ocaml\n\u003e if cond then (\n\u003e   e1\n\u003e ) else (\n\u003e   e2\n\u003e )\n\u003e ```\n\u003e Or alternatively first `begin` at beginning of line:\n\u003e \n\u003e ```ocaml\n\u003e if cond then\n\u003e   begin\n\u003e     e1\n\u003e   end else begin\n\u003e     e2\n\u003e   end\n\u003e ```\n\nIn fact the indentation of conditionals depends on the sizes of the\nexpressions which make them up.\n\n\u003e \n\u003e If `cond`, `e1` and `e2` are small, simply write them on one line:\n\u003e \n\u003e ```ocaml\n\u003e if cond then e1 else e2\n\u003e ```\n\u003e If the expressions making up a conditional are purely functional\n\u003e (without side effects), we advocate binding them within the\n\u003e conditional with `let e = ... in` when they're too big to fit on a\n\u003e line.\n\u003e \n\u003e \u003e \n\u003e \u003e **Justification**: This way you get back the simple indentation on\n\u003e \u003e one line which is the most readable. As a side benefit, the naming\n\u003e \u003e acts as an aid to comprehension.\n\u003e \u003e \n\u003e \n\u003e So now we consider the case in which the expressions in question do\n\u003e have side effects, which keeps us from simply binding them with a\n\u003e `let e = ... in`.\n\u003e \n\u003e \u003e \n\u003e \u003e If `e1` and `cond` are small, but `e2` large:\n\u003e \u003e \n\u003e \u003e ```ocaml\n\u003e \u003e if cond then e1 else\n\u003e \u003e   e2\n\u003e \u003e ```\n\u003e \u003e \n\u003e \u003e If `e1` and `cond` are large and `e2` small:\n\u003e \u003e \n\u003e \u003e ```ocaml\n\u003e \u003e if cond then\n\u003e \u003e   e1\n\u003e \u003e else e2\n\u003e \u003e ```\n\u003e \u003e \n\u003e \u003e If all the expressions are large:\n\u003e \u003e \n\u003e \u003e ```ocaml\n\u003e \u003e if cond then\n\u003e \u003e   e1\n\u003e \u003e else\n\u003e \u003e   e2\n\u003e \u003e ```\n\u003e \u003e \n\u003e \u003e If there are `( )` delimiters:\n\u003e \u003e \n\u003e \u003e ```ocaml\n\u003e \u003e if cond then (\n\u003e \u003e   e1\n\u003e \u003e ) else (\n\u003e \u003e   e2\n\u003e \u003e )\n\u003e \u003e ```\n\u003e \u003e \n\u003e \u003e A mixture where `e1` requires `( )` but `e2` is small:\n\u003e \u003e \n\u003e \u003e ```ocaml\n\u003e \u003e if cond then (\n\u003e \u003e     e1\n\u003e \u003e ) else e2\n\u003e \u003e ```\n\n###  How to indent pattern-matching constructs\n####  General principles\nAll the pattern-matching clauses are introduced by a vertical bar,\n*including* the first one.\n\n\u003e \n\u003e **Criticism**: The first vertical bar is not mandatory: hence, there\n\u003e is no need to write it.\n\u003e \n\u003e **Answer to criticism**: If you omit the first bar the indentation\n\u003e seems unnatural : the first case gets an indentation that is greater\n\u003e than a normal new line would necessitate. It is thus a useless\n\u003e exception to the correct indentation rule. It also insists not to use\n\u003e the same syntax for the whole set of clauses, writing the first clause\n\u003e as an exception with a slightly different syntax. Last, aesthetic\n\u003e value is doubtful (some people would say awful instead of\n\u003e doubtful).\n\u003e \n\nAlign all the pattern-matching clauses at the level of the vertical bar\nwhich begins each clause, *including* the first one.\n\nIf an expression in a clause is too large to fit on the line, you must\nbreak the line immediately after the arrow of the corresponding clause.\nThen indent normally, starting from the beginning of the pattern of the\nclause.\n\nArrows of pattern matching clauses should not be aligned.\n\n####  `match` or `try`\nFor a `match` or a `try` align the clauses with the beginning of the\nconstruct:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmatch lam with\n| Abs (x, body) -\u003e 1 + size_lambda body\n| App (lam1, lam2) -\u003e size_lambda lam1 + size_lambda lam2\n| Var v -\u003e 1\n\ntry f x with\n| Not_found -\u003e ...\n| Failure \"not yet implemented\" -\u003e ...\n```\nPut the keyword `with` at the end of the line. If the preceding\nexpression extends beyond one line, put `with` on a line by itself:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\ntry\n  let y = f x in\n  if ...\nwith\n| Not_found -\u003e ...\n| Failure \"not yet implemented\" -\u003e ...\n```\n\u003e \n\u003e **Justification**: The keyword `with`, on a line by itself shows that\n\u003e the program enters the pattern matching part of the construct.\n\u003e \n\n####  Indenting expressions inside clauses\nIf the expression on the right of the pattern matching arrow is too\nlarge, cut the line after the arrow.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmatch lam with\n| Abs (x, body) -\u003e\n   1 + size_lambda body\n| App (lam1, lam2) -\u003e\n   size_lambda lam1 + size_lambda lam2\n| Var v -\u003e\n```\nSome programmers generalize this rule to all clauses, as soon as one\nexpressions overflows. They will then indent the last clause like this:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\n| Var v -\u003e\n   1\n```\nOther programmers go one step further and apply this rule systematically\nto any clause of any pattern matching.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec fib = function\n  | 0 -\u003e\n     1\n  | 1 -\u003e\n     1\n  | n -\u003e\n     fib (n - 1) + fib ( n - 2)\n```\n\u003e \n\u003e **Criticism**: May be not compact enough; for simple pattern matchings\n\u003e (or simple clauses in complex matchings), the rule does not add any\n\u003e good to readability.\n\u003e \n\u003e **Justification**: I don't see any good reason for this rule, unless\n\u003e you are paid proportionally to the number of lines of code: in this\n\u003e case use this rule to get more money without adding more bugs in your\n\u003e OCaml programs!\n\u003e \n\n####  Pattern matching in anonymous functions\nSimilarly to `match` or `try`, pattern matching of anonymous functions,\nstarting by `function`, are indented with respect to the `function`\nkeyword:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmap\n  (function\n   | Abs (x, body) -\u003e 1 + size_lambda 0 body\n   | App (lam1, lam2) -\u003e size_lambda (size_lambda 0 lam1) lam2\n   | Var v -\u003e 1)\n  lambda_list\n```\n####  Pattern matching in named functions\nPattern-matching in functions defined by `let` or `let rec` gives rise\nto several reasonable styles which obey the preceding rules for pattern\nmatching (the one for anonymous functions being evidently excepted). See\nabove for recommended styles.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec size_lambda accu = function\n  | Abs (x, body) -\u003e size_lambda (succ accu) body\n  | App (lam1, lam2) -\u003e size_lambda (size_lambda accu lam1) lam2\n  | Var v -\u003e succ accu\n\nlet rec size_lambda accu = function\n| Abs (x, body) -\u003e size_lambda (succ accu) body\n| App (lam1, lam2) -\u003e size_lambda (size_lambda accu lam1) lam2\n| Var v -\u003e succ accu\n```\n###  Bad indentation of pattern-matching constructs\n####  No *beastly* indentation of functions and case analyses.\nThis consists in indenting normally under the keyword `match` or\n`function` which has previously been pushed to the right. Don't write:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec f x = function\n              | [] -\u003e ...\n              ...\n```\nbut choose to indent the line under the `let` keyword:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec f x = function\n  | [] -\u003e ...\n  ...\n```\n\u003e \n\u003e **Justification**: You bump into the margin. The aesthetic value is\n\u003e doubtful...\n\u003e \n\n####  No *beastly* alignment of the `-\u003e` symbols in pattern-matching clauses.\nCareful alignment of the arrows of a pattern matching is considered bad\npractice, as exemplify in the following fragment:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet f = function\n  | C1          -\u003e 1\n  | Long_name _ -\u003e 2\n  | _           -\u003e 3\n```\n\u003e \n\u003e **Justification**: This makes it harder to maintain the program (the\n\u003e addition of a supplementary case can lead the indentations of all the\n\u003e lines to change and so ... we often give up alignment at that time,\n\u003e then it is better not to align the arrows in the first place!).\n\u003e \n\n###  How to indent function calls\n####  Indentation to the function's name:\nNo problem arises except for functions with many arguments\u0026mdash;or very\ncomplicated arguments as well\u0026mdash;which can't fit on the same line. You\nmust indent the expressions with respect to the name of the function (1\nor 2 spaces according to the chosen convention). Write small arguments\non the same line, and change lines at the start of an argument.\n\nAs far as possible, avoid arguments which consist of complex\nexpressions: in these cases define the large argument by a `let`\nconstruction.\n\n\u003e \n\u003e **Justification**: No indentation problem; if the name given to the\n\u003e expressions is meaningful, the code is more readable as well.\n\u003e \n\u003e **Additional justification**: If the evaluation of the arguments\n\u003e produces side effects, the `let` binding is in fact necessary to\n\u003e explicitly define the order of evaluation.\n\u003e \n\n####  Naming complex arguments:\nIn place of\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet temp =\n  f x y z\n    large\n    expression\n    other large\n    expression in\n...\n```\nwrite\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet t =\n  large\n  expression\nand u =\n  other large\n  expression in\nlet temp =\n  f x y z t u in\n...\n```\n####  Naming anonymous functions:\nIn the case of an iterator whose argument is a complex function, define\nthe function by a `let` binding as well. In place of\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nList.map\n  (function x -\u003e\n    blabla\n    blabla\n    blabla)\n  l\n```\nwrite\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet f x =\n  blabla\n  blabla\n  blabla in\nList.map f l\n```\n\u003e \n\u003e **Justification**: Much clearer, in particular if the name given to\n\u003e the function is meaningful.\n\u003e \n\n###  How to indent operations\nWhen an operator takes complex arguments, or in the presence of multiple\ncalls to the same operator, start the next the line with the operator,\nand don't indent the rest of the operation. For example:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nx + y + z\n+ t + u\n```\n\u003e \n\u003e **Justification**: When the operator starts the line, it is clear that\n\u003e the operation continues on this line.\n\u003e \n\nIn the case of a large expression in such an operation sequence,\nto define the large expression with the help of a `let in`\nconstruction is preferable to having to indent the line. In place of\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nx + y + z\n+ large\n  expression\n```\nwrite\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet t =\n  large\n   expression in\nx + y + z + t\n```\nYou most certainly must bind those expressions too large to be written\nin one operation in the case of a combination of operators. In place of\nthe unreadable expression\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\n(x + y + z * t)\n/ (large\n    expression)\n```\nwrite\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet u =\n  large\n  expression in\n(x + y + z * t) / u\n```\nThese guidelines extend to all operators. For example:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet u =\n  large\n  expression in\nx :: y\n:: z + 1 :: t :: u\n```\n## Programming guidelines\n###  How to program\n\u003e \n\u003e *Always put your handiwork back on the bench,\u003cbr /\u003e\n\u003e  and then polish it and re-polish it.*\n\u003e \n\n####  Write simple and clear programs\nWhen this is done, reread, simplify and clarify. At every stage of\ncreation, use your head!\n\n####  Subdivide your programs into little functions\nSmall functions are easier to master.\n\n####  Factor out snippets of repeated code by defining them in separate functions\nThe sharing of code obtained in this way facilitates maintenance since\nevery correction or improvement automatically spreads throughout the\nprogram. Besides, the simple act of isolating and naming a snippet of\ncode sometimes lets you identify an unsuspected feature.\n\n####  Never copy-paste code when programming\nPasting code almost surely indicates introducing a default of code\nsharing and neglecting to identify and write a useful auxiliary\nfunction; hence, it means that some code sharing is lost in the program.\nLosing code sharing implies that you will have more problems afterwards\nfor maintenance: a bug in the pasted code has to be corrected at each\noccurrence of the bug in each copy of the code!\n\nMoreover, it is difficult to identify that the same set of 10 lines of\ncode is repeated 20 times throughout the program. By contrast, if an\nauxiliary function defines those 10 lines, it is fairly easy to see and\nfind where those lines are used: that's simply where the function is\ncalled. If code is copy-pasted all over the place then the program is\nmore difficult to understand.\n\nIn conclusion, copy-pasting code leads to programs that are more\ndifficult to read and more difficult to maintain: it has to be banished.\n\n###  How to comment programs\n####  Don't hesitate to comment when there's a difficulty\n####  If there's no difficulty, there's no point in commenting\n####  Avoid comments in the bodies of functions\n####  Prefer one comment at the beginning of the function...\n...which explains how the algorithm that is used works. Once more, if\nthere is no difficulty, there is no point in commenting.\n\n####  Avoid nocuous comments\nA *nocuous* comment is a comment that does not add any value, i.e. no\nnon-trivial information. The nocuous comment is evidently not of\ninterest; it is a nuisance since it uselessly distracts the reader. It\nis often used to fulfill some strange criteria related to the so-called\n*software metrology*, for instance the ratio *number of comments* /\n*number of lines of code* that perfectly measures a ratio that I don't\nknow the theoretical or practical interpretation. Absolutely avoid\nnocuous comments.\n\nAn example of what to avoid: the following comment uses technical words\nand is thus masquerade into a real comment when it has no additional\ninformation of interest;\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\n(*\n  Function print_lambda:\n  print a lambda-expression given as argument.\n\n  Arguments: lam, any lambda-expression.\n  Returns: nothing.\n\n  Remark: print_lambda can only be used for its side effect.\n*)\nlet rec print_lambda lam =\n  match lam with\n  | Var s -\u003e printf \"%s\" s\n  | Abs l -\u003e printf \"\\\\ %a\" print_lambda l\n  | App (l1, l2) -\u003e\n     printf \"(%a %a)\" print_lambda l1 print_lambda l2\n```\n####  Usage in module interface\nThe function's usage must appear in the interface of the module which\nexports it, not in the program which implements it. Choose comments as\nin the OCaml system's interface modules, which will subsequently allow\nthe documentation of the interface module to be extracted automatically\nif need be.\n\n####  Use assertions\nUse assertions as much as possible: they let you avoid verbose comments,\nwhile allowing a useful verification upon execution.\n\nFor example, the conditions for the arguments of a function to be valid\nare usefully verified by assertions.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet f x =\n  assert (x \u003e= 0);\n  ...\n```\nNote as well that an assertion is often preferable to a comment because\nit's more trustworthy: an assertion is forced to be pertinent because it\nis verified upon each execution, while a comment can quickly become\nobsolete and then becomes actually detrimental to the comprehension of\nthe program.\n\n####  Comments line by line in imperative code\nWhen writing difficult code, and particularly in case of highly\nimperative code with a lot of memory modifications (physical mutations\nin data structures), it is sometime mandatory to comment inside the body\nof functions to explain the implementation of the algorithm encoded\nhere, or to follow successive modifications of invariants that the\nfunction must maintain. Once more, if there is some difficulty\ncommenting is mandatory, for each program line if necessary.\n\n###  How to choose identifiers\nIt's hard to choose identifiers whose name evokes the meaning of the\ncorresponding portion of the program. This is why you must devote\nparticular care to this, emphasizing clarity and regularity of\nnomenclature.\n\n####  Don't use abbreviations for global names\nGlobal identifiers (including especially the names of functions) can be\nlong, because it's important to understand what purpose they serve far\nfrom their definition.\n\n####  Separate words by underscores: (`int_of_string`, not `intOfString`)\nCase modifications are meaningful in OCaml: in effect capitalized words\nare reserved for constructors and module names in OCaml; in contrast\nregular variables (functions or identifiers) must start by a lowercase\nletter. Those rules prevent proper usage of case modification for words\nseparation in identifiers: the first word starts the identifier, hence\nit must be lower case and it is forbidden to choose `IntOfString` as the\nname of a function.\n\n####  Always give the same name to function arguments which have the same meaning\nIf necessary, make this nomenclature explicit in a comment at the top of\nthe file); if there are several arguments with the same meaning then\nattach numeral suffixes to them.\n\n####  Local identifiers can be brief, and should be reused from one function to another\nThis augments regularity of style. Avoid using identifiers whose\nappearance can lead to confusion such as `l` or `O`, easy to confuse\nwith `1` and `0`.\n\nExample:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet add_expression expr1 expr2 = ...\nlet print_expression expr = ...\n```\nAn exception to the recommendation not to use capitalization to separate\nwords within identifiers is tolerated in the case of interfacing with\nexisting libraries which use this naming convention: this lets OCaml\nusers of the library to orient themselves in the original library\ndocumentation more easily.\n\n###  When to use parentheses within an expression\nParentheses are meaningful: they indicate the necessity of using an\nunusual precedence. So they should be used wisely and not sprinkled\nrandomly throughout programs. To this end, you should know the usual\nprecedences, that is, the combinations of operations which do not\nrequire parentheses. Quite fortunately this is not complicated if you\nknow a little mathematics or strive to follow the following rules:\n\n####  Arithmetic operators: the same rules as in mathematics\nFor example: `1 + 2 * x` means `1 + (2 * x)`.\n\n####  Function application: the same rules as those in mathematics for usage of *trigonometric functions*\nIn mathematics you write `sin x` to mean `sin (x)`. In the same way\n`sin x + cos x` means `(sin x) + (cos x)` not `sin (x + (cos x))`. Use\nthe same conventions in OCaml: write `f x + g x` to mean\n`(f x) + (g x)`.\u003cbr /\u003e\nThis convention generalizes **to all (infix) operators**: `f x :: g x`\nmeans `(f x) :: (g x)`, `f x @ g x` means `(f x) @ (g x)`, and\n`failwith s ^ s'` means `(failwith s) ^ s'`, *not* `failwith (s ^ s')`.\n\n####  Comparisons and boolean operators\nComparisons are infix operators, so the preceding rules apply. This is\nwhy `f x \u003c g x` means `(f x) \u003c (g x)`. For type reasons (no other\nsensible interpretation) the expression `f x \u003c x + 2` means\n`(f x) \u003c (x + 2)`. In the same way `f x \u003c x + 2 \u0026\u0026 x \u003e 3` means\n`((f x) \u003c (x + 2)) \u0026\u0026 (x \u003e 3)`.\n\n####  The relative precedences of the boolean operators are those of mathematics\nAlthough mathematicians have a tendency to overuse parens in this case,\nthe boolean or operator is analogous to addition and the and\nto multiplication. So, just as `1 + 2 * x` means `1 + (2 * x)`,\n`true || false \u0026\u0026 x` means `true || (false \u0026\u0026 x)`.\n\n###  How to delimit constructs in programs\nWhen it is necessary to delimit syntactic constructs in programs, use as\ndelimiters the keywords `begin` and `end` rather than parentheses.\nHowever using parentheses is acceptable if you do it in a consistent,\nthat is, systematic, way.\n\nThis explicit delimiting of constructs essentially concerns\npattern-matching constructs or sequences embedded within\n`if then     else` constructs.\n\n####  `match` construct in a `match` construct\nWhen a `match ... with` or `try ... with` construct appears in a\npattern-matching clause, it is absolutely necessary to delimit this\nembedded construct (otherwise subsequent clauses of the enclosing\npattern-matching construct will automatically be associated with the\nenclosed pattern-matching construct). For example:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmatch x with\n| 1 -\u003e\n  begin match y with\n  | ...\n  end\n| 2 -\u003e\n...\n```\n####  Sequences inside branches of `if`\nIn the same way, a sequence which appears in the `then` or `else` part\nof a conditional must be delimited:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nif cond then begin\n  e1;\n  e2\nend else begin\n  e3;\n  e4\nend\n```\n###  How to use modules\n####  Subdividing into modules\nYou must subdivide your programs into coherent modules.\n\nFor each module, you must explicitly write an interface.\n\nFor each interface, you must document the things defined by the module:\nfunctions, types, exceptions, etc.\n\n####  Opening modules\nAvoid `open` directives, using instead the qualified identifier\nnotation. Thus you will prefer short but meaningful module names.\n\n\u003e \n\u003e **Justification**: The use of unqualified identifiers is ambiguous and\n\u003e gives rise to difficult-to-detect semantic errors.\n\u003e \n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet lim = String.length name - 1 in\n...\nlet lim = Array.length v - 1 in\n...\n... List.map succ ...\n... Array.map succ ...\n```\n####  When to use open modules rather than leaving them closed\nYou can consider it normal to open a module which modifies the\nenvironment, and brings other versions of an important set of functions.\nFor example, the `Format` module provides automatically indented\nprinting. This module redefines the usual printing functions\n`print_string`, `print_int`, `print_float`, etc. So when you use\n`Format`, open it systematically at the top of the file.\u003cbr /\u003e\nIf you don't open `Format` you could miss the qualification of a\nprinting function, and this could be perfectly silent, since many of\n`Format`'s functions have a counterpart in the default environment\n(`Pervasives`). Mixing printing functions from `Format` and `Pervasives`\nleads to subtle bugs in the display, that are difficult to trace. For\ninstance:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet f () =\n  Format.print_string \"Hello World!\"; print_newline ()\n```\nis bogus since it does not call `Format.print_newline` to flush the\npretty-printer queue and output `\"Hello World!\"`. Instead\n`\"Hello World!\"` is stuck into the pretty-printer queue, while\n`Pervasives.print_newline` outputs a carriage return on the standard\noutput ... If `Format` is printing on a file and standard output is the\nterminal, the user will have a bad time finding that a carriage return\nis missing in the file (and the display of material on the file is\nstrange, since boxes that should be closed by `Format.print_newline` are\nstill open), while a spurious carriage return appeared on the screen!\n\nFor the same reason, open large libraries such as the one with\narbitrary-precision integers so as not to burden the program which uses\nthem.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nopen Num\n\nlet rec fib n =\n  if n \u003c= 2 then Int 1 else fib (n - 1) +/ fib (n - 2)\n```\n\u003e \n\u003e **Justification**: The program would be less readable if you had to\n\u003e qualify all the identifiers.\n\u003e \n\nIn a program where type definitions are shared, it is good to gather\nthese definitions into one or more module(s) without implementations\n(containing only types). Then it's acceptable to systematically open the\nmodule which exports the shared type definitions.\n\n###  Pattern-matching\n####  Never be afraid of over-using pattern-matching!\n####  On the other hand, be careful to avoid non-exhaustive pattern-matching constructs\nComplete them with care, without using a catch-all clause such as\n`| _ -\u003e ...` or `| x -\u003e ...` when it's possible to do without it (for\nexample when matching a concrete type defined within the program). See\nalso the next section: compiler warnings.\n\n###  Compiler warnings\nCompiler warnings are meant to prevent potential errors; this is why you\nabsolutely must heed them and correct your programs if compiling them\nproduces such warnings. Besides, programs whose compilation produces\nwarnings have an odor of amateurism which certainly doesn't suit your\nown work!\n\n####  Pattern-matching warnings\nWarnings about pattern-matching must be treated with the upmost care:\n\n* Those concerning useless clauses should of course be eliminated.\n\n\n* For non-exhaustive pattern-matching you must complete the\n corresponding pattern-matching construct, without adding a default\n case catch-all, such as `| _ -\u003e ... `, but with an explicit\n list of the constructors not examined by the rest of the construct,\n for example `| Cn _ | Cn1 _ -\u003e ... `.\n\n\u003e \n\u003e **Justification**: It's not really any more complicated to write\n\u003e it this way, and this allows the program to evolve more safely. In\n\u003e effect the addition of a new constructor to the datatype being\n\u003e matched will produce an alert anew, which will allow the\n\u003e programmer to add a clause corresponding to the new constructor if\n\u003e that is warranted. On the contrary, the catch-all clause\n\u003e will make the function compile silently and it might be thought\n\u003e that the function is correct as the new constructor will be\n\u003e handled by the default case.\n\u003e \n\n\n* Non-exhaustive pattern-matches induced by clauses with guards must\n also be corrected. A typical case consists in suppressing a\n redundant guard.\n\n####  De-structuring `let` bindings\n\\[Translator's note: a de-structuring `let` binding is one which\nbinds several names to several expressions simultaneously. You pack all\nthe names you want bound into a collection such as a tuple or a list,\nand you correspondingly pack all the expressions into a collective\nexpression. When the `let` binding is evaluated, it unpacks the\ncollections on both sides and binds each expression to its corresponding\nname. For example, `let x, y = 1, 2` is a de-structuring `let` binding\nwhich performs both the bindings `let x = 1` and `let y = 2`\nsimultaneously.\\]\u003cbr /\u003e\nThe `let` binding is not limited to simple identifier definitions: you\ncan use it with more complex or simpler patterns. For instance\n\n* `let` with complex patterns:\u003cbr /\u003e\n `let [x; y] as l = ...`\u003cbr /\u003e\n simultaneously defines a list `l` and its two elements `x` and `y`.\n* `let` with simple pattern:\u003cbr /\u003e\n `let _ = ...` does not define anything, it just evaluate the\n expression on the right hand side of the `=` symbol.\n\n####  The de-structuring `let` must be exhaustive\nOnly use de-structuring `let` bindings in the case where the\npattern-matching is exhaustive (the pattern can never fail to match).\nTypically, you will thus be limited to definitions of product types\n(tuples or records) or definitions of variant type with a single case.\nIn any other case, you should use an explicit `match   ... with`\nconstruct.\n\n* `let ... in`: de-structuring `let` that give a warning must be\n replaced by an explicit pattern matching. For instance, instead of\n `let [x; y] as l = List.map succ     (l1 @ l2) in expression` write:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmatch List.map succ (l1 @ l2) with\n| [x; y] as l -\u003e expression\n| _ -\u003e assert false\n```\n\n\n* Global definition with de-structuring lets should be rewritten with\n explicit pattern matching and tuples:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet x, y, l =\n  match List.map succ (l1 @ l2) with\n  | [x; y] as l -\u003e x, y, l\n  | _ -\u003e assert false\n```\n\n\n\u003e \n\u003e **Justification**: There is no way to make the pattern-matching\n\u003e exhaustive if you use general de-structuring `let` bindings.\n\u003e \n\n####  Sequence warnings and `let _ = ...`\nWhen the compiler emits a warning about the type of an expression in a\nsequence, you have to explicitly indicate that you want to ignore the\nresult of this expression. To this end:\n\n* use a vacuous binding and suppress the sequence warning of\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nList.map f l;\nprint_newline ()\n```\nwrite\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet _ = List.map f l in\nprint_newline ()\n```\n\n\n* you can also use the predefined function `ignore : 'a     -\u003e unit`\n that ignores its argument to return `unit`.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nignore (List.map f l);\nprint_newline ()\n```\n\n\n* In any case, the best way to suppress this warning is to understand\n why it is emitted by the compiler: the compiler warns you because\n your code computes a result that is useless since this result is\n just deleted after computation. Hence, if useful at all, this\n computation is performed only for its side-effects; hence it should\n return unit.\u003cbr /\u003e\n Most of the time, the warning indicates the use of the wrong\n function, a probable confusion between the side-effect only version\n of a function (which is a procedure whose result is irrelevant) with\n its functional counterpart (whose result is meaningful).\u003cbr /\u003e\n In the example mentioned above, the first situation prevailed, and\n the programmer should have called `iter` instead of `map`, and\n simply write\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nList.iter f l;\nprint_newline ()\n```\nIn actual programs, the suitable (side-effect only) function may not\nexist and has to be written: very often, a careful separation of the\nprocedural part from the functional part of the function at hand\nelegantly solves the problem, and the resulting program just looks\nbetter afterwards! For instance, you would turn the problematic\ndefinition:\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet add x y =\n  if x \u003e 1 then print_int x;\n  print_newline ();\n  x + y;;\n```\ninto the clearer separate definitions and change old calls to `add`\naccordingly.\n\n\n\nIn any case, use the `let _ = ...` construction exactly in those cases\nwhere you want to ignore a result. Don't systematically replace\nsequences with this construction.\n\n\u003e \n\u003e **Justification**: Sequences are much clearer! Compare `e1; e2; e3` to\n\u003e \n\u003e ```ocaml\n\u003e let _ = e1 in\n\u003e let _ = e2 in\n\u003e e3\n\u003e ```\n\n###  The `hd` and `tl` functions\nDon't use the `hd` and `tl` functions, but pattern-match the list\nargument explicitly.\n\n\u003e \n\u003e **Justification**: This is just as brief as and much clearer than\n\u003e using `hd` and `tl` which must of necessity be protected by\n\u003e `try... with...` to catch the exception which might be raised by these\n\u003e functions.\n\u003e \n\n###  Loops\n####  `for` loops\nTo simply traverse an array or a string, use a `for` loop.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nfor i = 0 to Array.length v - 1 do\n  ...\ndone\n```\nIf the loop is complex or returns a result, use a recursive function.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet find_index e v =\n  let rec loop i =\n    if i \u003e= Array.length v then raise Not_found else\n    if v.(i) = e then i else loop (i + 1) in\n  loop 0;;\n```\n\u003e \n\u003e **Justification**: The recursive function lets you code any loop\n\u003e whatsoever simply, even a complex one, for example with multiple exit\n\u003e points or with strange index steps (steps depending on a data value\n\u003e for example).\n\u003e \n\u003e Besides, the recursive loop avoids the use of mutables whose value can\n\u003e be modified in any part of the body of the loop whatsoever (or even\n\u003e outside): on the contrary the recursive loop explicitly takes as\n\u003e arguments the values susceptible to change during the recursive calls.\n\u003e \n\n####  `while` loops\n\u003e \n\u003e **While loops law**: Beware: usually a while loop is wrong, unless its\n\u003e loop invariant has been explicitly written.\n\u003e \n\nThe main use of the `while` loop is the infinite loop\n`while true do     ...`. You get out of it through an exception,\ngenerally on termination of the program.\n\nOther `while` loops are hard to use, unless they come from canned\nprograms from algorithms courses where they were proved.\n\n\u003e \n\u003e **Justification**: `while` loops require one or more mutables in order\n\u003e that the loop condition change value and the loop finally terminate.\n\u003e To prove their correctness, you must therefore discover the loop\n\u003e invariants, an interesting but difficult sport.\n\u003e \n\n###  Exceptions\nDon't be afraid to define your own exceptions in your programs, but on\nthe other hand use as much as possible the exceptions predefined by the\nsystem. For example, every search function which fails should raise the\npredefined exception `Not_found`. Be careful to handle the exceptions\nwhich may be raised by a function call with the help of a\n`try ... with`.\n\nHandling all exceptions by `try     ... with _ -\u003e` is usually reserved\nfor the main function of the program. If you need to catch all\nexceptions to maintain an invariant of an algorithm, be careful to name\nthe exception and re-raise it, after having reset the invariant.\nTypically:\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet ic = open_in ...\nand oc = open_out ... in\ntry\n  treatment ic oc;\n  close_in ic; close_out oc\nwith x -\u003e close_in ic; close_out oc; raise x\n```\n\u003e \n\u003e **Justification**: `try ... with _     -\u003e` silently catches all\n\u003e exceptions, even those which have nothing to do with the computation\n\u003e at hand (for example an interruption will be captured and the\n\u003e computation will continue anyway!).\n\u003e \n\n###  Data structures\nOne of the great strengths of OCaml is the power of the data structures\nwhich can be defined and the simplicity of manipulating them. So you\nmust take advantage of this to the fullest extent; don't hesitate to\ndefine your own data structures. In particular, don't systematically\nrepresent enumerations by whole numbers, nor enumerations with two cases\nby booleans. Examples:\n\n```ocaml\ntype figure =\n   | Triangle | Square | Circle | Parallelogram\ntype convexity =\n   | Convex | Concave | Other\ntype type_of_definition =\n   | Recursive | Non_recursive\n```\n\u003e \n\u003e **Justification**: A boolean value often prevents intuitive\n\u003e understanding of the corresponding code. For example, if\n\u003e `type_of_definition` is coded by a boolean, what does `true` signify?\n\u003e A normal definition (that is, non-recursive) or a recursive\n\u003e definition?\n\u003e \n\u003e In the case of an enumerated type encode by an integer, it is very\n\u003e difficult to limit the range of acceptable integers: one must define\n\u003e construction functions that will ensure the mandatory invariants of\n\u003e the program (and verify afterwards that no values has been built\n\u003e directly), or add assertions in the program and guards in pattern\n\u003e matchings. This is not good practice, when the definition of a sum\n\u003e type elegantly solves this problem, with the additional benefit of\n\u003e firing the full power of pattern matching and compiler's verifications\n\u003e of exhaustiveness.\n\u003e \n\u003e **Criticism**: For binary enumerations, one can systematically define\n\u003e predicates whose names carry the semantics of the boolean that\n\u003e implements the type. For instance, we can adopt the convention that a\n\u003e predicate ends by the letter `p`. Then, in place of defining a new sum\n\u003e type for `type_of_definition`, we will use a predicate function\n\u003e `recursivep` that returns true if the definition is recursive.\n\u003e \n\u003e **Answer**: This method is specific to binary enumeration and cannot\n\u003e be easily extended; moreover it is not well suited to pattern\n\u003e matching. For instance, for definitions encoded by\n\u003e `| Let of bool * string * expression` a typical pattern matching would\n\u003e look like:\n\u003e \n\u003e ```ocaml\n\u003e | Let (_, v, e) as def -\u003e\n\u003e    if recursivep def then code_for_recursive_case\n\u003e    else code_for_non_recursive_case\n\u003e ```\n\u003e \n\u003e or, if `recursivep` can be applied to booleans:\n\u003e \n\u003e ```ocaml\n\u003e | Let (b, v, e) -\u003e\n\u003e    if recursivep b then code_for_recursive_case\n\u003e    else code_for_non_recursive_case\n\u003e ```\n\u003e \n\u003e contrast with an explicit encoding:\n\u003e \n\u003e ```ocaml\n\u003e | Let (Recursive, v, e) -\u003e code_for_recursive_case\n\u003e | Let (Non_recursive, v, e) -\u003e code_for_non_recursive_case\n\u003e ```\n\u003e \n\u003e The difference between the two programs is subtle and you may think\n\u003e that this is just a matter of taste; however the explicit encoding is\n\u003e definitively more robust to modifications and fits better with the\n\u003e language.\n\u003e \n\n*A contrario*, it is not necessary to systematically define new types\nfor boolean flags, when the interpretation of constructors `true` and\n`false` is clear. The usefulness of the definition of the following\ntypes is then questionable:\n\u003c!-- $MDX skip --\u003e\n```ocaml\ntype switch = On | Off\ntype bit = One | Zero\n```\nThe same objection is admissible for enumerated types represented as\nintegers, when those integers have an evident interpretation with\nrespect to the data to be represented.\n\n###  When to use mutables\nMutable values are useful and sometimes indispensable to simple and\nclear programming. Nevertheless, you must use them with discernment:\nOCaml's normal data structures are immutable. They are to be preferred\nfor the clarity and safety of programming which they allow.\n\n###  Iterators\nOCaml's iterators are a powerful and useful feature. However you should\nnot overuse them, nor *a contrario* neglect them: they are provided to\nyou by libraries and have every chance of being correct and\nwell-thought-out by the author of the library. So it's useless to\nreinvent them.\n\nSo write\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet square_elements elements = List.map square elements\n```\nrather than:\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec square_elements = function\n  | [] -\u003e []\n  | elem :: elements -\u003e square elem :: square_elements elements\n```\nOn the other hand avoid writing:\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet iterator f x l =\n  List.fold_right (List.fold_left f) [List.map x l] l\n```\neven though you get:\n\u003c!-- $MDX skip --\u003e\n```ocaml\n  let iterator f x l =\n    List.fold_right (List.fold_left f) [List.map x l] l;;\n  iterator (fun l x -\u003e x :: l) (fun l -\u003e List.rev l) [[1; 2; 3]]\n```\nIn case of express need, you must be careful to add an explanatory\ncomment: in my opinion it's absolutely necessary!\n\n###  How to optimize programs\n\u003e \n\u003e **Pseudo law of optimization**: No optimization *a priori*.\u003cbr /\u003e\n\u003e  No optimization *a posteriori* either.\n\u003e \n\nAbove all program simply and clearly. Don't start optimizing until the\nprogram bottleneck has been identified (in general a few routines). Then\noptimization consists above all of changing *the complexity* of the\nalgorithm used. This often happens through redefining the data\nstructures being manipulated and completely rewriting the part of the\nprogram which poses a problem.\n\n\u003e \n\u003e **Justification**: Clarity and correctness of programs take\n\u003e precedence. Besides, in a substantial program, it is practically\n\u003e impossible to identify *a priori* the parts of the program whose\n\u003e efficiency is of prime importance.\n\u003e \n\n###  How to choose between classes and modules\nYou should use OCaml classes when you need inheritance, that is,\nincremental refinement of data and their functionality.\n\nYou should use conventional data structures (in particular, variant\ntypes) when you need pattern-matching.\n\nYou should use modules when the data structures are fixed and their\nfunctionality is equally fixed or it's enough to add new functions in\nthe programs which use them.\n\n###  Clarity of OCaml code\nThe OCaml language includes powerful constructs which allow simple and\nclear programming. The main problem to obtain crystal clear programs it\nto use them appropriately.\n\nThe language features numerous programming styles (or programming\nparadigms): imperative programming (based on the notion of state and\nassignment), functional programming (based on the notion of function,\nfunction results, and calculus), object oriented programming (based of\nthe notion of objects encapsulating a state and some procedures or\nmethods that can modify the state). The first work of the programmer is\nto choose the programming paradigm that fits the best the problem at\nhand. When using one of those programming paradigms, the difficulty is\nto use the language construct that expresses in the most natural and\neasiest way the computation that implements the algorithm.\n\n####  Style dangers\nConcerning programming styles, one can usually observe the two\nsymmetrical problematic behaviors: on the one hand, the all\nimperative way (*systematic* usage of loops and assignment), and on\nthe other hand the purely functional way (*never* use loops nor\nassignments); the 100% object style will certainly appear in the\nnext future, but (fortunately) it is too new to be discussed here.\n\n* **The Too much imperative danger**:\n    * It is a bad idea to use imperative style to code a function that\n is *naturally* recursive. For instance, to compute the length of\n a list, you should not write:\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet list_length l =\n  let l = ref l in\n  let res = ref 0 in\n  while !l \u003c\u003e [] do\n    incr res; l := List.tl !l\n  done;\n  !res;;\n```\nin place of the following recursive function, so simple and\nclear:\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec list_length = function\n  | [] -\u003e 0\n  | _ :: l -\u003e 1 + list_length l\n```\n(For those that would contest the equivalence of those two\nversions, see the [note below](#Imperativeandfunctionalversionsoflistlength)).\n\n\n* Another common over imperative error in the imperative world is\n  not to systematically choose the simple `for` loop to iter on the\n  element of a vector, but instead to use a complex `while` loop, with\n  one or two references (too many useless assignments, too many\n  opportunity for errors).\n\n* This category of programmer feels that the `mutable` keyword in\n  the record type definitions should be implicit.\n\n* **The Too much functional danger**:\n    * The programmer that adheres to this dogma avoids\n using arrays and assignment. In the most severe case, one\n observes a complete denial of writing any imperative\n construction, even in case it is evidently the most elegant way\n to solve the problem.\n    * Characteristic symptoms: systematic rewriting of `for` loops\n with recursive functions, usage of lists in contexts where\n imperative data structures seem to be mandatory to anyone,\n passing numerous global parameters of the problem to every\n functions, even if a global reference would be perfect to avoid\n these spurious parameters that are mainly invariants that must\n be passed all over the place.\n    * This programmer feels that the `mutable` keyword in the record\n type definitions should be suppressed from the language.\n\n####  OCaml code generally considered unreadable\nThe OCaml language includes powerful constructs which allow simple and\nclear programming. However the power of these constructs also lets you\nwrite uselessly complicated code, to the point where you get a perfectly\nunreadable program.\n\nHere are a number of known ways:\n\n* Use useless (hence novice for readability) `if then else`, as in\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet flush_ps () =\n  if not !psused then psused := true\n```\nor (more subtle)\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet sync b =\n  if !last_is_dvi \u003c\u003e b then last_is_dvi := b\n```\n\n\n* Code one construct with another. For example code a `let ... in` by\n the application of an anonymous function to an argument. You would\n write\u003cbr /\u003e\n\u003c!-- $MDX skip --\u003e\n```ocaml\n(fun x y -\u003e x + y)\n   e1 e2\n```\ninstead of simply writing\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet x = e1\nand y = e2 in\nx + y\n```\n\n\n* Systematically code sequences with `let in` bindings.\n\n\n* Mix computations and side effects, particularly in function calls.\n Recall that the order of evaluation of arguments in a function call\n is unspecified, which implies that you must not mix side effects and\n computations in function calls. However, when there is only one\n argument you might take advantage of this to perform a side effect\n within the argument, which is extremely troublesome for the reader\n albeit without danger to the program semantics. To be absolutely\n forbidden.\n\n\n* Misuse of iterators and higher-order functions (i.e. over- or\n under-use). For example it's better to use `List.map` or\n `List.iter` than to write their equivalents in-line using specific\n recursive functions of your own. Even worse, you don't use\n `List.map` or `List.iter` but write their equivalents in terms of\n `List.fold_right` and `List.fold_left`.\n\n\n* Another efficient way to write unreadable code is to mix all or some\n of these methods. For example:\n\u003c!-- $MDX skip --\u003e\n```ocaml\n(fun u -\u003e print_string \"world\"; print_string u)\n  (let temp = print_string \"Hello\"; \"!\" in\n   ((fun x -\u003e print_string x; flush stdout) \" \";\n    temp));;\n```\n\n\nIf you naturally write the program `print_string \"Hello world!\"` in this\nway, you can without a doubt submit your work to the [Obfuscated OCaml\nContest](mailto:Pierre.Weis@inria.fr).\n\n## Managing program development\nWe give here tips from veteran OCaml programmers, which have served in\ndeveloping the compilers which are good examples of large complex\nprograms developed by small teams.\n\n###  How to edit programs\nMany developers nurture a kind of veneration towards the Emacs editor\n(gnu-emacs in general) which they use to write their programs. The\neditor interfaces well with the language since it is capable of syntax\ncoloring OCaml source code (rendering different categories of words in\ncolor, coloring keywords for example).\n\nThe following two commands are considered indispensable:\n\n* `CTRL-C-CTRL-C` or `Meta-X compile`: launches re-compilation from\n within the editor (using the `make` command).\n* `` CTRL-X-` ``: puts the cursor in the file and at the exact place\n where the OCaml compiler has signaled an error.\n\nDevelopers describe thus how to use these features: `CTRL-C-CTRL-C`\ncombination recompiles the whole application; in case of errors, a\nsuccession of `` CTRL-X-` `` commands permits correction of all the\nerrors signaled; the cycle begins again with a new re-compilation\nlaunched by `CTRL-C-CTRL-C`.\n\n####  Other emacs tricks\nThe `ESC-/` command (dynamic-abbrev-expand) automatically completes the\nword in front of the cursor with one of the words present in one of the\nfiles being edited. Thus this lets you always choose meaningful\nidentifiers without the tedium of having to type extended names in your\nprograms: the `ESC-/` easily completes the identifier after typing the\nfirst letters. In case it brings up the wrong completion, each\nsubsequent `ESC-/` proposes an alternate completion.\n\nUnder Unix, the `CTRL-C-CTRL-C` or `Meta-X     compile` combination,\nfollowed by `` CTRL-X-` `` is also used to find all occurrences of a\ncertain string in a OCaml program. Instead of launching `make` to\nrecompile, you launch the `grep` command; then all the error\nmessages from `grep` are compatible with the `` CTRL-X-` `` usage\nwhich automatically takes you to the file and the place where the string\nis found.\n\n###  How to edit with the interactive system\nUnder Unix: use the line editor `ledit` which offers great editing\ncapabilities  la emacs (including `ESC-/`!), as well as a history\nmechanism which lets you retrieve previously typed commands and even\nretrieve commands from one session in another. `ledit` is written in\nOCaml and can be freely down-loaded\n[here](ftp://ftp.inria.fr/INRIA/Projects/cristal/caml-light/bazar-ocaml/ledit.tar.gz).\n\n###  How to compile\nThe `make` utility is indispensable for managing the compilation and\nre-compilation of programs. Sample `make` files can be found on [The\nHump](https://caml.inria.fr//cgi-bin/hump.en.cgi). You can also consult\nthe `Makefiles` for the OCaml compilers.\n\n###  How to develop as a team: version control\nUsers of the [Git](https://git-scm.com/) software version control system\nnever run out of good things to say about the productivity gains it\nbrings. This system supports managing development by a team of\nprogrammers while imposing consistency among them, and also maintains a\nlog of changes made to the software.\u003cbr /\u003e\n Git also supports simultaneous development by several teams, possibly\ndispersed among several sites linked on the Net.\n\nAn anonymous Git read-only mirror [contains the working sources of the\nOCaml compilers](https://github.com/ocaml/ocaml), and the sources of\nother software related to OCaml.\n\n##  Notes\n###  Imperative and functional versions of `list_length`\nThe two versions of `list_length` are not completely equivalent in term\nof complexity, since the imperative version uses a constant amount of\nstack room to execute, whereas the functional version needs to store\nreturn addresses of suspended recursive calls (whose maximum number is\nequal to the length of the list argument). If you want to retrieve a\nconstant space requirement to run the functional program you just have\nto write a function that is recursive in its tail (or *tail-rec*), that\nis a function that just ends by a recursive call (which is not the case\nhere since a call to `+` has to be perform after the recursive call has\nreturned). Just use an accumulator for intermediate results, as in:\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet list_length l =\n  let rec loop accu = function\n    | [] -\u003e accu\n    | _ :: l -\u003e loop (accu + 1) l in\n  loop 0 l\n```\nThis way, you get a program that has the same computational properties\nas the imperative program with the additional clarity and natural\nlook of an algorithm that performs pattern matching and recursive\ncalls to handle an argument that belongs to a recursive sum data type.\n\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#general-guidelines-to-write-programs\"\u003eGeneral guidelines to write programs\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#program-formatting-guidelines\"\u003eProgram formatting guidelines\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#indentation-of-programs\"\u003eIndentation of programs\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#programming-guidelines\"\u003eProgramming guidelines\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#managing-program-development\"\u003eManaging program development\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#notes\"\u003eNotes\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eThis is a set of reasonable guidelines for formatting OCaml\nprogramsguidelines which reflect the consensus among veteran OCaml\nprogrammers. Nevertheless, all detailed notifications of possible errors\nor omissions will be noted with pleasure. To send your comments using\n\u003ca href=\"https://github.com/ocaml/ocaml.org/issues?state=open\"\u003eGitHub issues\u003c/a\u003e.\n\u003cbr /\u003e\nOriginal translation from French: \u003ca href=\"mailto:datta@math.berkeley.edu\"\u003eRuchira\nDatta\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThanks to all those who have already participated in the critique of\nthis page: Daniel de Rauglaudre, Luc Maranget, Jacques Garrigue, Damien\nDoligez, Xavier Leroy, Bruno Verlyck, Bruno Petazzoni, Francois Maltey,\nBasile Starynkevitch, Toby Moth, Pierre Lescanne.\u003c/p\u003e\n\u003ch2 id=\"general-guidelines-to-write-programs\"\u003eGeneral guidelines to write programs\u003c/h2\u003e\n\u003ch3 id=\"be-simple-and-readable\"\u003eBe simple and readable\u003c/h3\u003e\n\u003cp\u003eThe time you spend typing the programs is negligible compared to the\ntime spent reading them. That's the reason why you save a lot of time if\nyou work hard to optimize readability.\u003c/p\u003e\n\u003cp\u003eAll the time you are \u0026quot;wasting\u0026quot; to get a simpler program today, will\nreturn a hundred times in the future during the uncountably many\nmodifications and readings of the program (starting with the first\ndebugging).\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eWriting programs law\u003c/strong\u003e: A program is written once, modified ten\ntimes, and read 100 times. So simplify its writing, always keep future\nmodifications in mind, and never jeopardize readability.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"program-formatting-guidelines\"\u003eProgram formatting guidelines\u003c/h2\u003e\n\u003ch3 id=\"lexical-conventions\"\u003eLexical conventions\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003ePseudo spaces law\u003c/strong\u003e: never hesitate to separate words of your\nprograms with spaces; the space bar is the easiest key to find on the\nkeyboard, press it as often as necessary!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"delimiters\"\u003eDelimiters\u003c/h4\u003e\n\u003cp\u003eA space should always follow a delimiter symbol, and spaces should\nsurround operator symbols. It has been a great step forward in\ntypography to separate words by spaces to make written texts easier to\nread. Do the same in your programs if you want them to be readable.\u003c/p\u003e\n\u003ch4 id=\"how-to-write-pairs\"\u003eHow to write pairs\u003c/h4\u003e\n\u003cp\u003eA tuple is parenthesized and the commas therein (delimiters) are each\nfollowed by a space: \u003ccode\u003e(1, 2)\u003c/code\u003e, \u003ccode\u003elet   triplet = (x, y, z)\u003c/code\u003e...\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCommonly accepted exceptions\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDefinition of the components of a pair\u003c/strong\u003e: In place of\n\u003ccode\u003elet (x, y) =       ...\u003c/code\u003e, you can write \u003ccode\u003elet x, y = ...\u003c/code\u003e.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: The point is to define several values\nsimultaneously, not to construct a tuple. Moreover, the\npattern is set off nicely between \u003ccode\u003elet\u003c/code\u003e and \u003ccode\u003e=\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eMatching several values simultaneously\u003c/strong\u003e: It's okay to omit\nparentheses around n-tuples when matching several values\nsimultaneously.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  match x, y with\n  | 1, _ -\u0026gt; ...\n  | x, 1 -\u0026gt; ...\n  | x, y -\u0026gt; ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: The point is to match several values in\nparallel, not to construct a tuple. Moreover, the expressions\nbeing matched are set off by \u003ccode\u003ematch\u003c/code\u003e and \u003ccode\u003ewith\u003c/code\u003e, while the\npatterns are set off nicely by \u003ccode\u003e|\u003c/code\u003e and \u003ccode\u003e-\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"how-to-write-lists\"\u003eHow to write lists\u003c/h4\u003e\n\u003cp\u003eWrite \u003ccode\u003ex :: l\u003c/code\u003e with spaces around the \u003ccode\u003e::\u003c/code\u003e (since \u003ccode\u003e::\u003c/code\u003e is an infix\noperator, hence surrounded by spaces) and \u003ccode\u003e[1; 2; 3]\u003c/code\u003e (since \u003ccode\u003e;\u003c/code\u003e is a\ndelimiter, hence followed by a space).\u003c/p\u003e\n\u003ch4 id=\"how-to-write-operator-symbols\"\u003eHow to write operator symbols\u003c/h4\u003e\n\u003cp\u003eBe careful to keep operator symbols well separated by spaces: not only\nwill your formulas be more readable, but you will avoid confusion with\nmulti-character operators. (Obvious exceptions to this rule: the symbols\n\u003ccode\u003e!\u003c/code\u003e and \u003ccode\u003e.\u003c/code\u003e are not separated from their arguments.)\u003cbr /\u003e\nExample: write \u003ccode\u003ex + 1\u003c/code\u003e or \u003ccode\u003ex + !y\u003c/code\u003e.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: If you left out the spaces then \u003ccode\u003ex+1\u003c/code\u003e would be\nunderstood, but \u003ccode\u003ex+!y\u003c/code\u003e would change its meaning since \u003ccode\u003e+!\u003c/code\u003e would\nbe interpreted as a multi-character operator.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCriticism\u003c/strong\u003e: The absence of spaces around an operator improves the\nreadability of formulas when you use it to reflect the relative\nprecedences of operators. For example \u003ccode\u003ex*y + 2*z\u003c/code\u003e makes it very\nobvious that multiplication takes precedence over addition.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eResponse\u003c/strong\u003e: This is a bad idea, a chimera, because nothing in the\nlanguage ensures that the spaces properly reflect the meaning of the\nformula. For example \u003ccode\u003ex * z-1\u003c/code\u003e means \u003ccode\u003e(x * z) - 1\u003c/code\u003e, and not\n\u003ccode\u003ex * (z - 1)\u003c/code\u003e as the proposed interpretation of spaces would seem to\nsuggest. Besides, the problem of multi-character symbols would keep\nyou from using this convention in a uniform way: you couldn't leave\nout the spaces around the multiplication to write \u003ccode\u003ex*!y + 2*!z\u003c/code\u003e.\nFinally, this playing with the spaces is a subtle and flimsy\nconvention, a subliminal message which is difficult to grasp on\nreading. If you want to make the precedences obvious, use the\nexpressive means brought to you by the language: write parentheses.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAdditional justification\u003c/strong\u003e: Systematically surrounding operators\nwith spaces simplify the treatment of infix operators which are no\nmore a complex particular case; in effect, whereas you can write \u003ccode\u003e(+)\u003c/code\u003e\nwithout spaces, you evidently cannot write \u003ccode\u003e(*)\u003c/code\u003e since \u003ccode\u003e(*\u003c/code\u003e is read as\nthe beginning of a comment. You must write at least one space as in\n\u003ccode\u003e( *)\u003c/code\u003e, although an extra space after \u003ccode\u003e*\u003c/code\u003e is definitively preferable\nif you want to avoid that \u003ccode\u003e*)\u003c/code\u003e could be read, in some contexts, as the\nend of a comment. All those difficulties are easily avoided if you\nadopt the simple rule proposed here: keep operator symbols well\nseparated by spaces.\u003cbr /\u003e\nIn fact you will quickly feel that this rule is not so difficult to\nfollow: the space bar is the greatest and best situated key of the\nkeyboard, it is the easiest to enter and you cannot miss it!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"how-to-write-long-character-strings\"\u003eHow to write long character strings\u003c/h4\u003e\n\u003cp\u003eIndent long character strings with the convention in force at that line\nplus an indication of string continuation at the end of each line (a \u003ccode\u003e\\\u003c/code\u003e\ncharacter at the end of the line that omits white spaces on the\nbeginning of next line):\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet universal_declaration =\n  \u0026quot;-1- Programs are born and remain free and equal under the law;\\n\\\n   distinctions can only be based on the common good.\u0026quot; in\n  ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"indentation-of-programs\"\u003eIndentation of programs\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eLandin's pseudo law\u003c/strong\u003e: Treat the indentation of your programs as if\nit determines the meaning of your programs.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI would add to this law: carefully treat the indentation of programs\nbecause in some cases it really gives the meaning of the program!\u003c/p\u003e\n\u003cp\u003eThe indentation of programs is an art which excites many strong\nopinions. Here several indentation styles are given which are drawn from\nexperience and which have not been severely criticized.\u003c/p\u003e\n\u003cp\u003eWhen a justification for the adopted style has seemed obvious to me, I\nhave indicated it. On the other hand, criticisms are also noted.\u003c/p\u003e\n\u003cp\u003eSo each time, you have to choose between the different styles\nsuggested.\u003cbr /\u003e\nThe only absolute rule is the first below.\u003c/p\u003e\n\u003ch3 id=\"consistency-of-indentation\"\u003eConsistency of indentation\u003c/h3\u003e\n\u003cp\u003eChoose a generally accepted style of indentation, then use it\nsystematically throughout the whole application.\u003c/p\u003e\n\u003ch3 id=\"width-of-the-page\"\u003eWidth of the page\u003c/h3\u003e\n\u003cp\u003eThe page is 80 columns wide.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: This width makes it possible to read the code on\nall displays and to print it in a legible font on a standard sheet.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"height-of-the-page\"\u003eHeight of the page\u003c/h3\u003e\n\u003cp\u003eA function should always fit within one screenful (of about 70 lines),\nor in exceptional cases two, at the very most three. To go beyond this\nis unreasonable.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: When a function goes beyond one screenful, it's\ntime to divide it into subproblems and handle them independently.\nBeyond a screenful, one gets lost in the code. The indentation is not\nreadable and is difficult to keep correct.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"how-much-to-indent\"\u003eHow much to indent\u003c/h3\u003e\n\u003cp\u003eThe change in indentation between successive lines of the program is\ngenerally 1 or 2 spaces. Pick an amount to indent and stick with it\nthroughout the program.\u003c/p\u003e\n\u003ch3 id=\"using-tab-stops\"\u003eUsing tab stops\u003c/h3\u003e\n\u003cp\u003eUsing the tab character (ASCII character 9) is absolutely \u003cem\u003enot\u003c/em\u003e\nrecommended.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: Between one display and another, the indentation of\nthe program changes completely; it can also become completely wrong,\nif the programmer used both tabulations and spaces to indent the\nprogram.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCriticism\u003c/strong\u003e: The purpose of using tabulations is just to allow the\nreaders of the program to indent more or less by changing the tabs\nstops. The overall indentation remains correct and the reader is glad\nto easily customize the indentation amount.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAnswer\u003c/strong\u003e: It seems almost impossible to use this method since you\nshould always use tabulations to indent, which is hard and unnatural.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"how-to-indent-global-let---definitions\"\u003eHow to indent global \u003ccode\u003elet ... ;;\u003c/code\u003e definitions\u003c/h3\u003e\n\u003cp\u003eThe body of a function defined globally in a module is generally\nindented normally. However, it's okay to treat this case specially to\nset off the definition better.\u003c/p\u003e\n\u003cp\u003eWith a regular indentation of 1 or 2 spaces:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet f x = function\n  | C -\u0026gt;\n  | D -\u0026gt;\n  ...\n\nlet g x =\n  let tmp =\n    match x with\n    | C -\u0026gt; 1\n    | x -\u0026gt; 0 in\n  tmp + 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: No exception to the amount of indentation.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOther conventions are acceptable, for example:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe body is left-justified in the case of pattern-matching.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet f x = function\n| C -\u0026gt;\n| D -\u0026gt;\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: The vertical bars separating the patterns stop\nwhen the definition is done, so it's still easy to pass on to the\nfollowing definition.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCriticism\u003c/strong\u003e: An unpleasant exception to the normal indentation.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eThe body is justified just under the name of the defined function.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet f x =\n    let tmp = ... in\n    try g x with\n    | Not_found -\u0026gt;\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: The first line of the definition is set off\nnicely, so it's easier to pass from definition to definition.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCriticism\u003c/strong\u003e: You run into the right margin too quickly.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"how-to-indent-let--in-constructs\"\u003eHow to indent \u003ccode\u003elet ... in\u003c/code\u003e constructs\u003c/h3\u003e\n\u003cp\u003eThe expression following a definition introduced by \u003ccode\u003elet\u003c/code\u003e is indented to\nthe same level as the keyword \u003ccode\u003elet\u003c/code\u003e, and the keyword \u003ccode\u003ein\u003c/code\u003e which\nintroduces it is written at the end of the line:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet expr1 = ... in\nexpr1 + expr1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the case of a series of \u003ccode\u003elet\u003c/code\u003e definitions, the preceding rule implies\nthat these definitions should be placed at the same indentation level:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet expr1 = ... in\nlet n = ... in\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: It is suggested that a series of let ... in\nconstructs is analogous to a set of assumptions in a mathematical\ntext, whence the same indentation level for all the assumptions.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eVariation: some write the keyword \u003ccode\u003ein\u003c/code\u003e alone on one line to set apart\nthe final expression of the computation:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet e1 = ... in\nlet e2 = ... in\nlet new_expr =\n  let e1' = derive_expression e1\n  and e2' = derive_expression e2 in\n  Add_expression e1' e2'\nin\nMult_expression (new_expr, new_expr)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eCriticism\u003c/strong\u003e: Lack of consistency.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"how-to-indent-if--then----else--\"\u003eHow to indent \u003ccode\u003eif ... then   ... else ... \u003c/code\u003e\u003c/h3\u003e\n\u003ch4 id=\"multiple-branches\"\u003eMultiple branches\u003c/h4\u003e\n\u003cp\u003eWrite conditions with multiple branches at the same level of\nindentation:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond1 ...\nif cond2 ...\nif cond3 ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: Analogous treatment to pattern-matching clauses,\nall aligned to the same tab stop.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIf the sizes of the conditions and the expressions allow, write for\nexample:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond1 then e1 else\nif cond2 then e2 else\nif cond3 then e3 else\ne4\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf expressions in the branches of multiple conditions have to be\nenclosed (when they include statements for instance), write:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond then begin\n    e1\n  end else\nif cond2 then begin\n    e2\n  end else\nif cond3 then ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSome suggest another method for multiple conditionals, starting each\nline by the keyword \u003ccode\u003eelse\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond1 ...\nelse if cond2 ...\nelse if cond3 ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: \u003ccode\u003eelsif\u003c/code\u003e is a keyword in many languages, so use\nindentation and \u003ccode\u003eelse if\u003c/code\u003e to bring it to mind. Moreover, you do not\nhave to look to the end of line to know whether the condition is\ncontinued or another test is performed.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCriticism\u003c/strong\u003e: Lack of consistency in the treatment of all the\nconditions. Why a special case for the first condition?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eYet again, choose your style and use it systematically.\u003c/p\u003e\n\u003ch4 id=\"single-branches\"\u003eSingle branches\u003c/h4\u003e\n\u003cp\u003eSeveral styles are possible for single branches, according to the size\nof the expressions in question and especially the presence of \u003ccode\u003ebegin\u003c/code\u003e\n\u003ccode\u003eend\u003c/code\u003e or \u003ccode\u003e(\u003c/code\u003e \u003ccode\u003e)\u003c/code\u003e delimiters for these expressions.\u003c/p\u003e\n\u003cp\u003eIn the case of delimiting the branches of a conditional, several styles\nare used:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e(\u003c/code\u003e at end of line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond then (\n  e1\n) else (\n  e2\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr alternatively first \u003ccode\u003ebegin\u003c/code\u003e at beginning of line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond then\n  begin\n    e1\n  end else begin\n    e2\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn fact the indentation of conditionals depends on the sizes of the\nexpressions which make them up.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf \u003ccode\u003econd\u003c/code\u003e, \u003ccode\u003ee1\u003c/code\u003e and \u003ccode\u003ee2\u003c/code\u003e are small, simply write them on one line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond then e1 else e2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the expressions making up a conditional are purely functional\n(without side effects), we advocate binding them within the\nconditional with \u003ccode\u003elet e = ... in\u003c/code\u003e when they're too big to fit on a\nline.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: This way you get back the simple indentation on\none line which is the most readable. As a side benefit, the naming\nacts as an aid to comprehension.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSo now we consider the case in which the expressions in question do\nhave side effects, which keeps us from simply binding them with a\n\u003ccode\u003elet e = ... in\u003c/code\u003e.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf \u003ccode\u003ee1\u003c/code\u003e and \u003ccode\u003econd\u003c/code\u003e are small, but \u003ccode\u003ee2\u003c/code\u003e large:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond then e1 else\n  e2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf \u003ccode\u003ee1\u003c/code\u003e and \u003ccode\u003econd\u003c/code\u003e are large and \u003ccode\u003ee2\u003c/code\u003e small:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond then\n  e1\nelse e2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf all the expressions are large:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond then\n  e1\nelse\n  e2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf there are \u003ccode\u003e( )\u003c/code\u003e delimiters:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond then (\n  e1\n) else (\n  e2\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA mixture where \u003ccode\u003ee1\u003c/code\u003e requires \u003ccode\u003e( )\u003c/code\u003e but \u003ccode\u003ee2\u003c/code\u003e is small:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond then (\n    e1\n) else e2\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"how-to-indent-pattern-matching-constructs\"\u003eHow to indent pattern-matching constructs\u003c/h3\u003e\n\u003ch4 id=\"general-principles\"\u003eGeneral principles\u003c/h4\u003e\n\u003cp\u003eAll the pattern-matching clauses are introduced by a vertical bar,\n\u003cem\u003eincluding\u003c/em\u003e the first one.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eCriticism\u003c/strong\u003e: The first vertical bar is not mandatory: hence, there\nis no need to write it.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAnswer to criticism\u003c/strong\u003e: If you omit the first bar the indentation\nseems unnatural : the first case gets an indentation that is greater\nthan a normal new line would necessitate. It is thus a useless\nexception to the correct indentation rule. It also insists not to use\nthe same syntax for the whole set of clauses, writing the first clause\nas an exception with a slightly different syntax. Last, aesthetic\nvalue is doubtful (some people would say awful instead of\ndoubtful).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAlign all the pattern-matching clauses at the level of the vertical bar\nwhich begins each clause, \u003cem\u003eincluding\u003c/em\u003e the first one.\u003c/p\u003e\n\u003cp\u003eIf an expression in a clause is too large to fit on the line, you must\nbreak the line immediately after the arrow of the corresponding clause.\nThen indent normally, starting from the beginning of the pattern of the\nclause.\u003c/p\u003e\n\u003cp\u003eArrows of pattern matching clauses should not be aligned.\u003c/p\u003e\n\u003ch4 id=\"match-or-try\"\u003e\u003ccode\u003ematch\u003c/code\u003e or \u003ccode\u003etry\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eFor a \u003ccode\u003ematch\u003c/code\u003e or a \u003ccode\u003etry\u003c/code\u003e align the clauses with the beginning of the\nconstruct:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ematch lam with\n| Abs (x, body) -\u0026gt; 1 + size_lambda body\n| App (lam1, lam2) -\u0026gt; size_lambda lam1 + size_lambda lam2\n| Var v -\u0026gt; 1\n\ntry f x with\n| Not_found -\u0026gt; ...\n| Failure \u0026quot;not yet implemented\u0026quot; -\u0026gt; ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePut the keyword \u003ccode\u003ewith\u003c/code\u003e at the end of the line. If the preceding\nexpression extends beyond one line, put \u003ccode\u003ewith\u003c/code\u003e on a line by itself:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etry\n  let y = f x in\n  if ...\nwith\n| Not_found -\u0026gt; ...\n| Failure \u0026quot;not yet implemented\u0026quot; -\u0026gt; ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: The keyword \u003ccode\u003ewith\u003c/code\u003e, on a line by itself shows that\nthe program enters the pattern matching part of the construct.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"indenting-expressions-inside-clauses\"\u003eIndenting expressions inside clauses\u003c/h4\u003e\n\u003cp\u003eIf the expression on the right of the pattern matching arrow is too\nlarge, cut the line after the arrow.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ematch lam with\n| Abs (x, body) -\u0026gt;\n   1 + size_lambda body\n| App (lam1, lam2) -\u0026gt;\n   size_lambda lam1 + size_lambda lam2\n| Var v -\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSome programmers generalize this rule to all clauses, as soon as one\nexpressions overflows. They will then indent the last clause like this:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e| Var v -\u0026gt;\n   1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOther programmers go one step further and apply this rule systematically\nto any clause of any pattern matching.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec fib = function\n  | 0 -\u0026gt;\n     1\n  | 1 -\u0026gt;\n     1\n  | n -\u0026gt;\n     fib (n - 1) + fib ( n - 2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eCriticism\u003c/strong\u003e: May be not compact enough; for simple pattern matchings\n(or simple clauses in complex matchings), the rule does not add any\ngood to readability.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: I don't see any good reason for this rule, unless\nyou are paid proportionally to the number of lines of code: in this\ncase use this rule to get more money without adding more bugs in your\nOCaml programs!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"pattern-matching-in-anonymous-functions\"\u003ePattern matching in anonymous functions\u003c/h4\u003e\n\u003cp\u003eSimilarly to \u003ccode\u003ematch\u003c/code\u003e or \u003ccode\u003etry\u003c/code\u003e, pattern matching of anonymous functions,\nstarting by \u003ccode\u003efunction\u003c/code\u003e, are indented with respect to the \u003ccode\u003efunction\u003c/code\u003e\nkeyword:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003emap\n  (function\n   | Abs (x, body) -\u0026gt; 1 + size_lambda 0 body\n   | App (lam1, lam2) -\u0026gt; size_lambda (size_lambda 0 lam1) lam2\n   | Var v -\u0026gt; 1)\n  lambda_list\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"pattern-matching-in-named-functions\"\u003ePattern matching in named functions\u003c/h4\u003e\n\u003cp\u003ePattern-matching in functions defined by \u003ccode\u003elet\u003c/code\u003e or \u003ccode\u003elet rec\u003c/code\u003e gives rise\nto several reasonable styles which obey the preceding rules for pattern\nmatching (the one for anonymous functions being evidently excepted). See\nabove for recommended styles.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec size_lambda accu = function\n  | Abs (x, body) -\u0026gt; size_lambda (succ accu) body\n  | App (lam1, lam2) -\u0026gt; size_lambda (size_lambda accu lam1) lam2\n  | Var v -\u0026gt; succ accu\n\nlet rec size_lambda accu = function\n| Abs (x, body) -\u0026gt; size_lambda (succ accu) body\n| App (lam1, lam2) -\u0026gt; size_lambda (size_lambda accu lam1) lam2\n| Var v -\u0026gt; succ accu\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"bad-indentation-of-pattern-matching-constructs\"\u003eBad indentation of pattern-matching constructs\u003c/h3\u003e\n\u003ch4 id=\"no-beastly-indentation-of-functions-and-case-analyses\"\u003eNo \u003cem\u003ebeastly\u003c/em\u003e indentation of functions and case analyses.\u003c/h4\u003e\n\u003cp\u003eThis consists in indenting normally under the keyword \u003ccode\u003ematch\u003c/code\u003e or\n\u003ccode\u003efunction\u003c/code\u003e which has previously been pushed to the right. Don't write:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec f x = function\n              | [] -\u0026gt; ...\n              ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebut choose to indent the line under the \u003ccode\u003elet\u003c/code\u003e keyword:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec f x = function\n  | [] -\u0026gt; ...\n  ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: You bump into the margin. The aesthetic value is\ndoubtful...\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"no-beastly-alignment-of-the---symbols-in-pattern-matching-clauses\"\u003eNo \u003cem\u003ebeastly\u003c/em\u003e alignment of the \u003ccode\u003e-\u0026gt;\u003c/code\u003e symbols in pattern-matching clauses.\u003c/h4\u003e\n\u003cp\u003eCareful alignment of the arrows of a pattern matching is considered bad\npractice, as exemplify in the following fragment:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet f = function\n  | C1          -\u0026gt; 1\n  | Long_name _ -\u0026gt; 2\n  | _           -\u0026gt; 3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: This makes it harder to maintain the program (the\naddition of a supplementary case can lead the indentations of all the\nlines to change and so ... we often give up alignment at that time,\nthen it is better not to align the arrows in the first place!).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"how-to-indent-function-calls\"\u003eHow to indent function calls\u003c/h3\u003e\n\u003ch4 id=\"indentation-to-the-functions-name\"\u003eIndentation to the function's name:\u003c/h4\u003e\n\u003cp\u003eNo problem arises except for functions with many argumentsor very\ncomplicated arguments as wellwhich can't fit on the same line. You\nmust indent the expressions with respect to the name of the function (1\nor 2 spaces according to the chosen convention). Write small arguments\non the same line, and change lines at the start of an argument.\u003c/p\u003e\n\u003cp\u003eAs far as possible, avoid arguments which consist of complex\nexpressions: in these cases define the large argument by a \u003ccode\u003elet\u003c/code\u003e\nconstruction.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: No indentation problem; if the name given to the\nexpressions is meaningful, the code is more readable as well.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAdditional justification\u003c/strong\u003e: If the evaluation of the arguments\nproduces side effects, the \u003ccode\u003elet\u003c/code\u003e binding is in fact necessary to\nexplicitly define the order of evaluation.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"naming-complex-arguments\"\u003eNaming complex arguments:\u003c/h4\u003e\n\u003cp\u003eIn place of\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet temp =\n  f x y z\n    large\n    expression\n    other large\n    expression in\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewrite\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet t =\n  large\n  expression\nand u =\n  other large\n  expression in\nlet temp =\n  f x y z t u in\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"naming-anonymous-functions\"\u003eNaming anonymous functions:\u003c/h4\u003e\n\u003cp\u003eIn the case of an iterator whose argument is a complex function, define\nthe function by a \u003ccode\u003elet\u003c/code\u003e binding as well. In place of\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eList.map\n  (function x -\u0026gt;\n    blabla\n    blabla\n    blabla)\n  l\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewrite\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet f x =\n  blabla\n  blabla\n  blabla in\nList.map f l\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: Much clearer, in particular if the name given to\nthe function is meaningful.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"how-to-indent-operations\"\u003eHow to indent operations\u003c/h3\u003e\n\u003cp\u003eWhen an operator takes complex arguments, or in the presence of multiple\ncalls to the same operator, start the next the line with the operator,\nand don't indent the rest of the operation. For example:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ex + y + z\n+ t + u\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: When the operator starts the line, it is clear that\nthe operation continues on this line.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn the case of a large expression in such an operation sequence,\nto define the large expression with the help of a \u003ccode\u003elet in\u003c/code\u003e\nconstruction is preferable to having to indent the line. In place of\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ex + y + z\n+ large\n  expression\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewrite\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet t =\n  large\n   expression in\nx + y + z + t\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou most certainly must bind those expressions too large to be written\nin one operation in the case of a combination of operators. In place of\nthe unreadable expression\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(x + y + z * t)\n/ (large\n    expression)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewrite\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet u =\n  large\n  expression in\n(x + y + z * t) / u\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese guidelines extend to all operators. For example:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet u =\n  large\n  expression in\nx :: y\n:: z + 1 :: t :: u\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"programming-guidelines\"\u003eProgramming guidelines\u003c/h2\u003e\n\u003ch3 id=\"how-to-program\"\u003eHow to program\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eAlways put your handiwork back on the bench,\u003cbr /\u003e\nand then polish it and re-polish it.\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"write-simple-and-clear-programs\"\u003eWrite simple and clear programs\u003c/h4\u003e\n\u003cp\u003eWhen this is done, reread, simplify and clarify. At every stage of\ncreation, use your head!\u003c/p\u003e\n\u003ch4 id=\"subdivide-your-programs-into-little-functions\"\u003eSubdivide your programs into little functions\u003c/h4\u003e\n\u003cp\u003eSmall functions are easier to master.\u003c/p\u003e\n\u003ch4 id=\"factor-out-snippets-of-repeated-code-by-defining-them-in-separate-functions\"\u003eFactor out snippets of repeated code by defining them in separate functions\u003c/h4\u003e\n\u003cp\u003eThe sharing of code obtained in this way facilitates maintenance since\nevery correction or improvement automatically spreads throughout the\nprogram. Besides, the simple act of isolating and naming a snippet of\ncode sometimes lets you identify an unsuspected feature.\u003c/p\u003e\n\u003ch4 id=\"never-copy-paste-code-when-programming\"\u003eNever copy-paste code when programming\u003c/h4\u003e\n\u003cp\u003ePasting code almost surely indicates introducing a default of code\nsharing and neglecting to identify and write a useful auxiliary\nfunction; hence, it means that some code sharing is lost in the program.\nLosing code sharing implies that you will have more problems afterwards\nfor maintenance: a bug in the pasted code has to be corrected at each\noccurrence of the bug in each copy of the code!\u003c/p\u003e\n\u003cp\u003eMoreover, it is difficult to identify that the same set of 10 lines of\ncode is repeated 20 times throughout the program. By contrast, if an\nauxiliary function defines those 10 lines, it is fairly easy to see and\nfind where those lines are used: that's simply where the function is\ncalled. If code is copy-pasted all over the place then the program is\nmore difficult to understand.\u003c/p\u003e\n\u003cp\u003eIn conclusion, copy-pasting code leads to programs that are more\ndifficult to read and more difficult to maintain: it has to be banished.\u003c/p\u003e\n\u003ch3 id=\"how-to-comment-programs\"\u003eHow to comment programs\u003c/h3\u003e\n\u003ch4 id=\"dont-hesitate-to-comment-when-theres-a-difficulty\"\u003eDon't hesitate to comment when there's a difficulty\u003c/h4\u003e\n\u003ch4 id=\"if-theres-no-difficulty-theres-no-point-in-commenting\"\u003eIf there's no difficulty, there's no point in commenting\u003c/h4\u003e\n\u003ch4 id=\"avoid-comments-in-the-bodies-of-functions\"\u003eAvoid comments in the bodies of functions\u003c/h4\u003e\n\u003ch4 id=\"prefer-one-comment-at-the-beginning-of-the-function\"\u003ePrefer one comment at the beginning of the function...\u003c/h4\u003e\n\u003cp\u003e...which explains how the algorithm that is used works. Once more, if\nthere is no difficulty, there is no point in commenting.\u003c/p\u003e\n\u003ch4 id=\"avoid-nocuous-comments\"\u003eAvoid nocuous comments\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003enocuous\u003c/em\u003e comment is a comment that does not add any value, i.e. no\nnon-trivial information. The nocuous comment is evidently not of\ninterest; it is a nuisance since it uselessly distracts the reader. It\nis often used to fulfill some strange criteria related to the so-called\n\u003cem\u003esoftware metrology\u003c/em\u003e, for instance the ratio \u003cem\u003enumber of comments\u003c/em\u003e /\n\u003cem\u003enumber of lines of code\u003c/em\u003e that perfectly measures a ratio that I don't\nknow the theoretical or practical interpretation. Absolutely avoid\nnocuous comments.\u003c/p\u003e\n\u003cp\u003eAn example of what to avoid: the following comment uses technical words\nand is thus masquerade into a real comment when it has no additional\ninformation of interest;\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(*\n  Function print_lambda:\n  print a lambda-expression given as argument.\n\n  Arguments: lam, any lambda-expression.\n  Returns: nothing.\n\n  Remark: print_lambda can only be used for its side effect.\n*)\nlet rec print_lambda lam =\n  match lam with\n  | Var s -\u0026gt; printf \u0026quot;%s\u0026quot; s\n  | Abs l -\u0026gt; printf \u0026quot;\\\\ %a\u0026quot; print_lambda l\n  | App (l1, l2) -\u0026gt;\n     printf \u0026quot;(%a %a)\u0026quot; print_lambda l1 print_lambda l2\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"usage-in-module-interface\"\u003eUsage in module interface\u003c/h4\u003e\n\u003cp\u003eThe function's usage must appear in the interface of the module which\nexports it, not in the program which implements it. Choose comments as\nin the OCaml system's interface modules, which will subsequently allow\nthe documentation of the interface module to be extracted automatically\nif need be.\u003c/p\u003e\n\u003ch4 id=\"use-assertions\"\u003eUse assertions\u003c/h4\u003e\n\u003cp\u003eUse assertions as much as possible: they let you avoid verbose comments,\nwhile allowing a useful verification upon execution.\u003c/p\u003e\n\u003cp\u003eFor example, the conditions for the arguments of a function to be valid\nare usefully verified by assertions.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet f x =\n  assert (x \u0026gt;= 0);\n  ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote as well that an assertion is often preferable to a comment because\nit's more trustworthy: an assertion is forced to be pertinent because it\nis verified upon each execution, while a comment can quickly become\nobsolete and then becomes actually detrimental to the comprehension of\nthe program.\u003c/p\u003e\n\u003ch4 id=\"comments-line-by-line-in-imperative-code\"\u003eComments line by line in imperative code\u003c/h4\u003e\n\u003cp\u003eWhen writing difficult code, and particularly in case of highly\nimperative code with a lot of memory modifications (physical mutations\nin data structures), it is sometime mandatory to comment inside the body\nof functions to explain the implementation of the algorithm encoded\nhere, or to follow successive modifications of invariants that the\nfunction must maintain. Once more, if there is some difficulty\ncommenting is mandatory, for each program line if necessary.\u003c/p\u003e\n\u003ch3 id=\"how-to-choose-identifiers\"\u003eHow to choose identifiers\u003c/h3\u003e\n\u003cp\u003eIt's hard to choose identifiers whose name evokes the meaning of the\ncorresponding portion of the program. This is why you must devote\nparticular care to this, emphasizing clarity and regularity of\nnomenclature.\u003c/p\u003e\n\u003ch4 id=\"dont-use-abbreviations-for-global-names\"\u003eDon't use abbreviations for global names\u003c/h4\u003e\n\u003cp\u003eGlobal identifiers (including especially the names of functions) can be\nlong, because it's important to understand what purpose they serve far\nfrom their definition.\u003c/p\u003e\n\u003ch4 id=\"separate-words-by-underscores-intofstring-not-intofstring\"\u003eSeparate words by underscores: (\u003ccode\u003eint_of_string\u003c/code\u003e, not \u003ccode\u003eintOfString\u003c/code\u003e)\u003c/h4\u003e\n\u003cp\u003eCase modifications are meaningful in OCaml: in effect capitalized words\nare reserved for constructors and module names in OCaml; in contrast\nregular variables (functions or identifiers) must start by a lowercase\nletter. Those rules prevent proper usage of case modification for words\nseparation in identifiers: the first word starts the identifier, hence\nit must be lower case and it is forbidden to choose \u003ccode\u003eIntOfString\u003c/code\u003e as the\nname of a function.\u003c/p\u003e\n\u003ch4 id=\"always-give-the-same-name-to-function-arguments-which-have-the-same-meaning\"\u003eAlways give the same name to function arguments which have the same meaning\u003c/h4\u003e\n\u003cp\u003eIf necessary, make this nomenclature explicit in a comment at the top of\nthe file); if there are several arguments with the same meaning then\nattach numeral suffixes to them.\u003c/p\u003e\n\u003ch4 id=\"local-identifiers-can-be-brief-and-should-be-reused-from-one-function-to-another\"\u003eLocal identifiers can be brief, and should be reused from one function to another\u003c/h4\u003e\n\u003cp\u003eThis augments regularity of style. Avoid using identifiers whose\nappearance can lead to confusion such as \u003ccode\u003el\u003c/code\u003e or \u003ccode\u003eO\u003c/code\u003e, easy to confuse\nwith \u003ccode\u003e1\u003c/code\u003e and \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet add_expression expr1 expr2 = ...\nlet print_expression expr = ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAn exception to the recommendation not to use capitalization to separate\nwords within identifiers is tolerated in the case of interfacing with\nexisting libraries which use this naming convention: this lets OCaml\nusers of the library to orient themselves in the original library\ndocumentation more easily.\u003c/p\u003e\n\u003ch3 id=\"when-to-use-parentheses-within-an-expression\"\u003eWhen to use parentheses within an expression\u003c/h3\u003e\n\u003cp\u003eParentheses are meaningful: they indicate the necessity of using an\nunusual precedence. So they should be used wisely and not sprinkled\nrandomly throughout programs. To this end, you should know the usual\nprecedences, that is, the combinations of operations which do not\nrequire parentheses. Quite fortunately this is not complicated if you\nknow a little mathematics or strive to follow the following rules:\u003c/p\u003e\n\u003ch4 id=\"arithmetic-operators-the-same-rules-as-in-mathematics\"\u003eArithmetic operators: the same rules as in mathematics\u003c/h4\u003e\n\u003cp\u003eFor example: \u003ccode\u003e1 + 2 * x\u003c/code\u003e means \u003ccode\u003e1 + (2 * x)\u003c/code\u003e.\u003c/p\u003e\n\u003ch4 id=\"function-application-the-same-rules-as-those-in-mathematics-for-usage-of-trigonometric-functions\"\u003eFunction application: the same rules as those in mathematics for usage of \u003cem\u003etrigonometric functions\u003c/em\u003e\u003c/h4\u003e\n\u003cp\u003eIn mathematics you write \u003ccode\u003esin x\u003c/code\u003e to mean \u003ccode\u003esin (x)\u003c/code\u003e. In the same way\n\u003ccode\u003esin x + cos x\u003c/code\u003e means \u003ccode\u003e(sin x) + (cos x)\u003c/code\u003e not \u003ccode\u003esin (x + (cos x))\u003c/code\u003e. Use\nthe same conventions in OCaml: write \u003ccode\u003ef x + g x\u003c/code\u003e to mean\n\u003ccode\u003e(f x) + (g x)\u003c/code\u003e.\u003cbr /\u003e\nThis convention generalizes \u003cstrong\u003eto all (infix) operators\u003c/strong\u003e: \u003ccode\u003ef x :: g x\u003c/code\u003e\nmeans \u003ccode\u003e(f x) :: (g x)\u003c/code\u003e, \u003ccode\u003ef x @ g x\u003c/code\u003e means \u003ccode\u003e(f x) @ (g x)\u003c/code\u003e, and\n\u003ccode\u003efailwith s ^ s'\u003c/code\u003e means \u003ccode\u003e(failwith s) ^ s'\u003c/code\u003e, \u003cem\u003enot\u003c/em\u003e \u003ccode\u003efailwith (s ^ s')\u003c/code\u003e.\u003c/p\u003e\n\u003ch4 id=\"comparisons-and-boolean-operators\"\u003eComparisons and boolean operators\u003c/h4\u003e\n\u003cp\u003eComparisons are infix operators, so the preceding rules apply. This is\nwhy \u003ccode\u003ef x \u0026lt; g x\u003c/code\u003e means \u003ccode\u003e(f x) \u0026lt; (g x)\u003c/code\u003e. For type reasons (no other\nsensible interpretation) the expression \u003ccode\u003ef x \u0026lt; x + 2\u003c/code\u003e means\n\u003ccode\u003e(f x) \u0026lt; (x + 2)\u003c/code\u003e. In the same way \u003ccode\u003ef x \u0026lt; x + 2 \u0026amp;\u0026amp; x \u0026gt; 3\u003c/code\u003e means\n\u003ccode\u003e((f x) \u0026lt; (x + 2)) \u0026amp;\u0026amp; (x \u0026gt; 3)\u003c/code\u003e.\u003c/p\u003e\n\u003ch4 id=\"the-relative-precedences-of-the-boolean-operators-are-those-of-mathematics\"\u003eThe relative precedences of the boolean operators are those of mathematics\u003c/h4\u003e\n\u003cp\u003eAlthough mathematicians have a tendency to overuse parens in this case,\nthe boolean or operator is analogous to addition and the and\nto multiplication. So, just as \u003ccode\u003e1 + 2 * x\u003c/code\u003e means \u003ccode\u003e1 + (2 * x)\u003c/code\u003e,\n\u003ccode\u003etrue || false \u0026amp;\u0026amp; x\u003c/code\u003e means \u003ccode\u003etrue || (false \u0026amp;\u0026amp; x)\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"how-to-delimit-constructs-in-programs\"\u003eHow to delimit constructs in programs\u003c/h3\u003e\n\u003cp\u003eWhen it is necessary to delimit syntactic constructs in programs, use as\ndelimiters the keywords \u003ccode\u003ebegin\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e rather than parentheses.\nHowever using parentheses is acceptable if you do it in a consistent,\nthat is, systematic, way.\u003c/p\u003e\n\u003cp\u003eThis explicit delimiting of constructs essentially concerns\npattern-matching constructs or sequences embedded within\n\u003ccode\u003eif then     else\u003c/code\u003e constructs.\u003c/p\u003e\n\u003ch4 id=\"match-construct-in-a-match-construct\"\u003e\u003ccode\u003ematch\u003c/code\u003e construct in a \u003ccode\u003ematch\u003c/code\u003e construct\u003c/h4\u003e\n\u003cp\u003eWhen a \u003ccode\u003ematch ... with\u003c/code\u003e or \u003ccode\u003etry ... with\u003c/code\u003e construct appears in a\npattern-matching clause, it is absolutely necessary to delimit this\nembedded construct (otherwise subsequent clauses of the enclosing\npattern-matching construct will automatically be associated with the\nenclosed pattern-matching construct). For example:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ematch x with\n| 1 -\u0026gt;\n  begin match y with\n  | ...\n  end\n| 2 -\u0026gt;\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"sequences-inside-branches-of-if\"\u003eSequences inside branches of \u003ccode\u003eif\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eIn the same way, a sequence which appears in the \u003ccode\u003ethen\u003c/code\u003e or \u003ccode\u003eelse\u003c/code\u003e part\nof a conditional must be delimited:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif cond then begin\n  e1;\n  e2\nend else begin\n  e3;\n  e4\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"how-to-use-modules\"\u003eHow to use modules\u003c/h3\u003e\n\u003ch4 id=\"subdividing-into-modules\"\u003eSubdividing into modules\u003c/h4\u003e\n\u003cp\u003eYou must subdivide your programs into coherent modules.\u003c/p\u003e\n\u003cp\u003eFor each module, you must explicitly write an interface.\u003c/p\u003e\n\u003cp\u003eFor each interface, you must document the things defined by the module:\nfunctions, types, exceptions, etc.\u003c/p\u003e\n\u003ch4 id=\"opening-modules\"\u003eOpening modules\u003c/h4\u003e\n\u003cp\u003eAvoid \u003ccode\u003eopen\u003c/code\u003e directives, using instead the qualified identifier\nnotation. Thus you will prefer short but meaningful module names.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: The use of unqualified identifiers is ambiguous and\ngives rise to difficult-to-detect semantic errors.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet lim = String.length name - 1 in\n...\nlet lim = Array.length v - 1 in\n...\n... List.map succ ...\n... Array.map succ ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"when-to-use-open-modules-rather-than-leaving-them-closed\"\u003eWhen to use open modules rather than leaving them closed\u003c/h4\u003e\n\u003cp\u003eYou can consider it normal to open a module which modifies the\nenvironment, and brings other versions of an important set of functions.\nFor example, the \u003ccode\u003eFormat\u003c/code\u003e module provides automatically indented\nprinting. This module redefines the usual printing functions\n\u003ccode\u003eprint_string\u003c/code\u003e, \u003ccode\u003eprint_int\u003c/code\u003e, \u003ccode\u003eprint_float\u003c/code\u003e, etc. So when you use\n\u003ccode\u003eFormat\u003c/code\u003e, open it systematically at the top of the file.\u003cbr /\u003e\nIf you don't open \u003ccode\u003eFormat\u003c/code\u003e you could miss the qualification of a\nprinting function, and this could be perfectly silent, since many of\n\u003ccode\u003eFormat\u003c/code\u003e's functions have a counterpart in the default environment\n(\u003ccode\u003ePervasives\u003c/code\u003e). Mixing printing functions from \u003ccode\u003eFormat\u003c/code\u003e and \u003ccode\u003ePervasives\u003c/code\u003e\nleads to subtle bugs in the display, that are difficult to trace. For\ninstance:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet f () =\n  Format.print_string \u0026quot;Hello World!\u0026quot;; print_newline ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eis bogus since it does not call \u003ccode\u003eFormat.print_newline\u003c/code\u003e to flush the\npretty-printer queue and output \u003ccode\u003e\u0026quot;Hello World!\u0026quot;\u003c/code\u003e. Instead\n\u003ccode\u003e\u0026quot;Hello World!\u0026quot;\u003c/code\u003e is stuck into the pretty-printer queue, while\n\u003ccode\u003ePervasives.print_newline\u003c/code\u003e outputs a carriage return on the standard\noutput ... If \u003ccode\u003eFormat\u003c/code\u003e is printing on a file and standard output is the\nterminal, the user will have a bad time finding that a carriage return\nis missing in the file (and the display of material on the file is\nstrange, since boxes that should be closed by \u003ccode\u003eFormat.print_newline\u003c/code\u003e are\nstill open), while a spurious carriage return appeared on the screen!\u003c/p\u003e\n\u003cp\u003eFor the same reason, open large libraries such as the one with\narbitrary-precision integers so as not to burden the program which uses\nthem.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eopen Num\n\nlet rec fib n =\n  if n \u0026lt;= 2 then Int 1 else fib (n - 1) +/ fib (n - 2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: The program would be less readable if you had to\nqualify all the identifiers.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn a program where type definitions are shared, it is good to gather\nthese definitions into one or more module(s) without implementations\n(containing only types). Then it's acceptable to systematically open the\nmodule which exports the shared type definitions.\u003c/p\u003e\n\u003ch3 id=\"pattern-matching\"\u003ePattern-matching\u003c/h3\u003e\n\u003ch4 id=\"never-be-afraid-of-over-using-pattern-matching\"\u003eNever be afraid of over-using pattern-matching!\u003c/h4\u003e\n\u003ch4 id=\"on-the-other-hand-be-careful-to-avoid-non-exhaustive-pattern-matching-constructs\"\u003eOn the other hand, be careful to avoid non-exhaustive pattern-matching constructs\u003c/h4\u003e\n\u003cp\u003eComplete them with care, without using a catch-all clause such as\n\u003ccode\u003e| _ -\u0026gt; ...\u003c/code\u003e or \u003ccode\u003e| x -\u0026gt; ...\u003c/code\u003e when it's possible to do without it (for\nexample when matching a concrete type defined within the program). See\nalso the next section: compiler warnings.\u003c/p\u003e\n\u003ch3 id=\"compiler-warnings\"\u003eCompiler warnings\u003c/h3\u003e\n\u003cp\u003eCompiler warnings are meant to prevent potential errors; this is why you\nabsolutely must heed them and correct your programs if compiling them\nproduces such warnings. Besides, programs whose compilation produces\nwarnings have an odor of amateurism which certainly doesn't suit your\nown work!\u003c/p\u003e\n\u003ch4 id=\"pattern-matching-warnings\"\u003ePattern-matching warnings\u003c/h4\u003e\n\u003cp\u003eWarnings about pattern-matching must be treated with the upmost care:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThose concerning useless clauses should of course be eliminated.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFor non-exhaustive pattern-matching you must complete the\ncorresponding pattern-matching construct, without adding a default\ncase catch-all, such as \u003ccode\u003e| _ -\u0026gt; ... \u003c/code\u003e, but with an explicit\nlist of the constructors not examined by the rest of the construct,\nfor example \u003ccode\u003e| Cn _ | Cn1 _ -\u0026gt; ... \u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: It's not really any more complicated to write\nit this way, and this allows the program to evolve more safely. In\neffect the addition of a new constructor to the datatype being\nmatched will produce an alert anew, which will allow the\nprogrammer to add a clause corresponding to the new constructor if\nthat is warranted. On the contrary, the catch-all clause\nwill make the function compile silently and it might be thought\nthat the function is correct as the new constructor will be\nhandled by the default case.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eNon-exhaustive pattern-matches induced by clauses with guards must\nalso be corrected. A typical case consists in suppressing a\nredundant guard.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"de-structuring-let-bindings\"\u003eDe-structuring \u003ccode\u003elet\u003c/code\u003e bindings\u003c/h4\u003e\n\u003cp\u003e[Translator's note: a de-structuring \u003ccode\u003elet\u003c/code\u003e binding is one which\nbinds several names to several expressions simultaneously. You pack all\nthe names you want bound into a collection such as a tuple or a list,\nand you correspondingly pack all the expressions into a collective\nexpression. When the \u003ccode\u003elet\u003c/code\u003e binding is evaluated, it unpacks the\ncollections on both sides and binds each expression to its corresponding\nname. For example, \u003ccode\u003elet x, y = 1, 2\u003c/code\u003e is a de-structuring \u003ccode\u003elet\u003c/code\u003e binding\nwhich performs both the bindings \u003ccode\u003elet x = 1\u003c/code\u003e and \u003ccode\u003elet y = 2\u003c/code\u003e\nsimultaneously.]\u003cbr /\u003e\nThe \u003ccode\u003elet\u003c/code\u003e binding is not limited to simple identifier definitions: you\ncan use it with more complex or simpler patterns. For instance\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elet\u003c/code\u003e with complex patterns:\u003cbr /\u003e\n\u003ccode\u003elet [x; y] as l = ...\u003c/code\u003e\u003cbr /\u003e\nsimultaneously defines a list \u003ccode\u003el\u003c/code\u003e and its two elements \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e.\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elet\u003c/code\u003e with simple pattern:\u003cbr /\u003e\n\u003ccode\u003elet _ = ...\u003c/code\u003e does not define anything, it just evaluate the\nexpression on the right hand side of the \u003ccode\u003e=\u003c/code\u003e symbol.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"the-de-structuring-let-must-be-exhaustive\"\u003eThe de-structuring \u003ccode\u003elet\u003c/code\u003e must be exhaustive\u003c/h4\u003e\n\u003cp\u003eOnly use de-structuring \u003ccode\u003elet\u003c/code\u003e bindings in the case where the\npattern-matching is exhaustive (the pattern can never fail to match).\nTypically, you will thus be limited to definitions of product types\n(tuples or records) or definitions of variant type with a single case.\nIn any other case, you should use an explicit \u003ccode\u003ematch   ... with\u003c/code\u003e\nconstruct.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elet ... in\u003c/code\u003e: de-structuring \u003ccode\u003elet\u003c/code\u003e that give a warning must be\nreplaced by an explicit pattern matching. For instance, instead of\n\u003ccode\u003elet [x; y] as l = List.map succ     (l1 @ l2) in expression\u003c/code\u003e write:\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ematch List.map succ (l1 @ l2) with\n| [x; y] as l -\u0026gt; expression\n| _ -\u0026gt; assert false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eGlobal definition with de-structuring lets should be rewritten with\nexplicit pattern matching and tuples:\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet x, y, l =\n  match List.map succ (l1 @ l2) with\n  | [x; y] as l -\u0026gt; x, y, l\n  | _ -\u0026gt; assert false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: There is no way to make the pattern-matching\nexhaustive if you use general de-structuring \u003ccode\u003elet\u003c/code\u003e bindings.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"sequence-warnings-and-let---\"\u003eSequence warnings and \u003ccode\u003elet _ = ...\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eWhen the compiler emits a warning about the type of an expression in a\nsequence, you have to explicitly indicate that you want to ignore the\nresult of this expression. To this end:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003euse a vacuous binding and suppress the sequence warning of\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eList.map f l;\nprint_newline ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewrite\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet _ = List.map f l in\nprint_newline ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eyou can also use the predefined function \u003ccode\u003eignore : 'a     -\u0026gt; unit\u003c/code\u003e\nthat ignores its argument to return \u003ccode\u003eunit\u003c/code\u003e.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eignore (List.map f l);\nprint_newline ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eIn any case, the best way to suppress this warning is to understand\nwhy it is emitted by the compiler: the compiler warns you because\nyour code computes a result that is useless since this result is\njust deleted after computation. Hence, if useful at all, this\ncomputation is performed only for its side-effects; hence it should\nreturn unit.\u003cbr /\u003e\nMost of the time, the warning indicates the use of the wrong\nfunction, a probable confusion between the side-effect only version\nof a function (which is a procedure whose result is irrelevant) with\nits functional counterpart (whose result is meaningful).\u003cbr /\u003e\nIn the example mentioned above, the first situation prevailed, and\nthe programmer should have called \u003ccode\u003eiter\u003c/code\u003e instead of \u003ccode\u003emap\u003c/code\u003e, and\nsimply write\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eList.iter f l;\nprint_newline ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn actual programs, the suitable (side-effect only) function may not\nexist and has to be written: very often, a careful separation of the\nprocedural part from the functional part of the function at hand\nelegantly solves the problem, and the resulting program just looks\nbetter afterwards! For instance, you would turn the problematic\ndefinition:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet add x y =\n  if x \u0026gt; 1 then print_int x;\n  print_newline ();\n  x + y;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003einto the clearer separate definitions and change old calls to \u003ccode\u003eadd\u003c/code\u003e\naccordingly.\u003c/p\u003e\n\u003cp\u003eIn any case, use the \u003ccode\u003elet _ = ...\u003c/code\u003e construction exactly in those cases\nwhere you want to ignore a result. Don't systematically replace\nsequences with this construction.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: Sequences are much clearer! Compare \u003ccode\u003ee1; e2; e3\u003c/code\u003e to\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet _ = e1 in\nlet _ = e2 in\ne3\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"the-hd-and-tl-functions\"\u003eThe \u003ccode\u003ehd\u003c/code\u003e and \u003ccode\u003etl\u003c/code\u003e functions\u003c/h3\u003e\n\u003cp\u003eDon't use the \u003ccode\u003ehd\u003c/code\u003e and \u003ccode\u003etl\u003c/code\u003e functions, but pattern-match the list\nargument explicitly.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: This is just as brief as and much clearer than\nusing \u003ccode\u003ehd\u003c/code\u003e and \u003ccode\u003etl\u003c/code\u003e which must of necessity be protected by\n\u003ccode\u003etry... with...\u003c/code\u003e to catch the exception which might be raised by these\nfunctions.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"loops\"\u003eLoops\u003c/h3\u003e\n\u003ch4 id=\"for-loops\"\u003e\u003ccode\u003efor\u003c/code\u003e loops\u003c/h4\u003e\n\u003cp\u003eTo simply traverse an array or a string, use a \u003ccode\u003efor\u003c/code\u003e loop.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003efor i = 0 to Array.length v - 1 do\n  ...\ndone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the loop is complex or returns a result, use a recursive function.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet find_index e v =\n  let rec loop i =\n    if i \u0026gt;= Array.length v then raise Not_found else\n    if v.(i) = e then i else loop (i + 1) in\n  loop 0;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: The recursive function lets you code any loop\nwhatsoever simply, even a complex one, for example with multiple exit\npoints or with strange index steps (steps depending on a data value\nfor example).\u003c/p\u003e\n\u003cp\u003eBesides, the recursive loop avoids the use of mutables whose value can\nbe modified in any part of the body of the loop whatsoever (or even\noutside): on the contrary the recursive loop explicitly takes as\narguments the values susceptible to change during the recursive calls.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"while-loops\"\u003e\u003ccode\u003ewhile\u003c/code\u003e loops\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eWhile loops law\u003c/strong\u003e: Beware: usually a while loop is wrong, unless its\nloop invariant has been explicitly written.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe main use of the \u003ccode\u003ewhile\u003c/code\u003e loop is the infinite loop\n\u003ccode\u003ewhile true do     ...\u003c/code\u003e. You get out of it through an exception,\ngenerally on termination of the program.\u003c/p\u003e\n\u003cp\u003eOther \u003ccode\u003ewhile\u003c/code\u003e loops are hard to use, unless they come from canned\nprograms from algorithms courses where they were proved.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: \u003ccode\u003ewhile\u003c/code\u003e loops require one or more mutables in order\nthat the loop condition change value and the loop finally terminate.\nTo prove their correctness, you must therefore discover the loop\ninvariants, an interesting but difficult sport.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"exceptions\"\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eDon't be afraid to define your own exceptions in your programs, but on\nthe other hand use as much as possible the exceptions predefined by the\nsystem. For example, every search function which fails should raise the\npredefined exception \u003ccode\u003eNot_found\u003c/code\u003e. Be careful to handle the exceptions\nwhich may be raised by a function call with the help of a\n\u003ccode\u003etry ... with\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHandling all exceptions by \u003ccode\u003etry     ... with _ -\u0026gt;\u003c/code\u003e is usually reserved\nfor the main function of the program. If you need to catch all\nexceptions to maintain an invariant of an algorithm, be careful to name\nthe exception and re-raise it, after having reset the invariant.\nTypically:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet ic = open_in ...\nand oc = open_out ... in\ntry\n  treatment ic oc;\n  close_in ic; close_out oc\nwith x -\u0026gt; close_in ic; close_out oc; raise x\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: \u003ccode\u003etry ... with _     -\u0026gt;\u003c/code\u003e silently catches all\nexceptions, even those which have nothing to do with the computation\nat hand (for example an interruption will be captured and the\ncomputation will continue anyway!).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"data-structures\"\u003eData structures\u003c/h3\u003e\n\u003cp\u003eOne of the great strengths of OCaml is the power of the data structures\nwhich can be defined and the simplicity of manipulating them. So you\nmust take advantage of this to the fullest extent; don't hesitate to\ndefine your own data structures. In particular, don't systematically\nrepresent enumerations by whole numbers, nor enumerations with two cases\nby booleans. Examples:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype figure =\n   | Triangle | Square | Circle | Parallelogram\ntype convexity =\n   | Convex | Concave | Other\ntype type_of_definition =\n   | Recursive | Non_recursive\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: A boolean value often prevents intuitive\nunderstanding of the corresponding code. For example, if\n\u003ccode\u003etype_of_definition\u003c/code\u003e is coded by a boolean, what does \u003ccode\u003etrue\u003c/code\u003e signify?\nA normal definition (that is, non-recursive) or a recursive\ndefinition?\u003c/p\u003e\n\u003cp\u003eIn the case of an enumerated type encode by an integer, it is very\ndifficult to limit the range of acceptable integers: one must define\nconstruction functions that will ensure the mandatory invariants of\nthe program (and verify afterwards that no values has been built\ndirectly), or add assertions in the program and guards in pattern\nmatchings. This is not good practice, when the definition of a sum\ntype elegantly solves this problem, with the additional benefit of\nfiring the full power of pattern matching and compiler's verifications\nof exhaustiveness.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCriticism\u003c/strong\u003e: For binary enumerations, one can systematically define\npredicates whose names carry the semantics of the boolean that\nimplements the type. For instance, we can adopt the convention that a\npredicate ends by the letter \u003ccode\u003ep\u003c/code\u003e. Then, in place of defining a new sum\ntype for \u003ccode\u003etype_of_definition\u003c/code\u003e, we will use a predicate function\n\u003ccode\u003erecursivep\u003c/code\u003e that returns true if the definition is recursive.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAnswer\u003c/strong\u003e: This method is specific to binary enumeration and cannot\nbe easily extended; moreover it is not well suited to pattern\nmatching. For instance, for definitions encoded by\n\u003ccode\u003e| Let of bool * string * expression\u003c/code\u003e a typical pattern matching would\nlook like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e| Let (_, v, e) as def -\u0026gt;\n   if recursivep def then code_for_recursive_case\n   else code_for_non_recursive_case\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor, if \u003ccode\u003erecursivep\u003c/code\u003e can be applied to booleans:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e| Let (b, v, e) -\u0026gt;\n   if recursivep b then code_for_recursive_case\n   else code_for_non_recursive_case\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003econtrast with an explicit encoding:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e| Let (Recursive, v, e) -\u0026gt; code_for_recursive_case\n| Let (Non_recursive, v, e) -\u0026gt; code_for_non_recursive_case\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe difference between the two programs is subtle and you may think\nthat this is just a matter of taste; however the explicit encoding is\ndefinitively more robust to modifications and fits better with the\nlanguage.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cem\u003eA contrario\u003c/em\u003e, it is not necessary to systematically define new types\nfor boolean flags, when the interpretation of constructors \u003ccode\u003etrue\u003c/code\u003e and\n\u003ccode\u003efalse\u003c/code\u003e is clear. The usefulness of the definition of the following\ntypes is then questionable:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype switch = On | Off\ntype bit = One | Zero\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe same objection is admissible for enumerated types represented as\nintegers, when those integers have an evident interpretation with\nrespect to the data to be represented.\u003c/p\u003e\n\u003ch3 id=\"when-to-use-mutables\"\u003eWhen to use mutables\u003c/h3\u003e\n\u003cp\u003eMutable values are useful and sometimes indispensable to simple and\nclear programming. Nevertheless, you must use them with discernment:\nOCaml's normal data structures are immutable. They are to be preferred\nfor the clarity and safety of programming which they allow.\u003c/p\u003e\n\u003ch3 id=\"iterators\"\u003eIterators\u003c/h3\u003e\n\u003cp\u003eOCaml's iterators are a powerful and useful feature. However you should\nnot overuse them, nor \u003cem\u003ea contrario\u003c/em\u003e neglect them: they are provided to\nyou by libraries and have every chance of being correct and\nwell-thought-out by the author of the library. So it's useless to\nreinvent them.\u003c/p\u003e\n\u003cp\u003eSo write\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet square_elements elements = List.map square elements\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003erather than:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec square_elements = function\n  | [] -\u0026gt; []\n  | elem :: elements -\u0026gt; square elem :: square_elements elements\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn the other hand avoid writing:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet iterator f x l =\n  List.fold_right (List.fold_left f) [List.map x l] l\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eeven though you get:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e  let iterator f x l =\n    List.fold_right (List.fold_left f) [List.map x l] l;;\n  iterator (fun l x -\u0026gt; x :: l) (fun l -\u0026gt; List.rev l) [[1; 2; 3]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn case of express need, you must be careful to add an explanatory\ncomment: in my opinion it's absolutely necessary!\u003c/p\u003e\n\u003ch3 id=\"how-to-optimize-programs\"\u003eHow to optimize programs\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003ePseudo law of optimization\u003c/strong\u003e: No optimization \u003cem\u003ea priori\u003c/em\u003e.\u003cbr /\u003e\nNo optimization \u003cem\u003ea posteriori\u003c/em\u003e either.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAbove all program simply and clearly. Don't start optimizing until the\nprogram bottleneck has been identified (in general a few routines). Then\noptimization consists above all of changing \u003cem\u003ethe complexity\u003c/em\u003e of the\nalgorithm used. This often happens through redefining the data\nstructures being manipulated and completely rewriting the part of the\nprogram which poses a problem.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eJustification\u003c/strong\u003e: Clarity and correctness of programs take\nprecedence. Besides, in a substantial program, it is practically\nimpossible to identify \u003cem\u003ea priori\u003c/em\u003e the parts of the program whose\nefficiency is of prime importance.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"how-to-choose-between-classes-and-modules\"\u003eHow to choose between classes and modules\u003c/h3\u003e\n\u003cp\u003eYou should use OCaml classes when you need inheritance, that is,\nincremental refinement of data and their functionality.\u003c/p\u003e\n\u003cp\u003eYou should use conventional data structures (in particular, variant\ntypes) when you need pattern-matching.\u003c/p\u003e\n\u003cp\u003eYou should use modules when the data structures are fixed and their\nfunctionality is equally fixed or it's enough to add new functions in\nthe programs which use them.\u003c/p\u003e\n\u003ch3 id=\"clarity-of-ocaml-code\"\u003eClarity of OCaml code\u003c/h3\u003e\n\u003cp\u003eThe OCaml language includes powerful constructs which allow simple and\nclear programming. The main problem to obtain crystal clear programs it\nto use them appropriately.\u003c/p\u003e\n\u003cp\u003eThe language features numerous programming styles (or programming\nparadigms): imperative programming (based on the notion of state and\nassignment), functional programming (based on the notion of function,\nfunction results, and calculus), object oriented programming (based of\nthe notion of objects encapsulating a state and some procedures or\nmethods that can modify the state). The first work of the programmer is\nto choose the programming paradigm that fits the best the problem at\nhand. When using one of those programming paradigms, the difficulty is\nto use the language construct that expresses in the most natural and\neasiest way the computation that implements the algorithm.\u003c/p\u003e\n\u003ch4 id=\"style-dangers\"\u003eStyle dangers\u003c/h4\u003e\n\u003cp\u003eConcerning programming styles, one can usually observe the two\nsymmetrical problematic behaviors: on the one hand, the all\nimperative way (\u003cem\u003esystematic\u003c/em\u003e usage of loops and assignment), and on\nthe other hand the purely functional way (\u003cem\u003enever\u003c/em\u003e use loops nor\nassignments); the 100% object style will certainly appear in the\nnext future, but (fortunately) it is too new to be discussed here.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eThe Too much imperative danger\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003eIt is a bad idea to use imperative style to code a function that\nis \u003cem\u003enaturally\u003c/em\u003e recursive. For instance, to compute the length of\na list, you should not write:\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet list_length l =\n  let l = ref l in\n  let res = ref 0 in\n  while !l \u0026lt;\u0026gt; [] do\n    incr res; l := List.tl !l\n  done;\n  !res;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ein place of the following recursive function, so simple and\nclear:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec list_length = function\n  | [] -\u0026gt; 0\n  | _ :: l -\u0026gt; 1 + list_length l\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(For those that would contest the equivalence of those two\nversions, see the \u003ca href=\"#Imperativeandfunctionalversionsoflistlength\"\u003enote below\u003c/a\u003e).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAnother common over imperative error in the imperative world is\nnot to systematically choose the simple \u003ccode\u003efor\u003c/code\u003e loop to iter on the\nelement of a vector, but instead to use a complex \u003ccode\u003ewhile\u003c/code\u003e loop, with\none or two references (too many useless assignments, too many\nopportunity for errors).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThis category of programmer feels that the \u003ccode\u003emutable\u003c/code\u003e keyword in\nthe record type definitions should be implicit.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eThe Too much functional danger\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe programmer that adheres to this dogma avoids\nusing arrays and assignment. In the most severe case, one\nobserves a complete denial of writing any imperative\nconstruction, even in case it is evidently the most elegant way\nto solve the problem.\n\u003c/li\u003e\n\u003cli\u003eCharacteristic symptoms: systematic rewriting of \u003ccode\u003efor\u003c/code\u003e loops\nwith recursive functions, usage of lists in contexts where\nimperative data structures seem to be mandatory to anyone,\npassing numerous global parameters of the problem to every\nfunctions, even if a global reference would be perfect to avoid\nthese spurious parameters that are mainly invariants that must\nbe passed all over the place.\n\u003c/li\u003e\n\u003cli\u003eThis programmer feels that the \u003ccode\u003emutable\u003c/code\u003e keyword in the record\ntype definitions should be suppressed from the language.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"ocaml-code-generally-considered-unreadable\"\u003eOCaml code generally considered unreadable\u003c/h4\u003e\n\u003cp\u003eThe OCaml language includes powerful constructs which allow simple and\nclear programming. However the power of these constructs also lets you\nwrite uselessly complicated code, to the point where you get a perfectly\nunreadable program.\u003c/p\u003e\n\u003cp\u003eHere are a number of known ways:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUse useless (hence novice for readability) \u003ccode\u003eif then else\u003c/code\u003e, as in\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet flush_ps () =\n  if not !psused then psused := true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor (more subtle)\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet sync b =\n  if !last_is_dvi \u0026lt;\u0026gt; b then last_is_dvi := b\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eCode one construct with another. For example code a \u003ccode\u003elet ... in\u003c/code\u003e by\nthe application of an anonymous function to an argument. You would\nwrite\u003cbr /\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(fun x y -\u0026gt; x + y)\n   e1 e2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003einstead of simply writing\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet x = e1\nand y = e2 in\nx + y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eSystematically code sequences with \u003ccode\u003elet in\u003c/code\u003e bindings.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMix computations and side effects, particularly in function calls.\nRecall that the order of evaluation of arguments in a function call\nis unspecified, which implies that you must not mix side effects and\ncomputations in function calls. However, when there is only one\nargument you might take advantage of this to perform a side effect\nwithin the argument, which is extremely troublesome for the reader\nalbeit without danger to the program semantics. To be absolutely\nforbidden.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMisuse of iterators and higher-order functions (i.e. over- or\nunder-use). For example it's better to use \u003ccode\u003eList.map\u003c/code\u003e or\n\u003ccode\u003eList.iter\u003c/code\u003e than to write their equivalents in-line using specific\nrecursive functions of your own. Even worse, you don't use\n\u003ccode\u003eList.map\u003c/code\u003e or \u003ccode\u003eList.iter\u003c/code\u003e but write their equivalents in terms of\n\u003ccode\u003eList.fold_right\u003c/code\u003e and \u003ccode\u003eList.fold_left\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAnother efficient way to write unreadable code is to mix all or some\nof these methods. For example:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(fun u -\u0026gt; print_string \u0026quot;world\u0026quot;; print_string u)\n  (let temp = print_string \u0026quot;Hello\u0026quot;; \u0026quot;!\u0026quot; in\n   ((fun x -\u0026gt; print_string x; flush stdout) \u0026quot; \u0026quot;;\n    temp));;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you naturally write the program \u003ccode\u003eprint_string \u0026quot;Hello world!\u0026quot;\u003c/code\u003e in this\nway, you can without a doubt submit your work to the \u003ca href=\"mailto:Pierre.Weis@inria.fr\"\u003eObfuscated OCaml\nContest\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"managing-program-development\"\u003eManaging program development\u003c/h2\u003e\n\u003cp\u003eWe give here tips from veteran OCaml programmers, which have served in\ndeveloping the compilers which are good examples of large complex\nprograms developed by small teams.\u003c/p\u003e\n\u003ch3 id=\"how-to-edit-programs\"\u003eHow to edit programs\u003c/h3\u003e\n\u003cp\u003eMany developers nurture a kind of veneration towards the Emacs editor\n(gnu-emacs in general) which they use to write their programs. The\neditor interfaces well with the language since it is capable of syntax\ncoloring OCaml source code (rendering different categories of words in\ncolor, coloring keywords for example).\u003c/p\u003e\n\u003cp\u003eThe following two commands are considered indispensable:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCTRL-C-CTRL-C\u003c/code\u003e or \u003ccode\u003eMeta-X compile\u003c/code\u003e: launches re-compilation from\nwithin the editor (using the \u003ccode\u003emake\u003c/code\u003e command).\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCTRL-X-`\u003c/code\u003e: puts the cursor in the file and at the exact place\nwhere the OCaml compiler has signaled an error.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDevelopers describe thus how to use these features: \u003ccode\u003eCTRL-C-CTRL-C\u003c/code\u003e\ncombination recompiles the whole application; in case of errors, a\nsuccession of \u003ccode\u003eCTRL-X-`\u003c/code\u003e commands permits correction of all the\nerrors signaled; the cycle begins again with a new re-compilation\nlaunched by \u003ccode\u003eCTRL-C-CTRL-C\u003c/code\u003e.\u003c/p\u003e\n\u003ch4 id=\"other-emacs-tricks\"\u003eOther emacs tricks\u003c/h4\u003e\n\u003cp\u003eThe \u003ccode\u003eESC-/\u003c/code\u003e command (dynamic-abbrev-expand) automatically completes the\nword in front of the cursor with one of the words present in one of the\nfiles being edited. Thus this lets you always choose meaningful\nidentifiers without the tedium of having to type extended names in your\nprograms: the \u003ccode\u003eESC-/\u003c/code\u003e easily completes the identifier after typing the\nfirst letters. In case it brings up the wrong completion, each\nsubsequent \u003ccode\u003eESC-/\u003c/code\u003e proposes an alternate completion.\u003c/p\u003e\n\u003cp\u003eUnder Unix, the \u003ccode\u003eCTRL-C-CTRL-C\u003c/code\u003e or \u003ccode\u003eMeta-X     compile\u003c/code\u003e combination,\nfollowed by \u003ccode\u003eCTRL-X-`\u003c/code\u003e is also used to find all occurrences of a\ncertain string in a OCaml program. Instead of launching \u003ccode\u003emake\u003c/code\u003e to\nrecompile, you launch the \u003ccode\u003egrep\u003c/code\u003e command; then all the error\nmessages from \u003ccode\u003egrep\u003c/code\u003e are compatible with the \u003ccode\u003eCTRL-X-`\u003c/code\u003e usage\nwhich automatically takes you to the file and the place where the string\nis found.\u003c/p\u003e\n\u003ch3 id=\"how-to-edit-with-the-interactive-system\"\u003eHow to edit with the interactive system\u003c/h3\u003e\n\u003cp\u003eUnder Unix: use the line editor \u003ccode\u003eledit\u003c/code\u003e which offers great editing\ncapabilities  la emacs (including \u003ccode\u003eESC-/\u003c/code\u003e!), as well as a history\nmechanism which lets you retrieve previously typed commands and even\nretrieve commands from one session in another. \u003ccode\u003eledit\u003c/code\u003e is written in\nOCaml and can be freely down-loaded\n\u003ca href=\"ftp://ftp.inria.fr/INRIA/Projects/cristal/caml-light/bazar-ocaml/ledit.tar.gz\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"how-to-compile\"\u003eHow to compile\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003emake\u003c/code\u003e utility is indispensable for managing the compilation and\nre-compilation of programs. Sample \u003ccode\u003emake\u003c/code\u003e files can be found on \u003ca href=\"https://caml.inria.fr//cgi-bin/hump.en.cgi\"\u003eThe\nHump\u003c/a\u003e. You can also consult\nthe \u003ccode\u003eMakefiles\u003c/code\u003e for the OCaml compilers.\u003c/p\u003e\n\u003ch3 id=\"how-to-develop-as-a-team-version-control\"\u003eHow to develop as a team: version control\u003c/h3\u003e\n\u003cp\u003eUsers of the \u003ca href=\"https://git-scm.com/\"\u003eGit\u003c/a\u003e software version control system\nnever run out of good things to say about the productivity gains it\nbrings. This system supports managing development by a team of\nprogrammers while imposing consistency among them, and also maintains a\nlog of changes made to the software.\u003cbr /\u003e\nGit also supports simultaneous development by several teams, possibly\ndispersed among several sites linked on the Net.\u003c/p\u003e\n\u003cp\u003eAn anonymous Git read-only mirror \u003ca href=\"https://github.com/ocaml/ocaml\"\u003econtains the working sources of the\nOCaml compilers\u003c/a\u003e, and the sources of\nother software related to OCaml.\u003c/p\u003e\n\u003ch2 id=\"notes\"\u003eNotes\u003c/h2\u003e\n\u003ch3 id=\"imperative-and-functional-versions-of-listlength\"\u003eImperative and functional versions of \u003ccode\u003elist_length\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eThe two versions of \u003ccode\u003elist_length\u003c/code\u003e are not completely equivalent in term\nof complexity, since the imperative version uses a constant amount of\nstack room to execute, whereas the functional version needs to store\nreturn addresses of suspended recursive calls (whose maximum number is\nequal to the length of the list argument). If you want to retrieve a\nconstant space requirement to run the functional program you just have\nto write a function that is recursive in its tail (or \u003cem\u003etail-rec\u003c/em\u003e), that\nis a function that just ends by a recursive call (which is not the case\nhere since a call to \u003ccode\u003e+\u003c/code\u003e has to be perform after the recursive call has\nreturned). Just use an accumulator for intermediate results, as in:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet list_length l =\n  let rec loop accu = function\n    | [] -\u0026gt; accu\n    | _ :: l -\u0026gt; loop (accu + 1) l in\n  loop 0 l\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis way, you get a program that has the same computational properties\nas the imperative program with the additional clarity and natural\nlook of an algorithm that performs pattern matching and recursive\ncalls to handle an argument that belongs to a recursive sum data type.\u003c/p\u003e\n"},{"title":"Compiling OCaml Projects","slug":"compiling-ocaml-projects","description":"An introduction to the OCaml compiler tools for building OCaml projects as well as the most common build tools\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"getting-started","tl":0},"users":{"hd":"Intermediate","tl":0},"body_md":"\nThis tutorial explains how to compile your OCaml programs into executable form.\nIt addresses, in turn:\n\n1. The compilation commands `ocamlc` and `ocamlopt` provided with OCaml. It is\n   useful to learn these commands to understand OCaml's compilation model.\n\n1. The `ocamlfind` front-end to the compiler, which saves you from worrying\n   about where libraries have been installed on your particular system. \n\n1. Automatic build systems for OCaml, such as `dune`, which release us from\n   details of compiler command invocation, so we never touch `ocamlc`,\n   `ocamlopt`, or even `ocamlfind`.\n\nIn our [up and running tutorial](up_and_running.html) we jumped straight to using\nthe automated build system `dune`. Now we shall look under the hood.\n\n## Compilation basics\n\nIn this section, we will first see how to compile a simple program using\nonly `ocamlc` or `ocamlopt`. Then we will see how to use libraries and how\nto take advantage of the\n[findlib](https://projects.camlcity.org/projects/findlib.html)\nsystem, which provides the `ocamlfind` command.\n\n### The ocamlc and ocamlopt compilers\n\nOCaml comes with two compilers: `ocamlc` is the bytecode compiler, and\n`ocamlopt` is the native code compiler. If you don't know which one to use, use\n`ocamlopt` since it provides executables that are faster than bytecode.\n\nLet's assume that our program `program` has two source files,\n`module1.ml` and `module2.ml`. We will compile them to native code,\nusing `ocamlopt`. For now, we also assume that they do not use any other\nlibrary than the standard library, which is automatically loaded. You\ncan compile the program in one single step:\n\n```shell\nocamlopt -o program module1.ml module2.ml\n```\n\nThe compiler produces an executable named `program` or `program.exe`. The order\nof the source files matters, and so `module1.ml` cannot depend upon things that\nare defined in `module2.ml`.\n\nThe OCaml distribution is shipped with the standard library, plus several other\nlibraries. There are also a large number of third-party libraries, for a wide\nrange of applications, from networking to graphics. You should understand the\nfollowing:\n\n1. The OCaml compilers know where the standard library is and use it\n   systematically (try: `ocamlc -where`). You don't have to worry much about\n   it.\n\n1. The other libraries that ship with the OCaml distribution (str, unix, etc.)\n   are installed in the same directory as the standard library.\n\n1. Third-party libraries may be installed in various places, and even a given\n   library can be installed in different places from one system to another.\n\nIf your program uses the unix library in addition to the standard library, for\nexample, the command line would be:\n\n```shell\nocamlopt -o program unix.cmxa module1.ml module2.ml\n```\n\nNote that `.cmxa` is the extension of native code libraries, while `.cma` is\nthe extension of bytecode libraries. The file `unix.cmxa` is found because it\nis always installed at the same place as the standard library, and this\ndirectory is in the library search path.\n\nIf your program depends upon third-party libraries, you must pass them on the\ncommand line. You must also indicate the libraries on which these libraries\ndepend. You must also pass the -I option to `ocamlopt` for each directory where\nthey may be found. This becomes complicated, and this information is\ninstallation dependent. So we will use `ocamlfind` instead, which does these\njobs for us.\n\n###  Using the ocamlfind front-end\n\nThe `ocamlfind` front-end is often used for compiling programs that use\nthird-party OCaml libraries. Library authors themselves make their library\ninstallable with `ocamlfind` as well. You can install `ocamlfind` using the\nopam package manager, by typing `opam install ocamlfind`.\n\nLet's assume that all the libraries you want to use have been installed\nproperly with ocamlfind. You can see which libraries are available in your\nsystem by typing:\n\n```shell\nocamlfind list\n```\n\nThis shows the list of package names, with their versions. Note that most\nopam packages install software using ocamlfind, so your list of ocamlfind\nlibraries will be somewhat similar to your list of installed opam packages\nobtained by `opam list`.\n\nThe command for compiling our program using package `pkg` will be:\n\n```shell\nocamlfind ocamlopt -o program -linkpkg -package pkg module1.ml module2.ml\n```\n\nMultiple packages may be specified using commas e.g `pkg1,pkg2`. Ocamlfind\nknows how to find any files `ocamlopt` may need from the package, for example\n`.cmxa` implementation files or `.cmi` interface files, because they have been\npackaged together and installed at a known location by ocamlfind. We need only\nthe name `pkg` to refer to them all - ocamlfind does the rest.\n\nNote that you can compile the files separately. This is useful if\nyou want to recompile only some parts of the programs. Here are the\nequivalent commands that perform a separate compilation of the source\nfiles and link them together in a final step:\n\n```shell\nocamlfind ocamlopt -c -package pkg module1.ml\nocamlfind ocamlopt -c -package pkg module2.ml\nocamlfind ocamlopt -o program -linkpkg -package pkg module1.cmx module2.cmx\n```\n\nSeparate compilation (one command for `module1.ml`, another for `module2.ml`\nand another to link the final output) is usually not performed manually but\nonly when using an automated build system that will take care of recompiling\nonly what it necessary.\n\n## Interlude: making a custom toplevel\n\nOCaml provides another tool `ocamlmktop` to make an interactive toplevel with\nlibraries accessible. For example:\n\n```shell\nocamlmktop -o toplevel unix.cma module1.ml module2.ml\n```\n\nWe run `toplevel` and get an OCaml toplevel with modules `Unix`, `Module1`, and\n`Module2` all available, allowing us to experiment interactively with our\nprogram.\n\nOCamlfind also supports `ocamlmktop`:\n\n```shell\nocamlfind ocamlmktop -o toplevel unix.cma -package pkg module1.ml module2.ml\n```\n\n## Dune: an automated build system\n\nThe most popular modern system for building OCaml projects is\n[dune](https://dune.readthedocs.io/en/stable/) which may be installed with\n`opam install dune`. It allows one to build OCaml projects from a simple\ndescription of their elements. For example, the dune file for our project might\nlook like this:\n\n```scheme\n;; our example project\n(executable\n  (name program)\n  (libraries unix pkg))\n```\n\nThe dune [quick-start\nguide](https://dune.readthedocs.io/en/latest/quick-start.html) shows you how to\nwrite such description files for more complicated situations, and how to\nstructure, build, and run dune projects. \n\n## Other build systems\n\n- [OMake](https://github.com/ocaml-omake/omake) Another OCaml build system.\n- [GNU make](https://www.gnu.org/software/make/) GNU make can build anything, including OCaml. May be used in conjunction with [OCamlmakefile](https://github.com/mmottl/ocaml-makefile)\n- [Oasis](https://github.com/ocaml/oasis) Generates a configure, build, and install system from a specification.\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#compilation-basics\"\u003eCompilation basics\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#interlude-making-a-custom-toplevel\"\u003eInterlude: making a custom toplevel\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#dune-an-automated-build-system\"\u003eDune: an automated build system\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#other-build-systems\"\u003eOther build systems\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eThis tutorial explains how to compile your OCaml programs into executable form.\nIt addresses, in turn:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eThe compilation commands \u003ccode\u003eocamlc\u003c/code\u003e and \u003ccode\u003eocamlopt\u003c/code\u003e provided with OCaml. It is\nuseful to learn these commands to understand OCaml's compilation model.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003eocamlfind\u003c/code\u003e front-end to the compiler, which saves you from worrying\nabout where libraries have been installed on your particular system.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAutomatic build systems for OCaml, such as \u003ccode\u003edune\u003c/code\u003e, which release us from\ndetails of compiler command invocation, so we never touch \u003ccode\u003eocamlc\u003c/code\u003e,\n\u003ccode\u003eocamlopt\u003c/code\u003e, or even \u003ccode\u003eocamlfind\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIn our \u003ca href=\"up_and_running.html\"\u003eup and running tutorial\u003c/a\u003e we jumped straight to using\nthe automated build system \u003ccode\u003edune\u003c/code\u003e. Now we shall look under the hood.\u003c/p\u003e\n\u003ch2 id=\"compilation-basics\"\u003eCompilation basics\u003c/h2\u003e\n\u003cp\u003eIn this section, we will first see how to compile a simple program using\nonly \u003ccode\u003eocamlc\u003c/code\u003e or \u003ccode\u003eocamlopt\u003c/code\u003e. Then we will see how to use libraries and how\nto take advantage of the\n\u003ca href=\"https://projects.camlcity.org/projects/findlib.html\"\u003efindlib\u003c/a\u003e\nsystem, which provides the \u003ccode\u003eocamlfind\u003c/code\u003e command.\u003c/p\u003e\n\u003ch3 id=\"the-ocamlc-and-ocamlopt-compilers\"\u003eThe ocamlc and ocamlopt compilers\u003c/h3\u003e\n\u003cp\u003eOCaml comes with two compilers: \u003ccode\u003eocamlc\u003c/code\u003e is the bytecode compiler, and\n\u003ccode\u003eocamlopt\u003c/code\u003e is the native code compiler. If you don't know which one to use, use\n\u003ccode\u003eocamlopt\u003c/code\u003e since it provides executables that are faster than bytecode.\u003c/p\u003e\n\u003cp\u003eLet's assume that our program \u003ccode\u003eprogram\u003c/code\u003e has two source files,\n\u003ccode\u003emodule1.ml\u003c/code\u003e and \u003ccode\u003emodule2.ml\u003c/code\u003e. We will compile them to native code,\nusing \u003ccode\u003eocamlopt\u003c/code\u003e. For now, we also assume that they do not use any other\nlibrary than the standard library, which is automatically loaded. You\ncan compile the program in one single step:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eocamlopt -o program module1.ml module2.ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe compiler produces an executable named \u003ccode\u003eprogram\u003c/code\u003e or \u003ccode\u003eprogram.exe\u003c/code\u003e. The order\nof the source files matters, and so \u003ccode\u003emodule1.ml\u003c/code\u003e cannot depend upon things that\nare defined in \u003ccode\u003emodule2.ml\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe OCaml distribution is shipped with the standard library, plus several other\nlibraries. There are also a large number of third-party libraries, for a wide\nrange of applications, from networking to graphics. You should understand the\nfollowing:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eThe OCaml compilers know where the standard library is and use it\nsystematically (try: \u003ccode\u003eocamlc -where\u003c/code\u003e). You don't have to worry much about\nit.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe other libraries that ship with the OCaml distribution (str, unix, etc.)\nare installed in the same directory as the standard library.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThird-party libraries may be installed in various places, and even a given\nlibrary can be installed in different places from one system to another.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIf your program uses the unix library in addition to the standard library, for\nexample, the command line would be:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eocamlopt -o program unix.cmxa module1.ml module2.ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that \u003ccode\u003e.cmxa\u003c/code\u003e is the extension of native code libraries, while \u003ccode\u003e.cma\u003c/code\u003e is\nthe extension of bytecode libraries. The file \u003ccode\u003eunix.cmxa\u003c/code\u003e is found because it\nis always installed at the same place as the standard library, and this\ndirectory is in the library search path.\u003c/p\u003e\n\u003cp\u003eIf your program depends upon third-party libraries, you must pass them on the\ncommand line. You must also indicate the libraries on which these libraries\ndepend. You must also pass the -I option to \u003ccode\u003eocamlopt\u003c/code\u003e for each directory where\nthey may be found. This becomes complicated, and this information is\ninstallation dependent. So we will use \u003ccode\u003eocamlfind\u003c/code\u003e instead, which does these\njobs for us.\u003c/p\u003e\n\u003ch3 id=\"using-the-ocamlfind-front-end\"\u003eUsing the ocamlfind front-end\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eocamlfind\u003c/code\u003e front-end is often used for compiling programs that use\nthird-party OCaml libraries. Library authors themselves make their library\ninstallable with \u003ccode\u003eocamlfind\u003c/code\u003e as well. You can install \u003ccode\u003eocamlfind\u003c/code\u003e using the\nopam package manager, by typing \u003ccode\u003eopam install ocamlfind\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLet's assume that all the libraries you want to use have been installed\nproperly with ocamlfind. You can see which libraries are available in your\nsystem by typing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eocamlfind list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis shows the list of package names, with their versions. Note that most\nopam packages install software using ocamlfind, so your list of ocamlfind\nlibraries will be somewhat similar to your list of installed opam packages\nobtained by \u003ccode\u003eopam list\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe command for compiling our program using package \u003ccode\u003epkg\u003c/code\u003e will be:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eocamlfind ocamlopt -o program -linkpkg -package pkg module1.ml module2.ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMultiple packages may be specified using commas e.g \u003ccode\u003epkg1,pkg2\u003c/code\u003e. Ocamlfind\nknows how to find any files \u003ccode\u003eocamlopt\u003c/code\u003e may need from the package, for example\n\u003ccode\u003e.cmxa\u003c/code\u003e implementation files or \u003ccode\u003e.cmi\u003c/code\u003e interface files, because they have been\npackaged together and installed at a known location by ocamlfind. We need only\nthe name \u003ccode\u003epkg\u003c/code\u003e to refer to them all - ocamlfind does the rest.\u003c/p\u003e\n\u003cp\u003eNote that you can compile the files separately. This is useful if\nyou want to recompile only some parts of the programs. Here are the\nequivalent commands that perform a separate compilation of the source\nfiles and link them together in a final step:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eocamlfind ocamlopt -c -package pkg module1.ml\nocamlfind ocamlopt -c -package pkg module2.ml\nocamlfind ocamlopt -o program -linkpkg -package pkg module1.cmx module2.cmx\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSeparate compilation (one command for \u003ccode\u003emodule1.ml\u003c/code\u003e, another for \u003ccode\u003emodule2.ml\u003c/code\u003e\nand another to link the final output) is usually not performed manually but\nonly when using an automated build system that will take care of recompiling\nonly what it necessary.\u003c/p\u003e\n\u003ch2 id=\"interlude-making-a-custom-toplevel\"\u003eInterlude: making a custom toplevel\u003c/h2\u003e\n\u003cp\u003eOCaml provides another tool \u003ccode\u003eocamlmktop\u003c/code\u003e to make an interactive toplevel with\nlibraries accessible. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eocamlmktop -o toplevel unix.cma module1.ml module2.ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe run \u003ccode\u003etoplevel\u003c/code\u003e and get an OCaml toplevel with modules \u003ccode\u003eUnix\u003c/code\u003e, \u003ccode\u003eModule1\u003c/code\u003e, and\n\u003ccode\u003eModule2\u003c/code\u003e all available, allowing us to experiment interactively with our\nprogram.\u003c/p\u003e\n\u003cp\u003eOCamlfind also supports \u003ccode\u003eocamlmktop\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eocamlfind ocamlmktop -o toplevel unix.cma -package pkg module1.ml module2.ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"dune-an-automated-build-system\"\u003eDune: an automated build system\u003c/h2\u003e\n\u003cp\u003eThe most popular modern system for building OCaml projects is\n\u003ca href=\"https://dune.readthedocs.io/en/stable/\"\u003edune\u003c/a\u003e which may be installed with\n\u003ccode\u003eopam install dune\u003c/code\u003e. It allows one to build OCaml projects from a simple\ndescription of their elements. For example, the dune file for our project might\nlook like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-scheme\"\u003e;; our example project\n(executable\n  (name program)\n  (libraries unix pkg))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe dune \u003ca href=\"https://dune.readthedocs.io/en/latest/quick-start.html\"\u003equick-start\nguide\u003c/a\u003e shows you how to\nwrite such description files for more complicated situations, and how to\nstructure, build, and run dune projects.\u003c/p\u003e\n\u003ch2 id=\"other-build-systems\"\u003eOther build systems\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ocaml-omake/omake\"\u003eOMake\u003c/a\u003e Another OCaml build system.\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.gnu.org/software/make/\"\u003eGNU make\u003c/a\u003e GNU make can build anything, including OCaml. May be used in conjunction with \u003ca href=\"https://github.com/mmottl/ocaml-makefile\"\u003eOCamlmakefile\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ocaml/oasis\"\u003eOasis\u003c/a\u003e Generates a configure, build, and install system from a specification.\n\u003c/li\u003e\n\u003c/ul\u003e\n"},{"title":"Data Types and Matching","slug":"data-types-and-matching","description":"Learn to build custom types and write function to process this data\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"language","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\nIn this tutorial we learn how to build our own types in OCaml, and how to write\nfunctions which process this new data.\n\n## Built-in compound types\n\nWe have already seen simple data types such as `int`, `float`, `string`, and\n`bool`.  Let's recap the built-in compound data types we can use in OCaml to\ncombine such values. First, we have lists which are ordered collections of any\nnumber of elements of like type:\n\n```ocaml\n# []\n- : 'a list = []\n# [1; 2; 3]\n- : int list = [1; 2; 3]\n# [[1; 2]; [3; 4]; [5; 6]]\n- : int list list = [[1; 2]; [3; 4]; [5; 6]]\n# [false; true; false]\n- : bool list = [false; true; false]\n```\n\nNext, we have tuples, which collect a fixed number of elements together:\n\n```ocaml\n# (5.0, 6.5)\n- : float * float = (5., 6.5)\n# (true, 0.0, 0.45, 0.73, \"french blue\")\n- : bool * float * float * float * string =\n(true, 0., 0.45, 0.73, \"french blue\")\n```\n\nWe have records, which are like labeled tuples. They are defined by writing a\ntype definition giving a name for the record, and names for each of its fields,\nand their types:\n\n```ocaml\n# type point = {x : float; y : float}\ntype point = { x : float; y : float; }\n# let a = {x = 5.0; y = 6.5}\nval a : point = {x = 5.; y = 6.5}\n# type colour = {websafe : bool; r : float; g : float; b : float; name : string}\ntype colour = {\n  websafe : bool;\n  r : float;\n  g : float;\n  b : float;\n  name : string;\n}\n# let b = {websafe = true; r = 0.0; g = 0.45; b = 0.73; name = \"french blue\"}\nval b : colour =\n  {websafe = true; r = 0.; g = 0.45; b = 0.73; name = \"french blue\"}\n```\n\nA record must contain all fields:\n\n```ocaml\n# let c = {name = \"puce\"}\nLine 1, characters 9-24:\nError: Some record fields are undefined: websafe r g b\n```\n\nRecords may be mutable:\n\n```ocaml\n# type person =\n  {first_name : string;\n   surname : string;\n   mutable age : int}\ntype person = { first_name : string; surname : string; mutable age : int; }\n# let birthday p =\n  p.age \u003c- p.age + 1\nval birthday : person -\u003e unit = \u003cfun\u003e\n```\n\nAnother mutable compound data type is the fixed-length array which, just as a\nlist, must contain elements of like type. However, its elements may be accessed\nin constant time:\n\n```ocaml\n# let arr = [|1; 2; 3|]\nval arr : int array = [|1; 2; 3|]\n# arr.(0)\n- : int = 1\n# arr.(0) \u003c- 0\n- : unit = ()\n# arr\n- : int array = [|0; 2; 3|]\n```\n\nIn this tutorial, we will define our own compound data types, using the `type`\nkeyword, and some of these built-in structures as building blocks.\n\n## A simple custom type\n\nWe can define a new data type `colour` which can take one of four values.\n\n```ocaml env=colours\ntype colour = Red | Green | Blue | Yellow\n```\n\nOur new type is called `colour`, and has four *constructors* `Red`, `Green`,\n`Blue` and `Yellow`. The name of the type must begin with a lower case letter,\nand the names of the constructors with upper case letters. We can use our new\ntype anywhere a built-in type could be used:\n\n```ocaml env=colours\n# let additive_primaries = (Red, Green, Blue)\nval additive_primaries : colour * colour * colour = (Red, Green, Blue)\n# let pattern = [(1, Red); (3, Green); (1, Red); (2, Green)]\nval pattern : (int * colour) list =\n  [(1, Red); (3, Green); (1, Red); (2, Green)]\n```\n\nNotice the types inferred by OCaml for these expressions. We can pattern-match\non our new type, just as with any built-in type:\n\n```ocaml env=colours\n# let example c =\n  match c with\n  | Red -\u003e \"rose\"\n  | Green -\u003e \"grass\"\n  | Blue -\u003e \"sky\"\n  | Yellow -\u003e \"banana\"\nval example : colour -\u003e string = \u003cfun\u003e\n```\n\nNotice the type of the function includes the name of our new type `colour`. We\ncan make the function shorter and elide its parameter `c` by using the\nalternative `function` keyword which allows direct matching:\n\n```ocaml env=colours\n# let example = function\n  | Red -\u003e \"rose\"\n  | Green -\u003e \"grass\"\n  | Blue -\u003e \"sky\"\n  | Yellow -\u003e \"banana\"\nval example : colour -\u003e string = \u003cfun\u003e\n```\n\nWe can match on more than one case at a time too:\n\n```ocaml env=colours\n# let rec is_primary = function\n  | Red | Green | Blue -\u003e true\n  | _ -\u003e false\nval is_primary : colour -\u003e bool = \u003cfun\u003e\n```\n\n## Constructors with data\n\nEach constructor in a data type can carry additional information with it. Let's\nextend our `colour` type to allow arbitrary RGB triples, each element begin a\nnumber from 0 (no colour) to 1 (full colour): \n\n```ocaml env=colours\n# type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\ntype colour = Red | Green | Blue | Yellow | RGB of float * float * float\n\n# [Red; Blue; RGB (0.5, 0.65, 0.12)]\n- : colour list = [Red; Blue; RGB (0.5, 0.65, 0.12)]\n```\n\nTypes, just like functions, may be recursively-defined. We extend our data type\nto allow mixing of colours:\n\n```ocaml env=colours\n# type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\n  | Mix of float * colour * colour\ntype colour =\n    Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\n  | Mix of float * colour * colour\n# Mix (0.5, Red, Mix (0.5, Blue, Green))\n- : colour = Mix (0.5, Red, Mix (0.5, Blue, Green))\n```\n\nHere is a function over our new `colour` data type:\n\n```ocaml env=colours\n# let rec rgb_of_colour = function\n  | Red -\u003e (1.0, 0.0, 0.0)\n  | Green -\u003e (0.0, 1.0, 0.0)\n  | Blue -\u003e (0.0, 0.0, 1.0)\n  | Yellow -\u003e (1.0, 1.0, 0.0)\n  | RGB (r, g, b) -\u003e (r, g, b)\n  | Mix (p, a, b) -\u003e\n      let (r1, g1, b1) = rgb_of_colour a in\n      let (r2, g2, b2) = rgb_of_colour b in\n      let mix x y = x *. p +. y *. (1.0 -. p) in\n        (mix r1 r2, mix g1 g2, mix b1 b2)\nval rgb_of_colour : colour -\u003e float * float * float = \u003cfun\u003e\n```\n\nWe can use records directly in the data type instead to label our components:\n\n```ocaml env=colours\n# type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of {r : float; g : float; b : float}\n  | Mix of {proportion : float; c1 : colour; c2 : colour}\ntype colour =\n    Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of { r : float; g : float; b : float; }\n  | Mix of { proportion : float; c1 : colour; c2 : colour; }\n```\n\n## Example: trees\n\nData types may be polymorphic as well as recursive. Here is an OCaml data type\nfor a binary tree carrying any kind of data:\n\n```ocaml env=trees\n# type 'a tree =\n  | Leaf\n  | Node of 'a tree * 'a * 'a tree\ntype 'a tree = Leaf | Node of 'a tree * 'a * 'a tree\n# let t =\n    Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Leaf))\nval t : int tree =\n  Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Leaf))\n```\n\nNotice that we give the type parameter `'a` before the type name (if there is\nmore than one, we write `('a, 'b)` etc).  A `Leaf` holds no information,\njust like an empty list. A `Node` holds a left tree, a value of type `'a`\nand a right tree. In our example, we built an integer tree, but any type can be\nused. Now we can write recursive and polymorphic functions over these trees, by\npattern matching on our new constructors:\n\n```ocaml env=trees\n# let rec total = function\n  | Leaf -\u003e 0\n  | Node (l, x, r) -\u003e total l + x + total r\nval total : int tree -\u003e int = \u003cfun\u003e\n# let rec flip = function\n  | Leaf -\u003e Leaf\n  | Node (l, x, r) -\u003e Node (flip r, x, flip l)\nval flip : 'a tree -\u003e 'a tree = \u003cfun\u003e\n```\n\nHere, `flip` is polymorphic while `total` operates only on trees of type `int\ntree`. Let's try our new functions out:\n\n```ocaml env=trees\n# let all = total t\nval all : int = 10\n# let flipped = flip t\nval flipped : int tree =\n  Node (Node (Leaf, 4, Node (Leaf, 3, Leaf)), 2, Node (Leaf, 1, Leaf))\n# t = flip flipped\n- : bool = true\n```\n\nInstead of integers, we could build a tree of key-value pairs. Then, if we\ninsist that the keys are unique and that a smaller key is always left of a\nlarger key, we have a data structure for dictionaries which performs better\nthan a simple list of pairs. It is known as a *binary search tree*:\n\n```ocaml env=trees\n# let rec insert (k, v) = function\n  | Leaf -\u003e Node (Leaf, (k, v), Leaf)\n  | Node (l, (k', v'), r) -\u003e\n      if k \u003c k' then Node (insert (k, v) l, (k', v'), r) \n      else if k \u003e k' then Node (l, (k', v'), insert (k, v) r)\n      else Node (l, (k, v), r)\nval insert : 'a * 'b -\u003e ('a * 'b) tree -\u003e ('a * 'b) tree = \u003cfun\u003e\n```\n\nSimilar functions can be written to look up values in a dictionary, to convert\na list of pairs to or from a tree dictionary and so on.\n\n## Example: mathematical expressions\n\nWe wish to represent simple mathematical expressions like `n * (x + y)` and\nmultiply them out symbolically to get `n * x + n * y`.\n\nLet's define a type for these expressions:\n\n```ocaml env=expr\ntype expr =\n  | Plus of expr * expr        (* a + b *)\n  | Minus of expr * expr       (* a - b *)\n  | Times of expr * expr       (* a * b *)\n  | Divide of expr * expr      (* a / b *)\n  | Var of string              (* \"x\", \"y\", etc. *)\n```\n\nThe expression `n * (x + y)` would be written:\n\n```ocaml env=expr\n# Times (Var \"n\", Plus (Var \"x\", Var \"y\"))\n- : expr = Times (Var \"n\", Plus (Var \"x\", Var \"y\"))\n```\n\nLet's write a function which prints out `Times (Var \"n\", Plus (Var \"x\", Var\n\"y\"))` as something more like `n * (x + y)`.\n\n```ocaml env=expr\n# let rec to_string e =\n  match e with\n  | Plus (left, right) -\u003e\n     \"(\" ^ to_string left ^ \" + \" ^ to_string right ^ \")\"\n  | Minus (left, right) -\u003e\n     \"(\" ^ to_string left ^ \" - \" ^ to_string right ^ \")\"\n  | Times (left, right) -\u003e\n   \"(\" ^ to_string left ^ \" * \" ^ to_string right ^ \")\"\n  | Divide (left, right) -\u003e\n   \"(\" ^ to_string left ^ \" / \" ^ to_string right ^ \")\"\n  | Var v -\u003e v\nval to_string : expr -\u003e string = \u003cfun\u003e\n# let print_expr e =\n  print_endline (to_string e)\nval print_expr : expr -\u003e unit = \u003cfun\u003e\n```\n\n(The `^` operator concatenates strings). We separate the function into two so\nthat our `to_string` function is usable in other contexts. Here's the\n`print_expr` function in action:\n\n```ocaml env=expr\n# print_expr (Times (Var \"n\", Plus (Var \"x\", Var \"y\")))\n(n * (x + y))\n- : unit = ()\n```\n\nWe can write a function to multiply out expressions of the form `n * (x + y)`\nor `(x + y) * n` and for this we will use a nested pattern:\n\n```ocaml env=expr\n# let rec multiply_out e =\n  match e with\n  | Times (e1, Plus (e2, e3)) -\u003e\n     Plus (Times (multiply_out e1, multiply_out e2),\n           Times (multiply_out e1, multiply_out e3))\n  | Times (Plus (e1, e2), e3) -\u003e\n     Plus (Times (multiply_out e1, multiply_out e3),\n           Times (multiply_out e2, multiply_out e3))\n  | Plus (left, right) -\u003e\n     Plus (multiply_out left, multiply_out right)\n  | Minus (left, right) -\u003e\n     Minus (multiply_out left, multiply_out right)\n  | Times (left, right) -\u003e\n     Times (multiply_out left, multiply_out right)\n  | Divide (left, right) -\u003e\n     Divide (multiply_out left, multiply_out right)\n  | Var v -\u003e Var v\nval multiply_out : expr -\u003e expr = \u003cfun\u003e\n```\n\nHere it is in action:\n\n```ocaml env=expr\n# print_expr (multiply_out (Times (Var \"n\", Plus (Var \"x\", Var \"y\"))))\n((n * x) + (n * y))\n- : unit = ()\n```\n\nHow does the `multiply_out` function work? The key is in the first two\npatterns. The first pattern is `Times (e1, Plus (e2, e3))` which matches\nexpressions of the form `e1 * (e2 + e3)`. Now look at the right hand side of\nthis first pattern match, and convince yourself that it is the equivalent of\n`(e1 * e2) + (e1 * e3)`. The second pattern does the same thing, except for\nexpressions of the form `(e1 + e2) * e3`.\n\nThe remaining patterns don't change the form of the expression, but they\ncrucially *do* call the `multiply_out` function recursively on their\nsubexpressions. This ensures that all subexpressions within the expression get\nmultiplied out too (if you only wanted to multiply out the very top level of an\nexpression, then you could replace all the remaining patterns with a simple `e\n-\u003e e` rule).\n\nCan we do the reverse (i.e. factorizing out common subexpressions)? We can!\n(But it's a bit more complicated). The following version only works for the top\nlevel expression. You could certainly extend it to cope with all levels of an\nexpression and more complex cases:\n\n```ocaml env=expr\n# let factorize e =\n  match e with\n  | Plus (Times (e1, e2), Times (e3, e4)) when e1 = e3 -\u003e\n     Times (e1, Plus (e2, e4))\n  | Plus (Times (e1, e2), Times (e3, e4)) when e2 = e4 -\u003e\n     Times (Plus (e1, e3), e4)\n  | e -\u003e e\nval factorize : expr -\u003e expr = \u003cfun\u003e\n# factorize (Plus (Times (Var \"n\", Var \"x\"),\n                   Times (Var \"n\", Var \"y\")))\n- : expr = Times (Var \"n\", Plus (Var \"x\", Var \"y\"))\n```\n\nThe factorize function above introduces another couple of features. You can add\nwhat are known as *guards* to each pattern match. A guard is the conditional\nwhich follows the `when`, and it means that the pattern match only happens if\nthe pattern matches *and* the condition in the `when`-clause is satisfied.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmatch value with\n| pattern [ when condition ] -\u003e result\n| pattern [ when condition ] -\u003e result\n  ...\n```\n\nThe second feature is the `=` operator which tests for \"structural equality\"\nbetween two expressions. That means it goes recursively into each expression\nchecking they're exactly the same at all levels down.\n\nAnother feature which is useful when we build more complicated nested patterns\nis the `as` keyword, which can be used to name part of an expression. For\nexample:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nName (\"/DeviceGray\" | \"/DeviceRGB\" | \"/DeviceCMYK\") as n -\u003e n\n\nNode (l, ((k, _) as pair), r) when k = k' -\u003e Some pair\n```\n\n## Mutually recursive data types\n\nData types may be mutually-recursive when declared with `and`:\n\n```ocaml\ntype t = A | B of t' and t' = C | D of t\n```\n\nOne common use for mutually-recursive data types is to *decorate* a tree, by\nadding information to each node using mutually-recursive types, one of which is\na tuple or record. For example:\n\n```ocaml\ntype t' = Int of int | Add of t * t\nand t = {annotation : string; data : t'}\n```\n\nValues of such mutually-recursive data type are manipulated by accompanying\nmutually-recursive functions:\n\n```ocaml\n# let rec sum_t' = function\n  | Int i -\u003e i\n  | Add (i, i') -\u003e sum_t i + sum_t i'\n  and sum_t {annotation; data} =\n    if annotation \u003c\u003e \"\" then Printf.printf \"Touching %s\\n\" annotation;\n    sum_t' data\nval sum_t' : t' -\u003e int = \u003cfun\u003e\nval sum_t : t -\u003e int = \u003cfun\u003e\n```\n\n## A note on tupled constructors\n\nThere is a difference between `RGB of float * float * float` and `RGB of (float\n* float * float)`. The first is a constructor with three pieces of data\nassociated with it, the second is a constructor with one tuple associated with\nit. There are two ways this matters: the memory layout differs between the two\n(a tuple is an extra indirection), and the ability to create or match using a\ntuple:\n\n```ocaml\n# type t = T of int * int\ntype t = T of int * int\n\n# type t2 = T2 of (int * int)\ntype t2 = T2 of (int * int)\n\n# let pair = (1, 2)\nval pair : int * int = (1, 2)\n\n# T2 pair\n- : t2 = T2 (1, 2)\n\n# T pair\nLine 1, characters 1-7:\nError: The constructor T expects 2 argument(s),\n       but is applied here to 1 argument(s)\n\n# match T2 (1, 2) with T2 x -\u003e fst x\n- : int = 1\n\n# match T (1, 2) with T x -\u003e fst x\nLine 1, characters 21-24:\nError: The constructor T expects 2 argument(s),\n       but is applied here to 1 argument(s)\n```\n\nNote, however, that OCaml allows us to use the always-matching `_` in either\nversion:\n\n```ocaml\n# match T2 (1, 2) with T2 _ -\u003e 0\n- : int = 0\n\n# match T (1, 2) with T _ -\u003e 0\n- : int = 0\n```\n\n## Types and modules\n\nOften, a module will provide a single type and operations on that type. For\nexample, a module for a file format like PNG might have the following `png.mli`\ninterface:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\ntype t\n\nval of_file : filename -\u003e t\n\nval to_file : t -\u003e filename -\u003e unit\n\nval flip_vertical : t -\u003e t\n\nval flip_horizontal : t -\u003e t\n\nval rotate : float -\u003e t -\u003e t\n```\n\nTraditionally, we name the type `t`. In the program using this library, it\nwould then be `Png.t` which is shorter, reads better than `Png.png`, and avoids\nconfusion if the library also defines other types.\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#built-in-compound-types\"\u003eBuilt-in compound types\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#a-simple-custom-type\"\u003eA simple custom type\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#constructors-with-data\"\u003eConstructors with data\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#example-trees\"\u003eExample: trees\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#example-mathematical-expressions\"\u003eExample: mathematical expressions\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mutually-recursive-data-types\"\u003eMutually recursive data types\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#a-note-on-tupled-constructors\"\u003eA note on tupled constructors\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#types-and-modules\"\u003eTypes and modules\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eIn this tutorial we learn how to build our own types in OCaml, and how to write\nfunctions which process this new data.\u003c/p\u003e\n\u003ch2 id=\"built-in-compound-types\"\u003eBuilt-in compound types\u003c/h2\u003e\n\u003cp\u003eWe have already seen simple data types such as \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003estring\u003c/code\u003e, and\n\u003ccode\u003ebool\u003c/code\u003e.  Let's recap the built-in compound data types we can use in OCaml to\ncombine such values. First, we have lists which are ordered collections of any\nnumber of elements of like type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# []\n- : 'a list = []\n# [1; 2; 3]\n- : int list = [1; 2; 3]\n# [[1; 2]; [3; 4]; [5; 6]]\n- : int list list = [[1; 2]; [3; 4]; [5; 6]]\n# [false; true; false]\n- : bool list = [false; true; false]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we have tuples, which collect a fixed number of elements together:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# (5.0, 6.5)\n- : float * float = (5., 6.5)\n# (true, 0.0, 0.45, 0.73, \u0026quot;french blue\u0026quot;)\n- : bool * float * float * float * string =\n(true, 0., 0.45, 0.73, \u0026quot;french blue\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe have records, which are like labeled tuples. They are defined by writing a\ntype definition giving a name for the record, and names for each of its fields,\nand their types:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type point = {x : float; y : float}\ntype point = { x : float; y : float; }\n# let a = {x = 5.0; y = 6.5}\nval a : point = {x = 5.; y = 6.5}\n# type colour = {websafe : bool; r : float; g : float; b : float; name : string}\ntype colour = {\n  websafe : bool;\n  r : float;\n  g : float;\n  b : float;\n  name : string;\n}\n# let b = {websafe = true; r = 0.0; g = 0.45; b = 0.73; name = \u0026quot;french blue\u0026quot;}\nval b : colour =\n  {websafe = true; r = 0.; g = 0.45; b = 0.73; name = \u0026quot;french blue\u0026quot;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA record must contain all fields:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let c = {name = \u0026quot;puce\u0026quot;}\nLine 1, characters 9-24:\nError: Some record fields are undefined: websafe r g b\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRecords may be mutable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type person =\n  {first_name : string;\n   surname : string;\n   mutable age : int}\ntype person = { first_name : string; surname : string; mutable age : int; }\n# let birthday p =\n  p.age \u0026lt;- p.age + 1\nval birthday : person -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnother mutable compound data type is the fixed-length array which, just as a\nlist, must contain elements of like type. However, its elements may be accessed\nin constant time:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let arr = [|1; 2; 3|]\nval arr : int array = [|1; 2; 3|]\n# arr.(0)\n- : int = 1\n# arr.(0) \u0026lt;- 0\n- : unit = ()\n# arr\n- : int array = [|0; 2; 3|]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this tutorial, we will define our own compound data types, using the \u003ccode\u003etype\u003c/code\u003e\nkeyword, and some of these built-in structures as building blocks.\u003c/p\u003e\n\u003ch2 id=\"a-simple-custom-type\"\u003eA simple custom type\u003c/h2\u003e\n\u003cp\u003eWe can define a new data type \u003ccode\u003ecolour\u003c/code\u003e which can take one of four values.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype colour = Red | Green | Blue | Yellow\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOur new type is called \u003ccode\u003ecolour\u003c/code\u003e, and has four \u003cem\u003econstructors\u003c/em\u003e \u003ccode\u003eRed\u003c/code\u003e, \u003ccode\u003eGreen\u003c/code\u003e,\n\u003ccode\u003eBlue\u003c/code\u003e and \u003ccode\u003eYellow\u003c/code\u003e. The name of the type must begin with a lower case letter,\nand the names of the constructors with upper case letters. We can use our new\ntype anywhere a built-in type could be used:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let additive_primaries = (Red, Green, Blue)\nval additive_primaries : colour * colour * colour = (Red, Green, Blue)\n# let pattern = [(1, Red); (3, Green); (1, Red); (2, Green)]\nval pattern : (int * colour) list =\n  [(1, Red); (3, Green); (1, Red); (2, Green)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice the types inferred by OCaml for these expressions. We can pattern-match\non our new type, just as with any built-in type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let example c =\n  match c with\n  | Red -\u0026gt; \u0026quot;rose\u0026quot;\n  | Green -\u0026gt; \u0026quot;grass\u0026quot;\n  | Blue -\u0026gt; \u0026quot;sky\u0026quot;\n  | Yellow -\u0026gt; \u0026quot;banana\u0026quot;\nval example : colour -\u0026gt; string = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice the type of the function includes the name of our new type \u003ccode\u003ecolour\u003c/code\u003e. We\ncan make the function shorter and elide its parameter \u003ccode\u003ec\u003c/code\u003e by using the\nalternative \u003ccode\u003efunction\u003c/code\u003e keyword which allows direct matching:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let example = function\n  | Red -\u0026gt; \u0026quot;rose\u0026quot;\n  | Green -\u0026gt; \u0026quot;grass\u0026quot;\n  | Blue -\u0026gt; \u0026quot;sky\u0026quot;\n  | Yellow -\u0026gt; \u0026quot;banana\u0026quot;\nval example : colour -\u0026gt; string = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can match on more than one case at a time too:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec is_primary = function\n  | Red | Green | Blue -\u0026gt; true\n  | _ -\u0026gt; false\nval is_primary : colour -\u0026gt; bool = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"constructors-with-data\"\u003eConstructors with data\u003c/h2\u003e\n\u003cp\u003eEach constructor in a data type can carry additional information with it. Let's\nextend our \u003ccode\u003ecolour\u003c/code\u003e type to allow arbitrary RGB triples, each element begin a\nnumber from 0 (no colour) to 1 (full colour):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\ntype colour = Red | Green | Blue | Yellow | RGB of float * float * float\n\n# [Red; Blue; RGB (0.5, 0.65, 0.12)]\n- : colour list = [Red; Blue; RGB (0.5, 0.65, 0.12)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTypes, just like functions, may be recursively-defined. We extend our data type\nto allow mixing of colours:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\n  | Mix of float * colour * colour\ntype colour =\n    Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of float * float * float\n  | Mix of float * colour * colour\n# Mix (0.5, Red, Mix (0.5, Blue, Green))\n- : colour = Mix (0.5, Red, Mix (0.5, Blue, Green))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is a function over our new \u003ccode\u003ecolour\u003c/code\u003e data type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec rgb_of_colour = function\n  | Red -\u0026gt; (1.0, 0.0, 0.0)\n  | Green -\u0026gt; (0.0, 1.0, 0.0)\n  | Blue -\u0026gt; (0.0, 0.0, 1.0)\n  | Yellow -\u0026gt; (1.0, 1.0, 0.0)\n  | RGB (r, g, b) -\u0026gt; (r, g, b)\n  | Mix (p, a, b) -\u0026gt;\n      let (r1, g1, b1) = rgb_of_colour a in\n      let (r2, g2, b2) = rgb_of_colour b in\n      let mix x y = x *. p +. y *. (1.0 -. p) in\n        (mix r1 r2, mix g1 g2, mix b1 b2)\nval rgb_of_colour : colour -\u0026gt; float * float * float = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can use records directly in the data type instead to label our components:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type colour =\n  | Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of {r : float; g : float; b : float}\n  | Mix of {proportion : float; c1 : colour; c2 : colour}\ntype colour =\n    Red\n  | Green\n  | Blue\n  | Yellow\n  | RGB of { r : float; g : float; b : float; }\n  | Mix of { proportion : float; c1 : colour; c2 : colour; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"example-trees\"\u003eExample: trees\u003c/h2\u003e\n\u003cp\u003eData types may be polymorphic as well as recursive. Here is an OCaml data type\nfor a binary tree carrying any kind of data:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type 'a tree =\n  | Leaf\n  | Node of 'a tree * 'a * 'a tree\ntype 'a tree = Leaf | Node of 'a tree * 'a * 'a tree\n# let t =\n    Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Leaf))\nval t : int tree =\n  Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Leaf))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that we give the type parameter \u003ccode\u003e'a\u003c/code\u003e before the type name (if there is\nmore than one, we write \u003ccode\u003e('a, 'b)\u003c/code\u003e etc).  A \u003ccode\u003eLeaf\u003c/code\u003e holds no information,\njust like an empty list. A \u003ccode\u003eNode\u003c/code\u003e holds a left tree, a value of type \u003ccode\u003e'a\u003c/code\u003e\nand a right tree. In our example, we built an integer tree, but any type can be\nused. Now we can write recursive and polymorphic functions over these trees, by\npattern matching on our new constructors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec total = function\n  | Leaf -\u0026gt; 0\n  | Node (l, x, r) -\u0026gt; total l + x + total r\nval total : int tree -\u0026gt; int = \u0026lt;fun\u0026gt;\n# let rec flip = function\n  | Leaf -\u0026gt; Leaf\n  | Node (l, x, r) -\u0026gt; Node (flip r, x, flip l)\nval flip : 'a tree -\u0026gt; 'a tree = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, \u003ccode\u003eflip\u003c/code\u003e is polymorphic while \u003ccode\u003etotal\u003c/code\u003e operates only on trees of type \u003ccode\u003eint tree\u003c/code\u003e. Let's try our new functions out:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let all = total t\nval all : int = 10\n# let flipped = flip t\nval flipped : int tree =\n  Node (Node (Leaf, 4, Node (Leaf, 3, Leaf)), 2, Node (Leaf, 1, Leaf))\n# t = flip flipped\n- : bool = true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInstead of integers, we could build a tree of key-value pairs. Then, if we\ninsist that the keys are unique and that a smaller key is always left of a\nlarger key, we have a data structure for dictionaries which performs better\nthan a simple list of pairs. It is known as a \u003cem\u003ebinary search tree\u003c/em\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec insert (k, v) = function\n  | Leaf -\u0026gt; Node (Leaf, (k, v), Leaf)\n  | Node (l, (k', v'), r) -\u0026gt;\n      if k \u0026lt; k' then Node (insert (k, v) l, (k', v'), r) \n      else if k \u0026gt; k' then Node (l, (k', v'), insert (k, v) r)\n      else Node (l, (k, v), r)\nval insert : 'a * 'b -\u0026gt; ('a * 'b) tree -\u0026gt; ('a * 'b) tree = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSimilar functions can be written to look up values in a dictionary, to convert\na list of pairs to or from a tree dictionary and so on.\u003c/p\u003e\n\u003ch2 id=\"example-mathematical-expressions\"\u003eExample: mathematical expressions\u003c/h2\u003e\n\u003cp\u003eWe wish to represent simple mathematical expressions like \u003ccode\u003en * (x + y)\u003c/code\u003e and\nmultiply them out symbolically to get \u003ccode\u003en * x + n * y\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLet's define a type for these expressions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype expr =\n  | Plus of expr * expr        (* a + b *)\n  | Minus of expr * expr       (* a - b *)\n  | Times of expr * expr       (* a * b *)\n  | Divide of expr * expr      (* a / b *)\n  | Var of string              (* \u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, etc. *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe expression \u003ccode\u003en * (x + y)\u003c/code\u003e would be written:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Times (Var \u0026quot;n\u0026quot;, Plus (Var \u0026quot;x\u0026quot;, Var \u0026quot;y\u0026quot;))\n- : expr = Times (Var \u0026quot;n\u0026quot;, Plus (Var \u0026quot;x\u0026quot;, Var \u0026quot;y\u0026quot;))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's write a function which prints out \u003ccode\u003eTimes (Var \u0026quot;n\u0026quot;, Plus (Var \u0026quot;x\u0026quot;, Var \u0026quot;y\u0026quot;))\u003c/code\u003e as something more like \u003ccode\u003en * (x + y)\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec to_string e =\n  match e with\n  | Plus (left, right) -\u0026gt;\n     \u0026quot;(\u0026quot; ^ to_string left ^ \u0026quot; + \u0026quot; ^ to_string right ^ \u0026quot;)\u0026quot;\n  | Minus (left, right) -\u0026gt;\n     \u0026quot;(\u0026quot; ^ to_string left ^ \u0026quot; - \u0026quot; ^ to_string right ^ \u0026quot;)\u0026quot;\n  | Times (left, right) -\u0026gt;\n   \u0026quot;(\u0026quot; ^ to_string left ^ \u0026quot; * \u0026quot; ^ to_string right ^ \u0026quot;)\u0026quot;\n  | Divide (left, right) -\u0026gt;\n   \u0026quot;(\u0026quot; ^ to_string left ^ \u0026quot; / \u0026quot; ^ to_string right ^ \u0026quot;)\u0026quot;\n  | Var v -\u0026gt; v\nval to_string : expr -\u0026gt; string = \u0026lt;fun\u0026gt;\n# let print_expr e =\n  print_endline (to_string e)\nval print_expr : expr -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(The \u003ccode\u003e^\u003c/code\u003e operator concatenates strings). We separate the function into two so\nthat our \u003ccode\u003eto_string\u003c/code\u003e function is usable in other contexts. Here's the\n\u003ccode\u003eprint_expr\u003c/code\u003e function in action:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# print_expr (Times (Var \u0026quot;n\u0026quot;, Plus (Var \u0026quot;x\u0026quot;, Var \u0026quot;y\u0026quot;)))\n(n * (x + y))\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can write a function to multiply out expressions of the form \u003ccode\u003en * (x + y)\u003c/code\u003e\nor \u003ccode\u003e(x + y) * n\u003c/code\u003e and for this we will use a nested pattern:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec multiply_out e =\n  match e with\n  | Times (e1, Plus (e2, e3)) -\u0026gt;\n     Plus (Times (multiply_out e1, multiply_out e2),\n           Times (multiply_out e1, multiply_out e3))\n  | Times (Plus (e1, e2), e3) -\u0026gt;\n     Plus (Times (multiply_out e1, multiply_out e3),\n           Times (multiply_out e2, multiply_out e3))\n  | Plus (left, right) -\u0026gt;\n     Plus (multiply_out left, multiply_out right)\n  | Minus (left, right) -\u0026gt;\n     Minus (multiply_out left, multiply_out right)\n  | Times (left, right) -\u0026gt;\n     Times (multiply_out left, multiply_out right)\n  | Divide (left, right) -\u0026gt;\n     Divide (multiply_out left, multiply_out right)\n  | Var v -\u0026gt; Var v\nval multiply_out : expr -\u0026gt; expr = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere it is in action:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# print_expr (multiply_out (Times (Var \u0026quot;n\u0026quot;, Plus (Var \u0026quot;x\u0026quot;, Var \u0026quot;y\u0026quot;))))\n((n * x) + (n * y))\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHow does the \u003ccode\u003emultiply_out\u003c/code\u003e function work? The key is in the first two\npatterns. The first pattern is \u003ccode\u003eTimes (e1, Plus (e2, e3))\u003c/code\u003e which matches\nexpressions of the form \u003ccode\u003ee1 * (e2 + e3)\u003c/code\u003e. Now look at the right hand side of\nthis first pattern match, and convince yourself that it is the equivalent of\n\u003ccode\u003e(e1 * e2) + (e1 * e3)\u003c/code\u003e. The second pattern does the same thing, except for\nexpressions of the form \u003ccode\u003e(e1 + e2) * e3\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe remaining patterns don't change the form of the expression, but they\ncrucially \u003cem\u003edo\u003c/em\u003e call the \u003ccode\u003emultiply_out\u003c/code\u003e function recursively on their\nsubexpressions. This ensures that all subexpressions within the expression get\nmultiplied out too (if you only wanted to multiply out the very top level of an\nexpression, then you could replace all the remaining patterns with a simple \u003ccode\u003ee -\u0026gt; e\u003c/code\u003e rule).\u003c/p\u003e\n\u003cp\u003eCan we do the reverse (i.e. factorizing out common subexpressions)? We can!\n(But it's a bit more complicated). The following version only works for the top\nlevel expression. You could certainly extend it to cope with all levels of an\nexpression and more complex cases:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let factorize e =\n  match e with\n  | Plus (Times (e1, e2), Times (e3, e4)) when e1 = e3 -\u0026gt;\n     Times (e1, Plus (e2, e4))\n  | Plus (Times (e1, e2), Times (e3, e4)) when e2 = e4 -\u0026gt;\n     Times (Plus (e1, e3), e4)\n  | e -\u0026gt; e\nval factorize : expr -\u0026gt; expr = \u0026lt;fun\u0026gt;\n# factorize (Plus (Times (Var \u0026quot;n\u0026quot;, Var \u0026quot;x\u0026quot;),\n                   Times (Var \u0026quot;n\u0026quot;, Var \u0026quot;y\u0026quot;)))\n- : expr = Times (Var \u0026quot;n\u0026quot;, Plus (Var \u0026quot;x\u0026quot;, Var \u0026quot;y\u0026quot;))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe factorize function above introduces another couple of features. You can add\nwhat are known as \u003cem\u003eguards\u003c/em\u003e to each pattern match. A guard is the conditional\nwhich follows the \u003ccode\u003ewhen\u003c/code\u003e, and it means that the pattern match only happens if\nthe pattern matches \u003cem\u003eand\u003c/em\u003e the condition in the \u003ccode\u003ewhen\u003c/code\u003e-clause is satisfied.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ematch value with\n| pattern [ when condition ] -\u0026gt; result\n| pattern [ when condition ] -\u0026gt; result\n  ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe second feature is the \u003ccode\u003e=\u003c/code\u003e operator which tests for \u0026quot;structural equality\u0026quot;\nbetween two expressions. That means it goes recursively into each expression\nchecking they're exactly the same at all levels down.\u003c/p\u003e\n\u003cp\u003eAnother feature which is useful when we build more complicated nested patterns\nis the \u003ccode\u003eas\u003c/code\u003e keyword, which can be used to name part of an expression. For\nexample:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eName (\u0026quot;/DeviceGray\u0026quot; | \u0026quot;/DeviceRGB\u0026quot; | \u0026quot;/DeviceCMYK\u0026quot;) as n -\u0026gt; n\n\nNode (l, ((k, _) as pair), r) when k = k' -\u0026gt; Some pair\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"mutually-recursive-data-types\"\u003eMutually recursive data types\u003c/h2\u003e\n\u003cp\u003eData types may be mutually-recursive when declared with \u003ccode\u003eand\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype t = A | B of t' and t' = C | D of t\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne common use for mutually-recursive data types is to \u003cem\u003edecorate\u003c/em\u003e a tree, by\nadding information to each node using mutually-recursive types, one of which is\na tuple or record. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype t' = Int of int | Add of t * t\nand t = {annotation : string; data : t'}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eValues of such mutually-recursive data type are manipulated by accompanying\nmutually-recursive functions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec sum_t' = function\n  | Int i -\u0026gt; i\n  | Add (i, i') -\u0026gt; sum_t i + sum_t i'\n  and sum_t {annotation; data} =\n    if annotation \u0026lt;\u0026gt; \u0026quot;\u0026quot; then Printf.printf \u0026quot;Touching %s\\n\u0026quot; annotation;\n    sum_t' data\nval sum_t' : t' -\u0026gt; int = \u0026lt;fun\u0026gt;\nval sum_t : t -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"a-note-on-tupled-constructors\"\u003eA note on tupled constructors\u003c/h2\u003e\n\u003cp\u003eThere is a difference between \u003ccode\u003eRGB of float * float * float\u003c/code\u003e and `RGB of (float\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efloat * float)`. The first is a constructor with three pieces of data\nassociated with it, the second is a constructor with one tuple associated with\nit. There are two ways this matters: the memory layout differs between the two\n(a tuple is an extra indirection), and the ability to create or match using a\ntuple:\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type t = T of int * int\ntype t = T of int * int\n\n# type t2 = T2 of (int * int)\ntype t2 = T2 of (int * int)\n\n# let pair = (1, 2)\nval pair : int * int = (1, 2)\n\n# T2 pair\n- : t2 = T2 (1, 2)\n\n# T pair\nLine 1, characters 1-7:\nError: The constructor T expects 2 argument(s),\n       but is applied here to 1 argument(s)\n\n# match T2 (1, 2) with T2 x -\u0026gt; fst x\n- : int = 1\n\n# match T (1, 2) with T x -\u0026gt; fst x\nLine 1, characters 21-24:\nError: The constructor T expects 2 argument(s),\n       but is applied here to 1 argument(s)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote, however, that OCaml allows us to use the always-matching \u003ccode\u003e_\u003c/code\u003e in either\nversion:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# match T2 (1, 2) with T2 _ -\u0026gt; 0\n- : int = 0\n\n# match T (1, 2) with T _ -\u0026gt; 0\n- : int = 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"types-and-modules\"\u003eTypes and modules\u003c/h2\u003e\n\u003cp\u003eOften, a module will provide a single type and operations on that type. For\nexample, a module for a file format like PNG might have the following \u003ccode\u003epng.mli\u003c/code\u003e\ninterface:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype t\n\nval of_file : filename -\u0026gt; t\n\nval to_file : t -\u0026gt; filename -\u0026gt; unit\n\nval flip_vertical : t -\u0026gt; t\n\nval flip_horizontal : t -\u0026gt; t\n\nval rotate : float -\u0026gt; t -\u0026gt; t\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTraditionally, we name the type \u003ccode\u003et\u003c/code\u003e. In the program using this library, it\nwould then be \u003ccode\u003ePng.t\u003c/code\u003e which is shorter, reads better than \u003ccode\u003ePng.png\u003c/code\u003e, and avoids\nconfusion if the library also defines other types.\u003c/p\u003e\n"},{"title":"Functional Programming","slug":"functional-programming","description":"A guide to functional programming in OCaml\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"language","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\n## What is functional programming?\nWe've got quite far into the tutorial, yet we haven't really considered\n**functional programming**. All of the features given so far - rich data\ntypes, pattern matching, type inference, nested functions - you could\nimagine could exist in a kind of \"super C\" language. These are Cool\nFeatures certainly, and make your code concise, easy to read, and have\nfewer bugs, but they actually have very little to do with functional\nprogramming. In fact my argument is going to be that the reason that\nfunctional languages are so great is *not* because of functional\nprogramming, but because we've been stuck with C-like languages for\nyears and in the meantime the cutting edge of programming has moved on\nconsiderably. So while we were writing\n`struct { int type; union { ... } }` for the umpteenth time, ML and\nHaskell programmers had safe variants and pattern matching on datatypes.\nWhile we were being careful to `free` all our `malloc`s, there have been\nlanguages with garbage collectors able to outperform hand-coding since\nthe 80s.\n\nWell, after that I'd better tell you what functional programming is\nanyhow.\n\nThe basic, and not very enlightening definition is this: in a\n**functional language**, **functions** are first-class citizens.\n\nLot of words there that don't really make much sense. So let's have an\nexample:\n\n```ocaml\n# let double x = x * 2 in\n    List.map double [1; 2; 3]\n- : int list = [2; 4; 6]\n```\n\nIn this example, I've first defined a nested function called `double`\nwhich takes an argument `x` and returns `x * 2`. Then `map` calls\n`double` on each element of the given list (`[1; 2; 3]`) to produce the\nresult: a list with each number doubled.\n\n`map` is known as a **higher-order function** (HOF). Higher-order\nfunctions are just a fancy way of saying that the function takes a\nfunction as one of its arguments. So far so simple. If you're familiar\nwith C/C++ then this looks like passing a function pointer around.\n\n**Closures** are functions which carry around some of the \"environment\"\nin which they were defined. In particular, a closure can reference\nvariables which were available at the point of its definition. Let's\ngeneralise the function above so that now we can take any list of\nintegers and multiply each element by an arbitrary value `n`:\n\n```ocaml\n# let multiply n list =\n    let f x = n * x in\n      List.map f list\nval multiply : int -\u003e int list -\u003e int list = \u003cfun\u003e\n```\n\nHence:\n\n```ocaml\n# multiply 2 [1; 2; 3]\n- : int list = [2; 4; 6]\n# multiply 5 [1; 2; 3]\n- : int list = [5; 10; 15]\n```\n\nThe important point to note about the `multiply` function is the nested\nfunction `f`. This is a closure. Look at how `f` uses the value of `n`\nwhich isn't actually passed as an explicit argument to `f`. Instead `f`\npicks it up from its environment - it's an argument to the `multiply`\nfunction and hence available within this function.\n\nThis might sound straightforward, but let's look a bit closer at that\ncall to map: `List.map f list`.\n\n`map` is defined in the `List` module, far away from the current code.\nIn other words, we're passing `f` into a module defined \"a long time\nago, in a galaxy far far away\". For all we know that code might pass `f`\nto other modules, or save a reference to `f` somewhere and call it\nlater. Whether it does this or not, the closure will ensure that `f`\nalways has access back to its parental environment, and to `n`.\n\nHere's a real example from lablgtk. This is actually a method on a class\n(we haven't talked about classes and objects yet, but just think of it\nas a function definition for now).\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nclass html_skel obj = object (self)\n  ...\n  ...\n  method save_to_channel chan =\n    let receiver_fn content =\n      output_string chan content;\n      true\n    in\n      save obj receiver_fn\n  ...\nend\n```\nFirst of all you need to know that the `save` function called at the end\nof the method takes as its second argument a function (`receiver_fn`).\nIt repeatedly calls `receiver_fn` with snippets of text from the widget\nthat it's trying to save.\n\nNow look at the definition of `receiver_fn`. This function is a closure\nalright because it keeps a reference to `chan` from its environment.\n\n## Partial function applications and currying\nLet's define a plus function which just adds two integers:\n\n```ocaml\n# let plus a b =\n    a + b\nval plus : int -\u003e int -\u003e int = \u003cfun\u003e\n```\nSome questions for people asleep at the back of the class.\n\n1. What is `plus`?\n1. What is `plus 2 3`?\n1. What is `plus 2`?\n\nQuestion 1 is easy. `plus` is a function, it takes two arguments which\nare integers and it returns an integer. We write its type like this:\n\n```ocaml\n# plus\n- : int -\u003e int -\u003e int = \u003cfun\u003e\n```\nQuestion 2 is even easier. `plus 2 3` is a number, the integer `5`. We\nwrite its value and type like this:\n\n```ocaml\n# 5\n- : int = 5\n```\nBut what about question 3? It looks like `plus 2` is a mistake, a bug.\nIn fact, however, it isn't. If we type this into the OCaml toplevel, it\ntells us:\n\n```ocaml\n# plus 2\n- : int -\u003e int = \u003cfun\u003e\n```\nThis isn't an error. It's telling us that `plus 2` is in fact a\n*function*, which takes an `int` and returns an `int`. What sort of\nfunction is this? We experiment by first of all giving this mysterious\nfunction a name (`f`), and then trying it out on a few integers to see\nwhat it does:\n\n```ocaml\n# let f = plus 2\nval f : int -\u003e int = \u003cfun\u003e\n# f 10\n- : int = 12\n# f 15\n- : int = 17\n# f 99\n- : int = 101\n```\nIn engineering this is sufficient [proof by example](humor_proof.html)\nfor us to state that `plus 2` is the function which adds 2 to things.\n\nGoing back to the original definition, let's \"fill in\" the first\nargument (`a`) setting it to 2 to get:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet plus 2 b =       (* This is not real OCaml code! *)\n  2 + b\n```\nYou can kind of see, I hope, why `plus 2` is the function which adds 2\nto things.\n\nLooking at the types of these expressions we may be able to see some\nrationale for the strange `-\u003e` arrow notation used for function types:\n\n```ocaml\n# plus\n- : int -\u003e int -\u003e int = \u003cfun\u003e\n# plus 2\n- : int -\u003e int = \u003cfun\u003e\n# plus 2 3\n- : int = 5\n```\nThis process is called **currying** (or perhaps it's called\n**uncurrying**, I never was really sure which was which). It is called\nthis after Haskell Curry who did some important stuff related to the\nlambda calculus. Since I'm trying to avoid entering into the mathematics\nbehind OCaml because that makes for a very boring and irrelevant\ntutorial, I won't go any further on the subject. You can find much more\ninformation about currying if it interests you by [doing a search on\nGoogle](https://www.google.com/search?q=currying \"https://www.google.com/search?q=currying\").\n\nRemember our `double` and `multiply` functions from earlier on?\n`multiply` was defined as this:\n\n```ocaml\n# let multiply n list =\n  let f x = n * x in\n    List.map f list\nval multiply : int -\u003e int list -\u003e int list = \u003cfun\u003e\n```\nWe can now define `double`, `triple` \u0026amp;c functions very easily just like\nthis:\n\n```ocaml\n# let double = multiply 2\nval double : int list -\u003e int list = \u003cfun\u003e\n# let triple = multiply 3\nval triple : int list -\u003e int list = \u003cfun\u003e\n```\nThey really are functions, look:\n\n```ocaml\n# double [1; 2; 3]\n- : int list = [2; 4; 6]\n# triple [1; 2; 3]\n- : int list = [3; 6; 9]\n```\n\nYou can also use partial application directly (without the intermediate\n`f` function) like this:\n\n```ocaml\n# let multiply n = List.map (( * ) n)\nval multiply : int -\u003e int list -\u003e int list = \u003cfun\u003e\n# let double = multiply 2\nval double : int list -\u003e int list = \u003cfun\u003e\n# let triple = multiply 3\nval triple : int list -\u003e int list = \u003cfun\u003e\n# double [1; 2; 3]\n- : int list = [2; 4; 6]\n# triple [1; 2; 3]\n- : int list = [3; 6; 9]\n```\n\nIn the example above, `(( * ) n)` is the partial application of the `( * )`\n(times) function. Note the extra spaces needed so that OCaml doesn't\nthink `(*` starts a comment.\n\nYou can put infix operators into brackets to make functions. Here's an\nidentical definition of the `plus` function as before:\n\n```ocaml\n# let plus = ( + )\nval plus : int -\u003e int -\u003e int = \u003cfun\u003e\n# plus 2 3\n- : int = 5\n```\nHere's some more currying fun:\n\n```ocaml\n# List.map (plus 2) [1; 2; 3]\n- : int list = [3; 4; 5]\n# let list_of_functions = List.map plus [1; 2; 3]\nval list_of_functions : (int -\u003e int) list = [\u003cfun\u003e; \u003cfun\u003e; \u003cfun\u003e]\n```\n\n##  What is functional programming good for?\nFunctional programming, like any good programming technique, is a useful\ntool in your armoury for solving some classes of problems. It's very\ngood for callbacks, which have multiple uses from GUIs through to\nevent-driven loops. It's great for expressing generic algorithms.\n`List.map` is really a generic algorithm for applying functions over any\ntype of list. Similarly you can define generic functions over trees.\nCertain types of numerical problems can be solved more quickly with\nfunctional programming (for example, numerically calculating the\nderivative of a mathematical function).\n\n##  Pure and impure functional programming\nA **pure function** is one without any **side-effects**. A side-effect\nreally means that the function keeps some sort of hidden state inside\nit. `strlen` is a good example of a pure function in C. If you call\n`strlen` with the same string, it always returns the same length. The\noutput of `strlen` (the length) only depends on the inputs (the string)\nand nothing else. Many functions in C are, unfortunately, impure. For\nexample, `malloc` - if you call it with the same number, it certainly\nwon't return the same pointer to you. `malloc`, of course, relies on a\nhuge amount of hidden internal state (objects allocated on the heap, the\nallocation method in use, grabbing pages from the operating system,\netc.).\n\nML-derived languages like OCaml are \"mostly pure\". They allow\nside-effects through things like references and arrays, but by and large\nmost of the code you'll write will be pure functional because they\nencourage this thinking. Haskell, another functional language, is pure\nfunctional. OCaml is therefore more practical because writing impure\nfunctions is sometimes useful.\n\nThere are various theoretical advantages of having pure functions. One\nadvantage is that if a function is pure, then if it is called several\ntimes with the same arguments, the compiler only needs to actually call\nthe function once. A good example in C is:\n\n```C\nfor (i = 0; i \u003c strlen (s); ++i)\n  {\n    // Do something which doesn't affect s.\n  }\n```\nIf naively compiled, this loop is O(n\u003csup\u003e2\u003c/sup\u003e) because `strlen (s)`\nis called each time and `strlen` needs to iterate over the whole of `s`.\nIf the compiler is smart enough to work out that `strlen` is pure\nfunctional *and* that `s` is not updated in the loop, then it can remove\nthe redundant extra calls to `strlen` and make the loop O(n). Do\ncompilers really do this? In the case of `strlen` yes, in other cases,\nprobably not.\n\nConcentrating on writing small pure functions allows you to construct\nreusable code using a bottom-up approach, testing each small function as\nyou go along. The current fashion is for carefully planning your\nprograms using a top-down approach, but in the author's opinion this\noften results in projects failing.\n\n##  Strictness vs laziness\nC-derived and ML-derived languages are strict. Haskell and Miranda are\nnon-strict, or lazy, languages. OCaml is strict by default but allows a\nlazy style of programming where it is needed.\n\nIn a strict language, arguments to functions are always evaluated first,\nand the results are then passed to the function. For example in a strict\nlanguage, the call `give_me_a_three (1/0)` is always going to result in\na divide-by-zero error:\n\n```ocaml\n# let give_me_a_three _ = 3\nval give_me_a_three : 'a -\u003e int = \u003cfun\u003e\n# give_me_a_three (1/0)\nException: Division_by_zero.\n```\n\nIf you've programmed in any conventional language, this is just how\nthings work, and you'd be surprised that things could work any other\nway.\n\nIn a lazy language, something stranger happens. Arguments to functions\nare only evaluated if the function actually uses them. Remember that the\n`give_me_a_three` function throws away its argument and always returns a\n3? Well in a lazy language, the above call would *not* fail because\n`give_me_a_three` never looks at its first argument, so the first\nargument is never evaluated, so the division by zero doesn't happen.\n\nLazy languages also let you do really odd things like defining an\ninfinitely long list. Provided you don't actually try to iterate over\nthe whole list this works (say, instead, that you just try to fetch the\nfirst 10 elements).\n\nOCaml is a strict language, but has a `Lazy` module that lets you write\nlazy expressions. Here's an example. First we create a lazy expression\nfor `1/0`:\n\n```ocaml\n# let lazy_expr = lazy (1 / 0)\nval lazy_expr : int lazy_t = \u003clazy\u003e\n```\n\nNotice the type of this lazy expression is `int lazy_t`.\n\nBecause `give_me_a_three` takes `'a` (any type) we can pass this lazy\nexpression into the function:\n\n```ocaml\n# give_me_a_three lazy_expr\n- : int = 3\n```\n\nTo evaluate a lazy expression, you must use the `Lazy.force` function:\n\n```ocaml\n# Lazy.force lazy_expr\nException: Division_by_zero.\n```\n\n##  Boxed vs. unboxed types\nOne term which you'll hear a lot when discussing functional languages is\n\"boxed\". I was very confused when I first heard this term, but in fact\nthe distinction between boxed and unboxed types is quite simple if\nyou've used C, C++ or Java before (in Perl, everything is boxed).\n\nThe way to think of a boxed object is to think of an object which has\nbeen allocated on the heap using `malloc` in C (or equivalently `new` in\nC++), and/or is referred to through a pointer. Take a look at this\nexample C program:\n\n```C\n#include \u003cstdio.h\u003e\n\nvoid\nprintit (int *ptr)\n{\n  printf (\"the number is %d\\n\", *ptr);\n}\n\nvoid\nmain ()\n{\n  int a = 3;\n  int *p = \u0026a;\n\n  printit (p);\n}\n```\n\nThe variable `a` is allocated on the stack, and is quite definitely\nunboxed.\n\nThe function `printit` takes a boxed integer and prints it.\n\nThe diagram below shows an array of unboxed (top) vs. boxed (below)\nintegers:\n\n![Boxed Array](/tutorials/boxedarray.png \"\")\n\nNo prizes for guessing that the array of unboxed integers is much faster\nthan the array of boxed integers. In addition, because there are fewer\nseparate allocations, garbage collection is much faster and simpler on\nthe array of unboxed objects.\n\nIn C or C++ you should have no problems constructing either of the two\ntypes of arrays above. In Java, you have two types, `int` which is\nunboxed and `Integer` which is boxed, and hence considerably less\nefficient. In OCaml, the basic types are all unboxed.\n\n## Aliases for function names and arguments\nIt's possible to use this as a neat trick to save typing: aliasing function\nnames, and function arguments.\n\nAlthough we haven't looked at object-oriented programming (that's the\nsubject for the [\"Objects\" section](objects.html)),\nhere's an example from OCamlNet of an\naliased function call. All you need to know is that\n`cgi # output # output_string \"string\"` is a method call, similar to\n`cgi.output().output_string (\"string\")` in Java.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet begin_page cgi title =\n  let out = cgi # output # output_string in\n  out \"\u003chtml\u003e\\n\";\n  out \"\u003chead\u003e\\n\";\n  out (\"\u003ctitle\u003e\" ^ text title ^ \"\u003c/title\u003e\\n\");\n  out (\"\u003cstyle type=\\\"text/css\\\"\u003e\\n\");\n  out \"body { background: white; color: black; }\\n\";\n  out \"\u003c/style\u003e\\n\";\n  out \"\u003c/head\u003e\\n\";\n  out \"\u003cbody\u003e\\n\";\n  out (\"\u003ch1\u003e\" ^ text title ^ \"\u003c/h1\u003e\\n\")\n```\n\nThe `let out = ... ` is a partial function application for that method\ncall (partial, because the string parameter hasn't been applied). `out`\nis therefore a function, which takes a string parameter.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nout \"\u003chtml\u003e\\n\";\n```\n\nis equivalent to:\n\u003c!-- $MDX skip --\u003e\n```ocaml\ncgi # output # output_string \"\u003chtml\u003e\\n\";\n```\n\nWe saved ourselves a lot of typing there.\n\nWe can also add arguments. This alternative definition of `print_string`\ncan be thought of as a kind of alias for a function name plus arguments:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet print_string = output_string stdout\n```\n\n`output_string` takes two arguments (a channel and a string), but since\nwe have only supplied one, it is partially applied. So `print_string` is\na function, expecting one string argument.\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#what-is-functional-programming\"\u003eWhat is functional programming?\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#partial-function-applications-and-currying\"\u003ePartial function applications and currying\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-functional-programming-good-for\"\u003eWhat is functional programming good for?\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#pure-and-impure-functional-programming\"\u003ePure and impure functional programming\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#strictness-vs-laziness\"\u003eStrictness vs laziness\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#boxed-vs-unboxed-types\"\u003eBoxed vs. unboxed types\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#aliases-for-function-names-and-arguments\"\u003eAliases for function names and arguments\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"what-is-functional-programming\"\u003eWhat is functional programming?\u003c/h2\u003e\n\u003cp\u003eWe've got quite far into the tutorial, yet we haven't really considered\n\u003cstrong\u003efunctional programming\u003c/strong\u003e. All of the features given so far - rich data\ntypes, pattern matching, type inference, nested functions - you could\nimagine could exist in a kind of \u0026quot;super C\u0026quot; language. These are Cool\nFeatures certainly, and make your code concise, easy to read, and have\nfewer bugs, but they actually have very little to do with functional\nprogramming. In fact my argument is going to be that the reason that\nfunctional languages are so great is \u003cem\u003enot\u003c/em\u003e because of functional\nprogramming, but because we've been stuck with C-like languages for\nyears and in the meantime the cutting edge of programming has moved on\nconsiderably. So while we were writing\n\u003ccode\u003estruct { int type; union { ... } }\u003c/code\u003e for the umpteenth time, ML and\nHaskell programmers had safe variants and pattern matching on datatypes.\nWhile we were being careful to \u003ccode\u003efree\u003c/code\u003e all our \u003ccode\u003emalloc\u003c/code\u003es, there have been\nlanguages with garbage collectors able to outperform hand-coding since\nthe 80s.\u003c/p\u003e\n\u003cp\u003eWell, after that I'd better tell you what functional programming is\nanyhow.\u003c/p\u003e\n\u003cp\u003eThe basic, and not very enlightening definition is this: in a\n\u003cstrong\u003efunctional language\u003c/strong\u003e, \u003cstrong\u003efunctions\u003c/strong\u003e are first-class citizens.\u003c/p\u003e\n\u003cp\u003eLot of words there that don't really make much sense. So let's have an\nexample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let double x = x * 2 in\n    List.map double [1; 2; 3]\n- : int list = [2; 4; 6]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, I've first defined a nested function called \u003ccode\u003edouble\u003c/code\u003e\nwhich takes an argument \u003ccode\u003ex\u003c/code\u003e and returns \u003ccode\u003ex * 2\u003c/code\u003e. Then \u003ccode\u003emap\u003c/code\u003e calls\n\u003ccode\u003edouble\u003c/code\u003e on each element of the given list (\u003ccode\u003e[1; 2; 3]\u003c/code\u003e) to produce the\nresult: a list with each number doubled.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emap\u003c/code\u003e is known as a \u003cstrong\u003ehigher-order function\u003c/strong\u003e (HOF). Higher-order\nfunctions are just a fancy way of saying that the function takes a\nfunction as one of its arguments. So far so simple. If you're familiar\nwith C/C++ then this looks like passing a function pointer around.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eClosures\u003c/strong\u003e are functions which carry around some of the \u0026quot;environment\u0026quot;\nin which they were defined. In particular, a closure can reference\nvariables which were available at the point of its definition. Let's\ngeneralise the function above so that now we can take any list of\nintegers and multiply each element by an arbitrary value \u003ccode\u003en\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let multiply n list =\n    let f x = n * x in\n      List.map f list\nval multiply : int -\u0026gt; int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHence:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# multiply 2 [1; 2; 3]\n- : int list = [2; 4; 6]\n# multiply 5 [1; 2; 3]\n- : int list = [5; 10; 15]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe important point to note about the \u003ccode\u003emultiply\u003c/code\u003e function is the nested\nfunction \u003ccode\u003ef\u003c/code\u003e. This is a closure. Look at how \u003ccode\u003ef\u003c/code\u003e uses the value of \u003ccode\u003en\u003c/code\u003e\nwhich isn't actually passed as an explicit argument to \u003ccode\u003ef\u003c/code\u003e. Instead \u003ccode\u003ef\u003c/code\u003e\npicks it up from its environment - it's an argument to the \u003ccode\u003emultiply\u003c/code\u003e\nfunction and hence available within this function.\u003c/p\u003e\n\u003cp\u003eThis might sound straightforward, but let's look a bit closer at that\ncall to map: \u003ccode\u003eList.map f list\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emap\u003c/code\u003e is defined in the \u003ccode\u003eList\u003c/code\u003e module, far away from the current code.\nIn other words, we're passing \u003ccode\u003ef\u003c/code\u003e into a module defined \u0026quot;a long time\nago, in a galaxy far far away\u0026quot;. For all we know that code might pass \u003ccode\u003ef\u003c/code\u003e\nto other modules, or save a reference to \u003ccode\u003ef\u003c/code\u003e somewhere and call it\nlater. Whether it does this or not, the closure will ensure that \u003ccode\u003ef\u003c/code\u003e\nalways has access back to its parental environment, and to \u003ccode\u003en\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHere's a real example from lablgtk. This is actually a method on a class\n(we haven't talked about classes and objects yet, but just think of it\nas a function definition for now).\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eclass html_skel obj = object (self)\n  ...\n  ...\n  method save_to_channel chan =\n    let receiver_fn content =\n      output_string chan content;\n      true\n    in\n      save obj receiver_fn\n  ...\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFirst of all you need to know that the \u003ccode\u003esave\u003c/code\u003e function called at the end\nof the method takes as its second argument a function (\u003ccode\u003ereceiver_fn\u003c/code\u003e).\nIt repeatedly calls \u003ccode\u003ereceiver_fn\u003c/code\u003e with snippets of text from the widget\nthat it's trying to save.\u003c/p\u003e\n\u003cp\u003eNow look at the definition of \u003ccode\u003ereceiver_fn\u003c/code\u003e. This function is a closure\nalright because it keeps a reference to \u003ccode\u003echan\u003c/code\u003e from its environment.\u003c/p\u003e\n\u003ch2 id=\"partial-function-applications-and-currying\"\u003ePartial function applications and currying\u003c/h2\u003e\n\u003cp\u003eLet's define a plus function which just adds two integers:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let plus a b =\n    a + b\nval plus : int -\u0026gt; int -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSome questions for people asleep at the back of the class.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWhat is \u003ccode\u003eplus\u003c/code\u003e?\n\u003c/li\u003e\n\u003cli\u003eWhat is \u003ccode\u003eplus 2 3\u003c/code\u003e?\n\u003c/li\u003e\n\u003cli\u003eWhat is \u003ccode\u003eplus 2\u003c/code\u003e?\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eQuestion 1 is easy. \u003ccode\u003eplus\u003c/code\u003e is a function, it takes two arguments which\nare integers and it returns an integer. We write its type like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# plus\n- : int -\u0026gt; int -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eQuestion 2 is even easier. \u003ccode\u003eplus 2 3\u003c/code\u003e is a number, the integer \u003ccode\u003e5\u003c/code\u003e. We\nwrite its value and type like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# 5\n- : int = 5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut what about question 3? It looks like \u003ccode\u003eplus 2\u003c/code\u003e is a mistake, a bug.\nIn fact, however, it isn't. If we type this into the OCaml toplevel, it\ntells us:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# plus 2\n- : int -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis isn't an error. It's telling us that \u003ccode\u003eplus 2\u003c/code\u003e is in fact a\n\u003cem\u003efunction\u003c/em\u003e, which takes an \u003ccode\u003eint\u003c/code\u003e and returns an \u003ccode\u003eint\u003c/code\u003e. What sort of\nfunction is this? We experiment by first of all giving this mysterious\nfunction a name (\u003ccode\u003ef\u003c/code\u003e), and then trying it out on a few integers to see\nwhat it does:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let f = plus 2\nval f : int -\u0026gt; int = \u0026lt;fun\u0026gt;\n# f 10\n- : int = 12\n# f 15\n- : int = 17\n# f 99\n- : int = 101\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn engineering this is sufficient \u003ca href=\"humor_proof.html\"\u003eproof by example\u003c/a\u003e\nfor us to state that \u003ccode\u003eplus 2\u003c/code\u003e is the function which adds 2 to things.\u003c/p\u003e\n\u003cp\u003eGoing back to the original definition, let's \u0026quot;fill in\u0026quot; the first\nargument (\u003ccode\u003ea\u003c/code\u003e) setting it to 2 to get:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet plus 2 b =       (* This is not real OCaml code! *)\n  2 + b\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can kind of see, I hope, why \u003ccode\u003eplus 2\u003c/code\u003e is the function which adds 2\nto things.\u003c/p\u003e\n\u003cp\u003eLooking at the types of these expressions we may be able to see some\nrationale for the strange \u003ccode\u003e-\u0026gt;\u003c/code\u003e arrow notation used for function types:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# plus\n- : int -\u0026gt; int -\u0026gt; int = \u0026lt;fun\u0026gt;\n# plus 2\n- : int -\u0026gt; int = \u0026lt;fun\u0026gt;\n# plus 2 3\n- : int = 5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis process is called \u003cstrong\u003ecurrying\u003c/strong\u003e (or perhaps it's called\n\u003cstrong\u003euncurrying\u003c/strong\u003e, I never was really sure which was which). It is called\nthis after Haskell Curry who did some important stuff related to the\nlambda calculus. Since I'm trying to avoid entering into the mathematics\nbehind OCaml because that makes for a very boring and irrelevant\ntutorial, I won't go any further on the subject. You can find much more\ninformation about currying if it interests you by \u003ca href=\"https://www.google.com/search?q=currying\" title=\"https://www.google.com/search?q=currying\"\u003edoing a search on\nGoogle\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eRemember our \u003ccode\u003edouble\u003c/code\u003e and \u003ccode\u003emultiply\u003c/code\u003e functions from earlier on?\n\u003ccode\u003emultiply\u003c/code\u003e was defined as this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let multiply n list =\n  let f x = n * x in\n    List.map f list\nval multiply : int -\u0026gt; int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can now define \u003ccode\u003edouble\u003c/code\u003e, \u003ccode\u003etriple\u003c/code\u003e \u0026amp;c functions very easily just like\nthis:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let double = multiply 2\nval double : int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n# let triple = multiply 3\nval triple : int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThey really are functions, look:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# double [1; 2; 3]\n- : int list = [2; 4; 6]\n# triple [1; 2; 3]\n- : int list = [3; 6; 9]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can also use partial application directly (without the intermediate\n\u003ccode\u003ef\u003c/code\u003e function) like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let multiply n = List.map (( * ) n)\nval multiply : int -\u0026gt; int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n# let double = multiply 2\nval double : int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n# let triple = multiply 3\nval triple : int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n# double [1; 2; 3]\n- : int list = [2; 4; 6]\n# triple [1; 2; 3]\n- : int list = [3; 6; 9]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the example above, \u003ccode\u003e(( * ) n)\u003c/code\u003e is the partial application of the \u003ccode\u003e( * )\u003c/code\u003e\n(times) function. Note the extra spaces needed so that OCaml doesn't\nthink \u003ccode\u003e(*\u003c/code\u003e starts a comment.\u003c/p\u003e\n\u003cp\u003eYou can put infix operators into brackets to make functions. Here's an\nidentical definition of the \u003ccode\u003eplus\u003c/code\u003e function as before:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let plus = ( + )\nval plus : int -\u0026gt; int -\u0026gt; int = \u0026lt;fun\u0026gt;\n# plus 2 3\n- : int = 5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere's some more currying fun:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# List.map (plus 2) [1; 2; 3]\n- : int list = [3; 4; 5]\n# let list_of_functions = List.map plus [1; 2; 3]\nval list_of_functions : (int -\u0026gt; int) list = [\u0026lt;fun\u0026gt;; \u0026lt;fun\u0026gt;; \u0026lt;fun\u0026gt;]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"what-is-functional-programming-good-for\"\u003eWhat is functional programming good for?\u003c/h2\u003e\n\u003cp\u003eFunctional programming, like any good programming technique, is a useful\ntool in your armoury for solving some classes of problems. It's very\ngood for callbacks, which have multiple uses from GUIs through to\nevent-driven loops. It's great for expressing generic algorithms.\n\u003ccode\u003eList.map\u003c/code\u003e is really a generic algorithm for applying functions over any\ntype of list. Similarly you can define generic functions over trees.\nCertain types of numerical problems can be solved more quickly with\nfunctional programming (for example, numerically calculating the\nderivative of a mathematical function).\u003c/p\u003e\n\u003ch2 id=\"pure-and-impure-functional-programming\"\u003ePure and impure functional programming\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003epure function\u003c/strong\u003e is one without any \u003cstrong\u003eside-effects\u003c/strong\u003e. A side-effect\nreally means that the function keeps some sort of hidden state inside\nit. \u003ccode\u003estrlen\u003c/code\u003e is a good example of a pure function in C. If you call\n\u003ccode\u003estrlen\u003c/code\u003e with the same string, it always returns the same length. The\noutput of \u003ccode\u003estrlen\u003c/code\u003e (the length) only depends on the inputs (the string)\nand nothing else. Many functions in C are, unfortunately, impure. For\nexample, \u003ccode\u003emalloc\u003c/code\u003e - if you call it with the same number, it certainly\nwon't return the same pointer to you. \u003ccode\u003emalloc\u003c/code\u003e, of course, relies on a\nhuge amount of hidden internal state (objects allocated on the heap, the\nallocation method in use, grabbing pages from the operating system,\netc.).\u003c/p\u003e\n\u003cp\u003eML-derived languages like OCaml are \u0026quot;mostly pure\u0026quot;. They allow\nside-effects through things like references and arrays, but by and large\nmost of the code you'll write will be pure functional because they\nencourage this thinking. Haskell, another functional language, is pure\nfunctional. OCaml is therefore more practical because writing impure\nfunctions is sometimes useful.\u003c/p\u003e\n\u003cp\u003eThere are various theoretical advantages of having pure functions. One\nadvantage is that if a function is pure, then if it is called several\ntimes with the same arguments, the compiler only needs to actually call\nthe function once. A good example in C is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003efor (i = 0; i \u0026lt; strlen (s); ++i)\n  {\n    // Do something which doesn't affect s.\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf naively compiled, this loop is O(n\u003csup\u003e2\u003c/sup\u003e) because \u003ccode\u003estrlen (s)\u003c/code\u003e\nis called each time and \u003ccode\u003estrlen\u003c/code\u003e needs to iterate over the whole of \u003ccode\u003es\u003c/code\u003e.\nIf the compiler is smart enough to work out that \u003ccode\u003estrlen\u003c/code\u003e is pure\nfunctional \u003cem\u003eand\u003c/em\u003e that \u003ccode\u003es\u003c/code\u003e is not updated in the loop, then it can remove\nthe redundant extra calls to \u003ccode\u003estrlen\u003c/code\u003e and make the loop O(n). Do\ncompilers really do this? In the case of \u003ccode\u003estrlen\u003c/code\u003e yes, in other cases,\nprobably not.\u003c/p\u003e\n\u003cp\u003eConcentrating on writing small pure functions allows you to construct\nreusable code using a bottom-up approach, testing each small function as\nyou go along. The current fashion is for carefully planning your\nprograms using a top-down approach, but in the author's opinion this\noften results in projects failing.\u003c/p\u003e\n\u003ch2 id=\"strictness-vs-laziness\"\u003eStrictness vs laziness\u003c/h2\u003e\n\u003cp\u003eC-derived and ML-derived languages are strict. Haskell and Miranda are\nnon-strict, or lazy, languages. OCaml is strict by default but allows a\nlazy style of programming where it is needed.\u003c/p\u003e\n\u003cp\u003eIn a strict language, arguments to functions are always evaluated first,\nand the results are then passed to the function. For example in a strict\nlanguage, the call \u003ccode\u003egive_me_a_three (1/0)\u003c/code\u003e is always going to result in\na divide-by-zero error:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let give_me_a_three _ = 3\nval give_me_a_three : 'a -\u0026gt; int = \u0026lt;fun\u0026gt;\n# give_me_a_three (1/0)\nException: Division_by_zero.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you've programmed in any conventional language, this is just how\nthings work, and you'd be surprised that things could work any other\nway.\u003c/p\u003e\n\u003cp\u003eIn a lazy language, something stranger happens. Arguments to functions\nare only evaluated if the function actually uses them. Remember that the\n\u003ccode\u003egive_me_a_three\u003c/code\u003e function throws away its argument and always returns a\n3? Well in a lazy language, the above call would \u003cem\u003enot\u003c/em\u003e fail because\n\u003ccode\u003egive_me_a_three\u003c/code\u003e never looks at its first argument, so the first\nargument is never evaluated, so the division by zero doesn't happen.\u003c/p\u003e\n\u003cp\u003eLazy languages also let you do really odd things like defining an\ninfinitely long list. Provided you don't actually try to iterate over\nthe whole list this works (say, instead, that you just try to fetch the\nfirst 10 elements).\u003c/p\u003e\n\u003cp\u003eOCaml is a strict language, but has a \u003ccode\u003eLazy\u003c/code\u003e module that lets you write\nlazy expressions. Here's an example. First we create a lazy expression\nfor \u003ccode\u003e1/0\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let lazy_expr = lazy (1 / 0)\nval lazy_expr : int lazy_t = \u0026lt;lazy\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice the type of this lazy expression is \u003ccode\u003eint lazy_t\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBecause \u003ccode\u003egive_me_a_three\u003c/code\u003e takes \u003ccode\u003e'a\u003c/code\u003e (any type) we can pass this lazy\nexpression into the function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# give_me_a_three lazy_expr\n- : int = 3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo evaluate a lazy expression, you must use the \u003ccode\u003eLazy.force\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Lazy.force lazy_expr\nException: Division_by_zero.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"boxed-vs-unboxed-types\"\u003eBoxed vs. unboxed types\u003c/h2\u003e\n\u003cp\u003eOne term which you'll hear a lot when discussing functional languages is\n\u0026quot;boxed\u0026quot;. I was very confused when I first heard this term, but in fact\nthe distinction between boxed and unboxed types is quite simple if\nyou've used C, C++ or Java before (in Perl, everything is boxed).\u003c/p\u003e\n\u003cp\u003eThe way to think of a boxed object is to think of an object which has\nbeen allocated on the heap using \u003ccode\u003emalloc\u003c/code\u003e in C (or equivalently \u003ccode\u003enew\u003c/code\u003e in\nC++), and/or is referred to through a pointer. Take a look at this\nexample C program:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003e#include \u0026lt;stdio.h\u0026gt;\n\nvoid\nprintit (int *ptr)\n{\n  printf (\u0026quot;the number is %d\\n\u0026quot;, *ptr);\n}\n\nvoid\nmain ()\n{\n  int a = 3;\n  int *p = \u0026amp;a;\n\n  printit (p);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe variable \u003ccode\u003ea\u003c/code\u003e is allocated on the stack, and is quite definitely\nunboxed.\u003c/p\u003e\n\u003cp\u003eThe function \u003ccode\u003eprintit\u003c/code\u003e takes a boxed integer and prints it.\u003c/p\u003e\n\u003cp\u003eThe diagram below shows an array of unboxed (top) vs. boxed (below)\nintegers:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tutorials/boxedarray.png\" alt=\"Boxed Array\" title=\"\" /\u003e\u003c/p\u003e\n\u003cp\u003eNo prizes for guessing that the array of unboxed integers is much faster\nthan the array of boxed integers. In addition, because there are fewer\nseparate allocations, garbage collection is much faster and simpler on\nthe array of unboxed objects.\u003c/p\u003e\n\u003cp\u003eIn C or C++ you should have no problems constructing either of the two\ntypes of arrays above. In Java, you have two types, \u003ccode\u003eint\u003c/code\u003e which is\nunboxed and \u003ccode\u003eInteger\u003c/code\u003e which is boxed, and hence considerably less\nefficient. In OCaml, the basic types are all unboxed.\u003c/p\u003e\n\u003ch2 id=\"aliases-for-function-names-and-arguments\"\u003eAliases for function names and arguments\u003c/h2\u003e\n\u003cp\u003eIt's possible to use this as a neat trick to save typing: aliasing function\nnames, and function arguments.\u003c/p\u003e\n\u003cp\u003eAlthough we haven't looked at object-oriented programming (that's the\nsubject for the \u003ca href=\"objects.html\"\u003e\u0026quot;Objects\u0026quot; section\u003c/a\u003e),\nhere's an example from OCamlNet of an\naliased function call. All you need to know is that\n\u003ccode\u003ecgi # output # output_string \u0026quot;string\u0026quot;\u003c/code\u003e is a method call, similar to\n\u003ccode\u003ecgi.output().output_string (\u0026quot;string\u0026quot;)\u003c/code\u003e in Java.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet begin_page cgi title =\n  let out = cgi # output # output_string in\n  out \u0026quot;\u0026lt;html\u0026gt;\\n\u0026quot;;\n  out \u0026quot;\u0026lt;head\u0026gt;\\n\u0026quot;;\n  out (\u0026quot;\u0026lt;title\u0026gt;\u0026quot; ^ text title ^ \u0026quot;\u0026lt;/title\u0026gt;\\n\u0026quot;);\n  out (\u0026quot;\u0026lt;style type=\\\u0026quot;text/css\\\u0026quot;\u0026gt;\\n\u0026quot;);\n  out \u0026quot;body { background: white; color: black; }\\n\u0026quot;;\n  out \u0026quot;\u0026lt;/style\u0026gt;\\n\u0026quot;;\n  out \u0026quot;\u0026lt;/head\u0026gt;\\n\u0026quot;;\n  out \u0026quot;\u0026lt;body\u0026gt;\\n\u0026quot;;\n  out (\u0026quot;\u0026lt;h1\u0026gt;\u0026quot; ^ text title ^ \u0026quot;\u0026lt;/h1\u0026gt;\\n\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003elet out = ... \u003c/code\u003e is a partial function application for that method\ncall (partial, because the string parameter hasn't been applied). \u003ccode\u003eout\u003c/code\u003e\nis therefore a function, which takes a string parameter.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eout \u0026quot;\u0026lt;html\u0026gt;\\n\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eis equivalent to:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ecgi # output # output_string \u0026quot;\u0026lt;html\u0026gt;\\n\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe saved ourselves a lot of typing there.\u003c/p\u003e\n\u003cp\u003eWe can also add arguments. This alternative definition of \u003ccode\u003eprint_string\u003c/code\u003e\ncan be thought of as a kind of alias for a function name plus arguments:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet print_string = output_string stdout\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eoutput_string\u003c/code\u003e takes two arguments (a channel and a string), but since\nwe have only supplied one, it is partially applied. So \u003ccode\u003eprint_string\u003c/code\u003e is\na function, expecting one string argument.\u003c/p\u003e\n"},{"title":"If Statements, Loops and Recursions","slug":"if-statements-loops-and-recursions","description":"Learn basic control-flow and recusion in OCaml\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"language","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\n## If statements (actually, these are if expressions)\nOCaml has an `if` statement with two variations, and the obvious meaning:\n\n```ocaml\nif boolean-condition then expression\n  \nif boolean-condition then expression else other-expression\n```\n```mdx-error\nLine 3, characters 3-5:\nError: Syntax error\n```\n\nUnlike in the conventional languages you'll be used to, `if` statements\nare really expressions. In other words, they're much more like\n`boolean-condition ? expression : other-expression` in C than like the if\nstatements you may be used to.\n\nHere's a simple example of an `if` statement:\n\n```ocaml\n# let max a b =\n  if a \u003e b then a else b\nval max : 'a -\u003e 'a -\u003e 'a = \u003cfun\u003e\n```\n\nAs a short aside, if you type this into the OCaml\ninteractive toplevel (as above), you'll\nnotice that OCaml decides that this function is polymorphic, with the\nfollowing type:\n\n```ocaml\n# max\n- : 'a -\u003e 'a -\u003e 'a = \u003cfun\u003e\n```\n\nAnd indeed OCaml lets you use `max` on any type:\n\n```ocaml\n# max 3 5\n- : int = 5\n# max 3.5 13.0\n- : float = 13.\n# max \"a\" \"b\"\n- : string = \"b\"\n```\n\nThis is because `\u003e` is in fact polymorphic. It works on any type, even\nobjects (it does a binary comparison).\n\n\\[Note that the `Stdlib` module defines `min` and `max` for you.\\]\n\nLet's look a bit more closely at the `if` expression. Here's the `range`\nfunction which I showed you earlier without much explanation. You should\nbe able to combine your knowledge of recursive functions, lists and if\nexpressions to see what it does:\n\n```ocaml\n# let rec range a b =\n    if a \u003e b then []\n    else a :: range (a + 1) b\nval range : int -\u003e int -\u003e int list = \u003cfun\u003e\n```\n\nLet's examine some typical calls to this function. Let's start with the\neasy case of `a \u003e b`. A call to `range 11 10` returns `[]` (the empty\nlist) and that's it.\n\nWhat about calling `range 10 10`? Since `10 \u003e 10` is false, the\n`else`-clause is evaluated, which is: `10 :: (range 11 10)` (I've added\nthe brackets to make the order of evaluation more clear). We've just\nworked out that `range 11 10` = `[]`, so this is: `10 :: []`. Remember\nour formal description of lists and the `::` (cons) operator? `10 :: []`\nis just the same as `[10]`.\n\nLet's try `range 9 10`:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nrange 9 10\n 9 :: (range 10 10)\n 9 :: [10]\n [9; 10]\n```\n\nIt should be fairly clear that `range 1 10` evaluates to\n`[1; 2; 3; 4; 5; 6; 7; 8; 9; 10]`.\n\nWhat we've got here is a simple case of recursion. Functional\nprogramming can be said to prefer recursion over loops, but I'm jumping\nahead of myself. We'll discuss recursion more at the end of this\nchapter.\n\nBack, temporarily, to `if` statements. What does this function do?\n\n```ocaml\n# let f x y =\n    x + if y \u003e 0 then y else 0\nval f : int -\u003e int -\u003e int = \u003cfun\u003e\n```\n\nClue: add brackets around the whole of the if expression. It clips `y`\nlike an [electronic diode](https://en.wikipedia.org/wiki/Diode#Current.E2.80.93voltage_characteristic).\n\nThe `abs` (absolute value) function is defined in `Stdlib` as:\n\n```ocaml\n# let abs x =\n    if x \u003e= 0 then x else -x\nval abs : int -\u003e int = \u003cfun\u003e\n```\n\nAlso in `Stdlib`, the `string_of_float` function contains a complex\npair of nested `if` expressions:\n\n```ocaml\n# let string_of_float f =\n  let s = format_float \"%.12g\" f in\n  let l = string_length s in\n  let rec loop i =\n    if i \u003e= l then s ^ \".\"\n    else if s.[i] = '.' || s.[i] = 'e' then s\n    else loop (i + 1)\n  in\n    loop 0\nLine 2, characters 11-23:\nError: Unbound value format_float\n```\n\nLet's examine this function. Suppose the function is called with `f` =\n12.34. Then `s` = \"12.34\", and `l` = 5. We call `loop` the first time\nwith `i` = 0.\n\n`i` is not greater than or equal to `l`, and `s.[i]` (the\n`i`\u003csup\u003eth\u003c/sup\u003e character in `s`) is not a period or `'e'`. So\n`loop (i + 1)` is called, ie. `loop 1`.\n\nWe go through the same dance for `i` = 1, and end up calling `loop 2`.\n\nFor `i` = 2, however, `s.[i]` is a period (refer to the original string,\n`s` = \"12.34\"). So this immediately returns `s`, and the function\n`string_of_float` returns \"12.34\".\n\nWhat is `loop` doing? In fact it's checking whether the string returned\nfrom `format_float` contains a period (or `'e'`). Suppose that we called\n`string_of_float` with `12.0`. `format_float` would return the string\n\"12\", but `string_of_float` must return \"12.\" or \"12.0\" (because\nfloating point constants in OCaml must contain a period to differentiate\nthem from integer constants). Hence the check.\n\nThe strange use of recursion in this function is almost certainly for\nefficiency. OCaml supports for loops, so why didn't the authors use for\nloops? We'll see in the next section that OCaml's for loops are limited\nin a way which prevents them from being used in `string_of_float`. Here,\nhowever, is a more straightforward, but approximately twice as slow, way\nof writing `string_of_float`:\n\n```ocaml\n# let string_of_float f =\n  let s = format_float \"%.12g\" f in\n    if String.contains s '.' || String.contains s 'e'\n      then s\n      else s ^ \".\"\nLine 2, characters 11-23:\nError: Unbound value format_float\n```\n\n## Using begin ... end\nHere is some code from lablgtk:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nif GtkBase.Object.is_a obj cls then\n  fun _ -\u003e f obj\nelse begin\n  eprintf \"Glade-warning: %s expects a %s argument.\\n\" name cls;\n  raise Not_found\nend\n```\n\n`begin` and `end` are what is known as **syntactic sugar** for open and\nclose parentheses. In the example above, all they do is group the two\nstatements in the `else`-clause together. Suppose the author had written\nthis instead:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nif GtkBase.Object.is_a obj cls then\n  fun _ -\u003e f obj\nelse\n  eprintf \"Glade-warning: %s expects a %s argument.\\n\" name cls;\n  raise Not_found\n```\nFully bracketing and properly indenting the above expression gives:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\n(if GtkBase.Object.is_a obj cls then\n   fun _ -\u003e f obj\n else\n   eprintf \"Glade-warning: %s expects a %s argument.\\n\" name cls\n);\nraise Not_found\n```\nNot what was intended at all. So the `begin` and `end` are necessary to\ngroup together multiple statements in a `then` or `else` clause of an if\nexpression. You can also use plain ordinary parentheses `( ... )` if you\nprefer (and I do prefer, because I **loathe** Pascal :-). Here are two\nsimple examples:\n\n```ocaml\n# if 1 = 0 then\n    print_endline \"THEN\"\n  else begin\n    print_endline \"ELSE\";\n    failwith \"else clause\"\n  end\nException: Failure \"else clause\".\nELSE\n# if 1 = 0 then\n    print_endline \"THEN\"\n  else (\n    print_endline \"ELSE\";\n    failwith \"else clause\"\n  )\nException: Failure \"else clause\".\nELSE\n```\n\n## For loops and while loops\nOCaml supports a rather limited form of the familiar `for` loop:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nfor variable = start_value to end_value do\n  expression\ndone\n  \nfor variable = start_value downto end_value do\n  expression\ndone\n```\nA simple but real example from lablgtk:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nfor i = 1 to n_jobs () do\n  do_next_job ()\ndone\n```\nIn OCaml, `for` loops are just shorthand for writing:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet i = 1 in\ndo_next_job ();\nlet i = 2 in\ndo_next_job ();\nlet i = 3 in\ndo_next_job ();\n  ...\nlet i = n_jobs () in\ndo_next_job ();\n()\n```\n\nOCaml doesn't support the concept of breaking out of a `for` loop early\ni.e. it has no `break`, `continue` or `last` statements. (You *could*\nthrow an exception and catch it outside, and this would run fast but\noften looks clumsy.)\n\nThe expression inside an OCaml for loop should evaluate to `unit`\n(otherwise you'll get a warning), and the for loop expression as a whole\nreturns `unit`:\n\n```ocaml\n# for i = 1 to 10 do i done\nLine 1, characters 20-21:\nWarning 10: this expression should have type unit.\n- : unit = ()\n```\nFunctional programmers tend to use recursion instead of explicit loops,\nand regard **for** loops with suspicion since it can't return anything,\nhence OCaml's relatively powerless **for** loop. We talk about recursion\nbelow.\n\n**While loops** in OCaml are written:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nwhile boolean-condition do\n  expression\ndone\n```\nAs with for loops, there is no way provided by the language to break out\nof a while loop, except by throwing an exception, and this means that\nwhile loops have fairly limited use. Again, remember that functional\nprogrammers like recursion, and so while loops are second-class citizens\nin the language.\n\nIf you stop to consider while loops, you may see that they aren't really\nany use at all, except in conjunction with our old friend references.\nLet's imagine that OCaml didn't have references for a moment:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet quit_loop = false in\n  while not quit_loop do\n    print_string \"Have you had enough yet? (y/n) \";\n    let str = read_line () in\n      if str.[0] = 'y' then\n        (* how do I set quit_loop to true ?!? *)\n  done\n```\nRemember that `quit_loop` is not a real \"variable\" - the let-binding\njust makes `quit_loop` a shorthand for `false`. This means the while\nloop condition (shown in red) is always true, and the loop runs on\nforever!\n\nLuckily OCaml *does have* references, so we can write the code above if\nwe want. Don't get confused and think that the `!` (exclamation mark)\nmeans \"not\" as in C/Java. It's used here to mean \"dereference the\npointer\", similar in fact to Forth. You're better off reading `!` as\n\"get\" or \"deref\".\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet quit_loop = ref false in\n  while not !quit_loop do\n    print_string \"Have you had enough yet? (y/n) \";\n    let str = read_line () in\n      if str.[0] = 'y' then quit_loop := true\n  done;;\n```\n\n## Looping over lists\nIf you want to loop over a list, don't be an imperative programmer and\nreach for your trusty six-shooter Mr. For Loop! OCaml has some better\nand faster ways to loop over lists, and they are all located in the\n`List` module. There are in fact dozens of good functions in `List`, but\nI'll only talk about the most useful ones here.\n\nFirst off, let's define a list for us to use:\n\n```ocaml\n# let my_list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\nval my_list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n```\n\nIf you want to call a function once on every element of the list, use\n`List.iter`, like this:\n\n```ocaml\n# let f elem =\n    Printf.printf \"I'm looking at element %d now\\n\" elem\n  in\n    List.iter f my_list\nI'm looking at element 1 now\nI'm looking at element 2 now\nI'm looking at element 3 now\nI'm looking at element 4 now\nI'm looking at element 5 now\nI'm looking at element 6 now\nI'm looking at element 7 now\nI'm looking at element 8 now\nI'm looking at element 9 now\nI'm looking at element 10 now\n- : unit = ()\n```\n\n`List.iter` is in fact what you should think about using first every\ntime your cerebellum suggests you use a for loop.\n\nIf you want to *transform* each element separately in the list - for\nexample, doubling each element in the list - then use `List.map`.\n\n```ocaml\n# List.map (( * ) 2) my_list\n- : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]\n```\n\nThe function `List.filter` collects only those elements of a list which satisfy\nsome condition - e.g. returning all even numbers in a list.\n\n```ocaml\n# let is_even i =\n    i mod 2 = 0\n  in\n    List.filter is_even my_list\n- : int list = [2; 4; 6; 8; 10]\n```\n\nTo find out if a list contains some element, use `List.mem` (short for\nmember):\n\n```ocaml\n# List.mem 12 my_list\n- : bool = false\n```\n\n`List.for_all` and `List.exists` are the same as the \"forall\" and\n\"exist\" operators in predicate logic.\n\nFor operating over two lists at the same time, there are \"-2\" variants\nof some of these functions, namely `iter2`, `map2`, `for_all2`,\n`exists2`.\n\nThe `map` and `filter` functions operate on individual list elements in\nisolation. **Fold** is a more unusual operation that is best\nthought about as \"inserting an operator between each element of the\nlist\". Suppose I wanted to add all the numbers in my list together. In\nhand-waving terms what I want to do is insert a plus sign between the\nelements in my list:\n\n```ocaml\n# 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10\n- : int = 55\n```\n\nThe fold operation does this, although the exact details are a little\nbit more tricky. First of all, what happens if I try to fold an empty\nlist? In the case of summing the list it would be nice if the answer was\nzero, instead of error. However if I was trying to find the product of\nthe list, I'd like the answer to be one instead. So I obviously have to\nprovide some sort of \"default\" argument to my fold. The second issue\ndoesn't arise with simple operators like `+` and `*`: what happens if\nthe operator I'm using isn't associative, ie. (a *op* b) *op* c not\nequal to a *op* (b *op* c)? In that case it would matter if I started\nfrom the left hand end of the list and worked right, versus if I started\nfrom the right and worked left. For this reason there are two versions\nof fold, called `List.fold_left` (works left to right) and\n`List.fold_right` (works right to left, and is also less efficient).\n\nLet's use `List.fold_left` to define `sum` and `product` functions for\ninteger lists:\n\n```ocaml\n# let sum = List.fold_left ( + ) 0\nval sum : int list -\u003e int = \u003cfun\u003e\n# let product = List.fold_left ( * ) 1\nval product : int list -\u003e int = \u003cfun\u003e\n# sum my_list\n- : int = 55\n# product my_list\n- : int = 3628800\n```\n\nThat was easy! Notice that I've accidentally come up with a way to do\nmathematical factorials:\n\n```ocaml\n# let fact n = product (range 1 n)\nval fact : int -\u003e int = \u003cfun\u003e\n# fact 10\n- : int = 3628800\n```\n\n(Notice that this factorial function isn't very useful because it\noverflows the integers and gives wrong answers even for quite small\nvalues of `n`.)\n\n## Looping over strings\nThe `String` module also contains many dozens of useful string-related\nfunctions, and some of them are concerned with looping over strings.\n\n`String.copy` copies a string, like `strdup`. There is also a `String.iter`\nfunction which works like `List.iter`, except over the characters of the\nstring.\n\n## Recursion\nNow we come to a hard topic - recursion. Functional programmers are\ndefined by their love of recursive functions, and in many ways recursive\nfunctions in f.p. are the equivalent of loops in imperative programming.\nIn functional languages loops are second-class citizens, whilst\nrecursive functions get all the best support.\n\nWriting recursive functions requires a change in mindset from writing\nfor loops and while loops. So what I'll give you in this section will be\njust an introduction and examples.\n\nIn the first example we're going to read the whole of a file into memory\n(into a long string). There are essentially three possible approaches to\nthis:\n\n###  Approach 1\nGet the length of the file, and read it all in one go using the\n`really_input` method. This is the simplest, but it might not work on\nchannels which are not really files (eg. reading keyboard input) which\nis why we look at the other two approaches.\n\n###  Approach 2\nThe imperative approach, using a while loop which is broken out of using\nan exception.\n\n###  Approach 3\nA recursive loop, breaking out of the recursion again using an\nexception.\n\nWe're going to introduce a few new concepts here. Our second two\napproaches will use the `Buffer` module - an expandable buffer which you\ncan think of like a string onto which you can efficiently append more\ntext at the end. We're also going to be catching the `End_of_file`\nexception which the input functions throw when they reach the end of the\ninput. Also we're going to use `Sys.argv.(1)` to get the first command\nline parameter.\n\n```ocaml\n(* Read whole file: Approach 1 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let len = in_channel_length chan in\n  let result = (Bytes.create len) in\n    really_input chan result 0 len;\n    (Bytes.to_string result)\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n    printf \"I read %d characters from %s\\n\" (String.length str) filename\n```\n\nApproach 1 works but is not very satisfactory because `read_whole_chan`\nwon't work on non-file channels like keyboard input or sockets. Approach\n2 involves a while loop:\n\n```ocaml\n(* Read whole file: Approach 2 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let buf = Buffer.create 4096 in\n  try\n    while true do\n      let line = input_line chan in\n        Buffer.add_string buf line;\n        Buffer.add_char buf '\\n'\n    done;\n    assert false (* This is never executed\n\t                (always raises Assert_failure). *)\n  with\n    End_of_file -\u003e Buffer.contents buf\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n    printf \"I read %d characters from %s\\n\" (String.length str) filename\n```\n\nThe key to approach 2 is to look at the central while loop. Remember\nthat I said the only way to break out of a while loop early was with an\nexception? This is exactly what we're doing here. Although I haven't\ncovered exceptions yet, you probably won't have any trouble\nunderstanding the `End_of_file` exception thrown in the code above by\n`input_line` when it hits the end of the file. The buffer `buf`\naccumulates the contents of the file, and when we hit the end of the\nfile we return it (`Buffer.contents buf`).\n\nOne curious point about this is the apparently superfluous statement\n(`assert false`) just after the while loop. What is it for?  Remember\nthat while loops, like for loops, are just expressions, and they return\nthe `unit` object (`()`). However OCaml demands that the return type\ninside a `try` matches the return type of each caught exception. In this\ncase because `End_of_file` results in a `string`, the main body of the\n`try` must also \"return\" a string  even though because of the infinite\nwhile loop the string could never actually be returned.  `assert false`\nhas a polymorphic type, so will unify with whatever value is returned\nby the `with` branch.\n\nHere's our recursive version. Notice that it's *shorter* than approach\n2, but not so easy to understand for imperative programmers at least:\n\n```ocaml\n(* Read whole file: Approach 3 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let buf = Buffer.create 4096 in\n  let rec loop () =\n    let line = input_line chan in\n      Buffer.add_string buf line;\n      Buffer.add_char buf '\\n';\n      loop ()\n  in\n    try loop () with\n      End_of_file -\u003e Buffer.contents buf\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n  printf \"I read %d characters from %s\\n\" (String.length str) filename\n```\n\nAgain we have an infinite loop - but in this case done using recursion.\n`loop` calls itself at the end of the function. The infinite recursion\nis broken when `input_line` throws an `End_of_file` exception.\n\nIt looks like approach 3 might overflow the stack if you gave it a\nparticularly large file, but this is in fact not the case. Because of\ntail recursion (discussed below) the compiler will turn the recursive\n`loop` function into a real while loop (!) which runs in constant stack\nspace.\n\nIn the next example we will show how recursion is great for constructing\nor examining certain types of data structures, particularly trees. Let's\nhave a recursive type to represent files in a filesystem:\n\n```ocaml\n# type filesystem = File of string | Directory of filesystem list\ntype filesystem = File of string | Directory of filesystem list\n```\n\nThe `opendir` and `readdir` functions are used to open a directory and\nread elements from the directory. I'm going to define a handy\n`readdir_no_ex` function which hides the annoying `End_of_file`\nexception that `readdir` throws when it reaches the end of the\ndirectory:\n\n```ocaml\n# #load \"unix.cma\"\n# open Unix\n# let readdir_no_ex dirh =\n  try\n    Some (readdir dirh)\n  with\n    End_of_file -\u003e None\nval readdir_no_ex : dir_handle -\u003e string option = \u003cfun\u003e\n```\nThe type of `readdir_no_ex` is this. Recall our earlier discussion about\nnull pointers.\n\n```ocaml\n# readdir_no_ex\n- : dir_handle -\u003e string option = \u003cfun\u003e\n```\n\nI'm also going to define a simple recursive function which I can use to\nconvert the `filesystem` type into a string for (eg) printing:\n\n```ocaml\n# let rec string_of_filesystem fs =\n  match fs with\n  | File filename -\u003e filename ^ \"\\n\"\n  | Directory fs_list -\u003e\n      List.fold_left (^) \"\" (List.map string_of_filesystem fs_list)\nval string_of_filesystem : filesystem -\u003e string = \u003cfun\u003e\n```\n\nNote the use of `fold_left` and `map`. The `map` is used to\n(recursively) convert each `filesystem` in the list into a `string`.\nThen the `fold_left (^) \"\"` concatenates the list together into one big\nstring. Notice also the use of pattern matching. (The library defines a\nfunction called `String.concat` which is essentially equivalent to\n`fold_left (^) `, but implemented more efficiently).\n\nNow let's define a function to read a directory structure, recursively,\nand return a recursive `filesystem` data structure. I'm going to show\nthis function in steps, but I'll print out the entire function at the\nend of this section. First the outline of the function:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec read_directory path =\n  let dirh = opendir path in\n  let rec loop () =\n    (* ..... *) in\n  Directory (loop ())\n```\n\nThe call to `opendir` opens up the given path and returns a `dir_handle`\nfrom which we will be able to read the names using `readdir_no_ex`\nlater. The return value of the function is going to be a\n`Directory fs_list`, so all we need to do to complete the function is to\nwrite our function `loop` which returns a list of `filesystem`s. The\ntype of `loop` will be:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nloop : unit -\u003e filesystem list\n```\n\nHow do we define loop? Let's take it in steps again.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec loop () =\n  let filename = readdir_no_ex dirh in\n  (* ..... *)\n```\n\nFirst we read the next filename from the directory handle. `filename`\nhas type `string option`, in other words it could be `None` or\n`Some \"foo\"` where `foo` is the name of the next filename in the\ndirectory. We also need to ignore the `\".\"` and `\"..\"` files (ie. the\ncurrent directory and the parent directory). We can do all this with a\nnice pattern match:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec loop () =\n  let filename = readdir_no_ex dirh in\n    match filename with\n    | None -\u003e []\n    | Some \".\" -\u003e loop ()\n    | Some \"..\" -\u003e loop ()\n    | Some filename -\u003e\n        (* ..... *)\n```\n\nThe `None` case is easy. Thinking recursively (!) if `loop` is called\nand we've reached the end of the directory, `loop` needs to return a\nlist of entries - and there's no entries - so it returns the empty list\n(`[]`).\n\nFor `\".\"` and `\"..\"` we just ignore the file and call `loop` again.\n\nWhat do we do when `loop` reads a real filename (the `Some filename`\nmatch below)? Let `pathname` be the full path to the file. We 'stat' the\nfile to see if it's really a directory. If it *is* a directory, we set\n`this` by recursively calling `read_directory` which will return\n`Directory something`. Notice that the overall result of\n`read_directory` is `Directory (loop ())`. If the file is really a file\n(not a directory) then we let `this` be `File pathname`. Then we do\nsomething clever: we return `this :: loop ()`. This is the recursive\ncall to `loop ()` to calculate the remaining directory members (a list),\nto which we prepend `this`.\n\n```ocaml\n# let rec read_directory path =\n  let dirh = opendir path in\n  let rec loop () =\n    let filename = readdir_no_ex dirh in\n      match filename with\n      | None -\u003e []\n      | Some \".\" -\u003e loop ()\n      | Some \"..\" -\u003e loop ()\n      | Some filename -\u003e\n          let pathname = path ^ \"/\" ^ filename in\n          let stat = lstat pathname in\n          let this =\n            if stat.st_kind = S_DIR then\n              read_directory pathname\n            else\n              File pathname\n          in\n            this :: loop ()\n  in\n    Directory (loop ())\nval read_directory : string -\u003e filesystem = \u003cfun\u003e\n```\n\nThat's quite a complex bit of recursion, but although this is a made-up\nexample, it's fairly typical of the complex patterns of recursion found\nin real-world functional programs. The two important lessons to take\naway from this are:\n\n* The use of recursion to build a list:\n\n    \u003c!-- $MDX skip --\u003e\n    ```ocaml\n    let rec loop () =\n      a match or if statement\n      | base case -\u003e []\n      | recursive case -\u003e element :: loop ()\n    ```\n    Compare this to our previous `range` function. The pattern of recursion\n    is exactly the same:\n    \n    ```ocaml\n    # let rec range a b =\n      if a \u003e b then []            (* Base case *)\n      else a :: range (a + 1) b     (* Recursive case *)\n    ```\n\t\n* The use of recursion to build up trees:\n\n    \u003c!-- $MDX skip --\u003e\n    ```ocaml\n    let rec read_directory path =\n      (* blah blah *)\n      if file-is-a-directory then\n        read_directory path-to-file\n      else\n        Leaf file\n    ```\n    All that remains now to make this a working program is a little bit of\n    code to call `read_directory` and display the result:\n    \n    \u003c!-- $MDX skip --\u003e\n    ```ocaml\n    let path = Sys.argv.(1) in\n    let fs = read_directory path in\n    print_endline (string_of_filesystem fs)\n    ```\n\n###  Recursion example: maximum element in a list\nRemember the basic recursion pattern for lists:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec loop () =\n  a match or if statement\n  | base case -\u003e []\n  | recursive case -\u003e element :: loop ()\n```\nThe key here is actually the use of the match / base case / recursive\ncase pattern. In this example - finding the maximum element in a list -\nwe're going to have two base cases and one recursive case. But before I\njump ahead to the code, let's just step back and think about the\nproblem. By thinking about the problem, the solution will appear \"as if\nby magic\" (I promise you :-)\n\nFirst of all, let's be clear that the maximum element of a list is just\nthe biggest one, e.g. the maximum element of the list `[1; 2; 3; 4; 1]`\nis `4`.\n\nAre there any special cases? Yes, there are. What's the maximum element\nof the empty list `[]`? There *isn't one*. If we are passed an empty\nlist, we should throw an error.\n\nWhat's the maximum element of a single element list such as `[4]`?\nThat's easy: it's just the element itself. So `list_max [4]` should\nreturn `4`, or in the general case, `list_max [x]` should return `x`.\n\nWhat's the maximum element of the general list `x :: remainder` (this is\nthe \"cons\" notation for the list, so `remainder` is the tail - also a\nlist)?\n\nThink about this for a while. Suppose you know the maximum element of\n`remainder`, which is, say, `y`. What's the maximum element of\n`x :: remainder`? It depends on whether `x \u003e y` or `x \u003c= y`. If `x` is\nbigger than `y`, then the overall maximum is `x`, whereas conversely if\n`x` is less than `y`, then the overall maximum is `y`.\n\nDoes this really work? Consider `[1; 2; 3; 4; 1]` again. This is\n`1 :: [2; 3; 4; 1]`. Now the maximum element of the remainder,\n`[2; 3; 4; 1]`, is `4`. So now we're interested in `x = 1` and `y = 4`.\nThat head element `x = 1` doesn't matter because `y = 4` is bigger, so\nthe overall maximum of the whole list is `y = 4`.\n\nLet's now code those rules above up, to get a working function:\n\n```ocaml\n# let rec list_max xs =\n  match xs with\n  | [] -\u003e (* empty list: fail *)\n      failwith \"list_max called on empty list\"\n  | [x] -\u003e (* single element list: return the element *)\n      x\n  | x :: remainder -\u003e (* multiple element list: recursive case *)\n      max x (list_max remainder)\nval list_max : 'a list -\u003e 'a = \u003cfun\u003e\n```\nI've added comments so you can see how the rules / special cases we\ndecided upon above really correspond to lines of code.\n\nDoes it work?\n\n```ocaml\n# list_max [1; 2; 3; 4; 1]\n- : int = 4\n# list_max []\nException: Failure \"list_max called on empty list\".\n# list_max [5; 4; 3; 2; 1]\n- : int = 5\n# list_max [5; 4; 3; 2; 1; 100]\n- : int = 100\n```\nNotice how the solution proposed is both (a) very different from the\nimperative for-loop solution, and (b) much more closely tied to the\nproblem specification. Functional programmers will tell you that this is\nbecause the functional style is much higher level than the imperative\nstyle, and therefore better and simpler. Whether you believe them is up\nto you. It's certainly true that it's much simpler to reason logically\nabout the functional version, which is useful if you wanted to formally\nprove that `list_max` is correct (\"correct\" being the mathematical way\nto say that a program is provably bug-free, useful for space shuttles,\nnuclear power plants and higher quality software in general).\n\n###  Tail recursion\nLet's look at the `range` function again for about the twentieth time:\n\n```ocaml\n# let rec range a b =\n  if a \u003e b then []\n  else a :: range (a+1) b\nval range : int -\u003e int -\u003e int list = \u003cfun\u003e\n```\nI'm going to rewrite it slightly to make something about the structure\nof the program clearer (still the same function however):\n\n```ocaml\n# let rec range a b =\n  if a \u003e b then [] else\n    let result = range (a+1) b in\n      a :: result\nval range : int -\u003e int -\u003e int list = \u003cfun\u003e\n```\nLet's call it:\n\n```ocaml\n# List.length (range 1 10)\n- : int = 10\n# List.length (range 1 1000000)\nStack overflow during evaluation (looping recursion?).\n```\nHmmm ... at first sight this looks like a problem with recursive\nprogramming, and hence with the whole of functional programming! If you\nwrite your code recursively instead of iteratively then you necessarily\nrun out of stack space on large inputs, right?\n\nIn fact, wrong. Compilers can perform a simple optimisation on certain\ntypes of recursive functions to turn them into while loops. These\ncertain types of recursive functions therefore run in constant stack\nspace, and with the equivalent efficiency of imperative while loops.\nThese functions are called **tail-recursive functions**.\n\nIn tail-recursive functions, the recursive call happens last of all.\nRemember our `loop ()` functions above? They all had the form:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec loop () =\n  (* do something *)\n  loop ()\n```\nBecause the recursive call to `loop ()` happens as the very last thing,\n`loop` is tail-recursive and the compiler will turn the whole thing into\na while loop.\n\nUnfortunately `range` is not tail-recursive, and the longer version\nabove shows why. The recursive call to `range` doesn't happen as the\nvery last thing. In fact the last thing to happen is the `::` (cons)\noperation. As a result, the compiler doesn't turn the recursion into a\nwhile loop, and the function is not efficient in its use of stack space.\n\nThe use of an accumulating argument or `accumulator` allows one to write\nfunctions such as `range` above in a tail-recursive manner, which means they\nwill be efficient and work properly on large inputs. Let's plan our rewritten\n`range` function which will use an accumulator argument to store the \"result so\nfar\":\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec range2 a b accum =\n  (* ... *)\n  \nlet range a b =\n  range2 a b []\n```\n\nThe `accum` argument is going to accumulate the result. It's the \"result\nso far\". We pass in the empty list (\"no result so far\"). The easy case\nis when `a \u003e b`:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec range2 a b accum =\n  if a \u003e b then accum\n  else\n    (* ... *)\n```\nIf `a \u003e b` (i.e. if we've reached the end of the recursion), then stop\nand return the result (`accum`).\n\nNow the trick is to write the `else`-clause and make sure that the call\nto `range2` is the very last thing that we do, so the function is\ntail-recursive:\n\n```ocaml\n# let rec range2 a b accum =\n  if a \u003e b then accum\n  else range2 (a + 1) b (a :: accum)\nval range2 : int -\u003e int -\u003e int list -\u003e int list = \u003cfun\u003e\n```\nThere's only one slight problem with this function: it constructs the\nlist backwards! However, this is easy to rectify by redefining range as:\n\n```ocaml\n# let range a b = List.rev (range2 a b [])\nval range : int -\u003e int -\u003e int list = \u003cfun\u003e\n```\nIt works this time, although it's a bit slow to run because it really\ndoes have to construct a list with a million elements in it:\n\n```ocaml\n# List.length (range 1 1000000)\n- : int = 1000000\n```\nThe following implementation is twice as fast as the previous one,\nbecause it does not need to reverse a list:\n\n```ocaml\n# let rec range2 a b accum =\n  if b \u003c a then accum\n  else range2 a (b - 1) (b :: accum)\nval range2 : int -\u003e int -\u003e int list -\u003e int list = \u003cfun\u003e\n# let range a b =\n  range2 a b []\nval range : int -\u003e int -\u003e int list = \u003cfun\u003e\n```\nThat was a brief overview of tail recursion, but in real world\nsituations determining if a function is tail recursive can be quite\nhard. What did we really learn here? One thing is that recursive\nfunctions have a dangerous trap for inexperienced programmers. Your\nfunction can appear to work for small inputs (during testing), but fail\ncatastrophically in the field when exposed to large inputs. This is one\nargument *against* using recursive functions, and for using explicit\nwhile loops when possible.\n\n## Mutable records, references (again!) and arrays\nPreviously we mentioned records in passing. These are like C `struct`s:\n\n```ocaml\n# type pair_of_ints = {a : int; b : int}\ntype pair_of_ints = { a : int; b : int; }\n# {a = 3; b = 5}\n- : pair_of_ints = {a = 3; b = 5}\n# {a = 3}\nLine 1, characters 1-8:\nError: Some record fields are undefined: b\n```\n\nOne feature which I didn't cover: OCaml records can have mutable fields.\nNormally an expression like `{a = 3; b = 5}` is an immutable, constant\nobject. However if the record has **mutable fields**, then\nthere is a way to change those fields in the record. This is an\nimperative feature of OCaml, because functional languages don't normally\nallow mutable objects (or references or mutable arrays, which we'll look\nat in a moment).\n\nHere is an object defined with a mutable field. This field is used to\ncount how many times the object has been accessed. You could imagine\nthis being used in a caching scheme to decide which objects you'd evict\nfrom memory.\n\n```ocaml\n# type name = {name : string; mutable access_count : int}\ntype name = { name : string; mutable access_count : int; }\n```\n\nHere is a function defined on names which prints the `name` field and\nincrements the mutable `access_count` field:\n\n```ocaml\n# let print_name name =\n  print_endline (\"The name is \" ^ name.name);\n  name.access_count \u003c- name.access_count + 1\nval print_name : name -\u003e unit = \u003cfun\u003e\n```\n\nNotice a strange, and very non-functional feature of `print_name`: it modifies\nits `access_count` parameter. This function is not \"pure\". OCaml is a\nfunctional language, but not to the extent that it forces functional\nprogramming down your throat.\n\nAnyway, let's see `print_name` in action:\n\n```ocaml\n# let n = {name = \"Richard Jones\"; access_count = 0}\nval n : name = {name = \"Richard Jones\"; access_count = 0}\n# n\n- : name = {name = \"Richard Jones\"; access_count = 0}\n# print_name n\nThe name is Richard Jones\n- : unit = ()\n# n\n- : name = {name = \"Richard Jones\"; access_count = 1}\n# print_name n\nThe name is Richard Jones\n- : unit = ()\n# n\n- : name = {name = \"Richard Jones\"; access_count = 2}\n```\n\nOnly fields explicitly marked as `mutable` can be assigned to using the\n`\u003c-` operator. If you try to assign to a non-mutable field, OCaml won't\nlet you:\n\n```ocaml\n# n.name \u003c- \"John Smith\"\nLine 1, characters 1-23:\nError: The record field name is not mutable\n```\nReferences, with which we should be familiar by now, are implemented\nusing records with a mutable `contents` field. Check out the definition\nin `Stdlib`:\n\n```ocaml\ntype 'a ref = {mutable contents : 'a}\n```\n\nAnd look closely at what the OCaml toplevel prints out for the value of\na reference:\n\n```ocaml\n# let r = ref 100\nval r : int Stdlib.ref = {Stdlib.contents = 100}\n```\n\nArrays are another sort of mutable structure provided by OCaml. In\nOCaml, plain lists are implemented as linked lists, and linked lists are\nslow for some types of operation. For example, getting the head of a\nlist, or iterating over a list to perform some operation on each element\nis reasonably fast. However, jumping to the n\u003csup\u003eth\u003c/sup\u003e element of a\nlist, or trying to randomly access a list - both are slow operations.\nThe OCaml `Array` type is a real array, so random access is fast, but\ninsertion and deletion of elements is slow. `Array`s are also mutable so\nyou can randomly change elements too.\n\nThe basics of arrays are simple:\n\n```ocaml\n# let a = Array.create 10 0\nLine 1, characters 9-21:\nAlert deprecated: Stdlib.Array.create\nUse Array.make instead.\nval a : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]\n# for i = 0 to Array.length a - 1 do\n  a.(i) \u003c- i\nLine 3, characters 1-3:\nError: Syntax error\n# a\n- : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]\n```\nNotice the syntax for writing arrays: `[| element; element; ... |]`\n\nThe OCaml compiler was designed with heavy numerical processing in mind\n(the sort of thing that FORTRAN is traditionally used for), and so it\ncontains various optimisations specifically for arrays of numbers,\nvectors and matrices. Here is some benchmark code for doing dense matrix\nmultiplication. Notice that it uses for-loops and is generally very\nimperative in style:\n\n```ocaml\n# let size = 30\nval size : int = 30\n\n# let mkmatrix rows cols =\n  let count = ref 1\n  and last_col = cols - 1\n  and m = Array.make_matrix rows cols 0 in\n    for i = 0 to rows - 1 do\n      let mi = m.(i) in\n        for j = 0 to last_col do\n          mi.(j) \u003c- !count;\n          incr count\n        done;\n    done;\n    m\nval mkmatrix : int -\u003e int -\u003e int array array = \u003cfun\u003e\n\n# let rec inner_loop k v m1i m2 j =\n  if k \u003c 0 then v\n  else inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j\nval inner_loop : int -\u003e int -\u003e int array -\u003e int array array -\u003e int -\u003e int =\n  \u003cfun\u003e\n\n# let mmult rows cols m1 m2 m3 =\n  let last_col = cols - 1\n  and last_row = rows - 1 in\n    for i = 0 to last_row do\n      let m1i = m1.(i) and m3i = m3.(i) in\n      for j = 0 to last_col do\n        m3i.(j) \u003c- inner_loop last_row 0 m1i m2 j\n      done;\n    done\nval mmult :\n  int -\u003e int -\u003e int array array -\u003e int array array -\u003e int array array -\u003e unit =\n  \u003cfun\u003e\n\n# let () =\n  let n =\n    try int_of_string Sys.argv.(1)\n    with Invalid_argument _ -\u003e 1\n  and m1 = mkmatrix size size\n  and m2 = mkmatrix size size\n  and m3 = Array.make_matrix size size 0 in\n    for i = 1 to n - 1 do\n      mmult size size m1 m2 m3\n    done;\n    mmult size size m1 m2 m3;\n    Printf.printf \"%d %d %d %d\\n\" m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)\nException: Failure \"int_of_string\".\n```\n\n## Mutually recursive functions\nSuppose I want to define two functions which call each other. This is\nactually not a very common thing to do, but it can be useful sometimes.\nHere's a contrived example (thanks to Ryan Tarpine): The number 0 is\neven. Other numbers greater than 0 are even if their predecessor is odd.\nHence:\n\n```ocaml\n# let rec even n =\n  match n with\n  | 0 -\u003e true\n  | x -\u003e odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n```\n\nThe code above doesn't compile because we haven't defined the function\n`odd` yet! That's easy though. Zero is not odd, and other numbers\ngreater than 0 are odd if their predecessor is even. So to make this\ncomplete we need that function too:\n\n```ocaml\n# let rec even n =\n  match n with\n  | 0 -\u003e true\n  | x -\u003e odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n# let rec odd n =\n  match n with\n  | 0 -\u003e false\n  | x -\u003e even (x - 1)\nLine 4, characters 10-14:\nError: Unbound value even\n```\n\nThe only problem is... this program doesn't compile. In order to compile\nthe `even` function, we already need the definition of `odd`, and to\ncompile `odd` we need the definition of `even`. So swapping the two\ndefinitions around won't help either.\n\nThere are no \"forward prototypes\" (as seen in languages descended\nfrom C) in OCaml but there is a special syntax\nfor defining a set of two or more mutually recursive functions, like\n`odd` and `even`:\n\n```ocaml\n# let rec even n =\n  match n with\n  | 0 -\u003e true\n  | x -\u003e odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n```\nYou can also\nuse similar syntax for writing mutually recursive class definitions and\nmodules.\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#if-statements-actually-these-are-if-expressions\"\u003eIf statements (actually, these are if expressions)\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#using-begin--end\"\u003eUsing begin ... end\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#for-loops-and-while-loops\"\u003eFor loops and while loops\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#looping-over-lists\"\u003eLooping over lists\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#looping-over-strings\"\u003eLooping over strings\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#recursion\"\u003eRecursion\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mutable-records-references-again-and-arrays\"\u003eMutable records, references (again!) and arrays\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mutually-recursive-functions\"\u003eMutually recursive functions\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"if-statements-actually-these-are-if-expressions\"\u003eIf statements (actually, these are if expressions)\u003c/h2\u003e\n\u003cp\u003eOCaml has an \u003ccode\u003eif\u003c/code\u003e statement with two variations, and the obvious meaning:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif boolean-condition then expression\n  \nif boolean-condition then expression else other-expression\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-mdx-error\"\u003eLine 3, characters 3-5:\nError: Syntax error\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnlike in the conventional languages you'll be used to, \u003ccode\u003eif\u003c/code\u003e statements\nare really expressions. In other words, they're much more like\n\u003ccode\u003eboolean-condition ? expression : other-expression\u003c/code\u003e in C than like the if\nstatements you may be used to.\u003c/p\u003e\n\u003cp\u003eHere's a simple example of an \u003ccode\u003eif\u003c/code\u003e statement:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let max a b =\n  if a \u0026gt; b then a else b\nval max : 'a -\u0026gt; 'a -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs a short aside, if you type this into the OCaml\ninteractive toplevel (as above), you'll\nnotice that OCaml decides that this function is polymorphic, with the\nfollowing type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# max\n- : 'a -\u0026gt; 'a -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd indeed OCaml lets you use \u003ccode\u003emax\u003c/code\u003e on any type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# max 3 5\n- : int = 5\n# max 3.5 13.0\n- : float = 13.\n# max \u0026quot;a\u0026quot; \u0026quot;b\u0026quot;\n- : string = \u0026quot;b\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is because \u003ccode\u003e\u0026gt;\u003c/code\u003e is in fact polymorphic. It works on any type, even\nobjects (it does a binary comparison).\u003c/p\u003e\n\u003cp\u003e[Note that the \u003ccode\u003eStdlib\u003c/code\u003e module defines \u003ccode\u003emin\u003c/code\u003e and \u003ccode\u003emax\u003c/code\u003e for you.]\u003c/p\u003e\n\u003cp\u003eLet's look a bit more closely at the \u003ccode\u003eif\u003c/code\u003e expression. Here's the \u003ccode\u003erange\u003c/code\u003e\nfunction which I showed you earlier without much explanation. You should\nbe able to combine your knowledge of recursive functions, lists and if\nexpressions to see what it does:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range a b =\n    if a \u0026gt; b then []\n    else a :: range (a + 1) b\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's examine some typical calls to this function. Let's start with the\neasy case of \u003ccode\u003ea \u0026gt; b\u003c/code\u003e. A call to \u003ccode\u003erange 11 10\u003c/code\u003e returns \u003ccode\u003e[]\u003c/code\u003e (the empty\nlist) and that's it.\u003c/p\u003e\n\u003cp\u003eWhat about calling \u003ccode\u003erange 10 10\u003c/code\u003e? Since \u003ccode\u003e10 \u0026gt; 10\u003c/code\u003e is false, the\n\u003ccode\u003eelse\u003c/code\u003e-clause is evaluated, which is: \u003ccode\u003e10 :: (range 11 10)\u003c/code\u003e (I've added\nthe brackets to make the order of evaluation more clear). We've just\nworked out that \u003ccode\u003erange 11 10\u003c/code\u003e = \u003ccode\u003e[]\u003c/code\u003e, so this is: \u003ccode\u003e10 :: []\u003c/code\u003e. Remember\nour formal description of lists and the \u003ccode\u003e::\u003c/code\u003e (cons) operator? \u003ccode\u003e10 :: []\u003c/code\u003e\nis just the same as \u003ccode\u003e[10]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLet's try \u003ccode\u003erange 9 10\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003erange 9 10\n 9 :: (range 10 10)\n 9 :: [10]\n [9; 10]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt should be fairly clear that \u003ccode\u003erange 1 10\u003c/code\u003e evaluates to\n\u003ccode\u003e[1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhat we've got here is a simple case of recursion. Functional\nprogramming can be said to prefer recursion over loops, but I'm jumping\nahead of myself. We'll discuss recursion more at the end of this\nchapter.\u003c/p\u003e\n\u003cp\u003eBack, temporarily, to \u003ccode\u003eif\u003c/code\u003e statements. What does this function do?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let f x y =\n    x + if y \u0026gt; 0 then y else 0\nval f : int -\u0026gt; int -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eClue: add brackets around the whole of the if expression. It clips \u003ccode\u003ey\u003c/code\u003e\nlike an \u003ca href=\"https://en.wikipedia.org/wiki/Diode#Current.E2.80.93voltage_characteristic\"\u003eelectronic diode\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eabs\u003c/code\u003e (absolute value) function is defined in \u003ccode\u003eStdlib\u003c/code\u003e as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let abs x =\n    if x \u0026gt;= 0 then x else -x\nval abs : int -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlso in \u003ccode\u003eStdlib\u003c/code\u003e, the \u003ccode\u003estring_of_float\u003c/code\u003e function contains a complex\npair of nested \u003ccode\u003eif\u003c/code\u003e expressions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let string_of_float f =\n  let s = format_float \u0026quot;%.12g\u0026quot; f in\n  let l = string_length s in\n  let rec loop i =\n    if i \u0026gt;= l then s ^ \u0026quot;.\u0026quot;\n    else if s.[i] = '.' || s.[i] = 'e' then s\n    else loop (i + 1)\n  in\n    loop 0\nLine 2, characters 11-23:\nError: Unbound value format_float\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's examine this function. Suppose the function is called with \u003ccode\u003ef\u003c/code\u003e =\n12.34. Then \u003ccode\u003es\u003c/code\u003e = \u0026quot;12.34\u0026quot;, and \u003ccode\u003el\u003c/code\u003e = 5. We call \u003ccode\u003eloop\u003c/code\u003e the first time\nwith \u003ccode\u003ei\u003c/code\u003e = 0.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ei\u003c/code\u003e is not greater than or equal to \u003ccode\u003el\u003c/code\u003e, and \u003ccode\u003es.[i]\u003c/code\u003e (the\n\u003ccode\u003ei\u003c/code\u003e\u003csup\u003eth\u003c/sup\u003e character in \u003ccode\u003es\u003c/code\u003e) is not a period or \u003ccode\u003e'e'\u003c/code\u003e. So\n\u003ccode\u003eloop (i + 1)\u003c/code\u003e is called, ie. \u003ccode\u003eloop 1\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe go through the same dance for \u003ccode\u003ei\u003c/code\u003e = 1, and end up calling \u003ccode\u003eloop 2\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor \u003ccode\u003ei\u003c/code\u003e = 2, however, \u003ccode\u003es.[i]\u003c/code\u003e is a period (refer to the original string,\n\u003ccode\u003es\u003c/code\u003e = \u0026quot;12.34\u0026quot;). So this immediately returns \u003ccode\u003es\u003c/code\u003e, and the function\n\u003ccode\u003estring_of_float\u003c/code\u003e returns \u0026quot;12.34\u0026quot;.\u003c/p\u003e\n\u003cp\u003eWhat is \u003ccode\u003eloop\u003c/code\u003e doing? In fact it's checking whether the string returned\nfrom \u003ccode\u003eformat_float\u003c/code\u003e contains a period (or \u003ccode\u003e'e'\u003c/code\u003e). Suppose that we called\n\u003ccode\u003estring_of_float\u003c/code\u003e with \u003ccode\u003e12.0\u003c/code\u003e. \u003ccode\u003eformat_float\u003c/code\u003e would return the string\n\u0026quot;12\u0026quot;, but \u003ccode\u003estring_of_float\u003c/code\u003e must return \u0026quot;12.\u0026quot; or \u0026quot;12.0\u0026quot; (because\nfloating point constants in OCaml must contain a period to differentiate\nthem from integer constants). Hence the check.\u003c/p\u003e\n\u003cp\u003eThe strange use of recursion in this function is almost certainly for\nefficiency. OCaml supports for loops, so why didn't the authors use for\nloops? We'll see in the next section that OCaml's for loops are limited\nin a way which prevents them from being used in \u003ccode\u003estring_of_float\u003c/code\u003e. Here,\nhowever, is a more straightforward, but approximately twice as slow, way\nof writing \u003ccode\u003estring_of_float\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let string_of_float f =\n  let s = format_float \u0026quot;%.12g\u0026quot; f in\n    if String.contains s '.' || String.contains s 'e'\n      then s\n      else s ^ \u0026quot;.\u0026quot;\nLine 2, characters 11-23:\nError: Unbound value format_float\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"using-begin--end\"\u003eUsing begin ... end\u003c/h2\u003e\n\u003cp\u003eHere is some code from lablgtk:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif GtkBase.Object.is_a obj cls then\n  fun _ -\u0026gt; f obj\nelse begin\n  eprintf \u0026quot;Glade-warning: %s expects a %s argument.\\n\u0026quot; name cls;\n  raise Not_found\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebegin\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e are what is known as \u003cstrong\u003esyntactic sugar\u003c/strong\u003e for open and\nclose parentheses. In the example above, all they do is group the two\nstatements in the \u003ccode\u003eelse\u003c/code\u003e-clause together. Suppose the author had written\nthis instead:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif GtkBase.Object.is_a obj cls then\n  fun _ -\u0026gt; f obj\nelse\n  eprintf \u0026quot;Glade-warning: %s expects a %s argument.\\n\u0026quot; name cls;\n  raise Not_found\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFully bracketing and properly indenting the above expression gives:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(if GtkBase.Object.is_a obj cls then\n   fun _ -\u0026gt; f obj\n else\n   eprintf \u0026quot;Glade-warning: %s expects a %s argument.\\n\u0026quot; name cls\n);\nraise Not_found\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNot what was intended at all. So the \u003ccode\u003ebegin\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e are necessary to\ngroup together multiple statements in a \u003ccode\u003ethen\u003c/code\u003e or \u003ccode\u003eelse\u003c/code\u003e clause of an if\nexpression. You can also use plain ordinary parentheses \u003ccode\u003e( ... )\u003c/code\u003e if you\nprefer (and I do prefer, because I \u003cstrong\u003eloathe\u003c/strong\u003e Pascal :-). Here are two\nsimple examples:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# if 1 = 0 then\n    print_endline \u0026quot;THEN\u0026quot;\n  else begin\n    print_endline \u0026quot;ELSE\u0026quot;;\n    failwith \u0026quot;else clause\u0026quot;\n  end\nException: Failure \u0026quot;else clause\u0026quot;.\nELSE\n# if 1 = 0 then\n    print_endline \u0026quot;THEN\u0026quot;\n  else (\n    print_endline \u0026quot;ELSE\u0026quot;;\n    failwith \u0026quot;else clause\u0026quot;\n  )\nException: Failure \u0026quot;else clause\u0026quot;.\nELSE\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"for-loops-and-while-loops\"\u003eFor loops and while loops\u003c/h2\u003e\n\u003cp\u003eOCaml supports a rather limited form of the familiar \u003ccode\u003efor\u003c/code\u003e loop:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003efor variable = start_value to end_value do\n  expression\ndone\n  \nfor variable = start_value downto end_value do\n  expression\ndone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA simple but real example from lablgtk:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003efor i = 1 to n_jobs () do\n  do_next_job ()\ndone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn OCaml, \u003ccode\u003efor\u003c/code\u003e loops are just shorthand for writing:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet i = 1 in\ndo_next_job ();\nlet i = 2 in\ndo_next_job ();\nlet i = 3 in\ndo_next_job ();\n  ...\nlet i = n_jobs () in\ndo_next_job ();\n()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOCaml doesn't support the concept of breaking out of a \u003ccode\u003efor\u003c/code\u003e loop early\ni.e. it has no \u003ccode\u003ebreak\u003c/code\u003e, \u003ccode\u003econtinue\u003c/code\u003e or \u003ccode\u003elast\u003c/code\u003e statements. (You \u003cem\u003ecould\u003c/em\u003e\nthrow an exception and catch it outside, and this would run fast but\noften looks clumsy.)\u003c/p\u003e\n\u003cp\u003eThe expression inside an OCaml for loop should evaluate to \u003ccode\u003eunit\u003c/code\u003e\n(otherwise you'll get a warning), and the for loop expression as a whole\nreturns \u003ccode\u003eunit\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# for i = 1 to 10 do i done\nLine 1, characters 20-21:\nWarning 10: this expression should have type unit.\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFunctional programmers tend to use recursion instead of explicit loops,\nand regard \u003cstrong\u003efor\u003c/strong\u003e loops with suspicion since it can't return anything,\nhence OCaml's relatively powerless \u003cstrong\u003efor\u003c/strong\u003e loop. We talk about recursion\nbelow.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhile loops\u003c/strong\u003e in OCaml are written:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ewhile boolean-condition do\n  expression\ndone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs with for loops, there is no way provided by the language to break out\nof a while loop, except by throwing an exception, and this means that\nwhile loops have fairly limited use. Again, remember that functional\nprogrammers like recursion, and so while loops are second-class citizens\nin the language.\u003c/p\u003e\n\u003cp\u003eIf you stop to consider while loops, you may see that they aren't really\nany use at all, except in conjunction with our old friend references.\nLet's imagine that OCaml didn't have references for a moment:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet quit_loop = false in\n  while not quit_loop do\n    print_string \u0026quot;Have you had enough yet? (y/n) \u0026quot;;\n    let str = read_line () in\n      if str.[0] = 'y' then\n        (* how do I set quit_loop to true ?!? *)\n  done\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRemember that \u003ccode\u003equit_loop\u003c/code\u003e is not a real \u0026quot;variable\u0026quot; - the let-binding\njust makes \u003ccode\u003equit_loop\u003c/code\u003e a shorthand for \u003ccode\u003efalse\u003c/code\u003e. This means the while\nloop condition (shown in red) is always true, and the loop runs on\nforever!\u003c/p\u003e\n\u003cp\u003eLuckily OCaml \u003cem\u003edoes have\u003c/em\u003e references, so we can write the code above if\nwe want. Don't get confused and think that the \u003ccode\u003e!\u003c/code\u003e (exclamation mark)\nmeans \u0026quot;not\u0026quot; as in C/Java. It's used here to mean \u0026quot;dereference the\npointer\u0026quot;, similar in fact to Forth. You're better off reading \u003ccode\u003e!\u003c/code\u003e as\n\u0026quot;get\u0026quot; or \u0026quot;deref\u0026quot;.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet quit_loop = ref false in\n  while not !quit_loop do\n    print_string \u0026quot;Have you had enough yet? (y/n) \u0026quot;;\n    let str = read_line () in\n      if str.[0] = 'y' then quit_loop := true\n  done;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"looping-over-lists\"\u003eLooping over lists\u003c/h2\u003e\n\u003cp\u003eIf you want to loop over a list, don't be an imperative programmer and\nreach for your trusty six-shooter Mr. For Loop! OCaml has some better\nand faster ways to loop over lists, and they are all located in the\n\u003ccode\u003eList\u003c/code\u003e module. There are in fact dozens of good functions in \u003ccode\u003eList\u003c/code\u003e, but\nI'll only talk about the most useful ones here.\u003c/p\u003e\n\u003cp\u003eFirst off, let's define a list for us to use:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let my_list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\nval my_list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you want to call a function once on every element of the list, use\n\u003ccode\u003eList.iter\u003c/code\u003e, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let f elem =\n    Printf.printf \u0026quot;I'm looking at element %d now\\n\u0026quot; elem\n  in\n    List.iter f my_list\nI'm looking at element 1 now\nI'm looking at element 2 now\nI'm looking at element 3 now\nI'm looking at element 4 now\nI'm looking at element 5 now\nI'm looking at element 6 now\nI'm looking at element 7 now\nI'm looking at element 8 now\nI'm looking at element 9 now\nI'm looking at element 10 now\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eList.iter\u003c/code\u003e is in fact what you should think about using first every\ntime your cerebellum suggests you use a for loop.\u003c/p\u003e\n\u003cp\u003eIf you want to \u003cem\u003etransform\u003c/em\u003e each element separately in the list - for\nexample, doubling each element in the list - then use \u003ccode\u003eList.map\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# List.map (( * ) 2) my_list\n- : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe function \u003ccode\u003eList.filter\u003c/code\u003e collects only those elements of a list which satisfy\nsome condition - e.g. returning all even numbers in a list.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let is_even i =\n    i mod 2 = 0\n  in\n    List.filter is_even my_list\n- : int list = [2; 4; 6; 8; 10]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo find out if a list contains some element, use \u003ccode\u003eList.mem\u003c/code\u003e (short for\nmember):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# List.mem 12 my_list\n- : bool = false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eList.for_all\u003c/code\u003e and \u003ccode\u003eList.exists\u003c/code\u003e are the same as the \u0026quot;forall\u0026quot; and\n\u0026quot;exist\u0026quot; operators in predicate logic.\u003c/p\u003e\n\u003cp\u003eFor operating over two lists at the same time, there are \u0026quot;-2\u0026quot; variants\nof some of these functions, namely \u003ccode\u003eiter2\u003c/code\u003e, \u003ccode\u003emap2\u003c/code\u003e, \u003ccode\u003efor_all2\u003c/code\u003e,\n\u003ccode\u003eexists2\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003emap\u003c/code\u003e and \u003ccode\u003efilter\u003c/code\u003e functions operate on individual list elements in\nisolation. \u003cstrong\u003eFold\u003c/strong\u003e is a more unusual operation that is best\nthought about as \u0026quot;inserting an operator between each element of the\nlist\u0026quot;. Suppose I wanted to add all the numbers in my list together. In\nhand-waving terms what I want to do is insert a plus sign between the\nelements in my list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10\n- : int = 55\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe fold operation does this, although the exact details are a little\nbit more tricky. First of all, what happens if I try to fold an empty\nlist? In the case of summing the list it would be nice if the answer was\nzero, instead of error. However if I was trying to find the product of\nthe list, I'd like the answer to be one instead. So I obviously have to\nprovide some sort of \u0026quot;default\u0026quot; argument to my fold. The second issue\ndoesn't arise with simple operators like \u003ccode\u003e+\u003c/code\u003e and \u003ccode\u003e*\u003c/code\u003e: what happens if\nthe operator I'm using isn't associative, ie. (a \u003cem\u003eop\u003c/em\u003e b) \u003cem\u003eop\u003c/em\u003e c not\nequal to a \u003cem\u003eop\u003c/em\u003e (b \u003cem\u003eop\u003c/em\u003e c)? In that case it would matter if I started\nfrom the left hand end of the list and worked right, versus if I started\nfrom the right and worked left. For this reason there are two versions\nof fold, called \u003ccode\u003eList.fold_left\u003c/code\u003e (works left to right) and\n\u003ccode\u003eList.fold_right\u003c/code\u003e (works right to left, and is also less efficient).\u003c/p\u003e\n\u003cp\u003eLet's use \u003ccode\u003eList.fold_left\u003c/code\u003e to define \u003ccode\u003esum\u003c/code\u003e and \u003ccode\u003eproduct\u003c/code\u003e functions for\ninteger lists:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let sum = List.fold_left ( + ) 0\nval sum : int list -\u0026gt; int = \u0026lt;fun\u0026gt;\n# let product = List.fold_left ( * ) 1\nval product : int list -\u0026gt; int = \u0026lt;fun\u0026gt;\n# sum my_list\n- : int = 55\n# product my_list\n- : int = 3628800\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat was easy! Notice that I've accidentally come up with a way to do\nmathematical factorials:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let fact n = product (range 1 n)\nval fact : int -\u0026gt; int = \u0026lt;fun\u0026gt;\n# fact 10\n- : int = 3628800\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Notice that this factorial function isn't very useful because it\noverflows the integers and gives wrong answers even for quite small\nvalues of \u003ccode\u003en\u003c/code\u003e.)\u003c/p\u003e\n\u003ch2 id=\"looping-over-strings\"\u003eLooping over strings\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eString\u003c/code\u003e module also contains many dozens of useful string-related\nfunctions, and some of them are concerned with looping over strings.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eString.copy\u003c/code\u003e copies a string, like \u003ccode\u003estrdup\u003c/code\u003e. There is also a \u003ccode\u003eString.iter\u003c/code\u003e\nfunction which works like \u003ccode\u003eList.iter\u003c/code\u003e, except over the characters of the\nstring.\u003c/p\u003e\n\u003ch2 id=\"recursion\"\u003eRecursion\u003c/h2\u003e\n\u003cp\u003eNow we come to a hard topic - recursion. Functional programmers are\ndefined by their love of recursive functions, and in many ways recursive\nfunctions in f.p. are the equivalent of loops in imperative programming.\nIn functional languages loops are second-class citizens, whilst\nrecursive functions get all the best support.\u003c/p\u003e\n\u003cp\u003eWriting recursive functions requires a change in mindset from writing\nfor loops and while loops. So what I'll give you in this section will be\njust an introduction and examples.\u003c/p\u003e\n\u003cp\u003eIn the first example we're going to read the whole of a file into memory\n(into a long string). There are essentially three possible approaches to\nthis:\u003c/p\u003e\n\u003ch3 id=\"approach-1\"\u003eApproach 1\u003c/h3\u003e\n\u003cp\u003eGet the length of the file, and read it all in one go using the\n\u003ccode\u003ereally_input\u003c/code\u003e method. This is the simplest, but it might not work on\nchannels which are not really files (eg. reading keyboard input) which\nis why we look at the other two approaches.\u003c/p\u003e\n\u003ch3 id=\"approach-2\"\u003eApproach 2\u003c/h3\u003e\n\u003cp\u003eThe imperative approach, using a while loop which is broken out of using\nan exception.\u003c/p\u003e\n\u003ch3 id=\"approach-3\"\u003eApproach 3\u003c/h3\u003e\n\u003cp\u003eA recursive loop, breaking out of the recursion again using an\nexception.\u003c/p\u003e\n\u003cp\u003eWe're going to introduce a few new concepts here. Our second two\napproaches will use the \u003ccode\u003eBuffer\u003c/code\u003e module - an expandable buffer which you\ncan think of like a string onto which you can efficiently append more\ntext at the end. We're also going to be catching the \u003ccode\u003eEnd_of_file\u003c/code\u003e\nexception which the input functions throw when they reach the end of the\ninput. Also we're going to use \u003ccode\u003eSys.argv.(1)\u003c/code\u003e to get the first command\nline parameter.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Read whole file: Approach 1 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let len = in_channel_length chan in\n  let result = (Bytes.create len) in\n    really_input chan result 0 len;\n    (Bytes.to_string result)\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n    printf \u0026quot;I read %d characters from %s\\n\u0026quot; (String.length str) filename\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eApproach 1 works but is not very satisfactory because \u003ccode\u003eread_whole_chan\u003c/code\u003e\nwon't work on non-file channels like keyboard input or sockets. Approach\n2 involves a while loop:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Read whole file: Approach 2 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let buf = Buffer.create 4096 in\n  try\n    while true do\n      let line = input_line chan in\n        Buffer.add_string buf line;\n        Buffer.add_char buf '\\n'\n    done;\n    assert false (* This is never executed\n\t                (always raises Assert_failure). *)\n  with\n    End_of_file -\u0026gt; Buffer.contents buf\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n    printf \u0026quot;I read %d characters from %s\\n\u0026quot; (String.length str) filename\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe key to approach 2 is to look at the central while loop. Remember\nthat I said the only way to break out of a while loop early was with an\nexception? This is exactly what we're doing here. Although I haven't\ncovered exceptions yet, you probably won't have any trouble\nunderstanding the \u003ccode\u003eEnd_of_file\u003c/code\u003e exception thrown in the code above by\n\u003ccode\u003einput_line\u003c/code\u003e when it hits the end of the file. The buffer \u003ccode\u003ebuf\u003c/code\u003e\naccumulates the contents of the file, and when we hit the end of the\nfile we return it (\u003ccode\u003eBuffer.contents buf\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eOne curious point about this is the apparently superfluous statement\n(\u003ccode\u003eassert false\u003c/code\u003e) just after the while loop. What is it for?  Remember\nthat while loops, like for loops, are just expressions, and they return\nthe \u003ccode\u003eunit\u003c/code\u003e object (\u003ccode\u003e()\u003c/code\u003e). However OCaml demands that the return type\ninside a \u003ccode\u003etry\u003c/code\u003e matches the return type of each caught exception. In this\ncase because \u003ccode\u003eEnd_of_file\u003c/code\u003e results in a \u003ccode\u003estring\u003c/code\u003e, the main body of the\n\u003ccode\u003etry\u003c/code\u003e must also \u0026quot;return\u0026quot; a string  even though because of the infinite\nwhile loop the string could never actually be returned.  \u003ccode\u003eassert false\u003c/code\u003e\nhas a polymorphic type, so will unify with whatever value is returned\nby the \u003ccode\u003ewith\u003c/code\u003e branch.\u003c/p\u003e\n\u003cp\u003eHere's our recursive version. Notice that it's \u003cem\u003eshorter\u003c/em\u003e than approach\n2, but not so easy to understand for imperative programmers at least:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Read whole file: Approach 3 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let buf = Buffer.create 4096 in\n  let rec loop () =\n    let line = input_line chan in\n      Buffer.add_string buf line;\n      Buffer.add_char buf '\\n';\n      loop ()\n  in\n    try loop () with\n      End_of_file -\u0026gt; Buffer.contents buf\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n  printf \u0026quot;I read %d characters from %s\\n\u0026quot; (String.length str) filename\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgain we have an infinite loop - but in this case done using recursion.\n\u003ccode\u003eloop\u003c/code\u003e calls itself at the end of the function. The infinite recursion\nis broken when \u003ccode\u003einput_line\u003c/code\u003e throws an \u003ccode\u003eEnd_of_file\u003c/code\u003e exception.\u003c/p\u003e\n\u003cp\u003eIt looks like approach 3 might overflow the stack if you gave it a\nparticularly large file, but this is in fact not the case. Because of\ntail recursion (discussed below) the compiler will turn the recursive\n\u003ccode\u003eloop\u003c/code\u003e function into a real while loop (!) which runs in constant stack\nspace.\u003c/p\u003e\n\u003cp\u003eIn the next example we will show how recursion is great for constructing\nor examining certain types of data structures, particularly trees. Let's\nhave a recursive type to represent files in a filesystem:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type filesystem = File of string | Directory of filesystem list\ntype filesystem = File of string | Directory of filesystem list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eopendir\u003c/code\u003e and \u003ccode\u003ereaddir\u003c/code\u003e functions are used to open a directory and\nread elements from the directory. I'm going to define a handy\n\u003ccode\u003ereaddir_no_ex\u003c/code\u003e function which hides the annoying \u003ccode\u003eEnd_of_file\u003c/code\u003e\nexception that \u003ccode\u003ereaddir\u003c/code\u003e throws when it reaches the end of the\ndirectory:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# #load \u0026quot;unix.cma\u0026quot;\n# open Unix\n# let readdir_no_ex dirh =\n  try\n    Some (readdir dirh)\n  with\n    End_of_file -\u0026gt; None\nval readdir_no_ex : dir_handle -\u0026gt; string option = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe type of \u003ccode\u003ereaddir_no_ex\u003c/code\u003e is this. Recall our earlier discussion about\nnull pointers.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# readdir_no_ex\n- : dir_handle -\u0026gt; string option = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI'm also going to define a simple recursive function which I can use to\nconvert the \u003ccode\u003efilesystem\u003c/code\u003e type into a string for (eg) printing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec string_of_filesystem fs =\n  match fs with\n  | File filename -\u0026gt; filename ^ \u0026quot;\\n\u0026quot;\n  | Directory fs_list -\u0026gt;\n      List.fold_left (^) \u0026quot;\u0026quot; (List.map string_of_filesystem fs_list)\nval string_of_filesystem : filesystem -\u0026gt; string = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the use of \u003ccode\u003efold_left\u003c/code\u003e and \u003ccode\u003emap\u003c/code\u003e. The \u003ccode\u003emap\u003c/code\u003e is used to\n(recursively) convert each \u003ccode\u003efilesystem\u003c/code\u003e in the list into a \u003ccode\u003estring\u003c/code\u003e.\nThen the \u003ccode\u003efold_left (^) \u0026quot;\u0026quot;\u003c/code\u003e concatenates the list together into one big\nstring. Notice also the use of pattern matching. (The library defines a\nfunction called \u003ccode\u003eString.concat\u003c/code\u003e which is essentially equivalent to\n\u003ccode\u003efold_left (^) \u003c/code\u003e, but implemented more efficiently).\u003c/p\u003e\n\u003cp\u003eNow let's define a function to read a directory structure, recursively,\nand return a recursive \u003ccode\u003efilesystem\u003c/code\u003e data structure. I'm going to show\nthis function in steps, but I'll print out the entire function at the\nend of this section. First the outline of the function:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec read_directory path =\n  let dirh = opendir path in\n  let rec loop () =\n    (* ..... *) in\n  Directory (loop ())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe call to \u003ccode\u003eopendir\u003c/code\u003e opens up the given path and returns a \u003ccode\u003edir_handle\u003c/code\u003e\nfrom which we will be able to read the names using \u003ccode\u003ereaddir_no_ex\u003c/code\u003e\nlater. The return value of the function is going to be a\n\u003ccode\u003eDirectory fs_list\u003c/code\u003e, so all we need to do to complete the function is to\nwrite our function \u003ccode\u003eloop\u003c/code\u003e which returns a list of \u003ccode\u003efilesystem\u003c/code\u003es. The\ntype of \u003ccode\u003eloop\u003c/code\u003e will be:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eloop : unit -\u0026gt; filesystem list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHow do we define loop? Let's take it in steps again.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec loop () =\n  let filename = readdir_no_ex dirh in\n  (* ..... *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFirst we read the next filename from the directory handle. \u003ccode\u003efilename\u003c/code\u003e\nhas type \u003ccode\u003estring option\u003c/code\u003e, in other words it could be \u003ccode\u003eNone\u003c/code\u003e or\n\u003ccode\u003eSome \u0026quot;foo\u0026quot;\u003c/code\u003e where \u003ccode\u003efoo\u003c/code\u003e is the name of the next filename in the\ndirectory. We also need to ignore the \u003ccode\u003e\u0026quot;.\u0026quot;\u003c/code\u003e and \u003ccode\u003e\u0026quot;..\u0026quot;\u003c/code\u003e files (ie. the\ncurrent directory and the parent directory). We can do all this with a\nnice pattern match:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec loop () =\n  let filename = readdir_no_ex dirh in\n    match filename with\n    | None -\u0026gt; []\n    | Some \u0026quot;.\u0026quot; -\u0026gt; loop ()\n    | Some \u0026quot;..\u0026quot; -\u0026gt; loop ()\n    | Some filename -\u0026gt;\n        (* ..... *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eNone\u003c/code\u003e case is easy. Thinking recursively (!) if \u003ccode\u003eloop\u003c/code\u003e is called\nand we've reached the end of the directory, \u003ccode\u003eloop\u003c/code\u003e needs to return a\nlist of entries - and there's no entries - so it returns the empty list\n(\u003ccode\u003e[]\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eFor \u003ccode\u003e\u0026quot;.\u0026quot;\u003c/code\u003e and \u003ccode\u003e\u0026quot;..\u0026quot;\u003c/code\u003e we just ignore the file and call \u003ccode\u003eloop\u003c/code\u003e again.\u003c/p\u003e\n\u003cp\u003eWhat do we do when \u003ccode\u003eloop\u003c/code\u003e reads a real filename (the \u003ccode\u003eSome filename\u003c/code\u003e\nmatch below)? Let \u003ccode\u003epathname\u003c/code\u003e be the full path to the file. We 'stat' the\nfile to see if it's really a directory. If it \u003cem\u003eis\u003c/em\u003e a directory, we set\n\u003ccode\u003ethis\u003c/code\u003e by recursively calling \u003ccode\u003eread_directory\u003c/code\u003e which will return\n\u003ccode\u003eDirectory something\u003c/code\u003e. Notice that the overall result of\n\u003ccode\u003eread_directory\u003c/code\u003e is \u003ccode\u003eDirectory (loop ())\u003c/code\u003e. If the file is really a file\n(not a directory) then we let \u003ccode\u003ethis\u003c/code\u003e be \u003ccode\u003eFile pathname\u003c/code\u003e. Then we do\nsomething clever: we return \u003ccode\u003ethis :: loop ()\u003c/code\u003e. This is the recursive\ncall to \u003ccode\u003eloop ()\u003c/code\u003e to calculate the remaining directory members (a list),\nto which we prepend \u003ccode\u003ethis\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec read_directory path =\n  let dirh = opendir path in\n  let rec loop () =\n    let filename = readdir_no_ex dirh in\n      match filename with\n      | None -\u0026gt; []\n      | Some \u0026quot;.\u0026quot; -\u0026gt; loop ()\n      | Some \u0026quot;..\u0026quot; -\u0026gt; loop ()\n      | Some filename -\u0026gt;\n          let pathname = path ^ \u0026quot;/\u0026quot; ^ filename in\n          let stat = lstat pathname in\n          let this =\n            if stat.st_kind = S_DIR then\n              read_directory pathname\n            else\n              File pathname\n          in\n            this :: loop ()\n  in\n    Directory (loop ())\nval read_directory : string -\u0026gt; filesystem = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat's quite a complex bit of recursion, but although this is a made-up\nexample, it's fairly typical of the complex patterns of recursion found\nin real-world functional programs. The two important lessons to take\naway from this are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe use of recursion to build a list:\u003c/p\u003e\n  \u003c!-- $MDX skip --\u003e\n  ```ocaml\n  let rec loop () =\n    a match or if statement\n    | base case -\u003e []\n    | recursive case -\u003e element :: loop ()\n  ```\n  Compare this to our previous `range` function. The pattern of recursion\n  is exactly the same:\n    \n  ```ocaml\n  # let rec range a b =\n    if a \u003e b then []            (* Base case *)\n    else a :: range (a + 1) b     (* Recursive case *)\n  ```\n\t\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe use of recursion to build up trees:\u003c/p\u003e\n  \u003c!-- $MDX skip --\u003e\n  ```ocaml\n  let rec read_directory path =\n    (* blah blah *)\n    if file-is-a-directory then\n      read_directory path-to-file\n    else\n      Leaf file\n  ```\n  All that remains now to make this a working program is a little bit of\n  code to call `read_directory` and display the result:\n    \n  \u003c!-- $MDX skip --\u003e\n  ```ocaml\n  let path = Sys.argv.(1) in\n  let fs = read_directory path in\n  print_endline (string_of_filesystem fs)\n  ```\n\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"recursion-example-maximum-element-in-a-list\"\u003eRecursion example: maximum element in a list\u003c/h3\u003e\n\u003cp\u003eRemember the basic recursion pattern for lists:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec loop () =\n  a match or if statement\n  | base case -\u0026gt; []\n  | recursive case -\u0026gt; element :: loop ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe key here is actually the use of the match / base case / recursive\ncase pattern. In this example - finding the maximum element in a list -\nwe're going to have two base cases and one recursive case. But before I\njump ahead to the code, let's just step back and think about the\nproblem. By thinking about the problem, the solution will appear \u0026quot;as if\nby magic\u0026quot; (I promise you :-)\u003c/p\u003e\n\u003cp\u003eFirst of all, let's be clear that the maximum element of a list is just\nthe biggest one, e.g. the maximum element of the list \u003ccode\u003e[1; 2; 3; 4; 1]\u003c/code\u003e\nis \u003ccode\u003e4\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAre there any special cases? Yes, there are. What's the maximum element\nof the empty list \u003ccode\u003e[]\u003c/code\u003e? There \u003cem\u003eisn't one\u003c/em\u003e. If we are passed an empty\nlist, we should throw an error.\u003c/p\u003e\n\u003cp\u003eWhat's the maximum element of a single element list such as \u003ccode\u003e[4]\u003c/code\u003e?\nThat's easy: it's just the element itself. So \u003ccode\u003elist_max [4]\u003c/code\u003e should\nreturn \u003ccode\u003e4\u003c/code\u003e, or in the general case, \u003ccode\u003elist_max [x]\u003c/code\u003e should return \u003ccode\u003ex\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhat's the maximum element of the general list \u003ccode\u003ex :: remainder\u003c/code\u003e (this is\nthe \u0026quot;cons\u0026quot; notation for the list, so \u003ccode\u003eremainder\u003c/code\u003e is the tail - also a\nlist)?\u003c/p\u003e\n\u003cp\u003eThink about this for a while. Suppose you know the maximum element of\n\u003ccode\u003eremainder\u003c/code\u003e, which is, say, \u003ccode\u003ey\u003c/code\u003e. What's the maximum element of\n\u003ccode\u003ex :: remainder\u003c/code\u003e? It depends on whether \u003ccode\u003ex \u0026gt; y\u003c/code\u003e or \u003ccode\u003ex \u0026lt;= y\u003c/code\u003e. If \u003ccode\u003ex\u003c/code\u003e is\nbigger than \u003ccode\u003ey\u003c/code\u003e, then the overall maximum is \u003ccode\u003ex\u003c/code\u003e, whereas conversely if\n\u003ccode\u003ex\u003c/code\u003e is less than \u003ccode\u003ey\u003c/code\u003e, then the overall maximum is \u003ccode\u003ey\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eDoes this really work? Consider \u003ccode\u003e[1; 2; 3; 4; 1]\u003c/code\u003e again. This is\n\u003ccode\u003e1 :: [2; 3; 4; 1]\u003c/code\u003e. Now the maximum element of the remainder,\n\u003ccode\u003e[2; 3; 4; 1]\u003c/code\u003e, is \u003ccode\u003e4\u003c/code\u003e. So now we're interested in \u003ccode\u003ex = 1\u003c/code\u003e and \u003ccode\u003ey = 4\u003c/code\u003e.\nThat head element \u003ccode\u003ex = 1\u003c/code\u003e doesn't matter because \u003ccode\u003ey = 4\u003c/code\u003e is bigger, so\nthe overall maximum of the whole list is \u003ccode\u003ey = 4\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLet's now code those rules above up, to get a working function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec list_max xs =\n  match xs with\n  | [] -\u0026gt; (* empty list: fail *)\n      failwith \u0026quot;list_max called on empty list\u0026quot;\n  | [x] -\u0026gt; (* single element list: return the element *)\n      x\n  | x :: remainder -\u0026gt; (* multiple element list: recursive case *)\n      max x (list_max remainder)\nval list_max : 'a list -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI've added comments so you can see how the rules / special cases we\ndecided upon above really correspond to lines of code.\u003c/p\u003e\n\u003cp\u003eDoes it work?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# list_max [1; 2; 3; 4; 1]\n- : int = 4\n# list_max []\nException: Failure \u0026quot;list_max called on empty list\u0026quot;.\n# list_max [5; 4; 3; 2; 1]\n- : int = 5\n# list_max [5; 4; 3; 2; 1; 100]\n- : int = 100\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice how the solution proposed is both (a) very different from the\nimperative for-loop solution, and (b) much more closely tied to the\nproblem specification. Functional programmers will tell you that this is\nbecause the functional style is much higher level than the imperative\nstyle, and therefore better and simpler. Whether you believe them is up\nto you. It's certainly true that it's much simpler to reason logically\nabout the functional version, which is useful if you wanted to formally\nprove that \u003ccode\u003elist_max\u003c/code\u003e is correct (\u0026quot;correct\u0026quot; being the mathematical way\nto say that a program is provably bug-free, useful for space shuttles,\nnuclear power plants and higher quality software in general).\u003c/p\u003e\n\u003ch3 id=\"tail-recursion\"\u003eTail recursion\u003c/h3\u003e\n\u003cp\u003eLet's look at the \u003ccode\u003erange\u003c/code\u003e function again for about the twentieth time:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range a b =\n  if a \u0026gt; b then []\n  else a :: range (a+1) b\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI'm going to rewrite it slightly to make something about the structure\nof the program clearer (still the same function however):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range a b =\n  if a \u0026gt; b then [] else\n    let result = range (a+1) b in\n      a :: result\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's call it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# List.length (range 1 10)\n- : int = 10\n# List.length (range 1 1000000)\nStack overflow during evaluation (looping recursion?).\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHmmm ... at first sight this looks like a problem with recursive\nprogramming, and hence with the whole of functional programming! If you\nwrite your code recursively instead of iteratively then you necessarily\nrun out of stack space on large inputs, right?\u003c/p\u003e\n\u003cp\u003eIn fact, wrong. Compilers can perform a simple optimisation on certain\ntypes of recursive functions to turn them into while loops. These\ncertain types of recursive functions therefore run in constant stack\nspace, and with the equivalent efficiency of imperative while loops.\nThese functions are called \u003cstrong\u003etail-recursive functions\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn tail-recursive functions, the recursive call happens last of all.\nRemember our \u003ccode\u003eloop ()\u003c/code\u003e functions above? They all had the form:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec loop () =\n  (* do something *)\n  loop ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBecause the recursive call to \u003ccode\u003eloop ()\u003c/code\u003e happens as the very last thing,\n\u003ccode\u003eloop\u003c/code\u003e is tail-recursive and the compiler will turn the whole thing into\na while loop.\u003c/p\u003e\n\u003cp\u003eUnfortunately \u003ccode\u003erange\u003c/code\u003e is not tail-recursive, and the longer version\nabove shows why. The recursive call to \u003ccode\u003erange\u003c/code\u003e doesn't happen as the\nvery last thing. In fact the last thing to happen is the \u003ccode\u003e::\u003c/code\u003e (cons)\noperation. As a result, the compiler doesn't turn the recursion into a\nwhile loop, and the function is not efficient in its use of stack space.\u003c/p\u003e\n\u003cp\u003eThe use of an accumulating argument or \u003ccode\u003eaccumulator\u003c/code\u003e allows one to write\nfunctions such as \u003ccode\u003erange\u003c/code\u003e above in a tail-recursive manner, which means they\nwill be efficient and work properly on large inputs. Let's plan our rewritten\n\u003ccode\u003erange\u003c/code\u003e function which will use an accumulator argument to store the \u0026quot;result so\nfar\u0026quot;:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec range2 a b accum =\n  (* ... *)\n  \nlet range a b =\n  range2 a b []\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eaccum\u003c/code\u003e argument is going to accumulate the result. It's the \u0026quot;result\nso far\u0026quot;. We pass in the empty list (\u0026quot;no result so far\u0026quot;). The easy case\nis when \u003ccode\u003ea \u0026gt; b\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec range2 a b accum =\n  if a \u0026gt; b then accum\n  else\n    (* ... *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf \u003ccode\u003ea \u0026gt; b\u003c/code\u003e (i.e. if we've reached the end of the recursion), then stop\nand return the result (\u003ccode\u003eaccum\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eNow the trick is to write the \u003ccode\u003eelse\u003c/code\u003e-clause and make sure that the call\nto \u003ccode\u003erange2\u003c/code\u003e is the very last thing that we do, so the function is\ntail-recursive:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range2 a b accum =\n  if a \u0026gt; b then accum\n  else range2 (a + 1) b (a :: accum)\nval range2 : int -\u0026gt; int -\u0026gt; int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere's only one slight problem with this function: it constructs the\nlist backwards! However, this is easy to rectify by redefining range as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let range a b = List.rev (range2 a b [])\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt works this time, although it's a bit slow to run because it really\ndoes have to construct a list with a million elements in it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# List.length (range 1 1000000)\n- : int = 1000000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe following implementation is twice as fast as the previous one,\nbecause it does not need to reverse a list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range2 a b accum =\n  if b \u0026lt; a then accum\n  else range2 a (b - 1) (b :: accum)\nval range2 : int -\u0026gt; int -\u0026gt; int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n# let range a b =\n  range2 a b []\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat was a brief overview of tail recursion, but in real world\nsituations determining if a function is tail recursive can be quite\nhard. What did we really learn here? One thing is that recursive\nfunctions have a dangerous trap for inexperienced programmers. Your\nfunction can appear to work for small inputs (during testing), but fail\ncatastrophically in the field when exposed to large inputs. This is one\nargument \u003cem\u003eagainst\u003c/em\u003e using recursive functions, and for using explicit\nwhile loops when possible.\u003c/p\u003e\n\u003ch2 id=\"mutable-records-references-again-and-arrays\"\u003eMutable records, references (again!) and arrays\u003c/h2\u003e\n\u003cp\u003ePreviously we mentioned records in passing. These are like C \u003ccode\u003estruct\u003c/code\u003es:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type pair_of_ints = {a : int; b : int}\ntype pair_of_ints = { a : int; b : int; }\n# {a = 3; b = 5}\n- : pair_of_ints = {a = 3; b = 5}\n# {a = 3}\nLine 1, characters 1-8:\nError: Some record fields are undefined: b\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne feature which I didn't cover: OCaml records can have mutable fields.\nNormally an expression like \u003ccode\u003e{a = 3; b = 5}\u003c/code\u003e is an immutable, constant\nobject. However if the record has \u003cstrong\u003emutable fields\u003c/strong\u003e, then\nthere is a way to change those fields in the record. This is an\nimperative feature of OCaml, because functional languages don't normally\nallow mutable objects (or references or mutable arrays, which we'll look\nat in a moment).\u003c/p\u003e\n\u003cp\u003eHere is an object defined with a mutable field. This field is used to\ncount how many times the object has been accessed. You could imagine\nthis being used in a caching scheme to decide which objects you'd evict\nfrom memory.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type name = {name : string; mutable access_count : int}\ntype name = { name : string; mutable access_count : int; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is a function defined on names which prints the \u003ccode\u003ename\u003c/code\u003e field and\nincrements the mutable \u003ccode\u003eaccess_count\u003c/code\u003e field:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let print_name name =\n  print_endline (\u0026quot;The name is \u0026quot; ^ name.name);\n  name.access_count \u0026lt;- name.access_count + 1\nval print_name : name -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice a strange, and very non-functional feature of \u003ccode\u003eprint_name\u003c/code\u003e: it modifies\nits \u003ccode\u003eaccess_count\u003c/code\u003e parameter. This function is not \u0026quot;pure\u0026quot;. OCaml is a\nfunctional language, but not to the extent that it forces functional\nprogramming down your throat.\u003c/p\u003e\n\u003cp\u003eAnyway, let's see \u003ccode\u003eprint_name\u003c/code\u003e in action:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let n = {name = \u0026quot;Richard Jones\u0026quot;; access_count = 0}\nval n : name = {name = \u0026quot;Richard Jones\u0026quot;; access_count = 0}\n# n\n- : name = {name = \u0026quot;Richard Jones\u0026quot;; access_count = 0}\n# print_name n\nThe name is Richard Jones\n- : unit = ()\n# n\n- : name = {name = \u0026quot;Richard Jones\u0026quot;; access_count = 1}\n# print_name n\nThe name is Richard Jones\n- : unit = ()\n# n\n- : name = {name = \u0026quot;Richard Jones\u0026quot;; access_count = 2}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnly fields explicitly marked as \u003ccode\u003emutable\u003c/code\u003e can be assigned to using the\n\u003ccode\u003e\u0026lt;-\u003c/code\u003e operator. If you try to assign to a non-mutable field, OCaml won't\nlet you:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# n.name \u0026lt;- \u0026quot;John Smith\u0026quot;\nLine 1, characters 1-23:\nError: The record field name is not mutable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReferences, with which we should be familiar by now, are implemented\nusing records with a mutable \u003ccode\u003econtents\u003c/code\u003e field. Check out the definition\nin \u003ccode\u003eStdlib\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype 'a ref = {mutable contents : 'a}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd look closely at what the OCaml toplevel prints out for the value of\na reference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let r = ref 100\nval r : int Stdlib.ref = {Stdlib.contents = 100}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArrays are another sort of mutable structure provided by OCaml. In\nOCaml, plain lists are implemented as linked lists, and linked lists are\nslow for some types of operation. For example, getting the head of a\nlist, or iterating over a list to perform some operation on each element\nis reasonably fast. However, jumping to the n\u003csup\u003eth\u003c/sup\u003e element of a\nlist, or trying to randomly access a list - both are slow operations.\nThe OCaml \u003ccode\u003eArray\u003c/code\u003e type is a real array, so random access is fast, but\ninsertion and deletion of elements is slow. \u003ccode\u003eArray\u003c/code\u003es are also mutable so\nyou can randomly change elements too.\u003c/p\u003e\n\u003cp\u003eThe basics of arrays are simple:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let a = Array.create 10 0\nLine 1, characters 9-21:\nAlert deprecated: Stdlib.Array.create\nUse Array.make instead.\nval a : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]\n# for i = 0 to Array.length a - 1 do\n  a.(i) \u0026lt;- i\nLine 3, characters 1-3:\nError: Syntax error\n# a\n- : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice the syntax for writing arrays: \u003ccode\u003e[| element; element; ... |]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe OCaml compiler was designed with heavy numerical processing in mind\n(the sort of thing that FORTRAN is traditionally used for), and so it\ncontains various optimisations specifically for arrays of numbers,\nvectors and matrices. Here is some benchmark code for doing dense matrix\nmultiplication. Notice that it uses for-loops and is generally very\nimperative in style:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let size = 30\nval size : int = 30\n\n# let mkmatrix rows cols =\n  let count = ref 1\n  and last_col = cols - 1\n  and m = Array.make_matrix rows cols 0 in\n    for i = 0 to rows - 1 do\n      let mi = m.(i) in\n        for j = 0 to last_col do\n          mi.(j) \u0026lt;- !count;\n          incr count\n        done;\n    done;\n    m\nval mkmatrix : int -\u0026gt; int -\u0026gt; int array array = \u0026lt;fun\u0026gt;\n\n# let rec inner_loop k v m1i m2 j =\n  if k \u0026lt; 0 then v\n  else inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j\nval inner_loop : int -\u0026gt; int -\u0026gt; int array -\u0026gt; int array array -\u0026gt; int -\u0026gt; int =\n  \u0026lt;fun\u0026gt;\n\n# let mmult rows cols m1 m2 m3 =\n  let last_col = cols - 1\n  and last_row = rows - 1 in\n    for i = 0 to last_row do\n      let m1i = m1.(i) and m3i = m3.(i) in\n      for j = 0 to last_col do\n        m3i.(j) \u0026lt;- inner_loop last_row 0 m1i m2 j\n      done;\n    done\nval mmult :\n  int -\u0026gt; int -\u0026gt; int array array -\u0026gt; int array array -\u0026gt; int array array -\u0026gt; unit =\n  \u0026lt;fun\u0026gt;\n\n# let () =\n  let n =\n    try int_of_string Sys.argv.(1)\n    with Invalid_argument _ -\u0026gt; 1\n  and m1 = mkmatrix size size\n  and m2 = mkmatrix size size\n  and m3 = Array.make_matrix size size 0 in\n    for i = 1 to n - 1 do\n      mmult size size m1 m2 m3\n    done;\n    mmult size size m1 m2 m3;\n    Printf.printf \u0026quot;%d %d %d %d\\n\u0026quot; m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)\nException: Failure \u0026quot;int_of_string\u0026quot;.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"mutually-recursive-functions\"\u003eMutually recursive functions\u003c/h2\u003e\n\u003cp\u003eSuppose I want to define two functions which call each other. This is\nactually not a very common thing to do, but it can be useful sometimes.\nHere's a contrived example (thanks to Ryan Tarpine): The number 0 is\neven. Other numbers greater than 0 are even if their predecessor is odd.\nHence:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec even n =\n  match n with\n  | 0 -\u0026gt; true\n  | x -\u0026gt; odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe code above doesn't compile because we haven't defined the function\n\u003ccode\u003eodd\u003c/code\u003e yet! That's easy though. Zero is not odd, and other numbers\ngreater than 0 are odd if their predecessor is even. So to make this\ncomplete we need that function too:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec even n =\n  match n with\n  | 0 -\u0026gt; true\n  | x -\u0026gt; odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n# let rec odd n =\n  match n with\n  | 0 -\u0026gt; false\n  | x -\u0026gt; even (x - 1)\nLine 4, characters 10-14:\nError: Unbound value even\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe only problem is... this program doesn't compile. In order to compile\nthe \u003ccode\u003eeven\u003c/code\u003e function, we already need the definition of \u003ccode\u003eodd\u003c/code\u003e, and to\ncompile \u003ccode\u003eodd\u003c/code\u003e we need the definition of \u003ccode\u003eeven\u003c/code\u003e. So swapping the two\ndefinitions around won't help either.\u003c/p\u003e\n\u003cp\u003eThere are no \u0026quot;forward prototypes\u0026quot; (as seen in languages descended\nfrom C) in OCaml but there is a special syntax\nfor defining a set of two or more mutually recursive functions, like\n\u003ccode\u003eodd\u003c/code\u003e and \u003ccode\u003eeven\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec even n =\n  match n with\n  | 0 -\u0026gt; true\n  | x -\u0026gt; odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can also\nuse similar syntax for writing mutually recursive class definitions and\nmodules.\u003c/p\u003e\n"},{"title":"Modules","slug":"modules","description":"Learn about OCaml modules and how they can be used to cleanly separate distinct parts of your program\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"language","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\n## Basic usage\n\nIn OCaml, every piece of code is wrapped into a module. Optionally, a module\nitself can be a submodule of another module, pretty much like directories in a\nfile system - but we don't do this very often.\n\nWhen you write a program let's say using two files `amodule.ml` and\n`bmodule.ml`, each of these files automatically defines a module named\n`Amodule` and a module named `Bmodule` that provide whatever you put into the\nfiles.\n\nHere is the code that we have in our file `amodule.ml`:\n\n\u003c!-- $MDX file=examples/amodule.ml --\u003e\n```ocaml\nlet hello () = print_endline \"Hello\"\n```\n\nAnd here is what we have in `bmodule.ml`:\n\n\u003c!-- $MDX file=examples/bmodule.ml --\u003e\n```ocaml\nlet () = Amodule.hello ()\n```\n\nWe can compile the files in one command:\n\n\u003c!-- $MDX dir=examples --\u003e\n```sh\n$ ocamlopt -o hello amodule.ml bmodule.ml\n```\n\nOr, as a build system might do, one by one:\n\n\u003c!-- $MDX dir=examples --\u003e\n```sh\n$ ocamlopt -c amodule.ml\n$ ocamlopt -c bmodule.ml\n$ ocamlopt -o hello amodule.cmx bmodule.cmx\n```\n\nNow we have an executable that prints \"Hello\". As you can see, if you want to\naccess anything from a given module, use the name of the module (always\nstarting with a capital) followed by a dot and the thing that you want to use.\nIt may be a value, a type constructor, or anything else that a given module can\nprovide.\n\nLibraries, starting with the standard library, provide collections of modules.\nfor example, `List.iter` designates the `iter` function from the `List` module.\n\nIf you are using a given module heavily, you may want to make its contents\ndirectly accessible. For this, we use the `open` directive. In our example,\n`bmodule.ml` could have been written:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nopen Amodule\nlet () = hello ()\n```\n\nUsing `open` or not is a matter of personal taste. Some modules provide names\nthat are used in many other modules. This is the case of the `List` module for\ninstance. Usually, we don't do `open List`. Other modules like `Printf` provide\nnames that are normally not subject to conflicts, such as `printf`. In order to\navoid writing `Printf.printf` all over the place, it often makes sense to place\none `open Printf` at the beginning of the file:\n\n```ocaml\nopen Printf\nlet data = [\"a\"; \"beautiful\"; \"day\"]\nlet () = List.iter (printf \"%s\\n\") data\n```\n\nThere are also local `open`s:\n\n```ocaml\n# let map_3d_matrix f m =\n  let open Array in\n    map (map (map f)) m\nval map_3d_matrix :\n  ('a -\u003e 'b) -\u003e 'a array array array -\u003e 'b array array array = \u003cfun\u003e\n# let map_3d_matrix' f =\n  Array.(map (map (map f)))\nval map_3d_matrix' :\n  ('a -\u003e 'b) -\u003e 'a array array array -\u003e 'b array array array = \u003cfun\u003e\n```\n\n## Interfaces and signatures\n\nA module can provide a certain number of things (functions, types, submodules,\n...) to the rest of the program that is using it. If nothing special is done,\neverything which is defined in a module will be accessible from the outside. That's\noften fine in small personal programs, but there are many situations where it\nis better that a module only provides what it is meant to provide, not any of\nthe auxiliary functions and types that are used internally.\n\nFor this, we have to define a module interface, which will act as a mask over\nthe module's implementation. Just like a module derives from a .ml file, the\ncorresponding module interface or signature derives from an .mli file. It\ncontains a list of values with their type. Let's rewrite our `amodule.ml` file\nto something called `amodule2.ml`:\n\n\u003c!-- $MDX file=examples/amodule2.ml --\u003e\n```ocaml\nlet hello () = print_endline \"Hello\"\n```\n\nAs it is, `Amodule` has the following interface:\n\n```ocaml\nval message : string\n\nval hello : unit -\u003e unit\n```\n```mdx-error\nLine 1, characters 1-21:\nError: Value declarations are only allowed in signatures\n```\n\nLet's assume that accessing the `message` value directly is none of the others\nmodules' business. We want to hide it by defining a restricted interface. This\nis our `amodule2.mli` file:\n\n\u003c!-- $MDX file=examples/amodule2.mli --\u003e\n```ocaml\nval hello : unit -\u003e unit\n(** Displays a greeting message. *)\n```\n\n(note the double asterisk at the beginning of the comment - it is a good habit\nto document .mli files using the format supported by\n[ocamldoc](/releases/{{! get LATEST_OCAML_VERSION_MAIN !}}/htmlman/ocamldoc.html))\n\nSuch .mli files must be compiled just before the matching .ml files. They are\ncompiled using `ocamlc`, even if .ml files are compiled to native code using\n`ocamlopt`:\n\n\u003c!-- $MDX dir=examples --\u003e\n```sh\n$ ocamlc -c amodule2.mli\n$ ocamlopt -c amodule2.ml\n```\n\n## Abstract types\n\nWhat about type definitions? We saw that values such as functions can be\nexported by placing their name and their type in a .mli file, e.g.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nval hello : unit -\u003e unit\n```\n\nBut modules often define new types. Let's define a simple record type that\nwould represent a date:\n\n```ocaml\ntype date = {day : int; month : int; year : int}\n```\n\nThere are four options when it comes to writing the .mli file:\n\n1. The type is completely omitted from the signature.\n1. The type definition is copy-pasted into the signature.\n1. The type is made abstract: only its name is given.\n1. The record fields are made read-only: `type date = private { ... }`\n\nCase 3 would look like this:\n\n```ocaml\ntype date\n```\n\nNow, users of the module can manipulate objects of type `date`, but they can't\naccess the record fields directly. They must use the functions that the module\nprovides. Let's assume the module provides three functions, one for creating a\ndate, one for computing the difference between two dates, and one that returns\nthe date in years:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\ntype date\n\nval create : ?days:int -\u003e ?months:int -\u003e ?years:int -\u003e unit -\u003e date\n\nval sub : date -\u003e date -\u003e date\n\nval years : date -\u003e float\n```\n\nThe point is that only `create` and `sub` can be used to create `date` records.\nTherefore, it is not possible for the user of the module to create ill-formed\nrecords. Actually, our implementation uses a record, but we could change it and\nbe sure that it will not break any code that relies on this module! This makes\na lot of sense in a library since subsequent versions of the same library can\ncontinue to expose the same interface, while internally changing the\nimplementation, including data structures.\n\n## Submodules\n\n###  Submodule implementation\n\nWe saw that one `example.ml` file results automatically in one module\nimplementation named `Example`. Its module signature is automatically derived\nand is the broadest possible, or can be restricted by writing an `example.mli`\nfile.\n\nThat said, a given module can also be defined explicitly from within a file.\nThat makes it a submodule of the current module. Let's consider this\n`example.ml` file:\n\n```ocaml\nmodule Hello = struct\n  let message = \"Hello\"\n  let hello () = print_endline message\nend\n\nlet goodbye () = print_endline \"Goodbye\"\n\nlet hello_goodbye () =\n  Hello.hello ();\n  goodbye ()\n```\n\nFrom another file, it is clear that we now have two levels of modules.  We can\nwrite:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet () =\n  Example.Hello.hello ();\n  Example.goodbye ()\n```\n\n###  Submodule interface\n\nWe can also restrict the interface of a given submodule. It is called a module\ntype. Let's do it in our `example.ml` file:\n\n```ocaml\nmodule Hello : sig\n val hello : unit -\u003e unit\nend\n= \nstruct\n  let message = \"Hello\"\n  let hello () = print_endline message\nend\n  \n(* At this point, Hello.message is not accessible anymore. *)\n\nlet goodbye () = print_endline \"Goodbye\"\n\nlet hello_goodbye () =\n  Hello.hello ();\n  goodbye ()\n```\n\nThe definition of the `Hello` module above is the equivalent of a\n`hello.mli`/`hello.ml` pair of files. Writing all of that in one block of code\nis not elegant so, in general, we prefer to define the module signature\nseparately:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmodule type Hello_type = sig\n val hello : unit -\u003e unit\nend\n  \nmodule Hello : Hello_type = struct\n  ...\nend\n```\n\n`Hello_type` is a named module type, and can be reused to define other module\ninterfaces.\n\n## Practical manipulation of modules\n\n###  Displaying the interface of a module\n\nYou can use the `ocaml` toplevel to visualize the contents of an existing\nmodule, such as `List`:\n\n```ocaml\n# #show List;;\nmodule List = List\nmodule List :\n  sig\n    type 'a t = 'a list = [] | (::) of 'a * 'a list\n    val length : 'a t -\u003e int\n    val compare_lengths : 'a t -\u003e 'b t -\u003e int\n    val compare_length_with : 'a t -\u003e int -\u003e int\n    val cons : 'a -\u003e 'a t -\u003e 'a t\n    val hd : 'a t -\u003e 'a\n    val tl : 'a t -\u003e 'a t\n    val nth : 'a t -\u003e int -\u003e 'a\n    val nth_opt : 'a t -\u003e int -\u003e 'a option\n    val rev : 'a t -\u003e 'a t\n    val init : int -\u003e (int -\u003e 'a) -\u003e 'a t\n    val append : 'a t -\u003e 'a t -\u003e 'a t\n    val rev_append : 'a t -\u003e 'a t -\u003e 'a t\n    val concat : 'a t t -\u003e 'a t\n    val flatten : 'a t t -\u003e 'a t\n    val iter : ('a -\u003e unit) -\u003e 'a t -\u003e unit\n    val iteri : (int -\u003e 'a -\u003e unit) -\u003e 'a t -\u003e unit\n    val map : ('a -\u003e 'b) -\u003e 'a t -\u003e 'b t\n    val mapi : (int -\u003e 'a -\u003e 'b) -\u003e 'a t -\u003e 'b t\n    val rev_map : ('a -\u003e 'b) -\u003e 'a t -\u003e 'b t\n    val filter_map : ('a -\u003e 'b option) -\u003e 'a t -\u003e 'b t\n    val concat_map : ('a -\u003e 'b t) -\u003e 'a t -\u003e 'b t\n    val fold_left : ('a -\u003e 'b -\u003e 'a) -\u003e 'a -\u003e 'b t -\u003e 'a\n    val fold_right : ('a -\u003e 'b -\u003e 'b) -\u003e 'a t -\u003e 'b -\u003e 'b\n    val iter2 : ('a -\u003e 'b -\u003e unit) -\u003e 'a t -\u003e 'b t -\u003e unit\n    val map2 : ('a -\u003e 'b -\u003e 'c) -\u003e 'a t -\u003e 'b t -\u003e 'c t\n    val rev_map2 : ('a -\u003e 'b -\u003e 'c) -\u003e 'a t -\u003e 'b t -\u003e 'c t\n    val fold_left2 : ('a -\u003e 'b -\u003e 'c -\u003e 'a) -\u003e 'a -\u003e 'b t -\u003e 'c t -\u003e 'a\n    val fold_right2 : ('a -\u003e 'b -\u003e 'c -\u003e 'c) -\u003e 'a t -\u003e 'b t -\u003e 'c -\u003e 'c\n    val for_all : ('a -\u003e bool) -\u003e 'a t -\u003e bool\n    val exists : ('a -\u003e bool) -\u003e 'a t -\u003e bool\n    val for_all2 : ('a -\u003e 'b -\u003e bool) -\u003e 'a t -\u003e 'b t -\u003e bool\n    val exists2 : ('a -\u003e 'b -\u003e bool) -\u003e 'a t -\u003e 'b t -\u003e bool\n    val mem : 'a -\u003e 'a t -\u003e bool\n    val memq : 'a -\u003e 'a t -\u003e bool\n    val find : ('a -\u003e bool) -\u003e 'a t -\u003e 'a\n    val find_opt : ('a -\u003e bool) -\u003e 'a t -\u003e 'a option\n    val find_map : ('a -\u003e 'b option) -\u003e 'a t -\u003e 'b option\n    val filter : ('a -\u003e bool) -\u003e 'a t -\u003e 'a t\n    val find_all : ('a -\u003e bool) -\u003e 'a t -\u003e 'a t\n    val partition : ('a -\u003e bool) -\u003e 'a t -\u003e 'a t * 'a t\n    val assoc : 'a -\u003e ('a * 'b) t -\u003e 'b\n    val assoc_opt : 'a -\u003e ('a * 'b) t -\u003e 'b option\n    val assq : 'a -\u003e ('a * 'b) t -\u003e 'b\n    val assq_opt : 'a -\u003e ('a * 'b) t -\u003e 'b option\n    val mem_assoc : 'a -\u003e ('a * 'b) t -\u003e bool\n    val mem_assq : 'a -\u003e ('a * 'b) t -\u003e bool\n    val remove_assoc : 'a -\u003e ('a * 'b) t -\u003e ('a * 'b) t\n    val remove_assq : 'a -\u003e ('a * 'b) t -\u003e ('a * 'b) t\n    val split : ('a * 'b) t -\u003e 'a t * 'b t\n    val combine : 'a t -\u003e 'b t -\u003e ('a * 'b) t\n    val sort : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t\n    val stable_sort : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t\n    val fast_sort : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t\n    val sort_uniq : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t\n    val merge : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t -\u003e 'a t\n    val to_seq : 'a t -\u003e 'a Seq.t\n    val of_seq : 'a Seq.t -\u003e 'a t\n  end\n```\n\nThere is online documentation for each library.\n\n###  Module inclusion\n\nLet's say we feel that a function is missing from the standard `List` module,\nbut we really want it as if it were part of it. In an `extensions.ml` file, we\ncan achieve this effect by using the `include` directive:\n\n```ocaml\n# module List = struct\n  include List\n  let rec optmap f = function\n    | [] -\u003e []\n    | hd :: tl -\u003e\n       match f hd with\n       | None -\u003e optmap f tl\n       | Some x -\u003e x :: optmap f tl\n  end\nmodule List :\n  sig\n    type 'a t = 'a list = [] | (::) of 'a * 'a list\n    val length : 'a t -\u003e int\n    val compare_lengths : 'a t -\u003e 'b t -\u003e int\n    val compare_length_with : 'a t -\u003e int -\u003e int\n    val cons : 'a -\u003e 'a t -\u003e 'a t\n    val hd : 'a t -\u003e 'a\n    val tl : 'a t -\u003e 'a t\n    val nth : 'a t -\u003e int -\u003e 'a\n    val nth_opt : 'a t -\u003e int -\u003e 'a option\n    val rev : 'a t -\u003e 'a t\n    val init : int -\u003e (int -\u003e 'a) -\u003e 'a t\n    val append : 'a t -\u003e 'a t -\u003e 'a t\n    val rev_append : 'a t -\u003e 'a t -\u003e 'a t\n    val concat : 'a t t -\u003e 'a t\n    val flatten : 'a t t -\u003e 'a t\n    val iter : ('a -\u003e unit) -\u003e 'a t -\u003e unit\n    val iteri : (int -\u003e 'a -\u003e unit) -\u003e 'a t -\u003e unit\n    val map : ('a -\u003e 'b) -\u003e 'a t -\u003e 'b t\n    val mapi : (int -\u003e 'a -\u003e 'b) -\u003e 'a t -\u003e 'b t\n    val rev_map : ('a -\u003e 'b) -\u003e 'a t -\u003e 'b t\n    val filter_map : ('a -\u003e 'b option) -\u003e 'a t -\u003e 'b t\n    val concat_map : ('a -\u003e 'b t) -\u003e 'a t -\u003e 'b t\n    val fold_left : ('a -\u003e 'b -\u003e 'a) -\u003e 'a -\u003e 'b t -\u003e 'a\n    val fold_right : ('a -\u003e 'b -\u003e 'b) -\u003e 'a t -\u003e 'b -\u003e 'b\n    val iter2 : ('a -\u003e 'b -\u003e unit) -\u003e 'a t -\u003e 'b t -\u003e unit\n    val map2 : ('a -\u003e 'b -\u003e 'c) -\u003e 'a t -\u003e 'b t -\u003e 'c t\n    val rev_map2 : ('a -\u003e 'b -\u003e 'c) -\u003e 'a t -\u003e 'b t -\u003e 'c t\n    val fold_left2 : ('a -\u003e 'b -\u003e 'c -\u003e 'a) -\u003e 'a -\u003e 'b t -\u003e 'c t -\u003e 'a\n    val fold_right2 : ('a -\u003e 'b -\u003e 'c -\u003e 'c) -\u003e 'a t -\u003e 'b t -\u003e 'c -\u003e 'c\n    val for_all : ('a -\u003e bool) -\u003e 'a t -\u003e bool\n    val exists : ('a -\u003e bool) -\u003e 'a t -\u003e bool\n    val for_all2 : ('a -\u003e 'b -\u003e bool) -\u003e 'a t -\u003e 'b t -\u003e bool\n    val exists2 : ('a -\u003e 'b -\u003e bool) -\u003e 'a t -\u003e 'b t -\u003e bool\n    val mem : 'a -\u003e 'a t -\u003e bool\n    val memq : 'a -\u003e 'a t -\u003e bool\n    val find : ('a -\u003e bool) -\u003e 'a t -\u003e 'a\n    val find_opt : ('a -\u003e bool) -\u003e 'a t -\u003e 'a option\n    val find_map : ('a -\u003e 'b option) -\u003e 'a t -\u003e 'b option\n    val filter : ('a -\u003e bool) -\u003e 'a t -\u003e 'a t\n    val find_all : ('a -\u003e bool) -\u003e 'a t -\u003e 'a t\n    val partition : ('a -\u003e bool) -\u003e 'a t -\u003e 'a t * 'a t\n    val assoc : 'a -\u003e ('a * 'b) t -\u003e 'b\n    val assoc_opt : 'a -\u003e ('a * 'b) t -\u003e 'b option\n    val assq : 'a -\u003e ('a * 'b) t -\u003e 'b\n    val assq_opt : 'a -\u003e ('a * 'b) t -\u003e 'b option\n    val mem_assoc : 'a -\u003e ('a * 'b) t -\u003e bool\n    val mem_assq : 'a -\u003e ('a * 'b) t -\u003e bool\n    val remove_assoc : 'a -\u003e ('a * 'b) t -\u003e ('a * 'b) t\n    val remove_assq : 'a -\u003e ('a * 'b) t -\u003e ('a * 'b) t\n    val split : ('a * 'b) t -\u003e 'a t * 'b t\n    val combine : 'a t -\u003e 'b t -\u003e ('a * 'b) t\n    val sort : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t\n    val stable_sort : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t\n    val fast_sort : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t\n    val sort_uniq : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t\n    val merge : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t -\u003e 'a t\n    val to_seq : 'a t -\u003e 'a Seq.t\n    val of_seq : 'a Seq.t -\u003e 'a t\n    val optmap : ('a -\u003e 'b option) -\u003e 'a t -\u003e 'b t\n  end\n```\n\nIt creates a module `Extensions.List` that has everything the standard `List`\nmodule has, plus a new `optmap` function. From another file, all we have to do\nto override the default `List` module is `open Extensions` at the beginning of\nthe .ml file:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nopen Extensions\n\n...\n\nList.optmap ...\n```\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#basic-usage\"\u003eBasic usage\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#interfaces-and-signatures\"\u003eInterfaces and signatures\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#abstract-types\"\u003eAbstract types\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#submodules\"\u003eSubmodules\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-manipulation-of-modules\"\u003ePractical manipulation of modules\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"basic-usage\"\u003eBasic usage\u003c/h2\u003e\n\u003cp\u003eIn OCaml, every piece of code is wrapped into a module. Optionally, a module\nitself can be a submodule of another module, pretty much like directories in a\nfile system - but we don't do this very often.\u003c/p\u003e\n\u003cp\u003eWhen you write a program let's say using two files \u003ccode\u003eamodule.ml\u003c/code\u003e and\n\u003ccode\u003ebmodule.ml\u003c/code\u003e, each of these files automatically defines a module named\n\u003ccode\u003eAmodule\u003c/code\u003e and a module named \u003ccode\u003eBmodule\u003c/code\u003e that provide whatever you put into the\nfiles.\u003c/p\u003e\n\u003cp\u003eHere is the code that we have in our file \u003ccode\u003eamodule.ml\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX file=examples/amodule.ml --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet hello () = print_endline \u0026quot;Hello\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd here is what we have in \u003ccode\u003ebmodule.ml\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX file=examples/bmodule.ml --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet () = Amodule.hello ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can compile the files in one command:\u003c/p\u003e\n\u003c!-- $MDX dir=examples --\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ocamlopt -o hello amodule.ml bmodule.ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr, as a build system might do, one by one:\u003c/p\u003e\n\u003c!-- $MDX dir=examples --\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ocamlopt -c amodule.ml\n$ ocamlopt -c bmodule.ml\n$ ocamlopt -o hello amodule.cmx bmodule.cmx\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we have an executable that prints \u0026quot;Hello\u0026quot;. As you can see, if you want to\naccess anything from a given module, use the name of the module (always\nstarting with a capital) followed by a dot and the thing that you want to use.\nIt may be a value, a type constructor, or anything else that a given module can\nprovide.\u003c/p\u003e\n\u003cp\u003eLibraries, starting with the standard library, provide collections of modules.\nfor example, \u003ccode\u003eList.iter\u003c/code\u003e designates the \u003ccode\u003eiter\u003c/code\u003e function from the \u003ccode\u003eList\u003c/code\u003e module.\u003c/p\u003e\n\u003cp\u003eIf you are using a given module heavily, you may want to make its contents\ndirectly accessible. For this, we use the \u003ccode\u003eopen\u003c/code\u003e directive. In our example,\n\u003ccode\u003ebmodule.ml\u003c/code\u003e could have been written:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eopen Amodule\nlet () = hello ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing \u003ccode\u003eopen\u003c/code\u003e or not is a matter of personal taste. Some modules provide names\nthat are used in many other modules. This is the case of the \u003ccode\u003eList\u003c/code\u003e module for\ninstance. Usually, we don't do \u003ccode\u003eopen List\u003c/code\u003e. Other modules like \u003ccode\u003ePrintf\u003c/code\u003e provide\nnames that are normally not subject to conflicts, such as \u003ccode\u003eprintf\u003c/code\u003e. In order to\navoid writing \u003ccode\u003ePrintf.printf\u003c/code\u003e all over the place, it often makes sense to place\none \u003ccode\u003eopen Printf\u003c/code\u003e at the beginning of the file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eopen Printf\nlet data = [\u0026quot;a\u0026quot;; \u0026quot;beautiful\u0026quot;; \u0026quot;day\u0026quot;]\nlet () = List.iter (printf \u0026quot;%s\\n\u0026quot;) data\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are also local \u003ccode\u003eopen\u003c/code\u003es:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let map_3d_matrix f m =\n  let open Array in\n    map (map (map f)) m\nval map_3d_matrix :\n  ('a -\u0026gt; 'b) -\u0026gt; 'a array array array -\u0026gt; 'b array array array = \u0026lt;fun\u0026gt;\n# let map_3d_matrix' f =\n  Array.(map (map (map f)))\nval map_3d_matrix' :\n  ('a -\u0026gt; 'b) -\u0026gt; 'a array array array -\u0026gt; 'b array array array = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"interfaces-and-signatures\"\u003eInterfaces and signatures\u003c/h2\u003e\n\u003cp\u003eA module can provide a certain number of things (functions, types, submodules,\n...) to the rest of the program that is using it. If nothing special is done,\neverything which is defined in a module will be accessible from the outside. That's\noften fine in small personal programs, but there are many situations where it\nis better that a module only provides what it is meant to provide, not any of\nthe auxiliary functions and types that are used internally.\u003c/p\u003e\n\u003cp\u003eFor this, we have to define a module interface, which will act as a mask over\nthe module's implementation. Just like a module derives from a .ml file, the\ncorresponding module interface or signature derives from an .mli file. It\ncontains a list of values with their type. Let's rewrite our \u003ccode\u003eamodule.ml\u003c/code\u003e file\nto something called \u003ccode\u003eamodule2.ml\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX file=examples/amodule2.ml --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet hello () = print_endline \u0026quot;Hello\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs it is, \u003ccode\u003eAmodule\u003c/code\u003e has the following interface:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eval message : string\n\nval hello : unit -\u0026gt; unit\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-mdx-error\"\u003eLine 1, characters 1-21:\nError: Value declarations are only allowed in signatures\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's assume that accessing the \u003ccode\u003emessage\u003c/code\u003e value directly is none of the others\nmodules' business. We want to hide it by defining a restricted interface. This\nis our \u003ccode\u003eamodule2.mli\u003c/code\u003e file:\u003c/p\u003e\n\u003c!-- $MDX file=examples/amodule2.mli --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eval hello : unit -\u0026gt; unit\n(** Displays a greeting message. *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(note the double asterisk at the beginning of the comment - it is a good habit\nto document .mli files using the format supported by\n[ocamldoc](/releases/{{! get LATEST_OCAML_VERSION_MAIN !}}/htmlman/ocamldoc.html))\u003c/p\u003e\n\u003cp\u003eSuch .mli files must be compiled just before the matching .ml files. They are\ncompiled using \u003ccode\u003eocamlc\u003c/code\u003e, even if .ml files are compiled to native code using\n\u003ccode\u003eocamlopt\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX dir=examples --\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ocamlc -c amodule2.mli\n$ ocamlopt -c amodule2.ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"abstract-types\"\u003eAbstract types\u003c/h2\u003e\n\u003cp\u003eWhat about type definitions? We saw that values such as functions can be\nexported by placing their name and their type in a .mli file, e.g.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eval hello : unit -\u0026gt; unit\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut modules often define new types. Let's define a simple record type that\nwould represent a date:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype date = {day : int; month : int; year : int}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are four options when it comes to writing the .mli file:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe type is completely omitted from the signature.\n\u003c/li\u003e\n\u003cli\u003eThe type definition is copy-pasted into the signature.\n\u003c/li\u003e\n\u003cli\u003eThe type is made abstract: only its name is given.\n\u003c/li\u003e\n\u003cli\u003eThe record fields are made read-only: \u003ccode\u003etype date = private { ... }\u003c/code\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eCase 3 would look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype date\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, users of the module can manipulate objects of type \u003ccode\u003edate\u003c/code\u003e, but they can't\naccess the record fields directly. They must use the functions that the module\nprovides. Let's assume the module provides three functions, one for creating a\ndate, one for computing the difference between two dates, and one that returns\nthe date in years:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype date\n\nval create : ?days:int -\u0026gt; ?months:int -\u0026gt; ?years:int -\u0026gt; unit -\u0026gt; date\n\nval sub : date -\u0026gt; date -\u0026gt; date\n\nval years : date -\u0026gt; float\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe point is that only \u003ccode\u003ecreate\u003c/code\u003e and \u003ccode\u003esub\u003c/code\u003e can be used to create \u003ccode\u003edate\u003c/code\u003e records.\nTherefore, it is not possible for the user of the module to create ill-formed\nrecords. Actually, our implementation uses a record, but we could change it and\nbe sure that it will not break any code that relies on this module! This makes\na lot of sense in a library since subsequent versions of the same library can\ncontinue to expose the same interface, while internally changing the\nimplementation, including data structures.\u003c/p\u003e\n\u003ch2 id=\"submodules\"\u003eSubmodules\u003c/h2\u003e\n\u003ch3 id=\"submodule-implementation\"\u003eSubmodule implementation\u003c/h3\u003e\n\u003cp\u003eWe saw that one \u003ccode\u003eexample.ml\u003c/code\u003e file results automatically in one module\nimplementation named \u003ccode\u003eExample\u003c/code\u003e. Its module signature is automatically derived\nand is the broadest possible, or can be restricted by writing an \u003ccode\u003eexample.mli\u003c/code\u003e\nfile.\u003c/p\u003e\n\u003cp\u003eThat said, a given module can also be defined explicitly from within a file.\nThat makes it a submodule of the current module. Let's consider this\n\u003ccode\u003eexample.ml\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003emodule Hello = struct\n  let message = \u0026quot;Hello\u0026quot;\n  let hello () = print_endline message\nend\n\nlet goodbye () = print_endline \u0026quot;Goodbye\u0026quot;\n\nlet hello_goodbye () =\n  Hello.hello ();\n  goodbye ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFrom another file, it is clear that we now have two levels of modules.  We can\nwrite:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet () =\n  Example.Hello.hello ();\n  Example.goodbye ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"submodule-interface\"\u003eSubmodule interface\u003c/h3\u003e\n\u003cp\u003eWe can also restrict the interface of a given submodule. It is called a module\ntype. Let's do it in our \u003ccode\u003eexample.ml\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003emodule Hello : sig\n val hello : unit -\u0026gt; unit\nend\n= \nstruct\n  let message = \u0026quot;Hello\u0026quot;\n  let hello () = print_endline message\nend\n  \n(* At this point, Hello.message is not accessible anymore. *)\n\nlet goodbye () = print_endline \u0026quot;Goodbye\u0026quot;\n\nlet hello_goodbye () =\n  Hello.hello ();\n  goodbye ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe definition of the \u003ccode\u003eHello\u003c/code\u003e module above is the equivalent of a\n\u003ccode\u003ehello.mli\u003c/code\u003e/\u003ccode\u003ehello.ml\u003c/code\u003e pair of files. Writing all of that in one block of code\nis not elegant so, in general, we prefer to define the module signature\nseparately:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003emodule type Hello_type = sig\n val hello : unit -\u0026gt; unit\nend\n  \nmodule Hello : Hello_type = struct\n  ...\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eHello_type\u003c/code\u003e is a named module type, and can be reused to define other module\ninterfaces.\u003c/p\u003e\n\u003ch2 id=\"practical-manipulation-of-modules\"\u003ePractical manipulation of modules\u003c/h2\u003e\n\u003ch3 id=\"displaying-the-interface-of-a-module\"\u003eDisplaying the interface of a module\u003c/h3\u003e\n\u003cp\u003eYou can use the \u003ccode\u003eocaml\u003c/code\u003e toplevel to visualize the contents of an existing\nmodule, such as \u003ccode\u003eList\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# #show List;;\nmodule List = List\nmodule List :\n  sig\n    type 'a t = 'a list = [] | (::) of 'a * 'a list\n    val length : 'a t -\u0026gt; int\n    val compare_lengths : 'a t -\u0026gt; 'b t -\u0026gt; int\n    val compare_length_with : 'a t -\u0026gt; int -\u0026gt; int\n    val cons : 'a -\u0026gt; 'a t -\u0026gt; 'a t\n    val hd : 'a t -\u0026gt; 'a\n    val tl : 'a t -\u0026gt; 'a t\n    val nth : 'a t -\u0026gt; int -\u0026gt; 'a\n    val nth_opt : 'a t -\u0026gt; int -\u0026gt; 'a option\n    val rev : 'a t -\u0026gt; 'a t\n    val init : int -\u0026gt; (int -\u0026gt; 'a) -\u0026gt; 'a t\n    val append : 'a t -\u0026gt; 'a t -\u0026gt; 'a t\n    val rev_append : 'a t -\u0026gt; 'a t -\u0026gt; 'a t\n    val concat : 'a t t -\u0026gt; 'a t\n    val flatten : 'a t t -\u0026gt; 'a t\n    val iter : ('a -\u0026gt; unit) -\u0026gt; 'a t -\u0026gt; unit\n    val iteri : (int -\u0026gt; 'a -\u0026gt; unit) -\u0026gt; 'a t -\u0026gt; unit\n    val map : ('a -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b t\n    val mapi : (int -\u0026gt; 'a -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b t\n    val rev_map : ('a -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b t\n    val filter_map : ('a -\u0026gt; 'b option) -\u0026gt; 'a t -\u0026gt; 'b t\n    val concat_map : ('a -\u0026gt; 'b t) -\u0026gt; 'a t -\u0026gt; 'b t\n    val fold_left : ('a -\u0026gt; 'b -\u0026gt; 'a) -\u0026gt; 'a -\u0026gt; 'b t -\u0026gt; 'a\n    val fold_right : ('a -\u0026gt; 'b -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b -\u0026gt; 'b\n    val iter2 : ('a -\u0026gt; 'b -\u0026gt; unit) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; unit\n    val map2 : ('a -\u0026gt; 'b -\u0026gt; 'c) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; 'c t\n    val rev_map2 : ('a -\u0026gt; 'b -\u0026gt; 'c) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; 'c t\n    val fold_left2 : ('a -\u0026gt; 'b -\u0026gt; 'c -\u0026gt; 'a) -\u0026gt; 'a -\u0026gt; 'b t -\u0026gt; 'c t -\u0026gt; 'a\n    val fold_right2 : ('a -\u0026gt; 'b -\u0026gt; 'c -\u0026gt; 'c) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; 'c -\u0026gt; 'c\n    val for_all : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; bool\n    val exists : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; bool\n    val for_all2 : ('a -\u0026gt; 'b -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; bool\n    val exists2 : ('a -\u0026gt; 'b -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; bool\n    val mem : 'a -\u0026gt; 'a t -\u0026gt; bool\n    val memq : 'a -\u0026gt; 'a t -\u0026gt; bool\n    val find : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a\n    val find_opt : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a option\n    val find_map : ('a -\u0026gt; 'b option) -\u0026gt; 'a t -\u0026gt; 'b option\n    val filter : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a t\n    val find_all : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a t\n    val partition : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a t * 'a t\n    val assoc : 'a -\u0026gt; ('a * 'b) t -\u0026gt; 'b\n    val assoc_opt : 'a -\u0026gt; ('a * 'b) t -\u0026gt; 'b option\n    val assq : 'a -\u0026gt; ('a * 'b) t -\u0026gt; 'b\n    val assq_opt : 'a -\u0026gt; ('a * 'b) t -\u0026gt; 'b option\n    val mem_assoc : 'a -\u0026gt; ('a * 'b) t -\u0026gt; bool\n    val mem_assq : 'a -\u0026gt; ('a * 'b) t -\u0026gt; bool\n    val remove_assoc : 'a -\u0026gt; ('a * 'b) t -\u0026gt; ('a * 'b) t\n    val remove_assq : 'a -\u0026gt; ('a * 'b) t -\u0026gt; ('a * 'b) t\n    val split : ('a * 'b) t -\u0026gt; 'a t * 'b t\n    val combine : 'a t -\u0026gt; 'b t -\u0026gt; ('a * 'b) t\n    val sort : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t\n    val stable_sort : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t\n    val fast_sort : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t\n    val sort_uniq : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t\n    val merge : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t -\u0026gt; 'a t\n    val to_seq : 'a t -\u0026gt; 'a Seq.t\n    val of_seq : 'a Seq.t -\u0026gt; 'a t\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere is online documentation for each library.\u003c/p\u003e\n\u003ch3 id=\"module-inclusion\"\u003eModule inclusion\u003c/h3\u003e\n\u003cp\u003eLet's say we feel that a function is missing from the standard \u003ccode\u003eList\u003c/code\u003e module,\nbut we really want it as if it were part of it. In an \u003ccode\u003eextensions.ml\u003c/code\u003e file, we\ncan achieve this effect by using the \u003ccode\u003einclude\u003c/code\u003e directive:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# module List = struct\n  include List\n  let rec optmap f = function\n    | [] -\u0026gt; []\n    | hd :: tl -\u0026gt;\n       match f hd with\n       | None -\u0026gt; optmap f tl\n       | Some x -\u0026gt; x :: optmap f tl\n  end\nmodule List :\n  sig\n    type 'a t = 'a list = [] | (::) of 'a * 'a list\n    val length : 'a t -\u0026gt; int\n    val compare_lengths : 'a t -\u0026gt; 'b t -\u0026gt; int\n    val compare_length_with : 'a t -\u0026gt; int -\u0026gt; int\n    val cons : 'a -\u0026gt; 'a t -\u0026gt; 'a t\n    val hd : 'a t -\u0026gt; 'a\n    val tl : 'a t -\u0026gt; 'a t\n    val nth : 'a t -\u0026gt; int -\u0026gt; 'a\n    val nth_opt : 'a t -\u0026gt; int -\u0026gt; 'a option\n    val rev : 'a t -\u0026gt; 'a t\n    val init : int -\u0026gt; (int -\u0026gt; 'a) -\u0026gt; 'a t\n    val append : 'a t -\u0026gt; 'a t -\u0026gt; 'a t\n    val rev_append : 'a t -\u0026gt; 'a t -\u0026gt; 'a t\n    val concat : 'a t t -\u0026gt; 'a t\n    val flatten : 'a t t -\u0026gt; 'a t\n    val iter : ('a -\u0026gt; unit) -\u0026gt; 'a t -\u0026gt; unit\n    val iteri : (int -\u0026gt; 'a -\u0026gt; unit) -\u0026gt; 'a t -\u0026gt; unit\n    val map : ('a -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b t\n    val mapi : (int -\u0026gt; 'a -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b t\n    val rev_map : ('a -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b t\n    val filter_map : ('a -\u0026gt; 'b option) -\u0026gt; 'a t -\u0026gt; 'b t\n    val concat_map : ('a -\u0026gt; 'b t) -\u0026gt; 'a t -\u0026gt; 'b t\n    val fold_left : ('a -\u0026gt; 'b -\u0026gt; 'a) -\u0026gt; 'a -\u0026gt; 'b t -\u0026gt; 'a\n    val fold_right : ('a -\u0026gt; 'b -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b -\u0026gt; 'b\n    val iter2 : ('a -\u0026gt; 'b -\u0026gt; unit) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; unit\n    val map2 : ('a -\u0026gt; 'b -\u0026gt; 'c) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; 'c t\n    val rev_map2 : ('a -\u0026gt; 'b -\u0026gt; 'c) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; 'c t\n    val fold_left2 : ('a -\u0026gt; 'b -\u0026gt; 'c -\u0026gt; 'a) -\u0026gt; 'a -\u0026gt; 'b t -\u0026gt; 'c t -\u0026gt; 'a\n    val fold_right2 : ('a -\u0026gt; 'b -\u0026gt; 'c -\u0026gt; 'c) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; 'c -\u0026gt; 'c\n    val for_all : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; bool\n    val exists : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; bool\n    val for_all2 : ('a -\u0026gt; 'b -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; bool\n    val exists2 : ('a -\u0026gt; 'b -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; bool\n    val mem : 'a -\u0026gt; 'a t -\u0026gt; bool\n    val memq : 'a -\u0026gt; 'a t -\u0026gt; bool\n    val find : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a\n    val find_opt : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a option\n    val find_map : ('a -\u0026gt; 'b option) -\u0026gt; 'a t -\u0026gt; 'b option\n    val filter : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a t\n    val find_all : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a t\n    val partition : ('a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a t * 'a t\n    val assoc : 'a -\u0026gt; ('a * 'b) t -\u0026gt; 'b\n    val assoc_opt : 'a -\u0026gt; ('a * 'b) t -\u0026gt; 'b option\n    val assq : 'a -\u0026gt; ('a * 'b) t -\u0026gt; 'b\n    val assq_opt : 'a -\u0026gt; ('a * 'b) t -\u0026gt; 'b option\n    val mem_assoc : 'a -\u0026gt; ('a * 'b) t -\u0026gt; bool\n    val mem_assq : 'a -\u0026gt; ('a * 'b) t -\u0026gt; bool\n    val remove_assoc : 'a -\u0026gt; ('a * 'b) t -\u0026gt; ('a * 'b) t\n    val remove_assq : 'a -\u0026gt; ('a * 'b) t -\u0026gt; ('a * 'b) t\n    val split : ('a * 'b) t -\u0026gt; 'a t * 'b t\n    val combine : 'a t -\u0026gt; 'b t -\u0026gt; ('a * 'b) t\n    val sort : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t\n    val stable_sort : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t\n    val fast_sort : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t\n    val sort_uniq : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t\n    val merge : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t -\u0026gt; 'a t\n    val to_seq : 'a t -\u0026gt; 'a Seq.t\n    val of_seq : 'a Seq.t -\u0026gt; 'a t\n    val optmap : ('a -\u0026gt; 'b option) -\u0026gt; 'a t -\u0026gt; 'b t\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt creates a module \u003ccode\u003eExtensions.List\u003c/code\u003e that has everything the standard \u003ccode\u003eList\u003c/code\u003e\nmodule has, plus a new \u003ccode\u003eoptmap\u003c/code\u003e function. From another file, all we have to do\nto override the default \u003ccode\u003eList\u003c/code\u003e module is \u003ccode\u003eopen Extensions\u003c/code\u003e at the beginning of\nthe .ml file:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eopen Extensions\n\n...\n\nList.optmap ...\n\u003c/code\u003e\u003c/pre\u003e\n"},{"title":"Labels","slug":"labels","description":"Provide labels to your functions arguments\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"language","tl":0},"users":{"hd":"Intermediate","tl":{"hd":"Advanced","tl":0}},"body_md":"\n## Labelled and optional arguments to functions\n\nPython has a nice syntax for writing arguments to functions. Here's\nan example (from the Python tutorial, since I'm not a Python\nprogrammer):\n\n```python\ndef ask_ok(prompt, retries=4, complaint='Yes or no, please!'):\n  # function definition omitted\n```\nHere are the ways we can call this Python function:\n\n```python\nask_ok ('Do you really want to quit?')\nask_ok ('Overwrite the file?', 2)\nask_ok (prompt='Are you sure?')\nask_ok (complaint='Please answer yes or no!', prompt='Are you sure?')\n```\n\nNotice that in Python we are allowed to name arguments when we call\nthem, or use the usual function call syntax, and we can have optional\narguments with default values.\n\nOCaml also has a way to label arguments and have optional arguments with\ndefault values.\n\nThe basic syntax is:\n\n```ocaml\n# let rec range ~first:a ~last:b =\n  if a \u003e b then []\n  else a :: range ~first:(a + 1) ~last:b\nval range : first:int -\u003e last:int -\u003e int list = \u003cfun\u003e\n```\n\n(Notice that both `to` and `end` are reserved words in OCaml, so they\ncannot be used as labels. So you cannot have `~from/~to` or\n`~start/~end`.)\n\nThe type of our previous `range` function was:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nrange : int -\u003e int -\u003e int list\n```\n\nAnd the type of our new `range` function with labelled arguments is:\n\n```ocaml\n# range\n- : first:int -\u003e last:int -\u003e int list = \u003cfun\u003e\n```\n\nConfusingly, the `~` (tilde) is *not* shown in the type definition, but\nyou need to use it everywhere else.\n\nWith labelled arguments, it doesn't matter which order you give the\narguments anymore:\n\n```ocaml\n# range ~first:1 ~last:10\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range ~last:10 ~first:1\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n```\n\nThere is also a shorthand way to name the arguments, so that the label\nis the same as the variable in the function definition:\n\n```ocaml\n# let may ~f x =\n  match x with\n  | None -\u003e ()\n  | Some x -\u003e ignore (f x)\nval may : f:('a -\u003e 'b) -\u003e 'a option -\u003e unit = \u003cfun\u003e\n```\n\nIt's worth spending some time working out exactly what this function\ndoes, and also working out by hand its type signature. There's a lot\ngoing on. First of all, the parameter `~f` is just shorthand for `~f:f`\n(ie. the label is `~f` and the variable used in the function is `f`).\nSecondly notice that the function takes two parameters. The second\nparameter (`x`) is unlabelled - it is permitted for a function to take a\nmixture of labelled and unlabelled arguments if you want.\n\nWhat is the type of the labelled `f` parameter? Obviously it's a\nfunction of some sort.\n\nWhat is the type of the unlabelled `x` parameter? The `match` clause\ngives us a clue. It's an `'a option`.\n\nThis tells us that `f` takes an `'a` parameter, and the return value of\n`f` is ignored, so it could be anything. The type of `f` is therefore\n`'a -\u003e 'b`.\n\nThe `may` function as a whole returns `unit`. Notice in each case of the\n`match` the result is `()`.\n\nThus the type of the `may` function is (and you can verify this in the\nOCaml interactive toplevel if you want):\n\n```ocaml\n# may\n- : f:('a -\u003e 'b) -\u003e 'a option -\u003e unit = \u003cfun\u003e\n```\nWhat does this function do? Running the function in the OCaml toplevel\ngives us some clues:\n\n```ocaml\n# may ~f:print_endline None\n- : unit = ()\n# may ~f:print_endline (Some \"hello\")\nhello\n- : unit = ()\n```\n\nIf the unlabelled argument is a null pointer then `may` does nothing.\nOtherwise `may` calls the `f` function on the argument. Why is this\nuseful? We're just about to find out ...\n\n###  Optional arguments\nOptional arguments are like labelled arguments, but we use `?` instead\nof `~` in front of them. Here is an example:\n\n```ocaml\n# let rec range ?(step=1) a b =\n  if a \u003e b then []\n  else a :: range ~step (a + step) b\nval range : ?step:int -\u003e int -\u003e int -\u003e int list = \u003cfun\u003e\n```\n\nNote the somewhat confusing syntax, switching between `?` and `~`. We'll\ntalk about that in the next section. Here is how you call this function:\n\n```ocaml\n# range 1 10\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range 1 10 ~step:2\n- : int list = [1; 3; 5; 7; 9]\n```\n\nIn this case, `?(step=1)` fairly obviously means that `~step` is an\noptional argument which defaults to 1. We can also omit the default\nvalue and just have an optional argument. This example is modified from\nlablgtk:\n\n```ocaml\n# type window =\n  {mutable title: string;\n   mutable width: int;\n   mutable height: int}\ntype window = {\n  mutable title : string;\n  mutable width : int;\n  mutable height : int;\n}\n# let create_window () =\n  {title = \"none\"; width = 640; height = 480;}\nval create_window : unit -\u003e window = \u003cfun\u003e\n# let set_title window title =\n  window.title \u003c- title\nval set_title : window -\u003e string -\u003e unit = \u003cfun\u003e\n# let set_width window width =\n  window.width \u003c- width\nval set_width : window -\u003e int -\u003e unit = \u003cfun\u003e\n# let set_height window height =\n  window.height \u003c- height\nval set_height : window -\u003e int -\u003e unit = \u003cfun\u003e\n# let open_window ?title ?width ?height () =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nval open_window :\n  ?title:string -\u003e ?width:int -\u003e ?height:int -\u003e unit -\u003e window = \u003cfun\u003e\n```\n\nThis example is significantly complex and quite subtle, but the pattern\nused is very common in the lablgtk source code. Let's concentrate on the\nsimple `create_window` function first. This function takes a `unit` and\nreturns a `window`, initialized with default settings for title, width\nand height:\n\n```ocaml\n# create_window ()\n- : window = {title = \"none\"; width = 640; height = 480}\n```\n\nThe `set_title`, `set_width` and `set_height` functions are impure\nfunctions which modify the `window` structure, in the obvious way. For\nexample:\n\n```ocaml\n# let w = create_window () in\n  set_title w \"My Application\";\n  w\n- : window = {title = \"My Application\"; width = 640; height = 480}\n```\n\nSo far this is just the imperative \"mutable records\" which we talked\nabout in the previous chapter. Now the complex part is the `open_window`\nfunction. This function takes *4* arguments, three of them optional,\nfollowed by a required, unlabelled `unit`. Let's first see this function\nin action:\n\n```ocaml\n# open_window ~title:\"My Application\" ()\n- : window = {title = \"My Application\"; width = 640; height = 480}\n# open_window ~title:\"Clock\" ~width:128 ~height:128 ()\n- : window = {title = \"Clock\"; width = 128; height = 128}\n```\n\nIt does what you expect, but how?! The secret is in the `may` function\n(see above) and the fact that the optional parameters *don't* have\ndefaults.\n\nWhen an optional parameter doesn't have a default, then it has type\n`'a option`. The `'a` would normally be inferred by type inference, so\nin the case of `?title` above, this has type `string option`.\n\nRemember the `may` function? It takes a function and an argument, and\ncalls the function on the argument provided the argument isn't `None`.\nSo:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\n# may ~f:(set_title window) title\n```\n\nIf the optional title argument is not specified by the caller, then\n`title` = `None`, so `may` does nothing. But if we call the function\nwith, for example,\n\n```ocaml\n# open_window ~title:\"My Application\" ()\n- : window = {title = \"My Application\"; width = 640; height = 480}\n```\n\nthen `title` = `Some \"My Application\"`, and `may` therefore calls\n`set_title window \"My Application\"`.\n\nYou should make sure you fully understand this example before proceeding\nto the next section.\n\n###  \"Warning: This optional argument cannot be erased\"\nWe've just touched upon labels and optional arguments, but even this\nbrief explanation should have raised several questions. The first may be\nwhy the extra `unit` argument to `open_window`? Let's try defining this\nfunction without the extra `unit`:\n\n```ocaml\n# let open_window ?title ?width ?height =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nLine 1, characters 32-38:\nWarning 16: this optional argument cannot be erased.\nval open_window : ?title:string -\u003e ?width:int -\u003e ?height:int -\u003e window =\n  \u003cfun\u003e\n```\n\nAlthough OCaml has compiled the function, it has generated a somewhat\ninfamous warning: \"This optional argument cannot be erased\", referring\nto the final `?height` argument. To try to show what's going on here,\nlet's call our modified `open_window` function:\n\n```ocaml\n# open_window\n- : ?title:string -\u003e ?width:int -\u003e ?height:int -\u003e window = \u003cfun\u003e\n# open_window ~title:\"My Application\"\n- : ?width:int -\u003e ?height:int -\u003e window = \u003cfun\u003e\n```\n\nDid that work or not? No it didn't. In fact it didn't even run the\n`open_window` function at all. Instead it printed some strange type\ninformation. What's going on?\n\nRecall currying and uncurrying, and partial application of functions. If\nwe have a function `plus` defined as:\n\n```ocaml\n# let plus x y =\n  x + y\nval plus : int -\u003e int -\u003e int = \u003cfun\u003e\n```\nWe can partially apply this, for example as `plus 2` which is \"the\nfunction that adds 2 to things\":\n\n```ocaml\n# let f = plus 2\nval f : int -\u003e int = \u003cfun\u003e\n# f 5\n- : int = 7\n# f 100\n- : int = 102\n```\n\nIn the `plus` example, the OCaml compiler can easily work out that\n`plus 2` doesn't have enough arguments supplied yet. It needs another\nargument before the `plus` function itself can be executed. Therefore\n`plus 2` is a function which is waiting for its extra argument to come\nalong.\n\nThings are not so clear when we add optional arguments into the mix. The\ncall to `open_window;;` above is a case in point. Does the user mean\n\"execute `open_window` now\"? Or does the user mean to supply some or all\nof the optional arguments later? Is `open_window;;` waiting for extra\narguments to come along like `plus 2`?\n\nOCaml plays it safe and doesn't execute `open_window`. Instead it treats\nit as a partial function application. The expression `open_window`\nliterally evaluates to a function value.\n\nLet's go back to the original and working definition of `open_window`\nwhere we had the extra unlabelled `unit` argument at the end:\n\n```ocaml\n# let open_window ?title ?width ?height () =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nval open_window :\n  ?title:string -\u003e ?width:int -\u003e ?height:int -\u003e unit -\u003e window = \u003cfun\u003e\n```\n\nIf you want to pass optional arguments to `open_window` you must do so\nbefore the final `unit`, so if you type:\n\n```ocaml\n# open_window ()\n- : window = {title = \"none\"; width = 640; height = 480}\n```\nyou must mean \"execute `open_window` now with all optional arguments\nunspecified\". Whereas if you type:\n\n```ocaml\n# open_window\n- : ?title:string -\u003e ?width:int -\u003e ?height:int -\u003e unit -\u003e window = \u003cfun\u003e\n```\nyou mean \"give me the functional value\" or (more usually in the\ntoplevel) \"print out the type of `open_window`\".\n\n###  More `~`shorthand\nLet's rewrite the `range` function yet again, this time using as much\nshorthand as possible for the labels:\n\n```ocaml\n# let rec range ~first ~last =\n  if first \u003e last then []\n  else first :: range ~first:(first + 1) ~last\nval range : first:int -\u003e last:int -\u003e int list = \u003cfun\u003e\n```\n\nRecall that `~foo` on its own is short for `~foo:foo`. This applies also\nwhen calling functions as well as declaring the arguments to functions,\nhence in the above the highlighted red `~last` is short for\n`~last:last`.\n\n###  Using `?foo` in a function call\nThere's another little wrinkle concerning optional arguments. Suppose we\nwrite a function around `open_window` to open up an application:\n\n```ocaml\n# let open_application ?width ?height () =\n  open_window ~title:\"My Application\" ~width ~height\nLine 2, characters 40-45:\nError: This expression has type 'a option\n       but an expression was expected of type int\n```\n\nRecall that `~width` is shorthand for `~width:width`. The type of\n`width` is `'a option`, but `open_window ~width:` expects an `int`.\n\nOCaml provides more syntactic sugar. Writing `?width` in the function\ncall is shorthand for writing `~width:(unwrap width)` where `unwrap`\nwould be a function which would remove the \"`option` wrapper\" around\n`width` (it's not actually possible to write an `unwrap` function like\nthis, but conceptually that's the idea). So the correct way to write\nthis function is:\n\n```ocaml\n# let open_application ?width ?height () =\n  open_window ~title:\"My Application\" ?width ?height\nval open_application : ?width:int -\u003e ?height:int -\u003e unit -\u003e unit -\u003e window =\n  \u003cfun\u003e\n```\n\n###  When and when not to use `~` and `?`\nThe syntax for labels and optional arguments is confusing, and you may\noften wonder when to use `~foo`, when to use `?foo` and when to use\nplain `foo`. It's something of a black art which takes practice to get\nright.\n\n`?foo` is only used when declaring the arguments of a function, ie:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet f ?arg1 ... =\n```\n\nor when using the specialised \"unwrap `option` wrapper\" form for\nfunction calls:\n\n```ocaml\n# let open_application ?width ?height () =\n  open_window ~title:\"My Application\" ?width ?height\nval open_application : ?width:int -\u003e ?height:int -\u003e unit -\u003e unit -\u003e window =\n  \u003cfun\u003e\n```\nThe declaration `?foo` creates a variable called `foo`, so if you need\nthe value of `?foo`, use just `foo`.\n\nThe same applies to labels. Only use the `~foo` form when declaring\narguments of a function, ie:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet f ~foo:foo ... =\n```\n\nThe declaration `~foo:foo` creates a variable called simply `foo`, so if\nyou need the value just use plain `foo`.\n\nThings, however, get complicated for two reasons: first, the shorthand\nform `~foo` (equivalent to `~foo:foo`), and second, when you call a\nfunction which takes a labelled or optional argument and you use the\nshorthand form.\n\nHere is some apparently obscure code from lablgtk to demonstrate all of\nthis:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\n# let html ?border_width ?width ?height ?packing ?show () =  (* line 1 *)\n  let w = create () in\n  load_empty w;\n  Container.set w ?border_width ?width ?height;            (* line 4 *)\n  pack_return (new html w) ~packing ~show                  (* line 5 *)\n```\nOn line 1 we have the function definition. Notice there are 5 optional\narguments, and the mandatory `unit` 6\u003csup\u003eth\u003c/sup\u003e argument. Each of the\noptional arguments is going to define a variable, eg. `border_width`, of\ntype `'a option`.\n\nOn line 4 we use the special `?foo` form for passing optional arguments\nto functions which take optional arguments. `Container.set` has the\nfollowing type:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmodule Container = struct\n  let set ?border_width ?(width = -2) ?(height = -2) w =\n    (* ... *)\n```\nLine 5 uses the `~`shorthand. Writing this in long form:\n\n```ocaml\n# pack_return (new html w) ~packing:packing ~show:show\nLine 1, characters 1-12:\nError: Unbound value pack_return\n```\n\nThe `pack_return` function actually takes mandatory labelled arguments\ncalled `~packing` and `~show`, each of type `'a option`. In other words,\n`pack_return` explicitly unwraps the `option` wrapper.\n\n## More variants (polymorphic variants)\nTry compiling the following C code:\n\n```C\n#include \u003cstdio.h\u003e\n#include \u003cfcntl.h\u003e\n#include \u003cunistd.h\u003e\n\nenum lock { open, close };\n\nmain ()\n{\n  int fd, n;\n  char buffer[256];\n\n  fd = open (\"/etc/motd\", O_RDONLY);                     // line 12\n  while ((n = read (fd, buffer, sizeof buffer)) \u003e 0)\n    write (1, buffer, n);\n  close (fd);                                            // line 15\n}\n```\nWhen I compile the code I get a whole bunch of errors including:\n\n```text\ntest.c: In function `main':\ntest.c:12: error: called object is not a function\ntest.c:15: error: called object is not a function\n```\nThis illustrates one problem with enumerated types (enums) in C. In the\nexample above, one enum statement reserves *three* symbols, namely\n`lock`, `open` and `close`. Here's another example:\n\n```C\nenum lock { open, close };\nenum door { open, close };\n```\nCompiling gives:\n\n```text\ntest.c:2: error: conflicting types for `open'\ntest.c:1: error: previous declaration of `open'\ntest.c:2: error: conflicting types for `close'\ntest.c:1: error: previous declaration of `close'\n```\nThe first enum defines the symbol `open` as something of type\n`enum lock`. You cannot reuse that symbol in another enum.\n\nThis will be familiar to most C/C++ programmers, and they won't write\nnaive code like that above. However the same issue happens with OCaml\nvariants, but OCaml provides a way to work around it.\n\nHere is some OCaml code, which actually *does* compile:\n\n```ocaml\n# type lock = Open | Close\ntype lock = Open | Close\n# type door = Open | Close\ntype door = Open | Close\n```\nAfter running those two statements, what is the type of `Open`? We can\nfind out easily enough in the toplevel:\n\n```ocaml\n# type lock = Open | Close\ntype lock = Open | Close\n# type door = Open | Close\ntype door = Open | Close\n# Open\n- : door = Open\n```\n\nOCaml uses the most recent definition for `Open`, giving it the type\n`door`. This is actually not such a serious problem because if you\naccidentally tried to use `Open` in the type context of a `lock`, then\nOCaml's wonderful type inference would immediately spot the error and\nyou wouldn't be able to compile the code.\n\nSo far, so much like C. Now I said that OCaml provides a way to work\naround the constraint that `Open` can only have one type. In other\nwords, suppose I want to use `Open` to mean either \"the `Open` of type\n`lock`\" or \"the `Open` of type `door`\" and I want OCaml to work out\nwhich one I mean.\n\nThe syntax is slightly different, but here is how we do it:\n\n```ocaml\n# type lock = [ `Open | `Close ]\ntype lock = [ `Close | `Open ]\n# type door = [ `Open | `Close ]\ntype door = [ `Close | `Open ]\n```\nNotice the syntactic differences:\n\n1. Each variant name is prefixed with `` ` `` (a back tick).\n1. You have to put square brackets (`[]`) around the alternatives.\n\nThe question naturally arises: What is the type of `` `Open``?\n\n```ocaml\n# `Open\n- : [\u003e `Open ] = `Open\n```\n`` [\u003e `Open] `` can be read as\n`` [ `Open | and some other possibilities which we don't know about ] ``.\n\nThe \u003e (greater than) sign indicates that the set of possibilities is\nbigger than those listed (open-ended).\n\nThere's nothing special about `` `Open ``. *Any* back-ticked word can be\nused as a type, even one which we haven't mentioned before:\n\n```ocaml\n# `Foo\n- : [\u003e `Foo ] = `Foo\n# `Foo 42\n- : [\u003e `Foo of int ] = `Foo 42\n```\nLet's write a function to print the state of a `lock`:\n\n```ocaml\n# let print_lock st =\n  match st with\n  | `Open -\u003e print_endline \"The lock is open\"\n  | `Close -\u003e print_endline \"The lock is closed\"\nval print_lock : [\u003c `Close | `Open ] -\u003e unit = \u003cfun\u003e\n```\nTake a careful look at the type of that function. Type inference has\nworked out that the `st` argument has type `` [\u003c `Close | `Open] ``. The\n`\u003c` (less than) sign means that this is a __closed class__. In\nother words, this function will only work on `` `Close`` or `` `Open``\nand not on anything else.\n\n```ocaml\n# print_lock `Open\nThe lock is open\n- : unit = ()\n```\n\nNotice that `print_lock` works just as well with a `door` as with a\n`lock`! We've deliberately given up some type safety, and type inference\nis now being used to help guess what we mean, rather than enforce\ncorrect coding.\n\nThis is only an introduction to polymorphic variants. Because of the\nreduction in type safety, it is recommended that you don't use these in\nyour code. You will, however, see them in advanced OCaml code quite a\nlot precisely because advanced programmers will sometimes want to weaken\nthe type system to write advanced idioms.\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#labelled-and-optional-arguments-to-functions\"\u003eLabelled and optional arguments to functions\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#more-variants-polymorphic-variants\"\u003eMore variants (polymorphic variants)\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"labelled-and-optional-arguments-to-functions\"\u003eLabelled and optional arguments to functions\u003c/h2\u003e\n\u003cp\u003ePython has a nice syntax for writing arguments to functions. Here's\nan example (from the Python tutorial, since I'm not a Python\nprogrammer):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef ask_ok(prompt, retries=4, complaint='Yes or no, please!'):\n  # function definition omitted\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere are the ways we can call this Python function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eask_ok ('Do you really want to quit?')\nask_ok ('Overwrite the file?', 2)\nask_ok (prompt='Are you sure?')\nask_ok (complaint='Please answer yes or no!', prompt='Are you sure?')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that in Python we are allowed to name arguments when we call\nthem, or use the usual function call syntax, and we can have optional\narguments with default values.\u003c/p\u003e\n\u003cp\u003eOCaml also has a way to label arguments and have optional arguments with\ndefault values.\u003c/p\u003e\n\u003cp\u003eThe basic syntax is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range ~first:a ~last:b =\n  if a \u0026gt; b then []\n  else a :: range ~first:(a + 1) ~last:b\nval range : first:int -\u0026gt; last:int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Notice that both \u003ccode\u003eto\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e are reserved words in OCaml, so they\ncannot be used as labels. So you cannot have \u003ccode\u003e~from/~to\u003c/code\u003e or\n\u003ccode\u003e~start/~end\u003c/code\u003e.)\u003c/p\u003e\n\u003cp\u003eThe type of our previous \u003ccode\u003erange\u003c/code\u003e function was:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003erange : int -\u0026gt; int -\u0026gt; int list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd the type of our new \u003ccode\u003erange\u003c/code\u003e function with labelled arguments is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# range\n- : first:int -\u0026gt; last:int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eConfusingly, the \u003ccode\u003e~\u003c/code\u003e (tilde) is \u003cem\u003enot\u003c/em\u003e shown in the type definition, but\nyou need to use it everywhere else.\u003c/p\u003e\n\u003cp\u003eWith labelled arguments, it doesn't matter which order you give the\narguments anymore:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# range ~first:1 ~last:10\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range ~last:10 ~first:1\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere is also a shorthand way to name the arguments, so that the label\nis the same as the variable in the function definition:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let may ~f x =\n  match x with\n  | None -\u0026gt; ()\n  | Some x -\u0026gt; ignore (f x)\nval may : f:('a -\u0026gt; 'b) -\u0026gt; 'a option -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt's worth spending some time working out exactly what this function\ndoes, and also working out by hand its type signature. There's a lot\ngoing on. First of all, the parameter \u003ccode\u003e~f\u003c/code\u003e is just shorthand for \u003ccode\u003e~f:f\u003c/code\u003e\n(ie. the label is \u003ccode\u003e~f\u003c/code\u003e and the variable used in the function is \u003ccode\u003ef\u003c/code\u003e).\nSecondly notice that the function takes two parameters. The second\nparameter (\u003ccode\u003ex\u003c/code\u003e) is unlabelled - it is permitted for a function to take a\nmixture of labelled and unlabelled arguments if you want.\u003c/p\u003e\n\u003cp\u003eWhat is the type of the labelled \u003ccode\u003ef\u003c/code\u003e parameter? Obviously it's a\nfunction of some sort.\u003c/p\u003e\n\u003cp\u003eWhat is the type of the unlabelled \u003ccode\u003ex\u003c/code\u003e parameter? The \u003ccode\u003ematch\u003c/code\u003e clause\ngives us a clue. It's an \u003ccode\u003e'a option\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis tells us that \u003ccode\u003ef\u003c/code\u003e takes an \u003ccode\u003e'a\u003c/code\u003e parameter, and the return value of\n\u003ccode\u003ef\u003c/code\u003e is ignored, so it could be anything. The type of \u003ccode\u003ef\u003c/code\u003e is therefore\n\u003ccode\u003e'a -\u0026gt; 'b\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003emay\u003c/code\u003e function as a whole returns \u003ccode\u003eunit\u003c/code\u003e. Notice in each case of the\n\u003ccode\u003ematch\u003c/code\u003e the result is \u003ccode\u003e()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThus the type of the \u003ccode\u003emay\u003c/code\u003e function is (and you can verify this in the\nOCaml interactive toplevel if you want):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# may\n- : f:('a -\u0026gt; 'b) -\u0026gt; 'a option -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat does this function do? Running the function in the OCaml toplevel\ngives us some clues:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# may ~f:print_endline None\n- : unit = ()\n# may ~f:print_endline (Some \u0026quot;hello\u0026quot;)\nhello\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the unlabelled argument is a null pointer then \u003ccode\u003emay\u003c/code\u003e does nothing.\nOtherwise \u003ccode\u003emay\u003c/code\u003e calls the \u003ccode\u003ef\u003c/code\u003e function on the argument. Why is this\nuseful? We're just about to find out ...\u003c/p\u003e\n\u003ch3 id=\"optional-arguments\"\u003eOptional arguments\u003c/h3\u003e\n\u003cp\u003eOptional arguments are like labelled arguments, but we use \u003ccode\u003e?\u003c/code\u003e instead\nof \u003ccode\u003e~\u003c/code\u003e in front of them. Here is an example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range ?(step=1) a b =\n  if a \u0026gt; b then []\n  else a :: range ~step (a + step) b\nval range : ?step:int -\u0026gt; int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the somewhat confusing syntax, switching between \u003ccode\u003e?\u003c/code\u003e and \u003ccode\u003e~\u003c/code\u003e. We'll\ntalk about that in the next section. Here is how you call this function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# range 1 10\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n# range 1 10 ~step:2\n- : int list = [1; 3; 5; 7; 9]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this case, \u003ccode\u003e?(step=1)\u003c/code\u003e fairly obviously means that \u003ccode\u003e~step\u003c/code\u003e is an\noptional argument which defaults to 1. We can also omit the default\nvalue and just have an optional argument. This example is modified from\nlablgtk:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type window =\n  {mutable title: string;\n   mutable width: int;\n   mutable height: int}\ntype window = {\n  mutable title : string;\n  mutable width : int;\n  mutable height : int;\n}\n# let create_window () =\n  {title = \u0026quot;none\u0026quot;; width = 640; height = 480;}\nval create_window : unit -\u0026gt; window = \u0026lt;fun\u0026gt;\n# let set_title window title =\n  window.title \u0026lt;- title\nval set_title : window -\u0026gt; string -\u0026gt; unit = \u0026lt;fun\u0026gt;\n# let set_width window width =\n  window.width \u0026lt;- width\nval set_width : window -\u0026gt; int -\u0026gt; unit = \u0026lt;fun\u0026gt;\n# let set_height window height =\n  window.height \u0026lt;- height\nval set_height : window -\u0026gt; int -\u0026gt; unit = \u0026lt;fun\u0026gt;\n# let open_window ?title ?width ?height () =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nval open_window :\n  ?title:string -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; unit -\u0026gt; window = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis example is significantly complex and quite subtle, but the pattern\nused is very common in the lablgtk source code. Let's concentrate on the\nsimple \u003ccode\u003ecreate_window\u003c/code\u003e function first. This function takes a \u003ccode\u003eunit\u003c/code\u003e and\nreturns a \u003ccode\u003ewindow\u003c/code\u003e, initialized with default settings for title, width\nand height:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# create_window ()\n- : window = {title = \u0026quot;none\u0026quot;; width = 640; height = 480}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eset_title\u003c/code\u003e, \u003ccode\u003eset_width\u003c/code\u003e and \u003ccode\u003eset_height\u003c/code\u003e functions are impure\nfunctions which modify the \u003ccode\u003ewindow\u003c/code\u003e structure, in the obvious way. For\nexample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let w = create_window () in\n  set_title w \u0026quot;My Application\u0026quot;;\n  w\n- : window = {title = \u0026quot;My Application\u0026quot;; width = 640; height = 480}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo far this is just the imperative \u0026quot;mutable records\u0026quot; which we talked\nabout in the previous chapter. Now the complex part is the \u003ccode\u003eopen_window\u003c/code\u003e\nfunction. This function takes \u003cem\u003e4\u003c/em\u003e arguments, three of them optional,\nfollowed by a required, unlabelled \u003ccode\u003eunit\u003c/code\u003e. Let's first see this function\nin action:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# open_window ~title:\u0026quot;My Application\u0026quot; ()\n- : window = {title = \u0026quot;My Application\u0026quot;; width = 640; height = 480}\n# open_window ~title:\u0026quot;Clock\u0026quot; ~width:128 ~height:128 ()\n- : window = {title = \u0026quot;Clock\u0026quot;; width = 128; height = 128}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt does what you expect, but how?! The secret is in the \u003ccode\u003emay\u003c/code\u003e function\n(see above) and the fact that the optional parameters \u003cem\u003edon't\u003c/em\u003e have\ndefaults.\u003c/p\u003e\n\u003cp\u003eWhen an optional parameter doesn't have a default, then it has type\n\u003ccode\u003e'a option\u003c/code\u003e. The \u003ccode\u003e'a\u003c/code\u003e would normally be inferred by type inference, so\nin the case of \u003ccode\u003e?title\u003c/code\u003e above, this has type \u003ccode\u003estring option\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eRemember the \u003ccode\u003emay\u003c/code\u003e function? It takes a function and an argument, and\ncalls the function on the argument provided the argument isn't \u003ccode\u003eNone\u003c/code\u003e.\nSo:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# may ~f:(set_title window) title\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the optional title argument is not specified by the caller, then\n\u003ccode\u003etitle\u003c/code\u003e = \u003ccode\u003eNone\u003c/code\u003e, so \u003ccode\u003emay\u003c/code\u003e does nothing. But if we call the function\nwith, for example,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# open_window ~title:\u0026quot;My Application\u0026quot; ()\n- : window = {title = \u0026quot;My Application\u0026quot;; width = 640; height = 480}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethen \u003ccode\u003etitle\u003c/code\u003e = \u003ccode\u003eSome \u0026quot;My Application\u0026quot;\u003c/code\u003e, and \u003ccode\u003emay\u003c/code\u003e therefore calls\n\u003ccode\u003eset_title window \u0026quot;My Application\u0026quot;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou should make sure you fully understand this example before proceeding\nto the next section.\u003c/p\u003e\n\u003ch3 id=\"warning-this-optional-argument-cannot-be-erased\"\u003e\u0026quot;Warning: This optional argument cannot be erased\u0026quot;\u003c/h3\u003e\n\u003cp\u003eWe've just touched upon labels and optional arguments, but even this\nbrief explanation should have raised several questions. The first may be\nwhy the extra \u003ccode\u003eunit\u003c/code\u003e argument to \u003ccode\u003eopen_window\u003c/code\u003e? Let's try defining this\nfunction without the extra \u003ccode\u003eunit\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let open_window ?title ?width ?height =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nLine 1, characters 32-38:\nWarning 16: this optional argument cannot be erased.\nval open_window : ?title:string -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; window =\n  \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlthough OCaml has compiled the function, it has generated a somewhat\ninfamous warning: \u0026quot;This optional argument cannot be erased\u0026quot;, referring\nto the final \u003ccode\u003e?height\u003c/code\u003e argument. To try to show what's going on here,\nlet's call our modified \u003ccode\u003eopen_window\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# open_window\n- : ?title:string -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; window = \u0026lt;fun\u0026gt;\n# open_window ~title:\u0026quot;My Application\u0026quot;\n- : ?width:int -\u0026gt; ?height:int -\u0026gt; window = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDid that work or not? No it didn't. In fact it didn't even run the\n\u003ccode\u003eopen_window\u003c/code\u003e function at all. Instead it printed some strange type\ninformation. What's going on?\u003c/p\u003e\n\u003cp\u003eRecall currying and uncurrying, and partial application of functions. If\nwe have a function \u003ccode\u003eplus\u003c/code\u003e defined as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let plus x y =\n  x + y\nval plus : int -\u0026gt; int -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can partially apply this, for example as \u003ccode\u003eplus 2\u003c/code\u003e which is \u0026quot;the\nfunction that adds 2 to things\u0026quot;:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let f = plus 2\nval f : int -\u0026gt; int = \u0026lt;fun\u0026gt;\n# f 5\n- : int = 7\n# f 100\n- : int = 102\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the \u003ccode\u003eplus\u003c/code\u003e example, the OCaml compiler can easily work out that\n\u003ccode\u003eplus 2\u003c/code\u003e doesn't have enough arguments supplied yet. It needs another\nargument before the \u003ccode\u003eplus\u003c/code\u003e function itself can be executed. Therefore\n\u003ccode\u003eplus 2\u003c/code\u003e is a function which is waiting for its extra argument to come\nalong.\u003c/p\u003e\n\u003cp\u003eThings are not so clear when we add optional arguments into the mix. The\ncall to \u003ccode\u003eopen_window;;\u003c/code\u003e above is a case in point. Does the user mean\n\u0026quot;execute \u003ccode\u003eopen_window\u003c/code\u003e now\u0026quot;? Or does the user mean to supply some or all\nof the optional arguments later? Is \u003ccode\u003eopen_window;;\u003c/code\u003e waiting for extra\narguments to come along like \u003ccode\u003eplus 2\u003c/code\u003e?\u003c/p\u003e\n\u003cp\u003eOCaml plays it safe and doesn't execute \u003ccode\u003eopen_window\u003c/code\u003e. Instead it treats\nit as a partial function application. The expression \u003ccode\u003eopen_window\u003c/code\u003e\nliterally evaluates to a function value.\u003c/p\u003e\n\u003cp\u003eLet's go back to the original and working definition of \u003ccode\u003eopen_window\u003c/code\u003e\nwhere we had the extra unlabelled \u003ccode\u003eunit\u003c/code\u003e argument at the end:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let open_window ?title ?width ?height () =\n  let window = create_window () in\n  may ~f:(set_title window) title;\n  may ~f:(set_width window) width;\n  may ~f:(set_height window) height;\n  window\nval open_window :\n  ?title:string -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; unit -\u0026gt; window = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you want to pass optional arguments to \u003ccode\u003eopen_window\u003c/code\u003e you must do so\nbefore the final \u003ccode\u003eunit\u003c/code\u003e, so if you type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# open_window ()\n- : window = {title = \u0026quot;none\u0026quot;; width = 640; height = 480}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eyou must mean \u0026quot;execute \u003ccode\u003eopen_window\u003c/code\u003e now with all optional arguments\nunspecified\u0026quot;. Whereas if you type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# open_window\n- : ?title:string -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; unit -\u0026gt; window = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eyou mean \u0026quot;give me the functional value\u0026quot; or (more usually in the\ntoplevel) \u0026quot;print out the type of \u003ccode\u003eopen_window\u003c/code\u003e\u0026quot;.\u003c/p\u003e\n\u003ch3 id=\"more-shorthand\"\u003eMore \u003ccode\u003e~\u003c/code\u003eshorthand\u003c/h3\u003e\n\u003cp\u003eLet's rewrite the \u003ccode\u003erange\u003c/code\u003e function yet again, this time using as much\nshorthand as possible for the labels:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range ~first ~last =\n  if first \u0026gt; last then []\n  else first :: range ~first:(first + 1) ~last\nval range : first:int -\u0026gt; last:int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRecall that \u003ccode\u003e~foo\u003c/code\u003e on its own is short for \u003ccode\u003e~foo:foo\u003c/code\u003e. This applies also\nwhen calling functions as well as declaring the arguments to functions,\nhence in the above the highlighted red \u003ccode\u003e~last\u003c/code\u003e is short for\n\u003ccode\u003e~last:last\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"using-foo-in-a-function-call\"\u003eUsing \u003ccode\u003e?foo\u003c/code\u003e in a function call\u003c/h3\u003e\n\u003cp\u003eThere's another little wrinkle concerning optional arguments. Suppose we\nwrite a function around \u003ccode\u003eopen_window\u003c/code\u003e to open up an application:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let open_application ?width ?height () =\n  open_window ~title:\u0026quot;My Application\u0026quot; ~width ~height\nLine 2, characters 40-45:\nError: This expression has type 'a option\n       but an expression was expected of type int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRecall that \u003ccode\u003e~width\u003c/code\u003e is shorthand for \u003ccode\u003e~width:width\u003c/code\u003e. The type of\n\u003ccode\u003ewidth\u003c/code\u003e is \u003ccode\u003e'a option\u003c/code\u003e, but \u003ccode\u003eopen_window ~width:\u003c/code\u003e expects an \u003ccode\u003eint\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOCaml provides more syntactic sugar. Writing \u003ccode\u003e?width\u003c/code\u003e in the function\ncall is shorthand for writing \u003ccode\u003e~width:(unwrap width)\u003c/code\u003e where \u003ccode\u003eunwrap\u003c/code\u003e\nwould be a function which would remove the \u0026quot;\u003ccode\u003eoption\u003c/code\u003e wrapper\u0026quot; around\n\u003ccode\u003ewidth\u003c/code\u003e (it's not actually possible to write an \u003ccode\u003eunwrap\u003c/code\u003e function like\nthis, but conceptually that's the idea). So the correct way to write\nthis function is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let open_application ?width ?height () =\n  open_window ~title:\u0026quot;My Application\u0026quot; ?width ?height\nval open_application : ?width:int -\u0026gt; ?height:int -\u0026gt; unit -\u0026gt; unit -\u0026gt; window =\n  \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"when-and-when-not-to-use--and-\"\u003eWhen and when not to use \u003ccode\u003e~\u003c/code\u003e and \u003ccode\u003e?\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eThe syntax for labels and optional arguments is confusing, and you may\noften wonder when to use \u003ccode\u003e~foo\u003c/code\u003e, when to use \u003ccode\u003e?foo\u003c/code\u003e and when to use\nplain \u003ccode\u003efoo\u003c/code\u003e. It's something of a black art which takes practice to get\nright.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e?foo\u003c/code\u003e is only used when declaring the arguments of a function, ie:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet f ?arg1 ... =\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor when using the specialised \u0026quot;unwrap \u003ccode\u003eoption\u003c/code\u003e wrapper\u0026quot; form for\nfunction calls:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let open_application ?width ?height () =\n  open_window ~title:\u0026quot;My Application\u0026quot; ?width ?height\nval open_application : ?width:int -\u0026gt; ?height:int -\u0026gt; unit -\u0026gt; unit -\u0026gt; window =\n  \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe declaration \u003ccode\u003e?foo\u003c/code\u003e creates a variable called \u003ccode\u003efoo\u003c/code\u003e, so if you need\nthe value of \u003ccode\u003e?foo\u003c/code\u003e, use just \u003ccode\u003efoo\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe same applies to labels. Only use the \u003ccode\u003e~foo\u003c/code\u003e form when declaring\narguments of a function, ie:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet f ~foo:foo ... =\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe declaration \u003ccode\u003e~foo:foo\u003c/code\u003e creates a variable called simply \u003ccode\u003efoo\u003c/code\u003e, so if\nyou need the value just use plain \u003ccode\u003efoo\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThings, however, get complicated for two reasons: first, the shorthand\nform \u003ccode\u003e~foo\u003c/code\u003e (equivalent to \u003ccode\u003e~foo:foo\u003c/code\u003e), and second, when you call a\nfunction which takes a labelled or optional argument and you use the\nshorthand form.\u003c/p\u003e\n\u003cp\u003eHere is some apparently obscure code from lablgtk to demonstrate all of\nthis:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let html ?border_width ?width ?height ?packing ?show () =  (* line 1 *)\n  let w = create () in\n  load_empty w;\n  Container.set w ?border_width ?width ?height;            (* line 4 *)\n  pack_return (new html w) ~packing ~show                  (* line 5 *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn line 1 we have the function definition. Notice there are 5 optional\narguments, and the mandatory \u003ccode\u003eunit\u003c/code\u003e 6\u003csup\u003eth\u003c/sup\u003e argument. Each of the\noptional arguments is going to define a variable, eg. \u003ccode\u003eborder_width\u003c/code\u003e, of\ntype \u003ccode\u003e'a option\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOn line 4 we use the special \u003ccode\u003e?foo\u003c/code\u003e form for passing optional arguments\nto functions which take optional arguments. \u003ccode\u003eContainer.set\u003c/code\u003e has the\nfollowing type:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003emodule Container = struct\n  let set ?border_width ?(width = -2) ?(height = -2) w =\n    (* ... *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLine 5 uses the \u003ccode\u003e~\u003c/code\u003eshorthand. Writing this in long form:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# pack_return (new html w) ~packing:packing ~show:show\nLine 1, characters 1-12:\nError: Unbound value pack_return\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003epack_return\u003c/code\u003e function actually takes mandatory labelled arguments\ncalled \u003ccode\u003e~packing\u003c/code\u003e and \u003ccode\u003e~show\u003c/code\u003e, each of type \u003ccode\u003e'a option\u003c/code\u003e. In other words,\n\u003ccode\u003epack_return\u003c/code\u003e explicitly unwraps the \u003ccode\u003eoption\u003c/code\u003e wrapper.\u003c/p\u003e\n\u003ch2 id=\"more-variants-polymorphic-variants\"\u003eMore variants (polymorphic variants)\u003c/h2\u003e\n\u003cp\u003eTry compiling the following C code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003e#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;fcntl.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nenum lock { open, close };\n\nmain ()\n{\n  int fd, n;\n  char buffer[256];\n\n  fd = open (\u0026quot;/etc/motd\u0026quot;, O_RDONLY);                     // line 12\n  while ((n = read (fd, buffer, sizeof buffer)) \u0026gt; 0)\n    write (1, buffer, n);\n  close (fd);                                            // line 15\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen I compile the code I get a whole bunch of errors including:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003etest.c: In function `main':\ntest.c:12: error: called object is not a function\ntest.c:15: error: called object is not a function\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis illustrates one problem with enumerated types (enums) in C. In the\nexample above, one enum statement reserves \u003cem\u003ethree\u003c/em\u003e symbols, namely\n\u003ccode\u003elock\u003c/code\u003e, \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eclose\u003c/code\u003e. Here's another example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003eenum lock { open, close };\nenum door { open, close };\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCompiling gives:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003etest.c:2: error: conflicting types for `open'\ntest.c:1: error: previous declaration of `open'\ntest.c:2: error: conflicting types for `close'\ntest.c:1: error: previous declaration of `close'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe first enum defines the symbol \u003ccode\u003eopen\u003c/code\u003e as something of type\n\u003ccode\u003eenum lock\u003c/code\u003e. You cannot reuse that symbol in another enum.\u003c/p\u003e\n\u003cp\u003eThis will be familiar to most C/C++ programmers, and they won't write\nnaive code like that above. However the same issue happens with OCaml\nvariants, but OCaml provides a way to work around it.\u003c/p\u003e\n\u003cp\u003eHere is some OCaml code, which actually \u003cem\u003edoes\u003c/em\u003e compile:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type lock = Open | Close\ntype lock = Open | Close\n# type door = Open | Close\ntype door = Open | Close\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter running those two statements, what is the type of \u003ccode\u003eOpen\u003c/code\u003e? We can\nfind out easily enough in the toplevel:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type lock = Open | Close\ntype lock = Open | Close\n# type door = Open | Close\ntype door = Open | Close\n# Open\n- : door = Open\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOCaml uses the most recent definition for \u003ccode\u003eOpen\u003c/code\u003e, giving it the type\n\u003ccode\u003edoor\u003c/code\u003e. This is actually not such a serious problem because if you\naccidentally tried to use \u003ccode\u003eOpen\u003c/code\u003e in the type context of a \u003ccode\u003elock\u003c/code\u003e, then\nOCaml's wonderful type inference would immediately spot the error and\nyou wouldn't be able to compile the code.\u003c/p\u003e\n\u003cp\u003eSo far, so much like C. Now I said that OCaml provides a way to work\naround the constraint that \u003ccode\u003eOpen\u003c/code\u003e can only have one type. In other\nwords, suppose I want to use \u003ccode\u003eOpen\u003c/code\u003e to mean either \u0026quot;the \u003ccode\u003eOpen\u003c/code\u003e of type\n\u003ccode\u003elock\u003c/code\u003e\u0026quot; or \u0026quot;the \u003ccode\u003eOpen\u003c/code\u003e of type \u003ccode\u003edoor\u003c/code\u003e\u0026quot; and I want OCaml to work out\nwhich one I mean.\u003c/p\u003e\n\u003cp\u003eThe syntax is slightly different, but here is how we do it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type lock = [ `Open | `Close ]\ntype lock = [ `Close | `Open ]\n# type door = [ `Open | `Close ]\ntype door = [ `Close | `Open ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice the syntactic differences:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eEach variant name is prefixed with \u003ccode\u003e`\u003c/code\u003e (a back tick).\n\u003c/li\u003e\n\u003cli\u003eYou have to put square brackets (\u003ccode\u003e[]\u003c/code\u003e) around the alternatives.\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe question naturally arises: What is the type of \u003ccode\u003e `Open\u003c/code\u003e?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# `Open\n- : [\u0026gt; `Open ] = `Open\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e[\u0026gt; `Open]\u003c/code\u003e can be read as\n\u003ccode\u003e[ `Open | and some other possibilities which we don't know about ]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u0026gt; (greater than) sign indicates that the set of possibilities is\nbigger than those listed (open-ended).\u003c/p\u003e\n\u003cp\u003eThere's nothing special about \u003ccode\u003e`Open\u003c/code\u003e. \u003cem\u003eAny\u003c/em\u003e back-ticked word can be\nused as a type, even one which we haven't mentioned before:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# `Foo\n- : [\u0026gt; `Foo ] = `Foo\n# `Foo 42\n- : [\u0026gt; `Foo of int ] = `Foo 42\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's write a function to print the state of a \u003ccode\u003elock\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let print_lock st =\n  match st with\n  | `Open -\u0026gt; print_endline \u0026quot;The lock is open\u0026quot;\n  | `Close -\u0026gt; print_endline \u0026quot;The lock is closed\u0026quot;\nval print_lock : [\u0026lt; `Close | `Open ] -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTake a careful look at the type of that function. Type inference has\nworked out that the \u003ccode\u003est\u003c/code\u003e argument has type \u003ccode\u003e[\u0026lt; `Close | `Open]\u003c/code\u003e. The\n\u003ccode\u003e\u0026lt;\u003c/code\u003e (less than) sign means that this is a \u003cstrong\u003eclosed class\u003c/strong\u003e. In\nother words, this function will only work on \u003ccode\u003e `Close\u003c/code\u003e or \u003ccode\u003e `Open\u003c/code\u003e\nand not on anything else.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# print_lock `Open\nThe lock is open\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that \u003ccode\u003eprint_lock\u003c/code\u003e works just as well with a \u003ccode\u003edoor\u003c/code\u003e as with a\n\u003ccode\u003elock\u003c/code\u003e! We've deliberately given up some type safety, and type inference\nis now being used to help guess what we mean, rather than enforce\ncorrect coding.\u003c/p\u003e\n\u003cp\u003eThis is only an introduction to polymorphic variants. Because of the\nreduction in type safety, it is recommended that you don't use these in\nyour code. You will, however, see them in advanced OCaml code quite a\nlot precisely because advanced programmers will sometimes want to weaken\nthe type system to write advanced idioms.\u003c/p\u003e\n"},{"title":"Pointers in OCaml","slug":"pointers-in-ocaml","description":"Use OCaml's explicit pointers with references\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"language","tl":0},"users":{"hd":"Intermediate","tl":{"hd":"Advanced","tl":0}},"body_md":"\n## Status of pointers in OCaml\nPointers exist in OCaml, and in fact they spread all over the place.\nThey are used either implicitly (in the most cases), or explicitly (in\nthe rare occasions where implicit pointers are not more handy). The vast\nmajority of pointers usages that are found in usual programming\nlanguages simply disappear in OCaml, or more exactly, those pointers are\ntotally automatically handled by the compiler. Thus, the OCaml programmer\ncan safely ignore the existence of pointers, focusing on the semantics of their\nprogram.\n\nFor instance, lists or trees are defined without explicit pointers using\na concrete datatype definition. The underlying implementation uses\npointers, but this is hidden from the programmer since pointer\nhandling is done by the compiler.\n\nIn the rare occasions where explicit pointers are needed (the most\ncommon case is when translating into OCaml an algorithm described in a\nclassic imperative language), OCaml provides references that are\nfull-fledged pointers, even first class citizen pointers (references can\nbe passed as argument, embedded into arbitrary data structures, and\nreturned as function results).\n\n###  Explicit pointers are OCaml values of type `ref`\nYou can program directly with explicit references if you want to, but\nthis is normally a waste of time and effort.\n\nLet's examine the simple example of linked lists (integer lists to be\nsimple). This data type is defined in C (or in Pascal) using explicit\npointers, for instance:\n\n```C\n/* Cells and lists type in C */\nstruct cell {\n  int hd;\n  struct cell *tl;\n};\n\ntypedef struct cell cell, *list;\n```\n```Pascal\n{Cells and lists type in Pascal}\ntype\n list = ^cell;\n cell = record\n  hd: integer;\n  tl: cell;\n end;\n```\nWe can translate this in OCaml, using a sum type definition, without\npointers:\n\n```ocaml\n# type list = Nil | Cons of int * list\ntype list = Nil | Cons of int * list\n```\n\nCell lists are thus represented as pairs, and the recursive structure of\nlists is evident, with the two alternatives, empty list (the\n`Nil`constructor) and non empty list (the `Cons` constructor).\n\nAutomatic management of pointers and automatic memory allocation shine\nwhen allocating list values: one just writes `Cons (x, l)` to add `x` in\nfront of the list `l`. In C, you need to write this function, to\nallocate a new cell and then fill its fields. For instance:\n\n```C\n/* The empty list */\n#define nil NULL\n\n/* The constructor of lists */\nlist cons (element x, list l)\n{\n  list result;\n  result = (list) malloc (sizeof (cell));\n  result -\u003e hd = x;\n  result -\u003e tl = l;\n  return (result);\n}\n```\nSimilarly, in Pascal:\n\n```Pascal\n{Creating a list cell}\nfunction cons (x: integer; l: list): list;\n  var p: list;\n  begin\n    new(p);\n    p^.hd := x;\n    p^.tl := l;\n    cons := p\n  end;\n```\nWe thus see that fields of list cells in the C program have to be\nmutable, otherwise initialization is impossible. By contrast in OCaml,\nallocation and initialization are merged into a single basic operation:\nconstructor application. This way, immutable data structures are\ndefinable (those data types are often referred to as pure or\nfunctional data structures). If physical modifications are necessary\nfor other reasons than mere initialization, OCaml provides records with\nmutable fields. For instance, a list type defining lists whose elements\ncan be in place modified could be written:\n\n```ocaml\n# type list = Nil | Cons of cell\n  and cell = { mutable hd : int; tl : list }\ntype list = Nil | Cons of cell\nand cell = { mutable hd : int; tl : list; }\n```\nIf the structure of the list itself must also be modified (cells must be\nphysically removed from the list), the `tl` field would also be declared\nas mutable:\n\n```ocaml\n# type list = Nil | Cons of cell\n  and cell = { mutable hd : int; mutable tl : list }\ntype list = Nil | Cons of cell\nand cell = { mutable hd : int; mutable tl : list; }\n```\n\nPhysical assignments are still useless to allocate mutable data: you\nwrite `Cons {hd = 1; tl = l}` to add `1` to the list `l`. Physical\nassignments that remain in OCaml programs should be just those\nassignments that are mandatory to implement the algorithm at hand.\n\nVery often, pointers are used to implement physical modification of data\nstructures. In OCaml programs this means using vectors or mutable fields\nin records.\n\n**In conclusion:** You can use explicit pointers in OCaml, exactly as in C, but\nthis is not natural, since you get back the usual drawbacks and difficulties of\nexplicit pointers manipulation of classical algorithmic languages. See a more\ncomplete example below.\n\n## Defining pointers in OCaml\nThe general pointer type can be defined using the definition of a\npointer: a pointer is either null, or a pointer to an assignable memory\nlocation:\n\n```ocaml\n# type 'a pointer = Null | Pointer of 'a ref\ntype 'a pointer = Null | Pointer of 'a ref\n```\nExplicit dereferencing (or reading the pointer's designated value) and\npointer assignment (or writing to the pointer's designated memory\nlocation) are easily defined. We define dereferencing as a prefix\noperator named `!^`, and assignment as the infix `^:=`.\n\n```ocaml\n# let ( !^ ) = function\n    | Null -\u003e invalid_arg \"Attempt to dereference the null pointer\"\n    | Pointer r -\u003e !r\nval ( !^ ) : 'a pointer -\u003e 'a = \u003cfun\u003e\n\n# let ( ^:= ) p v =\n    match p with\n     | Null -\u003e invalid_arg \"Attempt to assign the null pointer\"\n     | Pointer r -\u003e r := v\nval ( ^:= ) : 'a pointer -\u003e 'a -\u003e unit = \u003cfun\u003e\n```\n\nNow we define the allocation of a new pointer initialized to point to a\ngiven value:\n\n```ocaml\n# let new_pointer x = Pointer (ref x)\nval new_pointer : 'a -\u003e 'a pointer = \u003cfun\u003e\n```\nFor instance, let's define and then assign a pointer to an integer:\n\n```ocaml\n# let p = new_pointer 0\nval p : int pointer = Pointer {contents = 0}\n# p ^:= 1\n- : unit = ()\n# !^p\n- : int = 1\n```\n\n## Integer Lists\nNow we can define lists using explicit pointers as in usual imperative\nlanguages:\n\n```ocaml\n# type ilist = cell pointer\n  and cell = { mutable hd : int; mutable tl : ilist }\ntype ilist = cell pointer\nand cell = { mutable hd : int; mutable tl : ilist; }\n```\nWe then define allocation of a new cell, the list constructor and its\nassociated destructors.\n\n```ocaml\n# let new_cell () = {hd = 0; tl = Null}\nval new_cell : unit -\u003e cell = \u003cfun\u003e\n# let cons x l =\n    let c = new_cell () in\n    c.hd \u003c- x;\n    c.tl \u003c- l;\n    (new_pointer c : ilist)\nval cons : int -\u003e ilist -\u003e ilist = \u003cfun\u003e\n# let hd (l : ilist) = !^l.hd\nval hd : ilist -\u003e int = \u003cfun\u003e\n# let tl (l : ilist) = !^l.tl\nval tl : ilist -\u003e ilist = \u003cfun\u003e\n```\n\nWe can now write all kind of classical algorithms, based on pointers\nmanipulation, with their associated loops, their unwanted sharing\nproblems and their null pointer errors. For instance, list\nconcatenation, as often described in literature, physically modifies\nits first list argument, hooking the second list to the end of the\nfirst:\n\n```ocaml\n# let append (l1 : ilist) (l2 : ilist) =\n  let temp = ref l1 in\n  while tl !temp \u003c\u003e Null do\n    temp := tl !temp\n  done;\n  !^ !temp.tl \u003c- l2\nval append : ilist -\u003e ilist -\u003e unit = \u003cfun\u003e\n\n# let l1 = cons 1 (cons 2 Null)\nval l1 : ilist =\n  Pointer\n   {contents = {hd = 1; tl = Pointer {contents = {hd = 2; tl = Null}}}}\n\n# let l2 = cons 3 Null\nval l2 : ilist = Pointer {contents = {hd = 3; tl = Null}}\n\n# append l1 l2\n- : unit = ()\n```\n\nThe lists `l1` and `l2` are effectively catenated:\n\n```ocaml\n# l1\n- : ilist =\nPointer\n {contents =\n   {hd = 1;\n    tl =\n     Pointer\n      {contents = {hd = 2; tl = Pointer {contents = {hd = 3; tl = Null}}}}}}\n```\n\nJust a nasty side effect of physical list concatenation: `l1` now\ncontains the concatenation of the two lists `l1` and `l2`, thus the list\n`l1` no longer exists: in some sense `append` *consumes* its first\nargument. In other words, the value of a list data now depends on its\nhistory, that is on the sequence of function calls that use the value.\nThis strange behaviour leads to a lot of difficulties when explicitly\nmanipulating pointers. Try for instance, the seemingly harmless:\n\n```ocaml\n# append l1 l1\n- : unit = ()\n```\n\nThen evaluate `l1`:\n\n```ocaml\n# l1\n- : ilist =\nPointer\n {contents =\n   {hd = 1;\n    tl =\n     Pointer\n      {contents = {hd = 2; tl = Pointer {contents = {hd = 3; tl = \u003ccycle\u003e}}}}}}\n```\n\n## Polymorphic lists\nWe can define polymorphic lists using pointers; here is a simple implementation\nof those polymorphic mutable lists:\n\n```ocaml\n# type 'a lists = 'a cell pointer\n  and 'a cell = { mutable hd : 'a pointer; mutable tl : 'a lists }\ntype 'a lists = 'a cell pointer\nand 'a cell = { mutable hd : 'a pointer; mutable tl : 'a lists; }\n# let new_cell () = {hd = Null; tl = Null}\nval new_cell : unit -\u003e 'a cell = \u003cfun\u003e\n# let cons x l =\n    let c = new_cell () in\n    c.hd \u003c- new_pointer x;\n    c.tl \u003c- l;\n    (new_pointer c : 'a lists)\nval cons : 'a -\u003e 'a lists -\u003e 'a lists = \u003cfun\u003e\n# let hd (l : 'a lists) = !^l.hd\nval hd : 'a lists -\u003e 'a pointer = \u003cfun\u003e\n# let tl (l : 'a lists) = !^l.tl\nval tl : 'a lists -\u003e 'a lists = \u003cfun\u003e\n# let append (l1 : 'a lists) (l2 : 'a lists) =\n  let temp = ref l1 in\n  while tl !temp \u003c\u003e Null do\n    temp := tl !temp\n  done;\n  !^ !temp.tl \u003c- l2\nval append : 'a lists -\u003e 'a lists -\u003e unit = \u003cfun\u003e\n```\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#status-of-pointers-in-ocaml\"\u003eStatus of pointers in OCaml\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defining-pointers-in-ocaml\"\u003eDefining pointers in OCaml\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#integer-lists\"\u003eInteger Lists\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#polymorphic-lists\"\u003ePolymorphic lists\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"status-of-pointers-in-ocaml\"\u003eStatus of pointers in OCaml\u003c/h2\u003e\n\u003cp\u003ePointers exist in OCaml, and in fact they spread all over the place.\nThey are used either implicitly (in the most cases), or explicitly (in\nthe rare occasions where implicit pointers are not more handy). The vast\nmajority of pointers usages that are found in usual programming\nlanguages simply disappear in OCaml, or more exactly, those pointers are\ntotally automatically handled by the compiler. Thus, the OCaml programmer\ncan safely ignore the existence of pointers, focusing on the semantics of their\nprogram.\u003c/p\u003e\n\u003cp\u003eFor instance, lists or trees are defined without explicit pointers using\na concrete datatype definition. The underlying implementation uses\npointers, but this is hidden from the programmer since pointer\nhandling is done by the compiler.\u003c/p\u003e\n\u003cp\u003eIn the rare occasions where explicit pointers are needed (the most\ncommon case is when translating into OCaml an algorithm described in a\nclassic imperative language), OCaml provides references that are\nfull-fledged pointers, even first class citizen pointers (references can\nbe passed as argument, embedded into arbitrary data structures, and\nreturned as function results).\u003c/p\u003e\n\u003ch3 id=\"explicit-pointers-are-ocaml-values-of-type-ref\"\u003eExplicit pointers are OCaml values of type \u003ccode\u003eref\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eYou can program directly with explicit references if you want to, but\nthis is normally a waste of time and effort.\u003c/p\u003e\n\u003cp\u003eLet's examine the simple example of linked lists (integer lists to be\nsimple). This data type is defined in C (or in Pascal) using explicit\npointers, for instance:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003e/* Cells and lists type in C */\nstruct cell {\n  int hd;\n  struct cell *tl;\n};\n\ntypedef struct cell cell, *list;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-Pascal\"\u003e{Cells and lists type in Pascal}\ntype\n list = ^cell;\n cell = record\n  hd: integer;\n  tl: cell;\n end;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can translate this in OCaml, using a sum type definition, without\npointers:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type list = Nil | Cons of int * list\ntype list = Nil | Cons of int * list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCell lists are thus represented as pairs, and the recursive structure of\nlists is evident, with the two alternatives, empty list (the\n\u003ccode\u003eNil\u003c/code\u003econstructor) and non empty list (the \u003ccode\u003eCons\u003c/code\u003e constructor).\u003c/p\u003e\n\u003cp\u003eAutomatic management of pointers and automatic memory allocation shine\nwhen allocating list values: one just writes \u003ccode\u003eCons (x, l)\u003c/code\u003e to add \u003ccode\u003ex\u003c/code\u003e in\nfront of the list \u003ccode\u003el\u003c/code\u003e. In C, you need to write this function, to\nallocate a new cell and then fill its fields. For instance:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003e/* The empty list */\n#define nil NULL\n\n/* The constructor of lists */\nlist cons (element x, list l)\n{\n  list result;\n  result = (list) malloc (sizeof (cell));\n  result -\u0026gt; hd = x;\n  result -\u0026gt; tl = l;\n  return (result);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSimilarly, in Pascal:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Pascal\"\u003e{Creating a list cell}\nfunction cons (x: integer; l: list): list;\n  var p: list;\n  begin\n    new(p);\n    p^.hd := x;\n    p^.tl := l;\n    cons := p\n  end;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe thus see that fields of list cells in the C program have to be\nmutable, otherwise initialization is impossible. By contrast in OCaml,\nallocation and initialization are merged into a single basic operation:\nconstructor application. This way, immutable data structures are\ndefinable (those data types are often referred to as pure or\nfunctional data structures). If physical modifications are necessary\nfor other reasons than mere initialization, OCaml provides records with\nmutable fields. For instance, a list type defining lists whose elements\ncan be in place modified could be written:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type list = Nil | Cons of cell\n  and cell = { mutable hd : int; tl : list }\ntype list = Nil | Cons of cell\nand cell = { mutable hd : int; tl : list; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the structure of the list itself must also be modified (cells must be\nphysically removed from the list), the \u003ccode\u003etl\u003c/code\u003e field would also be declared\nas mutable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type list = Nil | Cons of cell\n  and cell = { mutable hd : int; mutable tl : list }\ntype list = Nil | Cons of cell\nand cell = { mutable hd : int; mutable tl : list; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePhysical assignments are still useless to allocate mutable data: you\nwrite \u003ccode\u003eCons {hd = 1; tl = l}\u003c/code\u003e to add \u003ccode\u003e1\u003c/code\u003e to the list \u003ccode\u003el\u003c/code\u003e. Physical\nassignments that remain in OCaml programs should be just those\nassignments that are mandatory to implement the algorithm at hand.\u003c/p\u003e\n\u003cp\u003eVery often, pointers are used to implement physical modification of data\nstructures. In OCaml programs this means using vectors or mutable fields\nin records.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIn conclusion:\u003c/strong\u003e You can use explicit pointers in OCaml, exactly as in C, but\nthis is not natural, since you get back the usual drawbacks and difficulties of\nexplicit pointers manipulation of classical algorithmic languages. See a more\ncomplete example below.\u003c/p\u003e\n\u003ch2 id=\"defining-pointers-in-ocaml\"\u003eDefining pointers in OCaml\u003c/h2\u003e\n\u003cp\u003eThe general pointer type can be defined using the definition of a\npointer: a pointer is either null, or a pointer to an assignable memory\nlocation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type 'a pointer = Null | Pointer of 'a ref\ntype 'a pointer = Null | Pointer of 'a ref\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eExplicit dereferencing (or reading the pointer's designated value) and\npointer assignment (or writing to the pointer's designated memory\nlocation) are easily defined. We define dereferencing as a prefix\noperator named \u003ccode\u003e!^\u003c/code\u003e, and assignment as the infix \u003ccode\u003e^:=\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let ( !^ ) = function\n    | Null -\u0026gt; invalid_arg \u0026quot;Attempt to dereference the null pointer\u0026quot;\n    | Pointer r -\u0026gt; !r\nval ( !^ ) : 'a pointer -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n\n# let ( ^:= ) p v =\n    match p with\n     | Null -\u0026gt; invalid_arg \u0026quot;Attempt to assign the null pointer\u0026quot;\n     | Pointer r -\u0026gt; r := v\nval ( ^:= ) : 'a pointer -\u0026gt; 'a -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we define the allocation of a new pointer initialized to point to a\ngiven value:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let new_pointer x = Pointer (ref x)\nval new_pointer : 'a -\u0026gt; 'a pointer = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor instance, let's define and then assign a pointer to an integer:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let p = new_pointer 0\nval p : int pointer = Pointer {contents = 0}\n# p ^:= 1\n- : unit = ()\n# !^p\n- : int = 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"integer-lists\"\u003eInteger Lists\u003c/h2\u003e\n\u003cp\u003eNow we can define lists using explicit pointers as in usual imperative\nlanguages:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type ilist = cell pointer\n  and cell = { mutable hd : int; mutable tl : ilist }\ntype ilist = cell pointer\nand cell = { mutable hd : int; mutable tl : ilist; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe then define allocation of a new cell, the list constructor and its\nassociated destructors.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let new_cell () = {hd = 0; tl = Null}\nval new_cell : unit -\u0026gt; cell = \u0026lt;fun\u0026gt;\n# let cons x l =\n    let c = new_cell () in\n    c.hd \u0026lt;- x;\n    c.tl \u0026lt;- l;\n    (new_pointer c : ilist)\nval cons : int -\u0026gt; ilist -\u0026gt; ilist = \u0026lt;fun\u0026gt;\n# let hd (l : ilist) = !^l.hd\nval hd : ilist -\u0026gt; int = \u0026lt;fun\u0026gt;\n# let tl (l : ilist) = !^l.tl\nval tl : ilist -\u0026gt; ilist = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can now write all kind of classical algorithms, based on pointers\nmanipulation, with their associated loops, their unwanted sharing\nproblems and their null pointer errors. For instance, list\nconcatenation, as often described in literature, physically modifies\nits first list argument, hooking the second list to the end of the\nfirst:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let append (l1 : ilist) (l2 : ilist) =\n  let temp = ref l1 in\n  while tl !temp \u0026lt;\u0026gt; Null do\n    temp := tl !temp\n  done;\n  !^ !temp.tl \u0026lt;- l2\nval append : ilist -\u0026gt; ilist -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\n# let l1 = cons 1 (cons 2 Null)\nval l1 : ilist =\n  Pointer\n   {contents = {hd = 1; tl = Pointer {contents = {hd = 2; tl = Null}}}}\n\n# let l2 = cons 3 Null\nval l2 : ilist = Pointer {contents = {hd = 3; tl = Null}}\n\n# append l1 l2\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe lists \u003ccode\u003el1\u003c/code\u003e and \u003ccode\u003el2\u003c/code\u003e are effectively catenated:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# l1\n- : ilist =\nPointer\n {contents =\n   {hd = 1;\n    tl =\n     Pointer\n      {contents = {hd = 2; tl = Pointer {contents = {hd = 3; tl = Null}}}}}}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJust a nasty side effect of physical list concatenation: \u003ccode\u003el1\u003c/code\u003e now\ncontains the concatenation of the two lists \u003ccode\u003el1\u003c/code\u003e and \u003ccode\u003el2\u003c/code\u003e, thus the list\n\u003ccode\u003el1\u003c/code\u003e no longer exists: in some sense \u003ccode\u003eappend\u003c/code\u003e \u003cem\u003econsumes\u003c/em\u003e its first\nargument. In other words, the value of a list data now depends on its\nhistory, that is on the sequence of function calls that use the value.\nThis strange behaviour leads to a lot of difficulties when explicitly\nmanipulating pointers. Try for instance, the seemingly harmless:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# append l1 l1\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen evaluate \u003ccode\u003el1\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# l1\n- : ilist =\nPointer\n {contents =\n   {hd = 1;\n    tl =\n     Pointer\n      {contents = {hd = 2; tl = Pointer {contents = {hd = 3; tl = \u0026lt;cycle\u0026gt;}}}}}}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"polymorphic-lists\"\u003ePolymorphic lists\u003c/h2\u003e\n\u003cp\u003eWe can define polymorphic lists using pointers; here is a simple implementation\nof those polymorphic mutable lists:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type 'a lists = 'a cell pointer\n  and 'a cell = { mutable hd : 'a pointer; mutable tl : 'a lists }\ntype 'a lists = 'a cell pointer\nand 'a cell = { mutable hd : 'a pointer; mutable tl : 'a lists; }\n# let new_cell () = {hd = Null; tl = Null}\nval new_cell : unit -\u0026gt; 'a cell = \u0026lt;fun\u0026gt;\n# let cons x l =\n    let c = new_cell () in\n    c.hd \u0026lt;- new_pointer x;\n    c.tl \u0026lt;- l;\n    (new_pointer c : 'a lists)\nval cons : 'a -\u0026gt; 'a lists -\u0026gt; 'a lists = \u0026lt;fun\u0026gt;\n# let hd (l : 'a lists) = !^l.hd\nval hd : 'a lists -\u0026gt; 'a pointer = \u0026lt;fun\u0026gt;\n# let tl (l : 'a lists) = !^l.tl\nval tl : 'a lists -\u0026gt; 'a lists = \u0026lt;fun\u0026gt;\n# let append (l1 : 'a lists) (l2 : 'a lists) =\n  let temp = ref l1 in\n  while tl !temp \u0026lt;\u0026gt; Null do\n    temp := tl !temp\n  done;\n  !^ !temp.tl \u0026lt;- l2\nval append : 'a lists -\u0026gt; 'a lists -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n"},{"title":"Null Pointers, Asserts and Warnings","slug":"null-pointers-asserts-and-warnings","description":"Handling warnings and asserting invariants for your code\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"language","tl":0},"users":{"hd":"Intermediate","tl":{"hd":"Advanced","tl":0}},"body_md":"\n## Null pointers\nSo you've got a survey on your website which asks your readers for their\nnames and ages. Only problem is that for some reason a few of your\nreaders don't want to give you their age - they stubbornly refuse to\nfill that field in. What's a poor database administrator to do?\n\nAssume that the age is represented by an `int`, there are two possible\nways to solve this problem. The most common one (and the most *wrong*\none) is to assume some sort of \"special\" value for the age which means\nthat the age information wasn't collected. So if, say, age = -1 then the\ndata wasn't collected, otherwise the data was collected (even if it's\nnot valid!). This method kind of works until you start, for example,\ncalculating the mean age of visitors to your website. Since you forgot\nto take into account your special value, you conclude that the mean age\nof visitors is 7 years old, and you employ web designers to remove all\nthe long words and use primary colours everywhere.\n\nThe other, correct method is to store the age in a field which has type\n\"int or null\". Here's a SQL table for storing ages:\n\n```SQL\ncreate table users\n(\n  userid serial,\n  name text not null,\n  age int             -- may be null\n);\n```\n\nIf the age data isn't collected, then it goes into the database as a\nspecial SQL `NULL` value. SQL ignores this automatically when you ask it\nto compute averages and so on.\n\nProgramming languages also support nulls, although they may be easier to\nuse in some than in others. In Java, any reference to\nan object can be null, so it might make sense in Java to store the\nage as an `Integer` and allow references to the age to be null. In C\npointers can, of course, be null, but if you wanted a simple integer to\nbe null, you'd have to first box it up into an object allocated by\n`malloc` on the heap.\n\nOCaml has an elegant solution to the problem of nulls, using a simple\npolymorphic variant type defined (in `Stdlib`) as:\n\n```ocaml\ntype 'a option = None | Some of 'a\n```\n\nA \"null pointer\" is written `None`. The type of age in our example above\n(an `int` which can be null) is `int option` (remember: backwards like\n`int list` and `int binary_tree`).\n\n```ocaml\n# Some 3\n- : int option = Some 3\n```\n\nWhat about a list of optional ints?\n\n```ocaml\n# [None; Some 3; Some 6; None]\n- : int option list = [None; Some 3; Some 6; None]\n```\nAnd what about an optional list of ints?\n\n```ocaml\n# Some [1; 2; 3]\n- : int list option = Some [1; 2; 3]\n```\n\n## Assert, warnings, fatal errors, and printing to stderr\nThe built-in `assert` takes an expression as an argument and throws an\nexception *if* the provided expression evaluates to `false`. \nAssuming that you don't catch this exception (it's probably\nunwise to catch this exception, particularly for beginners), this\nresults in the program stopping and printing out the source file and\nline number where the error occurred. An example:\n\n```ocaml\n# assert (Sys.os_type = \"Win32\")\nException: Assert_failure (\"//toplevel//\", 1, 1).\n```\n\n(Running this on Win32, of course, won't throw an error).\n\nYou can also just call `assert false` to stop your program if things\njust aren't going well, but you're probably better to use ...\n\n`failwith \"error message\"` throws a `Failure` exception, which again\nassuming you don't try to catch it, will stop the program with the given\nerror message. `failwith` is often used during pattern matching, like\nthis real example:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmatch Sys.os_type with\n| \"Unix\" | \"Cygwin\" -\u003e   (* code omitted *)\n| \"Win32\" -\u003e             (* code omitted *)\n| \"MacOS\" -\u003e             (* code omitted *)\n| _ -\u003e failwith \"this system is not supported\"\n```\n\nNote a couple of extra pattern matching features in this example too. A\nso-called \"range pattern\" is used to match either `\"Unix\"` or\n`\"Cygwin\"`, and the special `_` pattern which matches \"anything else\".\n\nIf you want to debug your program, then you'll probably want to print out a\nwarning some way through your function. Here's an example:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nopen Graphics\n  \nlet () =\n  open_graph \" 640x480\";\n  for i = 12 downto 1 do\n    let radius = i * 20 in\n    prerr_endline (\"radius is \" ^ string_of_int radius);\n    set_color (if i mod 2 = 0 then red else yellow);\n    fill_circle 320 240 radius\n  done;\n  ignore(read_line ())\n```\n\nIf you prefer C-style `printf`'s then try using OCaml's `Printf` module\ninstead:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nopen Graphics\n  \nlet () =\n  open_graph \" 640x480\";\n  for i = 12 downto 1 do\n    let radius = i * 20 in\n    Printf.eprintf \"radius is %d\\n\" radius;\n    set_color (if i mod 2 = 0 then red else yellow);\n    fill_circle 320 240 radius\n  done;\n  ignore(read_line ())\n```\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#null-pointers\"\u003eNull pointers\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#assert-warnings-fatal-errors-and-printing-to-stderr\"\u003eAssert, warnings, fatal errors, and printing to stderr\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"null-pointers\"\u003eNull pointers\u003c/h2\u003e\n\u003cp\u003eSo you've got a survey on your website which asks your readers for their\nnames and ages. Only problem is that for some reason a few of your\nreaders don't want to give you their age - they stubbornly refuse to\nfill that field in. What's a poor database administrator to do?\u003c/p\u003e\n\u003cp\u003eAssume that the age is represented by an \u003ccode\u003eint\u003c/code\u003e, there are two possible\nways to solve this problem. The most common one (and the most \u003cem\u003ewrong\u003c/em\u003e\none) is to assume some sort of \u0026quot;special\u0026quot; value for the age which means\nthat the age information wasn't collected. So if, say, age = -1 then the\ndata wasn't collected, otherwise the data was collected (even if it's\nnot valid!). This method kind of works until you start, for example,\ncalculating the mean age of visitors to your website. Since you forgot\nto take into account your special value, you conclude that the mean age\nof visitors is 7 years old, and you employ web designers to remove all\nthe long words and use primary colours everywhere.\u003c/p\u003e\n\u003cp\u003eThe other, correct method is to store the age in a field which has type\n\u0026quot;int or null\u0026quot;. Here's a SQL table for storing ages:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-SQL\"\u003ecreate table users\n(\n  userid serial,\n  name text not null,\n  age int             -- may be null\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the age data isn't collected, then it goes into the database as a\nspecial SQL \u003ccode\u003eNULL\u003c/code\u003e value. SQL ignores this automatically when you ask it\nto compute averages and so on.\u003c/p\u003e\n\u003cp\u003eProgramming languages also support nulls, although they may be easier to\nuse in some than in others. In Java, any reference to\nan object can be null, so it might make sense in Java to store the\nage as an \u003ccode\u003eInteger\u003c/code\u003e and allow references to the age to be null. In C\npointers can, of course, be null, but if you wanted a simple integer to\nbe null, you'd have to first box it up into an object allocated by\n\u003ccode\u003emalloc\u003c/code\u003e on the heap.\u003c/p\u003e\n\u003cp\u003eOCaml has an elegant solution to the problem of nulls, using a simple\npolymorphic variant type defined (in \u003ccode\u003eStdlib\u003c/code\u003e) as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype 'a option = None | Some of 'a\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA \u0026quot;null pointer\u0026quot; is written \u003ccode\u003eNone\u003c/code\u003e. The type of age in our example above\n(an \u003ccode\u003eint\u003c/code\u003e which can be null) is \u003ccode\u003eint option\u003c/code\u003e (remember: backwards like\n\u003ccode\u003eint list\u003c/code\u003e and \u003ccode\u003eint binary_tree\u003c/code\u003e).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Some 3\n- : int option = Some 3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat about a list of optional ints?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# [None; Some 3; Some 6; None]\n- : int option list = [None; Some 3; Some 6; None]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd what about an optional list of ints?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Some [1; 2; 3]\n- : int list option = Some [1; 2; 3]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"assert-warnings-fatal-errors-and-printing-to-stderr\"\u003eAssert, warnings, fatal errors, and printing to stderr\u003c/h2\u003e\n\u003cp\u003eThe built-in \u003ccode\u003eassert\u003c/code\u003e takes an expression as an argument and throws an\nexception \u003cem\u003eif\u003c/em\u003e the provided expression evaluates to \u003ccode\u003efalse\u003c/code\u003e.\nAssuming that you don't catch this exception (it's probably\nunwise to catch this exception, particularly for beginners), this\nresults in the program stopping and printing out the source file and\nline number where the error occurred. An example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# assert (Sys.os_type = \u0026quot;Win32\u0026quot;)\nException: Assert_failure (\u0026quot;//toplevel//\u0026quot;, 1, 1).\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Running this on Win32, of course, won't throw an error).\u003c/p\u003e\n\u003cp\u003eYou can also just call \u003ccode\u003eassert false\u003c/code\u003e to stop your program if things\njust aren't going well, but you're probably better to use ...\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efailwith \u0026quot;error message\u0026quot;\u003c/code\u003e throws a \u003ccode\u003eFailure\u003c/code\u003e exception, which again\nassuming you don't try to catch it, will stop the program with the given\nerror message. \u003ccode\u003efailwith\u003c/code\u003e is often used during pattern matching, like\nthis real example:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ematch Sys.os_type with\n| \u0026quot;Unix\u0026quot; | \u0026quot;Cygwin\u0026quot; -\u0026gt;   (* code omitted *)\n| \u0026quot;Win32\u0026quot; -\u0026gt;             (* code omitted *)\n| \u0026quot;MacOS\u0026quot; -\u0026gt;             (* code omitted *)\n| _ -\u0026gt; failwith \u0026quot;this system is not supported\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote a couple of extra pattern matching features in this example too. A\nso-called \u0026quot;range pattern\u0026quot; is used to match either \u003ccode\u003e\u0026quot;Unix\u0026quot;\u003c/code\u003e or\n\u003ccode\u003e\u0026quot;Cygwin\u0026quot;\u003c/code\u003e, and the special \u003ccode\u003e_\u003c/code\u003e pattern which matches \u0026quot;anything else\u0026quot;.\u003c/p\u003e\n\u003cp\u003eIf you want to debug your program, then you'll probably want to print out a\nwarning some way through your function. Here's an example:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eopen Graphics\n  \nlet () =\n  open_graph \u0026quot; 640x480\u0026quot;;\n  for i = 12 downto 1 do\n    let radius = i * 20 in\n    prerr_endline (\u0026quot;radius is \u0026quot; ^ string_of_int radius);\n    set_color (if i mod 2 = 0 then red else yellow);\n    fill_circle 320 240 radius\n  done;\n  ignore(read_line ())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you prefer C-style \u003ccode\u003eprintf\u003c/code\u003e's then try using OCaml's \u003ccode\u003ePrintf\u003c/code\u003e module\ninstead:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eopen Graphics\n  \nlet () =\n  open_graph \u0026quot; 640x480\u0026quot;;\n  for i = 12 downto 1 do\n    let radius = i * 20 in\n    Printf.eprintf \u0026quot;radius is %d\\n\u0026quot; radius;\n    set_color (if i mod 2 = 0 then red else yellow);\n    fill_circle 320 240 radius\n  done;\n  ignore(read_line ())\n\u003c/code\u003e\u003c/pre\u003e\n"},{"title":"Functors","slug":"functors","description":"Learn about functors, modules parameterised by other modules\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"language","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\nFunctors are probably one of the most complex features of OCaml, but you don't\nhave to use them extensively to be a successful OCaml programmer.  Actually,\nyou may never have to define a functor yourself, but you will surely encounter\nthem in the standard library. They are the only way of using the Set and Map\nmodules, but using them is not so difficult.\n\n##  What are functors and why do we need them?\n\nA functor is a module that is parametrized by another module, just like a\nfunction is a value which is parametrized by other values, the arguments.\n\nIt allows one to parametrize a type by a value, which is not possible directly\nin OCaml without functors. For example, we can define a functor that takes an\nint n and returns a collection of array operations that work exclusively on\narrays of length n. If by mistake the programmer passes a regular array to one\nof those functions, it will result in a compilation error. If we were not using\nthis functor but the standard array type, the compiler would not be able to\ndetect the error, and we would get a runtime error at some undetermined date in\nthe future, which is much worse.\n\n##  Using an existing functor\n\nThe standard library defines a `Set` module, which provides a `Make` functor.\nThis functor takes one argument, which is a module that provides (at least) two\nthings: the type of elements, given as `t` and the comparison function given as\n`compare`. The point of the functor is to ensure that the same comparison\nfunction will always be used, even if the programmer makes a mistake.\n\nFor example, if we want to use sets of ints, we would do this:\n\n```ocaml\n# module Int_set =\n  Set.Make (struct\n              type t = int\n              let compare = compare\n            end)\nmodule Int_set :\n  sig\n    type elt = int\n    type t\n    val empty : t\n    val is_empty : t -\u003e bool\n    val mem : int -\u003e t -\u003e bool\n    val add : int -\u003e t -\u003e t\n    val singleton : int -\u003e t\n    val remove : int -\u003e t -\u003e t\n    val union : t -\u003e t -\u003e t\n    val inter : t -\u003e t -\u003e t\n    val disjoint : t -\u003e t -\u003e bool\n    val diff : t -\u003e t -\u003e t\n    val compare : t -\u003e t -\u003e int\n    val equal : t -\u003e t -\u003e bool\n    val subset : t -\u003e t -\u003e bool\n    val iter : (int -\u003e unit) -\u003e t -\u003e unit\n    val map : (int -\u003e int) -\u003e t -\u003e t\n    val fold : (int -\u003e 'a -\u003e 'a) -\u003e t -\u003e 'a -\u003e 'a\n    val for_all : (int -\u003e bool) -\u003e t -\u003e bool\n    val exists : (int -\u003e bool) -\u003e t -\u003e bool\n    val filter : (int -\u003e bool) -\u003e t -\u003e t\n    val partition : (int -\u003e bool) -\u003e t -\u003e t * t\n    val cardinal : t -\u003e int\n    val elements : t -\u003e int list\n    val min_elt : t -\u003e int\n    val min_elt_opt : t -\u003e int option\n    val max_elt : t -\u003e int\n    val max_elt_opt : t -\u003e int option\n    val choose : t -\u003e int\n    val choose_opt : t -\u003e int option\n    val split : int -\u003e t -\u003e t * bool * t\n    val find : int -\u003e t -\u003e int\n    val find_opt : int -\u003e t -\u003e int option\n    val find_first : (int -\u003e bool) -\u003e t -\u003e int\n    val find_first_opt : (int -\u003e bool) -\u003e t -\u003e int option\n    val find_last : (int -\u003e bool) -\u003e t -\u003e int\n    val find_last_opt : (int -\u003e bool) -\u003e t -\u003e int option\n    val of_list : int list -\u003e t\n    val to_seq_from : int -\u003e t -\u003e int Seq.t\n    val to_seq : t -\u003e int Seq.t\n    val add_seq : int Seq.t -\u003e t -\u003e t\n    val of_seq : int Seq.t -\u003e t\n  end\n```\n\nFor sets of strings, it is even easier because the standard library provides a\n`String` module with a type `t` and a function `compare`. If you were following\ncarefully, by now you must have guessed how to create a module for the\nmanipulation of sets of strings:\n\n```ocaml\n# module String_set = Set.Make (String)\nmodule String_set :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -\u003e bool\n    val mem : elt -\u003e t -\u003e bool\n    val add : elt -\u003e t -\u003e t\n    val singleton : elt -\u003e t\n    val remove : elt -\u003e t -\u003e t\n    val union : t -\u003e t -\u003e t\n    val inter : t -\u003e t -\u003e t\n    val disjoint : t -\u003e t -\u003e bool\n    val diff : t -\u003e t -\u003e t\n    val compare : t -\u003e t -\u003e int\n    val equal : t -\u003e t -\u003e bool\n    val subset : t -\u003e t -\u003e bool\n    val iter : (elt -\u003e unit) -\u003e t -\u003e unit\n    val map : (elt -\u003e elt) -\u003e t -\u003e t\n    val fold : (elt -\u003e 'a -\u003e 'a) -\u003e t -\u003e 'a -\u003e 'a\n    val for_all : (elt -\u003e bool) -\u003e t -\u003e bool\n    val exists : (elt -\u003e bool) -\u003e t -\u003e bool\n    val filter : (elt -\u003e bool) -\u003e t -\u003e t\n    val partition : (elt -\u003e bool) -\u003e t -\u003e t * t\n    val cardinal : t -\u003e int\n    val elements : t -\u003e elt list\n    val min_elt : t -\u003e elt\n    val min_elt_opt : t -\u003e elt option\n    val max_elt : t -\u003e elt\n    val max_elt_opt : t -\u003e elt option\n    val choose : t -\u003e elt\n    val choose_opt : t -\u003e elt option\n    val split : elt -\u003e t -\u003e t * bool * t\n    val find : elt -\u003e t -\u003e elt\n    val find_opt : elt -\u003e t -\u003e elt option\n    val find_first : (elt -\u003e bool) -\u003e t -\u003e elt\n    val find_first_opt : (elt -\u003e bool) -\u003e t -\u003e elt option\n    val find_last : (elt -\u003e bool) -\u003e t -\u003e elt\n    val find_last_opt : (elt -\u003e bool) -\u003e t -\u003e elt option\n    val of_list : elt list -\u003e t\n    val to_seq_from : elt -\u003e t -\u003e elt Seq.t\n    val to_seq : t -\u003e elt Seq.t\n    val add_seq : elt Seq.t -\u003e t -\u003e t\n    val of_seq : elt Seq.t -\u003e t\n  end\n```\n\n(the parentheses are necessary)\n\n##  Defining functors\n\nA functor with one argument can be defined like this:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmodule F (X : X_type) = struct\n  ...\nend\n```\n\nwhere `X` is the module that will be passed as argument, and `X_type` is its\nsignature, which is mandatory.\n\nThe signature of the returned module itself can be constrained, using this\nsyntax:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmodule F (X : X_type) : Y_type =\nstruct\n  ...\nend\n```\n\nor by specifying this in the .mli file:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmodule F (X : X_type) : Y_type\n```\n\nOverall, the syntax of functors is hard to grasp. The best may be to look at\nthe source files\n[`set.ml`](https://github.com/ocaml/ocaml/blob/trunk/stdlib/set.ml) or\n[`map.ml`](https://github.com/ocaml/ocaml/blob/trunk/stdlib/map.ml) of the\nstandard library.\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#what-are-functors-and-why-do-we-need-them\"\u003eWhat are functors and why do we need them?\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#using-an-existing-functor\"\u003eUsing an existing functor\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defining-functors\"\u003eDefining functors\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eFunctors are probably one of the most complex features of OCaml, but you don't\nhave to use them extensively to be a successful OCaml programmer.  Actually,\nyou may never have to define a functor yourself, but you will surely encounter\nthem in the standard library. They are the only way of using the Set and Map\nmodules, but using them is not so difficult.\u003c/p\u003e\n\u003ch2 id=\"what-are-functors-and-why-do-we-need-them\"\u003eWhat are functors and why do we need them?\u003c/h2\u003e\n\u003cp\u003eA functor is a module that is parametrized by another module, just like a\nfunction is a value which is parametrized by other values, the arguments.\u003c/p\u003e\n\u003cp\u003eIt allows one to parametrize a type by a value, which is not possible directly\nin OCaml without functors. For example, we can define a functor that takes an\nint n and returns a collection of array operations that work exclusively on\narrays of length n. If by mistake the programmer passes a regular array to one\nof those functions, it will result in a compilation error. If we were not using\nthis functor but the standard array type, the compiler would not be able to\ndetect the error, and we would get a runtime error at some undetermined date in\nthe future, which is much worse.\u003c/p\u003e\n\u003ch2 id=\"using-an-existing-functor\"\u003eUsing an existing functor\u003c/h2\u003e\n\u003cp\u003eThe standard library defines a \u003ccode\u003eSet\u003c/code\u003e module, which provides a \u003ccode\u003eMake\u003c/code\u003e functor.\nThis functor takes one argument, which is a module that provides (at least) two\nthings: the type of elements, given as \u003ccode\u003et\u003c/code\u003e and the comparison function given as\n\u003ccode\u003ecompare\u003c/code\u003e. The point of the functor is to ensure that the same comparison\nfunction will always be used, even if the programmer makes a mistake.\u003c/p\u003e\n\u003cp\u003eFor example, if we want to use sets of ints, we would do this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# module Int_set =\n  Set.Make (struct\n              type t = int\n              let compare = compare\n            end)\nmodule Int_set :\n  sig\n    type elt = int\n    type t\n    val empty : t\n    val is_empty : t -\u0026gt; bool\n    val mem : int -\u0026gt; t -\u0026gt; bool\n    val add : int -\u0026gt; t -\u0026gt; t\n    val singleton : int -\u0026gt; t\n    val remove : int -\u0026gt; t -\u0026gt; t\n    val union : t -\u0026gt; t -\u0026gt; t\n    val inter : t -\u0026gt; t -\u0026gt; t\n    val disjoint : t -\u0026gt; t -\u0026gt; bool\n    val diff : t -\u0026gt; t -\u0026gt; t\n    val compare : t -\u0026gt; t -\u0026gt; int\n    val equal : t -\u0026gt; t -\u0026gt; bool\n    val subset : t -\u0026gt; t -\u0026gt; bool\n    val iter : (int -\u0026gt; unit) -\u0026gt; t -\u0026gt; unit\n    val map : (int -\u0026gt; int) -\u0026gt; t -\u0026gt; t\n    val fold : (int -\u0026gt; 'a -\u0026gt; 'a) -\u0026gt; t -\u0026gt; 'a -\u0026gt; 'a\n    val for_all : (int -\u0026gt; bool) -\u0026gt; t -\u0026gt; bool\n    val exists : (int -\u0026gt; bool) -\u0026gt; t -\u0026gt; bool\n    val filter : (int -\u0026gt; bool) -\u0026gt; t -\u0026gt; t\n    val partition : (int -\u0026gt; bool) -\u0026gt; t -\u0026gt; t * t\n    val cardinal : t -\u0026gt; int\n    val elements : t -\u0026gt; int list\n    val min_elt : t -\u0026gt; int\n    val min_elt_opt : t -\u0026gt; int option\n    val max_elt : t -\u0026gt; int\n    val max_elt_opt : t -\u0026gt; int option\n    val choose : t -\u0026gt; int\n    val choose_opt : t -\u0026gt; int option\n    val split : int -\u0026gt; t -\u0026gt; t * bool * t\n    val find : int -\u0026gt; t -\u0026gt; int\n    val find_opt : int -\u0026gt; t -\u0026gt; int option\n    val find_first : (int -\u0026gt; bool) -\u0026gt; t -\u0026gt; int\n    val find_first_opt : (int -\u0026gt; bool) -\u0026gt; t -\u0026gt; int option\n    val find_last : (int -\u0026gt; bool) -\u0026gt; t -\u0026gt; int\n    val find_last_opt : (int -\u0026gt; bool) -\u0026gt; t -\u0026gt; int option\n    val of_list : int list -\u0026gt; t\n    val to_seq_from : int -\u0026gt; t -\u0026gt; int Seq.t\n    val to_seq : t -\u0026gt; int Seq.t\n    val add_seq : int Seq.t -\u0026gt; t -\u0026gt; t\n    val of_seq : int Seq.t -\u0026gt; t\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor sets of strings, it is even easier because the standard library provides a\n\u003ccode\u003eString\u003c/code\u003e module with a type \u003ccode\u003et\u003c/code\u003e and a function \u003ccode\u003ecompare\u003c/code\u003e. If you were following\ncarefully, by now you must have guessed how to create a module for the\nmanipulation of sets of strings:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# module String_set = Set.Make (String)\nmodule String_set :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -\u0026gt; bool\n    val mem : elt -\u0026gt; t -\u0026gt; bool\n    val add : elt -\u0026gt; t -\u0026gt; t\n    val singleton : elt -\u0026gt; t\n    val remove : elt -\u0026gt; t -\u0026gt; t\n    val union : t -\u0026gt; t -\u0026gt; t\n    val inter : t -\u0026gt; t -\u0026gt; t\n    val disjoint : t -\u0026gt; t -\u0026gt; bool\n    val diff : t -\u0026gt; t -\u0026gt; t\n    val compare : t -\u0026gt; t -\u0026gt; int\n    val equal : t -\u0026gt; t -\u0026gt; bool\n    val subset : t -\u0026gt; t -\u0026gt; bool\n    val iter : (elt -\u0026gt; unit) -\u0026gt; t -\u0026gt; unit\n    val map : (elt -\u0026gt; elt) -\u0026gt; t -\u0026gt; t\n    val fold : (elt -\u0026gt; 'a -\u0026gt; 'a) -\u0026gt; t -\u0026gt; 'a -\u0026gt; 'a\n    val for_all : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; bool\n    val exists : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; bool\n    val filter : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; t\n    val partition : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; t * t\n    val cardinal : t -\u0026gt; int\n    val elements : t -\u0026gt; elt list\n    val min_elt : t -\u0026gt; elt\n    val min_elt_opt : t -\u0026gt; elt option\n    val max_elt : t -\u0026gt; elt\n    val max_elt_opt : t -\u0026gt; elt option\n    val choose : t -\u0026gt; elt\n    val choose_opt : t -\u0026gt; elt option\n    val split : elt -\u0026gt; t -\u0026gt; t * bool * t\n    val find : elt -\u0026gt; t -\u0026gt; elt\n    val find_opt : elt -\u0026gt; t -\u0026gt; elt option\n    val find_first : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt\n    val find_first_opt : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt option\n    val find_last : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt\n    val find_last_opt : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt option\n    val of_list : elt list -\u0026gt; t\n    val to_seq_from : elt -\u0026gt; t -\u0026gt; elt Seq.t\n    val to_seq : t -\u0026gt; elt Seq.t\n    val add_seq : elt Seq.t -\u0026gt; t -\u0026gt; t\n    val of_seq : elt Seq.t -\u0026gt; t\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(the parentheses are necessary)\u003c/p\u003e\n\u003ch2 id=\"defining-functors\"\u003eDefining functors\u003c/h2\u003e\n\u003cp\u003eA functor with one argument can be defined like this:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003emodule F (X : X_type) = struct\n  ...\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere \u003ccode\u003eX\u003c/code\u003e is the module that will be passed as argument, and \u003ccode\u003eX_type\u003c/code\u003e is its\nsignature, which is mandatory.\u003c/p\u003e\n\u003cp\u003eThe signature of the returned module itself can be constrained, using this\nsyntax:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003emodule F (X : X_type) : Y_type =\nstruct\n  ...\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor by specifying this in the .mli file:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003emodule F (X : X_type) : Y_type\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOverall, the syntax of functors is hard to grasp. The best may be to look at\nthe source files\n\u003ca href=\"https://github.com/ocaml/ocaml/blob/trunk/stdlib/set.ml\"\u003e\u003ccode\u003eset.ml\u003c/code\u003e\u003c/a\u003e or\n\u003ca href=\"https://github.com/ocaml/ocaml/blob/trunk/stdlib/map.ml\"\u003e\u003ccode\u003emap.ml\u003c/code\u003e\u003c/a\u003e of the\nstandard library.\u003c/p\u003e\n"},{"title":"Objects","slug":"objects","description":"OCaml is an object-oriented, imperative, functional programming language\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"language","tl":0},"users":{"hd":"Intermediate","tl":{"hd":"Advanced","tl":0}},"body_md":"\n## Objects and classes\nOCaml is an object-oriented, imperative, functional programming language\n:-) It mixes all these paradigms and lets you use the most appropriate\n(or most familiar) programming paradigm for the task at hand. In this\nchapter I'm going to look at object-oriented programming in OCaml, but\nI'm also going to talk about why you might or might not want to write\nobject-oriented programs.\n\nThe classic noddy example used in text books to demonstrate\nobject-oriented programming is the stack class. This is a pretty\nterrible example in many ways, but I'm going to use it here to show the\nbasics of writing object-oriented OCaml.\n\nHere's some basic code to provide a stack of integers. The class is\nimplemented using a linked list.\n\n```ocaml\n# class stack_of_ints =\n  object (self)\n    val mutable the_list = ([] : int list)     (* instance variable *)\n    method push x =                            (* push method *)\n      the_list \u003c- x :: the_list\n    method pop =                               (* pop method *)\n      let result = List.hd the_list in\n      the_list \u003c- List.tl the_list;\n      result\n    method peek =                              (* peek method *)\n      List.hd the_list\n    method size =                              (* size method *)\n      List.length the_list\n  end\nclass stack_of_ints :\n  object\n    val mutable the_list : int list\n    method peek : int\n    method pop : int\n    method push : int -\u003e unit\n    method size : int\n  end\n```\n\nThe basic pattern `class name = object (self) ... end` defines a class\ncalled `name`.\n\nThe class has one instance variable, which is mutable (not constant),\ncalled `the_list`. This is the underlying linked list. We initialize\nthis (each time a `stack_of_ints` object is created) using a bit of code\nthat you may not be familiar with. The expression `( [] : int list )`\nmeans \"an empty list, of type `int list`\". Recall that the simple empty\nlist `[]` has type `'a list`, meaning a list of any type. However we\nwant a stack of `int`, not anything else, and so in this case we want to\ntell the type inference engine that this list isn't the general \"list of\nanything\" but is in fact the narrower \"list of `int`\". The syntax\n`( expression : type )` means `expression` which is in fact of type\n`type`. This *isn't* a general type cast, because you can't use it to\noverrule the type inference engine, only to narrow a general type to\nmake it more specific. So you can't write, for example, `( 1 : float )`:\n\n```ocaml\n# (1 : float)\nLine 1, characters 2-3:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.'?\n```\n\nType safety is preserved. Back to the example ...\n\nThis class has four simple methods. `push` pushes an integer onto the\nstack. `pop` pops the top integer off the stack and returns it. Notice\nthe `\u003c-` assignment operator used for updating our mutable instance\nvariable. It's the same `\u003c-` assignment operator which is used for\nupdating mutable fields in records.\n\n`peek` returns the top of the stack (ie. head of the list) without\naffecting the stack, while `size` returns the number of elements in the\nstack (ie. the length of the list).\n\nLet's write some code to test stacks of ints. First let's create a new\nobject. We use the familiar `new` operator:\n\n```ocaml\n# let s = new stack_of_ints\nval s : stack_of_ints = \u003cobj\u003e\n```\nNow we'll push and pop some elements off the stack:\n\n```ocaml\n# for i = 1 to 10 do\n    s#push i\n  done\n- : unit = ()\n# while s#size \u003e 0 do\n    Printf.printf \"Popped %d off the stack.\\n\" s#pop\n  done\nPopped 10 off the stack.\nPopped 9 off the stack.\nPopped 8 off the stack.\nPopped 7 off the stack.\nPopped 6 off the stack.\nPopped 5 off the stack.\nPopped 4 off the stack.\nPopped 3 off the stack.\nPopped 2 off the stack.\nPopped 1 off the stack.\n- : unit = ()\n```\nNotice the syntax. `object#method` means call `method` on `object`. This\nis the same as `object.method` or `object-\u003emethod` that you will be\nfamiliar with in imperative languages.\n\nIn the OCaml toplevel we can examine the types of objects and methods in\nmore detail:\n\n```ocaml\n# let s = new stack_of_ints\nval s : stack_of_ints = \u003cobj\u003e\n# s#push\n- : int -\u003e unit = \u003cfun\u003e\n```\n\n`s` is an opaque object. The implementation (ie. the list) is hidden\nfrom callers.\n\n###  Polymorphic classes\nA stack of integers is good, but what about a stack that can store any\ntype? (Not a single stack that can store a mixture of types, but\nmultiple stacks each storing objects of any single type). As with\n`'a list`, we can define `'a stack`:\n\n```ocaml\n# class ['a] stack =\n  object (self)\n    val mutable list = ([] : 'a list)    (* instance variable *)\n    method push x =                      (* push method *)\n      list \u003c- x :: list\n    method pop =                         (* pop method *)\n      let result = List.hd list in\n      list \u003c- List.tl list;\n      result\n    method peek =                        (* peek method *)\n      List.hd list\n    method size =                        (* size method *)\n      List.length list\n  end\nclass ['a] stack :\n  object\n    val mutable list : 'a list\n    method peek : 'a\n    method pop : 'a\n    method push : 'a -\u003e unit\n    method size : int\n  end\n```\nThe `class ['a] stack` doesn't really define just one class, but a whole\n\"class of classes\", one for every possible type (ie. an infinitely large\nnumber of classes!) Let's try and use our `'a stack` class. In this\ninstance we create a stack and push a floating point number onto the\nstack. Notice the type of the stack:\n\n```ocaml\n# let s = new stack\nval s : '_weak1 stack = \u003cobj\u003e\n# s#push 1.0\n- : unit = ()\n# s\n- : float stack = \u003cobj\u003e\n```\n\nThis stack is now a `float stack`, and only floating point numbers may\nbe pushed and popped from this stack. Let's demonstrate the type-safety\nof our new `float stack`:\n\n```ocaml\n# s#push 3.0\n- : unit = ()\n# s#pop\n- : float = 3.\n# s#pop\n- : float = 1.\n# s#push \"a string\"\nLine 1, characters 8-18:\nError: This expression has type string but an expression was expected of type\n         float\n```\n\nWe can define polymorphic functions which can operate on any type of\nstack. Our first attempt is this one:\n\n```ocaml\n# let drain_stack s =\n  while s#size \u003e 0 do\n    ignore (s#pop)\n  done\nval drain_stack : \u003c pop : 'a; size : int; .. \u003e -\u003e unit = \u003cfun\u003e\n```\n\nNotice the type of `drain_stack`. Cleverly - perhaps *too* cleverly -\nOCaml's type inference engine has worked out that `drain_stack` works on\n*any* object which has `pop` and `size` methods! So if we defined\nanother, entirely separate class which happened to contain `pop` and\n`size` methods with suitable type signatures, then we might accidentally\ncall `drain_stack` on objects of that other type.\n\nWe can force OCaml to be more specific and only allow `drain_stack` to\nbe called on `'a stack`s by narrowing the type of the `s` argument, like\nthis:\n\n```ocaml\n# let drain_stack (s : 'a stack) =\n  while s#size \u003e 0 do\n    ignore (s#pop)\n  done\nval drain_stack : 'a stack -\u003e unit = \u003cfun\u003e\n```\n\n###  Inheritance, virtual classes, initializers\nI've noticed programmers in Java tend to overuse inheritance, possibly\nbecause it's the only reasonable way of extending code in that language.\nA much better and more general way to extend code is usually to use\nhooks (cf. Apache's module API). Nevertheless in certain narrow areas\ninheritance can be useful, and the most important of these is in writing\nGUI widget libraries.\n\nLet's consider an imaginary OCaml widget library similar to Java's\nSwing. We will define buttons and labels with the following class\nhierarchy:\n\n```\nwidget  (superclass for all widgets)\n  |\n  +----\u003e container  (any widget that can contain other widgets)\n  |        |\n  |        +----\u003e button\n  |\n  +-------------\u003e label\n```\n(Notice that a `button` is a `container` because it can contain either a\nlabel or an image, depending on what is displayed on the button).\n\n`widget` is the virtual superclass for all widgets. I want every widget\nto have a name (just a string) which is constant over the life of that\nwidget. This was my first attempt:\n\n```ocaml\n# class virtual widget name =\n  object (self)\n    method get_name =\n      name\n    method virtual repaint : unit\n  end\nLines 1-6, characters 1-6:\nError: Some type variables are unbound in this type:\n         class virtual widget :\n           'a -\u003e\n           object method get_name : 'a method virtual repaint : unit end\n       The method get_name has type 'a where 'a is unbound\n```\nOops! I forgot that OCaml cannot infer the type of `name` so will assume\nthat it is `'a`. But that defines a polymorphic class, and I didn't\ndeclare the class as polymorphic (`class ['a] widget`). I need to narrow\nthe type of `name` like this:\n\n```ocaml\n# class virtual widget (name : string) =\n  object (self)\n    method get_name =\n      name\n    method virtual repaint : unit\n  end;;\nclass virtual widget :\n  string -\u003e object method get_name : string method virtual repaint : unit end\n```\nNow there are several new things going on in this code. Firstly the\nclass contains an **initializer**. This is an argument to the class\n(`name`) which you can think of as exactly the equivalent of an argument\nto a constructor in, eg., Java:\n\n```java\npublic class Widget\n{\n  public Widget (String name)\n  {\n    ...\n  }\n}\n```\nIn OCaml a constructor constructs the whole class, it's not just a\nspecially named function, so we write the arguments as if they are\narguments to the class:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nclass foo arg1 arg2 ... =\n```\n\nSecondly the class contains a virtual method, and thus the whole class\nis marked as virtual. The virtual method is our `repaint` method. We\nneed to tell OCaml it's virtual (`method virtual`), *and* we need to\ntell OCaml the type of the method. Because the method doesn't contain\nany code, OCaml can't use type inference to automatically work out the\ntype for you, so you need to tell it the type. In this case the method\njust returns `unit`. If your class contains any virtual methods (even\njust inherited ones) then you need to specify the whole class as virtual\nby using `class virtual ...`.\n\nAs in C++ and Java, virtual classes cannot be directly instantiated\nusing `new`:\n\n```ocaml\n# let w = new widget \"my widget\"\nLine 1, characters 9-19:\nError: Cannot instantiate the virtual class widget\n```\n\nNow my `container` class is more interesting. It must inherit from\n`widget` and have the mechanics for storing the list of contained\nwidgets. Here is my simple implementation for `container`:\n\n```ocaml\n# class virtual container name =\n  object (self)\n    inherit widget name\n    val mutable widgets = ([] : widget list)\n    method add w =\n      widgets \u003c- w :: widgets\n    method get_widgets =\n      widgets\n    method repaint =\n      List.iter (fun w -\u003e w#repaint) widgets\n  end\nclass virtual container :\n  string -\u003e\n  object\n    val mutable widgets : widget list\n    method add : widget -\u003e unit\n    method get_name : string\n    method get_widgets : widget list\n    method repaint : unit\n  end\n```\n\nNotes:\n\n1. The `container` class is marked as virtual. It doesn't contain any\n virtual methods, but in this case I just want to prevent people\n creating containers directly.\n1. The `container` class has a `name` argument which is passed directly\n up when constructing the `widget`.\n1. `inherit widget name` means that the `container` inherits from\n `widget`, and it passes the `name` argument to the constructor for\n `widget`.\n1. My `container` contains a mutable list of widgets and methods to\n `add` a widget to this list and `get_widgets` (return the list of\n widgets).\n1. The list of widgets returned by `get_widgets` cannot be modified by\n code outside the class. The reason for this is somewhat subtle, but\n basically comes down to the fact that OCaml's linked lists are\n immutable. Let's imagine that someone wrote this code:\n\n  ```ocaml\n  # let list = container#get_widgets in\n    x :: list\n  ```\n\nWould this modify the private internal representation of my `container`\nclass, by prepending `x` to the list of widgets? No it wouldn't. The\nprivate variable `widgets` would be unaffected by this or any other\nchange attempted by the outside code. This means, for example, that you\ncould change the internal representation to use an array at some later\ndate, and no code outside the class would need to be changed.\n\nLast, but not least, we have implemented the previously virtual\n`repaint` function so that `container#repaint` will repaint all of the\ncontained widgets. Notice I use `List.iter` to iterate over the list,\nand I also use a probably unfamiliar anonymous function expression:\n\n```ocaml\n# (fun w -\u003e w#repaint)\n- : \u003c repaint : 'a; .. \u003e -\u003e 'a = \u003cfun\u003e\n```\nwhich defines an anonymous function with one argument `w` that just\ncalls `w#repaint` (the `repaint` method on widget `w`).\n\nIn this instance our `button` class is simple (rather unrealistically\nsimple in fact, but nevermind that):\n\n```ocaml\n# type button_state = Released | Pressed\ntype button_state = Released | Pressed\n# class button ?callback name =\n  object (self)\n    inherit container name as super\n    val mutable state = Released\n    method press =\n      state \u003c- Pressed;\n      match callback with\n      | None -\u003e ()\n      | Some f -\u003e f ()\n    method release =\n      state \u003c- Released\n    method repaint =\n      super#repaint;\n      print_endline (\"Button being repainted, state is \" ^\n                     (match state with\n                      | Pressed -\u003e \"Pressed\"\n                      | Released -\u003e \"Released\"))\n  end\nclass button :\n  ?callback:(unit -\u003e unit) -\u003e\n  string -\u003e\n  object\n    val mutable state : button_state\n    val mutable widgets : widget list\n    method add : widget -\u003e unit\n    method get_name : string\n    method get_widgets : widget list\n    method press : unit\n    method release : unit\n    method repaint : unit\n  end\n```\n\nNotes:\n\n1. This function has an optional argument (see the previous chapter)\n which is used to pass in the optional callback function. The\n callback is called when the button is pressed.\n1. The expression `inherit container name as super` names the\n superclass `super`. I use this in the `repaint` method:\n `super#repaint`. This expressly calls the superclass method.\n1. Pressing the button (calling `button#press` in this rather\n simplistic code) sets the state of the button to `Pressed` and calls\n the callback function, if one was defined. Notice that the\n `callback` variable is either `None` or `Some f`, in other words it\n has type `(unit -\u003e unit) option`. Reread the previous chapter if you\n are unsure about this.\n1. Notice a strange thing about the `callback` variable. It's defined\n as an argument to the class, but any method can see and use it. In\n other words, the variable is supplied when the object is\n constructed, but persists over the lifetime of the object.\n1. The `repaint` method has been implemented. It calls the superclass\n (to repaint the container), then repaints the button, displaying the\n current state of the button.\n\nBefore defining our `label` class, let's play with the `button` class in\nthe OCaml toplevel:\n\n```ocaml\n# let b = new button ~callback:(fun () -\u003e print_endline \"Ouch!\") \"button\"\nval b : button = \u003cobj\u003e\n# b#repaint\nButton being repainted, state is Released\n- : unit = ()\n# b#press\nOuch!\n- : unit = ()\n# b#repaint\nButton being repainted, state is Pressed\n- : unit = ()\n# b#release\n- : unit = ()\n```\n\nHere's our comparatively trivial `label` class:\n\n```ocaml\n# class label name text =\n  object (self)\n    inherit widget name\n    method repaint =\n      print_endline (\"Label: \" ^ text)\n  end\nclass label :\n  string -\u003e\n  string -\u003e object method get_name : string method repaint : unit end\n```\nLet's create a label which says \"Press me!\" and add it to the button:\n\n```ocaml\n# let l = new label \"label\" \"Press me!\"\nval l : label = \u003cobj\u003e\n# b#add l\n- : unit = ()\n# b#repaint\nLabel: Press me!\nButton being repainted, state is Released\n- : unit = ()\n```\n\n###  A note about `self`\nIn all the examples above we defined classes using the general pattern:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nclass name =\n  object (self)\n    (* ... *)\n  end\n```\nI didn't explain the reference to `self`. In fact this names the object,\nallowing you to call methods in the same class or pass the object to\nfunctions outside the class. In other words, it's exactly the same as\n`this` in C++/Java. You may completely omit the\n`(self)` part if you don't need to refer to yourself - indeed in all the\nexamples above we could have done exactly that. However, I would advise\nyou to leave it in there because you never know when you might modify\nthe class and require the reference to `self`. There is no penalty for\nhaving it.\n\n###  Inheritance and coercions\n\n```ocaml\n# let b = new button \"button\"\nval b : button = \u003cobj\u003e\n# let l = new label \"label\" \"Press me!\"\nval l : label = \u003cobj\u003e\n# [b; l]\nLine 1, characters 5-6:\nError: This expression has type label but an expression was expected of type\n         button\n       The first object type has no method add\n```\nI created a button `b` and a label `l` and I tried to create a list\ncontaining both, but I got an error. Yet `b` and `l` are both `widget`s,\nso why can't I put them into the same list? Perhaps OCaml can't guess\nthat I want a `widget list`? Let's try telling it:\n\n```ocaml\n# let wl = ([] : widget list)\nval wl : widget list = []\n# let wl = b :: wl\nLine 1, characters 15-17:\nError: This expression has type widget list\n       but an expression was expected of type button list\n       Type widget = \u003c get_name : string; repaint : unit \u003e\n       is not compatible with type\n         button =\n           \u003c add : widget -\u003e unit; get_name : string;\n             get_widgets : widget list; press : unit; release : unit;\n             repaint : unit \u003e\n       The first object type has no method add\n```\n\nIt turns out that OCaml doesn't coerce subclasses to the type of the\nsuperclass by default, but you can tell it to by using the `:\u003e`\n(coercion) operator:\n\n```ocaml\n# let wl = (b :\u003e widget) :: wl\nval wl : widget list = [\u003cobj\u003e]\n# let wl = (l :\u003e widget) :: wl\nval wl : widget list = [\u003cobj\u003e; \u003cobj\u003e]\n```\n\nThe expression `(b :\u003e widget)` means \"coerce the button `b` to have type\n`widget`\". Type-safety is preserved because it is possible to tell\ncompletely at compile time whether the coercion will succeed.\n\nActually, coercions are somewhat more subtle than described above, and\nso I urge you to read the manual to find out the full details.\n\nThe `container#add` method defined above is actually incorrect, and\nfails if you try to add widgets of different types into a `container`. A\ncoercion would fix this.\n\nIs it possible to coerce from a superclass (eg. `widget`) to a subclass\n(eg. `button`)? The answer, perhaps surprisingly, is NO! Coercing in\nthis direction is *unsafe*. You might try to coerce a `widget` which is\nin fact a `label`, not a `button`.\n\n###  The `Oo` module and comparing objects\nThe `Oo` module contains a few useful functions for OO programming.\n\n`Oo.copy` makes a shallow copy of an object. `Oo.id object` returns a\nunique identifying number for each object (a unique number across all\nclasses).\n\n`=` and `\u003c\u003e` can be used to compare objects for *physical* equality (an\nobject and its copy are not physically identical). You can also use `\u003c`\netc. which provides an ordering of objects based apparently on their\nIDs.\n\n## Objects without class\nHere we examine how to use objects pretty much like records, without\nnecessarily using classes.\n\n###  Immediate objects and object types\nObjects can be used instead of records, and have some nice properties\nthat can make them preferable to records in some cases. We saw that the\ncanonical way of creating objects is to first define a class, and use\nthis class to create individual objects. This can be cumbersome in some\nsituations since class definitions are more than a type definition and\ncannot be defined recursively with types. However, objects have a type\nthat is very analog to a record type, and it can be used in type\ndefinitions. In addition, objects can be created without a class. They\nare called *immediate objects*. Here is the definition of an immediate\nobject:\n\n```ocaml\n# let o =\n  object\n    val mutable n = 0\n    method incr = n \u003c- n + 1\n    method get = n\n  end\nval o : \u003c get : int; incr : unit \u003e = \u003cobj\u003e\n```\n\nThis object has a type, which is defined by its public methods only.\nValues are not visible and neither are private methods (not shown).\nUnlike records, such a type does not need to be predefined explicitly,\nbut doing so can make things clearer. We can do it like this:\n\n```ocaml\n# type counter = \u003cget : int; incr : unit\u003e\ntype counter = \u003c get : int; incr : unit \u003e\n```\nCompare with an equivalent record type definition:\n\n```ocaml\n# type counter_r =\n  {get : unit -\u003e int;\n   incr : unit -\u003e unit}\ntype counter_r = { get : unit -\u003e int; incr : unit -\u003e unit; }\n```\nThe implementation of a record working like our object would be:\n\n```ocaml\n# let r =\n  let n = ref 0 in\n    {get = (fun () -\u003e !n);\n     incr = (fun () -\u003e incr n)}\nval r : counter_r = {get = \u003cfun\u003e; incr = \u003cfun\u003e}\n```\nIn terms of functionality, both the object and the record are similar,\nbut each solution has its own advantages:\n\n* **speed**: slightly faster field access in records\n* **field names**: it is inconvenient to manipulate records of\n different types when some fields are named identically but it's not\n a problem with objects\n* **subtyping**: it is impossible to coerce the type of a record to a\n type with less fields. That is however possible with objects, so\n objects of different kinds that share some methods can be mixed in a\n data structure where only their common methods are visible (see next\n section)\n* **type definitions**: there is no need to define an object type in\n advance, so it lightens the dependency constraints between modules\n\n###  Class types vs. just types\nBeware of the confusion between *class types* and object *types*. A\n*class type* is not a data *type*, normally referred to as *type* in the\nOCaml jargon. An object *type* is a kind of data *type*, just like a\nrecord type or a tuple.\n\nWhen a class is defined, both a *class type* and an object *type* of the\nsame name are defined:\n\n```ocaml\n# class t =\n  object\n    val x = 0\n    method get = x\n  end\nclass t : object val x : int method get : int end\n```\n\n`object val x : int method get : int end` is a class type.\n\nIn this example, `t` is also the type of objects that this class would\ncreate. Objects that derive from different classes or no class at all\n(immediate objects) can be mixed together as long as they have the same\ntype:\n\n```ocaml\n# let x = object method get = 123 end\nval x : \u003c get : int \u003e = \u003cobj\u003e\n# let l = [new t; x]\nval l : t list = [\u003cobj\u003e; \u003cobj\u003e]\n```\n\nMixing objects that share a common subtype can be done, but requires\nexplicit type coercion using the `:\u003e` operator:\n\n```ocaml\n# let x = object method get = 123 end\nval x : \u003c get : int \u003e = \u003cobj\u003e\n# let y = object method get = 80 method special = \"hello\" end\nval y : \u003c get : int; special : string \u003e = \u003cobj\u003e\n# let l = [x; y]\nLine 1, characters 13-14:\nError: This expression has type \u003c get : int; special : string \u003e\n       but an expression was expected of type \u003c get : int \u003e\n       The second object type has no method special\n# let l = [x; (y :\u003e t)]\nval l : t list = [\u003cobj\u003e; \u003cobj\u003e]\n```\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#objects-and-classes\"\u003eObjects and classes\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#objects-without-class\"\u003eObjects without class\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"objects-and-classes\"\u003eObjects and classes\u003c/h2\u003e\n\u003cp\u003eOCaml is an object-oriented, imperative, functional programming language\n:-) It mixes all these paradigms and lets you use the most appropriate\n(or most familiar) programming paradigm for the task at hand. In this\nchapter I'm going to look at object-oriented programming in OCaml, but\nI'm also going to talk about why you might or might not want to write\nobject-oriented programs.\u003c/p\u003e\n\u003cp\u003eThe classic noddy example used in text books to demonstrate\nobject-oriented programming is the stack class. This is a pretty\nterrible example in many ways, but I'm going to use it here to show the\nbasics of writing object-oriented OCaml.\u003c/p\u003e\n\u003cp\u003eHere's some basic code to provide a stack of integers. The class is\nimplemented using a linked list.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# class stack_of_ints =\n  object (self)\n    val mutable the_list = ([] : int list)     (* instance variable *)\n    method push x =                            (* push method *)\n      the_list \u0026lt;- x :: the_list\n    method pop =                               (* pop method *)\n      let result = List.hd the_list in\n      the_list \u0026lt;- List.tl the_list;\n      result\n    method peek =                              (* peek method *)\n      List.hd the_list\n    method size =                              (* size method *)\n      List.length the_list\n  end\nclass stack_of_ints :\n  object\n    val mutable the_list : int list\n    method peek : int\n    method pop : int\n    method push : int -\u0026gt; unit\n    method size : int\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe basic pattern \u003ccode\u003eclass name = object (self) ... end\u003c/code\u003e defines a class\ncalled \u003ccode\u003ename\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe class has one instance variable, which is mutable (not constant),\ncalled \u003ccode\u003ethe_list\u003c/code\u003e. This is the underlying linked list. We initialize\nthis (each time a \u003ccode\u003estack_of_ints\u003c/code\u003e object is created) using a bit of code\nthat you may not be familiar with. The expression \u003ccode\u003e( [] : int list )\u003c/code\u003e\nmeans \u0026quot;an empty list, of type \u003ccode\u003eint list\u003c/code\u003e\u0026quot;. Recall that the simple empty\nlist \u003ccode\u003e[]\u003c/code\u003e has type \u003ccode\u003e'a list\u003c/code\u003e, meaning a list of any type. However we\nwant a stack of \u003ccode\u003eint\u003c/code\u003e, not anything else, and so in this case we want to\ntell the type inference engine that this list isn't the general \u0026quot;list of\nanything\u0026quot; but is in fact the narrower \u0026quot;list of \u003ccode\u003eint\u003c/code\u003e\u0026quot;. The syntax\n\u003ccode\u003e( expression : type )\u003c/code\u003e means \u003ccode\u003eexpression\u003c/code\u003e which is in fact of type\n\u003ccode\u003etype\u003c/code\u003e. This \u003cem\u003eisn't\u003c/em\u003e a general type cast, because you can't use it to\noverrule the type inference engine, only to narrow a general type to\nmake it more specific. So you can't write, for example, \u003ccode\u003e( 1 : float )\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# (1 : float)\nLine 1, characters 2-3:\nError: This expression has type int but an expression was expected of type\n         float\n  Hint: Did you mean `1.'?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eType safety is preserved. Back to the example ...\u003c/p\u003e\n\u003cp\u003eThis class has four simple methods. \u003ccode\u003epush\u003c/code\u003e pushes an integer onto the\nstack. \u003ccode\u003epop\u003c/code\u003e pops the top integer off the stack and returns it. Notice\nthe \u003ccode\u003e\u0026lt;-\u003c/code\u003e assignment operator used for updating our mutable instance\nvariable. It's the same \u003ccode\u003e\u0026lt;-\u003c/code\u003e assignment operator which is used for\nupdating mutable fields in records.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epeek\u003c/code\u003e returns the top of the stack (ie. head of the list) without\naffecting the stack, while \u003ccode\u003esize\u003c/code\u003e returns the number of elements in the\nstack (ie. the length of the list).\u003c/p\u003e\n\u003cp\u003eLet's write some code to test stacks of ints. First let's create a new\nobject. We use the familiar \u003ccode\u003enew\u003c/code\u003e operator:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let s = new stack_of_ints\nval s : stack_of_ints = \u0026lt;obj\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we'll push and pop some elements off the stack:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# for i = 1 to 10 do\n    s#push i\n  done\n- : unit = ()\n# while s#size \u0026gt; 0 do\n    Printf.printf \u0026quot;Popped %d off the stack.\\n\u0026quot; s#pop\n  done\nPopped 10 off the stack.\nPopped 9 off the stack.\nPopped 8 off the stack.\nPopped 7 off the stack.\nPopped 6 off the stack.\nPopped 5 off the stack.\nPopped 4 off the stack.\nPopped 3 off the stack.\nPopped 2 off the stack.\nPopped 1 off the stack.\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice the syntax. \u003ccode\u003eobject#method\u003c/code\u003e means call \u003ccode\u003emethod\u003c/code\u003e on \u003ccode\u003eobject\u003c/code\u003e. This\nis the same as \u003ccode\u003eobject.method\u003c/code\u003e or \u003ccode\u003eobject-\u0026gt;method\u003c/code\u003e that you will be\nfamiliar with in imperative languages.\u003c/p\u003e\n\u003cp\u003eIn the OCaml toplevel we can examine the types of objects and methods in\nmore detail:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let s = new stack_of_ints\nval s : stack_of_ints = \u0026lt;obj\u0026gt;\n# s#push\n- : int -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003es\u003c/code\u003e is an opaque object. The implementation (ie. the list) is hidden\nfrom callers.\u003c/p\u003e\n\u003ch3 id=\"polymorphic-classes\"\u003ePolymorphic classes\u003c/h3\u003e\n\u003cp\u003eA stack of integers is good, but what about a stack that can store any\ntype? (Not a single stack that can store a mixture of types, but\nmultiple stacks each storing objects of any single type). As with\n\u003ccode\u003e'a list\u003c/code\u003e, we can define \u003ccode\u003e'a stack\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# class ['a] stack =\n  object (self)\n    val mutable list = ([] : 'a list)    (* instance variable *)\n    method push x =                      (* push method *)\n      list \u0026lt;- x :: list\n    method pop =                         (* pop method *)\n      let result = List.hd list in\n      list \u0026lt;- List.tl list;\n      result\n    method peek =                        (* peek method *)\n      List.hd list\n    method size =                        (* size method *)\n      List.length list\n  end\nclass ['a] stack :\n  object\n    val mutable list : 'a list\n    method peek : 'a\n    method pop : 'a\n    method push : 'a -\u0026gt; unit\n    method size : int\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eclass ['a] stack\u003c/code\u003e doesn't really define just one class, but a whole\n\u0026quot;class of classes\u0026quot;, one for every possible type (ie. an infinitely large\nnumber of classes!) Let's try and use our \u003ccode\u003e'a stack\u003c/code\u003e class. In this\ninstance we create a stack and push a floating point number onto the\nstack. Notice the type of the stack:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let s = new stack\nval s : '_weak1 stack = \u0026lt;obj\u0026gt;\n# s#push 1.0\n- : unit = ()\n# s\n- : float stack = \u0026lt;obj\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis stack is now a \u003ccode\u003efloat stack\u003c/code\u003e, and only floating point numbers may\nbe pushed and popped from this stack. Let's demonstrate the type-safety\nof our new \u003ccode\u003efloat stack\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# s#push 3.0\n- : unit = ()\n# s#pop\n- : float = 3.\n# s#pop\n- : float = 1.\n# s#push \u0026quot;a string\u0026quot;\nLine 1, characters 8-18:\nError: This expression has type string but an expression was expected of type\n         float\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can define polymorphic functions which can operate on any type of\nstack. Our first attempt is this one:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let drain_stack s =\n  while s#size \u0026gt; 0 do\n    ignore (s#pop)\n  done\nval drain_stack : \u0026lt; pop : 'a; size : int; .. \u0026gt; -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice the type of \u003ccode\u003edrain_stack\u003c/code\u003e. Cleverly - perhaps \u003cem\u003etoo\u003c/em\u003e cleverly -\nOCaml's type inference engine has worked out that \u003ccode\u003edrain_stack\u003c/code\u003e works on\n\u003cem\u003eany\u003c/em\u003e object which has \u003ccode\u003epop\u003c/code\u003e and \u003ccode\u003esize\u003c/code\u003e methods! So if we defined\nanother, entirely separate class which happened to contain \u003ccode\u003epop\u003c/code\u003e and\n\u003ccode\u003esize\u003c/code\u003e methods with suitable type signatures, then we might accidentally\ncall \u003ccode\u003edrain_stack\u003c/code\u003e on objects of that other type.\u003c/p\u003e\n\u003cp\u003eWe can force OCaml to be more specific and only allow \u003ccode\u003edrain_stack\u003c/code\u003e to\nbe called on \u003ccode\u003e'a stack\u003c/code\u003es by narrowing the type of the \u003ccode\u003es\u003c/code\u003e argument, like\nthis:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let drain_stack (s : 'a stack) =\n  while s#size \u0026gt; 0 do\n    ignore (s#pop)\n  done\nval drain_stack : 'a stack -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"inheritance-virtual-classes-initializers\"\u003eInheritance, virtual classes, initializers\u003c/h3\u003e\n\u003cp\u003eI've noticed programmers in Java tend to overuse inheritance, possibly\nbecause it's the only reasonable way of extending code in that language.\nA much better and more general way to extend code is usually to use\nhooks (cf. Apache's module API). Nevertheless in certain narrow areas\ninheritance can be useful, and the most important of these is in writing\nGUI widget libraries.\u003c/p\u003e\n\u003cp\u003eLet's consider an imaginary OCaml widget library similar to Java's\nSwing. We will define buttons and labels with the following class\nhierarchy:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewidget  (superclass for all widgets)\n  |\n  +----\u0026gt; container  (any widget that can contain other widgets)\n  |        |\n  |        +----\u0026gt; button\n  |\n  +-------------\u0026gt; label\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Notice that a \u003ccode\u003ebutton\u003c/code\u003e is a \u003ccode\u003econtainer\u003c/code\u003e because it can contain either a\nlabel or an image, depending on what is displayed on the button).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewidget\u003c/code\u003e is the virtual superclass for all widgets. I want every widget\nto have a name (just a string) which is constant over the life of that\nwidget. This was my first attempt:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# class virtual widget name =\n  object (self)\n    method get_name =\n      name\n    method virtual repaint : unit\n  end\nLines 1-6, characters 1-6:\nError: Some type variables are unbound in this type:\n         class virtual widget :\n           'a -\u0026gt;\n           object method get_name : 'a method virtual repaint : unit end\n       The method get_name has type 'a where 'a is unbound\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOops! I forgot that OCaml cannot infer the type of \u003ccode\u003ename\u003c/code\u003e so will assume\nthat it is \u003ccode\u003e'a\u003c/code\u003e. But that defines a polymorphic class, and I didn't\ndeclare the class as polymorphic (\u003ccode\u003eclass ['a] widget\u003c/code\u003e). I need to narrow\nthe type of \u003ccode\u003ename\u003c/code\u003e like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# class virtual widget (name : string) =\n  object (self)\n    method get_name =\n      name\n    method virtual repaint : unit\n  end;;\nclass virtual widget :\n  string -\u0026gt; object method get_name : string method virtual repaint : unit end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow there are several new things going on in this code. Firstly the\nclass contains an \u003cstrong\u003einitializer\u003c/strong\u003e. This is an argument to the class\n(\u003ccode\u003ename\u003c/code\u003e) which you can think of as exactly the equivalent of an argument\nto a constructor in, eg., Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Widget\n{\n  public Widget (String name)\n  {\n    ...\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn OCaml a constructor constructs the whole class, it's not just a\nspecially named function, so we write the arguments as if they are\narguments to the class:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eclass foo arg1 arg2 ... =\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSecondly the class contains a virtual method, and thus the whole class\nis marked as virtual. The virtual method is our \u003ccode\u003erepaint\u003c/code\u003e method. We\nneed to tell OCaml it's virtual (\u003ccode\u003emethod virtual\u003c/code\u003e), \u003cem\u003eand\u003c/em\u003e we need to\ntell OCaml the type of the method. Because the method doesn't contain\nany code, OCaml can't use type inference to automatically work out the\ntype for you, so you need to tell it the type. In this case the method\njust returns \u003ccode\u003eunit\u003c/code\u003e. If your class contains any virtual methods (even\njust inherited ones) then you need to specify the whole class as virtual\nby using \u003ccode\u003eclass virtual ...\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAs in C++ and Java, virtual classes cannot be directly instantiated\nusing \u003ccode\u003enew\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let w = new widget \u0026quot;my widget\u0026quot;\nLine 1, characters 9-19:\nError: Cannot instantiate the virtual class widget\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow my \u003ccode\u003econtainer\u003c/code\u003e class is more interesting. It must inherit from\n\u003ccode\u003ewidget\u003c/code\u003e and have the mechanics for storing the list of contained\nwidgets. Here is my simple implementation for \u003ccode\u003econtainer\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# class virtual container name =\n  object (self)\n    inherit widget name\n    val mutable widgets = ([] : widget list)\n    method add w =\n      widgets \u0026lt;- w :: widgets\n    method get_widgets =\n      widgets\n    method repaint =\n      List.iter (fun w -\u0026gt; w#repaint) widgets\n  end\nclass virtual container :\n  string -\u0026gt;\n  object\n    val mutable widgets : widget list\n    method add : widget -\u0026gt; unit\n    method get_name : string\n    method get_widgets : widget list\n    method repaint : unit\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotes:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe \u003ccode\u003econtainer\u003c/code\u003e class is marked as virtual. It doesn't contain any\nvirtual methods, but in this case I just want to prevent people\ncreating containers directly.\n\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003econtainer\u003c/code\u003e class has a \u003ccode\u003ename\u003c/code\u003e argument which is passed directly\nup when constructing the \u003ccode\u003ewidget\u003c/code\u003e.\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einherit widget name\u003c/code\u003e means that the \u003ccode\u003econtainer\u003c/code\u003e inherits from\n\u003ccode\u003ewidget\u003c/code\u003e, and it passes the \u003ccode\u003ename\u003c/code\u003e argument to the constructor for\n\u003ccode\u003ewidget\u003c/code\u003e.\n\u003c/li\u003e\n\u003cli\u003eMy \u003ccode\u003econtainer\u003c/code\u003e contains a mutable list of widgets and methods to\n\u003ccode\u003eadd\u003c/code\u003e a widget to this list and \u003ccode\u003eget_widgets\u003c/code\u003e (return the list of\nwidgets).\n\u003c/li\u003e\n\u003cli\u003eThe list of widgets returned by \u003ccode\u003eget_widgets\u003c/code\u003e cannot be modified by\ncode outside the class. The reason for this is somewhat subtle, but\nbasically comes down to the fact that OCaml's linked lists are\nimmutable. Let's imagine that someone wrote this code:\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let list = container#get_widgets in\n  x :: list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWould this modify the private internal representation of my \u003ccode\u003econtainer\u003c/code\u003e\nclass, by prepending \u003ccode\u003ex\u003c/code\u003e to the list of widgets? No it wouldn't. The\nprivate variable \u003ccode\u003ewidgets\u003c/code\u003e would be unaffected by this or any other\nchange attempted by the outside code. This means, for example, that you\ncould change the internal representation to use an array at some later\ndate, and no code outside the class would need to be changed.\u003c/p\u003e\n\u003cp\u003eLast, but not least, we have implemented the previously virtual\n\u003ccode\u003erepaint\u003c/code\u003e function so that \u003ccode\u003econtainer#repaint\u003c/code\u003e will repaint all of the\ncontained widgets. Notice I use \u003ccode\u003eList.iter\u003c/code\u003e to iterate over the list,\nand I also use a probably unfamiliar anonymous function expression:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# (fun w -\u0026gt; w#repaint)\n- : \u0026lt; repaint : 'a; .. \u0026gt; -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich defines an anonymous function with one argument \u003ccode\u003ew\u003c/code\u003e that just\ncalls \u003ccode\u003ew#repaint\u003c/code\u003e (the \u003ccode\u003erepaint\u003c/code\u003e method on widget \u003ccode\u003ew\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eIn this instance our \u003ccode\u003ebutton\u003c/code\u003e class is simple (rather unrealistically\nsimple in fact, but nevermind that):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type button_state = Released | Pressed\ntype button_state = Released | Pressed\n# class button ?callback name =\n  object (self)\n    inherit container name as super\n    val mutable state = Released\n    method press =\n      state \u0026lt;- Pressed;\n      match callback with\n      | None -\u0026gt; ()\n      | Some f -\u0026gt; f ()\n    method release =\n      state \u0026lt;- Released\n    method repaint =\n      super#repaint;\n      print_endline (\u0026quot;Button being repainted, state is \u0026quot; ^\n                     (match state with\n                      | Pressed -\u0026gt; \u0026quot;Pressed\u0026quot;\n                      | Released -\u0026gt; \u0026quot;Released\u0026quot;))\n  end\nclass button :\n  ?callback:(unit -\u0026gt; unit) -\u0026gt;\n  string -\u0026gt;\n  object\n    val mutable state : button_state\n    val mutable widgets : widget list\n    method add : widget -\u0026gt; unit\n    method get_name : string\n    method get_widgets : widget list\n    method press : unit\n    method release : unit\n    method repaint : unit\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotes:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThis function has an optional argument (see the previous chapter)\nwhich is used to pass in the optional callback function. The\ncallback is called when the button is pressed.\n\u003c/li\u003e\n\u003cli\u003eThe expression \u003ccode\u003einherit container name as super\u003c/code\u003e names the\nsuperclass \u003ccode\u003esuper\u003c/code\u003e. I use this in the \u003ccode\u003erepaint\u003c/code\u003e method:\n\u003ccode\u003esuper#repaint\u003c/code\u003e. This expressly calls the superclass method.\n\u003c/li\u003e\n\u003cli\u003ePressing the button (calling \u003ccode\u003ebutton#press\u003c/code\u003e in this rather\nsimplistic code) sets the state of the button to \u003ccode\u003ePressed\u003c/code\u003e and calls\nthe callback function, if one was defined. Notice that the\n\u003ccode\u003ecallback\u003c/code\u003e variable is either \u003ccode\u003eNone\u003c/code\u003e or \u003ccode\u003eSome f\u003c/code\u003e, in other words it\nhas type \u003ccode\u003e(unit -\u0026gt; unit) option\u003c/code\u003e. Reread the previous chapter if you\nare unsure about this.\n\u003c/li\u003e\n\u003cli\u003eNotice a strange thing about the \u003ccode\u003ecallback\u003c/code\u003e variable. It's defined\nas an argument to the class, but any method can see and use it. In\nother words, the variable is supplied when the object is\nconstructed, but persists over the lifetime of the object.\n\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003erepaint\u003c/code\u003e method has been implemented. It calls the superclass\n(to repaint the container), then repaints the button, displaying the\ncurrent state of the button.\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBefore defining our \u003ccode\u003elabel\u003c/code\u003e class, let's play with the \u003ccode\u003ebutton\u003c/code\u003e class in\nthe OCaml toplevel:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let b = new button ~callback:(fun () -\u0026gt; print_endline \u0026quot;Ouch!\u0026quot;) \u0026quot;button\u0026quot;\nval b : button = \u0026lt;obj\u0026gt;\n# b#repaint\nButton being repainted, state is Released\n- : unit = ()\n# b#press\nOuch!\n- : unit = ()\n# b#repaint\nButton being repainted, state is Pressed\n- : unit = ()\n# b#release\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere's our comparatively trivial \u003ccode\u003elabel\u003c/code\u003e class:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# class label name text =\n  object (self)\n    inherit widget name\n    method repaint =\n      print_endline (\u0026quot;Label: \u0026quot; ^ text)\n  end\nclass label :\n  string -\u0026gt;\n  string -\u0026gt; object method get_name : string method repaint : unit end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's create a label which says \u0026quot;Press me!\u0026quot; and add it to the button:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let l = new label \u0026quot;label\u0026quot; \u0026quot;Press me!\u0026quot;\nval l : label = \u0026lt;obj\u0026gt;\n# b#add l\n- : unit = ()\n# b#repaint\nLabel: Press me!\nButton being repainted, state is Released\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"a-note-about-self\"\u003eA note about \u003ccode\u003eself\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eIn all the examples above we defined classes using the general pattern:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eclass name =\n  object (self)\n    (* ... *)\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI didn't explain the reference to \u003ccode\u003eself\u003c/code\u003e. In fact this names the object,\nallowing you to call methods in the same class or pass the object to\nfunctions outside the class. In other words, it's exactly the same as\n\u003ccode\u003ethis\u003c/code\u003e in C++/Java. You may completely omit the\n\u003ccode\u003e(self)\u003c/code\u003e part if you don't need to refer to yourself - indeed in all the\nexamples above we could have done exactly that. However, I would advise\nyou to leave it in there because you never know when you might modify\nthe class and require the reference to \u003ccode\u003eself\u003c/code\u003e. There is no penalty for\nhaving it.\u003c/p\u003e\n\u003ch3 id=\"inheritance-and-coercions\"\u003eInheritance and coercions\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let b = new button \u0026quot;button\u0026quot;\nval b : button = \u0026lt;obj\u0026gt;\n# let l = new label \u0026quot;label\u0026quot; \u0026quot;Press me!\u0026quot;\nval l : label = \u0026lt;obj\u0026gt;\n# [b; l]\nLine 1, characters 5-6:\nError: This expression has type label but an expression was expected of type\n         button\n       The first object type has no method add\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI created a button \u003ccode\u003eb\u003c/code\u003e and a label \u003ccode\u003el\u003c/code\u003e and I tried to create a list\ncontaining both, but I got an error. Yet \u003ccode\u003eb\u003c/code\u003e and \u003ccode\u003el\u003c/code\u003e are both \u003ccode\u003ewidget\u003c/code\u003es,\nso why can't I put them into the same list? Perhaps OCaml can't guess\nthat I want a \u003ccode\u003ewidget list\u003c/code\u003e? Let's try telling it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let wl = ([] : widget list)\nval wl : widget list = []\n# let wl = b :: wl\nLine 1, characters 15-17:\nError: This expression has type widget list\n       but an expression was expected of type button list\n       Type widget = \u0026lt; get_name : string; repaint : unit \u0026gt;\n       is not compatible with type\n         button =\n           \u0026lt; add : widget -\u0026gt; unit; get_name : string;\n             get_widgets : widget list; press : unit; release : unit;\n             repaint : unit \u0026gt;\n       The first object type has no method add\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt turns out that OCaml doesn't coerce subclasses to the type of the\nsuperclass by default, but you can tell it to by using the \u003ccode\u003e:\u0026gt;\u003c/code\u003e\n(coercion) operator:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let wl = (b :\u0026gt; widget) :: wl\nval wl : widget list = [\u0026lt;obj\u0026gt;]\n# let wl = (l :\u0026gt; widget) :: wl\nval wl : widget list = [\u0026lt;obj\u0026gt;; \u0026lt;obj\u0026gt;]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe expression \u003ccode\u003e(b :\u0026gt; widget)\u003c/code\u003e means \u0026quot;coerce the button \u003ccode\u003eb\u003c/code\u003e to have type\n\u003ccode\u003ewidget\u003c/code\u003e\u0026quot;. Type-safety is preserved because it is possible to tell\ncompletely at compile time whether the coercion will succeed.\u003c/p\u003e\n\u003cp\u003eActually, coercions are somewhat more subtle than described above, and\nso I urge you to read the manual to find out the full details.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003econtainer#add\u003c/code\u003e method defined above is actually incorrect, and\nfails if you try to add widgets of different types into a \u003ccode\u003econtainer\u003c/code\u003e. A\ncoercion would fix this.\u003c/p\u003e\n\u003cp\u003eIs it possible to coerce from a superclass (eg. \u003ccode\u003ewidget\u003c/code\u003e) to a subclass\n(eg. \u003ccode\u003ebutton\u003c/code\u003e)? The answer, perhaps surprisingly, is NO! Coercing in\nthis direction is \u003cem\u003eunsafe\u003c/em\u003e. You might try to coerce a \u003ccode\u003ewidget\u003c/code\u003e which is\nin fact a \u003ccode\u003elabel\u003c/code\u003e, not a \u003ccode\u003ebutton\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"the-oo-module-and-comparing-objects\"\u003eThe \u003ccode\u003eOo\u003c/code\u003e module and comparing objects\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eOo\u003c/code\u003e module contains a few useful functions for OO programming.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eOo.copy\u003c/code\u003e makes a shallow copy of an object. \u003ccode\u003eOo.id object\u003c/code\u003e returns a\nunique identifying number for each object (a unique number across all\nclasses).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e=\u003c/code\u003e and \u003ccode\u003e\u0026lt;\u0026gt;\u003c/code\u003e can be used to compare objects for \u003cem\u003ephysical\u003c/em\u003e equality (an\nobject and its copy are not physically identical). You can also use \u003ccode\u003e\u0026lt;\u003c/code\u003e\netc. which provides an ordering of objects based apparently on their\nIDs.\u003c/p\u003e\n\u003ch2 id=\"objects-without-class\"\u003eObjects without class\u003c/h2\u003e\n\u003cp\u003eHere we examine how to use objects pretty much like records, without\nnecessarily using classes.\u003c/p\u003e\n\u003ch3 id=\"immediate-objects-and-object-types\"\u003eImmediate objects and object types\u003c/h3\u003e\n\u003cp\u003eObjects can be used instead of records, and have some nice properties\nthat can make them preferable to records in some cases. We saw that the\ncanonical way of creating objects is to first define a class, and use\nthis class to create individual objects. This can be cumbersome in some\nsituations since class definitions are more than a type definition and\ncannot be defined recursively with types. However, objects have a type\nthat is very analog to a record type, and it can be used in type\ndefinitions. In addition, objects can be created without a class. They\nare called \u003cem\u003eimmediate objects\u003c/em\u003e. Here is the definition of an immediate\nobject:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let o =\n  object\n    val mutable n = 0\n    method incr = n \u0026lt;- n + 1\n    method get = n\n  end\nval o : \u0026lt; get : int; incr : unit \u0026gt; = \u0026lt;obj\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis object has a type, which is defined by its public methods only.\nValues are not visible and neither are private methods (not shown).\nUnlike records, such a type does not need to be predefined explicitly,\nbut doing so can make things clearer. We can do it like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type counter = \u0026lt;get : int; incr : unit\u0026gt;\ntype counter = \u0026lt; get : int; incr : unit \u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCompare with an equivalent record type definition:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type counter_r =\n  {get : unit -\u0026gt; int;\n   incr : unit -\u0026gt; unit}\ntype counter_r = { get : unit -\u0026gt; int; incr : unit -\u0026gt; unit; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe implementation of a record working like our object would be:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let r =\n  let n = ref 0 in\n    {get = (fun () -\u0026gt; !n);\n     incr = (fun () -\u0026gt; incr n)}\nval r : counter_r = {get = \u0026lt;fun\u0026gt;; incr = \u0026lt;fun\u0026gt;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn terms of functionality, both the object and the record are similar,\nbut each solution has its own advantages:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003espeed\u003c/strong\u003e: slightly faster field access in records\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003efield names\u003c/strong\u003e: it is inconvenient to manipulate records of\ndifferent types when some fields are named identically but it's not\na problem with objects\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003esubtyping\u003c/strong\u003e: it is impossible to coerce the type of a record to a\ntype with less fields. That is however possible with objects, so\nobjects of different kinds that share some methods can be mixed in a\ndata structure where only their common methods are visible (see next\nsection)\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003etype definitions\u003c/strong\u003e: there is no need to define an object type in\nadvance, so it lightens the dependency constraints between modules\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"class-types-vs-just-types\"\u003eClass types vs. just types\u003c/h3\u003e\n\u003cp\u003eBeware of the confusion between \u003cem\u003eclass types\u003c/em\u003e and object \u003cem\u003etypes\u003c/em\u003e. A\n\u003cem\u003eclass type\u003c/em\u003e is not a data \u003cem\u003etype\u003c/em\u003e, normally referred to as \u003cem\u003etype\u003c/em\u003e in the\nOCaml jargon. An object \u003cem\u003etype\u003c/em\u003e is a kind of data \u003cem\u003etype\u003c/em\u003e, just like a\nrecord type or a tuple.\u003c/p\u003e\n\u003cp\u003eWhen a class is defined, both a \u003cem\u003eclass type\u003c/em\u003e and an object \u003cem\u003etype\u003c/em\u003e of the\nsame name are defined:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# class t =\n  object\n    val x = 0\n    method get = x\n  end\nclass t : object val x : int method get : int end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eobject val x : int method get : int end\u003c/code\u003e is a class type.\u003c/p\u003e\n\u003cp\u003eIn this example, \u003ccode\u003et\u003c/code\u003e is also the type of objects that this class would\ncreate. Objects that derive from different classes or no class at all\n(immediate objects) can be mixed together as long as they have the same\ntype:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let x = object method get = 123 end\nval x : \u0026lt; get : int \u0026gt; = \u0026lt;obj\u0026gt;\n# let l = [new t; x]\nval l : t list = [\u0026lt;obj\u0026gt;; \u0026lt;obj\u0026gt;]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMixing objects that share a common subtype can be done, but requires\nexplicit type coercion using the \u003ccode\u003e:\u0026gt;\u003c/code\u003e operator:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let x = object method get = 123 end\nval x : \u0026lt; get : int \u0026gt; = \u0026lt;obj\u0026gt;\n# let y = object method get = 80 method special = \u0026quot;hello\u0026quot; end\nval y : \u0026lt; get : int; special : string \u0026gt; = \u0026lt;obj\u0026gt;\n# let l = [x; y]\nLine 1, characters 13-14:\nError: This expression has type \u0026lt; get : int; special : string \u0026gt;\n       but an expression was expected of type \u0026lt; get : int \u0026gt;\n       The second object type has no method special\n# let l = [x; (y :\u0026gt; t)]\nval l : t list = [\u0026lt;obj\u0026gt;; \u0026lt;obj\u0026gt;]\n\u003c/code\u003e\u003c/pre\u003e\n"},{"title":"Error Handling","slug":"error-handling","description":"Discover the different ways you can manage errors in your OCaml programs\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"errors","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\n## Exceptions\n\nOne way of handling errors in OCaml is exceptions. The\nstandard library relies heavily upon them.\n\nExceptions belong to the type `exn` (an extensible sum type):\n\n```ocaml\nexception Foo of string\n\nlet i_will_fail () =\n  raise (Foo \"Oh no!\")\n```\n\nHere, we add a variant `Foo` to the type `exn`, and create a function\nthat will raise this exception. Now, how do we handle exceptions?\nThe construct is `try ... with ...`:\n\n```ocaml\nlet safe_inverse n =\n  try Some (1 / n) with\n    Division_by_zero -\u003e None\n\nlet safe_list_find p l =\n  try Some (List.find p l) with\n    Not_found -\u003e None\n```\n\nWe can try those functions:\n\n```ocaml\n# 1 / 0;;\nException: Division_by_zero.\n# safe_inverse 2;;\n- : int option = Some 0\n# safe_inverse 0;;\n- : int option = None\n# List.find (fun x -\u003e x mod 2 = 0) [1; 3; 5]\nException: Not_found.\n# safe_list_find (fun x -\u003e x mod 2 = 0) [1; 3; 4; 5]\n- : int option = Some 4\n# safe_list_find (fun x -\u003e x mod 2 = 0) [1; 3; 5]\n- : int option = None\n```\n\nThe biggest issue with exceptions is that they do not appear in types.\nOne has to read the documentation to see that, indeed, `Map.S.find`\nor `List.hd` are not total functions, and that they might fail.\n\nIt is considered good practice nowadays, when a function can fail in\ncases that are not bugs (i.e., not `assert false`, but network failures,\nkeys not present, etc.)\nto return a more explicit type such as `'a option` or `('a, 'b) result`.\nA relatively common idiom is to have such a safe version of the function,\nsay, `val foo : a -\u003e b option`, and an exception raising\nversion `val foo_exn : a -\u003e b`.\n\n### Documentation\n\nFunctions that can raise exceptions should be documented like this:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nval foo : a -\u003e b\n(** foo does this and that, here is how it works, etc.\n    @raise Invalid_argument if [a] doesn't satisfy ...\n    @raise Sys_error if filesystem is not happy *)\n```\n\n### Stacktraces\n\nTo get a stacktrace when a unhandled exception makes your program crash, you\nneed to compile the program in \"debug\" mode (with `-g` when calling\n`ocamlc`, or `-tag 'debug'` when calling `ocamlbuild`).\nThen:\n\n```\nOCAMLRUNPARAM=b ./myprogram [args]\n```\n\nAnd you will get a stacktrace. Alternatively, you can call, from within the program,\n\n```ocaml\nlet () = Printexc.record_backtrace true\n```\n\n### Printing\n\nTo print an exception, the module `Printexc` comes in handy. For instance,\nthe following function `notify_user : (unit -\u003e 'a) -\u003e 'a` can be used\nto call a function and, if it fails, print the exception on `stderr`.\nIf stacktraces are enabled, this function will also display it.\n\n```ocaml\nlet notify_user f =\n  try f () with e -\u003e\n    let msg = Printexc.to_string e\n    and stack = Printexc.get_backtrace () in\n      Printf.eprintf \"there was an error: %s%s\\n\" msg stack;\n      raise e\n```\n\nOCaml knows how to print its built-in exception, but you can also tell it\nhow to print your own exceptions:\n\n```ocaml\nexception Foo of int\n\nlet () =\n  Printexc.register_printer\n    (function\n      | Foo i -\u003e Some (Printf.sprintf \"Foo(%d)\" i)\n      | _ -\u003e None (* for other exceptions *)\n    )\n```\n\nEach printer should take care of the exceptions it knows about, returning\n`Some \u003cprinted exception\u003e`, and return `None` otherwise (let the other printers\ndo the job!).\n\n## Result type\n\nThe Stdlib module contains the following type:\n\n```ocaml\ntype ('a, 'b) result =\n  | Ok of 'a\n  | Error of 'b\n```\n\nA value `Ok x` means that the computation succeeded with `x`, and\na value `Error e` means that it failed.\nPattern matching can be used to deal with both cases, as with any\nother sum type. The advantage here is that a function `a -\u003e b` that\nfails can be modified so its type is `a -\u003e (b, error) result`,\nwhich makes the failure explicit.\nThe error case `e` in `Error e` can be of any type\n(the `'b` type variable), but a few possible choices\nare:\n\n- `exn`, in which case the result type just makes exceptions explicit.\n- `string`, where the error case is a message that indicates what failed.\n- `string lazy_t`, a more elaborate form of error message that is only evaluated\n  if printing is required.\n- some polymorphic variant, with one case per\n  possible error. This is very accurate (each error can be dealt with\n  explicitly and occurs in the type) but the use of polymorphic variants\n  sometimes make error messages hard to read.\n\nFor easy combination of functions that can fail, many alternative standard\nlibraries provide useful combinators on the `result` type: `map`, `\u003e\u003e=`, etc.\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#exceptions\"\u003eExceptions\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#result-type\"\u003eResult type\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"exceptions\"\u003eExceptions\u003c/h2\u003e\n\u003cp\u003eOne way of handling errors in OCaml is exceptions. The\nstandard library relies heavily upon them.\u003c/p\u003e\n\u003cp\u003eExceptions belong to the type \u003ccode\u003eexn\u003c/code\u003e (an extensible sum type):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eexception Foo of string\n\nlet i_will_fail () =\n  raise (Foo \u0026quot;Oh no!\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, we add a variant \u003ccode\u003eFoo\u003c/code\u003e to the type \u003ccode\u003eexn\u003c/code\u003e, and create a function\nthat will raise this exception. Now, how do we handle exceptions?\nThe construct is \u003ccode\u003etry ... with ...\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet safe_inverse n =\n  try Some (1 / n) with\n    Division_by_zero -\u0026gt; None\n\nlet safe_list_find p l =\n  try Some (List.find p l) with\n    Not_found -\u0026gt; None\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can try those functions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# 1 / 0;;\nException: Division_by_zero.\n# safe_inverse 2;;\n- : int option = Some 0\n# safe_inverse 0;;\n- : int option = None\n# List.find (fun x -\u0026gt; x mod 2 = 0) [1; 3; 5]\nException: Not_found.\n# safe_list_find (fun x -\u0026gt; x mod 2 = 0) [1; 3; 4; 5]\n- : int option = Some 4\n# safe_list_find (fun x -\u0026gt; x mod 2 = 0) [1; 3; 5]\n- : int option = None\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe biggest issue with exceptions is that they do not appear in types.\nOne has to read the documentation to see that, indeed, \u003ccode\u003eMap.S.find\u003c/code\u003e\nor \u003ccode\u003eList.hd\u003c/code\u003e are not total functions, and that they might fail.\u003c/p\u003e\n\u003cp\u003eIt is considered good practice nowadays, when a function can fail in\ncases that are not bugs (i.e., not \u003ccode\u003eassert false\u003c/code\u003e, but network failures,\nkeys not present, etc.)\nto return a more explicit type such as \u003ccode\u003e'a option\u003c/code\u003e or \u003ccode\u003e('a, 'b) result\u003c/code\u003e.\nA relatively common idiom is to have such a safe version of the function,\nsay, \u003ccode\u003eval foo : a -\u0026gt; b option\u003c/code\u003e, and an exception raising\nversion \u003ccode\u003eval foo_exn : a -\u0026gt; b\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"documentation\"\u003eDocumentation\u003c/h3\u003e\n\u003cp\u003eFunctions that can raise exceptions should be documented like this:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eval foo : a -\u0026gt; b\n(** foo does this and that, here is how it works, etc.\n    @raise Invalid_argument if [a] doesn't satisfy ...\n    @raise Sys_error if filesystem is not happy *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"stacktraces\"\u003eStacktraces\u003c/h3\u003e\n\u003cp\u003eTo get a stacktrace when a unhandled exception makes your program crash, you\nneed to compile the program in \u0026quot;debug\u0026quot; mode (with \u003ccode\u003e-g\u003c/code\u003e when calling\n\u003ccode\u003eocamlc\u003c/code\u003e, or \u003ccode\u003e-tag 'debug'\u003c/code\u003e when calling \u003ccode\u003eocamlbuild\u003c/code\u003e).\nThen:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eOCAMLRUNPARAM=b ./myprogram [args]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd you will get a stacktrace. Alternatively, you can call, from within the program,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet () = Printexc.record_backtrace true\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"printing\"\u003ePrinting\u003c/h3\u003e\n\u003cp\u003eTo print an exception, the module \u003ccode\u003ePrintexc\u003c/code\u003e comes in handy. For instance,\nthe following function \u003ccode\u003enotify_user : (unit -\u0026gt; 'a) -\u0026gt; 'a\u003c/code\u003e can be used\nto call a function and, if it fails, print the exception on \u003ccode\u003estderr\u003c/code\u003e.\nIf stacktraces are enabled, this function will also display it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet notify_user f =\n  try f () with e -\u0026gt;\n    let msg = Printexc.to_string e\n    and stack = Printexc.get_backtrace () in\n      Printf.eprintf \u0026quot;there was an error: %s%s\\n\u0026quot; msg stack;\n      raise e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOCaml knows how to print its built-in exception, but you can also tell it\nhow to print your own exceptions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eexception Foo of int\n\nlet () =\n  Printexc.register_printer\n    (function\n      | Foo i -\u0026gt; Some (Printf.sprintf \u0026quot;Foo(%d)\u0026quot; i)\n      | _ -\u0026gt; None (* for other exceptions *)\n    )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEach printer should take care of the exceptions it knows about, returning\n\u003ccode\u003eSome \u0026lt;printed exception\u0026gt;\u003c/code\u003e, and return \u003ccode\u003eNone\u003c/code\u003e otherwise (let the other printers\ndo the job!).\u003c/p\u003e\n\u003ch2 id=\"result-type\"\u003eResult type\u003c/h2\u003e\n\u003cp\u003eThe Stdlib module contains the following type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype ('a, 'b) result =\n  | Ok of 'a\n  | Error of 'b\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA value \u003ccode\u003eOk x\u003c/code\u003e means that the computation succeeded with \u003ccode\u003ex\u003c/code\u003e, and\na value \u003ccode\u003eError e\u003c/code\u003e means that it failed.\nPattern matching can be used to deal with both cases, as with any\nother sum type. The advantage here is that a function \u003ccode\u003ea -\u0026gt; b\u003c/code\u003e that\nfails can be modified so its type is \u003ccode\u003ea -\u0026gt; (b, error) result\u003c/code\u003e,\nwhich makes the failure explicit.\nThe error case \u003ccode\u003ee\u003c/code\u003e in \u003ccode\u003eError e\u003c/code\u003e can be of any type\n(the \u003ccode\u003e'b\u003c/code\u003e type variable), but a few possible choices\nare:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eexn\u003c/code\u003e, in which case the result type just makes exceptions explicit.\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estring\u003c/code\u003e, where the error case is a message that indicates what failed.\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estring lazy_t\u003c/code\u003e, a more elaborate form of error message that is only evaluated\nif printing is required.\n\u003c/li\u003e\n\u003cli\u003esome polymorphic variant, with one case per\npossible error. This is very accurate (each error can be dealt with\nexplicitly and occurs in the type) but the use of polymorphic variants\nsometimes make error messages hard to read.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor easy combination of functions that can fail, many alternative standard\nlibraries provide useful combinators on the \u003ccode\u003eresult\u003c/code\u003e type: \u003ccode\u003emap\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;=\u003c/code\u003e, etc.\u003c/p\u003e\n"},{"title":"Common Error Messages","slug":"common-error-messages","description":"Understand the most common error messages the OCaml compiler can throw at you\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"errors","tl":{"hd":"debugging","tl":0}},"users":{"hd":"Beginner","tl":0},"body_md":"\nThis page gives a list of quick explanations for some error or warning\nmessages that are emitted by the OCaml compilers. Longer explanations\nare usually given in dedicated sections of this tutorial.\n\n## Type errors\n###  This expression has type ... but is here used with type ...\nWhen the type of an object is not compatible with the context in which\nit is used, it is frequent to obtain this kind of message:\n\n```ocaml\n# 1 + 2.5\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n```\n\"This expression has type *X* but is here used with type *Y*\" means that\nif the contents of the expression is isolated (2.5), its type is\ninferred as *X* (float). But the context, i.e. everything which is\naround (1 + ...) tells that the gap expects an expression of type *Y*\n(int) which is not compatible with *X*.\n\nMore disturbing is the following message:\n\n```text\nThis expression has type my_type but is here used with type my_type\n```\nThis error happens often while testing some type definitions using the\ninteractive toplevel.  In OCaml, it is perfectly legal\nto define a type with a name\nthat is already taken by another type. Consider the following session:\n\n```ocaml\n# type my_type = A | B\ntype my_type = A | B\n# let a = A\nval a : my_type = A\n# type my_type = A | B\ntype my_type = A | B\n# let b = B\nval b : my_type = B\n# a = b\nLine 1, characters 5-6:\nError: This expression has type my_type/1\n       but an expression was expected of type my_type/2\n       Hint: The type my_type has been defined multiple times in this\n         toplevel session. Some toplevel values still refer to old versions\n         of this type. Did you try to redefine them?\n```\nFor the compiler, the second definition of my_type is totally\nindependent from the first definition. So we have defined two types\nwhich have the same name. Since \"a\" was defined earlier, it belongs to\nthe first type while \"b\" belongs to the second type. In this example,\nredefining \"a\" after the last definition of my_type solves the problem.\nThis kind of problem should not happen in real programs unless you use\nthe same name for the same type in the same module, which is highly\ndiscouraged.\n\n###  Warning: This optional argument cannot be erased\nFunctions with optional arguments must have at least one non-labelled\nargument. For instance, this is not OK:\n\n```ocaml\n# let f ?(x = 0) ?(y = 0) = print_int (x + y)\nLine 1, characters 18-23:\nWarning 16: this optional argument cannot be erased.\nval f : ?x:int -\u003e ?y:int -\u003e unit = \u003cfun\u003e\n```\nThe solution is simply to add one argument of type unit, like this:\n\n```ocaml\n# let f ?(x = 0) ?(y = 0) () = print_int (x + y)\nval f : ?x:int -\u003e ?y:int -\u003e unit -\u003e unit = \u003cfun\u003e\n```\nSee the [Labels](labels.html \"Labels\") section for more details on\nfunctions with labelled arguments.\n\n###  The type of this expression... contains type variables that cannot be generalized\nThis happens in some cases when the full type of an object is not known\nby the compiler when it reaches the end of the compilation unit (file)\nbut for some reason it cannot remain polymorphic. Example:\n\n```ocaml env=ref\n# let x = ref None\nval x : '_weak1 option ref = {contents = None}\n```\ntriggers the following message during the compilation:\n\n```text\nThe type of this expression, '_a option ref,\ncontains type variables that cannot be generalized\n```\n\nSolution: help the compiler with a type annotation, like for instance:\n\n```ocaml env=ref\n# let x : string option ref = ref None\nval x : string option ref = {contents = None}\n```\nor:\n\n```ocaml env=ref\n# let x = ref (None : string option)\nval x : string option ref = {contents = None}\n```\n\nData of type `'_weak\u003cn\u003e` may be allowed temporarily, for instance during a\ntoplevel session. It means that the given object has an unknown type,\nbut it cannot be any type: it is not polymorphic data. In the toplevel,\nour example gives these results:\n\n```ocaml env=ref\n# let x = ref None\nval x : '_weak2 option ref = {contents = None}\n```\n\nThe compiler tells us that the type of x is not fully known yet. But by\nusing `x` later, the compiler can infer the type of `x`:\n\n```ocaml env=ref\n# x := Some 0\n- : unit = ()\n```\nNow `x` has a known type:\n\n```ocaml env=ref\n# x\n- : int option ref = {contents = Some 0}\n```\n\n## Pattern matching warnings and errors\n###  This pattern is unused\nThis warning should be considered as an error, since there is no reason\nto intentionally keep such code. It may happen when the programmer\nintroduced a catch-all pattern unintentionally such as in the following\nsituation:\n\n```ocaml\n# let test_member x tup =\n  match tup with\n  | (y, _) | (_, y) when y = x -\u003e true\n  | _ -\u003e false\nLine 3, characters 14-20:\nWarning 12: this sub-pattern is unused.\nLine 3, characters 5-20:\nWarning 57: Ambiguous or-pattern variables under guard;\nvariable y may match different arguments. (See manual section 9.5)\nval test_member : 'a -\u003e 'a * 'a -\u003e bool = \u003cfun\u003e\n```\nObviously, the programmer had a misconception of what OCaml's pattern\nmatching is about. Remember the following:\n\n* the tree of cases is traversed linearly, from left to right. There\n is *no backtracking* as in regexp matching.\n* a guard (\"when\" clause) is not part of a pattern. It is simply a\n condition which is evaluated at most once and is used as a last\n resort to jump to the next match case.\n* lowercase identifiers (bindings such as \"y\" above) are just names,\n so they will always match.\n\nIn our example, it is now clear that only the first item of the pair\nwill ever be tested. This leads to the following results:\n\n```ocaml\n# test_member 1 (1, 0)\n- : bool = true\n# test_member 1 (0, 1)\n- : bool = false\n```\n###  This pattern-matching is not exhaustive\nOCaml's pattern matching can check whether a set of patterns is\nexhaustive or not, based on the *type* only. So in the following\nexample, the compiler doesn't know what range of ints the \"mod\" operator\nwould return:\n\n```ocamltop\nlet is_even x =\n  match x mod 2 with\n  | 0 -\u003e true\n  | 1 | -1 -\u003e false\n```\nA short solution without pattern matching would be:\n\n```ocaml\n# let is_even x = x mod 2 = 0\nval is_even : int -\u003e bool = \u003cfun\u003e\n```\nIn general, that kind of simplification is not possible and the best\nsolution is to add a catch-all case which should never be reached:\n\n```ocaml\n# let is_even x =\n  match x mod 2 with\n  | 0 -\u003e true\n  | 1 | -1 -\u003e false\n  | _ -\u003e assert false\nval is_even : int -\u003e bool = \u003cfun\u003e\n```\n\n## Problems recompiling valid programs\n###  x.cmi is not a compiled interface\nWhen recompiling some old program or compiling a program from an\nexternal source that was not cleaned properly, it is possible to get\nthis error message:\n\n```text\nsome_module.cmi is not a compiled interface\n```\n\nIt means that some_module.cmi is not valid according to the *current\nversion* of the OCaml compiler. Most of the time, removing the old\ncompiled files (*.cmi, *.cmo, *.cmx, ...) and recompiling is\nsufficient to solve this problem.\n\t\n###  Warning: Illegal backslash escape in string\nRecent versions of OCaml warn you against unprotected backslashes in\nstrings since they should be doubled. Such a message may be displayed\nwhen compiling an older program, and can be turned off with the `-w x`\noption.\n\n```ocaml\n# \"\\e\\n\" (* bad practice *)\nFile \"_none_\", line 1, characters 1-3:\nWarning 14: illegal backslash escape in string.\n- : string = \"\\\\e\\n\"\n# \"\\\\e\\n\" (* good practice *)\n- : string = \"\\\\e\\n\"\n```\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#type-errors\"\u003eType errors\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#pattern-matching-warnings-and-errors\"\u003ePattern matching warnings and errors\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#problems-recompiling-valid-programs\"\u003eProblems recompiling valid programs\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eThis page gives a list of quick explanations for some error or warning\nmessages that are emitted by the OCaml compilers. Longer explanations\nare usually given in dedicated sections of this tutorial.\u003c/p\u003e\n\u003ch2 id=\"type-errors\"\u003eType errors\u003c/h2\u003e\n\u003ch3 id=\"this-expression-has-type--but-is-here-used-with-type-\"\u003eThis expression has type ... but is here used with type ...\u003c/h3\u003e\n\u003cp\u003eWhen the type of an object is not compatible with the context in which\nit is used, it is frequent to obtain this kind of message:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# 1 + 2.5\nLine 1, characters 5-8:\nError: This expression has type float but an expression was expected of type\n         int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u0026quot;This expression has type \u003cem\u003eX\u003c/em\u003e but is here used with type \u003cem\u003eY\u003c/em\u003e\u0026quot; means that\nif the contents of the expression is isolated (2.5), its type is\ninferred as \u003cem\u003eX\u003c/em\u003e (float). But the context, i.e. everything which is\naround (1 + ...) tells that the gap expects an expression of type \u003cem\u003eY\u003c/em\u003e\n(int) which is not compatible with \u003cem\u003eX\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eMore disturbing is the following message:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003eThis expression has type my_type but is here used with type my_type\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis error happens often while testing some type definitions using the\ninteractive toplevel.  In OCaml, it is perfectly legal\nto define a type with a name\nthat is already taken by another type. Consider the following session:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type my_type = A | B\ntype my_type = A | B\n# let a = A\nval a : my_type = A\n# type my_type = A | B\ntype my_type = A | B\n# let b = B\nval b : my_type = B\n# a = b\nLine 1, characters 5-6:\nError: This expression has type my_type/1\n       but an expression was expected of type my_type/2\n       Hint: The type my_type has been defined multiple times in this\n         toplevel session. Some toplevel values still refer to old versions\n         of this type. Did you try to redefine them?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor the compiler, the second definition of my_type is totally\nindependent from the first definition. So we have defined two types\nwhich have the same name. Since \u0026quot;a\u0026quot; was defined earlier, it belongs to\nthe first type while \u0026quot;b\u0026quot; belongs to the second type. In this example,\nredefining \u0026quot;a\u0026quot; after the last definition of my_type solves the problem.\nThis kind of problem should not happen in real programs unless you use\nthe same name for the same type in the same module, which is highly\ndiscouraged.\u003c/p\u003e\n\u003ch3 id=\"warning-this-optional-argument-cannot-be-erased\"\u003eWarning: This optional argument cannot be erased\u003c/h3\u003e\n\u003cp\u003eFunctions with optional arguments must have at least one non-labelled\nargument. For instance, this is not OK:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let f ?(x = 0) ?(y = 0) = print_int (x + y)\nLine 1, characters 18-23:\nWarning 16: this optional argument cannot be erased.\nval f : ?x:int -\u0026gt; ?y:int -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe solution is simply to add one argument of type unit, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let f ?(x = 0) ?(y = 0) () = print_int (x + y)\nval f : ?x:int -\u0026gt; ?y:int -\u0026gt; unit -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSee the \u003ca href=\"labels.html\" title=\"Labels\"\u003eLabels\u003c/a\u003e section for more details on\nfunctions with labelled arguments.\u003c/p\u003e\n\u003ch3 id=\"the-type-of-this-expression-contains-type-variables-that-cannot-be-generalized\"\u003eThe type of this expression... contains type variables that cannot be generalized\u003c/h3\u003e\n\u003cp\u003eThis happens in some cases when the full type of an object is not known\nby the compiler when it reaches the end of the compilation unit (file)\nbut for some reason it cannot remain polymorphic. Example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let x = ref None\nval x : '_weak1 option ref = {contents = None}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003etriggers the following message during the compilation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003eThe type of this expression, '_a option ref,\ncontains type variables that cannot be generalized\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSolution: help the compiler with a type annotation, like for instance:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let x : string option ref = ref None\nval x : string option ref = {contents = None}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let x = ref (None : string option)\nval x : string option ref = {contents = None}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eData of type \u003ccode\u003e'_weak\u0026lt;n\u0026gt;\u003c/code\u003e may be allowed temporarily, for instance during a\ntoplevel session. It means that the given object has an unknown type,\nbut it cannot be any type: it is not polymorphic data. In the toplevel,\nour example gives these results:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let x = ref None\nval x : '_weak2 option ref = {contents = None}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe compiler tells us that the type of x is not fully known yet. But by\nusing \u003ccode\u003ex\u003c/code\u003e later, the compiler can infer the type of \u003ccode\u003ex\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# x := Some 0\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow \u003ccode\u003ex\u003c/code\u003e has a known type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# x\n- : int option ref = {contents = Some 0}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"pattern-matching-warnings-and-errors\"\u003ePattern matching warnings and errors\u003c/h2\u003e\n\u003ch3 id=\"this-pattern-is-unused\"\u003eThis pattern is unused\u003c/h3\u003e\n\u003cp\u003eThis warning should be considered as an error, since there is no reason\nto intentionally keep such code. It may happen when the programmer\nintroduced a catch-all pattern unintentionally such as in the following\nsituation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let test_member x tup =\n  match tup with\n  | (y, _) | (_, y) when y = x -\u0026gt; true\n  | _ -\u0026gt; false\nLine 3, characters 14-20:\nWarning 12: this sub-pattern is unused.\nLine 3, characters 5-20:\nWarning 57: Ambiguous or-pattern variables under guard;\nvariable y may match different arguments. (See manual section 9.5)\nval test_member : 'a -\u0026gt; 'a * 'a -\u0026gt; bool = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eObviously, the programmer had a misconception of what OCaml's pattern\nmatching is about. Remember the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe tree of cases is traversed linearly, from left to right. There\nis \u003cem\u003eno backtracking\u003c/em\u003e as in regexp matching.\n\u003c/li\u003e\n\u003cli\u003ea guard (\u0026quot;when\u0026quot; clause) is not part of a pattern. It is simply a\ncondition which is evaluated at most once and is used as a last\nresort to jump to the next match case.\n\u003c/li\u003e\n\u003cli\u003elowercase identifiers (bindings such as \u0026quot;y\u0026quot; above) are just names,\nso they will always match.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn our example, it is now clear that only the first item of the pair\nwill ever be tested. This leads to the following results:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# test_member 1 (1, 0)\n- : bool = true\n# test_member 1 (0, 1)\n- : bool = false\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"this-pattern-matching-is-not-exhaustive\"\u003eThis pattern-matching is not exhaustive\u003c/h3\u003e\n\u003cp\u003eOCaml's pattern matching can check whether a set of patterns is\nexhaustive or not, based on the \u003cem\u003etype\u003c/em\u003e only. So in the following\nexample, the compiler doesn't know what range of ints the \u0026quot;mod\u0026quot; operator\nwould return:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocamltop\"\u003elet is_even x =\n  match x mod 2 with\n  | 0 -\u0026gt; true\n  | 1 | -1 -\u0026gt; false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA short solution without pattern matching would be:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let is_even x = x mod 2 = 0\nval is_even : int -\u0026gt; bool = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn general, that kind of simplification is not possible and the best\nsolution is to add a catch-all case which should never be reached:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let is_even x =\n  match x mod 2 with\n  | 0 -\u0026gt; true\n  | 1 | -1 -\u0026gt; false\n  | _ -\u0026gt; assert false\nval is_even : int -\u0026gt; bool = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"problems-recompiling-valid-programs\"\u003eProblems recompiling valid programs\u003c/h2\u003e\n\u003ch3 id=\"xcmi-is-not-a-compiled-interface\"\u003ex.cmi is not a compiled interface\u003c/h3\u003e\n\u003cp\u003eWhen recompiling some old program or compiling a program from an\nexternal source that was not cleaned properly, it is possible to get\nthis error message:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003esome_module.cmi is not a compiled interface\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt means that some_module.cmi is not valid according to the \u003cem\u003ecurrent\nversion\u003c/em\u003e of the OCaml compiler. Most of the time, removing the old\ncompiled files (*.cmi, *.cmo, *.cmx, ...) and recompiling is\nsufficient to solve this problem.\u003c/p\u003e\n\u003ch3 id=\"warning-illegal-backslash-escape-in-string\"\u003eWarning: Illegal backslash escape in string\u003c/h3\u003e\n\u003cp\u003eRecent versions of OCaml warn you against unprotected backslashes in\nstrings since they should be doubled. Such a message may be displayed\nwhen compiling an older program, and can be turned off with the \u003ccode\u003e-w x\u003c/code\u003e\noption.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# \u0026quot;\\e\\n\u0026quot; (* bad practice *)\nFile \u0026quot;_none_\u0026quot;, line 1, characters 1-3:\nWarning 14: illegal backslash escape in string.\n- : string = \u0026quot;\\\\e\\n\u0026quot;\n# \u0026quot;\\\\e\\n\u0026quot; (* good practice *)\n- : string = \u0026quot;\\\\e\\n\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n"},{"title":"Debug","slug":"debug","description":"Learn to build custom types and write function to process this data\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"debugging","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\nThis tutorial presents two techniques for debugging OCaml programs:\n\n* [Tracing functions calls](#Tracingfunctionscallsinthetoplevel),\n  which works in the interactive toplevel.\n* The [OCaml debugger](#The-OCaml-debugger), which allows analysing programs\n  compiled with `ocamlc`.\n\n## Tracing functions calls in the toplevel\n\nThe simplest way to debug programs in the toplevel is to follow the function\ncalls, by tracing the faulty function:\n\n```ocaml\n# let rec fib x = if x \u003c= 1 then 1 else fib (x - 1) + fib (x - 2)\nval fib : int -\u003e int = \u003cfun\u003e\n# #trace fib\nfib is now traced.\n# fib 3\nfib \u003c-- 3\nfib \u003c-- 1\nfib --\u003e 1\nfib \u003c-- 2\nfib \u003c-- 0\nfib --\u003e 1\nfib \u003c-- 1\nfib --\u003e 1\nfib --\u003e 2\nfib --\u003e 3\n- : int = 3\n# #untrace fib\nfib is no longer traced.\n```\n\n###  Polymorphic functions\n\nA difficulty with polymorphic functions is that the output of the trace system\nis not very informative in case of polymorphic arguments and/or results.\nConsider a sorting algorithm (say bubble sort):\n\n```ocaml\n# let exchange i j v =\n  let aux = v.(i) in\n    v.(i) \u003c- v.(j);\n    v.(j) \u003c- aux\nval exchange : int -\u003e int -\u003e 'a array -\u003e unit = \u003cfun\u003e\n# let one_pass_vect fin v =\n  for j = 1 to fin do\n    if v.(j - 1) \u003e v.(j) then exchange (j - 1) j v\n  done\nval one_pass_vect : int -\u003e 'a array -\u003e unit = \u003cfun\u003e\n# let bubble_sort_vect v =\n  for i = Array.length v - 1 downto 0 do\n    one_pass_vect i v\n  done\nval bubble_sort_vect : 'a array -\u003e unit = \u003cfun\u003e\n# let q = [|18; 3; 1|]\nval q : int array = [|18; 3; 1|]\n# #trace one_pass_vect\none_pass_vect is now traced.\n# bubble_sort_vect q\none_pass_vect \u003c-- 2\none_pass_vect --\u003e \u003cfun\u003e\none_pass_vect* \u003c-- [|\u003cpoly\u003e; \u003cpoly\u003e; \u003cpoly\u003e|]\none_pass_vect* --\u003e ()\none_pass_vect \u003c-- 1\none_pass_vect --\u003e \u003cfun\u003e\none_pass_vect* \u003c-- [|\u003cpoly\u003e; \u003cpoly\u003e; \u003cpoly\u003e|]\none_pass_vect* --\u003e ()\none_pass_vect \u003c-- 0\none_pass_vect --\u003e \u003cfun\u003e\none_pass_vect* \u003c-- [|\u003cpoly\u003e; \u003cpoly\u003e; \u003cpoly\u003e|]\none_pass_vect* --\u003e ()\n- : unit = ()\n```\n\nThe function `one_pass_vect` being polymorphic, its vector argument is printed\nas a vector containing polymorphic values, `[|\u003cpoly\u003e; \u003cpoly\u003e; \u003cpoly\u003e|]`, and\nthus we cannot properly follow the computation.\n\nA simple way to overcome this problem is to define a monomorphic version of the\nfaulty function. This is fairly easy using a *type constraint*.  Generally\nspeaking, this allows a proper understanding of the error in the definition of\nthe polymorphic function. Once this has been corrected, you just have to\nsuppress the type constraint to revert to a polymorphic version of the\nfunction.\n\nFor our sorting routine, a single type constraint on the argument of the\n`exchange` function warranties a monomorphic typing, that allows a proper trace\nof function calls:\n\n```ocaml\n# let exchange i j (v : int array) =    (* notice the type constraint *)\n  let aux = v.(i) in\n    v.(i) \u003c- v.(j);\n    v.(j) \u003c- aux\nval exchange : int -\u003e int -\u003e int array -\u003e unit = \u003cfun\u003e\n# let one_pass_vect fin v =\n  for j = 1 to fin do\n    if v.(j - 1) \u003e v.(j) then exchange (j - 1) j v\n  done\nval one_pass_vect : int -\u003e int array -\u003e unit = \u003cfun\u003e\n# let bubble_sort_vect v =\n  for i = Array.length v - 1 downto 0 do\n    one_pass_vect i v\n  done\nval bubble_sort_vect : int array -\u003e unit = \u003cfun\u003e\n# let q = [| 18; 3; 1 |]\nval q : int array = [|18; 3; 1|]\n# #trace one_pass_vect\none_pass_vect is now traced.\n# bubble_sort_vect q\none_pass_vect \u003c-- 2\none_pass_vect --\u003e \u003cfun\u003e\none_pass_vect* \u003c-- [|18; 3; 1|]\none_pass_vect* --\u003e ()\none_pass_vect \u003c-- 1\none_pass_vect --\u003e \u003cfun\u003e\none_pass_vect* \u003c-- [|3; 1; 18|]\none_pass_vect* --\u003e ()\none_pass_vect \u003c-- 0\none_pass_vect --\u003e \u003cfun\u003e\none_pass_vect* \u003c-- [|1; 3; 18|]\none_pass_vect* --\u003e ()\n- : unit = ()\n```\n\n###  Limitations\n\nTo keep track of assignments to data structures and mutable variables in a\nprogram, the trace facility is not powerful enough. You need an extra mechanism\nto stop the program in any place and ask for internal values: that is a\nsymbolic debugger with its stepping feature.\n\nStepping a functional program has a meaning which is a bit weird to define and\nunderstand. Let me say that we use the notion of *runtime events* that happen\nfor instance when a parameter is passed to a function or when entering a\npattern matching, or selecting a clause in a pttern matching. Computation\nprogress is taken into account by these events, independently of the\ninstructions executed on the hardware.\n\nAlthough this is difficult to implement, there exists such a debugger for OCaml\nunder Unix: `ocamldebug`. Its use is illustrated in the next section.\n\nIn fact, for complex programs, it is likely the case that the programmer will\nuse explicit printing to find the bugs, since this methodology allows the\nreduction of the trace material: only useful data are printed and special\npurpose formats are more suited to get the relevant information, than what can\nbe output automatically by the generic pretty-printer used by the trace\nmechanism.\n\n## The OCaml debugger\n\nWe now give a quick tutorial for the OCaml debugger (`ocamldebug`).  Before\nstarting, please note that `ocamldebug` does not work under native Windows\nports of OCaml (but it runs under the Cygwin port).\n\n###  Launching the debugger\n\nConsider the following obviously wrong program written in the file\n`uncaught.ml`:\n\n```ocaml\n(* file uncaught.ml *)\nlet l = ref []\nlet find_address name = List.assoc name !l\nlet add_address name address = l := (name, address) :: ! l\n\nlet () =\n  add_address \"IRIA\" \"Rocquencourt\";;\n  print_string (find_address \"INRIA\"); print_newline ();;\n```\n```mdx-error\nval l : (string * string) list ref = {contents = [(\"IRIA\", \"Rocquencourt\")]}\nval find_address : string -\u003e string = \u003cfun\u003e\nval add_address : string -\u003e string -\u003e unit = \u003cfun\u003e\nException: Not_found.\n```\n\nAt runtime, the program raises an uncaught exception `Not_found`.  Suppose we\nwant to find where and why this exception has been raised, we can proceed as\nfollows. First, we compile the program in debug mode:\n\n```\nocamlc -g uncaught.ml\n```\n\nWe launch the debugger:\n\n```\nocamldebug a.out\n```\n\nThen the debugger answers with a banner and a prompt:\n\n```\nOCaml Debugger version 4.12.0\n\n(ocd)\n```\n\n###  Finding the cause of a spurious exception\n\nType `r` (for *run*); you get\n\n```\n(ocd) r\nLoading program... done.\nTime : 12\nProgram end.\nUncaught exception: Not_found\n(ocd)\n```\n\nSelf explanatory, isn't it? So, you want to step backward to set the program\ncounter before the time the exception is raised; hence type in `b` as\n*backstep*, and you get\n\n```\n(ocd) b\nTime : 11 - pc : 15500 - module List\n143     [] -\u003e \u003c|b|\u003eraise Not_found\n```\n\nThe debugger tells you that you are in module `List`, inside a pattern matching\non a list that already chose the `[]` case and is about to execute `raise\nNot_found`, since the program is stopped just before this expression (as\nwitnessed by the `\u003c|b|\u003e` mark).\n\nBut, as you know, you want the debugger to tell you which procedure calls the\none from `List`, and also who calls the procedure that calls the one from\n`List`; hence, you want a backtrace of the execution stack:\n\n```\n(ocd) bt\n#0  Pc : 15500  List char 3562\n#1  Pc : 19128  Uncaught char 221\n```\n\nSo the last function called is from module `List` at character 3562, that is:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec assoc x = function\n  | [] -\u003e raise Not_found\n          ^\n  | (a,b)::l -\u003e if a = x then b else assoc x l\n```\n\nThe function that calls it is in module `Uncaught`, file `uncaught.ml` char\n221:\n\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nprint_string (find_address \"INRIA\"); print_newline ();;\n                                  ^\n```\n\nTo sum up: if you're developing a program you can compile it with the `-g`\noption, to be ready to debug the program if necessary. Hence, to find a\nspurious exception you just need to type `ocamldebug a.out`, then `r`, `b`, and\n`bt` gives you the backtrace.\n\n###  Getting help and info in the debugger\n\nTo get more info about the current status of the debugger you can ask it\ndirectly at the toplevel prompt of the debugger; for instance:\n\n```\n(ocd) info breakpoints\nNo breakpoint.\n\n(ocd) help break\n  1      15396  in List, character 3539\nbreak : Set breakpoint at specified line or function.\nSyntax: break function-name\nbreak @ [module] linenum\nbreak @ [module] # characternum\n```\n\n###  Setting break points\n\nLet's set up a breakpoint and rerun the entire program from the\nbeginning (`(g)oto 0` then `(r)un`):\n\n```\n(ocd) break @Uncaught 9\nBreakpoint 3 at 19112 : file Uncaught, line 9 column 34\n\n(ocd) g 0\nTime : 0\nBeginning of program.\n\n(ocd) r\nTime : 6 - pc : 19112 - module Uncaught\nBreakpoint : 1\n9 add \"IRIA\" \"Rocquencourt\"\u003c|a|\u003e;;\n```\n\nThen, we can step and find what happens when `find_address` is about to be\ncalled\n\n```\n(ocd) s\nTime : 7 - pc : 19012 - module Uncaught\n5 let find_address name = \u003c|b|\u003eList.assoc name !l;;\n\n(ocd) p name\nname : string = \"INRIA\"\n\n(ocd) p !l\n$1 : (string * string) list = [\"IRIA\", \"Rocquencourt\"]\n(ocd)\n```\n\nNow we can guess why `List.assoc` will fail to find \"INRIA\" in the list...\n\n###  Using the debugger under Emacs\n\nUnder Emacs you call the debugger using `ESC-x` `ocamldebug a.out`. Then Emacs\nwill send you directly to the file and character reported by the debugger, and\nyou can step back and forth using `ESC-b` and `ESC-s`, you can set up break\npoints using `CTRL-X space`, and so on...\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#tracing-functions-calls-in-the-toplevel\"\u003eTracing functions calls in the toplevel\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-ocaml-debugger\"\u003eThe OCaml debugger\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eThis tutorial presents two techniques for debugging OCaml programs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#Tracingfunctionscallsinthetoplevel\"\u003eTracing functions calls\u003c/a\u003e,\nwhich works in the interactive toplevel.\n\u003c/li\u003e\n\u003cli\u003eThe \u003ca href=\"#The-OCaml-debugger\"\u003eOCaml debugger\u003c/a\u003e, which allows analysing programs\ncompiled with \u003ccode\u003eocamlc\u003c/code\u003e.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tracing-functions-calls-in-the-toplevel\"\u003eTracing functions calls in the toplevel\u003c/h2\u003e\n\u003cp\u003eThe simplest way to debug programs in the toplevel is to follow the function\ncalls, by tracing the faulty function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec fib x = if x \u0026lt;= 1 then 1 else fib (x - 1) + fib (x - 2)\nval fib : int -\u0026gt; int = \u0026lt;fun\u0026gt;\n# #trace fib\nfib is now traced.\n# fib 3\nfib \u0026lt;-- 3\nfib \u0026lt;-- 1\nfib --\u0026gt; 1\nfib \u0026lt;-- 2\nfib \u0026lt;-- 0\nfib --\u0026gt; 1\nfib \u0026lt;-- 1\nfib --\u0026gt; 1\nfib --\u0026gt; 2\nfib --\u0026gt; 3\n- : int = 3\n# #untrace fib\nfib is no longer traced.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"polymorphic-functions\"\u003ePolymorphic functions\u003c/h3\u003e\n\u003cp\u003eA difficulty with polymorphic functions is that the output of the trace system\nis not very informative in case of polymorphic arguments and/or results.\nConsider a sorting algorithm (say bubble sort):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let exchange i j v =\n  let aux = v.(i) in\n    v.(i) \u0026lt;- v.(j);\n    v.(j) \u0026lt;- aux\nval exchange : int -\u0026gt; int -\u0026gt; 'a array -\u0026gt; unit = \u0026lt;fun\u0026gt;\n# let one_pass_vect fin v =\n  for j = 1 to fin do\n    if v.(j - 1) \u0026gt; v.(j) then exchange (j - 1) j v\n  done\nval one_pass_vect : int -\u0026gt; 'a array -\u0026gt; unit = \u0026lt;fun\u0026gt;\n# let bubble_sort_vect v =\n  for i = Array.length v - 1 downto 0 do\n    one_pass_vect i v\n  done\nval bubble_sort_vect : 'a array -\u0026gt; unit = \u0026lt;fun\u0026gt;\n# let q = [|18; 3; 1|]\nval q : int array = [|18; 3; 1|]\n# #trace one_pass_vect\none_pass_vect is now traced.\n# bubble_sort_vect q\none_pass_vect \u0026lt;-- 2\none_pass_vect --\u0026gt; \u0026lt;fun\u0026gt;\none_pass_vect* \u0026lt;-- [|\u0026lt;poly\u0026gt;; \u0026lt;poly\u0026gt;; \u0026lt;poly\u0026gt;|]\none_pass_vect* --\u0026gt; ()\none_pass_vect \u0026lt;-- 1\none_pass_vect --\u0026gt; \u0026lt;fun\u0026gt;\none_pass_vect* \u0026lt;-- [|\u0026lt;poly\u0026gt;; \u0026lt;poly\u0026gt;; \u0026lt;poly\u0026gt;|]\none_pass_vect* --\u0026gt; ()\none_pass_vect \u0026lt;-- 0\none_pass_vect --\u0026gt; \u0026lt;fun\u0026gt;\none_pass_vect* \u0026lt;-- [|\u0026lt;poly\u0026gt;; \u0026lt;poly\u0026gt;; \u0026lt;poly\u0026gt;|]\none_pass_vect* --\u0026gt; ()\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe function \u003ccode\u003eone_pass_vect\u003c/code\u003e being polymorphic, its vector argument is printed\nas a vector containing polymorphic values, \u003ccode\u003e[|\u0026lt;poly\u0026gt;; \u0026lt;poly\u0026gt;; \u0026lt;poly\u0026gt;|]\u003c/code\u003e, and\nthus we cannot properly follow the computation.\u003c/p\u003e\n\u003cp\u003eA simple way to overcome this problem is to define a monomorphic version of the\nfaulty function. This is fairly easy using a \u003cem\u003etype constraint\u003c/em\u003e.  Generally\nspeaking, this allows a proper understanding of the error in the definition of\nthe polymorphic function. Once this has been corrected, you just have to\nsuppress the type constraint to revert to a polymorphic version of the\nfunction.\u003c/p\u003e\n\u003cp\u003eFor our sorting routine, a single type constraint on the argument of the\n\u003ccode\u003eexchange\u003c/code\u003e function warranties a monomorphic typing, that allows a proper trace\nof function calls:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let exchange i j (v : int array) =    (* notice the type constraint *)\n  let aux = v.(i) in\n    v.(i) \u0026lt;- v.(j);\n    v.(j) \u0026lt;- aux\nval exchange : int -\u0026gt; int -\u0026gt; int array -\u0026gt; unit = \u0026lt;fun\u0026gt;\n# let one_pass_vect fin v =\n  for j = 1 to fin do\n    if v.(j - 1) \u0026gt; v.(j) then exchange (j - 1) j v\n  done\nval one_pass_vect : int -\u0026gt; int array -\u0026gt; unit = \u0026lt;fun\u0026gt;\n# let bubble_sort_vect v =\n  for i = Array.length v - 1 downto 0 do\n    one_pass_vect i v\n  done\nval bubble_sort_vect : int array -\u0026gt; unit = \u0026lt;fun\u0026gt;\n# let q = [| 18; 3; 1 |]\nval q : int array = [|18; 3; 1|]\n# #trace one_pass_vect\none_pass_vect is now traced.\n# bubble_sort_vect q\none_pass_vect \u0026lt;-- 2\none_pass_vect --\u0026gt; \u0026lt;fun\u0026gt;\none_pass_vect* \u0026lt;-- [|18; 3; 1|]\none_pass_vect* --\u0026gt; ()\none_pass_vect \u0026lt;-- 1\none_pass_vect --\u0026gt; \u0026lt;fun\u0026gt;\none_pass_vect* \u0026lt;-- [|3; 1; 18|]\none_pass_vect* --\u0026gt; ()\none_pass_vect \u0026lt;-- 0\none_pass_vect --\u0026gt; \u0026lt;fun\u0026gt;\none_pass_vect* \u0026lt;-- [|1; 3; 18|]\none_pass_vect* --\u0026gt; ()\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"limitations\"\u003eLimitations\u003c/h3\u003e\n\u003cp\u003eTo keep track of assignments to data structures and mutable variables in a\nprogram, the trace facility is not powerful enough. You need an extra mechanism\nto stop the program in any place and ask for internal values: that is a\nsymbolic debugger with its stepping feature.\u003c/p\u003e\n\u003cp\u003eStepping a functional program has a meaning which is a bit weird to define and\nunderstand. Let me say that we use the notion of \u003cem\u003eruntime events\u003c/em\u003e that happen\nfor instance when a parameter is passed to a function or when entering a\npattern matching, or selecting a clause in a pttern matching. Computation\nprogress is taken into account by these events, independently of the\ninstructions executed on the hardware.\u003c/p\u003e\n\u003cp\u003eAlthough this is difficult to implement, there exists such a debugger for OCaml\nunder Unix: \u003ccode\u003eocamldebug\u003c/code\u003e. Its use is illustrated in the next section.\u003c/p\u003e\n\u003cp\u003eIn fact, for complex programs, it is likely the case that the programmer will\nuse explicit printing to find the bugs, since this methodology allows the\nreduction of the trace material: only useful data are printed and special\npurpose formats are more suited to get the relevant information, than what can\nbe output automatically by the generic pretty-printer used by the trace\nmechanism.\u003c/p\u003e\n\u003ch2 id=\"the-ocaml-debugger\"\u003eThe OCaml debugger\u003c/h2\u003e\n\u003cp\u003eWe now give a quick tutorial for the OCaml debugger (\u003ccode\u003eocamldebug\u003c/code\u003e).  Before\nstarting, please note that \u003ccode\u003eocamldebug\u003c/code\u003e does not work under native Windows\nports of OCaml (but it runs under the Cygwin port).\u003c/p\u003e\n\u003ch3 id=\"launching-the-debugger\"\u003eLaunching the debugger\u003c/h3\u003e\n\u003cp\u003eConsider the following obviously wrong program written in the file\n\u003ccode\u003euncaught.ml\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* file uncaught.ml *)\nlet l = ref []\nlet find_address name = List.assoc name !l\nlet add_address name address = l := (name, address) :: ! l\n\nlet () =\n  add_address \u0026quot;IRIA\u0026quot; \u0026quot;Rocquencourt\u0026quot;;;\n  print_string (find_address \u0026quot;INRIA\u0026quot;); print_newline ();;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-mdx-error\"\u003eval l : (string * string) list ref = {contents = [(\u0026quot;IRIA\u0026quot;, \u0026quot;Rocquencourt\u0026quot;)]}\nval find_address : string -\u0026gt; string = \u0026lt;fun\u0026gt;\nval add_address : string -\u0026gt; string -\u0026gt; unit = \u0026lt;fun\u0026gt;\nException: Not_found.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt runtime, the program raises an uncaught exception \u003ccode\u003eNot_found\u003c/code\u003e.  Suppose we\nwant to find where and why this exception has been raised, we can proceed as\nfollows. First, we compile the program in debug mode:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eocamlc -g uncaught.ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe launch the debugger:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eocamldebug a.out\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen the debugger answers with a banner and a prompt:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eOCaml Debugger version 4.12.0\n\n(ocd)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"finding-the-cause-of-a-spurious-exception\"\u003eFinding the cause of a spurious exception\u003c/h3\u003e\n\u003cp\u003eType \u003ccode\u003er\u003c/code\u003e (for \u003cem\u003erun\u003c/em\u003e); you get\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(ocd) r\nLoading program... done.\nTime : 12\nProgram end.\nUncaught exception: Not_found\n(ocd)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSelf explanatory, isn't it? So, you want to step backward to set the program\ncounter before the time the exception is raised; hence type in \u003ccode\u003eb\u003c/code\u003e as\n\u003cem\u003ebackstep\u003c/em\u003e, and you get\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(ocd) b\nTime : 11 - pc : 15500 - module List\n143     [] -\u0026gt; \u0026lt;|b|\u0026gt;raise Not_found\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe debugger tells you that you are in module \u003ccode\u003eList\u003c/code\u003e, inside a pattern matching\non a list that already chose the \u003ccode\u003e[]\u003c/code\u003e case and is about to execute \u003ccode\u003eraise Not_found\u003c/code\u003e, since the program is stopped just before this expression (as\nwitnessed by the \u003ccode\u003e\u0026lt;|b|\u0026gt;\u003c/code\u003e mark).\u003c/p\u003e\n\u003cp\u003eBut, as you know, you want the debugger to tell you which procedure calls the\none from \u003ccode\u003eList\u003c/code\u003e, and also who calls the procedure that calls the one from\n\u003ccode\u003eList\u003c/code\u003e; hence, you want a backtrace of the execution stack:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(ocd) bt\n#0  Pc : 15500  List char 3562\n#1  Pc : 19128  Uncaught char 221\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo the last function called is from module \u003ccode\u003eList\u003c/code\u003e at character 3562, that is:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec assoc x = function\n  | [] -\u0026gt; raise Not_found\n          ^\n  | (a,b)::l -\u0026gt; if a = x then b else assoc x l\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe function that calls it is in module \u003ccode\u003eUncaught\u003c/code\u003e, file \u003ccode\u003euncaught.ml\u003c/code\u003e char\n221:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eprint_string (find_address \u0026quot;INRIA\u0026quot;); print_newline ();;\n                                  ^\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo sum up: if you're developing a program you can compile it with the \u003ccode\u003e-g\u003c/code\u003e\noption, to be ready to debug the program if necessary. Hence, to find a\nspurious exception you just need to type \u003ccode\u003eocamldebug a.out\u003c/code\u003e, then \u003ccode\u003er\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e, and\n\u003ccode\u003ebt\u003c/code\u003e gives you the backtrace.\u003c/p\u003e\n\u003ch3 id=\"getting-help-and-info-in-the-debugger\"\u003eGetting help and info in the debugger\u003c/h3\u003e\n\u003cp\u003eTo get more info about the current status of the debugger you can ask it\ndirectly at the toplevel prompt of the debugger; for instance:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(ocd) info breakpoints\nNo breakpoint.\n\n(ocd) help break\n  1      15396  in List, character 3539\nbreak : Set breakpoint at specified line or function.\nSyntax: break function-name\nbreak @ [module] linenum\nbreak @ [module] # characternum\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"setting-break-points\"\u003eSetting break points\u003c/h3\u003e\n\u003cp\u003eLet's set up a breakpoint and rerun the entire program from the\nbeginning (\u003ccode\u003e(g)oto 0\u003c/code\u003e then \u003ccode\u003e(r)un\u003c/code\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(ocd) break @Uncaught 9\nBreakpoint 3 at 19112 : file Uncaught, line 9 column 34\n\n(ocd) g 0\nTime : 0\nBeginning of program.\n\n(ocd) r\nTime : 6 - pc : 19112 - module Uncaught\nBreakpoint : 1\n9 add \u0026quot;IRIA\u0026quot; \u0026quot;Rocquencourt\u0026quot;\u0026lt;|a|\u0026gt;;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen, we can step and find what happens when \u003ccode\u003efind_address\u003c/code\u003e is about to be\ncalled\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(ocd) s\nTime : 7 - pc : 19012 - module Uncaught\n5 let find_address name = \u0026lt;|b|\u0026gt;List.assoc name !l;;\n\n(ocd) p name\nname : string = \u0026quot;INRIA\u0026quot;\n\n(ocd) p !l\n$1 : (string * string) list = [\u0026quot;IRIA\u0026quot;, \u0026quot;Rocquencourt\u0026quot;]\n(ocd)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we can guess why \u003ccode\u003eList.assoc\u003c/code\u003e will fail to find \u0026quot;INRIA\u0026quot; in the list...\u003c/p\u003e\n\u003ch3 id=\"using-the-debugger-under-emacs\"\u003eUsing the debugger under Emacs\u003c/h3\u003e\n\u003cp\u003eUnder Emacs you call the debugger using \u003ccode\u003eESC-x\u003c/code\u003e \u003ccode\u003eocamldebug a.out\u003c/code\u003e. Then Emacs\nwill send you directly to the file and character reported by the debugger, and\nyou can step back and forth using \u003ccode\u003eESC-b\u003c/code\u003e and \u003ccode\u003eESC-s\u003c/code\u003e, you can set up break\npoints using \u003ccode\u003eCTRL-X space\u003c/code\u003e, and so on...\u003c/p\u003e\n"},{"title":"Map","slug":"map","description":"Create a mapping using the standard library's Map module\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"stdlib","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\n## Module Map\n\nMap creates a \"mapping\". For instance, let's say I have some data that is\nusers and their associated passwords. I could with the Map module create\na mapping from user names to their passwords. The mapping module not\nonly does this but it does it fairly efficiently. It also does this in a\nfunctional way. In the example below I am going to do a mapping from\nstrings to strings. However, it is possible to do mappings with all\ndifferent types of data.\n\nTo create a Map I can do:\n\n```ocaml\n# module MyUsers = Map.Make(String)\nmodule MyUsers :\n  sig\n    type key = string\n    type 'a t = 'a Map.Make(String).t\n    val empty : 'a t\n    val is_empty : 'a t -\u003e bool\n    val mem : key -\u003e 'a t -\u003e bool\n    val add : key -\u003e 'a -\u003e 'a t -\u003e 'a t\n    val update : key -\u003e ('a option -\u003e 'a option) -\u003e 'a t -\u003e 'a t\n    val singleton : key -\u003e 'a -\u003e 'a t\n    val remove : key -\u003e 'a t -\u003e 'a t\n    val merge :\n      (key -\u003e 'a option -\u003e 'b option -\u003e 'c option) -\u003e 'a t -\u003e 'b t -\u003e 'c t\n    val union : (key -\u003e 'a -\u003e 'a -\u003e 'a option) -\u003e 'a t -\u003e 'a t -\u003e 'a t\n    val compare : ('a -\u003e 'a -\u003e int) -\u003e 'a t -\u003e 'a t -\u003e int\n    val equal : ('a -\u003e 'a -\u003e bool) -\u003e 'a t -\u003e 'a t -\u003e bool\n    val iter : (key -\u003e 'a -\u003e unit) -\u003e 'a t -\u003e unit\n    val fold : (key -\u003e 'a -\u003e 'b -\u003e 'b) -\u003e 'a t -\u003e 'b -\u003e 'b\n    val for_all : (key -\u003e 'a -\u003e bool) -\u003e 'a t -\u003e bool\n    val exists : (key -\u003e 'a -\u003e bool) -\u003e 'a t -\u003e bool\n    val filter : (key -\u003e 'a -\u003e bool) -\u003e 'a t -\u003e 'a t\n    val partition : (key -\u003e 'a -\u003e bool) -\u003e 'a t -\u003e 'a t * 'a t\n    val cardinal : 'a t -\u003e int\n    val bindings : 'a t -\u003e (key * 'a) list\n    val min_binding : 'a t -\u003e key * 'a\n    val min_binding_opt : 'a t -\u003e (key * 'a) option\n    val max_binding : 'a t -\u003e key * 'a\n    val max_binding_opt : 'a t -\u003e (key * 'a) option\n    val choose : 'a t -\u003e key * 'a\n    val choose_opt : 'a t -\u003e (key * 'a) option\n    val split : key -\u003e 'a t -\u003e 'a t * 'a option * 'a t\n    val find : key -\u003e 'a t -\u003e 'a\n    val find_opt : key -\u003e 'a t -\u003e 'a option\n    val find_first : (key -\u003e bool) -\u003e 'a t -\u003e key * 'a\n    val find_first_opt : (key -\u003e bool) -\u003e 'a t -\u003e (key * 'a) option\n    val find_last : (key -\u003e bool) -\u003e 'a t -\u003e key * 'a\n    val find_last_opt : (key -\u003e bool) -\u003e 'a t -\u003e (key * 'a) option\n    val map : ('a -\u003e 'b) -\u003e 'a t -\u003e 'b t\n    val mapi : (key -\u003e 'a -\u003e 'b) -\u003e 'a t -\u003e 'b t\n    val to_seq : 'a t -\u003e (key * 'a) Seq.t\n    val to_seq_from : key -\u003e 'a t -\u003e (key * 'a) Seq.t\n    val add_seq : (key * 'a) Seq.t -\u003e 'a t -\u003e 'a t\n    val of_seq : (key * 'a) Seq.t -\u003e 'a t\n  end\n```\n\nOK, we have created the module `MyUsers`.  Now, let's start putting\nsomething into it.  Where do we start?  Well, let's create an empty\nmap to begin with:\n\n```ocaml\n# let m = MyUsers.empty\nval m : 'a MyUsers.t = \u003cabstr\u003e\n```\n\nHummm. An empty map is kind of boring, so let's add some data.\n\n```ocaml\n# let m = MyUsers.add \"fred\" \"sugarplums\" m\nval m : string MyUsers.t = \u003cabstr\u003e\n```\n\nWe have now created a new mapagain called `m`, thus masking the previous\noneby adding\n\"fred\" and his password \"sugarplums\" to our previous empty map.\nThere is a fairly important point to make here. Once we have added the\nstring \"sugarplums\" we have fixed the types of mappings that we can do.\nThis means our mapping in our module `MyUsers` is from strings _to strings_.\nIf we want a mapping from strings to integers or a mapping from integers\nto whatever we will have to create a different mapping.\n\nLet's add in some additional data just for kicks.\n\n```ocaml\n# let m = MyUsers.add \"tom\" \"ilovelucy\" m\nval m : string MyUsers.t = \u003cabstr\u003e\n# let m = MyUsers.add \"mark\" \"ocamlrules\" m\nval m : string MyUsers.t = \u003cabstr\u003e\n# let m = MyUsers.add \"pete\" \"linux\" m\nval m : string MyUsers.t = \u003cabstr\u003e\n```\n\nNow that we have some data inside of our map, wouldn't it be nice\nto be able to view that data at some point? Let's begin by creating a\nsimple print function.\n\n```ocaml\n# let print_user key password =\n  print_string(key ^ \" \" ^ password ^ \"\\n\")\nval print_user : string -\u003e string -\u003e unit = \u003cfun\u003e\n```\n\nWe have here a function that will take two strings, a key, and a password,\nand print them out nicely, including a new line character at the end.\nAll we need to do is to have this function applied to our mapping. Here\nis what that would look like.\n\n```ocaml\n# MyUsers.iter print_user m\nfred sugarplums\nmark ocamlrules\npete linux\ntom ilovelucy\n- : unit = ()\n```\nThe reason we put our data into a mapping however is probably so we can\nquickly find the data. Let's actually show how to do a find.\n\n```ocaml\n# MyUsers.find \"fred\" m\n- : string = \"sugarplums\"\n```\n\nThis should quickly and efficiently return Fred's password: \"sugarplums\".\n\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#module-map\"\u003eModule Map\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"module-map\"\u003eModule Map\u003c/h2\u003e\n\u003cp\u003eMap creates a \u0026quot;mapping\u0026quot;. For instance, let's say I have some data that is\nusers and their associated passwords. I could with the Map module create\na mapping from user names to their passwords. The mapping module not\nonly does this but it does it fairly efficiently. It also does this in a\nfunctional way. In the example below I am going to do a mapping from\nstrings to strings. However, it is possible to do mappings with all\ndifferent types of data.\u003c/p\u003e\n\u003cp\u003eTo create a Map I can do:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# module MyUsers = Map.Make(String)\nmodule MyUsers :\n  sig\n    type key = string\n    type 'a t = 'a Map.Make(String).t\n    val empty : 'a t\n    val is_empty : 'a t -\u0026gt; bool\n    val mem : key -\u0026gt; 'a t -\u0026gt; bool\n    val add : key -\u0026gt; 'a -\u0026gt; 'a t -\u0026gt; 'a t\n    val update : key -\u0026gt; ('a option -\u0026gt; 'a option) -\u0026gt; 'a t -\u0026gt; 'a t\n    val singleton : key -\u0026gt; 'a -\u0026gt; 'a t\n    val remove : key -\u0026gt; 'a t -\u0026gt; 'a t\n    val merge :\n      (key -\u0026gt; 'a option -\u0026gt; 'b option -\u0026gt; 'c option) -\u0026gt; 'a t -\u0026gt; 'b t -\u0026gt; 'c t\n    val union : (key -\u0026gt; 'a -\u0026gt; 'a -\u0026gt; 'a option) -\u0026gt; 'a t -\u0026gt; 'a t -\u0026gt; 'a t\n    val compare : ('a -\u0026gt; 'a -\u0026gt; int) -\u0026gt; 'a t -\u0026gt; 'a t -\u0026gt; int\n    val equal : ('a -\u0026gt; 'a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a t -\u0026gt; bool\n    val iter : (key -\u0026gt; 'a -\u0026gt; unit) -\u0026gt; 'a t -\u0026gt; unit\n    val fold : (key -\u0026gt; 'a -\u0026gt; 'b -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b -\u0026gt; 'b\n    val for_all : (key -\u0026gt; 'a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; bool\n    val exists : (key -\u0026gt; 'a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; bool\n    val filter : (key -\u0026gt; 'a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a t\n    val partition : (key -\u0026gt; 'a -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; 'a t * 'a t\n    val cardinal : 'a t -\u0026gt; int\n    val bindings : 'a t -\u0026gt; (key * 'a) list\n    val min_binding : 'a t -\u0026gt; key * 'a\n    val min_binding_opt : 'a t -\u0026gt; (key * 'a) option\n    val max_binding : 'a t -\u0026gt; key * 'a\n    val max_binding_opt : 'a t -\u0026gt; (key * 'a) option\n    val choose : 'a t -\u0026gt; key * 'a\n    val choose_opt : 'a t -\u0026gt; (key * 'a) option\n    val split : key -\u0026gt; 'a t -\u0026gt; 'a t * 'a option * 'a t\n    val find : key -\u0026gt; 'a t -\u0026gt; 'a\n    val find_opt : key -\u0026gt; 'a t -\u0026gt; 'a option\n    val find_first : (key -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; key * 'a\n    val find_first_opt : (key -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; (key * 'a) option\n    val find_last : (key -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; key * 'a\n    val find_last_opt : (key -\u0026gt; bool) -\u0026gt; 'a t -\u0026gt; (key * 'a) option\n    val map : ('a -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b t\n    val mapi : (key -\u0026gt; 'a -\u0026gt; 'b) -\u0026gt; 'a t -\u0026gt; 'b t\n    val to_seq : 'a t -\u0026gt; (key * 'a) Seq.t\n    val to_seq_from : key -\u0026gt; 'a t -\u0026gt; (key * 'a) Seq.t\n    val add_seq : (key * 'a) Seq.t -\u0026gt; 'a t -\u0026gt; 'a t\n    val of_seq : (key * 'a) Seq.t -\u0026gt; 'a t\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOK, we have created the module \u003ccode\u003eMyUsers\u003c/code\u003e.  Now, let's start putting\nsomething into it.  Where do we start?  Well, let's create an empty\nmap to begin with:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let m = MyUsers.empty\nval m : 'a MyUsers.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHummm. An empty map is kind of boring, so let's add some data.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let m = MyUsers.add \u0026quot;fred\u0026quot; \u0026quot;sugarplums\u0026quot; m\nval m : string MyUsers.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe have now created a new mapagain called \u003ccode\u003em\u003c/code\u003e, thus masking the previous\noneby adding\n\u0026quot;fred\u0026quot; and his password \u0026quot;sugarplums\u0026quot; to our previous empty map.\nThere is a fairly important point to make here. Once we have added the\nstring \u0026quot;sugarplums\u0026quot; we have fixed the types of mappings that we can do.\nThis means our mapping in our module \u003ccode\u003eMyUsers\u003c/code\u003e is from strings \u003cem\u003eto strings\u003c/em\u003e.\nIf we want a mapping from strings to integers or a mapping from integers\nto whatever we will have to create a different mapping.\u003c/p\u003e\n\u003cp\u003eLet's add in some additional data just for kicks.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let m = MyUsers.add \u0026quot;tom\u0026quot; \u0026quot;ilovelucy\u0026quot; m\nval m : string MyUsers.t = \u0026lt;abstr\u0026gt;\n# let m = MyUsers.add \u0026quot;mark\u0026quot; \u0026quot;ocamlrules\u0026quot; m\nval m : string MyUsers.t = \u0026lt;abstr\u0026gt;\n# let m = MyUsers.add \u0026quot;pete\u0026quot; \u0026quot;linux\u0026quot; m\nval m : string MyUsers.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow that we have some data inside of our map, wouldn't it be nice\nto be able to view that data at some point? Let's begin by creating a\nsimple print function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let print_user key password =\n  print_string(key ^ \u0026quot; \u0026quot; ^ password ^ \u0026quot;\\n\u0026quot;)\nval print_user : string -\u0026gt; string -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe have here a function that will take two strings, a key, and a password,\nand print them out nicely, including a new line character at the end.\nAll we need to do is to have this function applied to our mapping. Here\nis what that would look like.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# MyUsers.iter print_user m\nfred sugarplums\nmark ocamlrules\npete linux\ntom ilovelucy\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe reason we put our data into a mapping however is probably so we can\nquickly find the data. Let's actually show how to do a find.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# MyUsers.find \u0026quot;fred\u0026quot; m\n- : string = \u0026quot;sugarplums\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis should quickly and efficiently return Fred's password: \u0026quot;sugarplums\u0026quot;.\u003c/p\u003e\n"},{"title":"Sets","slug":"sets","description":"The standard library's Set module\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"stdlib","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\n## Module Set\nTo make a set of strings:\n\n```ocaml\n# module SS = Set.Make(String)\nmodule SS :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -\u003e bool\n    val mem : elt -\u003e t -\u003e bool\n    val add : elt -\u003e t -\u003e t\n    val singleton : elt -\u003e t\n    val remove : elt -\u003e t -\u003e t\n    val union : t -\u003e t -\u003e t\n    val inter : t -\u003e t -\u003e t\n    val disjoint : t -\u003e t -\u003e bool\n    val diff : t -\u003e t -\u003e t\n    val compare : t -\u003e t -\u003e int\n    val equal : t -\u003e t -\u003e bool\n    val subset : t -\u003e t -\u003e bool\n    val iter : (elt -\u003e unit) -\u003e t -\u003e unit\n    val map : (elt -\u003e elt) -\u003e t -\u003e t\n    val fold : (elt -\u003e 'a -\u003e 'a) -\u003e t -\u003e 'a -\u003e 'a\n    val for_all : (elt -\u003e bool) -\u003e t -\u003e bool\n    val exists : (elt -\u003e bool) -\u003e t -\u003e bool\n    val filter : (elt -\u003e bool) -\u003e t -\u003e t\n    val partition : (elt -\u003e bool) -\u003e t -\u003e t * t\n    val cardinal : t -\u003e int\n    val elements : t -\u003e elt list\n    val min_elt : t -\u003e elt\n    val min_elt_opt : t -\u003e elt option\n    val max_elt : t -\u003e elt\n    val max_elt_opt : t -\u003e elt option\n    val choose : t -\u003e elt\n    val choose_opt : t -\u003e elt option\n    val split : elt -\u003e t -\u003e t * bool * t\n    val find : elt -\u003e t -\u003e elt\n    val find_opt : elt -\u003e t -\u003e elt option\n    val find_first : (elt -\u003e bool) -\u003e t -\u003e elt\n    val find_first_opt : (elt -\u003e bool) -\u003e t -\u003e elt option\n    val find_last : (elt -\u003e bool) -\u003e t -\u003e elt\n    val find_last_opt : (elt -\u003e bool) -\u003e t -\u003e elt option\n    val of_list : elt list -\u003e t\n    val to_seq_from : elt -\u003e t -\u003e elt Seq.t\n    val to_seq : t -\u003e elt Seq.t\n    val add_seq : elt Seq.t -\u003e t -\u003e t\n    val of_seq : elt Seq.t -\u003e t\n  end\n```\n\nTo create a set you need to start somewhere so here is the empty set:\n\n```ocaml\n# let s = SS.empty\nval s : SS.t = \u003cabstr\u003e\n```\n\nAlternatively if we know an element to start with we can create a set\nlike\n\n```ocaml\n# let s = SS.singleton \"hello\"\nval s : SS.t = \u003cabstr\u003e\n```\n\nTo add some elements to the set we can do.\n\n```ocaml\n# let s =\n  List.fold_right SS.add [\"hello\"; \"world\"; \"community\"; \"manager\";\n                          \"stuff\"; \"blue\"; \"green\"] s\nval s : SS.t = \u003cabstr\u003e\n```\n\nNow if we are playing around with sets we will probably want to see what\nis in the set that we have created. To do this we can write a function\nthat will print the set out.\n\n```ocaml\n# let print_set s = \n   SS.iter print_endline s\nval print_set : SS.t -\u003e unit = \u003cfun\u003e\n```\n\nIf we want to remove a specific element of a set there is a remove\nfunction. However if we want to remove several elements at once we could\nthink of it as doing a 'filter'. Let's filter out all words that are\nlonger than 5 characters.\n\nThis can be written as:\n\n```ocaml\n# let my_filter str =\n  String.length str \u003c= 5\nval my_filter : string -\u003e bool = \u003cfun\u003e\n# let s2 = SS.filter my_filter s\nval s2 : SS.t = \u003cabstr\u003e\n```\n\nor using an anonymous function:\n\n```ocaml\n# let s2 = SS.filter (fun str -\u003e String.length str \u003c= 5) s\nval s2 : SS.t = \u003cabstr\u003e\n```\n\nIf we want to check and see if an element is in the set it might look\nlike this.\n\n```ocaml\n# SS.mem \"hello\" s2\n- : bool = true\n```\n\nThe Set module also provides the set theoretic operations union,\nintersection and difference. For example, the difference of the original\nset and the set with short strings ( 5 characters) is the set of long\nstrings:\n\n```ocaml\n# print_set (SS.diff s s2)\ncommunity\nmanager\n- : unit = ()\n```\n\nNote that the Set module provides a purely functional data structure:\nremoving an element from a set does not alter that set but, rather,\nreturns a new set that is very similar to (and shares much of its\ninternals with) the original set.\n\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#module-set\"\u003eModule Set\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"module-set\"\u003eModule Set\u003c/h2\u003e\n\u003cp\u003eTo make a set of strings:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# module SS = Set.Make(String)\nmodule SS :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -\u0026gt; bool\n    val mem : elt -\u0026gt; t -\u0026gt; bool\n    val add : elt -\u0026gt; t -\u0026gt; t\n    val singleton : elt -\u0026gt; t\n    val remove : elt -\u0026gt; t -\u0026gt; t\n    val union : t -\u0026gt; t -\u0026gt; t\n    val inter : t -\u0026gt; t -\u0026gt; t\n    val disjoint : t -\u0026gt; t -\u0026gt; bool\n    val diff : t -\u0026gt; t -\u0026gt; t\n    val compare : t -\u0026gt; t -\u0026gt; int\n    val equal : t -\u0026gt; t -\u0026gt; bool\n    val subset : t -\u0026gt; t -\u0026gt; bool\n    val iter : (elt -\u0026gt; unit) -\u0026gt; t -\u0026gt; unit\n    val map : (elt -\u0026gt; elt) -\u0026gt; t -\u0026gt; t\n    val fold : (elt -\u0026gt; 'a -\u0026gt; 'a) -\u0026gt; t -\u0026gt; 'a -\u0026gt; 'a\n    val for_all : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; bool\n    val exists : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; bool\n    val filter : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; t\n    val partition : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; t * t\n    val cardinal : t -\u0026gt; int\n    val elements : t -\u0026gt; elt list\n    val min_elt : t -\u0026gt; elt\n    val min_elt_opt : t -\u0026gt; elt option\n    val max_elt : t -\u0026gt; elt\n    val max_elt_opt : t -\u0026gt; elt option\n    val choose : t -\u0026gt; elt\n    val choose_opt : t -\u0026gt; elt option\n    val split : elt -\u0026gt; t -\u0026gt; t * bool * t\n    val find : elt -\u0026gt; t -\u0026gt; elt\n    val find_opt : elt -\u0026gt; t -\u0026gt; elt option\n    val find_first : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt\n    val find_first_opt : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt option\n    val find_last : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt\n    val find_last_opt : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt option\n    val of_list : elt list -\u0026gt; t\n    val to_seq_from : elt -\u0026gt; t -\u0026gt; elt Seq.t\n    val to_seq : t -\u0026gt; elt Seq.t\n    val add_seq : elt Seq.t -\u0026gt; t -\u0026gt; t\n    val of_seq : elt Seq.t -\u0026gt; t\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo create a set you need to start somewhere so here is the empty set:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let s = SS.empty\nval s : SS.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlternatively if we know an element to start with we can create a set\nlike\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let s = SS.singleton \u0026quot;hello\u0026quot;\nval s : SS.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo add some elements to the set we can do.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let s =\n  List.fold_right SS.add [\u0026quot;hello\u0026quot;; \u0026quot;world\u0026quot;; \u0026quot;community\u0026quot;; \u0026quot;manager\u0026quot;;\n                          \u0026quot;stuff\u0026quot;; \u0026quot;blue\u0026quot;; \u0026quot;green\u0026quot;] s\nval s : SS.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow if we are playing around with sets we will probably want to see what\nis in the set that we have created. To do this we can write a function\nthat will print the set out.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let print_set s = \n   SS.iter print_endline s\nval print_set : SS.t -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we want to remove a specific element of a set there is a remove\nfunction. However if we want to remove several elements at once we could\nthink of it as doing a 'filter'. Let's filter out all words that are\nlonger than 5 characters.\u003c/p\u003e\n\u003cp\u003eThis can be written as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let my_filter str =\n  String.length str \u0026lt;= 5\nval my_filter : string -\u0026gt; bool = \u0026lt;fun\u0026gt;\n# let s2 = SS.filter my_filter s\nval s2 : SS.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor using an anonymous function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let s2 = SS.filter (fun str -\u0026gt; String.length str \u0026lt;= 5) s\nval s2 : SS.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we want to check and see if an element is in the set it might look\nlike this.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# SS.mem \u0026quot;hello\u0026quot; s2\n- : bool = true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe Set module also provides the set theoretic operations union,\nintersection and difference. For example, the difference of the original\nset and the set with short strings ( 5 characters) is the set of long\nstrings:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# print_set (SS.diff s s2)\ncommunity\nmanager\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that the Set module provides a purely functional data structure:\nremoving an element from a set does not alter that set but, rather,\nreturns a new set that is very similar to (and shares much of its\ninternals with) the original set.\u003c/p\u003e\n"},{"title":"Hashtables","slug":"hashtables","description":"Discover efficient and mutable lookup tables with OCaml's Hashtbl module\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"stdlib","tl":0},"users":{"hd":"Intermediate","tl":{"hd":"Advanced","tl":0}},"body_md":"\n## Module Hashtbl\n\nThe Hashtbl module implements an efficient, mutable lookup table. To\ncreate a hash table we could write:\n\n```ocaml\n# let my_hash = Hashtbl.create 123456\nval my_hash : ('_weak1, '_weak2) Hashtbl.t = \u003cabstr\u003e\n```\nThe 123456 is the initial size of the hashtbl. This initial number is\njust your best guess as to the amount of data that you will be putting\ninto the hash table. The hash table can grow if you under-estimate the\nsize so don't worry about it too much. The type of my_hash is:\n\n```ocaml\n# my_hash\n- : ('_weak1, '_weak2) Hashtbl.t = \u003cabstr\u003e\n```\n\nThe `'_weak1` and `'_weak2` correspond to the key and value types, respectively.\nThere are no concrete types (e.g., `int` or `float * string`) filled in in\nthose slots because the type of the key and value are not yet\ndetermined. The underscore indicates that the key and data types, once\nchosen, will be fixed. In other words, you can't sometimes use a given\nhashtable with ints for keys, and then later use a string as a key in\nthat same hashtable.\n\nLets add some data to `my_hash`. Lets say I am working on a cross word\nsolving program and I want to find all words that start with a certain\nletter. First I need to enter the data into `my_hash`.\n\nNote that a hashtable is modified by in-place updates, so, unlike a map,\nanother hash table is _not_ created every time you change the table. Thus,\nthe code `let my_hash = Hashtbl.add my_hash ...` wouldn't make any\nsense. Instead, we would write something like this:\n\n```ocaml\n# Hashtbl.add my_hash \"h\" \"hello\";\n  Hashtbl.add my_hash \"h\" \"hi\";\n  Hashtbl.add my_hash \"h\" \"hug\";\n  Hashtbl.add my_hash \"h\" \"hard\";\n  Hashtbl.add my_hash \"w\" \"wimp\";\n  Hashtbl.add my_hash \"w\" \"world\";\n  Hashtbl.add my_hash \"w\" \"wine\"\n- : unit = ()\n```\n\nIf we want to find one element in `my_hash` that has an `\"h\"` in it then we\nwould write: \n\n```ocaml\n# Hashtbl.find my_hash \"h\"\n- : string = \"hard\"\n```\n\nNotice how it returns just one element? That element\nwas the last one entered in with the value of `\"h\"`.\n\nWhat we probably want is all the elements that start with `\"h\"`. To do\nthis we want to *find all* of them. What better name for this than\n`find_all`?\n\n```ocaml\n# Hashtbl.find_all my_hash \"h\"\n- : string list = [\"hard\"; \"hug\"; \"hi\"; \"hello\"]\n```\n\nreturns `[\"hard\"; \"hug\"; \"hi\"; \"hello\"]`.\n\nIf you remove a key, its previous value becomes again the default one\nassociated to the key.\n\n```ocaml\n# Hashtbl.remove my_hash \"h\";;\n- : unit = ()\n# Hashtbl.find my_hash \"h\";;\n- : string = \"hug\"\n```\n\nThis behavior is interesting for the above example or when, say, the\nkeys represent variables that can be temporarily masked by a local\nvariables of the same name.\n\nIn other contexts, one may prefer new values to *replace* the previous\nones.  In this case, one uses `Hashtbl.replace`:\n\n```ocaml\n# Hashtbl.replace my_hash \"t\" \"try\";\n  Hashtbl.replace my_hash \"t\" \"test\";\n  Hashtbl.find_all my_hash \"t\"\n- : string list = [\"test\"]\n\n# Hashtbl.remove my_hash \"t\";\n  Hashtbl.find my_hash \"t\"\nException: Not_found.\n```\n\nTo find out whether there is an\nentry in `my_hash` for a letter we would do:\n\n```ocaml\n# Hashtbl.mem my_hash \"h\"\n- : bool = true\n```\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#module-hashtbl\"\u003eModule Hashtbl\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"module-hashtbl\"\u003eModule Hashtbl\u003c/h2\u003e\n\u003cp\u003eThe Hashtbl module implements an efficient, mutable lookup table. To\ncreate a hash table we could write:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let my_hash = Hashtbl.create 123456\nval my_hash : ('_weak1, '_weak2) Hashtbl.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe 123456 is the initial size of the hashtbl. This initial number is\njust your best guess as to the amount of data that you will be putting\ninto the hash table. The hash table can grow if you under-estimate the\nsize so don't worry about it too much. The type of my_hash is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# my_hash\n- : ('_weak1, '_weak2) Hashtbl.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e'_weak1\u003c/code\u003e and \u003ccode\u003e'_weak2\u003c/code\u003e correspond to the key and value types, respectively.\nThere are no concrete types (e.g., \u003ccode\u003eint\u003c/code\u003e or \u003ccode\u003efloat * string\u003c/code\u003e) filled in in\nthose slots because the type of the key and value are not yet\ndetermined. The underscore indicates that the key and data types, once\nchosen, will be fixed. In other words, you can't sometimes use a given\nhashtable with ints for keys, and then later use a string as a key in\nthat same hashtable.\u003c/p\u003e\n\u003cp\u003eLets add some data to \u003ccode\u003emy_hash\u003c/code\u003e. Lets say I am working on a cross word\nsolving program and I want to find all words that start with a certain\nletter. First I need to enter the data into \u003ccode\u003emy_hash\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNote that a hashtable is modified by in-place updates, so, unlike a map,\nanother hash table is \u003cem\u003enot\u003c/em\u003e created every time you change the table. Thus,\nthe code \u003ccode\u003elet my_hash = Hashtbl.add my_hash ...\u003c/code\u003e wouldn't make any\nsense. Instead, we would write something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Hashtbl.add my_hash \u0026quot;h\u0026quot; \u0026quot;hello\u0026quot;;\n  Hashtbl.add my_hash \u0026quot;h\u0026quot; \u0026quot;hi\u0026quot;;\n  Hashtbl.add my_hash \u0026quot;h\u0026quot; \u0026quot;hug\u0026quot;;\n  Hashtbl.add my_hash \u0026quot;h\u0026quot; \u0026quot;hard\u0026quot;;\n  Hashtbl.add my_hash \u0026quot;w\u0026quot; \u0026quot;wimp\u0026quot;;\n  Hashtbl.add my_hash \u0026quot;w\u0026quot; \u0026quot;world\u0026quot;;\n  Hashtbl.add my_hash \u0026quot;w\u0026quot; \u0026quot;wine\u0026quot;\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we want to find one element in \u003ccode\u003emy_hash\u003c/code\u003e that has an \u003ccode\u003e\u0026quot;h\u0026quot;\u003c/code\u003e in it then we\nwould write:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Hashtbl.find my_hash \u0026quot;h\u0026quot;\n- : string = \u0026quot;hard\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice how it returns just one element? That element\nwas the last one entered in with the value of \u003ccode\u003e\u0026quot;h\u0026quot;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhat we probably want is all the elements that start with \u003ccode\u003e\u0026quot;h\u0026quot;\u003c/code\u003e. To do\nthis we want to \u003cem\u003efind all\u003c/em\u003e of them. What better name for this than\n\u003ccode\u003efind_all\u003c/code\u003e?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Hashtbl.find_all my_hash \u0026quot;h\u0026quot;\n- : string list = [\u0026quot;hard\u0026quot;; \u0026quot;hug\u0026quot;; \u0026quot;hi\u0026quot;; \u0026quot;hello\u0026quot;]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ereturns \u003ccode\u003e[\u0026quot;hard\u0026quot;; \u0026quot;hug\u0026quot;; \u0026quot;hi\u0026quot;; \u0026quot;hello\u0026quot;]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf you remove a key, its previous value becomes again the default one\nassociated to the key.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Hashtbl.remove my_hash \u0026quot;h\u0026quot;;;\n- : unit = ()\n# Hashtbl.find my_hash \u0026quot;h\u0026quot;;;\n- : string = \u0026quot;hug\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis behavior is interesting for the above example or when, say, the\nkeys represent variables that can be temporarily masked by a local\nvariables of the same name.\u003c/p\u003e\n\u003cp\u003eIn other contexts, one may prefer new values to \u003cem\u003ereplace\u003c/em\u003e the previous\nones.  In this case, one uses \u003ccode\u003eHashtbl.replace\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Hashtbl.replace my_hash \u0026quot;t\u0026quot; \u0026quot;try\u0026quot;;\n  Hashtbl.replace my_hash \u0026quot;t\u0026quot; \u0026quot;test\u0026quot;;\n  Hashtbl.find_all my_hash \u0026quot;t\u0026quot;\n- : string list = [\u0026quot;test\u0026quot;]\n\n# Hashtbl.remove my_hash \u0026quot;t\u0026quot;;\n  Hashtbl.find my_hash \u0026quot;t\u0026quot;\nException: Not_found.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo find out whether there is an\nentry in \u003ccode\u003emy_hash\u003c/code\u003e for a letter we would do:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Hashtbl.mem my_hash \u0026quot;h\u0026quot;\n- : bool = true\n\u003c/code\u003e\u003c/pre\u003e\n"},{"title":"Streams","slug":"streams","description":"Streams offer an abstraction over consuming items from sequences\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"stdlib","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\nSuppose you need to process each line of a text file. One way to do this\nis to read the file in as a single large string and use something like\n`Str.split` to turn it into a list. This works when the file is small,\nbut because the entire file is loaded into memory, it does not scale\nwell when the file is large.\n\nMore commonly, the `input_line` function can be used to read one line at\na time from a channel. This typically looks like:\n\n```ocaml\nlet in_channel = open_in \"lines.txt\" in\ntry\n  while true do\n    let line = input_line in_channel in\n    (* do something with line *)\n  done\nwith End_of_file -\u003e\n  close_in in_channel\n```\n```mdx-error\nLine 6, characters 5-9:\nError: Syntax error\n```\n\nThe above code is efficient with memory, but it can be inconvenient in\nother ways. Since `input_line` only works with the `in_channel` type, it\ncannot be reused in cases where the text is already in memory. The\n`End_of_file` exception can be raised at any point during iteration, and\nit is the programmer's responsibility to ensure that the file is closed\nappropriately. In fact, if there is any other exception in the above\nexample, the file will not be closed at all. Altogether, there is a lot\ngoing on: channels, I/O, exceptions, and files.\n\nStreams offer an abstraction over one part of this process: reading\nitems from a sequence. They don't assume anything about files or\nchannels, and they replace the `End_of_file` exception with a more\nstructured approach to dealing with the end of input. Here is a function\nthat builds a stream of lines from an input channel:\n\n```ocaml\n# let line_stream_of_channel channel =\n  Stream.from\n    (fun _ -\u003e\n       try Some (input_line channel) with End_of_file -\u003e None)\nval line_stream_of_channel : in_channel -\u003e string Stream.t = \u003cfun\u003e\n```\nThe \"Stream.from\" function builds a stream from a callback function.\nThis function is passed the current stream count (starting with 0) as an\nargument and is expected to return an `'a option`. If the option has a\nvalue (`Some x`), that value will be the next item in the stream. If it\nhas no value (`None`), this indicates that the stream is empty and no\nfurther reads will be attempted. Since the option is polymorphic,\n`Stream.from` can construct streams of any type. These streams have a\ntype of `'a Stream.t`.\n\nWith this simple function, we can now easily construct line streams from\nany input channel:\n\n```ocaml\n# let in_channel = open_in \"019_streams.md\"\nval in_channel : in_channel = \u003cabstr\u003e\n# let lines = line_stream_of_channel in_channel\nval lines : string Stream.t = \u003cabstr\u003e\n```\n\nThis variable `lines` is a stream of strings, one string per line. We\ncan now begin reading lines from it by passing it to `Stream.next`:\n\n```ocaml\n# Stream.next lines\n- : string = \"---\"\n# Stream.next lines\n- : string = \"title: Streams\"\n# Stream.next lines\n- : string = \"description: \u003e\"\n# Stream.next lines\n- : string =\n\"  Streams offer an abstraction over consuming items from sequences\"\n# while true do ignore(Stream.next lines) done\nException: Stdlib.Stream.Failure.\n```\n\nAs you can see, `Stream.next` either returns the next item in the stream\nor raises a `Stream.Failure` exception indicating that the stream is\nempty. Likewise, with a little help from the `Stream.of_list`\nconstructor and the `Str` regular expression module, we could build a\nstream of lines from a string in memory:\n\n```ocaml\n# #load \"str.cma\"\n# let line_stream_of_string string =\n  Stream.of_list (Str.split (Str.regexp \"\\n\") string)\nval line_stream_of_string : string -\u003e string Stream.t = \u003cfun\u003e\n```\nand these streams could be used exactly the same way:\n\n```ocaml\n# let lines = line_stream_of_string \"hello\\nstream\\nworld\"\nval lines : string Stream.t = \u003cabstr\u003e\n# Stream.next lines\n- : string = \"hello\"\n# Stream.next lines\n- : string = \"stream\"\n# Stream.next lines\n- : string = \"world\"\n# Stream.next lines\nException: Stdlib.Stream.Failure.\n```\n\nSince both cases raise `Stream.Failure` on an empty stream, there is no\nneed to worry about catching `End_of_file` in the case of file I/O. This\nunified interface makes it much easier to write functions that can\nreceive data from multiple sources.\n\nThe `Stream.iter` function automates the common task of performing an\noperation for each item. With it, we can rewrite the original example as\nfollows:\n\n```ocaml\nlet in_channel = open_in \"019_streams.md\" in\ntry\n  Stream.iter\n    (fun line -\u003e\n       (* do something with line *)\n       print_endline line)\n    (line_stream_of_channel in_channel);\n  close_in in_channel\nwith e -\u003e\n  close_in in_channel;\n  raise e\n```\n\nNote how much easier it is to handle I/O exceptions properly, since we\ncan deal with them independently from the end-of-file condition. This\nseparation of concerns allows us to decompose this into simpler and more\nreusable functions:\n\n```ocaml\n# let process_line line =\n  print_endline line\nval process_line : string -\u003e unit = \u003cfun\u003e\n\n# let process_lines lines =\n  Stream.iter process_line lines\nval process_lines : string Stream.t -\u003e unit = \u003cfun\u003e\n\n# let process_file filename =\n  let in_channel = open_in filename in\n  try\n    process_lines (line_stream_of_channel in_channel);\n    close_in in_channel\n  with e -\u003e\n    close_in in_channel;\n    raise e\nval process_file : string -\u003e unit = \u003cfun\u003e\n\n# let process_string string =\n  process_lines (line_stream_of_string string)\nval process_string : string -\u003e unit = \u003cfun\u003e\n```\n\n## Constructing streams\nIn the above examples, we saw two methods for constructing streams:\n\n* Stream.from, which builds a stream from a callback function\n* Stream.of_list, which builds a stream from a list in memory\n\nThe `Stream` module provides a few other stream builders:\n\n* Stream.of_string, which builds a character stream from a string\n* Stream.of_channel, which builds a character stream from a channel\n\n`Stream.from` is the most general, and it can be used to produce streams\nof any type. It is not limited to I/O and can even produce infinite\nsequences. Here are a few simple stream builders defined with\n`Stream.from`:\n\n```ocaml\n# let empty_stream () = Stream.from (fun _ -\u003e None)\nval empty_stream : unit -\u003e 'a Stream.t = \u003cfun\u003e\n# let const_stream k = Stream.from (fun _ -\u003e Some k)\nval const_stream : 'a -\u003e 'a Stream.t = \u003cfun\u003e\n# let count_stream i = Stream.from (fun j -\u003e Some (i + j))\nval count_stream : int -\u003e int Stream.t = \u003cfun\u003e\n```\n\n## Deconstructing streams\nWe already saw the `Stream.next` function, which retrieves a single item\nfrom a stream. There is another way to work with streams that is often\npreferable: `Stream.peek` and `Stream.junk`. When used together, these\nfunctions allow you to see what the next item would be. This feature,\nknown as \"look ahead\", is very useful when writing parsers. Even if you\ndon't need to look ahead, the peek/junk protocol may be nicer to work\nwith because it uses options instead of exceptions:\n\n```ocaml\n# let lines = line_stream_of_string \"hello\\nworld\"\nval lines : string Stream.t = \u003cabstr\u003e\n# Stream.peek lines\n- : string option = Some \"hello\"\n# Stream.peek lines\n- : string option = Some \"hello\"\n# Stream.junk lines\n- : unit = ()\n# Stream.peek lines\n- : string option = Some \"world\"\n# Stream.junk lines\n- : unit = ()\n# Stream.peek lines\n- : string option = None\n```\n\nAs you can see, it is necessary to call `Stream.junk` to advance to the\nnext item. `Stream.peek` will always give you either the next item or\n`None`, and it will never fail. Likewise, `Stream.junk` always succeeds\n(even if the stream is empty).\n\n## A more complex `Stream.from` example\nHere is a function that converts a line stream into a paragraph stream.\nAs such, it is both a stream consumer and a stream producer.\n\n```ocaml\n# let paragraphs lines =\n  let rec next para_lines i =\n    match Stream.peek lines, para_lines with\n    | None, [] -\u003e None\n    | Some \"\", [] -\u003e\n        Stream.junk lines;\n        next para_lines i\n    | Some \"\", _ | None, _ -\u003e\n        Some (String.concat \"\\n\" (List.rev para_lines))\n    | Some line, _ -\u003e\n        Stream.junk lines;\n        next (line :: para_lines) i in\n  Stream.from (next [])\nval paragraphs : string Stream.t -\u003e string Stream.t = \u003cfun\u003e\n```\n\nThis function uses an extra parameter to `next` (the `Stream.from`\ncallback) called `para_lines` in order to collect the lines for each\nparagraph. Paragraphs are delimited by any number of blank lines.\n\nEach time `next` is called, a `match` expression tests two values: the\nnext line in the stream, and the contents of `para_lines`. Four cases\nare handled:\n\n1. If the end of the stream is reached and no lines have been\n collected, the paragraph stream ends as well.\n1. If the next line is blank and no lines have been collected, the\n blank is ignored and `next` is called recursively to keep looking\n for a non-blank line.\n1. If a blank line or end of stream is reached and lines **have** been\n collected, the paragraph is returned by concatenating `para_lines`\n to a single string.\n1. Finally, if a non-blank line has been reached, the line is collected\n by recursively calling `para_lines`.\n\nHappily, we can rely on the OCaml compiler's exhaustiveness checking to\nensure that we are handling all possible cases.\n\nWith this new tool, we can now work just as easily with paragraphs as we\ncould before with lines:\n\n```ocaml\n(* Print each paragraph, followed by a separator. *)\nlet lines = line_stream_of_channel in_channel in\nStream.iter\n  (fun para -\u003e\n     print_endline para;\n     print_endline \"--\")\n  (paragraphs lines)\n```\nFunctions like `paragraphs` that produce and consume streams can be\ncomposed together in a manner very similar to UNIX pipes and filters.\n\n## Stream combinators\nJust like lists and arrays, common iteration patterns such as `map`,\n`filter`, and `fold` can be very useful. The `Stream` module does not\nprovide such functions, but they can be built easily using\n`Stream.from`:\n\n```ocaml\n# let stream_map f stream =\n  let rec next i =\n    try Some (f (Stream.next stream))\n    with Stream.Failure -\u003e None in\n  Stream.from next\nval stream_map : ('a -\u003e 'b) -\u003e 'a Stream.t -\u003e 'b Stream.t = \u003cfun\u003e\n\n# let stream_filter p stream =\n  let rec next i =\n    try\n      let value = Stream.next stream in\n      if p value then Some value else next i\n    with Stream.Failure -\u003e None in\n  Stream.from next\nval stream_filter : ('a -\u003e bool) -\u003e 'a Stream.t -\u003e 'a Stream.t = \u003cfun\u003e\n\n# let stream_fold f stream init =\n  let result = ref init in\n  Stream.iter\n    (fun x -\u003e result := f x !result)\n    stream;\n  !result\nval stream_fold : ('a -\u003e 'b -\u003e 'b) -\u003e 'a Stream.t -\u003e 'b -\u003e 'b = \u003cfun\u003e\n```\nFor example, here is a stream of leap years starting with 2000:\n\n```ocaml\n# let is_leap year =\n  year mod 4 = 0 \u0026\u0026 (year mod 100 \u003c\u003e 0 || year mod 400 = 0)\nval is_leap : int -\u003e bool = \u003cfun\u003e\n# let leap_years = stream_filter is_leap (count_stream 2000)\nval leap_years : int Stream.t = \u003cabstr\u003e\n```\n\nWe can use the `Stream.npeek` function to look ahead by more than one\nitem. In this case, we'll peek at the next 30 items to make sure that\nthe year 2100 is not a leap year (since it's divisible by 100 but not\n400!):\n\n```ocaml\n# Stream.npeek 30 leap_years\n- : int list =\n[2000; 2004; 2008; 2012; 2016; 2020; 2024; 2028; 2032; 2036; 2040; 2044;\n 2048; 2052; 2056; 2060; 2064; 2068; 2072; 2076; 2080; 2084; 2088; 2092;\n 2096; 2104; 2108; 2112; 2116; 2120]\n```\n\nNote that we must be careful not to use `Stream.iter` on an infinite\nstream like `leap_years`. This applies to `stream_fold`, as well as any\nfunction that attempts to consume the entire stream.\n\n```ocaml\n# stream_fold (+) (Stream.of_list [1; 2; 3]) 0\n- : int = 6\n```\n\n`stream_fold (+) (count_stream 0) 0` runs forever.\n\n## Other useful stream builders\nThe previously defined `const_stream` function builds a stream that\nrepeats a single value. It is also useful to build a stream that repeats\na sequence of values. The following function does just that:\n\n```ocaml\n# let cycle items =\n  let buf = ref [] in\n  let rec next i =\n    if !buf = [] then buf := items;\n    match !buf with\n      | h :: t -\u003e (buf := t; Some h)\n      | [] -\u003e None in\n  Stream.from next\nval cycle : 'a list -\u003e 'a Stream.t = \u003cfun\u003e\n```\n\nOne common task that can benefit from this kind of stream is the\ngeneration of alternating background colors for HTML. By using `cycle`\nwith `stream_combine`, explained in the next section, an infinite stream\nof background colors can be combined with a finite stream of data to\nproduce a sequence of HTML blocks:\n\n```ocaml\n# let stream_combine stream1 stream2 =\n  let rec next i =\n    try Some (Stream.next stream1, Stream.next stream2)\n    with Stream.Failure -\u003e None in\n  Stream.from next\nval stream_combine : 'a Stream.t -\u003e 'b Stream.t -\u003e ('a * 'b) Stream.t = \u003cfun\u003e\n# Stream.iter print_endline\n  (stream_map\n     (fun (bg, s) -\u003e\n        Printf.sprintf \"\u003cdiv style='background: %s'\u003e%s\u003c/div\u003e\" bg s)\n     (stream_combine\n        (cycle [\"#eee\"; \"#fff\"])\n        (Stream.of_list [\"hello\"; \"html\"; \"world\"])))\n\u003cdiv style='background: #eee'\u003ehello\u003c/div\u003e\n\u003cdiv style='background: #fff'\u003ehtml\u003c/div\u003e\n\u003cdiv style='background: #eee'\u003eworld\u003c/div\u003e\n- : unit = ()\n```\nHere is a simple `range` function that produces a sequence of integers:\n\n```ocaml\n# let range ?(start=0) ?(stop=0) ?(step=1) () =\n  let in_range = if step \u003c 0 then (\u003e) else (\u003c) in\n  let current = ref start in\n  let rec next i =\n    if in_range !current stop\n    then let result = !current in (current := !current + step;\n                                   Some result)\n    else None in\n  Stream.from next\nval range : ?start:int -\u003e ?stop:int -\u003e ?step:int -\u003e unit -\u003e int Stream.t =\n  \u003cfun\u003e\n```\n\nThis works just like Python's `xrange` built-in function, providing an\neasy way to produce an assortment of lazy integer sequences by\nspecifying combinations of `start`, `stop`, or `step` values:\n\n```ocaml\n# Stream.npeek 10 (range ~start:5 ~stop:10 ())\n- : int list = [5; 6; 7; 8; 9]\n# Stream.npeek 10 (range ~stop:10 ~step:2 ())\n- : int list = [0; 2; 4; 6; 8]\n# Stream.npeek 10 (range ~start:10 ~step:(-1) ())\n- : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]\n# Stream.npeek 10 (range ~start:10 ~stop:5 ~step:(-1) ())\n- : int list = [10; 9; 8; 7; 6]\n```\n\n## Combining streams\nThere are several ways to combine streams. One is to produce a stream of\nstreams and then concatenate them into a single stream. The following\nfunction works just like `List.concat`, but instead of turning a list of\nlists into a list, it turns a stream of streams into a stream:\n\n```ocaml\n# let stream_concat streams =\n  let current_stream = ref None in\n  let rec next i =\n    try\n      let stream =\n        match !current_stream with\n        | Some stream -\u003e stream\n        | None -\u003e\n           let stream = Stream.next streams in\n           current_stream := Some stream;\n           stream in\n      try Some (Stream.next stream)\n      with Stream.Failure -\u003e (current_stream := None; next i)\n    with Stream.Failure -\u003e None in\n  Stream.from next\nval stream_concat : 'a Stream.t Stream.t -\u003e 'a Stream.t = \u003cfun\u003e\n```\nHere is a sequence of ranges which are themselves derived from a range,\nconcatenated with `stream_concat` to produce a flattened `int Stream.t`.\n\n```ocaml\n# Stream.npeek 10\n  (stream_concat\n     (stream_map\n        (fun i -\u003e range ~stop:i ())\n        (range ~stop:5 ())))\n- : int list = [0; 0; 1; 0; 1; 2; 0; 1; 2; 3]\n```\n\nAnother way to combine streams is to iterate through them in a pairwise\nfashion:\n\n```ocaml\n# let stream_combine stream1 stream2 =\n  let rec next i =\n    try Some (Stream.next stream1, Stream.next stream2)\n    with Stream.Failure -\u003e None in\n  Stream.from next\nval stream_combine : 'a Stream.t -\u003e 'b Stream.t -\u003e ('a * 'b) Stream.t = \u003cfun\u003e\n```\nThis is useful, for instance, if you have a stream of keys and a stream\nof corresponding values. Iterating through key value pairs is then as\nsimple as:\n\n```ocaml\nStream.iter\n  (fun (key, value) -\u003e\n     (* do something with 'key' and 'value' *)\n     ())\n  (stream_combine key_stream value_stream)\n```\n```mdx-error\nLine 5, characters 21-31:\nError: Unbound value key_stream\n```\nSince `stream_combine` stops as soon as either of its input streams runs\nout, it can be used to combine an infinite stream with a finite one.\nThis provides a neat way to add indexes to a sequence:\n\n```ocaml\n# let items = [\"this\"; \"is\"; \"a\"; \"test\"]\nval items : string list = [\"this\"; \"is\"; \"a\"; \"test\"]\n# Stream.iter\n  (fun (index, value) -\u003e\n     Printf.printf \"%d. %s\\n%!\" index value)\n  (stream_combine (count_stream 1) (Stream.of_list items))\n1. this\n2. is\n3. a\n4. test\n- : unit = ()\n```\n\n## Copying streams\nStreams are destructive; once you discard an item in a stream, it is no\nlonger available unless you save a copy somewhere. What if you want to\nuse the same stream more than once? One way is to create a \"tee\". The\nfollowing function creates two output streams from one input stream,\nintelligently queueing unseen values until they have been produced by\nboth streams:\n\n```ocaml\n# let stream_tee stream =\n  let next self other i =\n    try\n      if Queue.is_empty self\n      then\n        let value = Stream.next stream in\n        Queue.add value other;\n        Some value\n      else\n        Some (Queue.take self)\n    with Stream.Failure -\u003e None in\n  let q1 = Queue.create () in\n  let q2 = Queue.create () in\n  (Stream.from (next q1 q2), Stream.from (next q2 q1))\nval stream_tee : 'a Stream.t -\u003e 'a Stream.t * 'a Stream.t = \u003cfun\u003e\n```\nHere is an example of a stream tee in action:\n\n```ocaml\n# let letters = Stream.of_list ['a'; 'b'; 'c'; 'd'; 'e']\nval letters : char Stream.t = \u003cabstr\u003e\n# let s1, s2 = stream_tee letters\nval s1 : char Stream.t = \u003cabstr\u003e\nval s2 : char Stream.t = \u003cabstr\u003e\n# Stream.next s1\n- : char = 'a'\n# Stream.next s1\n- : char = 'b'\n# Stream.next s2\n- : char = 'a'\n# Stream.next s1\n- : char = 'c'\n# Stream.next s2\n- : char = 'b'\n# Stream.next s2\n- : char = 'c'\n```\n\nAgain, since streams are destructive, you probably want to leave the\noriginal stream alone or you will lose items from the copied streams:\n\n```ocaml\n# Stream.next letters\n- : char = 'd'\n# Stream.next s1\n- : char = 'e'\n# Stream.next s2\n- : char = 'e'\n```\n\n## Converting streams\nHere are a few functions for converting between streams and lists,\narrays, and hash tables. These probably belong in the standard library,\nbut they are simple to define anyhow. Again, beware of infinite streams,\nwhich will cause these functions to hang.\n\n```ocaml\n# let stream_of_list = Stream.of_list\nval stream_of_list : 'a list -\u003e 'a Stream.t = \u003cfun\u003e\n# let list_of_stream stream =\n  let result = ref [] in\n  Stream.iter (fun value -\u003e result := value :: !result) stream;\n  List.rev !result\nval list_of_stream : 'a Stream.t -\u003e 'a list = \u003cfun\u003e\n# let stream_of_array array =\n  Stream.of_list (Array.to_list array)\nval stream_of_array : 'a array -\u003e 'a Stream.t = \u003cfun\u003e\n# let array_of_stream stream =\n  Array.of_list (list_of_stream stream)\nval array_of_stream : 'a Stream.t -\u003e 'a array = \u003cfun\u003e\n# let stream_of_hash hash =\n  let result = ref [] in\n  Hashtbl.iter\n    (fun key value -\u003e result := (key, value) :: !result)\n    hash;\n  Stream.of_list !result\nval stream_of_hash : ('a, 'b) Hashtbl.t -\u003e ('a * 'b) Stream.t = \u003cfun\u003e\n# let hash_of_stream stream =\n  let result = Hashtbl.create 0 in\n  Stream.iter\n    (fun (key, value) -\u003e Hashtbl.replace result key value)\n    stream;\n  result\nval hash_of_stream : ('a * 'b) Stream.t -\u003e ('a, 'b) Hashtbl.t = \u003cfun\u003e\n```\n\nWhat if you want to convert arbitrary data types to streams? Well, if the\ndata type defines an `iter` function, and you don't mind using threads,\nyou can use a producer-consumer arrangement to invert control:\n\n```ocaml\n# #directory \"+threads\";;\n# #load \"threads.cma\";;\n# let elements iter coll =\n  let channel = Event.new_channel () in\n  let producer () =\n    let () =\n      iter (fun x -\u003e Event.sync (Event.send channel (Some x))) coll in\n    Event.sync (Event.send channel None) in\n  let consumer i =\n    Event.sync (Event.receive channel) in\n  ignore (Thread.create producer ());\n  Stream.from consumer\nval elements : (('a -\u003e unit) -\u003e 'b -\u003e unit) -\u003e 'b -\u003e 'a Stream.t = \u003cfun\u003e\n```\n\nNow it is possible to build a stream from an `iter` function and a\ncorresponding value:\n\n```ocaml\n# module StringSet = Set.Make(String)\nmodule StringSet :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -\u003e bool\n    val mem : elt -\u003e t -\u003e bool\n    val add : elt -\u003e t -\u003e t\n    val singleton : elt -\u003e t\n    val remove : elt -\u003e t -\u003e t\n    val union : t -\u003e t -\u003e t\n    val inter : t -\u003e t -\u003e t\n    val disjoint : t -\u003e t -\u003e bool\n    val diff : t -\u003e t -\u003e t\n    val compare : t -\u003e t -\u003e int\n    val equal : t -\u003e t -\u003e bool\n    val subset : t -\u003e t -\u003e bool\n    val iter : (elt -\u003e unit) -\u003e t -\u003e unit\n    val map : (elt -\u003e elt) -\u003e t -\u003e t\n    val fold : (elt -\u003e 'a -\u003e 'a) -\u003e t -\u003e 'a -\u003e 'a\n    val for_all : (elt -\u003e bool) -\u003e t -\u003e bool\n    val exists : (elt -\u003e bool) -\u003e t -\u003e bool\n    val filter : (elt -\u003e bool) -\u003e t -\u003e t\n    val partition : (elt -\u003e bool) -\u003e t -\u003e t * t\n    val cardinal : t -\u003e int\n    val elements : t -\u003e elt list\n    val min_elt : t -\u003e elt\n    val min_elt_opt : t -\u003e elt option\n    val max_elt : t -\u003e elt\n    val max_elt_opt : t -\u003e elt option\n    val choose : t -\u003e elt\n    val choose_opt : t -\u003e elt option\n    val split : elt -\u003e t -\u003e t * bool * t\n    val find : elt -\u003e t -\u003e elt\n    val find_opt : elt -\u003e t -\u003e elt option\n    val find_first : (elt -\u003e bool) -\u003e t -\u003e elt\n    val find_first_opt : (elt -\u003e bool) -\u003e t -\u003e elt option\n    val find_last : (elt -\u003e bool) -\u003e t -\u003e elt\n    val find_last_opt : (elt -\u003e bool) -\u003e t -\u003e elt option\n    val of_list : elt list -\u003e t\n    val to_seq_from : elt -\u003e t -\u003e elt Seq.t\n    val to_seq : t -\u003e elt Seq.t\n    val add_seq : elt Seq.t -\u003e t -\u003e t\n    val of_seq : elt Seq.t -\u003e t\n  end\n# let set = StringSet.empty\nval set : StringSet.t = \u003cabstr\u003e\n# let set = StringSet.add \"here\" set\nval set : StringSet.t = \u003cabstr\u003e\n# let set = StringSet.add \"are\" set\nval set : StringSet.t = \u003cabstr\u003e\n# let set = StringSet.add \"some\" set\nval set : StringSet.t = \u003cabstr\u003e\n# let set = StringSet.add \"values\" set\nval set : StringSet.t = \u003cabstr\u003e\n# let stream = elements StringSet.iter set\nval stream : string Stream.t = \u003cabstr\u003e\n# Stream.iter print_endline stream\nare\nhere\nsome\nvalues\n- : unit = ()\n```\n\nSome data types, like Hashtbl and Map, provide an `iter` function that\niterates through key-value pairs. Here's a function for those, too:\n\n```ocaml\n# let items iter coll =\n  let channel = Event.new_channel () in\n  let producer () =\n    let () =\n      iter (fun k v -\u003e\n              Event.sync (Event.send channel (Some (k, v)))) coll in\n    Event.sync (Event.send channel None) in\n  let consumer i =\n    Event.sync (Event.receive channel) in\n  ignore (Thread.create producer ());\n  Stream.from consumer\nval items : (('a -\u003e 'b -\u003e unit) -\u003e 'c -\u003e unit) -\u003e 'c -\u003e ('a * 'b) Stream.t =\n  \u003cfun\u003e\n```\n\nIf we want just the keys, or just the values, it is simple to transform\nthe output of `items` using `stream_map`:\n\n```ocaml\n# let keys iter coll = stream_map (fun (k, v) -\u003e k) (items iter coll)\nval keys : (('a -\u003e 'b -\u003e unit) -\u003e 'c -\u003e unit) -\u003e 'c -\u003e 'a Stream.t = \u003cfun\u003e\n# let values iter coll = stream_map (fun (k, v) -\u003e v) (items iter coll)\nval values : (('a -\u003e 'b -\u003e unit) -\u003e 'c -\u003e unit) -\u003e 'c -\u003e 'b Stream.t = \u003cfun\u003e\n```\n\nKeep in mind that these techniques spawn producer threads which carry a\nfew risks: they only terminate when they have finished iterating, and\nany change to the original data structure while iterating may produce\nunexpected results.\n\n## Other built-in Stream functions\nThere are a few other documented methods in the `Stream` module:\n\n* Stream.empty, which raises `Stream.Failure` unless a stream is empty\n* Stream.count, which returns the stream count (number of discarded\n elements)\n\nIn addition, there are a few undocumented functions: `iapp`, `icons`,\n`ising`, `lapp`, `lcons`, `lsing`, `sempty`, `slazy`, and `dump`. They\nare visible in the interface with the caveat: \"For system use only, not\nfor the casual user\".\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#constructing-streams\"\u003eConstructing streams\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#deconstructing-streams\"\u003eDeconstructing streams\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#a-more-complex-streamfrom-example\"\u003eA more complex \u003ccode\u003eStream.from\u003c/code\u003e example\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#stream-combinators\"\u003eStream combinators\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#other-useful-stream-builders\"\u003eOther useful stream builders\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#combining-streams\"\u003eCombining streams\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#copying-streams\"\u003eCopying streams\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#converting-streams\"\u003eConverting streams\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#other-built-in-stream-functions\"\u003eOther built-in Stream functions\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eSuppose you need to process each line of a text file. One way to do this\nis to read the file in as a single large string and use something like\n\u003ccode\u003eStr.split\u003c/code\u003e to turn it into a list. This works when the file is small,\nbut because the entire file is loaded into memory, it does not scale\nwell when the file is large.\u003c/p\u003e\n\u003cp\u003eMore commonly, the \u003ccode\u003einput_line\u003c/code\u003e function can be used to read one line at\na time from a channel. This typically looks like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet in_channel = open_in \u0026quot;lines.txt\u0026quot; in\ntry\n  while true do\n    let line = input_line in_channel in\n    (* do something with line *)\n  done\nwith End_of_file -\u0026gt;\n  close_in in_channel\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-mdx-error\"\u003eLine 6, characters 5-9:\nError: Syntax error\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe above code is efficient with memory, but it can be inconvenient in\nother ways. Since \u003ccode\u003einput_line\u003c/code\u003e only works with the \u003ccode\u003ein_channel\u003c/code\u003e type, it\ncannot be reused in cases where the text is already in memory. The\n\u003ccode\u003eEnd_of_file\u003c/code\u003e exception can be raised at any point during iteration, and\nit is the programmer's responsibility to ensure that the file is closed\nappropriately. In fact, if there is any other exception in the above\nexample, the file will not be closed at all. Altogether, there is a lot\ngoing on: channels, I/O, exceptions, and files.\u003c/p\u003e\n\u003cp\u003eStreams offer an abstraction over one part of this process: reading\nitems from a sequence. They don't assume anything about files or\nchannels, and they replace the \u003ccode\u003eEnd_of_file\u003c/code\u003e exception with a more\nstructured approach to dealing with the end of input. Here is a function\nthat builds a stream of lines from an input channel:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let line_stream_of_channel channel =\n  Stream.from\n    (fun _ -\u0026gt;\n       try Some (input_line channel) with End_of_file -\u0026gt; None)\nval line_stream_of_channel : in_channel -\u0026gt; string Stream.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u0026quot;Stream.from\u0026quot; function builds a stream from a callback function.\nThis function is passed the current stream count (starting with 0) as an\nargument and is expected to return an \u003ccode\u003e'a option\u003c/code\u003e. If the option has a\nvalue (\u003ccode\u003eSome x\u003c/code\u003e), that value will be the next item in the stream. If it\nhas no value (\u003ccode\u003eNone\u003c/code\u003e), this indicates that the stream is empty and no\nfurther reads will be attempted. Since the option is polymorphic,\n\u003ccode\u003eStream.from\u003c/code\u003e can construct streams of any type. These streams have a\ntype of \u003ccode\u003e'a Stream.t\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWith this simple function, we can now easily construct line streams from\nany input channel:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let in_channel = open_in \u0026quot;019_streams.md\u0026quot;\nval in_channel : in_channel = \u0026lt;abstr\u0026gt;\n# let lines = line_stream_of_channel in_channel\nval lines : string Stream.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis variable \u003ccode\u003elines\u003c/code\u003e is a stream of strings, one string per line. We\ncan now begin reading lines from it by passing it to \u003ccode\u003eStream.next\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Stream.next lines\n- : string = \u0026quot;---\u0026quot;\n# Stream.next lines\n- : string = \u0026quot;title: Streams\u0026quot;\n# Stream.next lines\n- : string = \u0026quot;description: \u0026gt;\u0026quot;\n# Stream.next lines\n- : string =\n\u0026quot;  Streams offer an abstraction over consuming items from sequences\u0026quot;\n# while true do ignore(Stream.next lines) done\nException: Stdlib.Stream.Failure.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, \u003ccode\u003eStream.next\u003c/code\u003e either returns the next item in the stream\nor raises a \u003ccode\u003eStream.Failure\u003c/code\u003e exception indicating that the stream is\nempty. Likewise, with a little help from the \u003ccode\u003eStream.of_list\u003c/code\u003e\nconstructor and the \u003ccode\u003eStr\u003c/code\u003e regular expression module, we could build a\nstream of lines from a string in memory:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# #load \u0026quot;str.cma\u0026quot;\n# let line_stream_of_string string =\n  Stream.of_list (Str.split (Str.regexp \u0026quot;\\n\u0026quot;) string)\nval line_stream_of_string : string -\u0026gt; string Stream.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand these streams could be used exactly the same way:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let lines = line_stream_of_string \u0026quot;hello\\nstream\\nworld\u0026quot;\nval lines : string Stream.t = \u0026lt;abstr\u0026gt;\n# Stream.next lines\n- : string = \u0026quot;hello\u0026quot;\n# Stream.next lines\n- : string = \u0026quot;stream\u0026quot;\n# Stream.next lines\n- : string = \u0026quot;world\u0026quot;\n# Stream.next lines\nException: Stdlib.Stream.Failure.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince both cases raise \u003ccode\u003eStream.Failure\u003c/code\u003e on an empty stream, there is no\nneed to worry about catching \u003ccode\u003eEnd_of_file\u003c/code\u003e in the case of file I/O. This\nunified interface makes it much easier to write functions that can\nreceive data from multiple sources.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eStream.iter\u003c/code\u003e function automates the common task of performing an\noperation for each item. With it, we can rewrite the original example as\nfollows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet in_channel = open_in \u0026quot;019_streams.md\u0026quot; in\ntry\n  Stream.iter\n    (fun line -\u0026gt;\n       (* do something with line *)\n       print_endline line)\n    (line_stream_of_channel in_channel);\n  close_in in_channel\nwith e -\u0026gt;\n  close_in in_channel;\n  raise e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote how much easier it is to handle I/O exceptions properly, since we\ncan deal with them independently from the end-of-file condition. This\nseparation of concerns allows us to decompose this into simpler and more\nreusable functions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let process_line line =\n  print_endline line\nval process_line : string -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\n# let process_lines lines =\n  Stream.iter process_line lines\nval process_lines : string Stream.t -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\n# let process_file filename =\n  let in_channel = open_in filename in\n  try\n    process_lines (line_stream_of_channel in_channel);\n    close_in in_channel\n  with e -\u0026gt;\n    close_in in_channel;\n    raise e\nval process_file : string -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\n# let process_string string =\n  process_lines (line_stream_of_string string)\nval process_string : string -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"constructing-streams\"\u003eConstructing streams\u003c/h2\u003e\n\u003cp\u003eIn the above examples, we saw two methods for constructing streams:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStream.from, which builds a stream from a callback function\n\u003c/li\u003e\n\u003cli\u003eStream.of_list, which builds a stream from a list in memory\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe \u003ccode\u003eStream\u003c/code\u003e module provides a few other stream builders:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStream.of_string, which builds a character stream from a string\n\u003c/li\u003e\n\u003cli\u003eStream.of_channel, which builds a character stream from a channel\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eStream.from\u003c/code\u003e is the most general, and it can be used to produce streams\nof any type. It is not limited to I/O and can even produce infinite\nsequences. Here are a few simple stream builders defined with\n\u003ccode\u003eStream.from\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let empty_stream () = Stream.from (fun _ -\u0026gt; None)\nval empty_stream : unit -\u0026gt; 'a Stream.t = \u0026lt;fun\u0026gt;\n# let const_stream k = Stream.from (fun _ -\u0026gt; Some k)\nval const_stream : 'a -\u0026gt; 'a Stream.t = \u0026lt;fun\u0026gt;\n# let count_stream i = Stream.from (fun j -\u0026gt; Some (i + j))\nval count_stream : int -\u0026gt; int Stream.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"deconstructing-streams\"\u003eDeconstructing streams\u003c/h2\u003e\n\u003cp\u003eWe already saw the \u003ccode\u003eStream.next\u003c/code\u003e function, which retrieves a single item\nfrom a stream. There is another way to work with streams that is often\npreferable: \u003ccode\u003eStream.peek\u003c/code\u003e and \u003ccode\u003eStream.junk\u003c/code\u003e. When used together, these\nfunctions allow you to see what the next item would be. This feature,\nknown as \u0026quot;look ahead\u0026quot;, is very useful when writing parsers. Even if you\ndon't need to look ahead, the peek/junk protocol may be nicer to work\nwith because it uses options instead of exceptions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let lines = line_stream_of_string \u0026quot;hello\\nworld\u0026quot;\nval lines : string Stream.t = \u0026lt;abstr\u0026gt;\n# Stream.peek lines\n- : string option = Some \u0026quot;hello\u0026quot;\n# Stream.peek lines\n- : string option = Some \u0026quot;hello\u0026quot;\n# Stream.junk lines\n- : unit = ()\n# Stream.peek lines\n- : string option = Some \u0026quot;world\u0026quot;\n# Stream.junk lines\n- : unit = ()\n# Stream.peek lines\n- : string option = None\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, it is necessary to call \u003ccode\u003eStream.junk\u003c/code\u003e to advance to the\nnext item. \u003ccode\u003eStream.peek\u003c/code\u003e will always give you either the next item or\n\u003ccode\u003eNone\u003c/code\u003e, and it will never fail. Likewise, \u003ccode\u003eStream.junk\u003c/code\u003e always succeeds\n(even if the stream is empty).\u003c/p\u003e\n\u003ch2 id=\"a-more-complex-streamfrom-example\"\u003eA more complex \u003ccode\u003eStream.from\u003c/code\u003e example\u003c/h2\u003e\n\u003cp\u003eHere is a function that converts a line stream into a paragraph stream.\nAs such, it is both a stream consumer and a stream producer.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let paragraphs lines =\n  let rec next para_lines i =\n    match Stream.peek lines, para_lines with\n    | None, [] -\u0026gt; None\n    | Some \u0026quot;\u0026quot;, [] -\u0026gt;\n        Stream.junk lines;\n        next para_lines i\n    | Some \u0026quot;\u0026quot;, _ | None, _ -\u0026gt;\n        Some (String.concat \u0026quot;\\n\u0026quot; (List.rev para_lines))\n    | Some line, _ -\u0026gt;\n        Stream.junk lines;\n        next (line :: para_lines) i in\n  Stream.from (next [])\nval paragraphs : string Stream.t -\u0026gt; string Stream.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis function uses an extra parameter to \u003ccode\u003enext\u003c/code\u003e (the \u003ccode\u003eStream.from\u003c/code\u003e\ncallback) called \u003ccode\u003epara_lines\u003c/code\u003e in order to collect the lines for each\nparagraph. Paragraphs are delimited by any number of blank lines.\u003c/p\u003e\n\u003cp\u003eEach time \u003ccode\u003enext\u003c/code\u003e is called, a \u003ccode\u003ematch\u003c/code\u003e expression tests two values: the\nnext line in the stream, and the contents of \u003ccode\u003epara_lines\u003c/code\u003e. Four cases\nare handled:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eIf the end of the stream is reached and no lines have been\ncollected, the paragraph stream ends as well.\n\u003c/li\u003e\n\u003cli\u003eIf the next line is blank and no lines have been collected, the\nblank is ignored and \u003ccode\u003enext\u003c/code\u003e is called recursively to keep looking\nfor a non-blank line.\n\u003c/li\u003e\n\u003cli\u003eIf a blank line or end of stream is reached and lines \u003cstrong\u003ehave\u003c/strong\u003e been\ncollected, the paragraph is returned by concatenating \u003ccode\u003epara_lines\u003c/code\u003e\nto a single string.\n\u003c/li\u003e\n\u003cli\u003eFinally, if a non-blank line has been reached, the line is collected\nby recursively calling \u003ccode\u003epara_lines\u003c/code\u003e.\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHappily, we can rely on the OCaml compiler's exhaustiveness checking to\nensure that we are handling all possible cases.\u003c/p\u003e\n\u003cp\u003eWith this new tool, we can now work just as easily with paragraphs as we\ncould before with lines:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Print each paragraph, followed by a separator. *)\nlet lines = line_stream_of_channel in_channel in\nStream.iter\n  (fun para -\u0026gt;\n     print_endline para;\n     print_endline \u0026quot;--\u0026quot;)\n  (paragraphs lines)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFunctions like \u003ccode\u003eparagraphs\u003c/code\u003e that produce and consume streams can be\ncomposed together in a manner very similar to UNIX pipes and filters.\u003c/p\u003e\n\u003ch2 id=\"stream-combinators\"\u003eStream combinators\u003c/h2\u003e\n\u003cp\u003eJust like lists and arrays, common iteration patterns such as \u003ccode\u003emap\u003c/code\u003e,\n\u003ccode\u003efilter\u003c/code\u003e, and \u003ccode\u003efold\u003c/code\u003e can be very useful. The \u003ccode\u003eStream\u003c/code\u003e module does not\nprovide such functions, but they can be built easily using\n\u003ccode\u003eStream.from\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let stream_map f stream =\n  let rec next i =\n    try Some (f (Stream.next stream))\n    with Stream.Failure -\u0026gt; None in\n  Stream.from next\nval stream_map : ('a -\u0026gt; 'b) -\u0026gt; 'a Stream.t -\u0026gt; 'b Stream.t = \u0026lt;fun\u0026gt;\n\n# let stream_filter p stream =\n  let rec next i =\n    try\n      let value = Stream.next stream in\n      if p value then Some value else next i\n    with Stream.Failure -\u0026gt; None in\n  Stream.from next\nval stream_filter : ('a -\u0026gt; bool) -\u0026gt; 'a Stream.t -\u0026gt; 'a Stream.t = \u0026lt;fun\u0026gt;\n\n# let stream_fold f stream init =\n  let result = ref init in\n  Stream.iter\n    (fun x -\u0026gt; result := f x !result)\n    stream;\n  !result\nval stream_fold : ('a -\u0026gt; 'b -\u0026gt; 'b) -\u0026gt; 'a Stream.t -\u0026gt; 'b -\u0026gt; 'b = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor example, here is a stream of leap years starting with 2000:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let is_leap year =\n  year mod 4 = 0 \u0026amp;\u0026amp; (year mod 100 \u0026lt;\u0026gt; 0 || year mod 400 = 0)\nval is_leap : int -\u0026gt; bool = \u0026lt;fun\u0026gt;\n# let leap_years = stream_filter is_leap (count_stream 2000)\nval leap_years : int Stream.t = \u0026lt;abstr\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can use the \u003ccode\u003eStream.npeek\u003c/code\u003e function to look ahead by more than one\nitem. In this case, we'll peek at the next 30 items to make sure that\nthe year 2100 is not a leap year (since it's divisible by 100 but not\n400!):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Stream.npeek 30 leap_years\n- : int list =\n[2000; 2004; 2008; 2012; 2016; 2020; 2024; 2028; 2032; 2036; 2040; 2044;\n 2048; 2052; 2056; 2060; 2064; 2068; 2072; 2076; 2080; 2084; 2088; 2092;\n 2096; 2104; 2108; 2112; 2116; 2120]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that we must be careful not to use \u003ccode\u003eStream.iter\u003c/code\u003e on an infinite\nstream like \u003ccode\u003eleap_years\u003c/code\u003e. This applies to \u003ccode\u003estream_fold\u003c/code\u003e, as well as any\nfunction that attempts to consume the entire stream.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# stream_fold (+) (Stream.of_list [1; 2; 3]) 0\n- : int = 6\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003estream_fold (+) (count_stream 0) 0\u003c/code\u003e runs forever.\u003c/p\u003e\n\u003ch2 id=\"other-useful-stream-builders\"\u003eOther useful stream builders\u003c/h2\u003e\n\u003cp\u003eThe previously defined \u003ccode\u003econst_stream\u003c/code\u003e function builds a stream that\nrepeats a single value. It is also useful to build a stream that repeats\na sequence of values. The following function does just that:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let cycle items =\n  let buf = ref [] in\n  let rec next i =\n    if !buf = [] then buf := items;\n    match !buf with\n      | h :: t -\u0026gt; (buf := t; Some h)\n      | [] -\u0026gt; None in\n  Stream.from next\nval cycle : 'a list -\u0026gt; 'a Stream.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne common task that can benefit from this kind of stream is the\ngeneration of alternating background colors for HTML. By using \u003ccode\u003ecycle\u003c/code\u003e\nwith \u003ccode\u003estream_combine\u003c/code\u003e, explained in the next section, an infinite stream\nof background colors can be combined with a finite stream of data to\nproduce a sequence of HTML blocks:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let stream_combine stream1 stream2 =\n  let rec next i =\n    try Some (Stream.next stream1, Stream.next stream2)\n    with Stream.Failure -\u0026gt; None in\n  Stream.from next\nval stream_combine : 'a Stream.t -\u0026gt; 'b Stream.t -\u0026gt; ('a * 'b) Stream.t = \u0026lt;fun\u0026gt;\n# Stream.iter print_endline\n  (stream_map\n     (fun (bg, s) -\u0026gt;\n        Printf.sprintf \u0026quot;\u0026lt;div style='background: %s'\u0026gt;%s\u0026lt;/div\u0026gt;\u0026quot; bg s)\n     (stream_combine\n        (cycle [\u0026quot;#eee\u0026quot;; \u0026quot;#fff\u0026quot;])\n        (Stream.of_list [\u0026quot;hello\u0026quot;; \u0026quot;html\u0026quot;; \u0026quot;world\u0026quot;])))\n\u0026lt;div style='background: #eee'\u0026gt;hello\u0026lt;/div\u0026gt;\n\u0026lt;div style='background: #fff'\u0026gt;html\u0026lt;/div\u0026gt;\n\u0026lt;div style='background: #eee'\u0026gt;world\u0026lt;/div\u0026gt;\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is a simple \u003ccode\u003erange\u003c/code\u003e function that produces a sequence of integers:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let range ?(start=0) ?(stop=0) ?(step=1) () =\n  let in_range = if step \u0026lt; 0 then (\u0026gt;) else (\u0026lt;) in\n  let current = ref start in\n  let rec next i =\n    if in_range !current stop\n    then let result = !current in (current := !current + step;\n                                   Some result)\n    else None in\n  Stream.from next\nval range : ?start:int -\u0026gt; ?stop:int -\u0026gt; ?step:int -\u0026gt; unit -\u0026gt; int Stream.t =\n  \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis works just like Python's \u003ccode\u003exrange\u003c/code\u003e built-in function, providing an\neasy way to produce an assortment of lazy integer sequences by\nspecifying combinations of \u003ccode\u003estart\u003c/code\u003e, \u003ccode\u003estop\u003c/code\u003e, or \u003ccode\u003estep\u003c/code\u003e values:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Stream.npeek 10 (range ~start:5 ~stop:10 ())\n- : int list = [5; 6; 7; 8; 9]\n# Stream.npeek 10 (range ~stop:10 ~step:2 ())\n- : int list = [0; 2; 4; 6; 8]\n# Stream.npeek 10 (range ~start:10 ~step:(-1) ())\n- : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]\n# Stream.npeek 10 (range ~start:10 ~stop:5 ~step:(-1) ())\n- : int list = [10; 9; 8; 7; 6]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"combining-streams\"\u003eCombining streams\u003c/h2\u003e\n\u003cp\u003eThere are several ways to combine streams. One is to produce a stream of\nstreams and then concatenate them into a single stream. The following\nfunction works just like \u003ccode\u003eList.concat\u003c/code\u003e, but instead of turning a list of\nlists into a list, it turns a stream of streams into a stream:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let stream_concat streams =\n  let current_stream = ref None in\n  let rec next i =\n    try\n      let stream =\n        match !current_stream with\n        | Some stream -\u0026gt; stream\n        | None -\u0026gt;\n           let stream = Stream.next streams in\n           current_stream := Some stream;\n           stream in\n      try Some (Stream.next stream)\n      with Stream.Failure -\u0026gt; (current_stream := None; next i)\n    with Stream.Failure -\u0026gt; None in\n  Stream.from next\nval stream_concat : 'a Stream.t Stream.t -\u0026gt; 'a Stream.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is a sequence of ranges which are themselves derived from a range,\nconcatenated with \u003ccode\u003estream_concat\u003c/code\u003e to produce a flattened \u003ccode\u003eint Stream.t\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Stream.npeek 10\n  (stream_concat\n     (stream_map\n        (fun i -\u0026gt; range ~stop:i ())\n        (range ~stop:5 ())))\n- : int list = [0; 0; 1; 0; 1; 2; 0; 1; 2; 3]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnother way to combine streams is to iterate through them in a pairwise\nfashion:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let stream_combine stream1 stream2 =\n  let rec next i =\n    try Some (Stream.next stream1, Stream.next stream2)\n    with Stream.Failure -\u0026gt; None in\n  Stream.from next\nval stream_combine : 'a Stream.t -\u0026gt; 'b Stream.t -\u0026gt; ('a * 'b) Stream.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is useful, for instance, if you have a stream of keys and a stream\nof corresponding values. Iterating through key value pairs is then as\nsimple as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eStream.iter\n  (fun (key, value) -\u0026gt;\n     (* do something with 'key' and 'value' *)\n     ())\n  (stream_combine key_stream value_stream)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-mdx-error\"\u003eLine 5, characters 21-31:\nError: Unbound value key_stream\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince \u003ccode\u003estream_combine\u003c/code\u003e stops as soon as either of its input streams runs\nout, it can be used to combine an infinite stream with a finite one.\nThis provides a neat way to add indexes to a sequence:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let items = [\u0026quot;this\u0026quot;; \u0026quot;is\u0026quot;; \u0026quot;a\u0026quot;; \u0026quot;test\u0026quot;]\nval items : string list = [\u0026quot;this\u0026quot;; \u0026quot;is\u0026quot;; \u0026quot;a\u0026quot;; \u0026quot;test\u0026quot;]\n# Stream.iter\n  (fun (index, value) -\u0026gt;\n     Printf.printf \u0026quot;%d. %s\\n%!\u0026quot; index value)\n  (stream_combine (count_stream 1) (Stream.of_list items))\n1. this\n2. is\n3. a\n4. test\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"copying-streams\"\u003eCopying streams\u003c/h2\u003e\n\u003cp\u003eStreams are destructive; once you discard an item in a stream, it is no\nlonger available unless you save a copy somewhere. What if you want to\nuse the same stream more than once? One way is to create a \u0026quot;tee\u0026quot;. The\nfollowing function creates two output streams from one input stream,\nintelligently queueing unseen values until they have been produced by\nboth streams:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let stream_tee stream =\n  let next self other i =\n    try\n      if Queue.is_empty self\n      then\n        let value = Stream.next stream in\n        Queue.add value other;\n        Some value\n      else\n        Some (Queue.take self)\n    with Stream.Failure -\u0026gt; None in\n  let q1 = Queue.create () in\n  let q2 = Queue.create () in\n  (Stream.from (next q1 q2), Stream.from (next q2 q1))\nval stream_tee : 'a Stream.t -\u0026gt; 'a Stream.t * 'a Stream.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is an example of a stream tee in action:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let letters = Stream.of_list ['a'; 'b'; 'c'; 'd'; 'e']\nval letters : char Stream.t = \u0026lt;abstr\u0026gt;\n# let s1, s2 = stream_tee letters\nval s1 : char Stream.t = \u0026lt;abstr\u0026gt;\nval s2 : char Stream.t = \u0026lt;abstr\u0026gt;\n# Stream.next s1\n- : char = 'a'\n# Stream.next s1\n- : char = 'b'\n# Stream.next s2\n- : char = 'a'\n# Stream.next s1\n- : char = 'c'\n# Stream.next s2\n- : char = 'b'\n# Stream.next s2\n- : char = 'c'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgain, since streams are destructive, you probably want to leave the\noriginal stream alone or you will lose items from the copied streams:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Stream.next letters\n- : char = 'd'\n# Stream.next s1\n- : char = 'e'\n# Stream.next s2\n- : char = 'e'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"converting-streams\"\u003eConverting streams\u003c/h2\u003e\n\u003cp\u003eHere are a few functions for converting between streams and lists,\narrays, and hash tables. These probably belong in the standard library,\nbut they are simple to define anyhow. Again, beware of infinite streams,\nwhich will cause these functions to hang.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let stream_of_list = Stream.of_list\nval stream_of_list : 'a list -\u0026gt; 'a Stream.t = \u0026lt;fun\u0026gt;\n# let list_of_stream stream =\n  let result = ref [] in\n  Stream.iter (fun value -\u0026gt; result := value :: !result) stream;\n  List.rev !result\nval list_of_stream : 'a Stream.t -\u0026gt; 'a list = \u0026lt;fun\u0026gt;\n# let stream_of_array array =\n  Stream.of_list (Array.to_list array)\nval stream_of_array : 'a array -\u0026gt; 'a Stream.t = \u0026lt;fun\u0026gt;\n# let array_of_stream stream =\n  Array.of_list (list_of_stream stream)\nval array_of_stream : 'a Stream.t -\u0026gt; 'a array = \u0026lt;fun\u0026gt;\n# let stream_of_hash hash =\n  let result = ref [] in\n  Hashtbl.iter\n    (fun key value -\u0026gt; result := (key, value) :: !result)\n    hash;\n  Stream.of_list !result\nval stream_of_hash : ('a, 'b) Hashtbl.t -\u0026gt; ('a * 'b) Stream.t = \u0026lt;fun\u0026gt;\n# let hash_of_stream stream =\n  let result = Hashtbl.create 0 in\n  Stream.iter\n    (fun (key, value) -\u0026gt; Hashtbl.replace result key value)\n    stream;\n  result\nval hash_of_stream : ('a * 'b) Stream.t -\u0026gt; ('a, 'b) Hashtbl.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat if you want to convert arbitrary data types to streams? Well, if the\ndata type defines an \u003ccode\u003eiter\u003c/code\u003e function, and you don't mind using threads,\nyou can use a producer-consumer arrangement to invert control:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# #directory \u0026quot;+threads\u0026quot;;;\n# #load \u0026quot;threads.cma\u0026quot;;;\n# let elements iter coll =\n  let channel = Event.new_channel () in\n  let producer () =\n    let () =\n      iter (fun x -\u0026gt; Event.sync (Event.send channel (Some x))) coll in\n    Event.sync (Event.send channel None) in\n  let consumer i =\n    Event.sync (Event.receive channel) in\n  ignore (Thread.create producer ());\n  Stream.from consumer\nval elements : (('a -\u0026gt; unit) -\u0026gt; 'b -\u0026gt; unit) -\u0026gt; 'b -\u0026gt; 'a Stream.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow it is possible to build a stream from an \u003ccode\u003eiter\u003c/code\u003e function and a\ncorresponding value:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# module StringSet = Set.Make(String)\nmodule StringSet :\n  sig\n    type elt = string\n    type t = Set.Make(String).t\n    val empty : t\n    val is_empty : t -\u0026gt; bool\n    val mem : elt -\u0026gt; t -\u0026gt; bool\n    val add : elt -\u0026gt; t -\u0026gt; t\n    val singleton : elt -\u0026gt; t\n    val remove : elt -\u0026gt; t -\u0026gt; t\n    val union : t -\u0026gt; t -\u0026gt; t\n    val inter : t -\u0026gt; t -\u0026gt; t\n    val disjoint : t -\u0026gt; t -\u0026gt; bool\n    val diff : t -\u0026gt; t -\u0026gt; t\n    val compare : t -\u0026gt; t -\u0026gt; int\n    val equal : t -\u0026gt; t -\u0026gt; bool\n    val subset : t -\u0026gt; t -\u0026gt; bool\n    val iter : (elt -\u0026gt; unit) -\u0026gt; t -\u0026gt; unit\n    val map : (elt -\u0026gt; elt) -\u0026gt; t -\u0026gt; t\n    val fold : (elt -\u0026gt; 'a -\u0026gt; 'a) -\u0026gt; t -\u0026gt; 'a -\u0026gt; 'a\n    val for_all : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; bool\n    val exists : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; bool\n    val filter : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; t\n    val partition : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; t * t\n    val cardinal : t -\u0026gt; int\n    val elements : t -\u0026gt; elt list\n    val min_elt : t -\u0026gt; elt\n    val min_elt_opt : t -\u0026gt; elt option\n    val max_elt : t -\u0026gt; elt\n    val max_elt_opt : t -\u0026gt; elt option\n    val choose : t -\u0026gt; elt\n    val choose_opt : t -\u0026gt; elt option\n    val split : elt -\u0026gt; t -\u0026gt; t * bool * t\n    val find : elt -\u0026gt; t -\u0026gt; elt\n    val find_opt : elt -\u0026gt; t -\u0026gt; elt option\n    val find_first : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt\n    val find_first_opt : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt option\n    val find_last : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt\n    val find_last_opt : (elt -\u0026gt; bool) -\u0026gt; t -\u0026gt; elt option\n    val of_list : elt list -\u0026gt; t\n    val to_seq_from : elt -\u0026gt; t -\u0026gt; elt Seq.t\n    val to_seq : t -\u0026gt; elt Seq.t\n    val add_seq : elt Seq.t -\u0026gt; t -\u0026gt; t\n    val of_seq : elt Seq.t -\u0026gt; t\n  end\n# let set = StringSet.empty\nval set : StringSet.t = \u0026lt;abstr\u0026gt;\n# let set = StringSet.add \u0026quot;here\u0026quot; set\nval set : StringSet.t = \u0026lt;abstr\u0026gt;\n# let set = StringSet.add \u0026quot;are\u0026quot; set\nval set : StringSet.t = \u0026lt;abstr\u0026gt;\n# let set = StringSet.add \u0026quot;some\u0026quot; set\nval set : StringSet.t = \u0026lt;abstr\u0026gt;\n# let set = StringSet.add \u0026quot;values\u0026quot; set\nval set : StringSet.t = \u0026lt;abstr\u0026gt;\n# let stream = elements StringSet.iter set\nval stream : string Stream.t = \u0026lt;abstr\u0026gt;\n# Stream.iter print_endline stream\nare\nhere\nsome\nvalues\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSome data types, like Hashtbl and Map, provide an \u003ccode\u003eiter\u003c/code\u003e function that\niterates through key-value pairs. Here's a function for those, too:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let items iter coll =\n  let channel = Event.new_channel () in\n  let producer () =\n    let () =\n      iter (fun k v -\u0026gt;\n              Event.sync (Event.send channel (Some (k, v)))) coll in\n    Event.sync (Event.send channel None) in\n  let consumer i =\n    Event.sync (Event.receive channel) in\n  ignore (Thread.create producer ());\n  Stream.from consumer\nval items : (('a -\u0026gt; 'b -\u0026gt; unit) -\u0026gt; 'c -\u0026gt; unit) -\u0026gt; 'c -\u0026gt; ('a * 'b) Stream.t =\n  \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we want just the keys, or just the values, it is simple to transform\nthe output of \u003ccode\u003eitems\u003c/code\u003e using \u003ccode\u003estream_map\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let keys iter coll = stream_map (fun (k, v) -\u0026gt; k) (items iter coll)\nval keys : (('a -\u0026gt; 'b -\u0026gt; unit) -\u0026gt; 'c -\u0026gt; unit) -\u0026gt; 'c -\u0026gt; 'a Stream.t = \u0026lt;fun\u0026gt;\n# let values iter coll = stream_map (fun (k, v) -\u0026gt; v) (items iter coll)\nval values : (('a -\u0026gt; 'b -\u0026gt; unit) -\u0026gt; 'c -\u0026gt; unit) -\u0026gt; 'c -\u0026gt; 'b Stream.t = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eKeep in mind that these techniques spawn producer threads which carry a\nfew risks: they only terminate when they have finished iterating, and\nany change to the original data structure while iterating may produce\nunexpected results.\u003c/p\u003e\n\u003ch2 id=\"other-built-in-stream-functions\"\u003eOther built-in Stream functions\u003c/h2\u003e\n\u003cp\u003eThere are a few other documented methods in the \u003ccode\u003eStream\u003c/code\u003e module:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStream.empty, which raises \u003ccode\u003eStream.Failure\u003c/code\u003e unless a stream is empty\n\u003c/li\u003e\n\u003cli\u003eStream.count, which returns the stream count (number of discarded\nelements)\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn addition, there are a few undocumented functions: \u003ccode\u003eiapp\u003c/code\u003e, \u003ccode\u003eicons\u003c/code\u003e,\n\u003ccode\u003eising\u003c/code\u003e, \u003ccode\u003elapp\u003c/code\u003e, \u003ccode\u003elcons\u003c/code\u003e, \u003ccode\u003elsing\u003c/code\u003e, \u003ccode\u003esempty\u003c/code\u003e, \u003ccode\u003eslazy\u003c/code\u003e, and \u003ccode\u003edump\u003c/code\u003e. They\nare visible in the interface with the caveat: \u0026quot;For system use only, not\nfor the casual user\u0026quot;.\u003c/p\u003e\n"},{"title":"Format","slug":"format","description":"The Format module of Caml Light and OCaml's standard libraries provides pretty-printing facilities to get a fancy display for printing routines\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"stdlib","tl":{"hd":"common","tl":0}},"users":{"hd":"Intermediate","tl":0},"body_md":"\nThe `Format` module of Caml Light and OCaml's standard libraries\nprovides pretty-printing facilities to get a fancy display for printing\nroutines. This module implements a pretty-printing engine that is\nintended to break lines in a nice way (let's say automatically when it\nis necessary).\n\n## Principles\nLine breaking is based on three concepts:\n\n* **boxes**: a box is a logical pretty-printing unit, which defines a\n behaviour of the pretty-printing engine to display the material\n inside the box.\n* **break hints**: a break hint is a directive to the pretty-printing\n engine that proposes to break the line here, if it is necessary to\n properly print the rest of the material. Otherwise, the\n pretty-printing engine never break lines (except in case of\n emergency to avoid very bad output). In short, a break hint tells\n the pretty printer that a line break here may be appropriate.\n* **Indentation rules**: When a line break occurs, the pretty-printing\n engines fixes the indentation (or amount of leading spaces) of the\n new line using indentation rules, as follows:\n    * A box can state the extra indentation of every new line opened\n in its scope. This extra indentation is named **box breaking\n indentation**.\n    * A break hint can also set the additional indentation of the new\n line it may fire. This extra indentation is named **hint\n breaking indentation**.\n    * If break hint `bh` fires a new line within box `b`, then the\n indentation of the new line is simply the sum of: the current\n indentation of box `b` `+` the additional box breaking\n indentation, as defined by box `b` `+` the additional hint\n breaking indentation, as defined by break hint `bh`.\n\n## Boxes\nThere are 4 types of boxes. (The most often used is the hov box type,\nso skip the rest at first reading).\n\n* **horizontal box** (*h* box, as obtained by the `open_hbox`\n procedure): within this box, break hints do not lead to line breaks.\n* **vertical box** (*v* box, as obtained by the `open_vbox`\n procedure): within this box, every break hint lead to a new line.\n* **vertical/horizontal box** (*hv* box, as obtained by the\n `open_hvbox` procedure): if it is possible, the entire box is\n written on a single line; otherwise, every break hint within the box\n leads to a new line.\n* **vertical or horizontal box** (*hov* box, as obtained by the\n open_box or open_hovbox procedures): within this box, break hints\n are used to cut the line when there is no more room on the line.\n There are two kinds of hov boxes, you can find the details\n [below](#Refinementonhovboxes). In first approximation, let me consider these\n two kinds of hov boxes as equivalent and obtained by calling the\n `open_box` procedure.\n\nLet me give an example. Suppose we can write 10 chars before the right\nmargin (that indicates no more room). We represent any char as a `-`\nsign; characters `[` and `]` indicates the opening and closing of a box\nand `b` stands for a break hint given to the pretty-printing engine.\n\nThe output \"--b--b--\" is displayed like this (the b symbol stands for\nthe value of the break that is explained below):\n\n* within a h box:\n\n    ```text\n    --b--b--\n    ```\n\n* within a v box:\n\n    ```text\n    --b\n    --b\n    --\n    ```\n\n* within a hv box:\n\n    If there is enough room to print the box on the line:\n\n    ```text\n    --b--b--\n    ```\n    But \"---b---b---\" that cannot fit on the line is written\n\n    ```text\n    ---b\n    ---b\n    ---\n    ```\n\n* within a hov box:\n\n    If there is enough room to print the box on the line:\n\n    ```text\n    --b--b--\n    ```\n    But if \"---b---b---\" cannot fit on the line, it is written as\n\n    ```text\n    ---b---b\n    ---\n    ```\n    The first break hint does not lead to a new line, since there is\n    enough room on the line. The second one leads to a new line since\n    there is no more room to print the material following it. If the\n    room left on the line were even shorter, the first break hint may\n    lead to a new line and \"---b---b---\" is written as:\n\n    ```text\n    ---b\n    ---b\n    ---\n    ```\n\n\n## Printing spaces\nBreak hints are also used to output spaces (if the line is not split\nwhen the break is encountered, otherwise the new line indicates properly\nthe separation between printing items). You output a break hint using\n`print_break sp indent`, and this `sp` integer is used to print sp\nspaces. Thus `print_break sp ...` may be thought as: print `sp` spaces\nor output a new line.\n\nFor instance, if b is `break 1 0` in the output \"--b--b--\", we get\n\n* within a h box:\n\n    ```text\n    -- -- --\n    ```\n\n* within a v box:\n\n    ```text\n    --\n    --\n    --\n    ```\n\n* within a hv box:\n\n    ```text\n    -- -- --\n    ```\n    or, according to the remaining room on the line:\n\n    ```text\n    --\n    --\n    --\n    ```\n\n* and similarly for hov boxes.\n\nGenerally speaking, a printing routine using \"format\", should not\ndirectly output white spaces: the routine should use break hints\ninstead. (For instance `print_space ()` that is a convenient\nabbreviation for `print_break 1 0` and outputs a single space or break\nthe line.)\n\n\n## Indentation of new lines\nThe user gets 2 ways to fix the indentation of new lines:\n\n* **when defining the box**: when you open a box, you can fix the\n indentation added to each new line opened within that box.\u003cbr /\u003e\n For instance: `open_hovbox 1` opens a hov box with new lines\n indented 1 more than the initial indentation of the box. With output\n \"---[--b--b--b--\", we get:\n\n    ```text\n    ---[--b--b\n         --b--\n    ```\n    with `open_hovbox 2`, we get\n\n    ```text\n    ---[--b--b\n          --b--\n    ```\n    Note: the `[` sign in the display is not visible on the screen, it\n    is just there to materialise the aperture of the pretty-printing\n    box. Last screen stands for:\n\n    ```text\n    -----b--b\n         --b--\n    ```\n\n* **when defining the break that makes the new line**. As said above,\n you output a break hint using `print_break     sp           indent`.\n The `indent` integer is used to fix the additional indentation of\n the new line. Namely, it is added to the default indentation offset\n of the box where the break occurs.\u003cbr /\u003e\n For instance, if `[` stands for the opening of a hov box with 1\n as extra indentation (as obtained by `open_hovbox 1`), and b is\n `print_break       1       2`, then from output \"---[--b--b--b--\",\n we get:\n\n    ```text\n    ---[-- --\n          --\n          --\n    ```\n\n\n## Refinement on hov boxes\n###  Packing and structural hov boxes\n\nThe hov box type is refined into two categories.\n\n* **the vertical or horizontal *packing* box** (as obtained by the\n open_hovbox procedure): break hints are used to cut the line when\n there is no more room on the line; no new line occurs if there is\n enough room on the line.\n* **vertical or horizontal *structural* box** (as obtained by the\n open_box procedure): similar to the hov packing box, the break\n hints are used to cut the line when there is no more room on the\n line; in addition, break hints that can show the box structure lead\n to new lines even if there is enough room on the current line.\n\n###  Differences between a packing and a structural hov box\nThe difference between a packing and a structural hov box is shown by\na routine that closes boxes and parentheses at the end of printing: with\npacking boxes, the closure of boxes and parentheses do not lead to new\nlines if there is enough room on the line, whereas with structural boxes\neach break hint will lead to a new line. For instance, when printing\n`[(---[(----[(---b)]b)]b)]`, where `b` is a break hint without extra\nindentation (`print_cut ()`). If `[` means opening of a packing hov\nbox (open_hovbox), `[(---[(----[(---b)]b)]b)]` is printed as follows:\n\n```text\n(---\n (----\n  (---)))\n```\nIf we replace the packing boxes by structural boxes (open_box), each\nbreak hint that precedes a closing parenthesis can show the boxes\nstructure, if it leads to a new line; hence `[(---[(----[(---b)]b)]b)]`\nis printed like this:\n\n```text\n(---\n (----\n  (---\n  )\n )\n)\n```\n\n## Practical advice\n\nWhen writing a pretty-printing routine, follow these simple rules:\n\n1. Boxes must be opened and closed consistently (`open_*` and\n `close_box` must be nested like parentheses).\n1. Never hesitate to open a box.\n1. Output many break hints, otherwise the pretty-printer is in a bad\n situation where it tries to do its best, which is always worse than\n your bad.\n1. Do not try to force spacing using explicit spaces in the character\n strings. For each space you want in the output emit a break hint\n (`print_space ()`), unless you explicitly don't want the line to be\n broken here. For instance, imagine you want to pretty print an OCaml\n definition, more precisely a `let rec ident =     expression` value\n definition. You will probably treat the first three spaces as\n unbreakable spaces and write them directly in the string constants\n for keywords, and print `\"let rec \"` before the identifier, and\n similarly write ` =` to get an unbreakable space after the\n identifier; in contrast, the space after the `=` sign is certainly a\n break hint, since breaking the line after `=` is a usual (and\n elegant) way to indent the expression part of a definition. In\n short, it is often necessary to print unbreakable spaces; however,\n most of the time a space should be considered a break hint.\n1. Do not try to force new lines, let the pretty-printer do it for you:\n that's its only job. In particular, do not use `force_newline`: this\n procedure effectively leads to a newline, but it also as the\n unfortunate side effect to partially reinitialise the\n pretty-printing engine, so that the rest of the printing material is\n noticeably messed up.\n1. Never put newline characters directly in the strings to be printed:\n pretty printing engine will consider this newline character as any\n other character written on the current line and this will completely\n mess up the output. Instead of new line characters use line break\n hints: if those break hints must always result in new lines, it just\n means that the surrounding box must be a vertical box!\n1. End your main program by a `print_newline ()` call, that flushes the\n pretty-printer tables (hence the output). (Note that the top-level\n loop of the interactive system does it as well, just before a new\n input.)\n\n## Printing to `stdout`: using `printf`\nThe `format` module provides a general printing facility  la\n`printf`. In addition to the usual conversion facility provided by\n`printf`, you can write pretty-printing indications directly inside the\nformat string (opening and closing boxes, indicating breaking hints,\netc).\n\nPretty-printing annotations are introduced by the `@` symbol, directly\ninto the string format. Almost any function of the `format` module can\nbe called from within a `printf` format string. For instance\n\n* `@[` open a box (`open_box     0`). You may precise the type as an\n extra argument. For instance `@[\u003chov n\u003e` is equivalent to\n `open_hovbox       n`.\n* `@]` close a box (`close_box       ()`).\n* `@`  output a breakable space (`print_space ()`).\n* `@,` output a break hint (`print_cut       ()`).\n* `@;\u003cn m\u003e` emit a full break hint (`print_break n m`).\n* `@.` end the pretty-printing, closing all the boxes still opened\n (`print_newline ()`).\n\nFor instance\n\n```ocaml\n# Format.printf \"@[\u003c1\u003e%s@ =@ %d@ %s@]@.\" \"Prix TTC\" 100 \"Euros\"\nPrix TTC = 100 Euros\n- : unit = ()\n```\n\n## A concrete example\n\nLet me give a full example: the shortest non trivial example you could\nimagine, that is the -calculus. :)\n\nThus the problem is to pretty-print the values of a concrete data type\nthat models a language of expressions that defines functions and their\napplications to arguments.\n\nFirst, I give the abstract syntax of lambda-terms (we illustrate it in\nthe [interactive system](../description.html#Interactivity)):\n\n```ocaml\n# type lambda =\n  | Lambda of string * lambda\n  | Var of string\n  | Apply of lambda * lambda\ntype lambda =\n    Lambda of string * lambda\n  | Var of string\n  | Apply of lambda * lambda\n```\nI use the format library to print the lambda-terms:\n\n```ocaml\nopen Format\nlet ident = print_string\nlet kwd = print_string\n\nlet rec print_exp0 = function\n  | Var s -\u003e  ident s\n  | lam -\u003e open_hovbox 1; kwd \"(\"; print_lambda lam; kwd \")\"; close_box ()\nand print_app = function\n  | e -\u003e open_hovbox 2; print_other_applications e; close_box ()\nand print_other_applications f =\n  match f with\n  | Apply (f, arg) -\u003e print_app f; print_space (); print_exp0 arg\n  | f -\u003e print_exp0 f\nand print_lambda = function\n  | Lambda (s, lam) -\u003e\n      open_hovbox 1;\n      kwd \"\\\\\"; ident s; kwd \".\"; print_space(); print_lambda lam;\n      close_box()\n  | e -\u003e print_app e\n```\nIn Caml Light, replace the first line by:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\n#open \"format\";;\n```\n\n###  Most general pretty-printing: using `fprintf`\n\nWe use the `fprintf` function to write the most versatile version of the\npretty-printing functions for lambda-terms. Now, the functions get an\nextra argument, namely a pretty-printing formatter (the `ppf` argument)\nwhere printing will occur. This way the printing routines are more\ngeneral, since they can print on any formatter defined in the program\n(either printing to a file, or to `stdout`, to `stderr`, or even to a\nstring). Furthermore, the pretty-printing functions are now\ncompositional, since they may be used in conjunction with the special\n`%a` conversion, that prints a `fprintf` argument with a user's supplied\nfunction (these user's supplied functions also have a formatter as first\nargument).\n\nUsing `fprintf`, the lambda-terms printing routines can be written as\nfollows:\n\n```ocaml\nopen Format\n\nlet ident ppf s = fprintf ppf \"%s\" s\nlet kwd ppf s = fprintf ppf \"%s\" s\n\nlet rec pr_exp0 ppf = function\n  | Var s -\u003e fprintf ppf \"%a\" ident s\n  | lam -\u003e fprintf ppf \"@[\u003c1\u003e(%a)@]\" pr_lambda lam\nand pr_app ppf e =\n  fprintf ppf \"@[\u003c2\u003e%a@]\" pr_other_applications e\nand pr_other_applications ppf f =\n  match f with\n  | Apply (f, arg) -\u003e fprintf ppf \"%a@ %a\" pr_app f pr_exp0 arg\n  | f -\u003e pr_exp0 ppf f\nand pr_lambda ppf = function\n  | Lambda (s, lam) -\u003e\n     fprintf ppf \"@[\u003c1\u003e%a%a%a@ %a@]\"\n             kwd \"\\\\\" ident s kwd \".\" pr_lambda lam\n  | e -\u003e pr_app ppf e\n```\n\nGiven those general printing routines, procedures to print to `stdout`\nor `stderr` is just a matter of partial application:\n\n```ocaml\nlet print_lambda = pr_lambda std_formatter\nlet eprint_lambda = pr_lambda err_formatter\n```\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#principles\"\u003ePrinciples\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#boxes\"\u003eBoxes\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#printing-spaces\"\u003ePrinting spaces\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#indentation-of-new-lines\"\u003eIndentation of new lines\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#refinement-on-hov-boxes\"\u003eRefinement on hov boxes\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-advice\"\u003ePractical advice\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#printing-to-stdout-using-printf\"\u003ePrinting to \u003ccode\u003estdout\u003c/code\u003e: using \u003ccode\u003eprintf\u003c/code\u003e\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#a-concrete-example\"\u003eA concrete example\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eThe \u003ccode\u003eFormat\u003c/code\u003e module of Caml Light and OCaml's standard libraries\nprovides pretty-printing facilities to get a fancy display for printing\nroutines. This module implements a pretty-printing engine that is\nintended to break lines in a nice way (let's say automatically when it\nis necessary).\u003c/p\u003e\n\u003ch2 id=\"principles\"\u003ePrinciples\u003c/h2\u003e\n\u003cp\u003eLine breaking is based on three concepts:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eboxes\u003c/strong\u003e: a box is a logical pretty-printing unit, which defines a\nbehaviour of the pretty-printing engine to display the material\ninside the box.\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ebreak hints\u003c/strong\u003e: a break hint is a directive to the pretty-printing\nengine that proposes to break the line here, if it is necessary to\nproperly print the rest of the material. Otherwise, the\npretty-printing engine never break lines (except in case of\nemergency to avoid very bad output). In short, a break hint tells\nthe pretty printer that a line break here may be appropriate.\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIndentation rules\u003c/strong\u003e: When a line break occurs, the pretty-printing\nengines fixes the indentation (or amount of leading spaces) of the\nnew line using indentation rules, as follows:\n\u003cul\u003e\n\u003cli\u003eA box can state the extra indentation of every new line opened\nin its scope. This extra indentation is named \u003cstrong\u003ebox breaking\nindentation\u003c/strong\u003e.\n\u003c/li\u003e\n\u003cli\u003eA break hint can also set the additional indentation of the new\nline it may fire. This extra indentation is named \u003cstrong\u003ehint\nbreaking indentation\u003c/strong\u003e.\n\u003c/li\u003e\n\u003cli\u003eIf break hint \u003ccode\u003ebh\u003c/code\u003e fires a new line within box \u003ccode\u003eb\u003c/code\u003e, then the\nindentation of the new line is simply the sum of: the current\nindentation of box \u003ccode\u003eb\u003c/code\u003e \u003ccode\u003e+\u003c/code\u003e the additional box breaking\nindentation, as defined by box \u003ccode\u003eb\u003c/code\u003e \u003ccode\u003e+\u003c/code\u003e the additional hint\nbreaking indentation, as defined by break hint \u003ccode\u003ebh\u003c/code\u003e.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"boxes\"\u003eBoxes\u003c/h2\u003e\n\u003cp\u003eThere are 4 types of boxes. (The most often used is the hov box type,\nso skip the rest at first reading).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ehorizontal box\u003c/strong\u003e (\u003cem\u003eh\u003c/em\u003e box, as obtained by the \u003ccode\u003eopen_hbox\u003c/code\u003e\nprocedure): within this box, break hints do not lead to line breaks.\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003evertical box\u003c/strong\u003e (\u003cem\u003ev\u003c/em\u003e box, as obtained by the \u003ccode\u003eopen_vbox\u003c/code\u003e\nprocedure): within this box, every break hint lead to a new line.\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003evertical/horizontal box\u003c/strong\u003e (\u003cem\u003ehv\u003c/em\u003e box, as obtained by the\n\u003ccode\u003eopen_hvbox\u003c/code\u003e procedure): if it is possible, the entire box is\nwritten on a single line; otherwise, every break hint within the box\nleads to a new line.\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003evertical or horizontal box\u003c/strong\u003e (\u003cem\u003ehov\u003c/em\u003e box, as obtained by the\nopen_box or open_hovbox procedures): within this box, break hints\nare used to cut the line when there is no more room on the line.\nThere are two kinds of hov boxes, you can find the details\n\u003ca href=\"#Refinementonhovboxes\"\u003ebelow\u003c/a\u003e. In first approximation, let me consider these\ntwo kinds of hov boxes as equivalent and obtained by calling the\n\u003ccode\u003eopen_box\u003c/code\u003e procedure.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet me give an example. Suppose we can write 10 chars before the right\nmargin (that indicates no more room). We represent any char as a \u003ccode\u003e-\u003c/code\u003e\nsign; characters \u003ccode\u003e[\u003c/code\u003e and \u003ccode\u003e]\u003c/code\u003e indicates the opening and closing of a box\nand \u003ccode\u003eb\u003c/code\u003e stands for a break hint given to the pretty-printing engine.\u003c/p\u003e\n\u003cp\u003eThe output \u0026quot;--b--b--\u0026quot; is displayed like this (the b symbol stands for\nthe value of the break that is explained below):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ewithin a h box:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e--b--b--\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ewithin a v box:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e--b\n--b\n--\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ewithin a hv box:\u003c/p\u003e\n\u003cp\u003eIf there is enough room to print the box on the line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e--b--b--\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut \u0026quot;---b---b---\u0026quot; that cannot fit on the line is written\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e---b\n---b\n---\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ewithin a hov box:\u003c/p\u003e\n\u003cp\u003eIf there is enough room to print the box on the line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e--b--b--\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut if \u0026quot;---b---b---\u0026quot; cannot fit on the line, it is written as\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e---b---b\n---\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe first break hint does not lead to a new line, since there is\nenough room on the line. The second one leads to a new line since\nthere is no more room to print the material following it. If the\nroom left on the line were even shorter, the first break hint may\nlead to a new line and \u0026quot;---b---b---\u0026quot; is written as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e---b\n---b\n---\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"printing-spaces\"\u003ePrinting spaces\u003c/h2\u003e\n\u003cp\u003eBreak hints are also used to output spaces (if the line is not split\nwhen the break is encountered, otherwise the new line indicates properly\nthe separation between printing items). You output a break hint using\n\u003ccode\u003eprint_break sp indent\u003c/code\u003e, and this \u003ccode\u003esp\u003c/code\u003e integer is used to print sp\nspaces. Thus \u003ccode\u003eprint_break sp ...\u003c/code\u003e may be thought as: print \u003ccode\u003esp\u003c/code\u003e spaces\nor output a new line.\u003c/p\u003e\n\u003cp\u003eFor instance, if b is \u003ccode\u003ebreak 1 0\u003c/code\u003e in the output \u0026quot;--b--b--\u0026quot;, we get\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ewithin a h box:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e-- -- --\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ewithin a v box:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e--\n--\n--\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ewithin a hv box:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e-- -- --\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor, according to the remaining room on the line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e--\n--\n--\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eand similarly for hov boxes.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGenerally speaking, a printing routine using \u0026quot;format\u0026quot;, should not\ndirectly output white spaces: the routine should use break hints\ninstead. (For instance \u003ccode\u003eprint_space ()\u003c/code\u003e that is a convenient\nabbreviation for \u003ccode\u003eprint_break 1 0\u003c/code\u003e and outputs a single space or break\nthe line.)\u003c/p\u003e\n\u003ch2 id=\"indentation-of-new-lines\"\u003eIndentation of new lines\u003c/h2\u003e\n\u003cp\u003eThe user gets 2 ways to fix the indentation of new lines:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ewhen defining the box\u003c/strong\u003e: when you open a box, you can fix the\nindentation added to each new line opened within that box.\u003cbr /\u003e\nFor instance: \u003ccode\u003eopen_hovbox 1\u003c/code\u003e opens a hov box with new lines\nindented 1 more than the initial indentation of the box. With output\n\u0026quot;---[--b--b--b--\u0026quot;, we get:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e---[--b--b\n     --b--\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewith \u003ccode\u003eopen_hovbox 2\u003c/code\u003e, we get\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e---[--b--b\n      --b--\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote: the \u003ccode\u003e[\u003c/code\u003e sign in the display is not visible on the screen, it\nis just there to materialise the aperture of the pretty-printing\nbox. Last screen stands for:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e-----b--b\n     --b--\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ewhen defining the break that makes the new line\u003c/strong\u003e. As said above,\nyou output a break hint using \u003ccode\u003eprint_break     sp           indent\u003c/code\u003e.\nThe \u003ccode\u003eindent\u003c/code\u003e integer is used to fix the additional indentation of\nthe new line. Namely, it is added to the default indentation offset\nof the box where the break occurs.\u003cbr /\u003e\nFor instance, if \u003ccode\u003e[\u003c/code\u003e stands for the opening of a hov box with 1\nas extra indentation (as obtained by \u003ccode\u003eopen_hovbox 1\u003c/code\u003e), and b is\n\u003ccode\u003eprint_break       1       2\u003c/code\u003e, then from output \u0026quot;---[--b--b--b--\u0026quot;,\nwe get:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e---[-- --\n      --\n      --\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"refinement-on-hov-boxes\"\u003eRefinement on hov boxes\u003c/h2\u003e\n\u003ch3 id=\"packing-and-structural-hov-boxes\"\u003ePacking and structural hov boxes\u003c/h3\u003e\n\u003cp\u003eThe hov box type is refined into two categories.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ethe vertical or horizontal \u003cem\u003epacking\u003c/em\u003e box\u003c/strong\u003e (as obtained by the\nopen_hovbox procedure): break hints are used to cut the line when\nthere is no more room on the line; no new line occurs if there is\nenough room on the line.\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003evertical or horizontal \u003cem\u003estructural\u003c/em\u003e box\u003c/strong\u003e (as obtained by the\nopen_box procedure): similar to the hov packing box, the break\nhints are used to cut the line when there is no more room on the\nline; in addition, break hints that can show the box structure lead\nto new lines even if there is enough room on the current line.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"differences-between-a-packing-and-a-structural-hov-box\"\u003eDifferences between a packing and a structural hov box\u003c/h3\u003e\n\u003cp\u003eThe difference between a packing and a structural hov box is shown by\na routine that closes boxes and parentheses at the end of printing: with\npacking boxes, the closure of boxes and parentheses do not lead to new\nlines if there is enough room on the line, whereas with structural boxes\neach break hint will lead to a new line. For instance, when printing\n\u003ccode\u003e[(---[(----[(---b)]b)]b)]\u003c/code\u003e, where \u003ccode\u003eb\u003c/code\u003e is a break hint without extra\nindentation (\u003ccode\u003eprint_cut ()\u003c/code\u003e). If \u003ccode\u003e[\u003c/code\u003e means opening of a packing hov\nbox (open_hovbox), \u003ccode\u003e[(---[(----[(---b)]b)]b)]\u003c/code\u003e is printed as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e(---\n (----\n  (---)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we replace the packing boxes by structural boxes (open_box), each\nbreak hint that precedes a closing parenthesis can show the boxes\nstructure, if it leads to a new line; hence \u003ccode\u003e[(---[(----[(---b)]b)]b)]\u003c/code\u003e\nis printed like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e(---\n (----\n  (---\n  )\n )\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"practical-advice\"\u003ePractical advice\u003c/h2\u003e\n\u003cp\u003eWhen writing a pretty-printing routine, follow these simple rules:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eBoxes must be opened and closed consistently (\u003ccode\u003eopen_*\u003c/code\u003e and\n\u003ccode\u003eclose_box\u003c/code\u003e must be nested like parentheses).\n\u003c/li\u003e\n\u003cli\u003eNever hesitate to open a box.\n\u003c/li\u003e\n\u003cli\u003eOutput many break hints, otherwise the pretty-printer is in a bad\nsituation where it tries to do its best, which is always worse than\nyour bad.\n\u003c/li\u003e\n\u003cli\u003eDo not try to force spacing using explicit spaces in the character\nstrings. For each space you want in the output emit a break hint\n(\u003ccode\u003eprint_space ()\u003c/code\u003e), unless you explicitly don't want the line to be\nbroken here. For instance, imagine you want to pretty print an OCaml\ndefinition, more precisely a \u003ccode\u003elet rec ident =     expression\u003c/code\u003e value\ndefinition. You will probably treat the first three spaces as\nunbreakable spaces and write them directly in the string constants\nfor keywords, and print \u003ccode\u003e\u0026quot;let rec \u0026quot;\u003c/code\u003e before the identifier, and\nsimilarly write \u003ccode\u003e =\u003c/code\u003e to get an unbreakable space after the\nidentifier; in contrast, the space after the \u003ccode\u003e=\u003c/code\u003e sign is certainly a\nbreak hint, since breaking the line after \u003ccode\u003e=\u003c/code\u003e is a usual (and\nelegant) way to indent the expression part of a definition. In\nshort, it is often necessary to print unbreakable spaces; however,\nmost of the time a space should be considered a break hint.\n\u003c/li\u003e\n\u003cli\u003eDo not try to force new lines, let the pretty-printer do it for you:\nthat's its only job. In particular, do not use \u003ccode\u003eforce_newline\u003c/code\u003e: this\nprocedure effectively leads to a newline, but it also as the\nunfortunate side effect to partially reinitialise the\npretty-printing engine, so that the rest of the printing material is\nnoticeably messed up.\n\u003c/li\u003e\n\u003cli\u003eNever put newline characters directly in the strings to be printed:\npretty printing engine will consider this newline character as any\nother character written on the current line and this will completely\nmess up the output. Instead of new line characters use line break\nhints: if those break hints must always result in new lines, it just\nmeans that the surrounding box must be a vertical box!\n\u003c/li\u003e\n\u003cli\u003eEnd your main program by a \u003ccode\u003eprint_newline ()\u003c/code\u003e call, that flushes the\npretty-printer tables (hence the output). (Note that the top-level\nloop of the interactive system does it as well, just before a new\ninput.)\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"printing-to-stdout-using-printf\"\u003ePrinting to \u003ccode\u003estdout\u003c/code\u003e: using \u003ccode\u003eprintf\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eformat\u003c/code\u003e module provides a general printing facility  la\n\u003ccode\u003eprintf\u003c/code\u003e. In addition to the usual conversion facility provided by\n\u003ccode\u003eprintf\u003c/code\u003e, you can write pretty-printing indications directly inside the\nformat string (opening and closing boxes, indicating breaking hints,\netc).\u003c/p\u003e\n\u003cp\u003ePretty-printing annotations are introduced by the \u003ccode\u003e@\u003c/code\u003e symbol, directly\ninto the string format. Almost any function of the \u003ccode\u003eformat\u003c/code\u003e module can\nbe called from within a \u003ccode\u003eprintf\u003c/code\u003e format string. For instance\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@[\u003c/code\u003e open a box (\u003ccode\u003eopen_box     0\u003c/code\u003e). You may precise the type as an\nextra argument. For instance \u003ccode\u003e@[\u0026lt;hov n\u0026gt;\u003c/code\u003e is equivalent to\n\u003ccode\u003eopen_hovbox       n\u003c/code\u003e.\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@]\u003c/code\u003e close a box (\u003ccode\u003eclose_box       ()\u003c/code\u003e).\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@\u003c/code\u003e  output a breakable space (\u003ccode\u003eprint_space ()\u003c/code\u003e).\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@,\u003c/code\u003e output a break hint (\u003ccode\u003eprint_cut       ()\u003c/code\u003e).\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@;\u0026lt;n m\u0026gt;\u003c/code\u003e emit a full break hint (\u003ccode\u003eprint_break n m\u003c/code\u003e).\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@.\u003c/code\u003e end the pretty-printing, closing all the boxes still opened\n(\u003ccode\u003eprint_newline ()\u003c/code\u003e).\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor instance\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Format.printf \u0026quot;@[\u0026lt;1\u0026gt;%s@ =@ %d@ %s@]@.\u0026quot; \u0026quot;Prix TTC\u0026quot; 100 \u0026quot;Euros\u0026quot;\nPrix TTC = 100 Euros\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"a-concrete-example\"\u003eA concrete example\u003c/h2\u003e\n\u003cp\u003eLet me give a full example: the shortest non trivial example you could\nimagine, that is the -calculus. :)\u003c/p\u003e\n\u003cp\u003eThus the problem is to pretty-print the values of a concrete data type\nthat models a language of expressions that defines functions and their\napplications to arguments.\u003c/p\u003e\n\u003cp\u003eFirst, I give the abstract syntax of lambda-terms (we illustrate it in\nthe \u003ca href=\"../description.html#Interactivity\"\u003einteractive system\u003c/a\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type lambda =\n  | Lambda of string * lambda\n  | Var of string\n  | Apply of lambda * lambda\ntype lambda =\n    Lambda of string * lambda\n  | Var of string\n  | Apply of lambda * lambda\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI use the format library to print the lambda-terms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eopen Format\nlet ident = print_string\nlet kwd = print_string\n\nlet rec print_exp0 = function\n  | Var s -\u0026gt;  ident s\n  | lam -\u0026gt; open_hovbox 1; kwd \u0026quot;(\u0026quot;; print_lambda lam; kwd \u0026quot;)\u0026quot;; close_box ()\nand print_app = function\n  | e -\u0026gt; open_hovbox 2; print_other_applications e; close_box ()\nand print_other_applications f =\n  match f with\n  | Apply (f, arg) -\u0026gt; print_app f; print_space (); print_exp0 arg\n  | f -\u0026gt; print_exp0 f\nand print_lambda = function\n  | Lambda (s, lam) -\u0026gt;\n      open_hovbox 1;\n      kwd \u0026quot;\\\\\u0026quot;; ident s; kwd \u0026quot;.\u0026quot;; print_space(); print_lambda lam;\n      close_box()\n  | e -\u0026gt; print_app e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn Caml Light, replace the first line by:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e#open \u0026quot;format\u0026quot;;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"most-general-pretty-printing-using-fprintf\"\u003eMost general pretty-printing: using \u003ccode\u003efprintf\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eWe use the \u003ccode\u003efprintf\u003c/code\u003e function to write the most versatile version of the\npretty-printing functions for lambda-terms. Now, the functions get an\nextra argument, namely a pretty-printing formatter (the \u003ccode\u003eppf\u003c/code\u003e argument)\nwhere printing will occur. This way the printing routines are more\ngeneral, since they can print on any formatter defined in the program\n(either printing to a file, or to \u003ccode\u003estdout\u003c/code\u003e, to \u003ccode\u003estderr\u003c/code\u003e, or even to a\nstring). Furthermore, the pretty-printing functions are now\ncompositional, since they may be used in conjunction with the special\n\u003ccode\u003e%a\u003c/code\u003e conversion, that prints a \u003ccode\u003efprintf\u003c/code\u003e argument with a user's supplied\nfunction (these user's supplied functions also have a formatter as first\nargument).\u003c/p\u003e\n\u003cp\u003eUsing \u003ccode\u003efprintf\u003c/code\u003e, the lambda-terms printing routines can be written as\nfollows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eopen Format\n\nlet ident ppf s = fprintf ppf \u0026quot;%s\u0026quot; s\nlet kwd ppf s = fprintf ppf \u0026quot;%s\u0026quot; s\n\nlet rec pr_exp0 ppf = function\n  | Var s -\u0026gt; fprintf ppf \u0026quot;%a\u0026quot; ident s\n  | lam -\u0026gt; fprintf ppf \u0026quot;@[\u0026lt;1\u0026gt;(%a)@]\u0026quot; pr_lambda lam\nand pr_app ppf e =\n  fprintf ppf \u0026quot;@[\u0026lt;2\u0026gt;%a@]\u0026quot; pr_other_applications e\nand pr_other_applications ppf f =\n  match f with\n  | Apply (f, arg) -\u0026gt; fprintf ppf \u0026quot;%a@ %a\u0026quot; pr_app f pr_exp0 arg\n  | f -\u0026gt; pr_exp0 ppf f\nand pr_lambda ppf = function\n  | Lambda (s, lam) -\u0026gt;\n     fprintf ppf \u0026quot;@[\u0026lt;1\u0026gt;%a%a%a@ %a@]\u0026quot;\n             kwd \u0026quot;\\\\\u0026quot; ident s kwd \u0026quot;.\u0026quot; pr_lambda lam\n  | e -\u0026gt; pr_app ppf e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGiven those general printing routines, procedures to print to \u003ccode\u003estdout\u003c/code\u003e\nor \u003ccode\u003estderr\u003c/code\u003e is just a matter of partial application:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet print_lambda = pr_lambda std_formatter\nlet eprint_lambda = pr_lambda err_formatter\n\u003c/code\u003e\u003c/pre\u003e\n"},{"title":"Calling C Libraries","slug":"calling-c-libraries","description":"Cross the divide and call C code from your OCaml program\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"interoperability","tl":0},"users":{"hd":"Advanced","tl":0},"body_md":"\n## MiniGtk\nWhile the structure of lablgtk outlined in [Introduction to\nGtk](introduction_to_gtk.html \"Introduction to Gtk\") seems perhaps\nover-complex, it's worth considering exactly why the author chose two\nlayers. To appreciate this, you really need to get your hands dirty and\nlook at other ways that a Gtk wrapper might have been written.\n\nTo this end I played around with something I call\n\u003cdfn\u003eMiniGtk\u003c/dfn\u003e, intended as a simple Gtk wrapper. All MiniGtk is\ncapable of is opening a window with a label, but after writing MiniGtk I\nhad renewed respect for the author of lablgtk!\n\nMiniGtk is also a good tutorial for people who want to write OCaml\nbindings around their favorite C library. If you've ever tried to write\nbindings for Python or Java, you'll find doing the same for OCaml is\nsurprisingly easy, although you do have to worry a bit about the garbage\ncollector.\n\nLet's talk first about how MiniGtk is structured: rather than using a\ntwo layered approach as with lablgtk, I wanted to implement MiniGtk\nusing a single (object-oriented) layer. This means that MiniGtk consists\nof a bunch of class definitions. Methods in those classes pretty much\ndirectly translate into calls to the C `libgtk-1.2.so` library.\n\nI also wanted to rationalise the module naming scheme for Gtk. So there\nis exactly one top-level module called (surprise!) `Gtk` and all classes\nare inside this module. A test program looks like this:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet win = new Gtk.window ~title:\"My window\" ();;\nlet lbl = new Gtk.label ~text:\"Hello\" ();;\nwin#add lbl;;\n\nlet () =\n  Gtk.main ()\n```\nI defined a single abstract type to cover all `GtkObject`s (and\n\"subclasses\" of this C structure). In the `Gtk` module you'll find this\ntype definition:\n\n```ocaml\ntype obj\n```\n\nAs discussed in the last chapter, this defines an abstract type of which\nit is impossible to create any instances. In OCaml, at least. Certain C\nfunctions are going to create instances of this type. For instance, the\nfunction which creates new labels (ie. `GtkLabel` structures) is defined\nthis way:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nexternal gtk_label_new : string -\u003e obj = \"gtk_label_new_c\"\n```\n\nThis strange function definition defines an \u003cdfn\u003eexternal\nfunction\u003c/dfn\u003e, one coming from C. The C function is called\n`gtk_label_new_c`, and it takes a string and returns one of our abstract\n`obj` types.\n\nOCaml doesn't quite let you call *any* C function yet. You need to write\na little C wrapper around the library's function to translate to and\nfrom OCaml's internal types and C types. `gtk_label_new_c` (note the\nadditional `_c`) is my wrapper around the real Gtk C function called\n`gtk_label_new`. Here it is. I'll explain more about it later.\n\n```C\nCAMLprim value\ngtk_label_new_c (value str)\n{\n  CAMLparam1 (str);\n  CAMLreturn (wrap (GTK_OBJECT (\n    gtk_label_new (String_val (str)))));\n }\n```\nBefore explaining this function further, I'm going to take a step back\nand look at the hierarchy of our Gtk classes. I've chosen to reflect the\nactual Gtk widget hierarchy as closely as possible. All Gtk widgets are\nderived from a virtual base class called `GtkObject`. In fact from this\nclass is derived `GtkWidget` and the whole variety of Gtk widgets are\nderived from this. So we define our own `GtkObject` equivalent class\nlike this (note that `object` is a reserved word in OCaml).\n\n```ocaml\ntype obj\n\nclass virtual gtk_object (obj : obj) =\nobject (self)\n  val obj = obj\n  method obj = obj\nend\n```\n\n`type obj` defines our abstract object type, and `class gtk_object`\ntakes one of these \"things\" as a parameter to its constructor. Recall\nfrom above that this parameter is actually the C `GtkObject` structure\n(in fact it's a specially wrapped pointer to this structure).\n\nYou can't create `gtk_object` instances directly because it's a virtual\nclass, but if you could you'd have to construct them like this:\n`new gtk_object obj`. What would you pass as that `obj` parameter? You'd\npass the return value of, for instance, `gtk_label_new` (go back and\nhave a look at how that `external` function was typed). This is shown\nbelow:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\n(* Example code, not really part of MiniGtk! *)\nclass label text =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit gtk_object obj\n  end\n```\n\nOf course the real `label` class doesn't inherit directly from\n`gtk_object` as shown above, but in principle this is how it works.\n\nFollowing the Gtk class hierarchy the only class derived directly from\n`gtk_object` is our `widget` class, defined like this:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nexternal gtk_widget_show : obj -\u003e unit = \"gtk_widget_show_c\"\nexternal gtk_widget_show_all : obj -\u003e unit = \"gtk_widget_show_all_c\"\n\nclass virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    method show = gtk_widget_show obj\n    method show_all = gtk_widget_show_all obj\n    initializer if show \u003c\u003e Some false then self#show\n  end\n```\nThis class is considerably more complex. Let's look at the\ninitialization code first:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nclass virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    initializer\n      if show \u003c\u003e Some false then self#show\n  end\n```\n\nThe `initializer` section may well be new to you. This is code which\nruns when an object is being created - the equivalent of a constructor\nin other languages. In this case we check the boolean optional `show`\nargument and unless the user specified it explicitly as `false` we\nautomatically call the `#show` method. (All Gtk widgets need to be\n\"shown\" after being created unless you want a widget to be created but\nhidden).\n\nThe actual definition of the methods happens with the help of a couple\nof external functions. These are basically direct calls to the C library\n(well, in fact there's a tiny bit of wrapper code, but that's not\nfunctionally important).\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nmethod show = gtk_widget_show obj\nmethod show_all = gtk_widget_show_all obj\n```\n\nNotice that we pass the underlying `GtkObject` to both C library calls.\nThis makes sense because these functions are prototyped as\n`void gtk_widget_show (GtkWidget *);` in C (`GtkWidget` and `GtkObject`\nare safely used interchangeably in this context).\n\nI want to describe the `label` class (the real one this time!), but in\nbetween `widget` and `label` is `misc`, a generic class which describes\na large class of miscellaneous widgets. This class just adds padding and\nalignment around a widget such as a label. Here is its definition:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet may f x =\n  match x with\n  | None -\u003e ()\n  | Some x -\u003e f x\n\nexternal gtk_misc_set_alignment :\n  obj -\u003e float * float -\u003e unit = \"gtk_misc_set_alignment_c\"\nexternal gtk_misc_set_padding :\n  obj -\u003e int * int -\u003e unit = \"gtk_misc_set_padding_c\"\n\nclass virtual misc ?alignment ?padding ?show obj =\n  object (self)\n    inherit widget ?show obj\n    method set_alignment = gtk_misc_set_alignment obj\n    method set_padding = gtk_misc_set_padding obj\n    initializer\n      may (gtk_misc_set_alignment obj) alignment;\n      may (gtk_misc_set_padding obj) padding\n  end\n```\n\nWe start with a helper function called\n`may : ('a -\u003e unit) -\u003e 'a option -\u003e unit` which invokes its first\nargument on the contents of its second unless the second argument is\n`None`. This trick (stolen from lablgtk of course) is very useful when\ndealing with optional arguments as we'll see.\n\nThe methods in `misc` should be straightforward. What is tricky is the\ninitialization code. First notice that we take optional `alignment` and\n`padding` arguments to the constructor, and we pass the optional `show`\nand mandatory `obj` arguments directly up to `widget`. What do we do\nwith the optional `alignment` and `padding`? The initializer uses these:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\ninitializer\n  may (gtk_misc_set_alignment obj) alignment;\n  may (gtk_misc_set_padding obj) padding \n```\n\nIt's that tricky `may` function in action. *If* the user gave an\n`alignment` argument, then this will set the alignment on the object by\ncalling `gtk_misc_set_alignment obj the_alignment`. But more commonly\nthe user will omit the `alignment` argument, in which case `alignment`\nis `None` and this does nothing. (In effect we get Gtk's default\nalignment, whatever that is). A similar thing happens with the\n`padding`. Note there is a certain simplicity and elegance in the way\nthis is done.\n\nNow we can finally get to the `label` class, which is derived directly\nfrom `misc`:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nexternal gtk_label_new :\n    string -\u003e obj  = \"gtk_label_new_c\"\nexternal gtk_label_set_text :\n    obj -\u003e string -\u003e unit = \"gtk_label_set_text_c\"\nexternal gtk_label_set_justify :\n    obj -\u003e Justification.t -\u003e unit = \"gtk_label_set_justify_c\"\nexternal gtk_label_set_pattern :\n    obj -\u003e string -\u003e unit = \"gtk_label_set_pattern_c\"\nexternal gtk_label_set_line_wrap :\n    obj -\u003e bool -\u003e unit = \"gtk_label_set_line_wrap_c\"\n\nclass label ~text\n  ?justify ?pattern ?line_wrap ?alignment\n  ?padding ?show () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ?alignment ?padding ?show obj\n    method set_text = gtk_label_set_text obj\n    method set_justify = gtk_label_set_justify obj\n    method set_pattern = gtk_label_set_pattern obj\n    method set_line_wrap = gtk_label_set_line_wrap obj\n    initializer\n      may (gtk_label_set_justify obj) justify;\n      may (gtk_label_set_pattern obj) pattern;\n      may (gtk_label_set_line_wrap obj) line_wrap\n  end\n```\nAlthough this class is bigger than the ones we've looked at up til now,\nit's really more of the same idea, *except* that this class isn't\nvirtual. You can create instances of this class which means it finally\nhas to call `gtk_..._new`. This is the initialization code (we discussed\nthis pattern above):\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nclass label ~text ... () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ... obj\n  end\n```\n(Pop quiz: what happens if we need to define a class which is both a\nbase class from which other classes can be derived, and is also a\nnon-virtual class of which the user should be allowed to create\ninstances?)\n\n####  Wrapping calls to C libraries\nNow we'll look in more detail at actually wrapping up calls to C library\nfunctions. Here's a simple example:\n\n```C\n/* external gtk_label_set_text :\n     obj -\u003e string -\u003e unit\n       = \"gtk_label_set_text_c\" */\n\nCAMLprim value\ngtk_label_set_text_c (value obj, value str)\n{\n  CAMLparam2 (obj, str);\n  gtk_label_set_text (unwrap (GtkLabel, obj),\n    String_val (str));\n  CAMLreturn (Val_unit);\n}\n```\nComparing the OCaml prototype for the external function call (in the\ncomment) with the definition of the function we can see two things:\n\n* The C function that OCaml calls is named `\"gtk_label_set_text_c\"`.\n* Two arguments are passed (`value obj` and `value str`) and a unit is\n returned.\n\nValues are OCaml's internal representation of all sorts of things from\nsimple integers through to strings and even objects. I'm not going to go\ninto any great detail about the `value` type because it is more than\nadequately covered in the OCaml manual. To use `value` you need to just\nknow what macros are available to convert between a `value` and some C\ntype. The macros look like this:\n\n\u003cdl\u003e \u003cdt\u003e`String_val (val)`\u003c/dt\u003e \u003cdd\u003e Convert from a `value`\nwhich is known to be a string to a C string (ie. `char *`). \u003c/dd\u003e\n\u003cdt\u003e`Val_unit`\u003c/dt\u003e \u003cdd\u003e The OCaml unit `()` as a `value`. \u003c/dd\u003e\n\u003cdt\u003e`Int_val (val)`\u003c/dt\u003e \u003cdd\u003e Convert from a `value` which\nis known to be an integer to a C `int`. \u003c/dd\u003e\n\u003cdt\u003e`Val_int (i)`\u003c/dt\u003e \u003cdd\u003e Convert from a C integer `i` into an\ninteger `value`. \u003c/dd\u003e \u003cdt\u003e`Bool_val (val)`\u003c/dt\u003e \u003cdd\u003e Convert\nfrom a `value` which is known to be a boolean to a C boolean (ie. an\n`int`). \u003c/dd\u003e \u003cdt\u003e`Val_bool (i)`\u003c/dt\u003e \u003cdd\u003e Convert from a C\ninteger `i` into a boolean `value`. \u003c/dd\u003e \u003c/dl\u003e\n\nYou can guess the others or consult the manual. Note that there is no\nstraightforward conversion from C `char *` to a value. This involves\nallocating memory, which is somewhat more complicated.\n\nIn `gtk_label_set_text_c` above, the `external` definition, plus strong\ntyping and type inference, has already ensured that the arguments are of\nthe correct type, so to convert `value str` to a C `char *` we called\n`String_val (str)`.\n\nThe other parts of the function are a bit stranger. To ensure that the\ngarbage collector \"knows\" that your C function is still using `obj` and\n`str` while the C function is running (remember that the garbage\ncollector might be triggered within your C function by a number of\nevents - a callback to OCaml or using one of OCaml's allocation\nfunctions), you need to frame the function to add code to tell the\ngarbage collector about the \"roots\" that you're using. And tell the\ngarbage collector when you finish using those roots too, of course. This\nis done by framing the function within `CAMLparamN` ... `CAMLreturn`.\nHence:\n\n```C\nCAMLparam2 (obj, str);\n...\nCAMLreturn (Val_unit); \n```\n\n`CAMLparam2` is a macro saying that you're using two `value` parameters.\n(There is another macro for annotating local `value` variables too). You\nneed to use `CAMLreturn` instead of plain `return` which tells the GC\nyou've finished with those roots. It might be instructive to examine\nwhat code is inlined when you write `CAMLparam2 (obj, str)`. This is the\ngenerated code (with the author's version of OCaml, so it might vary\nbetween implementations slightly):\n\n```C\nstruct caml__roots_block *caml__frame\n    = local_roots;\nstruct caml__roots_block caml__roots_obj;\n\ncaml__roots_obj.next = local_roots;\nlocal_roots = \u0026caml__roots_obj;\ncaml__roots_obj.nitems = 1;\ncaml__roots_obj.ntables = 2;\ncaml__roots_obj.tables [0] = \u0026obj;\ncaml__roots_obj.tables [1] = \u0026str; \n```\nAnd for `CAMLreturn (foo)`:\n\n```C\nlocal_roots = caml__frame;\nreturn (foo); \n```\n\nIf you follow the code closely you'll see that `local_roots` is\nobviously a linked list of `caml__roots_block` structures. One (or more)\nof these structures is pushed onto the linked list when we enter the\nfunction, and all of these are popped back off when we leave, thus\nrestoring `local_roots` to its previous state when we leave the\nfunction. (*If* you remembered to call `CAMLreturn` instead of `return`\nof course - otherwise `local_roots` will end up pointing at\nuninitialised data on the stack with \"hilarious\" consequences).\n\nEach `caml__roots_block` structure has space for up to five `value`s\n(you can have multiple blocks, so this isn't a limitation). When the GC\nruns we can infer that it must walk through the linked list, starting at\n`local_roots`, and treat each `value` as a root for garbage collection\npurposes. The consequences of *not* declaring a `value` parameter or\nlocal `value` variable in this way would be that the garbage collector\nmight treat that variable as unreachable memory and thus reclaim it\nwhile your function is running!\n\nFinally there is the mysterious `unwrap` macro. This is one I wrote\nmyself, or rather, this is one I mostly copied from lablgtk. There are\ntwo related functions, called `wrap` and `unwrap` and as you might\npossibly have guessed, they wrap and unwrap `GtkObject`s in OCaml\n`value`s. These functions establish the somewhat magical relationship\nbetween `GtkObject` and our opaque, mysterious `obj` type which we\ndefined for OCaml (see the very first part of this chapter to remind\nyourself).\n\nThe problem is how do we wrap up (and hide) the C `GtkObject` structure\nin a way that we can pass it around as an opaque \"thing\" (`obj`) through\nour OCaml code, and hopefully pass it back later to a C function which\ncan unwrap it and retrieve the same `GtkObject` back again?\n\nIn order for it to get passed to OCaml code at all, we must somehow\nconvert it to a `value`. Luckily we can quite easily use the C API to\ncreate `value` blocks which the OCaml garbage collector *won't* examine\ntoo closely ......\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#minigtk\"\u003eMiniGtk\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"minigtk\"\u003eMiniGtk\u003c/h2\u003e\n\u003cp\u003eWhile the structure of lablgtk outlined in \u003ca href=\"introduction_to_gtk.html\" title=\"Introduction to Gtk\"\u003eIntroduction to\nGtk\u003c/a\u003e seems perhaps\nover-complex, it's worth considering exactly why the author chose two\nlayers. To appreciate this, you really need to get your hands dirty and\nlook at other ways that a Gtk wrapper might have been written.\u003c/p\u003e\n\u003cp\u003eTo this end I played around with something I call\n\u003cdfn\u003eMiniGtk\u003c/dfn\u003e, intended as a simple Gtk wrapper. All MiniGtk is\ncapable of is opening a window with a label, but after writing MiniGtk I\nhad renewed respect for the author of lablgtk!\u003c/p\u003e\n\u003cp\u003eMiniGtk is also a good tutorial for people who want to write OCaml\nbindings around their favorite C library. If you've ever tried to write\nbindings for Python or Java, you'll find doing the same for OCaml is\nsurprisingly easy, although you do have to worry a bit about the garbage\ncollector.\u003c/p\u003e\n\u003cp\u003eLet's talk first about how MiniGtk is structured: rather than using a\ntwo layered approach as with lablgtk, I wanted to implement MiniGtk\nusing a single (object-oriented) layer. This means that MiniGtk consists\nof a bunch of class definitions. Methods in those classes pretty much\ndirectly translate into calls to the C \u003ccode\u003elibgtk-1.2.so\u003c/code\u003e library.\u003c/p\u003e\n\u003cp\u003eI also wanted to rationalise the module naming scheme for Gtk. So there\nis exactly one top-level module called (surprise!) \u003ccode\u003eGtk\u003c/code\u003e and all classes\nare inside this module. A test program looks like this:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet win = new Gtk.window ~title:\u0026quot;My window\u0026quot; ();;\nlet lbl = new Gtk.label ~text:\u0026quot;Hello\u0026quot; ();;\nwin#add lbl;;\n\nlet () =\n  Gtk.main ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI defined a single abstract type to cover all \u003ccode\u003eGtkObject\u003c/code\u003es (and\n\u0026quot;subclasses\u0026quot; of this C structure). In the \u003ccode\u003eGtk\u003c/code\u003e module you'll find this\ntype definition:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype obj\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs discussed in the last chapter, this defines an abstract type of which\nit is impossible to create any instances. In OCaml, at least. Certain C\nfunctions are going to create instances of this type. For instance, the\nfunction which creates new labels (ie. \u003ccode\u003eGtkLabel\u003c/code\u003e structures) is defined\nthis way:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eexternal gtk_label_new : string -\u0026gt; obj = \u0026quot;gtk_label_new_c\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis strange function definition defines an \u003cdfn\u003eexternal\nfunction\u003c/dfn\u003e, one coming from C. The C function is called\n\u003ccode\u003egtk_label_new_c\u003c/code\u003e, and it takes a string and returns one of our abstract\n\u003ccode\u003eobj\u003c/code\u003e types.\u003c/p\u003e\n\u003cp\u003eOCaml doesn't quite let you call \u003cem\u003eany\u003c/em\u003e C function yet. You need to write\na little C wrapper around the library's function to translate to and\nfrom OCaml's internal types and C types. \u003ccode\u003egtk_label_new_c\u003c/code\u003e (note the\nadditional \u003ccode\u003e_c\u003c/code\u003e) is my wrapper around the real Gtk C function called\n\u003ccode\u003egtk_label_new\u003c/code\u003e. Here it is. I'll explain more about it later.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003eCAMLprim value\ngtk_label_new_c (value str)\n{\n  CAMLparam1 (str);\n  CAMLreturn (wrap (GTK_OBJECT (\n    gtk_label_new (String_val (str)))));\n }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBefore explaining this function further, I'm going to take a step back\nand look at the hierarchy of our Gtk classes. I've chosen to reflect the\nactual Gtk widget hierarchy as closely as possible. All Gtk widgets are\nderived from a virtual base class called \u003ccode\u003eGtkObject\u003c/code\u003e. In fact from this\nclass is derived \u003ccode\u003eGtkWidget\u003c/code\u003e and the whole variety of Gtk widgets are\nderived from this. So we define our own \u003ccode\u003eGtkObject\u003c/code\u003e equivalent class\nlike this (note that \u003ccode\u003eobject\u003c/code\u003e is a reserved word in OCaml).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype obj\n\nclass virtual gtk_object (obj : obj) =\nobject (self)\n  val obj = obj\n  method obj = obj\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003etype obj\u003c/code\u003e defines our abstract object type, and \u003ccode\u003eclass gtk_object\u003c/code\u003e\ntakes one of these \u0026quot;things\u0026quot; as a parameter to its constructor. Recall\nfrom above that this parameter is actually the C \u003ccode\u003eGtkObject\u003c/code\u003e structure\n(in fact it's a specially wrapped pointer to this structure).\u003c/p\u003e\n\u003cp\u003eYou can't create \u003ccode\u003egtk_object\u003c/code\u003e instances directly because it's a virtual\nclass, but if you could you'd have to construct them like this:\n\u003ccode\u003enew gtk_object obj\u003c/code\u003e. What would you pass as that \u003ccode\u003eobj\u003c/code\u003e parameter? You'd\npass the return value of, for instance, \u003ccode\u003egtk_label_new\u003c/code\u003e (go back and\nhave a look at how that \u003ccode\u003eexternal\u003c/code\u003e function was typed). This is shown\nbelow:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Example code, not really part of MiniGtk! *)\nclass label text =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit gtk_object obj\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOf course the real \u003ccode\u003elabel\u003c/code\u003e class doesn't inherit directly from\n\u003ccode\u003egtk_object\u003c/code\u003e as shown above, but in principle this is how it works.\u003c/p\u003e\n\u003cp\u003eFollowing the Gtk class hierarchy the only class derived directly from\n\u003ccode\u003egtk_object\u003c/code\u003e is our \u003ccode\u003ewidget\u003c/code\u003e class, defined like this:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eexternal gtk_widget_show : obj -\u0026gt; unit = \u0026quot;gtk_widget_show_c\u0026quot;\nexternal gtk_widget_show_all : obj -\u0026gt; unit = \u0026quot;gtk_widget_show_all_c\u0026quot;\n\nclass virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    method show = gtk_widget_show obj\n    method show_all = gtk_widget_show_all obj\n    initializer if show \u0026lt;\u0026gt; Some false then self#show\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis class is considerably more complex. Let's look at the\ninitialization code first:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eclass virtual widget ?show obj =\n  object (self)\n    inherit gtk_object obj\n    initializer\n      if show \u0026lt;\u0026gt; Some false then self#show\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003einitializer\u003c/code\u003e section may well be new to you. This is code which\nruns when an object is being created - the equivalent of a constructor\nin other languages. In this case we check the boolean optional \u003ccode\u003eshow\u003c/code\u003e\nargument and unless the user specified it explicitly as \u003ccode\u003efalse\u003c/code\u003e we\nautomatically call the \u003ccode\u003e#show\u003c/code\u003e method. (All Gtk widgets need to be\n\u0026quot;shown\u0026quot; after being created unless you want a widget to be created but\nhidden).\u003c/p\u003e\n\u003cp\u003eThe actual definition of the methods happens with the help of a couple\nof external functions. These are basically direct calls to the C library\n(well, in fact there's a tiny bit of wrapper code, but that's not\nfunctionally important).\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003emethod show = gtk_widget_show obj\nmethod show_all = gtk_widget_show_all obj\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that we pass the underlying \u003ccode\u003eGtkObject\u003c/code\u003e to both C library calls.\nThis makes sense because these functions are prototyped as\n\u003ccode\u003evoid gtk_widget_show (GtkWidget *);\u003c/code\u003e in C (\u003ccode\u003eGtkWidget\u003c/code\u003e and \u003ccode\u003eGtkObject\u003c/code\u003e\nare safely used interchangeably in this context).\u003c/p\u003e\n\u003cp\u003eI want to describe the \u003ccode\u003elabel\u003c/code\u003e class (the real one this time!), but in\nbetween \u003ccode\u003ewidget\u003c/code\u003e and \u003ccode\u003elabel\u003c/code\u003e is \u003ccode\u003emisc\u003c/code\u003e, a generic class which describes\na large class of miscellaneous widgets. This class just adds padding and\nalignment around a widget such as a label. Here is its definition:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet may f x =\n  match x with\n  | None -\u0026gt; ()\n  | Some x -\u0026gt; f x\n\nexternal gtk_misc_set_alignment :\n  obj -\u0026gt; float * float -\u0026gt; unit = \u0026quot;gtk_misc_set_alignment_c\u0026quot;\nexternal gtk_misc_set_padding :\n  obj -\u0026gt; int * int -\u0026gt; unit = \u0026quot;gtk_misc_set_padding_c\u0026quot;\n\nclass virtual misc ?alignment ?padding ?show obj =\n  object (self)\n    inherit widget ?show obj\n    method set_alignment = gtk_misc_set_alignment obj\n    method set_padding = gtk_misc_set_padding obj\n    initializer\n      may (gtk_misc_set_alignment obj) alignment;\n      may (gtk_misc_set_padding obj) padding\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe start with a helper function called\n\u003ccode\u003emay : ('a -\u0026gt; unit) -\u0026gt; 'a option -\u0026gt; unit\u003c/code\u003e which invokes its first\nargument on the contents of its second unless the second argument is\n\u003ccode\u003eNone\u003c/code\u003e. This trick (stolen from lablgtk of course) is very useful when\ndealing with optional arguments as we'll see.\u003c/p\u003e\n\u003cp\u003eThe methods in \u003ccode\u003emisc\u003c/code\u003e should be straightforward. What is tricky is the\ninitialization code. First notice that we take optional \u003ccode\u003ealignment\u003c/code\u003e and\n\u003ccode\u003epadding\u003c/code\u003e arguments to the constructor, and we pass the optional \u003ccode\u003eshow\u003c/code\u003e\nand mandatory \u003ccode\u003eobj\u003c/code\u003e arguments directly up to \u003ccode\u003ewidget\u003c/code\u003e. What do we do\nwith the optional \u003ccode\u003ealignment\u003c/code\u003e and \u003ccode\u003epadding\u003c/code\u003e? The initializer uses these:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003einitializer\n  may (gtk_misc_set_alignment obj) alignment;\n  may (gtk_misc_set_padding obj) padding \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt's that tricky \u003ccode\u003emay\u003c/code\u003e function in action. \u003cem\u003eIf\u003c/em\u003e the user gave an\n\u003ccode\u003ealignment\u003c/code\u003e argument, then this will set the alignment on the object by\ncalling \u003ccode\u003egtk_misc_set_alignment obj the_alignment\u003c/code\u003e. But more commonly\nthe user will omit the \u003ccode\u003ealignment\u003c/code\u003e argument, in which case \u003ccode\u003ealignment\u003c/code\u003e\nis \u003ccode\u003eNone\u003c/code\u003e and this does nothing. (In effect we get Gtk's default\nalignment, whatever that is). A similar thing happens with the\n\u003ccode\u003epadding\u003c/code\u003e. Note there is a certain simplicity and elegance in the way\nthis is done.\u003c/p\u003e\n\u003cp\u003eNow we can finally get to the \u003ccode\u003elabel\u003c/code\u003e class, which is derived directly\nfrom \u003ccode\u003emisc\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eexternal gtk_label_new :\n    string -\u0026gt; obj  = \u0026quot;gtk_label_new_c\u0026quot;\nexternal gtk_label_set_text :\n    obj -\u0026gt; string -\u0026gt; unit = \u0026quot;gtk_label_set_text_c\u0026quot;\nexternal gtk_label_set_justify :\n    obj -\u0026gt; Justification.t -\u0026gt; unit = \u0026quot;gtk_label_set_justify_c\u0026quot;\nexternal gtk_label_set_pattern :\n    obj -\u0026gt; string -\u0026gt; unit = \u0026quot;gtk_label_set_pattern_c\u0026quot;\nexternal gtk_label_set_line_wrap :\n    obj -\u0026gt; bool -\u0026gt; unit = \u0026quot;gtk_label_set_line_wrap_c\u0026quot;\n\nclass label ~text\n  ?justify ?pattern ?line_wrap ?alignment\n  ?padding ?show () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ?alignment ?padding ?show obj\n    method set_text = gtk_label_set_text obj\n    method set_justify = gtk_label_set_justify obj\n    method set_pattern = gtk_label_set_pattern obj\n    method set_line_wrap = gtk_label_set_line_wrap obj\n    initializer\n      may (gtk_label_set_justify obj) justify;\n      may (gtk_label_set_pattern obj) pattern;\n      may (gtk_label_set_line_wrap obj) line_wrap\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlthough this class is bigger than the ones we've looked at up til now,\nit's really more of the same idea, \u003cem\u003eexcept\u003c/em\u003e that this class isn't\nvirtual. You can create instances of this class which means it finally\nhas to call \u003ccode\u003egtk_..._new\u003c/code\u003e. This is the initialization code (we discussed\nthis pattern above):\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eclass label ~text ... () =\n  let obj = gtk_label_new text in\n  object (self)\n    inherit misc ... obj\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Pop quiz: what happens if we need to define a class which is both a\nbase class from which other classes can be derived, and is also a\nnon-virtual class of which the user should be allowed to create\ninstances?)\u003c/p\u003e\n\u003ch4 id=\"wrapping-calls-to-c-libraries\"\u003eWrapping calls to C libraries\u003c/h4\u003e\n\u003cp\u003eNow we'll look in more detail at actually wrapping up calls to C library\nfunctions. Here's a simple example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003e/* external gtk_label_set_text :\n     obj -\u0026gt; string -\u0026gt; unit\n       = \u0026quot;gtk_label_set_text_c\u0026quot; */\n\nCAMLprim value\ngtk_label_set_text_c (value obj, value str)\n{\n  CAMLparam2 (obj, str);\n  gtk_label_set_text (unwrap (GtkLabel, obj),\n    String_val (str));\n  CAMLreturn (Val_unit);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eComparing the OCaml prototype for the external function call (in the\ncomment) with the definition of the function we can see two things:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe C function that OCaml calls is named \u003ccode\u003e\u0026quot;gtk_label_set_text_c\u0026quot;\u003c/code\u003e.\n\u003c/li\u003e\n\u003cli\u003eTwo arguments are passed (\u003ccode\u003evalue obj\u003c/code\u003e and \u003ccode\u003evalue str\u003c/code\u003e) and a unit is\nreturned.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eValues are OCaml's internal representation of all sorts of things from\nsimple integers through to strings and even objects. I'm not going to go\ninto any great detail about the \u003ccode\u003evalue\u003c/code\u003e type because it is more than\nadequately covered in the OCaml manual. To use \u003ccode\u003evalue\u003c/code\u003e you need to just\nknow what macros are available to convert between a \u003ccode\u003evalue\u003c/code\u003e and some C\ntype. The macros look like this:\u003c/p\u003e\n\u003cdl\u003e \u003cdt\u003e`String_val (val)`\u003c/dt\u003e \u003cdd\u003e Convert from a `value`\nwhich is known to be a string to a C string (ie. `char *`). \u003c/dd\u003e\n\u003cdt\u003e`Val_unit`\u003c/dt\u003e \u003cdd\u003e The OCaml unit `()` as a `value`. \u003c/dd\u003e\n\u003cdt\u003e`Int_val (val)`\u003c/dt\u003e \u003cdd\u003e Convert from a `value` which\nis known to be an integer to a C `int`. \u003c/dd\u003e\n\u003cdt\u003e`Val_int (i)`\u003c/dt\u003e \u003cdd\u003e Convert from a C integer `i` into an\ninteger `value`. \u003c/dd\u003e \u003cdt\u003e`Bool_val (val)`\u003c/dt\u003e \u003cdd\u003e Convert\nfrom a `value` which is known to be a boolean to a C boolean (ie. an\n`int`). \u003c/dd\u003e \u003cdt\u003e`Val_bool (i)`\u003c/dt\u003e \u003cdd\u003e Convert from a C\ninteger `i` into a boolean `value`. \u003c/dd\u003e \u003c/dl\u003e\n\u003cp\u003eYou can guess the others or consult the manual. Note that there is no\nstraightforward conversion from C \u003ccode\u003echar *\u003c/code\u003e to a value. This involves\nallocating memory, which is somewhat more complicated.\u003c/p\u003e\n\u003cp\u003eIn \u003ccode\u003egtk_label_set_text_c\u003c/code\u003e above, the \u003ccode\u003eexternal\u003c/code\u003e definition, plus strong\ntyping and type inference, has already ensured that the arguments are of\nthe correct type, so to convert \u003ccode\u003evalue str\u003c/code\u003e to a C \u003ccode\u003echar *\u003c/code\u003e we called\n\u003ccode\u003eString_val (str)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe other parts of the function are a bit stranger. To ensure that the\ngarbage collector \u0026quot;knows\u0026quot; that your C function is still using \u003ccode\u003eobj\u003c/code\u003e and\n\u003ccode\u003estr\u003c/code\u003e while the C function is running (remember that the garbage\ncollector might be triggered within your C function by a number of\nevents - a callback to OCaml or using one of OCaml's allocation\nfunctions), you need to frame the function to add code to tell the\ngarbage collector about the \u0026quot;roots\u0026quot; that you're using. And tell the\ngarbage collector when you finish using those roots too, of course. This\nis done by framing the function within \u003ccode\u003eCAMLparamN\u003c/code\u003e ... \u003ccode\u003eCAMLreturn\u003c/code\u003e.\nHence:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003eCAMLparam2 (obj, str);\n...\nCAMLreturn (Val_unit); \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eCAMLparam2\u003c/code\u003e is a macro saying that you're using two \u003ccode\u003evalue\u003c/code\u003e parameters.\n(There is another macro for annotating local \u003ccode\u003evalue\u003c/code\u003e variables too). You\nneed to use \u003ccode\u003eCAMLreturn\u003c/code\u003e instead of plain \u003ccode\u003ereturn\u003c/code\u003e which tells the GC\nyou've finished with those roots. It might be instructive to examine\nwhat code is inlined when you write \u003ccode\u003eCAMLparam2 (obj, str)\u003c/code\u003e. This is the\ngenerated code (with the author's version of OCaml, so it might vary\nbetween implementations slightly):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003estruct caml__roots_block *caml__frame\n    = local_roots;\nstruct caml__roots_block caml__roots_obj;\n\ncaml__roots_obj.next = local_roots;\nlocal_roots = \u0026amp;caml__roots_obj;\ncaml__roots_obj.nitems = 1;\ncaml__roots_obj.ntables = 2;\ncaml__roots_obj.tables [0] = \u0026amp;obj;\ncaml__roots_obj.tables [1] = \u0026amp;str; \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd for \u003ccode\u003eCAMLreturn (foo)\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003elocal_roots = caml__frame;\nreturn (foo); \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you follow the code closely you'll see that \u003ccode\u003elocal_roots\u003c/code\u003e is\nobviously a linked list of \u003ccode\u003ecaml__roots_block\u003c/code\u003e structures. One (or more)\nof these structures is pushed onto the linked list when we enter the\nfunction, and all of these are popped back off when we leave, thus\nrestoring \u003ccode\u003elocal_roots\u003c/code\u003e to its previous state when we leave the\nfunction. (\u003cem\u003eIf\u003c/em\u003e you remembered to call \u003ccode\u003eCAMLreturn\u003c/code\u003e instead of \u003ccode\u003ereturn\u003c/code\u003e\nof course - otherwise \u003ccode\u003elocal_roots\u003c/code\u003e will end up pointing at\nuninitialised data on the stack with \u0026quot;hilarious\u0026quot; consequences).\u003c/p\u003e\n\u003cp\u003eEach \u003ccode\u003ecaml__roots_block\u003c/code\u003e structure has space for up to five \u003ccode\u003evalue\u003c/code\u003es\n(you can have multiple blocks, so this isn't a limitation). When the GC\nruns we can infer that it must walk through the linked list, starting at\n\u003ccode\u003elocal_roots\u003c/code\u003e, and treat each \u003ccode\u003evalue\u003c/code\u003e as a root for garbage collection\npurposes. The consequences of \u003cem\u003enot\u003c/em\u003e declaring a \u003ccode\u003evalue\u003c/code\u003e parameter or\nlocal \u003ccode\u003evalue\u003c/code\u003e variable in this way would be that the garbage collector\nmight treat that variable as unreachable memory and thus reclaim it\nwhile your function is running!\u003c/p\u003e\n\u003cp\u003eFinally there is the mysterious \u003ccode\u003eunwrap\u003c/code\u003e macro. This is one I wrote\nmyself, or rather, this is one I mostly copied from lablgtk. There are\ntwo related functions, called \u003ccode\u003ewrap\u003c/code\u003e and \u003ccode\u003eunwrap\u003c/code\u003e and as you might\npossibly have guessed, they wrap and unwrap \u003ccode\u003eGtkObject\u003c/code\u003es in OCaml\n\u003ccode\u003evalue\u003c/code\u003es. These functions establish the somewhat magical relationship\nbetween \u003ccode\u003eGtkObject\u003c/code\u003e and our opaque, mysterious \u003ccode\u003eobj\u003c/code\u003e type which we\ndefined for OCaml (see the very first part of this chapter to remind\nyourself).\u003c/p\u003e\n\u003cp\u003eThe problem is how do we wrap up (and hide) the C \u003ccode\u003eGtkObject\u003c/code\u003e structure\nin a way that we can pass it around as an opaque \u0026quot;thing\u0026quot; (\u003ccode\u003eobj\u003c/code\u003e) through\nour OCaml code, and hopefully pass it back later to a C function which\ncan unwrap it and retrieve the same \u003ccode\u003eGtkObject\u003c/code\u003e back again?\u003c/p\u003e\n\u003cp\u003eIn order for it to get passed to OCaml code at all, we must somehow\nconvert it to a \u003ccode\u003evalue\u003c/code\u003e. Luckily we can quite easily use the C API to\ncreate \u003ccode\u003evalue\u003c/code\u003e blocks which the OCaml garbage collector \u003cem\u003ewon't\u003c/em\u003e examine\ntoo closely ......\u003c/p\u003e\n"},{"title":"Calling Fortran Libraries","slug":"calling-fortran-libraries","description":"Cross the divide and call Fortran code from your OCaml program\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"interoperability","tl":0},"users":{"hd":"Advanced","tl":0},"body_md":"\nFortran isn't a language the many people write new code in but it still\nis in extensive use in the scientific communities. Many, many libraries\nexist for doing numerical calculation that will never be written in C or\nC++. It is quite possible though to call Fortran routines from OCaml as\nthey are normally compiled into the same object format, with minimal\nname mangling, as C programs.\n\nThis tutorial will step by step through the process of compiling an\ninterface module for a fortran function. The steps that are involved\nhere are the same steps as for wrapping a C function with a few\nconsiderations that have to be taken into account for Fortran.\n\nThe Fortran function is contained in a file called func.f and has the\nfollowing signature\n\n`subroutine gtd6(integer iyd, real sec, real alt, real lat, real lon, real dens(8), real temp(2))`\n\nThe `iyd`, `sec`, `alt`, `lat`, and `lon` parameters are input\nparameters while `dens` and `temp` are output parameters.\n\nAll of the examples below use the GNU Fortran 77 compiler (g77). None of\nthese have been tested with the GNU fortran 90 compiler (gfort) and will\nnot be until it has proven itself through some time.\n\n###  Step 1: Compile the Fortran routine\nWhere C/C++ have only one category of subroutine (the function), Fortran\nhas two: the function and the subroutine. The function is the equivalent\nto a non-void C function in that it takes parameters and always returns\na value. The subroutine is equivalent to a void C function.\n\nWhen g77 compiles a fortran function it creates a named function that\nhas an underscore appended. If the fortran name for the function\ncontains any underscores then the compiled function name will have two\nunderscores appended. The generated function can be called by this name.\nSubroutines will be converted into a C function that returns an int.\n\nTo compile the funcs.f file into an object file, one can use the\nfollowing:\n\n`prompt\u003e g77 -c funcs.f`\n\nWhich will generate the file 'funcs.o'. You can then see the names of\nthe compiled functions by executing\n\n`prompt\u003e nm funcs.o`\n\nIn this output you will see a line that has the following\n\n` T gtd6_ `\n\nThis shows that the function gtd6_ has been created and is in the\nobject file.\n\nFortran has support for both integer and real types and those are the\nnames that they go by. In our case we have only real and integer types.\nReals are equivalent to C doubles and integers are equivalent to C\nlongs. In addition, Fortran passes everything by reference so the\ncorresponding C prototype for our gtd6 function is\n\n` int gtd6_(integer *iyd, real* sec, real* alt, real* glat, real* glong, real* dens, real* temp);`\n\nNote that its up to the caller to know that `dens` and `temp` are\nactually arrays. Failure to pass an array will cause a segmentation\nviolation since the gtd6_ function is using them as arrays (yet another\nreason OCaml shines).\n\n###  Step 2: Create the C wrapper\nBecause OCaml's foreign function interface is C based, it is necessary\nto create a C wrapper. To avoid difficulties in passing back arrays of\nvalues, we are going to simply create a function that will return the\nsecond element of the temperature array as computed by the function and\nignore the other return values (this is a very frequent use of the\nfunction). This function will be in the source file wrapper.c.\n\n```C\nCAMLprim value gtd6_t (value iydV, value secVal, value altVal, value latVal, value lonVal) {\n   CAMLparam5( iydV, secVal, altVal, latVal, lonVal );\n   long iyd = Long_val( iydV );\n   float    sec = Double_val( secVal );\n   float    alt = Double_val( altVal );\n   float    lat = Double_val( latVal );\n   float    lon = Double_val( lonVal );\n\n   gtd6_(\u0026iyd, \u0026sec, \u0026alt, \u0026glat, \u0026glon, d, t);\n   CAMLreturn( caml_copy_double( t[1] ) );\n}\n```\nA few points of interest\n\n1. The file must include the OCaml header files `alloc.h`, `memory.h`,\n and `mlvalue.h`.\n1. The function first calls the CAMLparam5 macro. This is required at\n the start of any function that uses the CAML types.\n1. The function uses the Double_val and Long_val macros to extract\n the C types from the OCaml value object.\n1. All of the values are passed by reference to the gtd6_ routine as\n required by the prototype.\n1. The function uses the copy_caml_double function and the CAMLreturn\n macro to create a new value containing the return value and to\n return it respectively.\n\n###  Step 3: Compile the shared library.\nNow having the two source files funcs.f and wrapper.c we need to create\na shared library that can be loaded by OCaml. Its easier to do this as a\nmultistep process, so here are the commands:\n\n`prompt\u003e g77 -c funcs.f`\n\n`prompt\u003e cc -I\u003cocaml include path\u003e -c wrapper.c `\n\n`prompt\u003e cc -shared -o wrapper.so wrapper.o funcs.o -lg2c`\n\nThis will create a shared object library called wrapper.so containing\nthe fortran function and the wrapper function. The -lg2c option is\nrequired to provide the implementations of the built in fortran\nfunctions that are used.\n\n###  Step 4: Now to OCaml\nNow in an OCaml file (gtd6.ml) we have to define the external reference\nto the function and a function to call it.\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nexternal temp : int -\u003e float -\u003e float -\u003e float -\u003e float -\u003e float = \"gtd6_t\"\n\nlet () =\n  print_double (temp 1 2.0 3.0 4.0 5.0);\n  print_newline ()\n```\nThis tells OCaml that the temp function takes 5 parameters and returns a\nsingle floating point and calls the C function gtd6_t.\n\nAt this point, the steps that are given are to compile this into\nbytecode. I don't yet have much experience compiling to native so I'll\nlet some else help out (or wait until I learn how to do it).\n\n```\nprompt\u003e ocamlc -c gtd6.ml prompt\u003e ocamlc -o test gtd6.cmo wrapper.so\n```\nAnd voila, we've called the fortran function from OCaml.\n","toc_html":"","body_html":"\u003cp\u003eFortran isn't a language the many people write new code in but it still\nis in extensive use in the scientific communities. Many, many libraries\nexist for doing numerical calculation that will never be written in C or\nC++. It is quite possible though to call Fortran routines from OCaml as\nthey are normally compiled into the same object format, with minimal\nname mangling, as C programs.\u003c/p\u003e\n\u003cp\u003eThis tutorial will step by step through the process of compiling an\ninterface module for a fortran function. The steps that are involved\nhere are the same steps as for wrapping a C function with a few\nconsiderations that have to be taken into account for Fortran.\u003c/p\u003e\n\u003cp\u003eThe Fortran function is contained in a file called func.f and has the\nfollowing signature\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esubroutine gtd6(integer iyd, real sec, real alt, real lat, real lon, real dens(8), real temp(2))\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eiyd\u003c/code\u003e, \u003ccode\u003esec\u003c/code\u003e, \u003ccode\u003ealt\u003c/code\u003e, \u003ccode\u003elat\u003c/code\u003e, and \u003ccode\u003elon\u003c/code\u003e parameters are input\nparameters while \u003ccode\u003edens\u003c/code\u003e and \u003ccode\u003etemp\u003c/code\u003e are output parameters.\u003c/p\u003e\n\u003cp\u003eAll of the examples below use the GNU Fortran 77 compiler (g77). None of\nthese have been tested with the GNU fortran 90 compiler (gfort) and will\nnot be until it has proven itself through some time.\u003c/p\u003e\n\u003ch3 id=\"step-1-compile-the-fortran-routine\"\u003eStep 1: Compile the Fortran routine\u003c/h3\u003e\n\u003cp\u003eWhere C/C++ have only one category of subroutine (the function), Fortran\nhas two: the function and the subroutine. The function is the equivalent\nto a non-void C function in that it takes parameters and always returns\na value. The subroutine is equivalent to a void C function.\u003c/p\u003e\n\u003cp\u003eWhen g77 compiles a fortran function it creates a named function that\nhas an underscore appended. If the fortran name for the function\ncontains any underscores then the compiled function name will have two\nunderscores appended. The generated function can be called by this name.\nSubroutines will be converted into a C function that returns an int.\u003c/p\u003e\n\u003cp\u003eTo compile the funcs.f file into an object file, one can use the\nfollowing:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprompt\u0026gt; g77 -c funcs.f\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWhich will generate the file 'funcs.o'. You can then see the names of\nthe compiled functions by executing\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprompt\u0026gt; nm funcs.o\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eIn this output you will see a line that has the following\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eT gtd6_\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThis shows that the function gtd6_ has been created and is in the\nobject file.\u003c/p\u003e\n\u003cp\u003eFortran has support for both integer and real types and those are the\nnames that they go by. In our case we have only real and integer types.\nReals are equivalent to C doubles and integers are equivalent to C\nlongs. In addition, Fortran passes everything by reference so the\ncorresponding C prototype for our gtd6 function is\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e int gtd6_(integer *iyd, real* sec, real* alt, real* glat, real* glong, real* dens, real* temp);\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNote that its up to the caller to know that \u003ccode\u003edens\u003c/code\u003e and \u003ccode\u003etemp\u003c/code\u003e are\nactually arrays. Failure to pass an array will cause a segmentation\nviolation since the gtd6_ function is using them as arrays (yet another\nreason OCaml shines).\u003c/p\u003e\n\u003ch3 id=\"step-2-create-the-c-wrapper\"\u003eStep 2: Create the C wrapper\u003c/h3\u003e\n\u003cp\u003eBecause OCaml's foreign function interface is C based, it is necessary\nto create a C wrapper. To avoid difficulties in passing back arrays of\nvalues, we are going to simply create a function that will return the\nsecond element of the temperature array as computed by the function and\nignore the other return values (this is a very frequent use of the\nfunction). This function will be in the source file wrapper.c.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003eCAMLprim value gtd6_t (value iydV, value secVal, value altVal, value latVal, value lonVal) {\n   CAMLparam5( iydV, secVal, altVal, latVal, lonVal );\n   long iyd = Long_val( iydV );\n   float    sec = Double_val( secVal );\n   float    alt = Double_val( altVal );\n   float    lat = Double_val( latVal );\n   float    lon = Double_val( lonVal );\n\n   gtd6_(\u0026amp;iyd, \u0026amp;sec, \u0026amp;alt, \u0026amp;glat, \u0026amp;glon, d, t);\n   CAMLreturn( caml_copy_double( t[1] ) );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA few points of interest\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe file must include the OCaml header files \u003ccode\u003ealloc.h\u003c/code\u003e, \u003ccode\u003ememory.h\u003c/code\u003e,\nand \u003ccode\u003emlvalue.h\u003c/code\u003e.\n\u003c/li\u003e\n\u003cli\u003eThe function first calls the CAMLparam5 macro. This is required at\nthe start of any function that uses the CAML types.\n\u003c/li\u003e\n\u003cli\u003eThe function uses the Double_val and Long_val macros to extract\nthe C types from the OCaml value object.\n\u003c/li\u003e\n\u003cli\u003eAll of the values are passed by reference to the gtd6_ routine as\nrequired by the prototype.\n\u003c/li\u003e\n\u003cli\u003eThe function uses the copy_caml_double function and the CAMLreturn\nmacro to create a new value containing the return value and to\nreturn it respectively.\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"step-3-compile-the-shared-library\"\u003eStep 3: Compile the shared library.\u003c/h3\u003e\n\u003cp\u003eNow having the two source files funcs.f and wrapper.c we need to create\na shared library that can be loaded by OCaml. Its easier to do this as a\nmultistep process, so here are the commands:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprompt\u0026gt; g77 -c funcs.f\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprompt\u0026gt; cc -I\u0026lt;ocaml include path\u0026gt; -c wrapper.c \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprompt\u0026gt; cc -shared -o wrapper.so wrapper.o funcs.o -lg2c\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThis will create a shared object library called wrapper.so containing\nthe fortran function and the wrapper function. The -lg2c option is\nrequired to provide the implementations of the built in fortran\nfunctions that are used.\u003c/p\u003e\n\u003ch3 id=\"step-4-now-to-ocaml\"\u003eStep 4: Now to OCaml\u003c/h3\u003e\n\u003cp\u003eNow in an OCaml file (gtd6.ml) we have to define the external reference\nto the function and a function to call it.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eexternal temp : int -\u0026gt; float -\u0026gt; float -\u0026gt; float -\u0026gt; float -\u0026gt; float = \u0026quot;gtd6_t\u0026quot;\n\nlet () =\n  print_double (temp 1 2.0 3.0 4.0 5.0);\n  print_newline ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells OCaml that the temp function takes 5 parameters and returns a\nsingle floating point and calls the C function gtd6_t.\u003c/p\u003e\n\u003cp\u003eAt this point, the steps that are given are to compile this into\nbytecode. I don't yet have much experience compiling to native so I'll\nlet some else help out (or wait until I learn how to do it).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprompt\u0026gt; ocamlc -c gtd6.ml prompt\u0026gt; ocamlc -o test gtd6.cmo wrapper.so\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd voila, we've called the fortran function from OCaml.\u003c/p\u003e\n"},{"title":"Command-line Arguments","slug":"command-line-arguments","description":"The Arg module that comes with the compiler can help you write command line interfaces\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"common","tl":0},"users":{"hd":"Intermediate","tl":0},"body_md":"\nIn this tutorial we learn how to read command line arguments directly, using\nOCaml's `Sys.argv` array, and then how to do so more easily using the standard\nlibrary's `Arg` module.\n\n## Sys.argv\n\nLike in C and many other languages, the arguments that are passed to a given\nprogram on the command line are stored in an array. Following tradition, this\narray is named `argv`. It is found in the `Sys` module of the standard library,\ntherefore its full name is `Sys.argv`. The number of arguments including the\nname of the program itself is simply the length of the array. It is obtained\nusing the `Array.length` function.\n\nThe following program displays the arguments with their position in `Sys.argv`:\n\n\u003c!-- $MDX file=examples/args.ml --\u003e\n```ocaml\nlet () =\n  for i = 0 to Array.length Sys.argv - 1 do\n    Printf.printf \"[%i] %s\\n\" i Sys.argv.(i)\n  done\n```\n\nIf you save the program above as `args.ml`, and run `ocaml args.ml arg1 arg2\narg3`, here is what you get:\n\n\u003c!-- $MDX dir=examples --\u003e\n```sh\n$ ocaml args.ml arg1 arg2 arg3\n[0] args.ml\n[1] arg1\n[2] arg2\n[3] arg3\n```\n\nNote that `ocaml` launched a subprocess that actually runs the program where\nargv is `args.ml arg1 arg2 arg3`. You can also compile your program using\n`ocamlopt -o args args.ml`, and then running `./args arg1 arg2 arg3` and you\nwill get:\n\n\u003c!-- $MDX dir=examples --\u003e\n```sh\n$ ocamlopt -o args args.ml\n$ ./args arg1 arg2 arg3\n[0] ./args\n[1] arg1\n[2] arg2\n[3] arg3\n```\n\n## Using the Arg module\n\nThe OCaml standard library has a module for writing command line interfaces, so\nwe do not have to use `Sys.argv` directly. We shall consider the example from\nthe OCaml documentation, a program for appending files.\n\nFirst, we set up the usage message to be printed in the case of a malformed\ncommand line, or when help is requested:\n\n\u003c!-- $MDX file=examples/append.ml,part=0 --\u003e\n```ocaml\nlet usage_msg = \"append [-verbose] \u003cfile1\u003e [\u003cfile2\u003e] ... -o \u003coutput\u003e\"\n```\n\nNow, we create some references to hold the information gathered from the\ncommand line. The `Arg` module will fill these in for us as the command line is\nread.\n\n\u003c!-- $MDX file=examples/append.ml,part=1 --\u003e\n```ocaml\nlet verbose = ref false\n\nlet input_files = ref []\n\nlet output_file = ref \"\"\n```\n\nWe have a boolean reference for the `-verbose` flag with a default value of\n`false`. Then we have a reference to a list which will hold the names of all\nthe input files. Finally, we have a string reference into which the single\noutput file name specified by `-o` will be placed.\n\nWe will need a function to handle the anonymous inputs, that is to say the ones\nwith no flag before them. In this case these are our input file names. Our\nfunction simply adds the file name to the reference defined earlier.\n\n\u003c!-- $MDX file=examples/append.ml,part=2 --\u003e\n```ocaml\nlet anon_fun filename = input_files := filename :: !input_files\n```\n\nFinally we build the list of command line flag specifcations. Each is a tuple\nof the flag name, the action to be taken when it is encountered, and the help\nstring.\n\n\u003c!-- $MDX file=examples/append.ml,part=3 --\u003e\n```ocaml\nlet speclist =\n  [\n    (\"-verbose\", Arg.Set verbose, \"Output debug information\");\n    (\"-o\", Arg.Set_string output_file, \"Set output file name\");\n  ]\n```\n\nWe have two kinds of action here: the `Arg.Set` action which sets a boolean\nreference, and the `Arg.Set_string` action which sets a string reference. Our\n`input_files` reference will of course be updated by the `anon_fun` function\nalready defined.\n\nWe can now call `Arg.parse`, giving it our specification list, anonymous\nfunction, and usage message. Once it returns, the references will be filled\nwith all the information required to append our files.\n\n\u003c!-- $MDX file=examples/append.ml,part=4 --\u003e\n```ocaml\nlet () = Arg.parse speclist anon_fun usage_msg\n\n(* Main functionality here *)\n```\n\nLet's save our program as `append.ml` and compile it with `ocamlopt -o append\nappend.ml` and try it out:\n\n\u003c!-- $MDX dir=examples --\u003e\n```sh\n$ ocamlopt -o append append.ml\n$ ./append -verbose one.txt two.txt -o three.txt\n$ ./append one.txt two.txt\n$ ./append -quiet\n./append: unknown option '-quiet'.\nappend [-verbose] \u003cfile1\u003e [\u003cfile2\u003e] ... -o \u003coutput\u003e\n  -verbose Output debug information\n  -o Set output file name\n  -help  Display this list of options\n  --help  Display this list of options\n[2]\n$ ./append -help\nappend [-verbose] \u003cfile1\u003e [\u003cfile2\u003e] ... -o \u003coutput\u003e\n  -verbose Output debug information\n  -o Set output file name\n  -help  Display this list of options\n  --help  Display this list of options\n```\n\nHere is the whole program:\n\n```ocaml\nlet usage_msg = \"append [-verbose] \u003cfile1\u003e [\u003cfile2\u003e] ... -o \u003coutput\u003e\"\n\nlet verbose = ref false\n\nlet input_files = ref []\n\nlet output_file = ref \"\"\n\nlet anon_fun filename =\n  input_files := filename :: !input_files\n\nlet speclist =\n  [(\"-verbose\", Arg.Set verbose, \"Output debug information\");\n   (\"-o\", Arg.Set_string output_file, \"Set output file name\")]\n\nlet () =\n  Arg.parse speclist anon_fun usage_msg;\n  (* Main functionality here *)\n```\n\nThe `Arg` module has many more actions than just `Set` and `Set_string`, and\nsome lower-level function for parsing more complicated command lines.\n\n## Other tools for parsing command-line options\n\nThere are libraries with facilities different from or more extensive than the\nbuilt-in `Arg` module:\n\n* [Cmdliner](https://erratique.ch/software/cmdliner/doc/Cmdliner) is a modern\n  interface for command line processing, which also generates UNIX man pages\n  automatically.\n\n* [Clap](https://opam.ocaml.org/packages/clap/) is an imperative command line\n  parser.\n\n* [Minicli](https://opam.ocaml.org/packages/minicli/) has good support for\n  rejecting malformed command lines which others might sliently accept.\n\n* [Getopt](https://opam.ocaml.org/packages/getopt/) for OCaml is similar to\n  [GNU getopt](https://www.gnu.org/software/libc/manual/html_node/Getopt.html).\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#sysargv\"\u003eSys.argv\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#using-the-arg-module\"\u003eUsing the Arg module\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#other-tools-for-parsing-command-line-options\"\u003eOther tools for parsing command-line options\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eIn this tutorial we learn how to read command line arguments directly, using\nOCaml's \u003ccode\u003eSys.argv\u003c/code\u003e array, and then how to do so more easily using the standard\nlibrary's \u003ccode\u003eArg\u003c/code\u003e module.\u003c/p\u003e\n\u003ch2 id=\"sysargv\"\u003eSys.argv\u003c/h2\u003e\n\u003cp\u003eLike in C and many other languages, the arguments that are passed to a given\nprogram on the command line are stored in an array. Following tradition, this\narray is named \u003ccode\u003eargv\u003c/code\u003e. It is found in the \u003ccode\u003eSys\u003c/code\u003e module of the standard library,\ntherefore its full name is \u003ccode\u003eSys.argv\u003c/code\u003e. The number of arguments including the\nname of the program itself is simply the length of the array. It is obtained\nusing the \u003ccode\u003eArray.length\u003c/code\u003e function.\u003c/p\u003e\n\u003cp\u003eThe following program displays the arguments with their position in \u003ccode\u003eSys.argv\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX file=examples/args.ml --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet () =\n  for i = 0 to Array.length Sys.argv - 1 do\n    Printf.printf \u0026quot;[%i] %s\\n\u0026quot; i Sys.argv.(i)\n  done\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you save the program above as \u003ccode\u003eargs.ml\u003c/code\u003e, and run \u003ccode\u003eocaml args.ml arg1 arg2 arg3\u003c/code\u003e, here is what you get:\u003c/p\u003e\n\u003c!-- $MDX dir=examples --\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ocaml args.ml arg1 arg2 arg3\n[0] args.ml\n[1] arg1\n[2] arg2\n[3] arg3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that \u003ccode\u003eocaml\u003c/code\u003e launched a subprocess that actually runs the program where\nargv is \u003ccode\u003eargs.ml arg1 arg2 arg3\u003c/code\u003e. You can also compile your program using\n\u003ccode\u003eocamlopt -o args args.ml\u003c/code\u003e, and then running \u003ccode\u003e./args arg1 arg2 arg3\u003c/code\u003e and you\nwill get:\u003c/p\u003e\n\u003c!-- $MDX dir=examples --\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ocamlopt -o args args.ml\n$ ./args arg1 arg2 arg3\n[0] ./args\n[1] arg1\n[2] arg2\n[3] arg3\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"using-the-arg-module\"\u003eUsing the Arg module\u003c/h2\u003e\n\u003cp\u003eThe OCaml standard library has a module for writing command line interfaces, so\nwe do not have to use \u003ccode\u003eSys.argv\u003c/code\u003e directly. We shall consider the example from\nthe OCaml documentation, a program for appending files.\u003c/p\u003e\n\u003cp\u003eFirst, we set up the usage message to be printed in the case of a malformed\ncommand line, or when help is requested:\u003c/p\u003e\n\u003c!-- $MDX file=examples/append.ml,part=0 --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet usage_msg = \u0026quot;append [-verbose] \u0026lt;file1\u0026gt; [\u0026lt;file2\u0026gt;] ... -o \u0026lt;output\u0026gt;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, we create some references to hold the information gathered from the\ncommand line. The \u003ccode\u003eArg\u003c/code\u003e module will fill these in for us as the command line is\nread.\u003c/p\u003e\n\u003c!-- $MDX file=examples/append.ml,part=1 --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet verbose = ref false\n\nlet input_files = ref []\n\nlet output_file = ref \u0026quot;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe have a boolean reference for the \u003ccode\u003e-verbose\u003c/code\u003e flag with a default value of\n\u003ccode\u003efalse\u003c/code\u003e. Then we have a reference to a list which will hold the names of all\nthe input files. Finally, we have a string reference into which the single\noutput file name specified by \u003ccode\u003e-o\u003c/code\u003e will be placed.\u003c/p\u003e\n\u003cp\u003eWe will need a function to handle the anonymous inputs, that is to say the ones\nwith no flag before them. In this case these are our input file names. Our\nfunction simply adds the file name to the reference defined earlier.\u003c/p\u003e\n\u003c!-- $MDX file=examples/append.ml,part=2 --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet anon_fun filename = input_files := filename :: !input_files\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFinally we build the list of command line flag specifcations. Each is a tuple\nof the flag name, the action to be taken when it is encountered, and the help\nstring.\u003c/p\u003e\n\u003c!-- $MDX file=examples/append.ml,part=3 --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet speclist =\n  [\n    (\u0026quot;-verbose\u0026quot;, Arg.Set verbose, \u0026quot;Output debug information\u0026quot;);\n    (\u0026quot;-o\u0026quot;, Arg.Set_string output_file, \u0026quot;Set output file name\u0026quot;);\n  ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe have two kinds of action here: the \u003ccode\u003eArg.Set\u003c/code\u003e action which sets a boolean\nreference, and the \u003ccode\u003eArg.Set_string\u003c/code\u003e action which sets a string reference. Our\n\u003ccode\u003einput_files\u003c/code\u003e reference will of course be updated by the \u003ccode\u003eanon_fun\u003c/code\u003e function\nalready defined.\u003c/p\u003e\n\u003cp\u003eWe can now call \u003ccode\u003eArg.parse\u003c/code\u003e, giving it our specification list, anonymous\nfunction, and usage message. Once it returns, the references will be filled\nwith all the information required to append our files.\u003c/p\u003e\n\u003c!-- $MDX file=examples/append.ml,part=4 --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet () = Arg.parse speclist anon_fun usage_msg\n\n(* Main functionality here *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's save our program as \u003ccode\u003eappend.ml\u003c/code\u003e and compile it with \u003ccode\u003eocamlopt -o append append.ml\u003c/code\u003e and try it out:\u003c/p\u003e\n\u003c!-- $MDX dir=examples --\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ocamlopt -o append append.ml\n$ ./append -verbose one.txt two.txt -o three.txt\n$ ./append one.txt two.txt\n$ ./append -quiet\n./append: unknown option '-quiet'.\nappend [-verbose] \u0026lt;file1\u0026gt; [\u0026lt;file2\u0026gt;] ... -o \u0026lt;output\u0026gt;\n  -verbose Output debug information\n  -o Set output file name\n  -help  Display this list of options\n  --help  Display this list of options\n[2]\n$ ./append -help\nappend [-verbose] \u0026lt;file1\u0026gt; [\u0026lt;file2\u0026gt;] ... -o \u0026lt;output\u0026gt;\n  -verbose Output debug information\n  -o Set output file name\n  -help  Display this list of options\n  --help  Display this list of options\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is the whole program:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet usage_msg = \u0026quot;append [-verbose] \u0026lt;file1\u0026gt; [\u0026lt;file2\u0026gt;] ... -o \u0026lt;output\u0026gt;\u0026quot;\n\nlet verbose = ref false\n\nlet input_files = ref []\n\nlet output_file = ref \u0026quot;\u0026quot;\n\nlet anon_fun filename =\n  input_files := filename :: !input_files\n\nlet speclist =\n  [(\u0026quot;-verbose\u0026quot;, Arg.Set verbose, \u0026quot;Output debug information\u0026quot;);\n   (\u0026quot;-o\u0026quot;, Arg.Set_string output_file, \u0026quot;Set output file name\u0026quot;)]\n\nlet () =\n  Arg.parse speclist anon_fun usage_msg;\n  (* Main functionality here *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eArg\u003c/code\u003e module has many more actions than just \u003ccode\u003eSet\u003c/code\u003e and \u003ccode\u003eSet_string\u003c/code\u003e, and\nsome lower-level function for parsing more complicated command lines.\u003c/p\u003e\n\u003ch2 id=\"other-tools-for-parsing-command-line-options\"\u003eOther tools for parsing command-line options\u003c/h2\u003e\n\u003cp\u003eThere are libraries with facilities different from or more extensive than the\nbuilt-in \u003ccode\u003eArg\u003c/code\u003e module:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://erratique.ch/software/cmdliner/doc/Cmdliner\"\u003eCmdliner\u003c/a\u003e is a modern\ninterface for command line processing, which also generates UNIX man pages\nautomatically.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://opam.ocaml.org/packages/clap/\"\u003eClap\u003c/a\u003e is an imperative command line\nparser.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://opam.ocaml.org/packages/minicli/\"\u003eMinicli\u003c/a\u003e has good support for\nrejecting malformed command lines which others might sliently accept.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://opam.ocaml.org/packages/getopt/\"\u003eGetopt\u003c/a\u003e for OCaml is similar to\n\u003ca href=\"https://www.gnu.org/software/libc/manual/html_node/Getopt.html\"\u003eGNU getopt\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"},{"title":"File Manipulation","slug":"file-manipulation","description":"A guide to basic file manipulation in OCaml with the standard library\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"common","tl":0},"users":{"hd":"Beginner","tl":{"hd":"Intermediate","tl":0}},"body_md":"\nThis is a guide to basic file manipulation in OCaml using only the\nstandard library.\n\n\u003c!-- TODO: links to new API locations --\u003e\nOfficial documentation for the modules of interest:\nthe core library including the initially opened module Stdlib and Printf.\n\n## Buffered channels\nThe normal way of opening a file in OCaml returns a **channel**. There\nare two kinds of channels:\n\n* channels that write to a file: type `out_channel`\n* channels that read from a file: type `in_channel`\n\n###  Writing\nFor writing into a file, you would do this:\n\n1. Open the file to obtain an `out_channel`\n1. Write to the channel\n1. If you want to force writing to the physical device, you must flush\n the channel, otherwise writing will not take place immediately.\n1. When you are done, you can close the channel. This flushes the\n channel automatically.\n\nCommonly used functions: `open_out`, `open_out_bin`, `flush`,\n`close_out`, `close_out_noerr`\n\nStandard `out_channel`s: `stdout`, `stderr`\n\n###  Reading\nFor reading data from a file you would do this:\n\n1. Open the file to obtain an `in_channel`\n1. Read characters from the channel. Reading consumes the channel, so\n if you read a character, the channel will point to the next\n character in the file.\n1. When there are no more characters to read, the `End_of_file`\n exception is raised. Often, this is where you want to close the\n channel.\n\nCommonly used functions: `open_in`, `open_in_bin`, `close_in`,\n`close_in_noerr`\n\nStandard `in_channel`: `stdin`\n\n###  Seeking\nWhenever you write or read something to or from a channel, the current\nposition changes to the next character after what you just wrote or\nread. Occasionally, you may want to skip to a particular position in the\nfile, or restart reading from the beginning. This is possible for\nchannels that point to regular files, use `seek_in` or `seek_out`.\n\n###  Gotchas\n* Don't forget to flush your `out_channel`s if you want to actually\n write something. This is particularly important if you are writing\n to non-files such as the standard output (`stdout`) or a socket.\n* Don't forget to close any unused channel, because operating systems\n have a limit on the number of files that can be opened\n simultaneously. You must catch any exception that would occur during\n the file manipulation, close the corresponding channel, and re-raise\n the exception.\n* The `Unix` module provides access to non-buffered file descriptors\n among other things. It provides standard file descriptors that have\n the same name as the corresponding standard channels: `stdin`,\n `stdout` and `stderr`. Therefore if you do `open Unix`, you may get\n type errors. If you want to be sure that you are using the `stdout`\n channel and not the `stdout` file descriptor, you can prepend it\n with the module name where it comes from: `Stdlib.stdout`. *Note\n that most things that don't seem to belong to any module actually\n belong to the `Stdlib` module, which is automatically opened.*\n* `open_out` and `open_out_bin` truncate the given file if it already\n exists! Use `open_out_gen` if you want an alternate behavior.\n\n###  Example\n\n\u003c!-- $MDX file=examples/file_manip.ml --\u003e\n```ocaml\nlet file = \"example.dat\"\n\nlet message = \"Hello!\"\n\nlet () =\n  (* Write message to file *)\n  let oc = open_out file in\n  (* create or truncate file, return channel *)\n  Printf.fprintf oc \"%s\\n\" message;\n  (* write something *)\n  close_out oc;\n\n  (* flush and close the channel *)\n\n  (* Read file and display the first line *)\n  let ic = open_in file in\n  try\n    let line = input_line ic in\n    (* read line, discard \\n *)\n    print_endline line;\n    (* write the result to stdout *)\n    flush stdout;\n    (* write on the underlying device now *)\n    close_in ic\n    (* close the input channel *)\n  with e -\u003e\n    (* some unexpected exception occurs *)\n    close_in_noerr ic;\n    (* emergency closing *)\n    raise e\n\n(* exit with error: files are closed but channels are not flushed *)\n\n(* normal exit: all channels are flushed and closed *)\n```\n\nWe can compile and run this example: \n\n\u003c!-- $MDX dir=examples --\u003e\n```sh\n$ ocamlopt -o file_manip file_manip.ml\n$ ./file_manip\nHello!\n```\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#buffered-channels\"\u003eBuffered channels\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eThis is a guide to basic file manipulation in OCaml using only the\nstandard library.\u003c/p\u003e\n\u003c!-- TODO: links to new API locations --\u003e\n\u003cp\u003eOfficial documentation for the modules of interest:\nthe core library including the initially opened module Stdlib and Printf.\u003c/p\u003e\n\u003ch2 id=\"buffered-channels\"\u003eBuffered channels\u003c/h2\u003e\n\u003cp\u003eThe normal way of opening a file in OCaml returns a \u003cstrong\u003echannel\u003c/strong\u003e. There\nare two kinds of channels:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003echannels that write to a file: type \u003ccode\u003eout_channel\u003c/code\u003e\n\u003c/li\u003e\n\u003cli\u003echannels that read from a file: type \u003ccode\u003ein_channel\u003c/code\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"writing\"\u003eWriting\u003c/h3\u003e\n\u003cp\u003eFor writing into a file, you would do this:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eOpen the file to obtain an \u003ccode\u003eout_channel\u003c/code\u003e\n\u003c/li\u003e\n\u003cli\u003eWrite to the channel\n\u003c/li\u003e\n\u003cli\u003eIf you want to force writing to the physical device, you must flush\nthe channel, otherwise writing will not take place immediately.\n\u003c/li\u003e\n\u003cli\u003eWhen you are done, you can close the channel. This flushes the\nchannel automatically.\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eCommonly used functions: \u003ccode\u003eopen_out\u003c/code\u003e, \u003ccode\u003eopen_out_bin\u003c/code\u003e, \u003ccode\u003eflush\u003c/code\u003e,\n\u003ccode\u003eclose_out\u003c/code\u003e, \u003ccode\u003eclose_out_noerr\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eStandard \u003ccode\u003eout_channel\u003c/code\u003es: \u003ccode\u003estdout\u003c/code\u003e, \u003ccode\u003estderr\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"reading\"\u003eReading\u003c/h3\u003e\n\u003cp\u003eFor reading data from a file you would do this:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eOpen the file to obtain an \u003ccode\u003ein_channel\u003c/code\u003e\n\u003c/li\u003e\n\u003cli\u003eRead characters from the channel. Reading consumes the channel, so\nif you read a character, the channel will point to the next\ncharacter in the file.\n\u003c/li\u003e\n\u003cli\u003eWhen there are no more characters to read, the \u003ccode\u003eEnd_of_file\u003c/code\u003e\nexception is raised. Often, this is where you want to close the\nchannel.\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eCommonly used functions: \u003ccode\u003eopen_in\u003c/code\u003e, \u003ccode\u003eopen_in_bin\u003c/code\u003e, \u003ccode\u003eclose_in\u003c/code\u003e,\n\u003ccode\u003eclose_in_noerr\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eStandard \u003ccode\u003ein_channel\u003c/code\u003e: \u003ccode\u003estdin\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"seeking\"\u003eSeeking\u003c/h3\u003e\n\u003cp\u003eWhenever you write or read something to or from a channel, the current\nposition changes to the next character after what you just wrote or\nread. Occasionally, you may want to skip to a particular position in the\nfile, or restart reading from the beginning. This is possible for\nchannels that point to regular files, use \u003ccode\u003eseek_in\u003c/code\u003e or \u003ccode\u003eseek_out\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"gotchas\"\u003eGotchas\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDon't forget to flush your \u003ccode\u003eout_channel\u003c/code\u003es if you want to actually\nwrite something. This is particularly important if you are writing\nto non-files such as the standard output (\u003ccode\u003estdout\u003c/code\u003e) or a socket.\n\u003c/li\u003e\n\u003cli\u003eDon't forget to close any unused channel, because operating systems\nhave a limit on the number of files that can be opened\nsimultaneously. You must catch any exception that would occur during\nthe file manipulation, close the corresponding channel, and re-raise\nthe exception.\n\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003eUnix\u003c/code\u003e module provides access to non-buffered file descriptors\namong other things. It provides standard file descriptors that have\nthe same name as the corresponding standard channels: \u003ccode\u003estdin\u003c/code\u003e,\n\u003ccode\u003estdout\u003c/code\u003e and \u003ccode\u003estderr\u003c/code\u003e. Therefore if you do \u003ccode\u003eopen Unix\u003c/code\u003e, you may get\ntype errors. If you want to be sure that you are using the \u003ccode\u003estdout\u003c/code\u003e\nchannel and not the \u003ccode\u003estdout\u003c/code\u003e file descriptor, you can prepend it\nwith the module name where it comes from: \u003ccode\u003eStdlib.stdout\u003c/code\u003e. \u003cem\u003eNote\nthat most things that don't seem to belong to any module actually\nbelong to the \u003ccode\u003eStdlib\u003c/code\u003e module, which is automatically opened.\u003c/em\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eopen_out\u003c/code\u003e and \u003ccode\u003eopen_out_bin\u003c/code\u003e truncate the given file if it already\nexists! Use \u003ccode\u003eopen_out_gen\u003c/code\u003e if you want an alternate behavior.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"example\"\u003eExample\u003c/h3\u003e\n\u003c!-- $MDX file=examples/file_manip.ml --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet file = \u0026quot;example.dat\u0026quot;\n\nlet message = \u0026quot;Hello!\u0026quot;\n\nlet () =\n  (* Write message to file *)\n  let oc = open_out file in\n  (* create or truncate file, return channel *)\n  Printf.fprintf oc \u0026quot;%s\\n\u0026quot; message;\n  (* write something *)\n  close_out oc;\n\n  (* flush and close the channel *)\n\n  (* Read file and display the first line *)\n  let ic = open_in file in\n  try\n    let line = input_line ic in\n    (* read line, discard \\n *)\n    print_endline line;\n    (* write the result to stdout *)\n    flush stdout;\n    (* write on the underlying device now *)\n    close_in ic\n    (* close the input channel *)\n  with e -\u0026gt;\n    (* some unexpected exception occurs *)\n    close_in_noerr ic;\n    (* emergency closing *)\n    raise e\n\n(* exit with error: files are closed but channels are not flushed *)\n\n(* normal exit: all channels are flushed and closed *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can compile and run this example:\u003c/p\u003e\n\u003c!-- $MDX dir=examples --\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ocamlopt -o file_manip file_manip.ml\n$ ./file_manip\nHello!\n\u003c/code\u003e\u003c/pre\u003e\n"},{"title":"Garbage Collection","slug":"garbage-collection","description":"OCaml is a garbage collected language meaning you don't have to worry about allocating and freeing memory\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"advanced","tl":0},"users":{"hd":"Intermediate","tl":{"hd":"Advanced","tl":0}},"body_md":"\n## Garbage collection, reference counting, explicit allocation\n\nAs with all modern languages, OCaml provides a garbage collector so that\nyou don't need to explicitly allocate and free memory as in C/C++.\n\nThe OCaml garbage collector is a modern hybrid generational/incremental\ncollector which outperforms hand-allocation in most cases.\n\nWhy would garbage collection be faster than explicit memory allocation\nas in C? It's often assumed that calling `free` costs nothing. In fact\n`free` is an expensive operation which involves navigating over the\ncomplex data structures used by the memory allocator. If your program\ncalls `free` intermittently, then all of that code and data needs to be\nloaded into the cache, displacing your program code and data, each time\nyou `free` a single memory allocation. A collection strategy which frees\nmultiple memory areas in one go (such as either a pool allocator or a\nGC) pays this penalty only once for multiple allocations (thus the cost\nper allocation is much reduced).\n\nGCs also move memory areas around and compact the heap. This makes\nallocation easier, hence faster, and a smart GC can be written to\ninteract well with the L1 and L2 caches.\n\nOf course none of this precludes writing a very fast hand-allocator, but\nit's considerably harder work than most programmers realise.\n\nOCaml's garbage collector has two heaps, the **minor heap** and the\n**major heap**. This recognises a general principle: Most objects are\nsmall and allocated frequently and then immediately freed. These objects\ngo into the minor heap first, which is GCed frequently. Only some\nobjects are long lasting. These objects get promoted from the minor heap\nto the major heap after some time, and the major heap is only collected\ninfrequently.\n\nThe OCaml GC is synchronous. It doesn't run in a separate thread, and it\ncan only get called during an allocation request.\n\n###  GC vs. reference counting\nPython has a form of garbage collection, but it uses a simple scheme\ncalled **reference counting**. Simply put, each Python object keeps a\ncount of the number of other objects pointing (referencing) itself. When\nthe count falls to zero, nothing is pointing at this object, and so the\nobject can be freed.\n\nReference counting is not considered as serious garbage collection by\ncomputer scientists, yet it has one big practical advantage over full\ngarbage collectors. With reference counting, you can avoid many explicit\ncalls to `close`/`closedir` in code. Whereas in OCaml\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet read_file filename =\n  let chan = open_in filename in\n  (* read from chan *) in\nList.iter read_file files\n```\n\nCalls to `read_file` open the file but don't close it. Because OCaml\nuses a full garbage collector `chan` isn't collected until some time\nlater when the minor heap becomes full. In addition, **OCaml will not\nclose the channel when it collects the handle's memory**. So this\nprogram would eventually run out of file descriptors.\n\nYou need to be aware of this when writing OCaml code which uses files or\ndirectories or any other heavyweight object with complex finalisation.\n\nTo be fair to full garbage collection, I should mention the\ndisadvantages of reference counting schemes:\n\n* Each object needs to store a reference count. In other words there's\n a word overhead for every object. Programs use more memory, and are\n consequently slower because they are more likely to fill up the\n cache or spill into swap.\n* Reference counting is expensive - every time you manipulate pointers\n to an object you need to update and check the reference count.\n Pointer manipulation is frequent, so this slows your program and\n bloats the code size of compiled code.\n* They cannot collect so-called circular, or self-referential\n structures. I've programmed in many languages in many years and\n can't recall ever having created one of these.\n* Graph algorithms, of course, violate the previous assumption.\n\n## The Gc module\nThe `Gc` module contains some useful functions for querying and calling\nthe garbage collector from OCaml programs.\n\nHere is a program which runs and then prints out GC statistics just\nbefore quitting:\n\n\u003c!-- TODO: Probably write a GC example without dependencies --\u003e\n\n\u003c!-- $MDX file=examples/gc.ml --\u003e\n```ocaml\nlet rec iterate r x_init i =\n  if i = 1 then x_init\n  else\n    let x = iterate r x_init (i - 1) in\n    r *. x *. (1.0 -. x)\n\nlet () =\n  Random.self_init ();\n  Graphics.open_graph \" 640x480\";\n  for x = 0 to 640 do\n    let r = 4.0 *. float_of_int x /. 640.0 in\n    for i = 0 to 39 do\n      let x_init = Random.float 1.0 in\n      let x_final = iterate r x_init 500 in\n      let y = int_of_float (x_final *. 480.) in\n      Graphics.plot x y\n    done\n  done;\n  Gc.print_stat stdout\n```\n\nHere is what it printed out for me:\n\n```\nminor_words: 115926165     # Total number of words allocated\npromoted_words: 31217      # Promoted from minor -\u003e major\nmajor_words: 31902         # Large objects allocated in major directly\nminor_collections: 3538    # Number of minor heap collections\nmajor_collections: 39      # Number of major heap collections\nheap_words: 63488          # Size of the heap, in words = approx. 256K\nheap_chunks: 1\ntop_heap_words: 63488\nlive_words: 2694\nlive_blocks: 733\nfree_words: 60794\nfree_blocks: 4\nlargest_free: 31586\nfragments: 0\ncompactions: 0\n```\n\nWe can see that minor heap collections are approximately 100 times more\nfrequent than major heap collections (in this example, not necessarily\nin general). Over the lifetime of the program, an astonishing 440 MB of\nmemory was allocated, although of course most of that would have been\nimmediately freed in a minor collection. Only about 128K was promoted to\nlong-term storage on the major heap, and about another 128K consisted of\nlarge objects which would have been allocated directly onto the major\nheap.\n\nWe can instruct the GC to print out debugging messages when one of\nseveral events happen (eg. on every major collection). Try adding the\nfollowing code to the example above near the beginning:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\n# Gc.set {(Gc.get ()) with Gc.verbose = 0x01}\n```\n\n(We haven't seen the `{ expression with field = value }` form before,\nbut it should be mostly obvious what it does). The above code anyway\ncauses the GC to print a message at the start of every major collection.\n\n## Finalisation and the Weak module\nWe can write a function called a **finaliser** which is called when an\nobject is about to be freed by the GC.\n\nThe `Weak` module lets us create so-called weak pointers. A **weak\npointer** is best defined by comparing it to a \"normal pointer\". When we\nhave an ordinary OCaml object, we reference that object through a name\n(eg. `let name = ... in`) or through another object. The garbage\ncollector sees that we have a reference to that object and won't collect\nit. That's what you might call a \"normal pointer\". If, however, you hold\na weak pointer or weak reference to an object, then you hint to the\ngarbage collector that it may collect the object at any time. (Not\nnecessarily that it *will* collect the object). Some time later, when\nyou come to examine the object, you can either turn your weak pointer\ninto a normal pointer, or else you can be informed that the GC did\nactually collect the object.\n\nFinalisation and weak pointers can be used together to implement an\nin-memory object database cache. Let's imagine that we have a very large\nnumber of large user records in a file on disk. This is far too much\ndata to be loaded into memory all at once, and anyway other programs\nmight access the data on the disk, so we need to lock individual records\nwhen we hold copies of them in memory.\n\nThe *public* interface to our \"in-memory object database cache\" is going\nto be just two functions:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\ntype record = {mutable name : string; mutable address : string}\nval get_record : int -\u003e record\nval sync_records : unit -\u003e unit\n```\n\nThe `get_record` call is the only call that most programs will need to\nmake. It gets the n\u003csup\u003eth\u003c/sup\u003e record either out of the cache or from\ndisk and returns it. The program can then read and/or update the\n`record.name` and `record.address` fields. The program then just\nliterally forgets about the record! Behind the scenes, finalisation is\ngoing to write the record back out to disk at some later point in time.\n\nThe `sync_records` function can also be called by user programs. This\nfunction synchronises the disk copy and in-memory copies of all records.\n\nOCaml doesn't currently run finalisers at exit. However you can easily\nforce it to by adding the following command to your code. This command\ncauses a full major GC cycle on exit:\n\n\u003c!-- $MDX skip --\u003e\n```ocaml\nat_exit Gc.full_major\n```\n\nOur code is also going to implement a cache of recently accessed records\nusing the `Weak` module. The advantage of using the `Weak` module rather\nthan hand-rolling our own code is two-fold: Firstly the garbage\ncollector has a global view of memory requirements for the whole\nprogram, and so is in a better position to decide when to shrink the\ncache. Secondly our code will be much simpler.\n\nFor our example, we're going to use a very simple format for the file of\nusers' records. The file is just a list of user records, each user\nrecord having a fixed size of 256 bytes. Each user record has just two\nfields (padded with spaces if necessary), the name field (64 bytes) and\nthe address field (192 bytes). Before a record can be loaded into\nmemory, the program must acquire an exclusive lock on the record. After\nthe in-memory copy is written back out to the file, the program must\nrelease the lock. Here is some code to define the on-disk format and\nsome low-level functions to read, write, lock and unlock records:\n\n\n\u003c!-- $MDX file=examples/objcache.ml,part=0 --\u003e\n```ocaml\n(* In-memory format. *)\ntype record = { mutable name : string; mutable address : string }\n\n(* On-disk format. *)\nlet record_size = 256\n\nlet name_size = 64\n\nlet addr_size = 192\n\n(* Low-level load/save records to file. *)\nlet seek_record n fd = ignore (Unix.lseek fd (n * record_size) Unix.SEEK_SET)\n\nlet write_record record n fd =\n  seek_record n fd;\n  ignore (Unix.write fd (Bytes.of_string record.name) 0 name_size);\n  ignore (Unix.write fd (Bytes.of_string record.address) 0 addr_size)\n\nlet read_record record n fd =\n  seek_record n fd;\n  ignore (Unix.read fd (Bytes.of_string record.name) 0 name_size);\n  ignore (Unix.read fd (Bytes.of_string record.address) 0 addr_size)\n\n(* Lock/unlock the nth record in a file. *)\nlet lock_record n fd =\n  seek_record n fd;\n  Unix.lockf fd Unix.F_LOCK record_size\n\nlet unlock_record n fd =\n  seek_record n fd;\n  Unix.lockf fd Unix.F_ULOCK record_size\n```\n\nWe also need a function to create new, empty in-memory `record` objects:\n\n\u003c!-- $MDX file=examples/objcache.ml,part=1 --\u003e\n```ocaml\n(* Create a new, empty record. *)\nlet new_record () =\n  { name = String.make name_size ' '; address = String.make addr_size ' ' }\n```\n\n\nBecause this is a really simple program, we're going to fix the number\nof records in advance:\n\n\u003c!-- $MDX file=examples/objcache.ml,part=2 --\u003e\n```ocaml\n(* Total number of records. *)\nlet nr_records = 10000\n\n(* On-disk file. *)\nlet diskfile = Unix.openfile \"users.bin\" [ Unix.O_RDWR; Unix.O_CREAT ] 0o666\n```\n\nDownload [users.bin.gz](users.bin.gz) and decompress it before\nrunning the program.\n\nOur cache of records is very simple:\n\n\u003c!-- $MDX file=examples/objcache.ml,part=3 --\u003e\n```ocaml\n(* Cache of records. *)\nlet cache = Weak.create nr_records\n```\n\nThe `get_record` function is very short and basically composed of two\nhalves. We grab the record from the cache. If the cache gives us `None`,\nthen that either means that we haven't loaded this record from the cache\nyet, or else it has been written out to disk (finalised) and dropped\nfrom the cache. If the cache gives us `Some record` then we just return\n`record` (this promotes the weak pointer to the record to a normal\npointer).\n\n\n\u003c!-- $MDX file=examples/objcache.ml,part=4 --\u003e\n```ocaml\n(* The finaliser function. *)\nlet finaliser n record =\n  printf \"*** objcache: finalising record %d\\n%!\" n;\n  write_record record n diskfile;\n  unlock_record n diskfile\n\n(* Get a record from the cache or off disk. *)\nlet get_record n =\n  match Weak.get cache n with\n  | Some record -\u003e\n      printf \"*** objcache: fetching record %d from memory cache\\n%!\" n;\n      record\n  | None -\u003e\n      printf \"*** objcache: loading record %d from disk\\n%!\" n;\n      let record = new_record () in\n      Gc.finalise (finaliser n) record;\n      lock_record n diskfile;\n      read_record record n diskfile;\n      Weak.set cache n (Some record);\n      record\n```\n\nThe `sync_records` function is even easier. First of all it empties the\ncache by replacing all the weak pointers with `None`. This now means\nthat the garbage collector *can* collect and finalise all of those\nrecords. But it doesn't necessarily mean that the GC *will* collect the\nrecords straightaway (in fact it's not likely that it will), so to force\nthe GC to collect the records immediately, we also invoke a major cycle:\n\n\nFinally we have some test code. I won't reproduce the test code, but you\ncan download the complete program and test code\n[objcache.ml](objcache.ml), and compile it with:\n\n\u003c!-- $MDX dir=examples --\u003e\n```sh\n$ ocamlc unix.cma objcache.ml -o objcache\n```\n\n## Exercises\nHere are some ways to extend the example above, in approximately\nincreasing order of difficulty:\n\n1. Implement the record as an **object**, and allow it to transparently\n pad/unpad strings. You will need to provide methods to set and get\n the name and address fields (four public methods in all). Hide as\n much of the implementation (file access, locking) code in the class\n as possible.\n1. Extend the program so that it acquires a **read lock** on getting\n the record, but upgrades this to a **write lock** just before the\n user updates any field.\n1. Support a **variable number of records** and add a function to\n create a new record (in the file). [Tip: OCaml has support for weak\n hashtables.]\n1. Add support for **variable-length records**.\n1. Make the underlying file representation a **DBM-style hash**.\n1. Provide a general-purpose cache fronting a \"users\" table in your\n choice of **relational database** (with locking).\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#garbage-collection-reference-counting-explicit-allocation\"\u003eGarbage collection, reference counting, explicit allocation\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-gc-module\"\u003eThe Gc module\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#finalisation-and-the-weak-module\"\u003eFinalisation and the Weak module\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#exercises\"\u003eExercises\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"garbage-collection-reference-counting-explicit-allocation\"\u003eGarbage collection, reference counting, explicit allocation\u003c/h2\u003e\n\u003cp\u003eAs with all modern languages, OCaml provides a garbage collector so that\nyou don't need to explicitly allocate and free memory as in C/C++.\u003c/p\u003e\n\u003cp\u003eThe OCaml garbage collector is a modern hybrid generational/incremental\ncollector which outperforms hand-allocation in most cases.\u003c/p\u003e\n\u003cp\u003eWhy would garbage collection be faster than explicit memory allocation\nas in C? It's often assumed that calling \u003ccode\u003efree\u003c/code\u003e costs nothing. In fact\n\u003ccode\u003efree\u003c/code\u003e is an expensive operation which involves navigating over the\ncomplex data structures used by the memory allocator. If your program\ncalls \u003ccode\u003efree\u003c/code\u003e intermittently, then all of that code and data needs to be\nloaded into the cache, displacing your program code and data, each time\nyou \u003ccode\u003efree\u003c/code\u003e a single memory allocation. A collection strategy which frees\nmultiple memory areas in one go (such as either a pool allocator or a\nGC) pays this penalty only once for multiple allocations (thus the cost\nper allocation is much reduced).\u003c/p\u003e\n\u003cp\u003eGCs also move memory areas around and compact the heap. This makes\nallocation easier, hence faster, and a smart GC can be written to\ninteract well with the L1 and L2 caches.\u003c/p\u003e\n\u003cp\u003eOf course none of this precludes writing a very fast hand-allocator, but\nit's considerably harder work than most programmers realise.\u003c/p\u003e\n\u003cp\u003eOCaml's garbage collector has two heaps, the \u003cstrong\u003eminor heap\u003c/strong\u003e and the\n\u003cstrong\u003emajor heap\u003c/strong\u003e. This recognises a general principle: Most objects are\nsmall and allocated frequently and then immediately freed. These objects\ngo into the minor heap first, which is GCed frequently. Only some\nobjects are long lasting. These objects get promoted from the minor heap\nto the major heap after some time, and the major heap is only collected\ninfrequently.\u003c/p\u003e\n\u003cp\u003eThe OCaml GC is synchronous. It doesn't run in a separate thread, and it\ncan only get called during an allocation request.\u003c/p\u003e\n\u003ch3 id=\"gc-vs-reference-counting\"\u003eGC vs. reference counting\u003c/h3\u003e\n\u003cp\u003ePython has a form of garbage collection, but it uses a simple scheme\ncalled \u003cstrong\u003ereference counting\u003c/strong\u003e. Simply put, each Python object keeps a\ncount of the number of other objects pointing (referencing) itself. When\nthe count falls to zero, nothing is pointing at this object, and so the\nobject can be freed.\u003c/p\u003e\n\u003cp\u003eReference counting is not considered as serious garbage collection by\ncomputer scientists, yet it has one big practical advantage over full\ngarbage collectors. With reference counting, you can avoid many explicit\ncalls to \u003ccode\u003eclose\u003c/code\u003e/\u003ccode\u003eclosedir\u003c/code\u003e in code. Whereas in OCaml\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet read_file filename =\n  let chan = open_in filename in\n  (* read from chan *) in\nList.iter read_file files\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCalls to \u003ccode\u003eread_file\u003c/code\u003e open the file but don't close it. Because OCaml\nuses a full garbage collector \u003ccode\u003echan\u003c/code\u003e isn't collected until some time\nlater when the minor heap becomes full. In addition, \u003cstrong\u003eOCaml will not\nclose the channel when it collects the handle's memory\u003c/strong\u003e. So this\nprogram would eventually run out of file descriptors.\u003c/p\u003e\n\u003cp\u003eYou need to be aware of this when writing OCaml code which uses files or\ndirectories or any other heavyweight object with complex finalisation.\u003c/p\u003e\n\u003cp\u003eTo be fair to full garbage collection, I should mention the\ndisadvantages of reference counting schemes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEach object needs to store a reference count. In other words there's\na word overhead for every object. Programs use more memory, and are\nconsequently slower because they are more likely to fill up the\ncache or spill into swap.\n\u003c/li\u003e\n\u003cli\u003eReference counting is expensive - every time you manipulate pointers\nto an object you need to update and check the reference count.\nPointer manipulation is frequent, so this slows your program and\nbloats the code size of compiled code.\n\u003c/li\u003e\n\u003cli\u003eThey cannot collect so-called circular, or self-referential\nstructures. I've programmed in many languages in many years and\ncan't recall ever having created one of these.\n\u003c/li\u003e\n\u003cli\u003eGraph algorithms, of course, violate the previous assumption.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"the-gc-module\"\u003eThe Gc module\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eGc\u003c/code\u003e module contains some useful functions for querying and calling\nthe garbage collector from OCaml programs.\u003c/p\u003e\n\u003cp\u003eHere is a program which runs and then prints out GC statistics just\nbefore quitting:\u003c/p\u003e\n\u003c!-- TODO: Probably write a GC example without dependencies --\u003e\n\u003c!-- $MDX file=examples/gc.ml --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec iterate r x_init i =\n  if i = 1 then x_init\n  else\n    let x = iterate r x_init (i - 1) in\n    r *. x *. (1.0 -. x)\n\nlet () =\n  Random.self_init ();\n  Graphics.open_graph \u0026quot; 640x480\u0026quot;;\n  for x = 0 to 640 do\n    let r = 4.0 *. float_of_int x /. 640.0 in\n    for i = 0 to 39 do\n      let x_init = Random.float 1.0 in\n      let x_final = iterate r x_init 500 in\n      let y = int_of_float (x_final *. 480.) in\n      Graphics.plot x y\n    done\n  done;\n  Gc.print_stat stdout\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is what it printed out for me:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eminor_words: 115926165     # Total number of words allocated\npromoted_words: 31217      # Promoted from minor -\u0026gt; major\nmajor_words: 31902         # Large objects allocated in major directly\nminor_collections: 3538    # Number of minor heap collections\nmajor_collections: 39      # Number of major heap collections\nheap_words: 63488          # Size of the heap, in words = approx. 256K\nheap_chunks: 1\ntop_heap_words: 63488\nlive_words: 2694\nlive_blocks: 733\nfree_words: 60794\nfree_blocks: 4\nlargest_free: 31586\nfragments: 0\ncompactions: 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can see that minor heap collections are approximately 100 times more\nfrequent than major heap collections (in this example, not necessarily\nin general). Over the lifetime of the program, an astonishing 440 MB of\nmemory was allocated, although of course most of that would have been\nimmediately freed in a minor collection. Only about 128K was promoted to\nlong-term storage on the major heap, and about another 128K consisted of\nlarge objects which would have been allocated directly onto the major\nheap.\u003c/p\u003e\n\u003cp\u003eWe can instruct the GC to print out debugging messages when one of\nseveral events happen (eg. on every major collection). Try adding the\nfollowing code to the example above near the beginning:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# Gc.set {(Gc.get ()) with Gc.verbose = 0x01}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(We haven't seen the \u003ccode\u003e{ expression with field = value }\u003c/code\u003e form before,\nbut it should be mostly obvious what it does). The above code anyway\ncauses the GC to print a message at the start of every major collection.\u003c/p\u003e\n\u003ch2 id=\"finalisation-and-the-weak-module\"\u003eFinalisation and the Weak module\u003c/h2\u003e\n\u003cp\u003eWe can write a function called a \u003cstrong\u003efinaliser\u003c/strong\u003e which is called when an\nobject is about to be freed by the GC.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eWeak\u003c/code\u003e module lets us create so-called weak pointers. A \u003cstrong\u003eweak\npointer\u003c/strong\u003e is best defined by comparing it to a \u0026quot;normal pointer\u0026quot;. When we\nhave an ordinary OCaml object, we reference that object through a name\n(eg. \u003ccode\u003elet name = ... in\u003c/code\u003e) or through another object. The garbage\ncollector sees that we have a reference to that object and won't collect\nit. That's what you might call a \u0026quot;normal pointer\u0026quot;. If, however, you hold\na weak pointer or weak reference to an object, then you hint to the\ngarbage collector that it may collect the object at any time. (Not\nnecessarily that it \u003cem\u003ewill\u003c/em\u003e collect the object). Some time later, when\nyou come to examine the object, you can either turn your weak pointer\ninto a normal pointer, or else you can be informed that the GC did\nactually collect the object.\u003c/p\u003e\n\u003cp\u003eFinalisation and weak pointers can be used together to implement an\nin-memory object database cache. Let's imagine that we have a very large\nnumber of large user records in a file on disk. This is far too much\ndata to be loaded into memory all at once, and anyway other programs\nmight access the data on the disk, so we need to lock individual records\nwhen we hold copies of them in memory.\u003c/p\u003e\n\u003cp\u003eThe \u003cem\u003epublic\u003c/em\u003e interface to our \u0026quot;in-memory object database cache\u0026quot; is going\nto be just two functions:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype record = {mutable name : string; mutable address : string}\nval get_record : int -\u0026gt; record\nval sync_records : unit -\u0026gt; unit\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eget_record\u003c/code\u003e call is the only call that most programs will need to\nmake. It gets the n\u003csup\u003eth\u003c/sup\u003e record either out of the cache or from\ndisk and returns it. The program can then read and/or update the\n\u003ccode\u003erecord.name\u003c/code\u003e and \u003ccode\u003erecord.address\u003c/code\u003e fields. The program then just\nliterally forgets about the record! Behind the scenes, finalisation is\ngoing to write the record back out to disk at some later point in time.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003esync_records\u003c/code\u003e function can also be called by user programs. This\nfunction synchronises the disk copy and in-memory copies of all records.\u003c/p\u003e\n\u003cp\u003eOCaml doesn't currently run finalisers at exit. However you can easily\nforce it to by adding the following command to your code. This command\ncauses a full major GC cycle on exit:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eat_exit Gc.full_major\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOur code is also going to implement a cache of recently accessed records\nusing the \u003ccode\u003eWeak\u003c/code\u003e module. The advantage of using the \u003ccode\u003eWeak\u003c/code\u003e module rather\nthan hand-rolling our own code is two-fold: Firstly the garbage\ncollector has a global view of memory requirements for the whole\nprogram, and so is in a better position to decide when to shrink the\ncache. Secondly our code will be much simpler.\u003c/p\u003e\n\u003cp\u003eFor our example, we're going to use a very simple format for the file of\nusers' records. The file is just a list of user records, each user\nrecord having a fixed size of 256 bytes. Each user record has just two\nfields (padded with spaces if necessary), the name field (64 bytes) and\nthe address field (192 bytes). Before a record can be loaded into\nmemory, the program must acquire an exclusive lock on the record. After\nthe in-memory copy is written back out to the file, the program must\nrelease the lock. Here is some code to define the on-disk format and\nsome low-level functions to read, write, lock and unlock records:\u003c/p\u003e\n\u003c!-- $MDX file=examples/objcache.ml,part=0 --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* In-memory format. *)\ntype record = { mutable name : string; mutable address : string }\n\n(* On-disk format. *)\nlet record_size = 256\n\nlet name_size = 64\n\nlet addr_size = 192\n\n(* Low-level load/save records to file. *)\nlet seek_record n fd = ignore (Unix.lseek fd (n * record_size) Unix.SEEK_SET)\n\nlet write_record record n fd =\n  seek_record n fd;\n  ignore (Unix.write fd (Bytes.of_string record.name) 0 name_size);\n  ignore (Unix.write fd (Bytes.of_string record.address) 0 addr_size)\n\nlet read_record record n fd =\n  seek_record n fd;\n  ignore (Unix.read fd (Bytes.of_string record.name) 0 name_size);\n  ignore (Unix.read fd (Bytes.of_string record.address) 0 addr_size)\n\n(* Lock/unlock the nth record in a file. *)\nlet lock_record n fd =\n  seek_record n fd;\n  Unix.lockf fd Unix.F_LOCK record_size\n\nlet unlock_record n fd =\n  seek_record n fd;\n  Unix.lockf fd Unix.F_ULOCK record_size\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe also need a function to create new, empty in-memory \u003ccode\u003erecord\u003c/code\u003e objects:\u003c/p\u003e\n\u003c!-- $MDX file=examples/objcache.ml,part=1 --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Create a new, empty record. *)\nlet new_record () =\n  { name = String.make name_size ' '; address = String.make addr_size ' ' }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBecause this is a really simple program, we're going to fix the number\nof records in advance:\u003c/p\u003e\n\u003c!-- $MDX file=examples/objcache.ml,part=2 --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Total number of records. *)\nlet nr_records = 10000\n\n(* On-disk file. *)\nlet diskfile = Unix.openfile \u0026quot;users.bin\u0026quot; [ Unix.O_RDWR; Unix.O_CREAT ] 0o666\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDownload \u003ca href=\"users.bin.gz\"\u003eusers.bin.gz\u003c/a\u003e and decompress it before\nrunning the program.\u003c/p\u003e\n\u003cp\u003eOur cache of records is very simple:\u003c/p\u003e\n\u003c!-- $MDX file=examples/objcache.ml,part=3 --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Cache of records. *)\nlet cache = Weak.create nr_records\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eget_record\u003c/code\u003e function is very short and basically composed of two\nhalves. We grab the record from the cache. If the cache gives us \u003ccode\u003eNone\u003c/code\u003e,\nthen that either means that we haven't loaded this record from the cache\nyet, or else it has been written out to disk (finalised) and dropped\nfrom the cache. If the cache gives us \u003ccode\u003eSome record\u003c/code\u003e then we just return\n\u003ccode\u003erecord\u003c/code\u003e (this promotes the weak pointer to the record to a normal\npointer).\u003c/p\u003e\n\u003c!-- $MDX file=examples/objcache.ml,part=4 --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* The finaliser function. *)\nlet finaliser n record =\n  printf \u0026quot;*** objcache: finalising record %d\\n%!\u0026quot; n;\n  write_record record n diskfile;\n  unlock_record n diskfile\n\n(* Get a record from the cache or off disk. *)\nlet get_record n =\n  match Weak.get cache n with\n  | Some record -\u0026gt;\n      printf \u0026quot;*** objcache: fetching record %d from memory cache\\n%!\u0026quot; n;\n      record\n  | None -\u0026gt;\n      printf \u0026quot;*** objcache: loading record %d from disk\\n%!\u0026quot; n;\n      let record = new_record () in\n      Gc.finalise (finaliser n) record;\n      lock_record n diskfile;\n      read_record record n diskfile;\n      Weak.set cache n (Some record);\n      record\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003esync_records\u003c/code\u003e function is even easier. First of all it empties the\ncache by replacing all the weak pointers with \u003ccode\u003eNone\u003c/code\u003e. This now means\nthat the garbage collector \u003cem\u003ecan\u003c/em\u003e collect and finalise all of those\nrecords. But it doesn't necessarily mean that the GC \u003cem\u003ewill\u003c/em\u003e collect the\nrecords straightaway (in fact it's not likely that it will), so to force\nthe GC to collect the records immediately, we also invoke a major cycle:\u003c/p\u003e\n\u003cp\u003eFinally we have some test code. I won't reproduce the test code, but you\ncan download the complete program and test code\n\u003ca href=\"objcache.ml\"\u003eobjcache.ml\u003c/a\u003e, and compile it with:\u003c/p\u003e\n\u003c!-- $MDX dir=examples --\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ocamlc unix.cma objcache.ml -o objcache\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"exercises\"\u003eExercises\u003c/h2\u003e\n\u003cp\u003eHere are some ways to extend the example above, in approximately\nincreasing order of difficulty:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eImplement the record as an \u003cstrong\u003eobject\u003c/strong\u003e, and allow it to transparently\npad/unpad strings. You will need to provide methods to set and get\nthe name and address fields (four public methods in all). Hide as\nmuch of the implementation (file access, locking) code in the class\nas possible.\n\u003c/li\u003e\n\u003cli\u003eExtend the program so that it acquires a \u003cstrong\u003eread lock\u003c/strong\u003e on getting\nthe record, but upgrades this to a \u003cstrong\u003ewrite lock\u003c/strong\u003e just before the\nuser updates any field.\n\u003c/li\u003e\n\u003cli\u003eSupport a \u003cstrong\u003evariable number of records\u003c/strong\u003e and add a function to\ncreate a new record (in the file). [Tip: OCaml has support for weak\nhashtables.]\n\u003c/li\u003e\n\u003cli\u003eAdd support for \u003cstrong\u003evariable-length records\u003c/strong\u003e.\n\u003c/li\u003e\n\u003cli\u003eMake the underlying file representation a \u003cstrong\u003eDBM-style hash\u003c/strong\u003e.\n\u003c/li\u003e\n\u003cli\u003eProvide a general-purpose cache fronting a \u0026quot;users\u0026quot; table in your\nchoice of \u003cstrong\u003erelational database\u003c/strong\u003e (with locking).\n\u003c/li\u003e\n\u003c/ol\u003e\n"},{"title":"Performance and Profiling","slug":"performance-and-profiling","description":"Understand how to profile your OCaml code to analyse its performance and produce faster programs\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"advanced","tl":0},"users":{"hd":"Intermediate","tl":{"hd":"Advanced","tl":0}},"body_md":"\n## Speed\nWhy is OCaml fast? Indeed, step back and ask *is OCaml fast?* How can we\nmake programs faster? In this chapter we'll look at what actually\nhappens when you compile your OCaml programs down to machine code. This\nwill help in understanding why OCaml is not just a great language for\nprogramming, but is also a very fast language indeed. And it'll help you\nto help the compiler write better machine code for you. It's also (I\nbelieve anyway) a good thing for programmers to have some idea of what\nhappens between you typing `ocamlopt` and getting a binary you can run.\n\nBut you will need to know some assembler to get the most out of this\nsection. Don't be afraid! I'll help you out by translating the assembler\ninto a C-like pseudocode (after all C is just a portable assembly\nlanguage).\n\n###  Basics of assembly language\nThe examples I give in this chapter are all compiled on an x86 Linux\nmachine. The x86 is, of course, a 32 bit machine, so an x86 \"word\" is 4\nbytes (= 32 bits) long. At this level OCaml deals mostly with word-sized\nobjects, so you'll need to remember to multiply by four to get the size\nin bytes.\n\nTo refresh your memory, the x86 has only a small number of general\npurpose registers, each of which can store one word. The Linux assembler\nputs `%` in front of register names. The registers are: `%eax`, `%ebx`,\n`%ecx`, `%edx`, `%esi`, `%edi`, `%ebp` (special register used for stack\nframes), and `%esp` (the stack pointer).\n\nThe Linux assembler (in common with other Unix assemblers, but opposite\nto MS-derived assemblers) writes moves to and from registers/memory as:\n\n```assembly\nmovl from, to\n```\n\nSo `movl %ebx, %eax` means \"copy the contents of register `%ebx` into\nregister `%eax`\" (not the other way round).\n\nAlmost all of the assembly language that we will look at is going to be\ndominated not by machine code instructions like `movl` but by what are\nknown as **assembler directives**. These directives begin\nwith a . (period) and they literally *direct* the assembler to do\nsomething. Here are the common ones for the Linux assembler:\n\n#### .text\n\n**Text** is the Unix way of saying \"program code\". The **text segment**\nsimply means the part of the executable where program code is stored.\nThe `.text` directive switches the assembler so it starts writing into\nthe text segment.\n\n#### .data\n\nSimilarly, the `.data` directive switches the assembler so it starts\nwriting into the data segment (part) of the executable.\n\n```assembly\n  .globl foo\nfoo:\n```\nThis declares a global symbol called `foo`. It means the address of the\nnext thing to come can be named `foo`. Writing just `foo:` without the\npreceding `.globl` directive declares a local symbol (local to just the\ncurrent file).\n\n```assembly\n.long 12345\n.byte 9\n.ascii \"hello\"\n.space 4\n```\n`.long` writes a word (4 bytes) to the current segment. `.byte` writes a\nsingle byte. `.ascii` writes a string of bytes (NOT nul-terminated).\n`.space` writes the given number of zero bytes. Normally you use these\nin the data segment.\n\n###  The \"hello, world\" program\nEnough assembler. Put the following program into a file called\n`smallest.ml`:\n\n```ocaml\nprint_string \"hello, world\\n\"\n```\nAnd compile it to a native code executable using:\n\n```shell\nocamlopt -S smallest.ml -o smallest\n```\n\nThe `-S` (capital S) tells the compiler to leave the assembly language\nfile (called `smallest.s` - lowercase s) instead of deleting it.\n\nHere are the edited highlights of the `smallest.s` file with my comments\nadded. First of all the data segment:\n\n```assembly\n    .data\n    .long   4348                     ; header for string\n    .globl  Smallest__1\nlest__1:\n    .ascii  \"hello, world\\12\"        ; string\n    .space  2                        ; padding ..\n    .byte   2                        ;  .. after string\n```\nNext up the text (program code) segment:\n\n```assembly\n    .text\n    .globl  Smallest__entry          ; entry point to the program\nlest__entry:\n\n    ; this is equivalent to the C pseudo-code:\n    ; Pervasives.output_string (stdout, \u0026Smallest__1)\n\n    movl    $Smallest__1, %ebx\n    movl    Pervasives + 92, %eax    ; Pervasives + 92 == stdout\n    call    Pervasives__output_string_212\n\n    ; return 1\n\n    movl    $1, %eax\n    ret\n```\n\nIn C everything has to be inside a function. Think about how you can't\njust write `printf (\"hello, world\\n\");` in C, but instead you have to\nput it inside `main () { ... }`. In OCaml you are allowed to have\ncommands at the top level, not inside a function. But when we translate\nthis into assembly language, where do we put those commands? There needs\nto be some way to call those commands from outside, so they need to be\nlabelled in some way. As you can see from the code snippet, OCaml solves\nthis by taking the filename (`smallest.ml`), capitalizing it and adding\n`__entry`, thus making up a symbol called `Smallest__entry` to refer to\nthe top level commands in this file.\n\nNow look at the code that OCaml has generated. The original code said\n`print_string \"hello, world\\n\"`, but OCaml has instead compiled the\nequivalent of `Pervasives.output_string stdout \"hello, world\\n\"`. Why?\nIf you look into `pervasives.ml` you'll see why:\n\n```ocaml\nlet print_string s = output_string stdout s\n```\n\nOCaml has *inlined* this function. **Inlining** - taking a function and\nexpanding it from its definition - is sometimes a performance win,\nbecause it avoids the overhead of an extra function call, and it can\nlead to more opportunities for the optimizer to do its thing. Sometimes\ninlining is not good, because it can lead to code bloating, and thus\ndestroys the good work done by the processor cache (and besides function\ncalls are actually not very expensive at all on modern processors).\nOCaml will inline simple calls like this, because they are essentially\nrisk free, almost always leading to a small performance gain.\n\nWhat else can we notice about this? The calling convention seems to be\nthat the first two arguments are passed in the `%eax` and `%ebx`\nregisters respectively. Other arguments are probably passed on the\nstack, but we'll see about that later.\n\nC programs have a simple convention for storing strings, known as\n**ASCIIZ**. This just means that the string is stored in ASCII, followed\nby a trailing NUL (`\\0`) character. OCaml stores strings in a different\nway, as we can see from the data segment above. This string is stored\nlike this:\n\n```\n4 byte header: 4348\nthe string:    h e l l o , SP w o r l d \\n\npadding:       \\0 \\0 \\002\n```\n\nFirstly the padding brings the total length of the string up to a whole\nnumber of words (4 words, 16 bytes in this example). The padding is\ncarefully designed so that you can work out the actual length of the\nstring in bytes, provided that you know the total number of *words*\nallocated to the string. The encoding for this is unambiguous (which you\ncan prove to yourself).\n\nOne nice feature of having strings with an explicit length is that you\ncan represent strings containing ASCII NUL (`\\0`) characters in them,\nsomething which is difficult to do in C. However, the flip side is that\nyou need to be aware of this if you pass an OCaml string to some C\nnative code: if it contains ASCII NUL, then the C `str*` functions will\nfail on it.\n\nSecondly we have the header. Every boxed (allocated) object in OCaml has\na header which tells the garbage collector about how large the object is\nin words, and something about what the object contains. Writing the\nnumber 4348 in binary:\n\n```\nlength of the object in words:  0000 0000 0000 0000 0001 00 (4 words)\ncolor (used by GC):             00\ntag:                            1111 1100 (String_tag)\n```\nSee `/usr/include/caml/mlvalues.h` for more information about\nthe format of heap allocated objects in OCaml.\n\nOne unusual thing is that the code passes a pointer to the start of the\nstring (ie. the word immediately after the header) to\n`Pervasives.output_string`. This means that `output_string` must\nsubtract 4 from the pointer to get at the header to determine the length\nof the string.\n\nWhat have I missed out from this simple example? Well, the text segment\nabove is not the whole story. It would be really nice if OCaml\ntranslated that simple hello world program into just the five lines of\nassembler shown above. But there is the question of what actually calls\n`Smallest__entry` in the real program. For this OCaml includes a whole\nload of bootstrapping code which does things like starting up the\ngarbage collector, allocating and initializing memory, calling\ninitializers in libraries and so on. OCaml links all of this code\nstatically to the final executable, which is why the program I end up\nwith (on Linux) weighs in at a portly 95,442 bytes. Nevertheless the\nstart-up time for the program is still unmeasurably small (under a\nmillisecond), compared to several seconds for starting up a reasonable\nJava program and a second or so for a Perl script.\n\n###  Tail recursion\nWe mentioned in chapter 6 that OCaml can turn tail-recursive function\ncalls into simple loops. Is this actually true? Let's look at what\nsimple tail recursion compiles to:\n\n\u003c!-- do not execute this code!! --\u003e\n\u003c!-- $MDX skip --\u003e\n```ocaml\nlet rec loop () =\n  print_string \"I go on forever ...\";\n  loop ()\n  \nlet () = loop ()\n```\n\nThe file is called `tail.ml`, so following OCaml's usual procedure for\nnaming functions, our function will be called `Tail__loop_nnn` (where\n`nnn` is some unique number which OCaml appends to distinguish\nidentically named functions from one another).\n\nHere is the assembler for just the `loop` function defined above:\n\n```assembly\n        .text\n        .globl  Tail__loop_56\nTail__loop_56:\n.L100:\n        ; Print the string\n        movl    $Tail__2, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n.L101:\n        ; The following movl is in fact obsolete:\n        movl    $1, %eax\n        ; Jump back to the .L100 label above (ie. loop forever)\n        jmp     .L100\n```\n\nSo that's pretty conclusive. Calling `Tail__loop_56` will first print\nthe string, and then jump back to the top, then print the string, and\njump back, and so on forever. It's a simple loop, *not* a recursive\nfunction call, so it doesn't use any stack space.\n\n###  Digression: Where are the types?\nOCaml is statically typed as we've said before on many occasions, so at\ncompile time, OCaml knows that the type of `loop` is `unit -\u003e unit`. It\nknows that the type of `\"hello, world\\n\"` is `string`. It doesn't make\nany attempt to communicate this fact to the `output_string` function.\n`output_string` is expecting a `channel` and a `string` as arguments,\nand indeed that's what it gets. What would happen if we passed, say, an\n`int` instead of a `string`?\n\nThis is essentially an impossible condition. Because OCaml knows the\ntypes at compile time, it doesn't need to deal with types or check types\nat run time. There is no way, in pure OCaml, to \"trick\" the compiler\ninto generating a call to `Pervasives.output_string stdout 1`. Such an\nerror would be flagged at compile time, by type inference, and so could\nnever be compiled.\n\nThe upshot is that by the time we have compiled OCaml code to assembler\ntype information mostly isn't required, certainly in the cases we've\nlooked at above where the type is fully known at compile time, and there\nis no polymorphism going on.\n\nFully knowing all your types at compile time is a major performance win\nbecause it totally avoids any dynamic type checking at run time. Compare\nthis to a Java method invocation for example: `obj.method ()`. This is\nan expensive operation because you need to find the concrete class that\n`obj` is an instance of, and then look up the method, and you need to do\nall of this potentially *every* time you call any method. Casting\nobjects is another case where you need to do a considerable amount of\nwork at run time in Java. None of this is allowed with OCaml's static\ntypes.\n\n###  Polymorphic types\nAs you might have guessed from the discussion above, polymorphism, which\nis where the compiler *doesn't* have a fully known type for a function\nat compile time, might have an impact on performance. Suppose we require\na function to work out the maximum of two integers. Our first attempt\nis:\n\n```ocaml\n# let max a b =\n  if a \u003e b then a else b\nval max : 'a -\u003e 'a -\u003e 'a = \u003cfun\u003e\n```\n\nSimple enough, but recall that the \\\u003e (greater than) operator in OCaml\nis polymorphic. It has type `'a -\u003e 'a -\u003e bool`, and this means that the\n`max` function we defined above is going to be polymorphic:\n\n```ocaml\n# let max a b =\n  if a \u003e b then a else b\nval max : 'a -\u003e 'a -\u003e 'a = \u003cfun\u003e\n```\n\nThis is indeed reflected in the code that OCaml generates for this\nfunction, which is pretty complex:\n\n```assembly\n        .text\n        .globl  Max__max_56\nMax__max_56:\n\n        ; Reserve two words of stack space.\n\n        subl    $8, %esp\n\n        ; Save the first and second arguments (a and b) on the stack.\n\n        movl    %eax, 4(%esp)\n        movl    %ebx, 0(%esp)\n\n        ; Call the C \"greaterthan\" function (in the OCaml library).\n\n        pushl   %ebx\n        pushl   %eax\n        movl    $greaterthan, %eax\n        call    caml_c_call\n.L102:\n        addl    $8, %esp\n\n        ; If the C \"greaterthan\" function returned 1, jump to .L100\n\n        cmpl    $1, %eax\n        je      .L100\n\n        ; Returned 0, so get argument a which we previously saved on\n        ; the stack and return it.\n\n        movl    4(%esp), %eax\n        addl    $8, %esp\n        ret\n\n        ; Returned 1, so get argument b which we previously saved on\n        ; the stack and return it.\n\n.L100:\n        movl    0(%esp), %eax\n        addl    $8, %esp\n        ret\n```\n\nBasically the \\\u003e operation is done by calling a C function from the\nOCaml library. This is obviously not going to be very efficient, nothing\nlike as efficient as if we could generate some quick inline assembly\nlanguage for doing the \\\u003e.\n\nThis is not a complete dead loss by any means. All we need to do is to\nhint to the OCaml compiler that the arguments are in fact integers. Then\nOCaml will generate a specialised version of `max` which only works on\n`int` arguments:\n\n```ocaml\n# let max (a : int) (b : int) =\n  if a \u003e b then a else b\nval max : int -\u003e int -\u003e int = \u003cfun\u003e\n```\nHere is the assembly code generated for this function:\n\n```assembly\n        .text\n        .globl  Max_int__max_56\nMax_int__max_56:\n\n        ; Single assembly instruction \"cmpl\" for performing the \u003e op.\n        cmpl    %ebx, %eax\n\n        ; If %ebx \u003e %eax, jump to .L100\n        jle     .L100\n        ; Just return argument a.\n        ret\n        ; Return argument b.\n\n.L100:\n        movl    %ebx, %eax\n        ret\n```\nThat's just 5 lines of assembler, and is about as simple as you can make\nit.\n\nWhat about this code:\n\n```ocaml\n# let max a b =\n  if a \u003e b then a else b\nval max : 'a -\u003e 'a -\u003e 'a = \u003cfun\u003e\n# let () = print_int (max 2 3)\n3\n```\n\nIs OCaml going to be smart enough to inline the `max` function and\nspecialise it to work on integers? Disappointingly the answer is no.\nOCaml still has to generate the external `Max.max` symbol (because this\nis a module, and so that function might be called from outside the\nmodule), and it doesn't inline the function.\n\nHere's another variation:\n\n```ocaml\n# let max a b =\n  if a \u003e b then a else b in\n  print_int (max 2 3)\n3\n- : unit = ()\n```\n\nDisappointingly although the definition of `max` in this code is local\n(it can't be called from outside the module), OCaml still doesn't\nspecialise the function.\n\nLesson: if you have a function which is unintentionally polymorphic then\nyou can help the compiler by specifying types for one or more of the\narguments.\n\n###  The representation of integers, tag bits, heap-allocated values\nThere are a number of peculiarities about integers in OCaml. One of\nthese is that integers are 31 bit entities, not 32 bit entities. What\nhappens to the \"missing\" bit?\n\nWrite this to `int.ml`:\n\n```ocaml\nprint_int 3\n```\n\nand compile with `ocamlopt -S int.ml -o int` to generate assembly\nlanguage in `int.s`. Recall from the discussion above that we are\nexpecting OCaml to inline the `print_int` function as\n`output_string (string_of_int 3)`, and examining the assembly language\noutput we can see that this is exactly what OCaml does:\n\n```assembly\n        .text\n        .globl  Int__entry\nInt__entry:\n\n        ; Call Pervasives.string_of_int (3)\n\n        movl    $7, %eax\n        call    Pervasives__string_of_int_152\n\n        ; Call Pervasives.output_string (stdout, result_of_previous)\n\n        movl    %eax, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n```\n\nThe important code is shown in red. It shows two things: Firstly the\ninteger is unboxed (not allocated on the heap), but is instead passed\ndirectly to the function in the register `%eax`. This is fast. But\nsecondly we see that the number being passed is 7, not 3.\n\nThis is a consequence of the representation of integers in OCaml. The\nbottom bit of the integer is used as a tag - we'll see what for next.\nThe top 31 bits are the actual integer. The binary representation of 7\nis 111, so the bottom tag bit is 1 and the top 31 bits form the number\n11 in binary = 3. To get from the OCaml representation to the integer,\ndivide by two and round down.\n\nWhy the tag bit at all? This bit is used to distinguish between integers\nand pointers to structures on the heap, and the distinction is only\nnecessary if we are calling a polymorphic function. In the case above,\nwhere we are calling `string_of_int`, the argument can only ever be an\n`int` and so the tag bit would never be consulted. Nevertheless, to\navoid having two internal representations for integers, all integers in\nOCaml carry around the tag bit.\n\nA bit of background about pointers is required to understand why the tag\nbit is really necessary, and why it is where it is.\n\nIn the world of RISC chips like the Sparc, MIPS and Alpha, pointers have\nto be word-aligned. So on the older 32 bit Sparc, for example, it's not\npossible to create and use a pointer which isn't aligned to a multiple\nof 4 (bytes). Trying to use one generates a processor exception, which\nmeans basically your program segfaults. The reason for this is just to\nsimplify memory access. It's just a lot simpler to design the memory\nsubsystem of a CPU if you only need to worry about word-aligned access.\n\nFor historical reasons (because the x86 is derived from an 8 bit chip),\nthe x86 has supported unaligned memory access, although if you align all\nmemory accesses to multiples of 4, then things go faster.\n\nNevertheless, all pointers in OCaml are aligned - ie. multiples of 4 for\n32 bit processors, and multiples of 8 for 64 bit processors. This means\nthat the bottom bit of any pointer in OCaml will always be zero.\n\nSo you can see that by looking at the bottom bit of a register, you can\nimmediately tell if it stores a pointer (\"tag\" bit is zero), or an\ninteger (tag bit set to one).\n\nRemember our polymorphic \\\u003e function which caused us so much trouble in\nthe previous section? We looked at the assembler and found out that\nOCaml compiles a call to a C function called `greaterthan` whenever it\nsees the polymorphic form of \\\u003e. This function takes two arguments, in\nregisters `%eax` and `%ebx`. But `greaterthan` can be called with\nintegers, floats, strings, opaque objects ... How does it know what\n`%eax` and `%ebx` point to?\n\nIt uses the following decision tree:\n\n* **Tag bit is one:** compare the two integers and return.\n* **Tag bit is zero:** `%eax` and `%ebx` must point at two\n heap-allocated memory blocks. Look at the header word of the memory\n blocks, specifically the bottom 8 bits of the header word, which tag\n the content of the block.\n     * **String_tag:** Compare two strings.\n     * **Double_tag:** Compare two floats.\n     * etc.\n\nNote that because \\\u003e has type `'a -\u003e 'a -\u003e bool`, both arguments must\nhave the same type. The compiler should enforce this at compile time. I\nwould assume that `greaterthan` probably contains code to sanity-check\nthis at run time however.\n\n###  Floats\nFloats are, by default, boxed (allocated on the heap). Save this as\n`float.ml` and compile it with `ocamlopt -S float.ml -o float`:\n\n```ocamltop\nprint_float 3.0\n```\nThe number is not passed directly to `string_of_float` in the `%eax`\nregister as happened above with ints. Instead, it is created statically\nin the data segment:\n\n```assembly\n        .data\n        .long   2301\n        .globl  Float__1\nFloat__1:\n        .double 3.0\n```\nand a pointer to the float is passed in `%eax` instead:\n\n```assembly\n        movl    $Float__1, %eax\n        call    Pervasives__string_of_float_157\n```\nNote the structure of the floating point number: it has a header (2301),\nfollowed by the 8 byte (2 word) representation of the number itself. The\nheader can be decoded by writing it as binary:\n\n```\nLength of the object in words:  0000 0000 0000 0000 0000 10 (8 bytes)\nColor:                          00\nTag:                            1111 1101 (Double_tag)\n```\n`string_of_float` isn't polymorphic, but suppose we have a polymorphic\nfunction `foo : 'a -\u003e unit` taking one polymorphic argument. If we call\n`foo` with `%eax` containing 7, then this is equivalent to `foo 3`,\nwhereas if we call `foo` with `%eax` containing a pointer to `Float__1`\nabove, then this is equivalent to `foo 3.0`.\n\n###  Arrays\nI mentioned earlier that one of OCaml's targets was numerical computing.\nNumerical computing does a lot of work on vectors and matrices, which\nare essentially arrays of floats. As a special hack to make this go\nfaster, OCaml implements **arrays of unboxed floats**. This\nmeans that in the special case where we have an object of type\n`float array` (array of floats), OCaml stores them the same way as in C:\n\n```C\ndouble array[10];\n```\n... instead of having an array of pointers to ten separately allocated\nfloats on the heap.\n\nLet's see this in practice:\n\n```ocaml\nlet a = Array.create 10 0.0;;\nfor i = 0 to 9 do\n  a.(i) \u003c- float_of_int i\ndone\n```\n\nI'm going to compile this code with the `-unsafe` option to remove\nbounds checking (simplifying the code for our exposition here). The\nfirst line, which creates the array, is compiled to a simple C call:\n\n```assembly\n        pushl   $Arrayfloats__1     ; Boxed float 0.0\n        pushl   $21                 ; The integer 10\n        movl    $make_vect, %eax    ; Address of the C function to call\n        call    caml_c_call\n    ; ...\n        movl    %eax, Arrayfloats   ; Store the resulting pointer to the\n                                    ; array at this place on the heap.\n```\nThe loop is compiled to this relatively simple assembly language:\n\n```assembly\n        movl    $1, %eax            ; Let %eax = 0. %eax is going to store i.\n        cmpl    $19, %eax           ; If %eax \u003e 9, then jump out of the\n        jg      .L100               ;   loop (to label .L100 at the end).\n\n.L101:                              ; This is the start of the loop body.\n        movl    Arrayfloats, %ecx   ; Address of the array to %ecx.\n\n        movl    %eax, %ebx          ; Copy i to %ebx.\n        sarl    $1, %ebx            ; Remove the tag bit from %ebx by\n                                    ;   shifting it right 1 place. So %ebx\n                                    ;   now contains the real integer i.\n\n        pushl   %ebx                ; Convert %ebx to a float.\n        fildl   (%esp)\n        addl    $4, %esp\n\n        fstpl   -4(%ecx, %eax, 4)   ; Store the float in the array at the ith\n                                ; position.\n\n        addl    $2, %eax            ; i := i + 1\n        cmpl    $19, %eax           ; If i \u003c= 9, loop around again.\n        jle     .L101\n.L100:\n```\nThe important statement is the one which stores the float into the\narray. It is:\n\n```assembly\n        fstpl   -4(%ecx, %eax, 4)\n```\nThe assembler syntax is rather complex, but the bracketed expression\n`-4(%ecx, %eax, 4)` means \"at the address `%ecx + 4*%eax - 4`\". Recall\nthat `%eax` is the OCaml representation of i, complete with tag bit, so\nit is essentially equal to `i*2+1`, so let's substitute that and\nmultiply it out:\n\n```assembly\n  %ecx + 4*%eax - 4\n= %ecx + 4*(i*2+1) - 4\n= %ecx + 4*i*2 + 4 - 4\n= %ecx + 8*i\n```\n(Each float in the array is 8 bytes long.)\n\nSo arrays of floats are unboxed, as expected.\n\n###  Partially applied functions and closures\nHow does OCaml compile functions which are only partially applied? Let's\ncompile this code:\n\n```ocaml\nArray.map ((+) 2) [|1; 2; 3; 4; 5|]\n```\n\nIf you recall the syntax, `[| ... |]` declares an array (in this case an\n`int array`), and `((+) 2)` is a closure - \"the function which adds 2 to\nthings\".\n\nCompiling this code reveals some interesting new features. Firstly the\ncode which allocates the array:\n\n```assembly\n        movl    $24, %eax           ; Allocate 5 * 4 + 4 = 24 bytes of memory.\n        call    caml_alloc\n\n        leal    4(%eax), %eax       ; Let %eax point to 4 bytes into the\n                                    ;   allocated memory.\n```\nAll heap allocations have the same format: 4 byte header + data. In this\ncase the data is 5 integers, so we allocate 4 bytes for the header plus\n5 * 4 bytes for the data. We update the pointer to point at the first\ndata word, ie. 4 bytes into the allocated memory block.\n\nNext OCaml generates code to initialize the array:\n\n```assembly\n        movl    $5120, -4(%eax)\n        movl    $3, (%eax)\n        movl    $5, 4(%eax)\n        movl    $7, 8(%eax)\n        movl    $9, 12(%eax)\n        movl    $11, 16(%eax)\n```\nThe header word is 5120, which if you write it in binary means a block\ncontaining 5 words, with tag zero. The tag of zero means it's a\n\"structured block\" a.k.a. an array. We also copy the numbers 1, 2, 3, 4\nand 5 to the appropriate places in the array. Notice the OCaml\nrepresentation of integers is used. Because this is a structured block,\nthe garbage collector will scan each word in this block, and the GC\nneeds to be able to distinguish between integers and pointers to other\nheap-allocated blocks (the GC does not have access to type information\nabout this array).\n\nNext the closure `((+) 2)` is created. The closure is represented by\nthis block allocated in the data segment:\n\n```assembly\n        .data\n        .long   3319\n        .globl  Closure__1\nClosure__1:\n        .long   caml_curry2\n        .long   5\n        .long   Closure__fun_58\n```\nThe header is 3319, indicating a `Closure_tag` with length 3 words. The\n3 words in the block are the address of the function `caml_curry2`, the\ninteger number 2 and the address of this function:\n\n```assembly\n        .text\n        .globl  Closure__fun_58\nClosure__fun_58:\n\n        ; The function takes two arguments, %eax and %ebx.\n        ; This line causes the function to return %eax + %ebx - 1.\n\n        lea     -1(%eax, %ebx), %eax\n        ret\n```\nWhat does this function do? On the face of it, it adds the two\narguments, and subtracts one. But remember that `%eax` and `%ebx` are in\nthe OCaml representation for integers. Let's represent them as:\n\n* `%eax = 2 * a + 1`\n* `%ebx = 2 * b + 1`\n\nwhere `a` and `b` are the actual integer arguments. So this function\nreturns:\n\n```\n%eax + %ebx - 1\n= 2 * a + 1 + 2 * b + 1 - 1\n= 2 * a + 2 * b + 1\n= 2 * (a + b) + 1\n```\nIn other words, this function returns the OCaml integer representation\nof the sum `a + b`. This function is `(+)`!\n\n(It's actually more subtle than this - to perform the mathematics\nquickly, OCaml uses the x86 addressing hardware in a way that probably\nwasn't intended by the designers of the x86.)\n\nSo back to our closure - we won't go into the details of the\n`caml_curry2` function, but just say that this closure is the argument\n`2` applied to the function `(+)`, waiting for a second argument. Just\nas expected.\n\nThe actual call to the `Array.map` function is quite difficult to\nunderstand, but the main points for our examination of OCaml is that the\ncode:\n\n* Does call `Array.map` with an explicit closure.\n* Does not attempt to inline the call and turn it into a loop.\n\nCalling `Array.map` in this way is undoubtedly slower than writing a\nloop over the array by hand. The overhead is mainly in the fact that the\nclosure must be evaluated for each element of the array, and that isn't\nas fast as inlining the closure as a function (if this optimization were\neven possible). However, if you had a more substantial closure than just\n`((+) 2)`, the overhead would be reduced. The FP version also saves\nexpensive *programmer* time versus writing the imperative loop.\n\n## Profiling\nThere are two types of profiling that you can do on OCaml programs:\n\n1. Get execution counts for bytecode.\n1. Get real profiling for native code.\n\nThe `ocamlcp` and `ocamlprof` programs perform profiling on bytecode.\nHere is an example:\n\n\u003c!-- $MDX file=examples/gc.ml --\u003e\n```ocaml\nlet rec iterate r x_init i =\n  if i = 1 then x_init\n  else\n    let x = iterate r x_init (i - 1) in\n    r *. x *. (1.0 -. x)\n\nlet () =\n  Random.self_init ();\n  Graphics.open_graph \" 640x480\";\n  for x = 0 to 640 do\n    let r = 4.0 *. float_of_int x /. 640.0 in\n    for i = 0 to 39 do\n      let x_init = Random.float 1.0 in\n      let x_final = iterate r x_init 500 in\n      let y = int_of_float (x_final *. 480.) in\n      Graphics.plot x y\n    done\n  done;\n  Gc.print_stat stdout\n```\n\nAnd can be run and compiled with \n\n\u003c!-- $MDX skip --\u003e\n```\n$ ocamlcp -p a graphics.cma graphtest.ml -o graphtest\n$ ./graphtest\n$ ocamlprof graphtest.ml\n```\n\nThe comments `(* nnn *)` are added by `ocamlprof`, showing how many\ntimes each part of the code was called.\n\nProfiling native code is done using your operating system's native\nsupport for profiling. In the case of Linux, we use `gprof`. An alternative\nis [perf](https://en.wikipedia.org/wiki/Perf_(Linux)), as explained below.\n\nWe compile it using the `-p` option to `ocamlopt` which tells the\ncompiler to include profiling information for `gprof`:\n\nAfter running the program as normal, the profiling code dumps out a file\n`gmon.out` which we can interpret with `gprof`:\n\n```\n$ gprof ./a.out\nFlat profile:\n  \nEach sample counts as 0.01 seconds.\n  %   cumulative   self              self     total\n time   seconds   seconds    calls   s/call   s/call  name\n 10.86      0.57     0.57     2109     0.00     0.00  sweep_slice\n  9.71      1.08     0.51     1113     0.00     0.00  mark_slice\n  7.24      1.46     0.38  4569034     0.00     0.00  Sieve__code_begin\n  6.86      1.82     0.36  9171515     0.00     0.00  Stream__set_data_140\n  6.57      2.17     0.34 12741964     0.00     0.00  fl_merge_block\n  6.29      2.50     0.33  4575034     0.00     0.00  Stream__peek_154\n  5.81      2.80     0.30 12561656     0.00     0.00  alloc_shr\n  5.71      3.10     0.30     3222     0.00     0.00  oldify_mopup\n  4.57      3.34     0.24 12561656     0.00     0.00  allocate_block\n  4.57      3.58     0.24  9171515     0.00     0.00  modify\n  4.38      3.81     0.23  8387342     0.00     0.00  oldify_one\n  3.81      4.01     0.20 12561658     0.00     0.00  fl_allocate\n  3.81      4.21     0.20  4569034     0.00     0.00  Sieve__filter_56\n  3.62      4.40     0.19     6444     0.00     0.00  empty_minor_heap\n  3.24      4.57     0.17     3222     0.00     0.00  oldify_local_roots\n  2.29      4.69     0.12  4599482     0.00     0.00  Stream__slazy_221\n  2.10      4.80     0.11  4597215     0.00     0.00  darken\n  1.90      4.90     0.10  4596481     0.00     0.00  Stream__fun_345\n  1.52      4.98     0.08  4575034     0.00     0.00  Stream__icons_207\n  1.52      5.06     0.08  4575034     0.00     0.00  Stream__junk_165\n  1.14      5.12     0.06     1112     0.00     0.00  do_local_roots\n  \n[ etc. ]\n```\n\n### Using perf on Linux\n\nAssuming perf is installed and your program is compiled into\nnative code with `-g` (or ocamlbuild tag `debug`), you just need to type\n\n\u003c!-- $MDX skip --\u003e\n```sh\nperf record --call-graph=dwarf -- ./foo.native a b c d\nperf report\n```\n\nThe first command launches `foo.native` with arguments `a b c d` and\nrecords profiling information in `perf.data`; the second command\nstarts an interactive program to explore the call graph. The option\n`--call-graph=dwarf` makes perf aware of the calling convention of\nOCaml (with old versions of `perf`, enabling frame pointers in OCaml\nmight help; opam provides suitable compiler switches, such as `4.02.1+fp`).\n\n## Summary\nIn summary here are some tips for getting the best performance out of\nyour programs:\n\n1. Write your program as simply as possible. If it takes too long to\n run, profile it to find out where it's spending its time and\n concentrate optimizations on just those areas.\n1. Check for unintentional polymorphism, and add type hints for the\n compiler.\n1. Closures are slower than simple function calls, but add to\n maintainability and readability.\n1. As a last resort, rewrite hotspots in your program in C (but first\n check the assembly language produced by the OCaml compiler to see if\n you can do better than it).\n1. Performance might depend on external factors (speed of your database\n queries? speed of the network?). If so then no amount of\n optimization will help you.\n\n###  Further reading\nYou can find out more about how OCaml represents different types by\nreading the (\"Interfacing C with OCaml\") chapter in the OCaml manual and also\nlooking at the `mlvalues.h` header file.\n\n\u003c!--###  Java dynamic dispatch\n**There are some serious mistakes in the last paragraph:**\n\n* Dynamic method dispatch itself is seldom a performance problem. In\n languages without multiple inheritance (e.g. Java) this is usually\n done via one step of pointer indirection. Objects in OCaml are also\n dynamically dispatched. Since this is the point with polymorphism in\n an OO setting.\n\n* Dynamic method dispatch often hinders a compiler to inline function\n and this hits the performance.\n\n* In Java is a dynamic type check (aka cast) much more expensive than\n a dynamic method dispatch. --\u003e\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#speed\"\u003eSpeed\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#profiling\"\u003eProfiling\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#summary\"\u003eSummary\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003ch2 id=\"speed\"\u003eSpeed\u003c/h2\u003e\n\u003cp\u003eWhy is OCaml fast? Indeed, step back and ask \u003cem\u003eis OCaml fast?\u003c/em\u003e How can we\nmake programs faster? In this chapter we'll look at what actually\nhappens when you compile your OCaml programs down to machine code. This\nwill help in understanding why OCaml is not just a great language for\nprogramming, but is also a very fast language indeed. And it'll help you\nto help the compiler write better machine code for you. It's also (I\nbelieve anyway) a good thing for programmers to have some idea of what\nhappens between you typing \u003ccode\u003eocamlopt\u003c/code\u003e and getting a binary you can run.\u003c/p\u003e\n\u003cp\u003eBut you will need to know some assembler to get the most out of this\nsection. Don't be afraid! I'll help you out by translating the assembler\ninto a C-like pseudocode (after all C is just a portable assembly\nlanguage).\u003c/p\u003e\n\u003ch3 id=\"basics-of-assembly-language\"\u003eBasics of assembly language\u003c/h3\u003e\n\u003cp\u003eThe examples I give in this chapter are all compiled on an x86 Linux\nmachine. The x86 is, of course, a 32 bit machine, so an x86 \u0026quot;word\u0026quot; is 4\nbytes (= 32 bits) long. At this level OCaml deals mostly with word-sized\nobjects, so you'll need to remember to multiply by four to get the size\nin bytes.\u003c/p\u003e\n\u003cp\u003eTo refresh your memory, the x86 has only a small number of general\npurpose registers, each of which can store one word. The Linux assembler\nputs \u003ccode\u003e%\u003c/code\u003e in front of register names. The registers are: \u003ccode\u003e%eax\u003c/code\u003e, \u003ccode\u003e%ebx\u003c/code\u003e,\n\u003ccode\u003e%ecx\u003c/code\u003e, \u003ccode\u003e%edx\u003c/code\u003e, \u003ccode\u003e%esi\u003c/code\u003e, \u003ccode\u003e%edi\u003c/code\u003e, \u003ccode\u003e%ebp\u003c/code\u003e (special register used for stack\nframes), and \u003ccode\u003e%esp\u003c/code\u003e (the stack pointer).\u003c/p\u003e\n\u003cp\u003eThe Linux assembler (in common with other Unix assemblers, but opposite\nto MS-derived assemblers) writes moves to and from registers/memory as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003emovl from, to\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo \u003ccode\u003emovl %ebx, %eax\u003c/code\u003e means \u0026quot;copy the contents of register \u003ccode\u003e%ebx\u003c/code\u003e into\nregister \u003ccode\u003e%eax\u003c/code\u003e\u0026quot; (not the other way round).\u003c/p\u003e\n\u003cp\u003eAlmost all of the assembly language that we will look at is going to be\ndominated not by machine code instructions like \u003ccode\u003emovl\u003c/code\u003e but by what are\nknown as \u003cstrong\u003eassembler directives\u003c/strong\u003e. These directives begin\nwith a . (period) and they literally \u003cem\u003edirect\u003c/em\u003e the assembler to do\nsomething. Here are the common ones for the Linux assembler:\u003c/p\u003e\n\u003ch4 id=\"text\"\u003e.text\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eText\u003c/strong\u003e is the Unix way of saying \u0026quot;program code\u0026quot;. The \u003cstrong\u003etext segment\u003c/strong\u003e\nsimply means the part of the executable where program code is stored.\nThe \u003ccode\u003e.text\u003c/code\u003e directive switches the assembler so it starts writing into\nthe text segment.\u003c/p\u003e\n\u003ch4 id=\"data\"\u003e.data\u003c/h4\u003e\n\u003cp\u003eSimilarly, the \u003ccode\u003e.data\u003c/code\u003e directive switches the assembler so it starts\nwriting into the data segment (part) of the executable.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e  .globl foo\nfoo:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis declares a global symbol called \u003ccode\u003efoo\u003c/code\u003e. It means the address of the\nnext thing to come can be named \u003ccode\u003efoo\u003c/code\u003e. Writing just \u003ccode\u003efoo:\u003c/code\u003e without the\npreceding \u003ccode\u003e.globl\u003c/code\u003e directive declares a local symbol (local to just the\ncurrent file).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e.long 12345\n.byte 9\n.ascii \u0026quot;hello\u0026quot;\n.space 4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e.long\u003c/code\u003e writes a word (4 bytes) to the current segment. \u003ccode\u003e.byte\u003c/code\u003e writes a\nsingle byte. \u003ccode\u003e.ascii\u003c/code\u003e writes a string of bytes (NOT nul-terminated).\n\u003ccode\u003e.space\u003c/code\u003e writes the given number of zero bytes. Normally you use these\nin the data segment.\u003c/p\u003e\n\u003ch3 id=\"the-hello-world-program\"\u003eThe \u0026quot;hello, world\u0026quot; program\u003c/h3\u003e\n\u003cp\u003eEnough assembler. Put the following program into a file called\n\u003ccode\u003esmallest.ml\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eprint_string \u0026quot;hello, world\\n\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd compile it to a native code executable using:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eocamlopt -S smallest.ml -o smallest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e-S\u003c/code\u003e (capital S) tells the compiler to leave the assembly language\nfile (called \u003ccode\u003esmallest.s\u003c/code\u003e - lowercase s) instead of deleting it.\u003c/p\u003e\n\u003cp\u003eHere are the edited highlights of the \u003ccode\u003esmallest.s\u003c/code\u003e file with my comments\nadded. First of all the data segment:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e    .data\n    .long   4348                     ; header for string\n    .globl  Smallest__1\nlest__1:\n    .ascii  \u0026quot;hello, world\\12\u0026quot;        ; string\n    .space  2                        ; padding ..\n    .byte   2                        ;  .. after string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext up the text (program code) segment:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e    .text\n    .globl  Smallest__entry          ; entry point to the program\nlest__entry:\n\n    ; this is equivalent to the C pseudo-code:\n    ; Pervasives.output_string (stdout, \u0026amp;Smallest__1)\n\n    movl    $Smallest__1, %ebx\n    movl    Pervasives + 92, %eax    ; Pervasives + 92 == stdout\n    call    Pervasives__output_string_212\n\n    ; return 1\n\n    movl    $1, %eax\n    ret\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn C everything has to be inside a function. Think about how you can't\njust write \u003ccode\u003eprintf (\u0026quot;hello, world\\n\u0026quot;);\u003c/code\u003e in C, but instead you have to\nput it inside \u003ccode\u003emain () { ... }\u003c/code\u003e. In OCaml you are allowed to have\ncommands at the top level, not inside a function. But when we translate\nthis into assembly language, where do we put those commands? There needs\nto be some way to call those commands from outside, so they need to be\nlabelled in some way. As you can see from the code snippet, OCaml solves\nthis by taking the filename (\u003ccode\u003esmallest.ml\u003c/code\u003e), capitalizing it and adding\n\u003ccode\u003e__entry\u003c/code\u003e, thus making up a symbol called \u003ccode\u003eSmallest__entry\u003c/code\u003e to refer to\nthe top level commands in this file.\u003c/p\u003e\n\u003cp\u003eNow look at the code that OCaml has generated. The original code said\n\u003ccode\u003eprint_string \u0026quot;hello, world\\n\u0026quot;\u003c/code\u003e, but OCaml has instead compiled the\nequivalent of \u003ccode\u003ePervasives.output_string stdout \u0026quot;hello, world\\n\u0026quot;\u003c/code\u003e. Why?\nIf you look into \u003ccode\u003epervasives.ml\u003c/code\u003e you'll see why:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet print_string s = output_string stdout s\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOCaml has \u003cem\u003einlined\u003c/em\u003e this function. \u003cstrong\u003eInlining\u003c/strong\u003e - taking a function and\nexpanding it from its definition - is sometimes a performance win,\nbecause it avoids the overhead of an extra function call, and it can\nlead to more opportunities for the optimizer to do its thing. Sometimes\ninlining is not good, because it can lead to code bloating, and thus\ndestroys the good work done by the processor cache (and besides function\ncalls are actually not very expensive at all on modern processors).\nOCaml will inline simple calls like this, because they are essentially\nrisk free, almost always leading to a small performance gain.\u003c/p\u003e\n\u003cp\u003eWhat else can we notice about this? The calling convention seems to be\nthat the first two arguments are passed in the \u003ccode\u003e%eax\u003c/code\u003e and \u003ccode\u003e%ebx\u003c/code\u003e\nregisters respectively. Other arguments are probably passed on the\nstack, but we'll see about that later.\u003c/p\u003e\n\u003cp\u003eC programs have a simple convention for storing strings, known as\n\u003cstrong\u003eASCIIZ\u003c/strong\u003e. This just means that the string is stored in ASCII, followed\nby a trailing NUL (\u003ccode\u003e\\0\u003c/code\u003e) character. OCaml stores strings in a different\nway, as we can see from the data segment above. This string is stored\nlike this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e4 byte header: 4348\nthe string:    h e l l o , SP w o r l d \\n\npadding:       \\0 \\0 \\002\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFirstly the padding brings the total length of the string up to a whole\nnumber of words (4 words, 16 bytes in this example). The padding is\ncarefully designed so that you can work out the actual length of the\nstring in bytes, provided that you know the total number of \u003cem\u003ewords\u003c/em\u003e\nallocated to the string. The encoding for this is unambiguous (which you\ncan prove to yourself).\u003c/p\u003e\n\u003cp\u003eOne nice feature of having strings with an explicit length is that you\ncan represent strings containing ASCII NUL (\u003ccode\u003e\\0\u003c/code\u003e) characters in them,\nsomething which is difficult to do in C. However, the flip side is that\nyou need to be aware of this if you pass an OCaml string to some C\nnative code: if it contains ASCII NUL, then the C \u003ccode\u003estr*\u003c/code\u003e functions will\nfail on it.\u003c/p\u003e\n\u003cp\u003eSecondly we have the header. Every boxed (allocated) object in OCaml has\na header which tells the garbage collector about how large the object is\nin words, and something about what the object contains. Writing the\nnumber 4348 in binary:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elength of the object in words:  0000 0000 0000 0000 0001 00 (4 words)\ncolor (used by GC):             00\ntag:                            1111 1100 (String_tag)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSee \u003ccode\u003e/usr/include/caml/mlvalues.h\u003c/code\u003e for more information about\nthe format of heap allocated objects in OCaml.\u003c/p\u003e\n\u003cp\u003eOne unusual thing is that the code passes a pointer to the start of the\nstring (ie. the word immediately after the header) to\n\u003ccode\u003ePervasives.output_string\u003c/code\u003e. This means that \u003ccode\u003eoutput_string\u003c/code\u003e must\nsubtract 4 from the pointer to get at the header to determine the length\nof the string.\u003c/p\u003e\n\u003cp\u003eWhat have I missed out from this simple example? Well, the text segment\nabove is not the whole story. It would be really nice if OCaml\ntranslated that simple hello world program into just the five lines of\nassembler shown above. But there is the question of what actually calls\n\u003ccode\u003eSmallest__entry\u003c/code\u003e in the real program. For this OCaml includes a whole\nload of bootstrapping code which does things like starting up the\ngarbage collector, allocating and initializing memory, calling\ninitializers in libraries and so on. OCaml links all of this code\nstatically to the final executable, which is why the program I end up\nwith (on Linux) weighs in at a portly 95,442 bytes. Nevertheless the\nstart-up time for the program is still unmeasurably small (under a\nmillisecond), compared to several seconds for starting up a reasonable\nJava program and a second or so for a Perl script.\u003c/p\u003e\n\u003ch3 id=\"tail-recursion\"\u003eTail recursion\u003c/h3\u003e\n\u003cp\u003eWe mentioned in chapter 6 that OCaml can turn tail-recursive function\ncalls into simple loops. Is this actually true? Let's look at what\nsimple tail recursion compiles to:\u003c/p\u003e\n\u003c!-- do not execute this code!! --\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec loop () =\n  print_string \u0026quot;I go on forever ...\u0026quot;;\n  loop ()\n  \nlet () = loop ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe file is called \u003ccode\u003etail.ml\u003c/code\u003e, so following OCaml's usual procedure for\nnaming functions, our function will be called \u003ccode\u003eTail__loop_nnn\u003c/code\u003e (where\n\u003ccode\u003ennn\u003c/code\u003e is some unique number which OCaml appends to distinguish\nidentically named functions from one another).\u003c/p\u003e\n\u003cp\u003eHere is the assembler for just the \u003ccode\u003eloop\u003c/code\u003e function defined above:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        .text\n        .globl  Tail__loop_56\nTail__loop_56:\n.L100:\n        ; Print the string\n        movl    $Tail__2, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n.L101:\n        ; The following movl is in fact obsolete:\n        movl    $1, %eax\n        ; Jump back to the .L100 label above (ie. loop forever)\n        jmp     .L100\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo that's pretty conclusive. Calling \u003ccode\u003eTail__loop_56\u003c/code\u003e will first print\nthe string, and then jump back to the top, then print the string, and\njump back, and so on forever. It's a simple loop, \u003cem\u003enot\u003c/em\u003e a recursive\nfunction call, so it doesn't use any stack space.\u003c/p\u003e\n\u003ch3 id=\"digression-where-are-the-types\"\u003eDigression: Where are the types?\u003c/h3\u003e\n\u003cp\u003eOCaml is statically typed as we've said before on many occasions, so at\ncompile time, OCaml knows that the type of \u003ccode\u003eloop\u003c/code\u003e is \u003ccode\u003eunit -\u0026gt; unit\u003c/code\u003e. It\nknows that the type of \u003ccode\u003e\u0026quot;hello, world\\n\u0026quot;\u003c/code\u003e is \u003ccode\u003estring\u003c/code\u003e. It doesn't make\nany attempt to communicate this fact to the \u003ccode\u003eoutput_string\u003c/code\u003e function.\n\u003ccode\u003eoutput_string\u003c/code\u003e is expecting a \u003ccode\u003echannel\u003c/code\u003e and a \u003ccode\u003estring\u003c/code\u003e as arguments,\nand indeed that's what it gets. What would happen if we passed, say, an\n\u003ccode\u003eint\u003c/code\u003e instead of a \u003ccode\u003estring\u003c/code\u003e?\u003c/p\u003e\n\u003cp\u003eThis is essentially an impossible condition. Because OCaml knows the\ntypes at compile time, it doesn't need to deal with types or check types\nat run time. There is no way, in pure OCaml, to \u0026quot;trick\u0026quot; the compiler\ninto generating a call to \u003ccode\u003ePervasives.output_string stdout 1\u003c/code\u003e. Such an\nerror would be flagged at compile time, by type inference, and so could\nnever be compiled.\u003c/p\u003e\n\u003cp\u003eThe upshot is that by the time we have compiled OCaml code to assembler\ntype information mostly isn't required, certainly in the cases we've\nlooked at above where the type is fully known at compile time, and there\nis no polymorphism going on.\u003c/p\u003e\n\u003cp\u003eFully knowing all your types at compile time is a major performance win\nbecause it totally avoids any dynamic type checking at run time. Compare\nthis to a Java method invocation for example: \u003ccode\u003eobj.method ()\u003c/code\u003e. This is\nan expensive operation because you need to find the concrete class that\n\u003ccode\u003eobj\u003c/code\u003e is an instance of, and then look up the method, and you need to do\nall of this potentially \u003cem\u003eevery\u003c/em\u003e time you call any method. Casting\nobjects is another case where you need to do a considerable amount of\nwork at run time in Java. None of this is allowed with OCaml's static\ntypes.\u003c/p\u003e\n\u003ch3 id=\"polymorphic-types\"\u003ePolymorphic types\u003c/h3\u003e\n\u003cp\u003eAs you might have guessed from the discussion above, polymorphism, which\nis where the compiler \u003cem\u003edoesn't\u003c/em\u003e have a fully known type for a function\nat compile time, might have an impact on performance. Suppose we require\na function to work out the maximum of two integers. Our first attempt\nis:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let max a b =\n  if a \u0026gt; b then a else b\nval max : 'a -\u0026gt; 'a -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSimple enough, but recall that the \u0026gt; (greater than) operator in OCaml\nis polymorphic. It has type \u003ccode\u003e'a -\u0026gt; 'a -\u0026gt; bool\u003c/code\u003e, and this means that the\n\u003ccode\u003emax\u003c/code\u003e function we defined above is going to be polymorphic:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let max a b =\n  if a \u0026gt; b then a else b\nval max : 'a -\u0026gt; 'a -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is indeed reflected in the code that OCaml generates for this\nfunction, which is pretty complex:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        .text\n        .globl  Max__max_56\nMax__max_56:\n\n        ; Reserve two words of stack space.\n\n        subl    $8, %esp\n\n        ; Save the first and second arguments (a and b) on the stack.\n\n        movl    %eax, 4(%esp)\n        movl    %ebx, 0(%esp)\n\n        ; Call the C \u0026quot;greaterthan\u0026quot; function (in the OCaml library).\n\n        pushl   %ebx\n        pushl   %eax\n        movl    $greaterthan, %eax\n        call    caml_c_call\n.L102:\n        addl    $8, %esp\n\n        ; If the C \u0026quot;greaterthan\u0026quot; function returned 1, jump to .L100\n\n        cmpl    $1, %eax\n        je      .L100\n\n        ; Returned 0, so get argument a which we previously saved on\n        ; the stack and return it.\n\n        movl    4(%esp), %eax\n        addl    $8, %esp\n        ret\n\n        ; Returned 1, so get argument b which we previously saved on\n        ; the stack and return it.\n\n.L100:\n        movl    0(%esp), %eax\n        addl    $8, %esp\n        ret\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBasically the \u0026gt; operation is done by calling a C function from the\nOCaml library. This is obviously not going to be very efficient, nothing\nlike as efficient as if we could generate some quick inline assembly\nlanguage for doing the \u0026gt;.\u003c/p\u003e\n\u003cp\u003eThis is not a complete dead loss by any means. All we need to do is to\nhint to the OCaml compiler that the arguments are in fact integers. Then\nOCaml will generate a specialised version of \u003ccode\u003emax\u003c/code\u003e which only works on\n\u003ccode\u003eint\u003c/code\u003e arguments:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let max (a : int) (b : int) =\n  if a \u0026gt; b then a else b\nval max : int -\u0026gt; int -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is the assembly code generated for this function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        .text\n        .globl  Max_int__max_56\nMax_int__max_56:\n\n        ; Single assembly instruction \u0026quot;cmpl\u0026quot; for performing the \u0026gt; op.\n        cmpl    %ebx, %eax\n\n        ; If %ebx \u0026gt; %eax, jump to .L100\n        jle     .L100\n        ; Just return argument a.\n        ret\n        ; Return argument b.\n\n.L100:\n        movl    %ebx, %eax\n        ret\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat's just 5 lines of assembler, and is about as simple as you can make\nit.\u003c/p\u003e\n\u003cp\u003eWhat about this code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let max a b =\n  if a \u0026gt; b then a else b\nval max : 'a -\u0026gt; 'a -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n# let () = print_int (max 2 3)\n3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIs OCaml going to be smart enough to inline the \u003ccode\u003emax\u003c/code\u003e function and\nspecialise it to work on integers? Disappointingly the answer is no.\nOCaml still has to generate the external \u003ccode\u003eMax.max\u003c/code\u003e symbol (because this\nis a module, and so that function might be called from outside the\nmodule), and it doesn't inline the function.\u003c/p\u003e\n\u003cp\u003eHere's another variation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let max a b =\n  if a \u0026gt; b then a else b in\n  print_int (max 2 3)\n3\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDisappointingly although the definition of \u003ccode\u003emax\u003c/code\u003e in this code is local\n(it can't be called from outside the module), OCaml still doesn't\nspecialise the function.\u003c/p\u003e\n\u003cp\u003eLesson: if you have a function which is unintentionally polymorphic then\nyou can help the compiler by specifying types for one or more of the\narguments.\u003c/p\u003e\n\u003ch3 id=\"the-representation-of-integers-tag-bits-heap-allocated-values\"\u003eThe representation of integers, tag bits, heap-allocated values\u003c/h3\u003e\n\u003cp\u003eThere are a number of peculiarities about integers in OCaml. One of\nthese is that integers are 31 bit entities, not 32 bit entities. What\nhappens to the \u0026quot;missing\u0026quot; bit?\u003c/p\u003e\n\u003cp\u003eWrite this to \u003ccode\u003eint.ml\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eprint_int 3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand compile with \u003ccode\u003eocamlopt -S int.ml -o int\u003c/code\u003e to generate assembly\nlanguage in \u003ccode\u003eint.s\u003c/code\u003e. Recall from the discussion above that we are\nexpecting OCaml to inline the \u003ccode\u003eprint_int\u003c/code\u003e function as\n\u003ccode\u003eoutput_string (string_of_int 3)\u003c/code\u003e, and examining the assembly language\noutput we can see that this is exactly what OCaml does:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        .text\n        .globl  Int__entry\nInt__entry:\n\n        ; Call Pervasives.string_of_int (3)\n\n        movl    $7, %eax\n        call    Pervasives__string_of_int_152\n\n        ; Call Pervasives.output_string (stdout, result_of_previous)\n\n        movl    %eax, %ebx\n        movl    Pervasives + 92, %eax\n        call    Pervasives__output_string_212\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe important code is shown in red. It shows two things: Firstly the\ninteger is unboxed (not allocated on the heap), but is instead passed\ndirectly to the function in the register \u003ccode\u003e%eax\u003c/code\u003e. This is fast. But\nsecondly we see that the number being passed is 7, not 3.\u003c/p\u003e\n\u003cp\u003eThis is a consequence of the representation of integers in OCaml. The\nbottom bit of the integer is used as a tag - we'll see what for next.\nThe top 31 bits are the actual integer. The binary representation of 7\nis 111, so the bottom tag bit is 1 and the top 31 bits form the number\n11 in binary = 3. To get from the OCaml representation to the integer,\ndivide by two and round down.\u003c/p\u003e\n\u003cp\u003eWhy the tag bit at all? This bit is used to distinguish between integers\nand pointers to structures on the heap, and the distinction is only\nnecessary if we are calling a polymorphic function. In the case above,\nwhere we are calling \u003ccode\u003estring_of_int\u003c/code\u003e, the argument can only ever be an\n\u003ccode\u003eint\u003c/code\u003e and so the tag bit would never be consulted. Nevertheless, to\navoid having two internal representations for integers, all integers in\nOCaml carry around the tag bit.\u003c/p\u003e\n\u003cp\u003eA bit of background about pointers is required to understand why the tag\nbit is really necessary, and why it is where it is.\u003c/p\u003e\n\u003cp\u003eIn the world of RISC chips like the Sparc, MIPS and Alpha, pointers have\nto be word-aligned. So on the older 32 bit Sparc, for example, it's not\npossible to create and use a pointer which isn't aligned to a multiple\nof 4 (bytes). Trying to use one generates a processor exception, which\nmeans basically your program segfaults. The reason for this is just to\nsimplify memory access. It's just a lot simpler to design the memory\nsubsystem of a CPU if you only need to worry about word-aligned access.\u003c/p\u003e\n\u003cp\u003eFor historical reasons (because the x86 is derived from an 8 bit chip),\nthe x86 has supported unaligned memory access, although if you align all\nmemory accesses to multiples of 4, then things go faster.\u003c/p\u003e\n\u003cp\u003eNevertheless, all pointers in OCaml are aligned - ie. multiples of 4 for\n32 bit processors, and multiples of 8 for 64 bit processors. This means\nthat the bottom bit of any pointer in OCaml will always be zero.\u003c/p\u003e\n\u003cp\u003eSo you can see that by looking at the bottom bit of a register, you can\nimmediately tell if it stores a pointer (\u0026quot;tag\u0026quot; bit is zero), or an\ninteger (tag bit set to one).\u003c/p\u003e\n\u003cp\u003eRemember our polymorphic \u0026gt; function which caused us so much trouble in\nthe previous section? We looked at the assembler and found out that\nOCaml compiles a call to a C function called \u003ccode\u003egreaterthan\u003c/code\u003e whenever it\nsees the polymorphic form of \u0026gt;. This function takes two arguments, in\nregisters \u003ccode\u003e%eax\u003c/code\u003e and \u003ccode\u003e%ebx\u003c/code\u003e. But \u003ccode\u003egreaterthan\u003c/code\u003e can be called with\nintegers, floats, strings, opaque objects ... How does it know what\n\u003ccode\u003e%eax\u003c/code\u003e and \u003ccode\u003e%ebx\u003c/code\u003e point to?\u003c/p\u003e\n\u003cp\u003eIt uses the following decision tree:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTag bit is one:\u003c/strong\u003e compare the two integers and return.\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTag bit is zero:\u003c/strong\u003e \u003ccode\u003e%eax\u003c/code\u003e and \u003ccode\u003e%ebx\u003c/code\u003e must point at two\nheap-allocated memory blocks. Look at the header word of the memory\nblocks, specifically the bottom 8 bits of the header word, which tag\nthe content of the block.\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eString_tag:\u003c/strong\u003e Compare two strings.\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDouble_tag:\u003c/strong\u003e Compare two floats.\n\u003c/li\u003e\n\u003cli\u003eetc.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote that because \u0026gt; has type \u003ccode\u003e'a -\u0026gt; 'a -\u0026gt; bool\u003c/code\u003e, both arguments must\nhave the same type. The compiler should enforce this at compile time. I\nwould assume that \u003ccode\u003egreaterthan\u003c/code\u003e probably contains code to sanity-check\nthis at run time however.\u003c/p\u003e\n\u003ch3 id=\"floats\"\u003eFloats\u003c/h3\u003e\n\u003cp\u003eFloats are, by default, boxed (allocated on the heap). Save this as\n\u003ccode\u003efloat.ml\u003c/code\u003e and compile it with \u003ccode\u003eocamlopt -S float.ml -o float\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocamltop\"\u003eprint_float 3.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe number is not passed directly to \u003ccode\u003estring_of_float\u003c/code\u003e in the \u003ccode\u003e%eax\u003c/code\u003e\nregister as happened above with ints. Instead, it is created statically\nin the data segment:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        .data\n        .long   2301\n        .globl  Float__1\nFloat__1:\n        .double 3.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand a pointer to the float is passed in \u003ccode\u003e%eax\u003c/code\u003e instead:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        movl    $Float__1, %eax\n        call    Pervasives__string_of_float_157\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the structure of the floating point number: it has a header (2301),\nfollowed by the 8 byte (2 word) representation of the number itself. The\nheader can be decoded by writing it as binary:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eLength of the object in words:  0000 0000 0000 0000 0000 10 (8 bytes)\nColor:                          00\nTag:                            1111 1101 (Double_tag)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003estring_of_float\u003c/code\u003e isn't polymorphic, but suppose we have a polymorphic\nfunction \u003ccode\u003efoo : 'a -\u0026gt; unit\u003c/code\u003e taking one polymorphic argument. If we call\n\u003ccode\u003efoo\u003c/code\u003e with \u003ccode\u003e%eax\u003c/code\u003e containing 7, then this is equivalent to \u003ccode\u003efoo 3\u003c/code\u003e,\nwhereas if we call \u003ccode\u003efoo\u003c/code\u003e with \u003ccode\u003e%eax\u003c/code\u003e containing a pointer to \u003ccode\u003eFloat__1\u003c/code\u003e\nabove, then this is equivalent to \u003ccode\u003efoo 3.0\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"arrays\"\u003eArrays\u003c/h3\u003e\n\u003cp\u003eI mentioned earlier that one of OCaml's targets was numerical computing.\nNumerical computing does a lot of work on vectors and matrices, which\nare essentially arrays of floats. As a special hack to make this go\nfaster, OCaml implements \u003cstrong\u003earrays of unboxed floats\u003c/strong\u003e. This\nmeans that in the special case where we have an object of type\n\u003ccode\u003efloat array\u003c/code\u003e (array of floats), OCaml stores them the same way as in C:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C\"\u003edouble array[10];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e... instead of having an array of pointers to ten separately allocated\nfloats on the heap.\u003c/p\u003e\n\u003cp\u003eLet's see this in practice:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet a = Array.create 10 0.0;;\nfor i = 0 to 9 do\n  a.(i) \u0026lt;- float_of_int i\ndone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI'm going to compile this code with the \u003ccode\u003e-unsafe\u003c/code\u003e option to remove\nbounds checking (simplifying the code for our exposition here). The\nfirst line, which creates the array, is compiled to a simple C call:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        pushl   $Arrayfloats__1     ; Boxed float 0.0\n        pushl   $21                 ; The integer 10\n        movl    $make_vect, %eax    ; Address of the C function to call\n        call    caml_c_call\n    ; ...\n        movl    %eax, Arrayfloats   ; Store the resulting pointer to the\n                                    ; array at this place on the heap.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe loop is compiled to this relatively simple assembly language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        movl    $1, %eax            ; Let %eax = 0. %eax is going to store i.\n        cmpl    $19, %eax           ; If %eax \u0026gt; 9, then jump out of the\n        jg      .L100               ;   loop (to label .L100 at the end).\n\n.L101:                              ; This is the start of the loop body.\n        movl    Arrayfloats, %ecx   ; Address of the array to %ecx.\n\n        movl    %eax, %ebx          ; Copy i to %ebx.\n        sarl    $1, %ebx            ; Remove the tag bit from %ebx by\n                                    ;   shifting it right 1 place. So %ebx\n                                    ;   now contains the real integer i.\n\n        pushl   %ebx                ; Convert %ebx to a float.\n        fildl   (%esp)\n        addl    $4, %esp\n\n        fstpl   -4(%ecx, %eax, 4)   ; Store the float in the array at the ith\n                                ; position.\n\n        addl    $2, %eax            ; i := i + 1\n        cmpl    $19, %eax           ; If i \u0026lt;= 9, loop around again.\n        jle     .L101\n.L100:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe important statement is the one which stores the float into the\narray. It is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        fstpl   -4(%ecx, %eax, 4)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe assembler syntax is rather complex, but the bracketed expression\n\u003ccode\u003e-4(%ecx, %eax, 4)\u003c/code\u003e means \u0026quot;at the address \u003ccode\u003e%ecx + 4*%eax - 4\u003c/code\u003e\u0026quot;. Recall\nthat \u003ccode\u003e%eax\u003c/code\u003e is the OCaml representation of i, complete with tag bit, so\nit is essentially equal to \u003ccode\u003ei*2+1\u003c/code\u003e, so let's substitute that and\nmultiply it out:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e  %ecx + 4*%eax - 4\n= %ecx + 4*(i*2+1) - 4\n= %ecx + 4*i*2 + 4 - 4\n= %ecx + 8*i\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Each float in the array is 8 bytes long.)\u003c/p\u003e\n\u003cp\u003eSo arrays of floats are unboxed, as expected.\u003c/p\u003e\n\u003ch3 id=\"partially-applied-functions-and-closures\"\u003ePartially applied functions and closures\u003c/h3\u003e\n\u003cp\u003eHow does OCaml compile functions which are only partially applied? Let's\ncompile this code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eArray.map ((+) 2) [|1; 2; 3; 4; 5|]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you recall the syntax, \u003ccode\u003e[| ... |]\u003c/code\u003e declares an array (in this case an\n\u003ccode\u003eint array\u003c/code\u003e), and \u003ccode\u003e((+) 2)\u003c/code\u003e is a closure - \u0026quot;the function which adds 2 to\nthings\u0026quot;.\u003c/p\u003e\n\u003cp\u003eCompiling this code reveals some interesting new features. Firstly the\ncode which allocates the array:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        movl    $24, %eax           ; Allocate 5 * 4 + 4 = 24 bytes of memory.\n        call    caml_alloc\n\n        leal    4(%eax), %eax       ; Let %eax point to 4 bytes into the\n                                    ;   allocated memory.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAll heap allocations have the same format: 4 byte header + data. In this\ncase the data is 5 integers, so we allocate 4 bytes for the header plus\n5 * 4 bytes for the data. We update the pointer to point at the first\ndata word, ie. 4 bytes into the allocated memory block.\u003c/p\u003e\n\u003cp\u003eNext OCaml generates code to initialize the array:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        movl    $5120, -4(%eax)\n        movl    $3, (%eax)\n        movl    $5, 4(%eax)\n        movl    $7, 8(%eax)\n        movl    $9, 12(%eax)\n        movl    $11, 16(%eax)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe header word is 5120, which if you write it in binary means a block\ncontaining 5 words, with tag zero. The tag of zero means it's a\n\u0026quot;structured block\u0026quot; a.k.a. an array. We also copy the numbers 1, 2, 3, 4\nand 5 to the appropriate places in the array. Notice the OCaml\nrepresentation of integers is used. Because this is a structured block,\nthe garbage collector will scan each word in this block, and the GC\nneeds to be able to distinguish between integers and pointers to other\nheap-allocated blocks (the GC does not have access to type information\nabout this array).\u003c/p\u003e\n\u003cp\u003eNext the closure \u003ccode\u003e((+) 2)\u003c/code\u003e is created. The closure is represented by\nthis block allocated in the data segment:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        .data\n        .long   3319\n        .globl  Closure__1\nClosure__1:\n        .long   caml_curry2\n        .long   5\n        .long   Closure__fun_58\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe header is 3319, indicating a \u003ccode\u003eClosure_tag\u003c/code\u003e with length 3 words. The\n3 words in the block are the address of the function \u003ccode\u003ecaml_curry2\u003c/code\u003e, the\ninteger number 2 and the address of this function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e        .text\n        .globl  Closure__fun_58\nClosure__fun_58:\n\n        ; The function takes two arguments, %eax and %ebx.\n        ; This line causes the function to return %eax + %ebx - 1.\n\n        lea     -1(%eax, %ebx), %eax\n        ret\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat does this function do? On the face of it, it adds the two\narguments, and subtracts one. But remember that \u003ccode\u003e%eax\u003c/code\u003e and \u003ccode\u003e%ebx\u003c/code\u003e are in\nthe OCaml representation for integers. Let's represent them as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e%eax = 2 * a + 1\u003c/code\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e%ebx = 2 * b + 1\u003c/code\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ewhere \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e are the actual integer arguments. So this function\nreturns:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e%eax + %ebx - 1\n= 2 * a + 1 + 2 * b + 1 - 1\n= 2 * a + 2 * b + 1\n= 2 * (a + b) + 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn other words, this function returns the OCaml integer representation\nof the sum \u003ccode\u003ea + b\u003c/code\u003e. This function is \u003ccode\u003e(+)\u003c/code\u003e!\u003c/p\u003e\n\u003cp\u003e(It's actually more subtle than this - to perform the mathematics\nquickly, OCaml uses the x86 addressing hardware in a way that probably\nwasn't intended by the designers of the x86.)\u003c/p\u003e\n\u003cp\u003eSo back to our closure - we won't go into the details of the\n\u003ccode\u003ecaml_curry2\u003c/code\u003e function, but just say that this closure is the argument\n\u003ccode\u003e2\u003c/code\u003e applied to the function \u003ccode\u003e(+)\u003c/code\u003e, waiting for a second argument. Just\nas expected.\u003c/p\u003e\n\u003cp\u003eThe actual call to the \u003ccode\u003eArray.map\u003c/code\u003e function is quite difficult to\nunderstand, but the main points for our examination of OCaml is that the\ncode:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDoes call \u003ccode\u003eArray.map\u003c/code\u003e with an explicit closure.\n\u003c/li\u003e\n\u003cli\u003eDoes not attempt to inline the call and turn it into a loop.\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCalling \u003ccode\u003eArray.map\u003c/code\u003e in this way is undoubtedly slower than writing a\nloop over the array by hand. The overhead is mainly in the fact that the\nclosure must be evaluated for each element of the array, and that isn't\nas fast as inlining the closure as a function (if this optimization were\neven possible). However, if you had a more substantial closure than just\n\u003ccode\u003e((+) 2)\u003c/code\u003e, the overhead would be reduced. The FP version also saves\nexpensive \u003cem\u003eprogrammer\u003c/em\u003e time versus writing the imperative loop.\u003c/p\u003e\n\u003ch2 id=\"profiling\"\u003eProfiling\u003c/h2\u003e\n\u003cp\u003eThere are two types of profiling that you can do on OCaml programs:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eGet execution counts for bytecode.\n\u003c/li\u003e\n\u003cli\u003eGet real profiling for native code.\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe \u003ccode\u003eocamlcp\u003c/code\u003e and \u003ccode\u003eocamlprof\u003c/code\u003e programs perform profiling on bytecode.\nHere is an example:\u003c/p\u003e\n\u003c!-- $MDX file=examples/gc.ml --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec iterate r x_init i =\n  if i = 1 then x_init\n  else\n    let x = iterate r x_init (i - 1) in\n    r *. x *. (1.0 -. x)\n\nlet () =\n  Random.self_init ();\n  Graphics.open_graph \u0026quot; 640x480\u0026quot;;\n  for x = 0 to 640 do\n    let r = 4.0 *. float_of_int x /. 640.0 in\n    for i = 0 to 39 do\n      let x_init = Random.float 1.0 in\n      let x_final = iterate r x_init 500 in\n      let y = int_of_float (x_final *. 480.) in\n      Graphics.plot x y\n    done\n  done;\n  Gc.print_stat stdout\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd can be run and compiled with\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode\u003e$ ocamlcp -p a graphics.cma graphtest.ml -o graphtest\n$ ./graphtest\n$ ocamlprof graphtest.ml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe comments \u003ccode\u003e(* nnn *)\u003c/code\u003e are added by \u003ccode\u003eocamlprof\u003c/code\u003e, showing how many\ntimes each part of the code was called.\u003c/p\u003e\n\u003cp\u003eProfiling native code is done using your operating system's native\nsupport for profiling. In the case of Linux, we use \u003ccode\u003egprof\u003c/code\u003e. An alternative\nis \u003ca href=\"https://en.wikipedia.org/wiki/Perf_(Linux)\"\u003eperf\u003c/a\u003e, as explained below.\u003c/p\u003e\n\u003cp\u003eWe compile it using the \u003ccode\u003e-p\u003c/code\u003e option to \u003ccode\u003eocamlopt\u003c/code\u003e which tells the\ncompiler to include profiling information for \u003ccode\u003egprof\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003eAfter running the program as normal, the profiling code dumps out a file\n\u003ccode\u003egmon.out\u003c/code\u003e which we can interpret with \u003ccode\u003egprof\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ gprof ./a.out\nFlat profile:\n  \nEach sample counts as 0.01 seconds.\n  %   cumulative   self              self     total\n time   seconds   seconds    calls   s/call   s/call  name\n 10.86      0.57     0.57     2109     0.00     0.00  sweep_slice\n  9.71      1.08     0.51     1113     0.00     0.00  mark_slice\n  7.24      1.46     0.38  4569034     0.00     0.00  Sieve__code_begin\n  6.86      1.82     0.36  9171515     0.00     0.00  Stream__set_data_140\n  6.57      2.17     0.34 12741964     0.00     0.00  fl_merge_block\n  6.29      2.50     0.33  4575034     0.00     0.00  Stream__peek_154\n  5.81      2.80     0.30 12561656     0.00     0.00  alloc_shr\n  5.71      3.10     0.30     3222     0.00     0.00  oldify_mopup\n  4.57      3.34     0.24 12561656     0.00     0.00  allocate_block\n  4.57      3.58     0.24  9171515     0.00     0.00  modify\n  4.38      3.81     0.23  8387342     0.00     0.00  oldify_one\n  3.81      4.01     0.20 12561658     0.00     0.00  fl_allocate\n  3.81      4.21     0.20  4569034     0.00     0.00  Sieve__filter_56\n  3.62      4.40     0.19     6444     0.00     0.00  empty_minor_heap\n  3.24      4.57     0.17     3222     0.00     0.00  oldify_local_roots\n  2.29      4.69     0.12  4599482     0.00     0.00  Stream__slazy_221\n  2.10      4.80     0.11  4597215     0.00     0.00  darken\n  1.90      4.90     0.10  4596481     0.00     0.00  Stream__fun_345\n  1.52      4.98     0.08  4575034     0.00     0.00  Stream__icons_207\n  1.52      5.06     0.08  4575034     0.00     0.00  Stream__junk_165\n  1.14      5.12     0.06     1112     0.00     0.00  do_local_roots\n  \n[ etc. ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"using-perf-on-linux\"\u003eUsing perf on Linux\u003c/h3\u003e\n\u003cp\u003eAssuming perf is installed and your program is compiled into\nnative code with \u003ccode\u003e-g\u003c/code\u003e (or ocamlbuild tag \u003ccode\u003edebug\u003c/code\u003e), you just need to type\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003eperf record --call-graph=dwarf -- ./foo.native a b c d\nperf report\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe first command launches \u003ccode\u003efoo.native\u003c/code\u003e with arguments \u003ccode\u003ea b c d\u003c/code\u003e and\nrecords profiling information in \u003ccode\u003eperf.data\u003c/code\u003e; the second command\nstarts an interactive program to explore the call graph. The option\n\u003ccode\u003e--call-graph=dwarf\u003c/code\u003e makes perf aware of the calling convention of\nOCaml (with old versions of \u003ccode\u003eperf\u003c/code\u003e, enabling frame pointers in OCaml\nmight help; opam provides suitable compiler switches, such as \u003ccode\u003e4.02.1+fp\u003c/code\u003e).\u003c/p\u003e\n\u003ch2 id=\"summary\"\u003eSummary\u003c/h2\u003e\n\u003cp\u003eIn summary here are some tips for getting the best performance out of\nyour programs:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWrite your program as simply as possible. If it takes too long to\nrun, profile it to find out where it's spending its time and\nconcentrate optimizations on just those areas.\n\u003c/li\u003e\n\u003cli\u003eCheck for unintentional polymorphism, and add type hints for the\ncompiler.\n\u003c/li\u003e\n\u003cli\u003eClosures are slower than simple function calls, but add to\nmaintainability and readability.\n\u003c/li\u003e\n\u003cli\u003eAs a last resort, rewrite hotspots in your program in C (but first\ncheck the assembly language produced by the OCaml compiler to see if\nyou can do better than it).\n\u003c/li\u003e\n\u003cli\u003ePerformance might depend on external factors (speed of your database\nqueries? speed of the network?). If so then no amount of\noptimization will help you.\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"further-reading\"\u003eFurther reading\u003c/h3\u003e\n\u003cp\u003eYou can find out more about how OCaml represents different types by\nreading the (\u0026quot;Interfacing C with OCaml\u0026quot;) chapter in the OCaml manual and also\nlooking at the \u003ccode\u003emlvalues.h\u003c/code\u003e header file.\u003c/p\u003e\n\u003c!--###  Java dynamic dispatch\n**There are some serious mistakes in the last paragraph:**\n\n* Dynamic method dispatch itself is seldom a performance problem. In\n languages without multiple inheritance (e.g. Java) this is usually\n done via one step of pointer indirection. Objects in OCaml are also\n dynamically dispatched. Since this is the point with polymorphism in\n an OO setting.\n\n* Dynamic method dispatch often hinders a compiler to inline function\n and this hits the performance.\n\n* In Java is a dynamic type check (aka cast) much more expensive than\n a dynamic method dispatch. --\u003e\n"},{"title":"Comparison of Standard Containers","slug":"comparison-of-standard-containers","description":"A comparison of some core data-structures including lists, queues and arrays\n","date":"2021-05-27T21:07:30-00:00","tags":{"hd":"language","tl":0},"users":{"hd":"Intermediate","tl":0},"body_md":"\nThis is a rough comparison of the different container types that are\nprovided by the OCaml language or by the OCaml standard library. In each\ncase, n is the number of valid elements in the container.\n\nNote that the big-O cost given for some operations reflects the current\nimplementation but is not guaranteed by the official documentation.\nHopefully it will not become worse. Anyway, if you want more details,\nyou should read the documentation about each of the modules. Often, it\nis also instructive to read the corresponding implementation.\n\n## Lists: immutable singly-linked lists\nAdding an element always creates a new list l from an element x and list\ntl. tl remains unchanged, but it is not copied either.\n\n* \"adding\" an element: O(1), cons operator `::`\n* length: O(n), function `List.length`\n* accessing cell `i`: O(i)\n* finding an element: O(n)\n\nWell-suited for: IO, pattern-matching\n\nNot very efficient for: random access, indexed elements\n\n## Arrays: mutable vectors\nArrays are mutable data structures with a fixed length and random access.\n\n* \"adding\" an element (by creating a new array): O(n)\n* length: O(1), function `Array.length`\n* accessing cell `i`: O(1)\n* finding an element: O(n)\n\nWell-suited for sets of elements of known size, access by numeric index,\nin-place modification. Basic arrays have a fixed length.\n\n## Strings: immutable vectors\nStrings are very similar to arrays but are immutable. Strings are\nspecialized for storing chars (bytes) and have some convenient syntax.\nStrings have a fixed length. For extensible strings, the standard Buffer\nmodule can be used (see below).\n\n* \"adding\" an element (by creating a new string): O(n)\n* length: O(1)\n* accessing character `i`: O(1)\n* finding an element: O(n)\n\n## Set and Map: immutable trees\nLike lists, these are immutable and they may share some subtrees. They\nare a good solution for keeping older versions of sets of items.\n\n* \"adding\" an element: O(log n)\n* returning the number of elements: O(n)\n* finding an element: O(log n)\n\nSets and maps are very useful in compilation and meta-programming, but\nin other situations hash tables are often more appropriate (see below).\n\n## Hashtbl: automatically growing hash tables\nOcaml hash tables are mutable data structures, which are a good solution\nfor storing (key, data) pairs in one single place.\n\n* adding an element: O(1) if the initial size of the table is larger\n than the number of elements it contains; O(log n) on average if n\n elements have been added in a table which is initially much smaller\n than n.\n* returning the number of elements: O(1)\n* finding an element: O(1)\n\n## Buffer: extensible strings\nBuffers provide an efficient way to accumulate a sequence of bytes in a\nsingle place. They are mutable.\n\n* adding a char: O(1) if the buffer is big enough, or O(log n) on\n average if the initial size of the buffer was much smaller than the\n number of bytes n.\n* adding a string of k chars: O(k * \"adding a char\")\n* length: O(1)\n* accessing cell `i`: O(1)\n\n## Queue\nOCaml queues are mutable first-in-first-out (FIFO) data structures.\n\n* adding an element: O(1)\n* taking an element: O(1)\n* length: O(1)\n\n## Stack\nOCaml stacks are mutable last-in-first-out (LIFO) data structures. They\nare just like lists, except that they are mutable, i.e. adding an\nelement doesn't create a new stack but simply adds it to the stack.\n\n* adding an element: O(1)\n* taking an element: O(1)\n* length: O(1)\n","toc_html":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#lists-immutable-singly-linked-lists\"\u003eLists: immutable singly-linked lists\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#arrays-mutable-vectors\"\u003eArrays: mutable vectors\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#strings-immutable-vectors\"\u003eStrings: immutable vectors\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#set-and-map-immutable-trees\"\u003eSet and Map: immutable trees\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#hashtbl-automatically-growing-hash-tables\"\u003eHashtbl: automatically growing hash tables\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#buffer-extensible-strings\"\u003eBuffer: extensible strings\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#queue\"\u003eQueue\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#stack\"\u003eStack\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","body_html":"\u003cp\u003eThis is a rough comparison of the different container types that are\nprovided by the OCaml language or by the OCaml standard library. In each\ncase, n is the number of valid elements in the container.\u003c/p\u003e\n\u003cp\u003eNote that the big-O cost given for some operations reflects the current\nimplementation but is not guaranteed by the official documentation.\nHopefully it will not become worse. Anyway, if you want more details,\nyou should read the documentation about each of the modules. Often, it\nis also instructive to read the corresponding implementation.\u003c/p\u003e\n\u003ch2 id=\"lists-immutable-singly-linked-lists\"\u003eLists: immutable singly-linked lists\u003c/h2\u003e\n\u003cp\u003eAdding an element always creates a new list l from an element x and list\ntl. tl remains unchanged, but it is not copied either.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026quot;adding\u0026quot; an element: O(1), cons operator \u003ccode\u003e::\u003c/code\u003e\n\u003c/li\u003e\n\u003cli\u003elength: O(n), function \u003ccode\u003eList.length\u003c/code\u003e\n\u003c/li\u003e\n\u003cli\u003eaccessing cell \u003ccode\u003ei\u003c/code\u003e: O(i)\n\u003c/li\u003e\n\u003cli\u003efinding an element: O(n)\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWell-suited for: IO, pattern-matching\u003c/p\u003e\n\u003cp\u003eNot very efficient for: random access, indexed elements\u003c/p\u003e\n\u003ch2 id=\"arrays-mutable-vectors\"\u003eArrays: mutable vectors\u003c/h2\u003e\n\u003cp\u003eArrays are mutable data structures with a fixed length and random access.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026quot;adding\u0026quot; an element (by creating a new array): O(n)\n\u003c/li\u003e\n\u003cli\u003elength: O(1), function \u003ccode\u003eArray.length\u003c/code\u003e\n\u003c/li\u003e\n\u003cli\u003eaccessing cell \u003ccode\u003ei\u003c/code\u003e: O(1)\n\u003c/li\u003e\n\u003cli\u003efinding an element: O(n)\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWell-suited for sets of elements of known size, access by numeric index,\nin-place modification. Basic arrays have a fixed length.\u003c/p\u003e\n\u003ch2 id=\"strings-immutable-vectors\"\u003eStrings: immutable vectors\u003c/h2\u003e\n\u003cp\u003eStrings are very similar to arrays but are immutable. Strings are\nspecialized for storing chars (bytes) and have some convenient syntax.\nStrings have a fixed length. For extensible strings, the standard Buffer\nmodule can be used (see below).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026quot;adding\u0026quot; an element (by creating a new string): O(n)\n\u003c/li\u003e\n\u003cli\u003elength: O(1)\n\u003c/li\u003e\n\u003cli\u003eaccessing character \u003ccode\u003ei\u003c/code\u003e: O(1)\n\u003c/li\u003e\n\u003cli\u003efinding an element: O(n)\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"set-and-map-immutable-trees\"\u003eSet and Map: immutable trees\u003c/h2\u003e\n\u003cp\u003eLike lists, these are immutable and they may share some subtrees. They\nare a good solution for keeping older versions of sets of items.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026quot;adding\u0026quot; an element: O(log n)\n\u003c/li\u003e\n\u003cli\u003ereturning the number of elements: O(n)\n\u003c/li\u003e\n\u003cli\u003efinding an element: O(log n)\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSets and maps are very useful in compilation and meta-programming, but\nin other situations hash tables are often more appropriate (see below).\u003c/p\u003e\n\u003ch2 id=\"hashtbl-automatically-growing-hash-tables\"\u003eHashtbl: automatically growing hash tables\u003c/h2\u003e\n\u003cp\u003eOcaml hash tables are mutable data structures, which are a good solution\nfor storing (key, data) pairs in one single place.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eadding an element: O(1) if the initial size of the table is larger\nthan the number of elements it contains; O(log n) on average if n\nelements have been added in a table which is initially much smaller\nthan n.\n\u003c/li\u003e\n\u003cli\u003ereturning the number of elements: O(1)\n\u003c/li\u003e\n\u003cli\u003efinding an element: O(1)\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"buffer-extensible-strings\"\u003eBuffer: extensible strings\u003c/h2\u003e\n\u003cp\u003eBuffers provide an efficient way to accumulate a sequence of bytes in a\nsingle place. They are mutable.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eadding a char: O(1) if the buffer is big enough, or O(log n) on\naverage if the initial size of the buffer was much smaller than the\nnumber of bytes n.\n\u003c/li\u003e\n\u003cli\u003eadding a string of k chars: O(k * \u0026quot;adding a char\u0026quot;)\n\u003c/li\u003e\n\u003cli\u003elength: O(1)\n\u003c/li\u003e\n\u003cli\u003eaccessing cell \u003ccode\u003ei\u003c/code\u003e: O(1)\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"queue\"\u003eQueue\u003c/h2\u003e\n\u003cp\u003eOCaml queues are mutable first-in-first-out (FIFO) data structures.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eadding an element: O(1)\n\u003c/li\u003e\n\u003cli\u003etaking an element: O(1)\n\u003c/li\u003e\n\u003cli\u003elength: O(1)\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"stack\"\u003eStack\u003c/h2\u003e\n\u003cp\u003eOCaml stacks are mutable last-in-first-out (LIFO) data structures. They\nare just like lists, except that they are mutable, i.e. adding an\nelement doesn't create a new stack but simply adds it to the stack.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eadding an element: O(1)\n\u003c/li\u003e\n\u003cli\u003etaking an element: O(1)\n\u003c/li\u003e\n\u003cli\u003elength: O(1)\n\u003c/li\u003e\n\u003c/ul\u003e\n"}]},"params":{"lang":"en"}},"__N_SSG":true},"page":"/[lang]/resources/tutorials","query":{"lang":"en"},"buildId":"5vwEGiEdVvGQoOBpMUVkF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>