<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/59c64e8e0cd4b887f80a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/59c64e8e0cd4b887f80a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-43375c3d74aa814440ba.js" defer=""></script><script src="/_next/static/chunks/framework-56721e7fe9e004cd9e49.js" defer=""></script><script src="/_next/static/chunks/main-ff11dfa7b9d2932d51f3.js" defer=""></script><script src="/_next/static/chunks/pages/_app-07487d06e9f25472007b.js" defer=""></script><script src="/_next/static/chunks/940-69f823f49742ab32bc63.js" defer=""></script><script src="/_next/static/chunks/908-08eeb7bba98263e14afe.js" defer=""></script><script src="/_next/static/chunks/891-1bbf9c7984e84793c141.js" defer=""></script><script src="/_next/static/chunks/pages/%5Blang%5D/resources/%5Btutorial%5D-d60f5912d8379c3f4f23.js" defer=""></script><script src="/_next/static/5vwEGiEdVvGQoOBpMUVkF/_buildManifest.js" defer=""></script><script src="/_next/static/5vwEGiEdVvGQoOBpMUVkF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-white"><div class="pb-0  bg-yellowdark"><div class="max-w-7xl mx-auto"><div class="flex flex-col md:flex-row items-center text-center text-white"><div class="w-full md:w-3/12 font-bold text-2xl">OCaml.org v3</div><div class="w-full md:w-8/12"><div class="h-4 relative rounded-full overflow-hidden ring-8 ring-white m-8"><div class="w-full h-full bg-white absolute"></div><div class="h-full rounded-full bg-yellowdark absolute" style="width:30%"></div></div></div><div class="w-full md:w-1/12 font-bold text-2xl">30%</div></div><div class="flex flex-col items-center"><button class="inline-flex items-center pt-0 pb-1.5 border border-transparent text-xs font-medium rounded shadow-sm text-white bg-yellowdark focus:outline-none" type="button">See more v</button></div><div class="hidden"><div class="flex flex-col"><div class="-my-2 overflow-x-auto sm:-mx-6 lg:-mx-8"><div class="py-2 align-middle inline-block min-w-full sm:px-6 lg:px-8"><div class="shadow overflow-hidden border-b border-gray-200 sm:rounded-lg"><table class="table-auto min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" scope="col">version</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" scope="col">description</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" scope="col">period</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" scope="col">completion</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" scope="col">results</th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.1</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Select technologies</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Nov - Jan 2020</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">100%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Selected NextJS as static site generator, ReScript as implementation language, FlowMapp as sitemap tool, Figma for design, Tailwind for CSS.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.2</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Implement most important layouts</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Feb - Apr 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">100%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">The 10 most important pages have been designed and implemented.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900"></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Design information architecture</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Aug 2020 - Jun 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">60%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"> Sitemap is complete, 8 user personas and some journeys have been defined.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.3</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Implement all 40 distinct layouts</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Jun 30, 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">25%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">A quarter of the 40 distinct pages have been implemented.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900"></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Port 40 most important pages</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Aug 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">10%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Some work started.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.4</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Implement OCaml Manual</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Jul - Aug 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">0%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Not started.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.5</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Integrate docs.ocaml.org</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Jul 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">0%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Pending completion of the separate docs.ocaml.org project.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900"></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Implement multilingual site framework</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Aug 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">10%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Some work started.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900"></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Finalize site design</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Jan - Aug 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">50%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Half of the 40 pages needing a distinct design have been designed.</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">v3.6</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Go live on ocaml.org, replacing old site</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Aug 1, 2021</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">30%</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">One-third of the work has been done.</td></tr></tbody></table></div></div></div></div></div></div></div><div class="relative shadow"><div class="relative font-roboto"><div class="max-w-7xl mx-auto px-4 sm:px-6 "><div class="flex justify-between items-center md:justify-start py-6 md:space-x-10 "><div class="flex justify-start "><a class="" href="/"><img class="h-8 w-auto sm:h-10" alt="" src="/static/logo1.jpeg"/></a></div><nav class="hidden md:flex space-x-10 "><div class="relative"><button aria-expanded="false" class="text-gray-500  pl-2 group bg-white rounded-md inline-flex items-center text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orangedark" type="button"><span>Principles</span><svg aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" fill-rule="evenodd"></path></svg></button><div class="absolute z-10 left-1/2 transform -translate-x-1/4 mt-3 px-2 w-screen max-w-sm sm:px-0  hidden "><div class="rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 overflow-hidden"><div class="relative grid gap-6 bg-white px-5 py-6 sm:gap-6 sm:p-8"><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/principles/whatisocaml/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 12.7 15.9" xmlns="http://www.w3.org/2000/svg"><path d="m9.01 1.23a0.676 0.676 0 0 0-0.658 0.52 7.02 7.02 0 0 0-0.185 1.41 0.338 0.338 0 0 1-0.674 0.0292 6.26 6.26 0 0 0-0.304-1.33 0.81 0.81 0 0 0-1.56 0.118 3.15 3.15 0 0 1-1.26 1.98 0.495 0.495 0 0 1-0.564 9e-3 1.49 1.49 0 0 1-0.459-0.492 0.495 0.495 0 0 1 0.023-0.531 1.22 1.22 0 0 0 0.141-0.266 0.295 0.295 0 0 0-0.374-0.383 0.987 0.987 0 0 0-0.183 0.0867 0.819 0.819 0 0 0-1.21-0.24 1.36 1.36 0 0 1-0.767 0.395 0.516 0.516 0 0 0 0.0788 1.03h0.42a0.789 0.789 0 0 0 0.507 0.259 2.67 2.67 0 0 0 2.32 2.59 0.471 0.471 0 0 0 0.328-0.0783 1.81 1.81 0 0 0 0.438 1.11 3.97 3.97 0 0 1 1.15 2.78 0.202 0.202 0 0 1-0.11 0.18 2.56 2.56 0 0 0-0.682 0.506 0.325 0.325 0 0 0 0.234 0.55h1.43a0.468 0.468 0 0 0 0.0934-0.784 0.202 0.202 0 0 1-0.0744-0.156v-1.43a1.5 1.5 0 0 0-0.15-1.08v-0.591a2.43 2.43 0 0 0 1.68 0.0748 3.43 3.43 0 0 0 1.4-0.668 1.78 1.78 0 0 0 0.228 0.465 2.84 2.84 0 0 1 0.408 2.9 0.202 0.202 0 0 1-0.115 0.11 2.56 2.56 0 0 0-0.934 0.617 0.325 0.325 0 0 0 0.234 0.55h1.43a0.468 0.468 0 0 0 0.122-0.759 0.202 0.202 0 0 1-0.0558-0.197 4.7 4.7 0 0 1 0.706-1.51 0.383 0.383 0 0 0 0.0598-0.309 6.18 6.18 0 0 1 0.035-2.97 1.06 1.06 0 0 0-0.45-1.16l-0.486-0.315a1.08 1.08 0 0 1-0.453-0.618 5.11 5.11 0 0 0-1.26-2.19 0.676 0.676 0 0 0-0.485-0.205zm-0.00227 0.181a0.495 0.495 0 0 1 0.355 0.15 4.93 4.93 0 0 1 1.21 2.11 1.26 1.26 0 0 0 0.529 0.721l0.486 0.315a0.882 0.882 0 0 1 0.374 0.962 6.36 6.36 0 0 0-0.0358 3.06 0.202 0.202 0 0 1-0.0319 0.163 4.88 4.88 0 0 0-0.733 1.57 0.383 0.383 0 0 0 0.105 0.374 0.287 0.287 0 0 1-0.0429 0.447h-1.38a0.143 0.143 0 0 1-0.103-0.243 2.38 2.38 0 0 1 0.868-0.574 0.383 0.383 0 0 0 0.216-0.208 3.02 3.02 0 0 0-0.429-3.08 1.6 1.6 0 0 1-0.218-1.33 0.0906 0.0906 0 0 0-0.174-0.0491 1.78 1.78 0 0 0-0.0319 0.83 3.25 3.25 0 0 1-1.39 0.686 2.25 2.25 0 0 1-1.63-0.0978v-0.624a0.0906 0.0906 0 0 0-0.181 0v1.46a1.32 1.32 0 0 1 0.15 1.01v1.46a0.383 0.383 0 0 0 0.14 0.297 0.287 0.287 0 0 1-0.0248 0.462h-1.38a0.143 0.143 0 0 1-0.103-0.243 2.38 2.38 0 0 1 0.634-0.47 0.383 0.383 0 0 0 0.209-0.343 4.15 4.15 0 0 0-1.19-2.9 1.62 1.62 0 0 1-0.308-1.57 0.0907 0.0907 0 1 0-0.172-0.058 1.81 1.81 0 0 0-0.073 0.298 0.29 0.29 0 0 1-0.324 0.243 2.48 2.48 0 0 1-2.16-2.42 0.789 0.789 0 0 0 0.404-0.176 0.0907 0.0907 0 0 0-0.116-0.139 0.608 0.608 0 0 1-0.888-0.123h-0.508a0.335 0.335 0 0 1-0.0505-0.667 1.54 1.54 0 0 0 0.86-0.438 0.638 0.638 0 0 1 0.942 0.212 0.987 0.987 0 0 0-0.0894 0.0907 0.0909 0.0909 0 1 0 0.138 0.119 0.805 0.805 0 0 1 0.342-0.234 0.114 0.114 0 0 1 0.144 0.148 1.04 1.04 0 0 1-0.119 0.227 0.676 0.676 0 0 0-0.031 0.725 1.68 1.68 0 0 0 0.515 0.551 0.676 0.676 0 0 0 0.772-0.0116 3.33 3.33 0 0 0 1.33-2.1 0.629 0.629 0 0 1 1.21-0.0912 6.08 6.08 0 0 1 0.295 1.29 0.52 0.52 0 0 0 1.04-0.0451 6.84 6.84 0 0 1 0.18-1.37 0.495 0.495 0 0 1 0.482-0.381z" stroke-width=".289"></path><path d="m2.16 2.76a0.128 0.128 0 1 0-0.256 0 0.128 0.128 0 1 0 0.256 0z" stroke-width=".2"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Why OCaml</p></dt><dd class="ml-10 text-sm text-gray-500">Find out about OCaml&#x27;s history and how it became what it is today.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/principles/users/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg class="stroke-0" version="1.1" viewBox="0 0 60 75" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M6,55h48c0.6,0,1-0.4,1-1V33c0-0.3-0.1-0.5-0.3-0.7l-9-8.4L44,5.9c0-0.1,0-0.1,0-0.2c0-0.1,0-0.1,0-0.2  c0-0.1-0.1-0.1-0.1-0.2c0,0-0.1-0.1-0.1-0.1c-0.1-0.1-0.1-0.1-0.2-0.1c0,0-0.1-0.1-0.1-0.1C43.3,5,43.1,5,43,5h-6  c-0.1,0-0.3,0-0.4,0.1c0,0-0.1,0-0.1,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0-0.1,0.1-0.1,0.1c0,0.1-0.1,0.1-0.1,0.2c0,0.1,0,0.1,0,0.2  c0,0.1,0,0.1,0,0.2l-1.3,20.8l-8-7.4c-0.3-0.3-0.7-0.3-1.1-0.2C25.2,19.2,25,19.6,25,20v10.7L12.7,19.3c-0.3-0.3-0.7-0.3-1.1-0.2  C11.2,19.2,11,19.6,11,20v12H6c-0.6,0-1,0.4-1,1v21C5,54.6,5.4,55,6,55z M42,7v1h-4V7H42z M37.8,10h4.6l1.1,11.9l-2.8-2.6  c-0.3-0.3-0.7-0.3-1.1-0.2C39.2,19.2,39,19.6,39,20v10.7l-2.4-2.2L37.8,10z M7,34h5c0.6,0,1-0.4,1-1V22.3l12.3,11.4  c0.3,0.3,0.7,0.3,1.1,0.2c0.4-0.2,0.6-0.5,0.6-0.9V22.3l12.3,11.4c0.3,0.3,0.7,0.3,1.1,0.2c0.4-0.2,0.6-0.5,0.6-0.9V22.3l3.1,2.9  c0,0,0,0,0,0l8.9,8.3V53H7V34z"></path><path d="M16,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C17,38.4,16.6,38,16,38z M15,42h-2v-2h2V42z"></path><path d="M24,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C25,38.4,24.6,38,24,38z M23,42h-2v-2h2V42z"></path><path d="M32,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C33,38.4,32.6,38,32,38z M31,42h-2v-2h2V42z"></path><path d="M40,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C41,38.4,40.6,38,40,38z M39,42h-2v-2h2V42z"></path><path d="M48,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C49,38.4,48.6,38,48,38z M47,42h-2v-2h2V42z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Industrial Users</p></dt><dd class="ml-10 text-sm text-gray-500">Discover the organisations that use OCaml to accomplish their goals.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/principles/academic/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg class="stroke-2" version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g transform="translate(0,-952.36218)"><path d="M 47.25 23 A 1.0001 1.0001 0 0 0 47.125 23.0625 L 5.625 39.0625 A 1.0001 1.0001 0 0 0 5.625 40.90625 L 21.1875 46.90625 A 1.0001 1.0001 0 0 0 21.1875 47 L 21.1875 63.4375 A 1.0001 1.0001 0 0 0 21.8125 64.34375 L 47.09375 74.90625 A 1.0001 1.0001 0 0 0 47.84375 74.90625 L 73.15625 64.34375 A 1.0001 1.0001 0 0 0 73.75 63.4375 L 73.75 47 A 1.0001 1.0001 0 0 0 73.75 46.9375 L 80.875 44.1875 A 1.0040202 1.0040202 0 0 0 80.15625 42.3125 L 47.46875 54.9375 L 8.75 40 L 47.5 25.03125 L 87.9375 40.65625 L 87.9375 65.09375 C 85.072141 65.568778 82.875 68.037767 82.875 71 C 82.875 74.2988 85.600803 77 88.9375 77 C 92.274197 77 95 74.2988 95 71 C 95 68.037767 92.802859 65.568778 89.9375 65.09375 L 89.9375 40 A 1.0001 1.0001 0 0 0 89.3125 39.0625 L 47.84375 23.0625 A 1.0001 1.0001 0 0 0 47.25 23 z M 23.1875 47.6875 L 47.125 56.90625 A 1.0001 1.0001 0 0 0 47.84375 56.90625 L 71.75 47.6875 L 71.75 62.75 L 47.46875 72.90625 L 23.1875 62.75 L 23.1875 47.6875 z M 88.9375 66.96875 C 91.187128 66.96875 92.96875 68.7759 92.96875 71 C 92.96875 73.2241 91.187128 75 88.9375 75 C 86.687872 75 84.875 73.2241 84.875 71 C 84.875 68.7759 86.687872 66.96875 88.9375 66.96875 z " transform="translate(0,952.36218)"></path></g></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Academic Excellence</p></dt><dd class="ml-10 text-sm text-gray-500">Learn about the academics that research programming language technology.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/principles/successes/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 160 200" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M151.305,149.32l-35.11-68.89c-0.6-1.17-1.8-1.91-3.12-1.91s-2.52,0.74-3.12,1.91l-11.98,23.5l3.93,7.71l11.17-21.92  l29.4,57.69h-22.34h-2.801L66.999,48.66v-8.949h42.25c1.933,0,3.5-1.567,3.5-3.5V9.09c0-1.933-1.567-3.5-3.5-3.5h-45.75  c-1.933,0-3.5,1.567-3.5,3.5v13.824v13.297V48.66L8.69,149.321c-0.553,1.085-0.502,2.38,0.134,3.418  c0.636,1.039,1.767,1.672,2.984,1.672h103.381c0.001,0,0.002,0,0.003,0h4.863h28.14c1.21,0,2.34-0.63,2.98-1.67  C151.815,151.7,151.865,150.41,151.305,149.32z M66.999,22.914V12.59h38.75v20.122h-38.75V22.914z M63.499,57.207l10.873,21.332  c-5.251-0.709-10.46,2.09-12.683,7.08c-0.751,1.687-2.234,2.781-4.067,3.003c-1.829,0.221-3.533-0.488-4.665-1.947l-2.703-3.484  L63.499,57.207z M17.52,147.41l29.221-57.328l0.685,0.883c2.329,3.002,5.817,4.696,9.543,4.695c0.494,0,0.993-0.029,1.493-0.09  c4.273-0.517,7.87-3.172,9.622-7.104c1.063-2.386,3.744-3.588,6.231-2.8l4.402,1.396l30.76,60.347H17.52z"></path><path d="M90.023,15.97l-5.161,5.71l-2.427-1.948c-1.075-0.864-2.649-0.692-3.514,0.384c-0.865,1.077-0.692,2.65,0.384,3.514  l4.265,3.424c0.461,0.37,1.014,0.551,1.564,0.551c0.684,0,1.364-0.279,1.855-0.824l6.742-7.46c0.926-1.024,0.846-2.605-0.178-3.531  C92.529,14.866,90.948,14.947,90.023,15.97z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Success Stories</p></dt><dd class="ml-10 text-sm text-gray-500">Read about the things that have been achieved using OCaml.</dd></a></div></div></div></div><div class="relative"><button aria-expanded="false" class="text-gray-500 pl-2 group bg-white rounded-md inline-flex items-center text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orangedark" type="button"><span>Resources</span><svg aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" fill-rule="evenodd"></path></svg></button><div class="absolute z-10 left-1/2 transform -translate-x-1/3 mt-3 px-2 w-screen max-w-sm sm:px-0  hidden "><div class="rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 overflow-hidden"><div class="relative grid gap-6 bg-white px-5 py-6 sm:gap-6 sm:p-8"><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/resources/language/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M10.7,22.2c0.4,0.2,0.9,0.2,1.4,0c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1  c0.7,0,1.3-0.4,1.6-1.1c0.4-0.9,0-1.9-0.9-2.3c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3C10,21.7,10.3,22,10.7,22.2z"></path><path d="M57.2,20.2c-0.4,0.2-0.8,0.5-0.9,1s-0.2,0.9,0,1.4c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.6-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1c0.4-0.9-0.1-1.9-1-2.3C74.1,13,57.9,19.9,57.2,20.2z"></path><path d="M42.6,31.4c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0  C25.7,28,41,34.6,41.2,34.6c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.9,32.8,43.5,31.8,42.6,31.4z"></path><path d="M89,30.1c-14.6-5.9-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.9,0.4,1.9-0.1,2.3-1C90.4,31.5,89.9,30.5,89,30.1z"></path><path d="M42.6,42.9c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.4,0.9,1.4,1.3,2.3,1  c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.9,44.3,43.5,43.3,42.6,42.9z"></path><path d="M89,41.6c-14.6-5.9-30.8,1-31.5,1.3c-0.4,0.2-0.8,0.5-0.9,1c-0.2,0.4-0.2,0.9,0,1.4  c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1c0.2-0.1,15.5-6.6,28.7-1.2c0.9,0.4,1.9-0.1,2.3-1C90.4,43,89.9,42,89,41.6z"></path><path d="M42.5,54.4c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0  c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.8,55.8,43.4,54.8,42.5,54.4z"></path><path d="M88.9,53.1c-14.6-6-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1C90.2,54.5,89.8,53.5,88.9,53.1z"></path><path d="M41.8,69.1c0.7,0,1.3-0.4,1.6-1.1c0.4-0.9,0-1.9-0.9-2.3c-0.7-0.3-16.9-7.2-31.5-1.3  c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0c13.2-5.4,28.6,1.2,28.7,1.2C41.3,69,41.5,69.1,41.8,69.1z"></path><path d="M88.9,64.4c-14.6-6-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1C90.2,65.8,89.8,64.7,88.9,64.4z"></path><path d="M97.9,12.1c0-0.8-0.5-1.6-1.3-1.9C72-0.3,54.9,10.1,50,13.8C45,10.1,27.9-0.3,3.3,10.2  c-0.8,0.3-1.3,1.1-1.3,1.9v78.6c0,0.7,0.4,1.4,1,1.8c0.3,0.2,0.7,0.3,1.1,0.3c0.3,0,0.6-0.1,0.9-0.2c0.2-0.1,17.1-7.8,43.5-0.2l0,0  l3,0l0.1,0c17.3-7,39.3-0.9,43.6,0.4c0.6,0.2,1.3,0.1,1.8-0.3c0.5-0.4,0.8-1,0.8-1.7L97.9,12.1z M93.8,87.8V88  c-7.7-2.1-15.2-3.1-22.4-3.1c-1.2,0-2.4,0-3.6,0.1C76.2,83.3,84.9,84.3,93.8,87.8z M93.8,83.4c-20.6-7.6-35.7-0.5-41.7,3.3l0-69.3  c3.2-2.5,19-13,41.7-3.9L93.8,83.4z M34.5,85.4C22.3,84,13.2,85.6,7.9,87.2c6.1-2.2,11.7-3.1,16.5-3.1  C28.3,84.1,31.7,84.6,34.5,85.4z M6.2,13.4c23.1-9.2,38.6,1.5,41.7,4l0,69.3C43.9,84.1,35.7,80,24.3,80c-5.4,0-11.4,0.9-18.1,3.4  L6.2,13.4z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Language</p></dt><dd class="ml-10 text-sm text-gray-500">Read through the OCaml tutorial, official manual and books.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/packages/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M85.8,35.6l11.2-13c0.5-0.5,0.6-1.3,0.4-2c-0.2-0.7-0.7-1.2-1.4-1.5L63.1,8.3c-0.8-0.3-1.7,0-2.3,0.6L50,21.5L39.2,9    c-0.6-0.7-1.5-0.9-2.3-0.6L4,19.1c-0.7,0.2-1.2,0.8-1.4,1.5c-0.2,0.7,0,1.4,0.4,2l11.2,13L3,48.6c-0.5,0.5-0.6,1.3-0.4,2    c0.2,0.7,0.7,1.2,1.4,1.5l10.9,3.6v23.2c0,0.9,0.6,1.8,1.5,2.1l32.9,10.8c0.2,0.1,0.5,0.1,0.7,0.1c0.2,0,0.5,0,0.7-0.1l32.9-10.8    c0.9-0.3,1.5-1.1,1.5-2.1V55.7l11-3.6c0.7-0.2,1.2-0.8,1.4-1.5c0.2-0.7,0-1.4-0.4-2L85.8,35.6z M24,35.6l26-8.5l26,8.5l-26,8.5    L24,35.6z M63.1,12.9l28.5,9.3l-9.4,10.9l-28.5-9.3L63.1,12.9z M36.9,12.9l9.4,10.9l-28.5,9.3L8.4,22.2L36.9,12.9z M17.8,38.1    l28.5,9.3l-9.4,10.9L8.4,49L17.8,38.1z M19.2,77.2V57.1l17.6,5.8c0.2,0.1,0.4,0.1,0.7,0.1c0.6,0,1.2-0.3,1.6-0.7l8.6-10v34.4    L19.2,77.2z M80.7,77.2l-28.6,9.4V52.2l8.6,10c0.4,0.5,1,0.7,1.6,0.7c0.2,0,0.5,0,0.7-0.1l17.6-5.8V77.2z M63.1,58.3l-9.4-10.9    l28.5-9.3L91.6,49L63.1,58.3z"></path></g></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Packages</p></dt><dd class="ml-10 text-sm text-gray-500">Browse the third-party packages published in the OCaml ecosystem.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/resources/applications/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M85.32,15.63H78.65a1.5,1.5,0,0,0-1.5,1.5v3.53H73.36a5.5,5.5,0,0,0-10.57,0h-7.9a5.5,5.5,0,0,0-10.57,0H36.11a5.5,5.5,0,0,0-10.57,0H22.85V17.13a1.5,1.5,0,0,0-1.5-1.5H14.68a1.5,1.5,0,0,0-1.5,1.5V82.87a1.5,1.5,0,0,0,1.5,1.5h6.67a1.5,1.5,0,0,0,1.5-1.5V74.63h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,9.29-2.27H54.79a5.49,5.49,0,0,0,9.29,2.27,5.49,5.49,0,0,0,9.28-2.27h3.79v8.24a1.5,1.5,0,0,0,1.5,1.5h6.67a1.5,1.5,0,0,0,1.5-1.5V17.13A1.5,1.5,0,0,0,85.32,15.63Zm-25.22,39a5.5,5.5,0,0,0-9.29-2.26,5.48,5.48,0,0,0-8,0,5.49,5.49,0,0,0-8,0,5.49,5.49,0,0,0-9.28,2.26H22.85v-14h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,8,0,5.49,5.49,0,0,0,9.28-2.27H62.79a5.49,5.49,0,0,0,10.57,0h3.79v14Zm-2.79,1.5a2.5,2.5,0,1,1-2.5-2.49A2.5,2.5,0,0,1,57.31,56.14Zm-8,0a2.5,2.5,0,1,1-2.49-2.49A2.5,2.5,0,0,1,49.31,56.14Zm-8,0a2.5,2.5,0,1,1-2.5-2.49A2.5,2.5,0,0,1,41.32,56.14Zm-8,0a2.5,2.5,0,1,1-2.49-2.49A2.5,2.5,0,0,1,33.32,56.14Zm-5-17a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,28.33,39.15Zm8,0a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,36.32,39.15Zm8,0a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,44.32,39.15Zm21.26,0a2.5,2.5,0,1,1,2.49,2.5A2.5,2.5,0,0,1,65.58,39.15Zm2.49-19.48a2.5,2.5,0,1,1-2.49,2.49A2.5,2.5,0,0,1,68.07,19.67Zm-18.47,0a2.5,2.5,0,1,1-2.5,2.49A2.5,2.5,0,0,1,49.6,19.67Zm-18.77,0a2.5,2.5,0,1,1-2.5,2.49A2.5,2.5,0,0,1,30.83,19.67Zm-5.29,4a5.49,5.49,0,0,0,10.57,0h8.21a5.49,5.49,0,0,0,10.57,0h7.9a5.49,5.49,0,0,0,10.57,0h3.79v14H73.36a5.5,5.5,0,0,0-10.57,0H52.1a5.49,5.49,0,0,0-9.28-2.26,5.49,5.49,0,0,0-8,0,5.49,5.49,0,0,0-9.28,2.26H22.85v-14ZM19.85,81.37H16.18V18.63h3.67Zm11-5.74a2.5,2.5,0,1,1,2.49-2.5A2.5,2.5,0,0,1,30.83,75.63Zm8,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,38.82,75.63Zm21.26,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,60.08,75.63Zm8,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,68.07,75.63Zm5.29-4a5.49,5.49,0,0,0-9.28-2.26,5.5,5.5,0,0,0-9.29,2.26H44.11a5.5,5.5,0,0,0-9.29-2.26,5.49,5.49,0,0,0-9.28,2.26H22.85v-14h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,8,0,5.48,5.48,0,0,0,8,0,5.49,5.49,0,0,0,9.29-2.27H77.15v14Zm10.46,9.74H80.15V18.63h3.67Z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Applications</p></dt><dd class="ml-10 text-sm text-gray-500">Learn techniques for building tools and applications in OCaml.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/resources/bestpractices/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M7,51h28.7c3.3,0,6.6-1.4,8.8-3.9L61.2,29H76c6.6,0,9-3.8,9-7c0-1.1-0.2-2.1-0.7-3H88c3.9,0,7-3.1,7-7s-3.1-7-7-7H45  c-0.1,0-0.1,0-0.2,0c0,0-0.1,0-0.2,0s-0.1,0-0.2,0c-0.1,0-0.1,0-0.2,0.1c0,0-0.1,0-0.2,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0,0,0,0,0  L22.3,21H7c-1.1,0-2,0.9-2,2v26C5,50.1,5.9,51,7,51z M76,25H64.5c0.5-1.1,0.8-2.4,0.7-3.7c-0.1-0.8-0.3-1.6-0.6-2.3H78  c1.7,0,3,1.3,3,3C81,24.7,77.5,25,76,25z M19,25h4c0.2,0,0.4,0,0.5-0.1c0,0,0.1,0,0.1,0c0.2-0.1,0.3-0.1,0.5-0.2c0,0,0,0,0,0L45.7,9  H88c1.7,0,3,1.3,3,3c0,1.6-1.3,3-3,3H58c-0.1,0-0.3,0-0.4,0c-1.8,0.2-3.5,1-4.7,2.3L34.9,36.9c-0.7,0.8-0.7,2.1,0.1,2.8  s2.1,0.7,2.8-0.1l18-19.5c1.1-1.2,2.9-1.4,4.2-0.5c0.7,0.5,1.1,1.3,1.2,2.1c0.1,0.8-0.2,1.7-0.8,2.3L41.6,44.4  c-1.5,1.6-3.7,2.6-5.9,2.6H19V25z M9,25h6v22H9V25z M93,49H64.3c-3.3,0-6.6,1.4-8.8,3.9L38.8,71H24c-6.6,0-9,3.8-9,7  c0,1.1,0.2,2.1,0.7,3H12c-3.9,0-7,3.1-7,7s3.1,7,7,7h43c0,0,0,0,0,0c0.2,0,0.4,0,0.5-0.1c0,0,0.1,0,0.1,0c0.2-0.1,0.3-0.1,0.5-0.2  c0,0,0,0,0,0L77.7,79H93c1.1,0,2-0.9,2-2V51C95,49.9,94.1,49,93,49z M24,75h11.5c-0.5,1.1-0.8,2.4-0.7,3.7c0.1,0.8,0.3,1.6,0.6,2.3  H22c-1.7,0-3-1.4-3-3C19,75.3,22.5,75,24,75z M81,75h-4c-0.1,0-0.2,0-0.3,0c0,0-0.1,0-0.1,0c-0.1,0-0.2,0-0.2,0.1c0,0-0.1,0-0.2,0.1  s-0.1,0-0.2,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0,0,0,0,0L54.3,91H12c-1.7,0-3-1.4-3-3c0-1.7,1.3-3,3-3h30c0.1,0,0.3,0,0.4,0  c1.8-0.2,3.5-0.9,4.7-2.3l17.9-19.5c0.7-0.8,0.7-2.1-0.1-2.8c-0.8-0.7-2.1-0.7-2.8,0.1l-18,19.5c-1.1,1.2-2.9,1.5-4.2,0.5  c-0.7-0.5-1.1-1.3-1.2-2.1c-0.1-0.9,0.2-1.7,0.8-2.3l18.8-20.4c1.5-1.6,3.7-2.6,5.9-2.6H81V75z M91,75h-6V53h6V75z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Best Practices</p></dt><dd class="ml-10 text-sm text-gray-500">Adopt the best known methods for development from the OCaml community.</dd></a></div></div></div></div><div class="relative"><button aria-expanded="false" class="text-gray-500  pl-2 group bg-white rounded-md inline-flex items-center text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orangedark" type="button"><span>Community</span><svg aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" fill-rule="evenodd"></path></svg></button><div class="absolute z-10 left-1/2 transform -translate-x-1/2 mt-3 px-2 w-screen max-w-sm sm:px-0  hidden "><div class="rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 overflow-hidden"><div class="relative grid gap-6 bg-white px-5 py-6 sm:gap-6 sm:p-8"><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/community/opportunities/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 1024 1280" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M512,300.4c-31,0-60-14.7-81.7-41.3c-20.6-25.2-32-58-32-92.1c0-34.5,11.8-63.3,34.1-83.4c20.1-18.2,48.4-28.2,79.6-28.2   c31.2,0,59.5,10,79.6,28.2c22.3,20.1,34.1,49,34.1,83.4c0,34.2-11.4,66.9-32,92.1C572,285.7,543,300.4,512,300.4z M512,95.4   c-17.3,0-73.7,5.2-73.7,71.6c0,24.6,8.4,49,23,66.8c14,17.1,32,26.6,50.7,26.6c18.7,0,36.7-9.4,50.7-26.6   c14.6-17.9,23-42.2,23-66.8C585.7,100.6,529.3,95.4,512,95.4z"></path><rect height="44.4" width="40" x="383.9" y="470.9"></rect><path d="M338.4,515.4h-40v-83.6c0-35,20.6-66.7,52.6-80.9l100-44.4c10.4-4.6,22.4-1.5,29.2,7.5l31.9,41.7l32.4-41.7   c6.8-9,18.8-12,29.2-7.4l99.4,44.3c31.9,14.2,52.5,45.9,52.5,80.9v83.6h-40v-83.6c0-19.2-11.3-36.6-28.7-44.3l-88.2-39.3   l-56.8,73.1l-55.9-73.1l-88.7,39.4c-17.5,7.8-28.8,25.2-28.8,44.3V515.4z"></path><rect height="44.4" width="40" x="600.1" y="470.9"></rect><rect height="126.9" width="40" x="492" y="388.4"></rect><path d="M819.5,784.5c-3.3,0-6.7-0.6-9.9-2c-9.6-4-15.9-13.3-15.9-23.7v-51.2h-75.1c-13,0-23.6-10.6-23.6-23.6V583.8   c0-13,10.6-23.6,23.6-23.6h75.1V509c0-10.5,6.2-19.8,15.9-23.8c9.7-4,20.7-1.8,28.1,5.6l124.9,124.9c10,10,10,26.4,0,36.4   L837.6,776.9C832.7,781.9,826.1,784.5,819.5,784.5z M735,667.6h98.7v56.7l90.5-90.5l-90.5-90.5v56.8H735V667.6z"></path><path d="M512,968.6c-6.6,0-13.2-2.5-18.2-7.5l-125-124.9c-7.3-7.3-9.5-18.2-5.7-27.7c3.9-9.6,13.1-16,23.5-16.2l0.4,0h51.2v-75.1   c0-13,10.6-23.6,23.6-23.6h100.3c13,0,23.6,10.6,23.6,23.6v75.1H637c10.4,0,19.7,6.2,23.7,15.9c4,9.7,1.8,20.7-5.6,28.1L530.2,961   C525.2,966.1,518.6,968.6,512,968.6z M421.5,832.2l90.5,90.5l90.5-90.5h-56.7v-98.7h-67.5v98.7H421.5z"></path><path d="M204.5,784.5c-6.7,0-13.3-2.6-18.2-7.6L61.5,652c-10-10-10-26.4,0-36.4l124.9-124.9c7.4-7.4,18.4-9.6,28.1-5.6   c9.7,4,15.9,13.3,15.9,23.8v51.2h75.1c13,0,23.6,10.6,23.6,23.6V684c0,13-10.6,23.6-23.6,23.6h-75.1v51.2   c0,10.4-6.2,19.7-15.9,23.7C211.2,783.9,207.9,784.5,204.5,784.5z M99.8,633.8l90.5,90.5v-56.7H289v-67.4h-98.7v-56.8L99.8,633.8z"></path></g></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Opportunities</p></dt><dd class="ml-10 text-sm text-gray-500">Explore vacancies in projects and companies and see where you could fit in.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/community/blog/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g transform="translate(0,-952.36218)"><path d="M 17.78125 15 A 2.0002 2.0002 0 0 0 15.96875 17 L 15.96875 25.3125 L 8 25.3125 A 2.0002 2.0002 0 0 0 6 27.3125 L 6 83 A 2.0002 2.0002 0 0 0 8 85 L 92 85 A 2.0002 2.0002 0 1 0 92 81 L 10 81 L 10 29.3125 L 15.96875 29.3125 L 15.96875 74.75 A 2.0002 2.0002 0 1 0 19.96875 74.75 L 19.96875 19 L 89.84375 19 L 89.84375 73.96875 A 2.0002 2.0002 0 1 0 93.84375 73.96875 L 93.84375 17 A 2.0002 2.0002 0 0 0 91.84375 15 L 17.96875 15 A 2.0002 2.0002 0 0 0 17.78125 15 z M 28.75 26.34375 A 2.0002 2.0002 0 0 0 26.96875 28.34375 L 26.96875 51.03125 A 2.0002 2.0002 0 0 0 28.96875 53.03125 L 52.90625 53.03125 A 2.0002 2.0002 0 0 0 54.90625 51.03125 L 54.90625 28.34375 A 2.0002 2.0002 0 0 0 52.90625 26.34375 L 28.96875 26.34375 A 2.0002 2.0002 0 0 0 28.75 26.34375 z M 63.6875 26.34375 A 2.0029885 2.0029885 0 1 0 63.90625 30.34375 L 81.84375 30.34375 A 2.0002 2.0002 0 1 0 81.84375 26.34375 L 63.90625 26.34375 A 2.0002 2.0002 0 0 0 63.6875 26.34375 z M 30.96875 30.34375 L 50.90625 30.34375 L 50.90625 49.03125 L 30.96875 49.03125 L 30.96875 30.34375 z M 63.6875 37.6875 A 2.0029885 2.0029885 0 1 0 63.90625 41.6875 L 81.84375 41.6875 A 2.0002 2.0002 0 1 0 81.84375 37.6875 L 63.90625 37.6875 A 2.0002 2.0002 0 0 0 63.6875 37.6875 z M 63.6875 49.03125 A 2.0029885 2.0029885 0 1 0 63.90625 53.03125 L 81.84375 53.03125 A 2.0002 2.0002 0 1 0 81.84375 49.03125 L 63.90625 49.03125 A 2.0002 2.0002 0 0 0 63.6875 49.03125 z M 27.75 60.375 A 2.0029885 2.0029885 0 1 0 27.96875 64.375 L 81.84375 64.375 A 2.0002 2.0002 0 1 0 81.84375 60.375 L 27.96875 60.375 A 2.0002 2.0002 0 0 0 27.75 60.375 z M 27.75 71.71875 A 2.0029885 2.0029885 0 1 0 27.96875 75.71875 L 81.6875 75.71875 A 2.0002 2.0002 0 1 0 81.6875 71.71875 L 27.96875 71.71875 A 2.0002 2.0002 0 0 0 27.75 71.71875 z " transform="translate(0,952.36218)"></path></g></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">News</p></dt><dd class="ml-10 text-sm text-gray-500">Catch up on the latest news from the OCaml sphere!</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/community/aroundweb/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg viewBox="0 0 64 80" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M32,9A23,23,0,1,0,55,32,23.0259,23.0259,0,0,0,32,9Zm0,44A21,21,0,1,1,53,32,21.0239,21.0239,0,0,1,32,53ZM63,32A30.99,30.99,0,0,1,10.3,54.124,29.6168,29.6168,0,0,1,8,51.6027V55a1,1,0,0,1-2,0V49a1,1,0,0,1,1-1h6a1,1,0,0,1,0,2H9.2789a27.8374,27.8374,0,0,0,2.4174,2.6929A28.99,28.99,0,0,0,61,32a28.617,28.617,0,0,0-2.86-12.5645,1,1,0,1,1,1.8008-.871A30.6112,30.6112,0,0,1,63,32ZM5.86,44.5645a1,1,0,0,1-1.8008.871A30.6112,30.6112,0,0,1,1,32,30.99,30.99,0,0,1,53.7,9.876,29.6168,29.6168,0,0,1,56,12.3973V9a1,1,0,0,1,2,0v6a1,1,0,0,1-1,1H51a1,1,0,0,1,0-2h3.7211a27.8374,27.8374,0,0,0-2.4174-2.6929A28.99,28.99,0,0,0,3,32,28.617,28.617,0,0,0,5.86,44.5645ZM43.1411,20.1112a23.1406,23.1406,0,0,0,2.1978-1.3661,1,1,0,0,0-1.1582-1.63c-.5694.4049-1.16.7679-1.76,1.1113A22.1893,22.1893,0,0,0,40.02,13.8438,1,1,0,1,0,38.4,15.0166,20.1638,20.1638,0,0,1,40.6245,19.14,20.8665,20.8665,0,0,1,33,20.9617V13a1,1,0,0,0-2,0v7.9617A20.866,20.866,0,0,1,23.3755,19.14,20.1638,20.1638,0,0,1,25.6,15.0166a1,1,0,1,0-1.6191-1.1728,22.1893,22.1893,0,0,0-2.4013,4.3827c-.6-.3434-1.19-.7064-1.76-1.1113a1,1,0,0,0-1.1582,1.63,23.1406,23.1406,0,0,0,2.1978,1.3661A36.8955,36.8955,0,0,0,19.0317,31H13a1,1,0,0,0,0,2h6.0317a36.8955,36.8955,0,0,0,1.8272,10.8888,23.1406,23.1406,0,0,0-2.1978,1.3661,1,1,0,0,0,1.1582,1.63c.5694-.4049,1.16-.7679,1.76-1.1113a22.193,22.193,0,0,0,2.4013,4.3828A1,1,0,1,0,25.6,48.9834a20.1636,20.1636,0,0,1-2.224-4.1233A20.866,20.866,0,0,1,31,43.0383V51a1,1,0,0,0,2,0V43.0383A20.8665,20.8665,0,0,1,40.6245,44.86,20.1638,20.1638,0,0,1,38.4,48.9834,1,1,0,1,0,40.02,50.1563a22.193,22.193,0,0,0,2.4013-4.3828c.6.3434,1.1905.7064,1.76,1.1113a1,1,0,0,0,1.1582-1.63,23.1406,23.1406,0,0,0-2.1978-1.3661A36.8955,36.8955,0,0,0,44.9683,33H51a1,1,0,0,0,0-2H44.9683A36.8955,36.8955,0,0,0,43.1411,20.1112Zm-1.8222.9086A35.3906,35.3906,0,0,1,42.9679,31H33V22.9617A22.855,22.855,0,0,0,41.3189,21.02Zm-18.6378,0A22.855,22.855,0,0,0,31,22.9617V31H21.0321A35.3906,35.3906,0,0,1,22.6811,21.02Zm0,21.96A35.3906,35.3906,0,0,1,21.0321,33H31v8.0383A22.855,22.855,0,0,0,22.6811,42.98Zm18.6378,0A22.855,22.855,0,0,0,33,41.0383V33h9.9679A35.3906,35.3906,0,0,1,41.3189,42.98Z"></path></g></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Around the Web</p></dt><dd class="ml-10 text-sm text-gray-500">A bit of everything, this page encapsulates OCaml&#x27;s presence online, blogposts, videos, and mailing lists all live here.</dd></a><a class="-m-3 p-3 block rounded-md hover:bg-gray-50 transition ease-in-out duration-150" href="/en/resources/archive/"><div class="h-7 w-7 float-left fill-current stroke-current text-orangedark"><svg viewBox="0 0 32 40" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M28,3H4A3,3,0,0,0,1,6V8a3,3,0,0,0,2,2.816V26a3,3,0,0,0,3,3H26a3,3,0,0,0,3-3V10.816A3,3,0,0,0,31,8V6A3,3,0,0,0,28,3ZM27,26a1,1,0,0,1-1,1H6a1,1,0,0,1-1-1V11H27ZM29,8a1,1,0,0,1-1,1H4A1,1,0,0,1,3,8V6A1,1,0,0,1,4,5H28a1,1,0,0,1,1,1Z"></path><path d="M13,17h6a1,1,0,0,0,0-2H13a1,1,0,0,0,0,2Z"></path></svg></div><dt><p class="ml-10 text-sm font-semibold text-gray-900">Archive</p></dt><dd class="ml-10 text-sm text-gray-500">Can&#x27;t find what you&#x27;re looking for? Try searching the Archive.</dd></a></div></div></div></div></nav><div class="flex-1 flex items-center justify-center px-2 md:justify-end "><div class="max-w-lg w-full md:max-w-xs"><label class="sr-only" for="search">Search ocaml.org</label><form id="searchform" action="https://duckduckgo.com/" method="get"><input type="hidden" name="sites" value="ocaml.org"/><div class="relative"><div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"><svg aria-hidden="true" class="h-5 w-5 text-gray-400" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" fill-rule="evenodd"></path></svg></div><input type="search" class="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md leading-5 bg-white placeholder-gray-500 focus:outline-none focus:placeholder-gray-400 focus:ring-1 focus:ring-orangedark focus:border-orangedarker sm:text-sm" id="search" name="q" placeholder="Search ocaml.org"/></div></form></div></div><div class="-mr-2 -my-2 md:hidden "><button class="bg-white rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500" type="button"><span class="sr-only">Open menu</span><svg aria-hidden="true" class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 6h16M4 12h16M4 18h16" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></button></div></div></div><div class="absolute top-0 inset-x-0 p-2 transition transform origin-top-right md:hidden z-10  hidden "><div class="rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 bg-white divide-y-2 divide-gray-50"><div class="pt-5 pb-6 px-5"><div class="flex items-center justify-between"><div><img class="h-8 w-auto sm:h-10" alt="" src="/static/logo1.jpeg"/></div><div class="-mr-2"><button class="bg-white rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500" type="button"><span class="sr-only"> Close menu </span><svg aria-hidden="true" class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></button></div></div><div class="mt-6"><nav class="grid gap-y-2"><h3 class="ml-6 mt-2 px-3 font-semibold text-gray-400 uppercase">Principles</h3><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/principles/whatisocaml/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 12.7 15.9" xmlns="http://www.w3.org/2000/svg"><path d="m9.01 1.23a0.676 0.676 0 0 0-0.658 0.52 7.02 7.02 0 0 0-0.185 1.41 0.338 0.338 0 0 1-0.674 0.0292 6.26 6.26 0 0 0-0.304-1.33 0.81 0.81 0 0 0-1.56 0.118 3.15 3.15 0 0 1-1.26 1.98 0.495 0.495 0 0 1-0.564 9e-3 1.49 1.49 0 0 1-0.459-0.492 0.495 0.495 0 0 1 0.023-0.531 1.22 1.22 0 0 0 0.141-0.266 0.295 0.295 0 0 0-0.374-0.383 0.987 0.987 0 0 0-0.183 0.0867 0.819 0.819 0 0 0-1.21-0.24 1.36 1.36 0 0 1-0.767 0.395 0.516 0.516 0 0 0 0.0788 1.03h0.42a0.789 0.789 0 0 0 0.507 0.259 2.67 2.67 0 0 0 2.32 2.59 0.471 0.471 0 0 0 0.328-0.0783 1.81 1.81 0 0 0 0.438 1.11 3.97 3.97 0 0 1 1.15 2.78 0.202 0.202 0 0 1-0.11 0.18 2.56 2.56 0 0 0-0.682 0.506 0.325 0.325 0 0 0 0.234 0.55h1.43a0.468 0.468 0 0 0 0.0934-0.784 0.202 0.202 0 0 1-0.0744-0.156v-1.43a1.5 1.5 0 0 0-0.15-1.08v-0.591a2.43 2.43 0 0 0 1.68 0.0748 3.43 3.43 0 0 0 1.4-0.668 1.78 1.78 0 0 0 0.228 0.465 2.84 2.84 0 0 1 0.408 2.9 0.202 0.202 0 0 1-0.115 0.11 2.56 2.56 0 0 0-0.934 0.617 0.325 0.325 0 0 0 0.234 0.55h1.43a0.468 0.468 0 0 0 0.122-0.759 0.202 0.202 0 0 1-0.0558-0.197 4.7 4.7 0 0 1 0.706-1.51 0.383 0.383 0 0 0 0.0598-0.309 6.18 6.18 0 0 1 0.035-2.97 1.06 1.06 0 0 0-0.45-1.16l-0.486-0.315a1.08 1.08 0 0 1-0.453-0.618 5.11 5.11 0 0 0-1.26-2.19 0.676 0.676 0 0 0-0.485-0.205zm-0.00227 0.181a0.495 0.495 0 0 1 0.355 0.15 4.93 4.93 0 0 1 1.21 2.11 1.26 1.26 0 0 0 0.529 0.721l0.486 0.315a0.882 0.882 0 0 1 0.374 0.962 6.36 6.36 0 0 0-0.0358 3.06 0.202 0.202 0 0 1-0.0319 0.163 4.88 4.88 0 0 0-0.733 1.57 0.383 0.383 0 0 0 0.105 0.374 0.287 0.287 0 0 1-0.0429 0.447h-1.38a0.143 0.143 0 0 1-0.103-0.243 2.38 2.38 0 0 1 0.868-0.574 0.383 0.383 0 0 0 0.216-0.208 3.02 3.02 0 0 0-0.429-3.08 1.6 1.6 0 0 1-0.218-1.33 0.0906 0.0906 0 0 0-0.174-0.0491 1.78 1.78 0 0 0-0.0319 0.83 3.25 3.25 0 0 1-1.39 0.686 2.25 2.25 0 0 1-1.63-0.0978v-0.624a0.0906 0.0906 0 0 0-0.181 0v1.46a1.32 1.32 0 0 1 0.15 1.01v1.46a0.383 0.383 0 0 0 0.14 0.297 0.287 0.287 0 0 1-0.0248 0.462h-1.38a0.143 0.143 0 0 1-0.103-0.243 2.38 2.38 0 0 1 0.634-0.47 0.383 0.383 0 0 0 0.209-0.343 4.15 4.15 0 0 0-1.19-2.9 1.62 1.62 0 0 1-0.308-1.57 0.0907 0.0907 0 1 0-0.172-0.058 1.81 1.81 0 0 0-0.073 0.298 0.29 0.29 0 0 1-0.324 0.243 2.48 2.48 0 0 1-2.16-2.42 0.789 0.789 0 0 0 0.404-0.176 0.0907 0.0907 0 0 0-0.116-0.139 0.608 0.608 0 0 1-0.888-0.123h-0.508a0.335 0.335 0 0 1-0.0505-0.667 1.54 1.54 0 0 0 0.86-0.438 0.638 0.638 0 0 1 0.942 0.212 0.987 0.987 0 0 0-0.0894 0.0907 0.0909 0.0909 0 1 0 0.138 0.119 0.805 0.805 0 0 1 0.342-0.234 0.114 0.114 0 0 1 0.144 0.148 1.04 1.04 0 0 1-0.119 0.227 0.676 0.676 0 0 0-0.031 0.725 1.68 1.68 0 0 0 0.515 0.551 0.676 0.676 0 0 0 0.772-0.0116 3.33 3.33 0 0 0 1.33-2.1 0.629 0.629 0 0 1 1.21-0.0912 6.08 6.08 0 0 1 0.295 1.29 0.52 0.52 0 0 0 1.04-0.0451 6.84 6.84 0 0 1 0.18-1.37 0.495 0.495 0 0 1 0.482-0.381z" stroke-width=".289"></path><path d="m2.16 2.76a0.128 0.128 0 1 0-0.256 0 0.128 0.128 0 1 0 0.256 0z" stroke-width=".2"></path></svg></span><span class="font-bold">Why OCaml</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/principles/users/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg class="stroke-0" version="1.1" viewBox="0 0 60 75" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M6,55h48c0.6,0,1-0.4,1-1V33c0-0.3-0.1-0.5-0.3-0.7l-9-8.4L44,5.9c0-0.1,0-0.1,0-0.2c0-0.1,0-0.1,0-0.2  c0-0.1-0.1-0.1-0.1-0.2c0,0-0.1-0.1-0.1-0.1c-0.1-0.1-0.1-0.1-0.2-0.1c0,0-0.1-0.1-0.1-0.1C43.3,5,43.1,5,43,5h-6  c-0.1,0-0.3,0-0.4,0.1c0,0-0.1,0-0.1,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0-0.1,0.1-0.1,0.1c0,0.1-0.1,0.1-0.1,0.2c0,0.1,0,0.1,0,0.2  c0,0.1,0,0.1,0,0.2l-1.3,20.8l-8-7.4c-0.3-0.3-0.7-0.3-1.1-0.2C25.2,19.2,25,19.6,25,20v10.7L12.7,19.3c-0.3-0.3-0.7-0.3-1.1-0.2  C11.2,19.2,11,19.6,11,20v12H6c-0.6,0-1,0.4-1,1v21C5,54.6,5.4,55,6,55z M42,7v1h-4V7H42z M37.8,10h4.6l1.1,11.9l-2.8-2.6  c-0.3-0.3-0.7-0.3-1.1-0.2C39.2,19.2,39,19.6,39,20v10.7l-2.4-2.2L37.8,10z M7,34h5c0.6,0,1-0.4,1-1V22.3l12.3,11.4  c0.3,0.3,0.7,0.3,1.1,0.2c0.4-0.2,0.6-0.5,0.6-0.9V22.3l12.3,11.4c0.3,0.3,0.7,0.3,1.1,0.2c0.4-0.2,0.6-0.5,0.6-0.9V22.3l3.1,2.9  c0,0,0,0,0,0l8.9,8.3V53H7V34z"></path><path d="M16,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C17,38.4,16.6,38,16,38z M15,42h-2v-2h2V42z"></path><path d="M24,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C25,38.4,24.6,38,24,38z M23,42h-2v-2h2V42z"></path><path d="M32,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C33,38.4,32.6,38,32,38z M31,42h-2v-2h2V42z"></path><path d="M40,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C41,38.4,40.6,38,40,38z M39,42h-2v-2h2V42z"></path><path d="M48,38h-4c-0.6,0-1,0.4-1,1v4c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-4C49,38.4,48.6,38,48,38z M47,42h-2v-2h2V42z"></path></svg></span><span class="font-bold">Industrial Users</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/principles/academic/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg class="stroke-2" version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g transform="translate(0,-952.36218)"><path d="M 47.25 23 A 1.0001 1.0001 0 0 0 47.125 23.0625 L 5.625 39.0625 A 1.0001 1.0001 0 0 0 5.625 40.90625 L 21.1875 46.90625 A 1.0001 1.0001 0 0 0 21.1875 47 L 21.1875 63.4375 A 1.0001 1.0001 0 0 0 21.8125 64.34375 L 47.09375 74.90625 A 1.0001 1.0001 0 0 0 47.84375 74.90625 L 73.15625 64.34375 A 1.0001 1.0001 0 0 0 73.75 63.4375 L 73.75 47 A 1.0001 1.0001 0 0 0 73.75 46.9375 L 80.875 44.1875 A 1.0040202 1.0040202 0 0 0 80.15625 42.3125 L 47.46875 54.9375 L 8.75 40 L 47.5 25.03125 L 87.9375 40.65625 L 87.9375 65.09375 C 85.072141 65.568778 82.875 68.037767 82.875 71 C 82.875 74.2988 85.600803 77 88.9375 77 C 92.274197 77 95 74.2988 95 71 C 95 68.037767 92.802859 65.568778 89.9375 65.09375 L 89.9375 40 A 1.0001 1.0001 0 0 0 89.3125 39.0625 L 47.84375 23.0625 A 1.0001 1.0001 0 0 0 47.25 23 z M 23.1875 47.6875 L 47.125 56.90625 A 1.0001 1.0001 0 0 0 47.84375 56.90625 L 71.75 47.6875 L 71.75 62.75 L 47.46875 72.90625 L 23.1875 62.75 L 23.1875 47.6875 z M 88.9375 66.96875 C 91.187128 66.96875 92.96875 68.7759 92.96875 71 C 92.96875 73.2241 91.187128 75 88.9375 75 C 86.687872 75 84.875 73.2241 84.875 71 C 84.875 68.7759 86.687872 66.96875 88.9375 66.96875 z " transform="translate(0,952.36218)"></path></g></svg></span><span class="font-bold">Academic Excellence</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/principles/successes/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 160 200" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M151.305,149.32l-35.11-68.89c-0.6-1.17-1.8-1.91-3.12-1.91s-2.52,0.74-3.12,1.91l-11.98,23.5l3.93,7.71l11.17-21.92  l29.4,57.69h-22.34h-2.801L66.999,48.66v-8.949h42.25c1.933,0,3.5-1.567,3.5-3.5V9.09c0-1.933-1.567-3.5-3.5-3.5h-45.75  c-1.933,0-3.5,1.567-3.5,3.5v13.824v13.297V48.66L8.69,149.321c-0.553,1.085-0.502,2.38,0.134,3.418  c0.636,1.039,1.767,1.672,2.984,1.672h103.381c0.001,0,0.002,0,0.003,0h4.863h28.14c1.21,0,2.34-0.63,2.98-1.67  C151.815,151.7,151.865,150.41,151.305,149.32z M66.999,22.914V12.59h38.75v20.122h-38.75V22.914z M63.499,57.207l10.873,21.332  c-5.251-0.709-10.46,2.09-12.683,7.08c-0.751,1.687-2.234,2.781-4.067,3.003c-1.829,0.221-3.533-0.488-4.665-1.947l-2.703-3.484  L63.499,57.207z M17.52,147.41l29.221-57.328l0.685,0.883c2.329,3.002,5.817,4.696,9.543,4.695c0.494,0,0.993-0.029,1.493-0.09  c4.273-0.517,7.87-3.172,9.622-7.104c1.063-2.386,3.744-3.588,6.231-2.8l4.402,1.396l30.76,60.347H17.52z"></path><path d="M90.023,15.97l-5.161,5.71l-2.427-1.948c-1.075-0.864-2.649-0.692-3.514,0.384c-0.865,1.077-0.692,2.65,0.384,3.514  l4.265,3.424c0.461,0.37,1.014,0.551,1.564,0.551c0.684,0,1.364-0.279,1.855-0.824l6.742-7.46c0.926-1.024,0.846-2.605-0.178-3.531  C92.529,14.866,90.948,14.947,90.023,15.97z"></path></svg></span><span class="font-bold">Success Stories</span></a><h3 class="ml-6 mt-2 px-3 font-semibold text-gray-400 uppercase">Resources</h3><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/resources/language/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M10.7,22.2c0.4,0.2,0.9,0.2,1.4,0c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1  c0.7,0,1.3-0.4,1.6-1.1c0.4-0.9,0-1.9-0.9-2.3c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3C10,21.7,10.3,22,10.7,22.2z"></path><path d="M57.2,20.2c-0.4,0.2-0.8,0.5-0.9,1s-0.2,0.9,0,1.4c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.6-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1c0.4-0.9-0.1-1.9-1-2.3C74.1,13,57.9,19.9,57.2,20.2z"></path><path d="M42.6,31.4c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0  C25.7,28,41,34.6,41.2,34.6c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.9,32.8,43.5,31.8,42.6,31.4z"></path><path d="M89,30.1c-14.6-5.9-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.9,0.4,1.9-0.1,2.3-1C90.4,31.5,89.9,30.5,89,30.1z"></path><path d="M42.6,42.9c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.4,0.9,1.4,1.3,2.3,1  c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.9,44.3,43.5,43.3,42.6,42.9z"></path><path d="M89,41.6c-14.6-5.9-30.8,1-31.5,1.3c-0.4,0.2-0.8,0.5-0.9,1c-0.2,0.4-0.2,0.9,0,1.4  c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1c0.2-0.1,15.5-6.6,28.7-1.2c0.9,0.4,1.9-0.1,2.3-1C90.4,43,89.9,42,89,41.6z"></path><path d="M42.5,54.4c-0.7-0.3-16.9-7.2-31.5-1.3c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0  c13.2-5.4,28.6,1.2,28.7,1.2c0.2,0.1,0.5,0.1,0.7,0.1c0.7,0,1.3-0.4,1.6-1.1C43.8,55.8,43.4,54.8,42.5,54.4z"></path><path d="M88.9,53.1c-14.6-6-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1C90.2,54.5,89.8,53.5,88.9,53.1z"></path><path d="M41.8,69.1c0.7,0,1.3-0.4,1.6-1.1c0.4-0.9,0-1.9-0.9-2.3c-0.7-0.3-16.9-7.2-31.5-1.3  c-0.9,0.4-1.3,1.4-1,2.3c0.2,0.4,0.5,0.8,1,1c0.4,0.2,0.9,0.2,1.4,0c13.2-5.4,28.6,1.2,28.7,1.2C41.3,69,41.5,69.1,41.8,69.1z"></path><path d="M88.9,64.4c-14.6-6-30.8,1-31.5,1.3c-0.9,0.4-1.3,1.4-0.9,2.3c0.3,0.6,0.9,1.1,1.6,1.1c0.2,0,0.5,0,0.7-0.1  c0.2-0.1,15.5-6.6,28.7-1.2c0.4,0.2,0.9,0.2,1.4,0c0.4-0.2,0.8-0.5,1-1C90.2,65.8,89.8,64.7,88.9,64.4z"></path><path d="M97.9,12.1c0-0.8-0.5-1.6-1.3-1.9C72-0.3,54.9,10.1,50,13.8C45,10.1,27.9-0.3,3.3,10.2  c-0.8,0.3-1.3,1.1-1.3,1.9v78.6c0,0.7,0.4,1.4,1,1.8c0.3,0.2,0.7,0.3,1.1,0.3c0.3,0,0.6-0.1,0.9-0.2c0.2-0.1,17.1-7.8,43.5-0.2l0,0  l3,0l0.1,0c17.3-7,39.3-0.9,43.6,0.4c0.6,0.2,1.3,0.1,1.8-0.3c0.5-0.4,0.8-1,0.8-1.7L97.9,12.1z M93.8,87.8V88  c-7.7-2.1-15.2-3.1-22.4-3.1c-1.2,0-2.4,0-3.6,0.1C76.2,83.3,84.9,84.3,93.8,87.8z M93.8,83.4c-20.6-7.6-35.7-0.5-41.7,3.3l0-69.3  c3.2-2.5,19-13,41.7-3.9L93.8,83.4z M34.5,85.4C22.3,84,13.2,85.6,7.9,87.2c6.1-2.2,11.7-3.1,16.5-3.1  C28.3,84.1,31.7,84.6,34.5,85.4z M6.2,13.4c23.1-9.2,38.6,1.5,41.7,4l0,69.3C43.9,84.1,35.7,80,24.3,80c-5.4,0-11.4,0.9-18.1,3.4  L6.2,13.4z"></path></svg></span><span class="font-bold">Language</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/packages/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M85.8,35.6l11.2-13c0.5-0.5,0.6-1.3,0.4-2c-0.2-0.7-0.7-1.2-1.4-1.5L63.1,8.3c-0.8-0.3-1.7,0-2.3,0.6L50,21.5L39.2,9    c-0.6-0.7-1.5-0.9-2.3-0.6L4,19.1c-0.7,0.2-1.2,0.8-1.4,1.5c-0.2,0.7,0,1.4,0.4,2l11.2,13L3,48.6c-0.5,0.5-0.6,1.3-0.4,2    c0.2,0.7,0.7,1.2,1.4,1.5l10.9,3.6v23.2c0,0.9,0.6,1.8,1.5,2.1l32.9,10.8c0.2,0.1,0.5,0.1,0.7,0.1c0.2,0,0.5,0,0.7-0.1l32.9-10.8    c0.9-0.3,1.5-1.1,1.5-2.1V55.7l11-3.6c0.7-0.2,1.2-0.8,1.4-1.5c0.2-0.7,0-1.4-0.4-2L85.8,35.6z M24,35.6l26-8.5l26,8.5l-26,8.5    L24,35.6z M63.1,12.9l28.5,9.3l-9.4,10.9l-28.5-9.3L63.1,12.9z M36.9,12.9l9.4,10.9l-28.5,9.3L8.4,22.2L36.9,12.9z M17.8,38.1    l28.5,9.3l-9.4,10.9L8.4,49L17.8,38.1z M19.2,77.2V57.1l17.6,5.8c0.2,0.1,0.4,0.1,0.7,0.1c0.6,0,1.2-0.3,1.6-0.7l8.6-10v34.4    L19.2,77.2z M80.7,77.2l-28.6,9.4V52.2l8.6,10c0.4,0.5,1,0.7,1.6,0.7c0.2,0,0.5,0,0.7-0.1l17.6-5.8V77.2z M63.1,58.3l-9.4-10.9    l28.5-9.3L91.6,49L63.1,58.3z"></path></g></svg></span><span class="font-bold">Packages</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/resources/applications/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M85.32,15.63H78.65a1.5,1.5,0,0,0-1.5,1.5v3.53H73.36a5.5,5.5,0,0,0-10.57,0h-7.9a5.5,5.5,0,0,0-10.57,0H36.11a5.5,5.5,0,0,0-10.57,0H22.85V17.13a1.5,1.5,0,0,0-1.5-1.5H14.68a1.5,1.5,0,0,0-1.5,1.5V82.87a1.5,1.5,0,0,0,1.5,1.5h6.67a1.5,1.5,0,0,0,1.5-1.5V74.63h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,9.29-2.27H54.79a5.49,5.49,0,0,0,9.29,2.27,5.49,5.49,0,0,0,9.28-2.27h3.79v8.24a1.5,1.5,0,0,0,1.5,1.5h6.67a1.5,1.5,0,0,0,1.5-1.5V17.13A1.5,1.5,0,0,0,85.32,15.63Zm-25.22,39a5.5,5.5,0,0,0-9.29-2.26,5.48,5.48,0,0,0-8,0,5.49,5.49,0,0,0-8,0,5.49,5.49,0,0,0-9.28,2.26H22.85v-14h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,8,0,5.49,5.49,0,0,0,9.28-2.27H62.79a5.49,5.49,0,0,0,10.57,0h3.79v14Zm-2.79,1.5a2.5,2.5,0,1,1-2.5-2.49A2.5,2.5,0,0,1,57.31,56.14Zm-8,0a2.5,2.5,0,1,1-2.49-2.49A2.5,2.5,0,0,1,49.31,56.14Zm-8,0a2.5,2.5,0,1,1-2.5-2.49A2.5,2.5,0,0,1,41.32,56.14Zm-8,0a2.5,2.5,0,1,1-2.49-2.49A2.5,2.5,0,0,1,33.32,56.14Zm-5-17a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,28.33,39.15Zm8,0a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,36.32,39.15Zm8,0a2.5,2.5,0,1,1,2.5,2.5A2.5,2.5,0,0,1,44.32,39.15Zm21.26,0a2.5,2.5,0,1,1,2.49,2.5A2.5,2.5,0,0,1,65.58,39.15Zm2.49-19.48a2.5,2.5,0,1,1-2.49,2.49A2.5,2.5,0,0,1,68.07,19.67Zm-18.47,0a2.5,2.5,0,1,1-2.5,2.49A2.5,2.5,0,0,1,49.6,19.67Zm-18.77,0a2.5,2.5,0,1,1-2.5,2.49A2.5,2.5,0,0,1,30.83,19.67Zm-5.29,4a5.49,5.49,0,0,0,10.57,0h8.21a5.49,5.49,0,0,0,10.57,0h7.9a5.49,5.49,0,0,0,10.57,0h3.79v14H73.36a5.5,5.5,0,0,0-10.57,0H52.1a5.49,5.49,0,0,0-9.28-2.26,5.49,5.49,0,0,0-8,0,5.49,5.49,0,0,0-9.28,2.26H22.85v-14ZM19.85,81.37H16.18V18.63h3.67Zm11-5.74a2.5,2.5,0,1,1,2.49-2.5A2.5,2.5,0,0,1,30.83,75.63Zm8,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,38.82,75.63Zm21.26,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,60.08,75.63Zm8,0a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,68.07,75.63Zm5.29-4a5.49,5.49,0,0,0-9.28-2.26,5.5,5.5,0,0,0-9.29,2.26H44.11a5.5,5.5,0,0,0-9.29-2.26,5.49,5.49,0,0,0-9.28,2.26H22.85v-14h2.69a5.49,5.49,0,0,0,9.28,2.27,5.49,5.49,0,0,0,8,0,5.48,5.48,0,0,0,8,0,5.49,5.49,0,0,0,9.29-2.27H77.15v14Zm10.46,9.74H80.15V18.63h3.67Z"></path></svg></span><span class="font-bold">Applications</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/resources/bestpractices/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M7,51h28.7c3.3,0,6.6-1.4,8.8-3.9L61.2,29H76c6.6,0,9-3.8,9-7c0-1.1-0.2-2.1-0.7-3H88c3.9,0,7-3.1,7-7s-3.1-7-7-7H45  c-0.1,0-0.1,0-0.2,0c0,0-0.1,0-0.2,0s-0.1,0-0.2,0c-0.1,0-0.1,0-0.2,0.1c0,0-0.1,0-0.2,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0,0,0,0,0  L22.3,21H7c-1.1,0-2,0.9-2,2v26C5,50.1,5.9,51,7,51z M76,25H64.5c0.5-1.1,0.8-2.4,0.7-3.7c-0.1-0.8-0.3-1.6-0.6-2.3H78  c1.7,0,3,1.3,3,3C81,24.7,77.5,25,76,25z M19,25h4c0.2,0,0.4,0,0.5-0.1c0,0,0.1,0,0.1,0c0.2-0.1,0.3-0.1,0.5-0.2c0,0,0,0,0,0L45.7,9  H88c1.7,0,3,1.3,3,3c0,1.6-1.3,3-3,3H58c-0.1,0-0.3,0-0.4,0c-1.8,0.2-3.5,1-4.7,2.3L34.9,36.9c-0.7,0.8-0.7,2.1,0.1,2.8  s2.1,0.7,2.8-0.1l18-19.5c1.1-1.2,2.9-1.4,4.2-0.5c0.7,0.5,1.1,1.3,1.2,2.1c0.1,0.8-0.2,1.7-0.8,2.3L41.6,44.4  c-1.5,1.6-3.7,2.6-5.9,2.6H19V25z M9,25h6v22H9V25z M93,49H64.3c-3.3,0-6.6,1.4-8.8,3.9L38.8,71H24c-6.6,0-9,3.8-9,7  c0,1.1,0.2,2.1,0.7,3H12c-3.9,0-7,3.1-7,7s3.1,7,7,7h43c0,0,0,0,0,0c0.2,0,0.4,0,0.5-0.1c0,0,0.1,0,0.1,0c0.2-0.1,0.3-0.1,0.5-0.2  c0,0,0,0,0,0L77.7,79H93c1.1,0,2-0.9,2-2V51C95,49.9,94.1,49,93,49z M24,75h11.5c-0.5,1.1-0.8,2.4-0.7,3.7c0.1,0.8,0.3,1.6,0.6,2.3  H22c-1.7,0-3-1.4-3-3C19,75.3,22.5,75,24,75z M81,75h-4c-0.1,0-0.2,0-0.3,0c0,0-0.1,0-0.1,0c-0.1,0-0.2,0-0.2,0.1c0,0-0.1,0-0.2,0.1  s-0.1,0-0.2,0.1c-0.1,0-0.1,0.1-0.2,0.1c0,0,0,0,0,0L54.3,91H12c-1.7,0-3-1.4-3-3c0-1.7,1.3-3,3-3h30c0.1,0,0.3,0,0.4,0  c1.8-0.2,3.5-0.9,4.7-2.3l17.9-19.5c0.7-0.8,0.7-2.1-0.1-2.8c-0.8-0.7-2.1-0.7-2.8,0.1l-18,19.5c-1.1,1.2-2.9,1.5-4.2,0.5  c-0.7-0.5-1.1-1.3-1.2-2.1c-0.1-0.9,0.2-1.7,0.8-2.3l18.8-20.4c1.5-1.6,3.7-2.6,5.9-2.6H81V75z M91,75h-6V53h6V75z"></path></svg></span><span class="font-bold">Best Practices</span></a><h3 class="ml-6 mt-2 px-3 font-semibold text-gray-400 uppercase">Community</h3><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/community/opportunities/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 1024 1280" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M512,300.4c-31,0-60-14.7-81.7-41.3c-20.6-25.2-32-58-32-92.1c0-34.5,11.8-63.3,34.1-83.4c20.1-18.2,48.4-28.2,79.6-28.2   c31.2,0,59.5,10,79.6,28.2c22.3,20.1,34.1,49,34.1,83.4c0,34.2-11.4,66.9-32,92.1C572,285.7,543,300.4,512,300.4z M512,95.4   c-17.3,0-73.7,5.2-73.7,71.6c0,24.6,8.4,49,23,66.8c14,17.1,32,26.6,50.7,26.6c18.7,0,36.7-9.4,50.7-26.6   c14.6-17.9,23-42.2,23-66.8C585.7,100.6,529.3,95.4,512,95.4z"></path><rect height="44.4" width="40" x="383.9" y="470.9"></rect><path d="M338.4,515.4h-40v-83.6c0-35,20.6-66.7,52.6-80.9l100-44.4c10.4-4.6,22.4-1.5,29.2,7.5l31.9,41.7l32.4-41.7   c6.8-9,18.8-12,29.2-7.4l99.4,44.3c31.9,14.2,52.5,45.9,52.5,80.9v83.6h-40v-83.6c0-19.2-11.3-36.6-28.7-44.3l-88.2-39.3   l-56.8,73.1l-55.9-73.1l-88.7,39.4c-17.5,7.8-28.8,25.2-28.8,44.3V515.4z"></path><rect height="44.4" width="40" x="600.1" y="470.9"></rect><rect height="126.9" width="40" x="492" y="388.4"></rect><path d="M819.5,784.5c-3.3,0-6.7-0.6-9.9-2c-9.6-4-15.9-13.3-15.9-23.7v-51.2h-75.1c-13,0-23.6-10.6-23.6-23.6V583.8   c0-13,10.6-23.6,23.6-23.6h75.1V509c0-10.5,6.2-19.8,15.9-23.8c9.7-4,20.7-1.8,28.1,5.6l124.9,124.9c10,10,10,26.4,0,36.4   L837.6,776.9C832.7,781.9,826.1,784.5,819.5,784.5z M735,667.6h98.7v56.7l90.5-90.5l-90.5-90.5v56.8H735V667.6z"></path><path d="M512,968.6c-6.6,0-13.2-2.5-18.2-7.5l-125-124.9c-7.3-7.3-9.5-18.2-5.7-27.7c3.9-9.6,13.1-16,23.5-16.2l0.4,0h51.2v-75.1   c0-13,10.6-23.6,23.6-23.6h100.3c13,0,23.6,10.6,23.6,23.6v75.1H637c10.4,0,19.7,6.2,23.7,15.9c4,9.7,1.8,20.7-5.6,28.1L530.2,961   C525.2,966.1,518.6,968.6,512,968.6z M421.5,832.2l90.5,90.5l90.5-90.5h-56.7v-98.7h-67.5v98.7H421.5z"></path><path d="M204.5,784.5c-6.7,0-13.3-2.6-18.2-7.6L61.5,652c-10-10-10-26.4,0-36.4l124.9-124.9c7.4-7.4,18.4-9.6,28.1-5.6   c9.7,4,15.9,13.3,15.9,23.8v51.2h75.1c13,0,23.6,10.6,23.6,23.6V684c0,13-10.6,23.6-23.6,23.6h-75.1v51.2   c0,10.4-6.2,19.7-15.9,23.7C211.2,783.9,207.9,784.5,204.5,784.5z M99.8,633.8l90.5,90.5v-56.7H289v-67.4h-98.7v-56.8L99.8,633.8z"></path></g></svg></span><span class="font-bold">Opportunities</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/community/blog/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg version="1.1" viewBox="0 0 100 125" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g transform="translate(0,-952.36218)"><path d="M 17.78125 15 A 2.0002 2.0002 0 0 0 15.96875 17 L 15.96875 25.3125 L 8 25.3125 A 2.0002 2.0002 0 0 0 6 27.3125 L 6 83 A 2.0002 2.0002 0 0 0 8 85 L 92 85 A 2.0002 2.0002 0 1 0 92 81 L 10 81 L 10 29.3125 L 15.96875 29.3125 L 15.96875 74.75 A 2.0002 2.0002 0 1 0 19.96875 74.75 L 19.96875 19 L 89.84375 19 L 89.84375 73.96875 A 2.0002 2.0002 0 1 0 93.84375 73.96875 L 93.84375 17 A 2.0002 2.0002 0 0 0 91.84375 15 L 17.96875 15 A 2.0002 2.0002 0 0 0 17.78125 15 z M 28.75 26.34375 A 2.0002 2.0002 0 0 0 26.96875 28.34375 L 26.96875 51.03125 A 2.0002 2.0002 0 0 0 28.96875 53.03125 L 52.90625 53.03125 A 2.0002 2.0002 0 0 0 54.90625 51.03125 L 54.90625 28.34375 A 2.0002 2.0002 0 0 0 52.90625 26.34375 L 28.96875 26.34375 A 2.0002 2.0002 0 0 0 28.75 26.34375 z M 63.6875 26.34375 A 2.0029885 2.0029885 0 1 0 63.90625 30.34375 L 81.84375 30.34375 A 2.0002 2.0002 0 1 0 81.84375 26.34375 L 63.90625 26.34375 A 2.0002 2.0002 0 0 0 63.6875 26.34375 z M 30.96875 30.34375 L 50.90625 30.34375 L 50.90625 49.03125 L 30.96875 49.03125 L 30.96875 30.34375 z M 63.6875 37.6875 A 2.0029885 2.0029885 0 1 0 63.90625 41.6875 L 81.84375 41.6875 A 2.0002 2.0002 0 1 0 81.84375 37.6875 L 63.90625 37.6875 A 2.0002 2.0002 0 0 0 63.6875 37.6875 z M 63.6875 49.03125 A 2.0029885 2.0029885 0 1 0 63.90625 53.03125 L 81.84375 53.03125 A 2.0002 2.0002 0 1 0 81.84375 49.03125 L 63.90625 49.03125 A 2.0002 2.0002 0 0 0 63.6875 49.03125 z M 27.75 60.375 A 2.0029885 2.0029885 0 1 0 27.96875 64.375 L 81.84375 64.375 A 2.0002 2.0002 0 1 0 81.84375 60.375 L 27.96875 60.375 A 2.0002 2.0002 0 0 0 27.75 60.375 z M 27.75 71.71875 A 2.0029885 2.0029885 0 1 0 27.96875 75.71875 L 81.6875 75.71875 A 2.0002 2.0002 0 1 0 81.6875 71.71875 L 27.96875 71.71875 A 2.0002 2.0002 0 0 0 27.75 71.71875 z " transform="translate(0,952.36218)"></path></g></svg></span><span class="font-bold">News</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/community/aroundweb/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg viewBox="0 0 64 80" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><g><path d="M32,9A23,23,0,1,0,55,32,23.0259,23.0259,0,0,0,32,9Zm0,44A21,21,0,1,1,53,32,21.0239,21.0239,0,0,1,32,53ZM63,32A30.99,30.99,0,0,1,10.3,54.124,29.6168,29.6168,0,0,1,8,51.6027V55a1,1,0,0,1-2,0V49a1,1,0,0,1,1-1h6a1,1,0,0,1,0,2H9.2789a27.8374,27.8374,0,0,0,2.4174,2.6929A28.99,28.99,0,0,0,61,32a28.617,28.617,0,0,0-2.86-12.5645,1,1,0,1,1,1.8008-.871A30.6112,30.6112,0,0,1,63,32ZM5.86,44.5645a1,1,0,0,1-1.8008.871A30.6112,30.6112,0,0,1,1,32,30.99,30.99,0,0,1,53.7,9.876,29.6168,29.6168,0,0,1,56,12.3973V9a1,1,0,0,1,2,0v6a1,1,0,0,1-1,1H51a1,1,0,0,1,0-2h3.7211a27.8374,27.8374,0,0,0-2.4174-2.6929A28.99,28.99,0,0,0,3,32,28.617,28.617,0,0,0,5.86,44.5645ZM43.1411,20.1112a23.1406,23.1406,0,0,0,2.1978-1.3661,1,1,0,0,0-1.1582-1.63c-.5694.4049-1.16.7679-1.76,1.1113A22.1893,22.1893,0,0,0,40.02,13.8438,1,1,0,1,0,38.4,15.0166,20.1638,20.1638,0,0,1,40.6245,19.14,20.8665,20.8665,0,0,1,33,20.9617V13a1,1,0,0,0-2,0v7.9617A20.866,20.866,0,0,1,23.3755,19.14,20.1638,20.1638,0,0,1,25.6,15.0166a1,1,0,1,0-1.6191-1.1728,22.1893,22.1893,0,0,0-2.4013,4.3827c-.6-.3434-1.19-.7064-1.76-1.1113a1,1,0,0,0-1.1582,1.63,23.1406,23.1406,0,0,0,2.1978,1.3661A36.8955,36.8955,0,0,0,19.0317,31H13a1,1,0,0,0,0,2h6.0317a36.8955,36.8955,0,0,0,1.8272,10.8888,23.1406,23.1406,0,0,0-2.1978,1.3661,1,1,0,0,0,1.1582,1.63c.5694-.4049,1.16-.7679,1.76-1.1113a22.193,22.193,0,0,0,2.4013,4.3828A1,1,0,1,0,25.6,48.9834a20.1636,20.1636,0,0,1-2.224-4.1233A20.866,20.866,0,0,1,31,43.0383V51a1,1,0,0,0,2,0V43.0383A20.8665,20.8665,0,0,1,40.6245,44.86,20.1638,20.1638,0,0,1,38.4,48.9834,1,1,0,1,0,40.02,50.1563a22.193,22.193,0,0,0,2.4013-4.3828c.6.3434,1.1905.7064,1.76,1.1113a1,1,0,0,0,1.1582-1.63,23.1406,23.1406,0,0,0-2.1978-1.3661A36.8955,36.8955,0,0,0,44.9683,33H51a1,1,0,0,0,0-2H44.9683A36.8955,36.8955,0,0,0,43.1411,20.1112Zm-1.8222.9086A35.3906,35.3906,0,0,1,42.9679,31H33V22.9617A22.855,22.855,0,0,0,41.3189,21.02Zm-18.6378,0A22.855,22.855,0,0,0,31,22.9617V31H21.0321A35.3906,35.3906,0,0,1,22.6811,21.02Zm0,21.96A35.3906,35.3906,0,0,1,21.0321,33H31v8.0383A22.855,22.855,0,0,0,22.6811,42.98Zm18.6378,0A22.855,22.855,0,0,0,33,41.0383V33h9.9679A35.3906,35.3906,0,0,1,41.3189,42.98Z"></path></g></svg></span><span class="font-bold">Around the Web</span></a><a class="text-gray-600 hover:bg-gray-50 hover:text-gray-900 group flex items-center px-2 py-2 text-sm font-medium rounded-md" href="/en/resources/archive/"><span class="text-gray-400 group-hover:text-gray-500 mr-3 flex-shrink-0 h-5 w-5 stroke-current fill-current stroke-2"><svg viewBox="0 0 32 40" x="0px" xmlns="http://www.w3.org/2000/svg" y="0px"><path d="M28,3H4A3,3,0,0,0,1,6V8a3,3,0,0,0,2,2.816V26a3,3,0,0,0,3,3H26a3,3,0,0,0,3-3V10.816A3,3,0,0,0,31,8V6A3,3,0,0,0,28,3ZM27,26a1,1,0,0,1-1,1H6a1,1,0,0,1-1-1V11H27ZM29,8a1,1,0,0,1-1,1H4A1,1,0,0,1,3,8V6A1,1,0,0,1,4,5H28a1,1,0,0,1,1,1Z"></path><path d="M13,17h6a1,1,0,0,0,0-2H13a1,1,0,0,0,0,2Z"></path></svg></span><span class="font-bold">Archive</span></a></nav></div></div></div></div></div></div><main class="relative bg-graylight pb-1"><div class="mx-auto"><div class="grid grid-cols-9 bg-white"><nav class="toc"><ul>
<li><ul>
<li><a href="#if-statements-actually-these-are-if-expressions">If statements (actually, these are if expressions)</a>
</li>
<li><a href="#using-begin--end">Using begin ... end</a>
</li>
<li><a href="#for-loops-and-while-loops">For loops and while loops</a>
</li>
<li><a href="#looping-over-lists">Looping over lists</a>
</li>
<li><a href="#looping-over-strings">Looping over strings</a>
</li>
<li><a href="#recursion">Recursion</a>
</li>
<li><a href="#mutable-records-references-again-and-arrays">Mutable records, references (again!) and arrays</a>
</li>
<li><a href="#mutually-recursive-functions">Mutually recursive functions</a>
</li>
</ul>
</li>
</ul>
</nav><div class="col-span-9 lg:col-span-7 bg-graylight relative py-16 overflow-hidden"><div class="relative px-4 sm:px-6 lg:px-8"><div class="text-lg max-w-prose mx-auto"><h1><span class="mt-2 block text-3xl text-center leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">If Statements, Loops and Recursions</span></h1><p class="mt-8 text-xl text-gray-500 leading-8">Learn basic control-flow and recusion in OCaml
</p></div><div class="mt-6 prose prose-yellow prose-lg text-gray-500 mx-auto"><h2 id="if-statements-actually-these-are-if-expressions">If statements (actually, these are if expressions)</h2>
<p>OCaml has an <code>if</code> statement with two variations, and the obvious meaning:</p>
<pre><code class="language-ocaml">if boolean-condition then expression
  
if boolean-condition then expression else other-expression
</code></pre>
<pre><code class="language-mdx-error">Line 3, characters 3-5:
Error: Syntax error
</code></pre>
<p>Unlike in the conventional languages you'll be used to, <code>if</code> statements
are really expressions. In other words, they're much more like
<code>boolean-condition ? expression : other-expression</code> in C than like the if
statements you may be used to.</p>
<p>Here's a simple example of an <code>if</code> statement:</p>
<pre><code class="language-ocaml"># let max a b =
  if a &gt; b then a else b
val max : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
</code></pre>
<p>As a short aside, if you type this into the OCaml
interactive toplevel (as above), you'll
notice that OCaml decides that this function is polymorphic, with the
following type:</p>
<pre><code class="language-ocaml"># max
- : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
</code></pre>
<p>And indeed OCaml lets you use <code>max</code> on any type:</p>
<pre><code class="language-ocaml"># max 3 5
- : int = 5
# max 3.5 13.0
- : float = 13.
# max &quot;a&quot; &quot;b&quot;
- : string = &quot;b&quot;
</code></pre>
<p>This is because <code>&gt;</code> is in fact polymorphic. It works on any type, even
objects (it does a binary comparison).</p>
<p>[Note that the <code>Stdlib</code> module defines <code>min</code> and <code>max</code> for you.]</p>
<p>Let's look a bit more closely at the <code>if</code> expression. Here's the <code>range</code>
function which I showed you earlier without much explanation. You should
be able to combine your knowledge of recursive functions, lists and if
expressions to see what it does:</p>
<pre><code class="language-ocaml"># let rec range a b =
    if a &gt; b then []
    else a :: range (a + 1) b
val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</code></pre>
<p>Let's examine some typical calls to this function. Let's start with the
easy case of <code>a &gt; b</code>. A call to <code>range 11 10</code> returns <code>[]</code> (the empty
list) and that's it.</p>
<p>What about calling <code>range 10 10</code>? Since <code>10 &gt; 10</code> is false, the
<code>else</code>-clause is evaluated, which is: <code>10 :: (range 11 10)</code> (I've added
the brackets to make the order of evaluation more clear). We've just
worked out that <code>range 11 10</code> = <code>[]</code>, so this is: <code>10 :: []</code>. Remember
our formal description of lists and the <code>::</code> (cons) operator? <code>10 :: []</code>
is just the same as <code>[10]</code>.</p>
<p>Let's try <code>range 9 10</code>:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">range 9 10
 9 :: (range 10 10)
 9 :: [10]
 [9; 10]
</code></pre>
<p>It should be fairly clear that <code>range 1 10</code> evaluates to
<code>[1; 2; 3; 4; 5; 6; 7; 8; 9; 10]</code>.</p>
<p>What we've got here is a simple case of recursion. Functional
programming can be said to prefer recursion over loops, but I'm jumping
ahead of myself. We'll discuss recursion more at the end of this
chapter.</p>
<p>Back, temporarily, to <code>if</code> statements. What does this function do?</p>
<pre><code class="language-ocaml"># let f x y =
    x + if y &gt; 0 then y else 0
val f : int -&gt; int -&gt; int = &lt;fun&gt;
</code></pre>
<p>Clue: add brackets around the whole of the if expression. It clips <code>y</code>
like an <a href="https://en.wikipedia.org/wiki/Diode#Current.E2.80.93voltage_characteristic">electronic diode</a>.</p>
<p>The <code>abs</code> (absolute value) function is defined in <code>Stdlib</code> as:</p>
<pre><code class="language-ocaml"># let abs x =
    if x &gt;= 0 then x else -x
val abs : int -&gt; int = &lt;fun&gt;
</code></pre>
<p>Also in <code>Stdlib</code>, the <code>string_of_float</code> function contains a complex
pair of nested <code>if</code> expressions:</p>
<pre><code class="language-ocaml"># let string_of_float f =
  let s = format_float &quot;%.12g&quot; f in
  let l = string_length s in
  let rec loop i =
    if i &gt;= l then s ^ &quot;.&quot;
    else if s.[i] = '.' || s.[i] = 'e' then s
    else loop (i + 1)
  in
    loop 0
Line 2, characters 11-23:
Error: Unbound value format_float
</code></pre>
<p>Let's examine this function. Suppose the function is called with <code>f</code> =
12.34. Then <code>s</code> = &quot;12.34&quot;, and <code>l</code> = 5. We call <code>loop</code> the first time
with <code>i</code> = 0.</p>
<p><code>i</code> is not greater than or equal to <code>l</code>, and <code>s.[i]</code> (the
<code>i</code><sup>th</sup> character in <code>s</code>) is not a period or <code>'e'</code>. So
<code>loop (i + 1)</code> is called, ie. <code>loop 1</code>.</p>
<p>We go through the same dance for <code>i</code> = 1, and end up calling <code>loop 2</code>.</p>
<p>For <code>i</code> = 2, however, <code>s.[i]</code> is a period (refer to the original string,
<code>s</code> = &quot;12.34&quot;). So this immediately returns <code>s</code>, and the function
<code>string_of_float</code> returns &quot;12.34&quot;.</p>
<p>What is <code>loop</code> doing? In fact it's checking whether the string returned
from <code>format_float</code> contains a period (or <code>'e'</code>). Suppose that we called
<code>string_of_float</code> with <code>12.0</code>. <code>format_float</code> would return the string
&quot;12&quot;, but <code>string_of_float</code> must return &quot;12.&quot; or &quot;12.0&quot; (because
floating point constants in OCaml must contain a period to differentiate
them from integer constants). Hence the check.</p>
<p>The strange use of recursion in this function is almost certainly for
efficiency. OCaml supports for loops, so why didn't the authors use for
loops? We'll see in the next section that OCaml's for loops are limited
in a way which prevents them from being used in <code>string_of_float</code>. Here,
however, is a more straightforward, but approximately twice as slow, way
of writing <code>string_of_float</code>:</p>
<pre><code class="language-ocaml"># let string_of_float f =
  let s = format_float &quot;%.12g&quot; f in
    if String.contains s '.' || String.contains s 'e'
      then s
      else s ^ &quot;.&quot;
Line 2, characters 11-23:
Error: Unbound value format_float
</code></pre>
<h2 id="using-begin--end">Using begin ... end</h2>
<p>Here is some code from lablgtk:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">if GtkBase.Object.is_a obj cls then
  fun _ -&gt; f obj
else begin
  eprintf &quot;Glade-warning: %s expects a %s argument.\n&quot; name cls;
  raise Not_found
end
</code></pre>
<p><code>begin</code> and <code>end</code> are what is known as <strong>syntactic sugar</strong> for open and
close parentheses. In the example above, all they do is group the two
statements in the <code>else</code>-clause together. Suppose the author had written
this instead:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">if GtkBase.Object.is_a obj cls then
  fun _ -&gt; f obj
else
  eprintf &quot;Glade-warning: %s expects a %s argument.\n&quot; name cls;
  raise Not_found
</code></pre>
<p>Fully bracketing and properly indenting the above expression gives:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">(if GtkBase.Object.is_a obj cls then
   fun _ -&gt; f obj
 else
   eprintf &quot;Glade-warning: %s expects a %s argument.\n&quot; name cls
);
raise Not_found
</code></pre>
<p>Not what was intended at all. So the <code>begin</code> and <code>end</code> are necessary to
group together multiple statements in a <code>then</code> or <code>else</code> clause of an if
expression. You can also use plain ordinary parentheses <code>( ... )</code> if you
prefer (and I do prefer, because I <strong>loathe</strong> Pascal :-). Here are two
simple examples:</p>
<pre><code class="language-ocaml"># if 1 = 0 then
    print_endline &quot;THEN&quot;
  else begin
    print_endline &quot;ELSE&quot;;
    failwith &quot;else clause&quot;
  end
Exception: Failure &quot;else clause&quot;.
ELSE
# if 1 = 0 then
    print_endline &quot;THEN&quot;
  else (
    print_endline &quot;ELSE&quot;;
    failwith &quot;else clause&quot;
  )
Exception: Failure &quot;else clause&quot;.
ELSE
</code></pre>
<h2 id="for-loops-and-while-loops">For loops and while loops</h2>
<p>OCaml supports a rather limited form of the familiar <code>for</code> loop:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">for variable = start_value to end_value do
  expression
done
  
for variable = start_value downto end_value do
  expression
done
</code></pre>
<p>A simple but real example from lablgtk:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">for i = 1 to n_jobs () do
  do_next_job ()
done
</code></pre>
<p>In OCaml, <code>for</code> loops are just shorthand for writing:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">let i = 1 in
do_next_job ();
let i = 2 in
do_next_job ();
let i = 3 in
do_next_job ();
  ...
let i = n_jobs () in
do_next_job ();
()
</code></pre>
<p>OCaml doesn't support the concept of breaking out of a <code>for</code> loop early
i.e. it has no <code>break</code>, <code>continue</code> or <code>last</code> statements. (You <em>could</em>
throw an exception and catch it outside, and this would run fast but
often looks clumsy.)</p>
<p>The expression inside an OCaml for loop should evaluate to <code>unit</code>
(otherwise you'll get a warning), and the for loop expression as a whole
returns <code>unit</code>:</p>
<pre><code class="language-ocaml"># for i = 1 to 10 do i done
Line 1, characters 20-21:
Warning 10: this expression should have type unit.
- : unit = ()
</code></pre>
<p>Functional programmers tend to use recursion instead of explicit loops,
and regard <strong>for</strong> loops with suspicion since it can't return anything,
hence OCaml's relatively powerless <strong>for</strong> loop. We talk about recursion
below.</p>
<p><strong>While loops</strong> in OCaml are written:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">while boolean-condition do
  expression
done
</code></pre>
<p>As with for loops, there is no way provided by the language to break out
of a while loop, except by throwing an exception, and this means that
while loops have fairly limited use. Again, remember that functional
programmers like recursion, and so while loops are second-class citizens
in the language.</p>
<p>If you stop to consider while loops, you may see that they aren't really
any use at all, except in conjunction with our old friend references.
Let's imagine that OCaml didn't have references for a moment:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">let quit_loop = false in
  while not quit_loop do
    print_string &quot;Have you had enough yet? (y/n) &quot;;
    let str = read_line () in
      if str.[0] = 'y' then
        (* how do I set quit_loop to true ?!? *)
  done
</code></pre>
<p>Remember that <code>quit_loop</code> is not a real &quot;variable&quot; - the let-binding
just makes <code>quit_loop</code> a shorthand for <code>false</code>. This means the while
loop condition (shown in red) is always true, and the loop runs on
forever!</p>
<p>Luckily OCaml <em>does have</em> references, so we can write the code above if
we want. Don't get confused and think that the <code>!</code> (exclamation mark)
means &quot;not&quot; as in C/Java. It's used here to mean &quot;dereference the
pointer&quot;, similar in fact to Forth. You're better off reading <code>!</code> as
&quot;get&quot; or &quot;deref&quot;.</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">let quit_loop = ref false in
  while not !quit_loop do
    print_string &quot;Have you had enough yet? (y/n) &quot;;
    let str = read_line () in
      if str.[0] = 'y' then quit_loop := true
  done;;
</code></pre>
<h2 id="looping-over-lists">Looping over lists</h2>
<p>If you want to loop over a list, don't be an imperative programmer and
reach for your trusty six-shooter Mr. For Loop! OCaml has some better
and faster ways to loop over lists, and they are all located in the
<code>List</code> module. There are in fact dozens of good functions in <code>List</code>, but
I'll only talk about the most useful ones here.</p>
<p>First off, let's define a list for us to use:</p>
<pre><code class="language-ocaml"># let my_list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
val my_list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</code></pre>
<p>If you want to call a function once on every element of the list, use
<code>List.iter</code>, like this:</p>
<pre><code class="language-ocaml"># let f elem =
    Printf.printf &quot;I'm looking at element %d now\n&quot; elem
  in
    List.iter f my_list
I'm looking at element 1 now
I'm looking at element 2 now
I'm looking at element 3 now
I'm looking at element 4 now
I'm looking at element 5 now
I'm looking at element 6 now
I'm looking at element 7 now
I'm looking at element 8 now
I'm looking at element 9 now
I'm looking at element 10 now
- : unit = ()
</code></pre>
<p><code>List.iter</code> is in fact what you should think about using first every
time your cerebellum suggests you use a for loop.</p>
<p>If you want to <em>transform</em> each element separately in the list - for
example, doubling each element in the list - then use <code>List.map</code>.</p>
<pre><code class="language-ocaml"># List.map (( * ) 2) my_list
- : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]
</code></pre>
<p>The function <code>List.filter</code> collects only those elements of a list which satisfy
some condition - e.g. returning all even numbers in a list.</p>
<pre><code class="language-ocaml"># let is_even i =
    i mod 2 = 0
  in
    List.filter is_even my_list
- : int list = [2; 4; 6; 8; 10]
</code></pre>
<p>To find out if a list contains some element, use <code>List.mem</code> (short for
member):</p>
<pre><code class="language-ocaml"># List.mem 12 my_list
- : bool = false
</code></pre>
<p><code>List.for_all</code> and <code>List.exists</code> are the same as the &quot;forall&quot; and
&quot;exist&quot; operators in predicate logic.</p>
<p>For operating over two lists at the same time, there are &quot;-2&quot; variants
of some of these functions, namely <code>iter2</code>, <code>map2</code>, <code>for_all2</code>,
<code>exists2</code>.</p>
<p>The <code>map</code> and <code>filter</code> functions operate on individual list elements in
isolation. <strong>Fold</strong> is a more unusual operation that is best
thought about as &quot;inserting an operator between each element of the
list&quot;. Suppose I wanted to add all the numbers in my list together. In
hand-waving terms what I want to do is insert a plus sign between the
elements in my list:</p>
<pre><code class="language-ocaml"># 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
- : int = 55
</code></pre>
<p>The fold operation does this, although the exact details are a little
bit more tricky. First of all, what happens if I try to fold an empty
list? In the case of summing the list it would be nice if the answer was
zero, instead of error. However if I was trying to find the product of
the list, I'd like the answer to be one instead. So I obviously have to
provide some sort of &quot;default&quot; argument to my fold. The second issue
doesn't arise with simple operators like <code>+</code> and <code>*</code>: what happens if
the operator I'm using isn't associative, ie. (a <em>op</em> b) <em>op</em> c not
equal to a <em>op</em> (b <em>op</em> c)? In that case it would matter if I started
from the left hand end of the list and worked right, versus if I started
from the right and worked left. For this reason there are two versions
of fold, called <code>List.fold_left</code> (works left to right) and
<code>List.fold_right</code> (works right to left, and is also less efficient).</p>
<p>Let's use <code>List.fold_left</code> to define <code>sum</code> and <code>product</code> functions for
integer lists:</p>
<pre><code class="language-ocaml"># let sum = List.fold_left ( + ) 0
val sum : int list -&gt; int = &lt;fun&gt;
# let product = List.fold_left ( * ) 1
val product : int list -&gt; int = &lt;fun&gt;
# sum my_list
- : int = 55
# product my_list
- : int = 3628800
</code></pre>
<p>That was easy! Notice that I've accidentally come up with a way to do
mathematical factorials:</p>
<pre><code class="language-ocaml"># let fact n = product (range 1 n)
val fact : int -&gt; int = &lt;fun&gt;
# fact 10
- : int = 3628800
</code></pre>
<p>(Notice that this factorial function isn't very useful because it
overflows the integers and gives wrong answers even for quite small
values of <code>n</code>.)</p>
<h2 id="looping-over-strings">Looping over strings</h2>
<p>The <code>String</code> module also contains many dozens of useful string-related
functions, and some of them are concerned with looping over strings.</p>
<p><code>String.copy</code> copies a string, like <code>strdup</code>. There is also a <code>String.iter</code>
function which works like <code>List.iter</code>, except over the characters of the
string.</p>
<h2 id="recursion">Recursion</h2>
<p>Now we come to a hard topic - recursion. Functional programmers are
defined by their love of recursive functions, and in many ways recursive
functions in f.p. are the equivalent of loops in imperative programming.
In functional languages loops are second-class citizens, whilst
recursive functions get all the best support.</p>
<p>Writing recursive functions requires a change in mindset from writing
for loops and while loops. So what I'll give you in this section will be
just an introduction and examples.</p>
<p>In the first example we're going to read the whole of a file into memory
(into a long string). There are essentially three possible approaches to
this:</p>
<h3 id="approach-1">Approach 1</h3>
<p>Get the length of the file, and read it all in one go using the
<code>really_input</code> method. This is the simplest, but it might not work on
channels which are not really files (eg. reading keyboard input) which
is why we look at the other two approaches.</p>
<h3 id="approach-2">Approach 2</h3>
<p>The imperative approach, using a while loop which is broken out of using
an exception.</p>
<h3 id="approach-3">Approach 3</h3>
<p>A recursive loop, breaking out of the recursion again using an
exception.</p>
<p>We're going to introduce a few new concepts here. Our second two
approaches will use the <code>Buffer</code> module - an expandable buffer which you
can think of like a string onto which you can efficiently append more
text at the end. We're also going to be catching the <code>End_of_file</code>
exception which the input functions throw when they reach the end of the
input. Also we're going to use <code>Sys.argv.(1)</code> to get the first command
line parameter.</p>
<pre><code class="language-ocaml">(* Read whole file: Approach 1 *)
open Printf
  
let read_whole_chan chan =
  let len = in_channel_length chan in
  let result = (Bytes.create len) in
    really_input chan result 0 len;
    (Bytes.to_string result)
  
let read_whole_file filename =
  let chan = open_in filename in
    read_whole_chan chan
  
let main () =
  let filename = Sys.argv.(1) in
  let str = read_whole_file filename in
    printf &quot;I read %d characters from %s\n&quot; (String.length str) filename
</code></pre>
<p>Approach 1 works but is not very satisfactory because <code>read_whole_chan</code>
won't work on non-file channels like keyboard input or sockets. Approach
2 involves a while loop:</p>
<pre><code class="language-ocaml">(* Read whole file: Approach 2 *)
open Printf
  
let read_whole_chan chan =
  let buf = Buffer.create 4096 in
  try
    while true do
      let line = input_line chan in
        Buffer.add_string buf line;
        Buffer.add_char buf '\n'
    done;
    assert false (* This is never executed
	                (always raises Assert_failure). *)
  with
    End_of_file -&gt; Buffer.contents buf
  
let read_whole_file filename =
  let chan = open_in filename in
    read_whole_chan chan
  
let main () =
  let filename = Sys.argv.(1) in
  let str = read_whole_file filename in
    printf &quot;I read %d characters from %s\n&quot; (String.length str) filename
</code></pre>
<p>The key to approach 2 is to look at the central while loop. Remember
that I said the only way to break out of a while loop early was with an
exception? This is exactly what we're doing here. Although I haven't
covered exceptions yet, you probably won't have any trouble
understanding the <code>End_of_file</code> exception thrown in the code above by
<code>input_line</code> when it hits the end of the file. The buffer <code>buf</code>
accumulates the contents of the file, and when we hit the end of the
file we return it (<code>Buffer.contents buf</code>).</p>
<p>One curious point about this is the apparently superfluous statement
(<code>assert false</code>) just after the while loop. What is it for?  Remember
that while loops, like for loops, are just expressions, and they return
the <code>unit</code> object (<code>()</code>). However OCaml demands that the return type
inside a <code>try</code> matches the return type of each caught exception. In this
case because <code>End_of_file</code> results in a <code>string</code>, the main body of the
<code>try</code> must also &quot;return&quot; a string  even though because of the infinite
while loop the string could never actually be returned.  <code>assert false</code>
has a polymorphic type, so will unify with whatever value is returned
by the <code>with</code> branch.</p>
<p>Here's our recursive version. Notice that it's <em>shorter</em> than approach
2, but not so easy to understand for imperative programmers at least:</p>
<pre><code class="language-ocaml">(* Read whole file: Approach 3 *)
open Printf
  
let read_whole_chan chan =
  let buf = Buffer.create 4096 in
  let rec loop () =
    let line = input_line chan in
      Buffer.add_string buf line;
      Buffer.add_char buf '\n';
      loop ()
  in
    try loop () with
      End_of_file -&gt; Buffer.contents buf
  
let read_whole_file filename =
  let chan = open_in filename in
    read_whole_chan chan
  
let main () =
  let filename = Sys.argv.(1) in
  let str = read_whole_file filename in
  printf &quot;I read %d characters from %s\n&quot; (String.length str) filename
</code></pre>
<p>Again we have an infinite loop - but in this case done using recursion.
<code>loop</code> calls itself at the end of the function. The infinite recursion
is broken when <code>input_line</code> throws an <code>End_of_file</code> exception.</p>
<p>It looks like approach 3 might overflow the stack if you gave it a
particularly large file, but this is in fact not the case. Because of
tail recursion (discussed below) the compiler will turn the recursive
<code>loop</code> function into a real while loop (!) which runs in constant stack
space.</p>
<p>In the next example we will show how recursion is great for constructing
or examining certain types of data structures, particularly trees. Let's
have a recursive type to represent files in a filesystem:</p>
<pre><code class="language-ocaml"># type filesystem = File of string | Directory of filesystem list
type filesystem = File of string | Directory of filesystem list
</code></pre>
<p>The <code>opendir</code> and <code>readdir</code> functions are used to open a directory and
read elements from the directory. I'm going to define a handy
<code>readdir_no_ex</code> function which hides the annoying <code>End_of_file</code>
exception that <code>readdir</code> throws when it reaches the end of the
directory:</p>
<pre><code class="language-ocaml"># #load &quot;unix.cma&quot;
# open Unix
# let readdir_no_ex dirh =
  try
    Some (readdir dirh)
  with
    End_of_file -&gt; None
val readdir_no_ex : dir_handle -&gt; string option = &lt;fun&gt;
</code></pre>
<p>The type of <code>readdir_no_ex</code> is this. Recall our earlier discussion about
null pointers.</p>
<pre><code class="language-ocaml"># readdir_no_ex
- : dir_handle -&gt; string option = &lt;fun&gt;
</code></pre>
<p>I'm also going to define a simple recursive function which I can use to
convert the <code>filesystem</code> type into a string for (eg) printing:</p>
<pre><code class="language-ocaml"># let rec string_of_filesystem fs =
  match fs with
  | File filename -&gt; filename ^ &quot;\n&quot;
  | Directory fs_list -&gt;
      List.fold_left (^) &quot;&quot; (List.map string_of_filesystem fs_list)
val string_of_filesystem : filesystem -&gt; string = &lt;fun&gt;
</code></pre>
<p>Note the use of <code>fold_left</code> and <code>map</code>. The <code>map</code> is used to
(recursively) convert each <code>filesystem</code> in the list into a <code>string</code>.
Then the <code>fold_left (^) &quot;&quot;</code> concatenates the list together into one big
string. Notice also the use of pattern matching. (The library defines a
function called <code>String.concat</code> which is essentially equivalent to
<code>fold_left (^) </code>, but implemented more efficiently).</p>
<p>Now let's define a function to read a directory structure, recursively,
and return a recursive <code>filesystem</code> data structure. I'm going to show
this function in steps, but I'll print out the entire function at the
end of this section. First the outline of the function:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">let rec read_directory path =
  let dirh = opendir path in
  let rec loop () =
    (* ..... *) in
  Directory (loop ())
</code></pre>
<p>The call to <code>opendir</code> opens up the given path and returns a <code>dir_handle</code>
from which we will be able to read the names using <code>readdir_no_ex</code>
later. The return value of the function is going to be a
<code>Directory fs_list</code>, so all we need to do to complete the function is to
write our function <code>loop</code> which returns a list of <code>filesystem</code>s. The
type of <code>loop</code> will be:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">loop : unit -&gt; filesystem list
</code></pre>
<p>How do we define loop? Let's take it in steps again.</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">let rec loop () =
  let filename = readdir_no_ex dirh in
  (* ..... *)
</code></pre>
<p>First we read the next filename from the directory handle. <code>filename</code>
has type <code>string option</code>, in other words it could be <code>None</code> or
<code>Some &quot;foo&quot;</code> where <code>foo</code> is the name of the next filename in the
directory. We also need to ignore the <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> files (ie. the
current directory and the parent directory). We can do all this with a
nice pattern match:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">let rec loop () =
  let filename = readdir_no_ex dirh in
    match filename with
    | None -&gt; []
    | Some &quot;.&quot; -&gt; loop ()
    | Some &quot;..&quot; -&gt; loop ()
    | Some filename -&gt;
        (* ..... *)
</code></pre>
<p>The <code>None</code> case is easy. Thinking recursively (!) if <code>loop</code> is called
and we've reached the end of the directory, <code>loop</code> needs to return a
list of entries - and there's no entries - so it returns the empty list
(<code>[]</code>).</p>
<p>For <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> we just ignore the file and call <code>loop</code> again.</p>
<p>What do we do when <code>loop</code> reads a real filename (the <code>Some filename</code>
match below)? Let <code>pathname</code> be the full path to the file. We 'stat' the
file to see if it's really a directory. If it <em>is</em> a directory, we set
<code>this</code> by recursively calling <code>read_directory</code> which will return
<code>Directory something</code>. Notice that the overall result of
<code>read_directory</code> is <code>Directory (loop ())</code>. If the file is really a file
(not a directory) then we let <code>this</code> be <code>File pathname</code>. Then we do
something clever: we return <code>this :: loop ()</code>. This is the recursive
call to <code>loop ()</code> to calculate the remaining directory members (a list),
to which we prepend <code>this</code>.</p>
<pre><code class="language-ocaml"># let rec read_directory path =
  let dirh = opendir path in
  let rec loop () =
    let filename = readdir_no_ex dirh in
      match filename with
      | None -&gt; []
      | Some &quot;.&quot; -&gt; loop ()
      | Some &quot;..&quot; -&gt; loop ()
      | Some filename -&gt;
          let pathname = path ^ &quot;/&quot; ^ filename in
          let stat = lstat pathname in
          let this =
            if stat.st_kind = S_DIR then
              read_directory pathname
            else
              File pathname
          in
            this :: loop ()
  in
    Directory (loop ())
val read_directory : string -&gt; filesystem = &lt;fun&gt;
</code></pre>
<p>That's quite a complex bit of recursion, but although this is a made-up
example, it's fairly typical of the complex patterns of recursion found
in real-world functional programs. The two important lessons to take
away from this are:</p>
<ul>
<li>
<p>The use of recursion to build a list:</p>
  <!-- $MDX skip -->
  ```ocaml
  let rec loop () =
    a match or if statement
    | base case -> []
    | recursive case -> element :: loop ()
  ```
  Compare this to our previous `range` function. The pattern of recursion
  is exactly the same:
    
  ```ocaml
  # let rec range a b =
    if a > b then []            (* Base case *)
    else a :: range (a + 1) b     (* Recursive case *)
  ```
	
</li>
<li>
<p>The use of recursion to build up trees:</p>
  <!-- $MDX skip -->
  ```ocaml
  let rec read_directory path =
    (* blah blah *)
    if file-is-a-directory then
      read_directory path-to-file
    else
      Leaf file
  ```
  All that remains now to make this a working program is a little bit of
  code to call `read_directory` and display the result:
    
  <!-- $MDX skip -->
  ```ocaml
  let path = Sys.argv.(1) in
  let fs = read_directory path in
  print_endline (string_of_filesystem fs)
  ```

</li>
</ul>
<h3 id="recursion-example-maximum-element-in-a-list">Recursion example: maximum element in a list</h3>
<p>Remember the basic recursion pattern for lists:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">let rec loop () =
  a match or if statement
  | base case -&gt; []
  | recursive case -&gt; element :: loop ()
</code></pre>
<p>The key here is actually the use of the match / base case / recursive
case pattern. In this example - finding the maximum element in a list -
we're going to have two base cases and one recursive case. But before I
jump ahead to the code, let's just step back and think about the
problem. By thinking about the problem, the solution will appear &quot;as if
by magic&quot; (I promise you :-)</p>
<p>First of all, let's be clear that the maximum element of a list is just
the biggest one, e.g. the maximum element of the list <code>[1; 2; 3; 4; 1]</code>
is <code>4</code>.</p>
<p>Are there any special cases? Yes, there are. What's the maximum element
of the empty list <code>[]</code>? There <em>isn't one</em>. If we are passed an empty
list, we should throw an error.</p>
<p>What's the maximum element of a single element list such as <code>[4]</code>?
That's easy: it's just the element itself. So <code>list_max [4]</code> should
return <code>4</code>, or in the general case, <code>list_max [x]</code> should return <code>x</code>.</p>
<p>What's the maximum element of the general list <code>x :: remainder</code> (this is
the &quot;cons&quot; notation for the list, so <code>remainder</code> is the tail - also a
list)?</p>
<p>Think about this for a while. Suppose you know the maximum element of
<code>remainder</code>, which is, say, <code>y</code>. What's the maximum element of
<code>x :: remainder</code>? It depends on whether <code>x &gt; y</code> or <code>x &lt;= y</code>. If <code>x</code> is
bigger than <code>y</code>, then the overall maximum is <code>x</code>, whereas conversely if
<code>x</code> is less than <code>y</code>, then the overall maximum is <code>y</code>.</p>
<p>Does this really work? Consider <code>[1; 2; 3; 4; 1]</code> again. This is
<code>1 :: [2; 3; 4; 1]</code>. Now the maximum element of the remainder,
<code>[2; 3; 4; 1]</code>, is <code>4</code>. So now we're interested in <code>x = 1</code> and <code>y = 4</code>.
That head element <code>x = 1</code> doesn't matter because <code>y = 4</code> is bigger, so
the overall maximum of the whole list is <code>y = 4</code>.</p>
<p>Let's now code those rules above up, to get a working function:</p>
<pre><code class="language-ocaml"># let rec list_max xs =
  match xs with
  | [] -&gt; (* empty list: fail *)
      failwith &quot;list_max called on empty list&quot;
  | [x] -&gt; (* single element list: return the element *)
      x
  | x :: remainder -&gt; (* multiple element list: recursive case *)
      max x (list_max remainder)
val list_max : 'a list -&gt; 'a = &lt;fun&gt;
</code></pre>
<p>I've added comments so you can see how the rules / special cases we
decided upon above really correspond to lines of code.</p>
<p>Does it work?</p>
<pre><code class="language-ocaml"># list_max [1; 2; 3; 4; 1]
- : int = 4
# list_max []
Exception: Failure &quot;list_max called on empty list&quot;.
# list_max [5; 4; 3; 2; 1]
- : int = 5
# list_max [5; 4; 3; 2; 1; 100]
- : int = 100
</code></pre>
<p>Notice how the solution proposed is both (a) very different from the
imperative for-loop solution, and (b) much more closely tied to the
problem specification. Functional programmers will tell you that this is
because the functional style is much higher level than the imperative
style, and therefore better and simpler. Whether you believe them is up
to you. It's certainly true that it's much simpler to reason logically
about the functional version, which is useful if you wanted to formally
prove that <code>list_max</code> is correct (&quot;correct&quot; being the mathematical way
to say that a program is provably bug-free, useful for space shuttles,
nuclear power plants and higher quality software in general).</p>
<h3 id="tail-recursion">Tail recursion</h3>
<p>Let's look at the <code>range</code> function again for about the twentieth time:</p>
<pre><code class="language-ocaml"># let rec range a b =
  if a &gt; b then []
  else a :: range (a+1) b
val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</code></pre>
<p>I'm going to rewrite it slightly to make something about the structure
of the program clearer (still the same function however):</p>
<pre><code class="language-ocaml"># let rec range a b =
  if a &gt; b then [] else
    let result = range (a+1) b in
      a :: result
val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</code></pre>
<p>Let's call it:</p>
<pre><code class="language-ocaml"># List.length (range 1 10)
- : int = 10
# List.length (range 1 1000000)
Stack overflow during evaluation (looping recursion?).
</code></pre>
<p>Hmmm ... at first sight this looks like a problem with recursive
programming, and hence with the whole of functional programming! If you
write your code recursively instead of iteratively then you necessarily
run out of stack space on large inputs, right?</p>
<p>In fact, wrong. Compilers can perform a simple optimisation on certain
types of recursive functions to turn them into while loops. These
certain types of recursive functions therefore run in constant stack
space, and with the equivalent efficiency of imperative while loops.
These functions are called <strong>tail-recursive functions</strong>.</p>
<p>In tail-recursive functions, the recursive call happens last of all.
Remember our <code>loop ()</code> functions above? They all had the form:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">let rec loop () =
  (* do something *)
  loop ()
</code></pre>
<p>Because the recursive call to <code>loop ()</code> happens as the very last thing,
<code>loop</code> is tail-recursive and the compiler will turn the whole thing into
a while loop.</p>
<p>Unfortunately <code>range</code> is not tail-recursive, and the longer version
above shows why. The recursive call to <code>range</code> doesn't happen as the
very last thing. In fact the last thing to happen is the <code>::</code> (cons)
operation. As a result, the compiler doesn't turn the recursion into a
while loop, and the function is not efficient in its use of stack space.</p>
<p>The use of an accumulating argument or <code>accumulator</code> allows one to write
functions such as <code>range</code> above in a tail-recursive manner, which means they
will be efficient and work properly on large inputs. Let's plan our rewritten
<code>range</code> function which will use an accumulator argument to store the &quot;result so
far&quot;:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">let rec range2 a b accum =
  (* ... *)
  
let range a b =
  range2 a b []
</code></pre>
<p>The <code>accum</code> argument is going to accumulate the result. It's the &quot;result
so far&quot;. We pass in the empty list (&quot;no result so far&quot;). The easy case
is when <code>a &gt; b</code>:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">let rec range2 a b accum =
  if a &gt; b then accum
  else
    (* ... *)
</code></pre>
<p>If <code>a &gt; b</code> (i.e. if we've reached the end of the recursion), then stop
and return the result (<code>accum</code>).</p>
<p>Now the trick is to write the <code>else</code>-clause and make sure that the call
to <code>range2</code> is the very last thing that we do, so the function is
tail-recursive:</p>
<pre><code class="language-ocaml"># let rec range2 a b accum =
  if a &gt; b then accum
  else range2 (a + 1) b (a :: accum)
val range2 : int -&gt; int -&gt; int list -&gt; int list = &lt;fun&gt;
</code></pre>
<p>There's only one slight problem with this function: it constructs the
list backwards! However, this is easy to rectify by redefining range as:</p>
<pre><code class="language-ocaml"># let range a b = List.rev (range2 a b [])
val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</code></pre>
<p>It works this time, although it's a bit slow to run because it really
does have to construct a list with a million elements in it:</p>
<pre><code class="language-ocaml"># List.length (range 1 1000000)
- : int = 1000000
</code></pre>
<p>The following implementation is twice as fast as the previous one,
because it does not need to reverse a list:</p>
<pre><code class="language-ocaml"># let rec range2 a b accum =
  if b &lt; a then accum
  else range2 a (b - 1) (b :: accum)
val range2 : int -&gt; int -&gt; int list -&gt; int list = &lt;fun&gt;
# let range a b =
  range2 a b []
val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</code></pre>
<p>That was a brief overview of tail recursion, but in real world
situations determining if a function is tail recursive can be quite
hard. What did we really learn here? One thing is that recursive
functions have a dangerous trap for inexperienced programmers. Your
function can appear to work for small inputs (during testing), but fail
catastrophically in the field when exposed to large inputs. This is one
argument <em>against</em> using recursive functions, and for using explicit
while loops when possible.</p>
<h2 id="mutable-records-references-again-and-arrays">Mutable records, references (again!) and arrays</h2>
<p>Previously we mentioned records in passing. These are like C <code>struct</code>s:</p>
<pre><code class="language-ocaml"># type pair_of_ints = {a : int; b : int}
type pair_of_ints = { a : int; b : int; }
# {a = 3; b = 5}
- : pair_of_ints = {a = 3; b = 5}
# {a = 3}
Line 1, characters 1-8:
Error: Some record fields are undefined: b
</code></pre>
<p>One feature which I didn't cover: OCaml records can have mutable fields.
Normally an expression like <code>{a = 3; b = 5}</code> is an immutable, constant
object. However if the record has <strong>mutable fields</strong>, then
there is a way to change those fields in the record. This is an
imperative feature of OCaml, because functional languages don't normally
allow mutable objects (or references or mutable arrays, which we'll look
at in a moment).</p>
<p>Here is an object defined with a mutable field. This field is used to
count how many times the object has been accessed. You could imagine
this being used in a caching scheme to decide which objects you'd evict
from memory.</p>
<pre><code class="language-ocaml"># type name = {name : string; mutable access_count : int}
type name = { name : string; mutable access_count : int; }
</code></pre>
<p>Here is a function defined on names which prints the <code>name</code> field and
increments the mutable <code>access_count</code> field:</p>
<pre><code class="language-ocaml"># let print_name name =
  print_endline (&quot;The name is &quot; ^ name.name);
  name.access_count &lt;- name.access_count + 1
val print_name : name -&gt; unit = &lt;fun&gt;
</code></pre>
<p>Notice a strange, and very non-functional feature of <code>print_name</code>: it modifies
its <code>access_count</code> parameter. This function is not &quot;pure&quot;. OCaml is a
functional language, but not to the extent that it forces functional
programming down your throat.</p>
<p>Anyway, let's see <code>print_name</code> in action:</p>
<pre><code class="language-ocaml"># let n = {name = &quot;Richard Jones&quot;; access_count = 0}
val n : name = {name = &quot;Richard Jones&quot;; access_count = 0}
# n
- : name = {name = &quot;Richard Jones&quot;; access_count = 0}
# print_name n
The name is Richard Jones
- : unit = ()
# n
- : name = {name = &quot;Richard Jones&quot;; access_count = 1}
# print_name n
The name is Richard Jones
- : unit = ()
# n
- : name = {name = &quot;Richard Jones&quot;; access_count = 2}
</code></pre>
<p>Only fields explicitly marked as <code>mutable</code> can be assigned to using the
<code>&lt;-</code> operator. If you try to assign to a non-mutable field, OCaml won't
let you:</p>
<pre><code class="language-ocaml"># n.name &lt;- &quot;John Smith&quot;
Line 1, characters 1-23:
Error: The record field name is not mutable
</code></pre>
<p>References, with which we should be familiar by now, are implemented
using records with a mutable <code>contents</code> field. Check out the definition
in <code>Stdlib</code>:</p>
<pre><code class="language-ocaml">type 'a ref = {mutable contents : 'a}
</code></pre>
<p>And look closely at what the OCaml toplevel prints out for the value of
a reference:</p>
<pre><code class="language-ocaml"># let r = ref 100
val r : int Stdlib.ref = {Stdlib.contents = 100}
</code></pre>
<p>Arrays are another sort of mutable structure provided by OCaml. In
OCaml, plain lists are implemented as linked lists, and linked lists are
slow for some types of operation. For example, getting the head of a
list, or iterating over a list to perform some operation on each element
is reasonably fast. However, jumping to the n<sup>th</sup> element of a
list, or trying to randomly access a list - both are slow operations.
The OCaml <code>Array</code> type is a real array, so random access is fast, but
insertion and deletion of elements is slow. <code>Array</code>s are also mutable so
you can randomly change elements too.</p>
<p>The basics of arrays are simple:</p>
<pre><code class="language-ocaml"># let a = Array.create 10 0
Line 1, characters 9-21:
Alert deprecated: Stdlib.Array.create
Use Array.make instead.
val a : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]
# for i = 0 to Array.length a - 1 do
  a.(i) &lt;- i
Line 3, characters 1-3:
Error: Syntax error
# a
- : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]
</code></pre>
<p>Notice the syntax for writing arrays: <code>[| element; element; ... |]</code></p>
<p>The OCaml compiler was designed with heavy numerical processing in mind
(the sort of thing that FORTRAN is traditionally used for), and so it
contains various optimisations specifically for arrays of numbers,
vectors and matrices. Here is some benchmark code for doing dense matrix
multiplication. Notice that it uses for-loops and is generally very
imperative in style:</p>
<pre><code class="language-ocaml"># let size = 30
val size : int = 30

# let mkmatrix rows cols =
  let count = ref 1
  and last_col = cols - 1
  and m = Array.make_matrix rows cols 0 in
    for i = 0 to rows - 1 do
      let mi = m.(i) in
        for j = 0 to last_col do
          mi.(j) &lt;- !count;
          incr count
        done;
    done;
    m
val mkmatrix : int -&gt; int -&gt; int array array = &lt;fun&gt;

# let rec inner_loop k v m1i m2 j =
  if k &lt; 0 then v
  else inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j
val inner_loop : int -&gt; int -&gt; int array -&gt; int array array -&gt; int -&gt; int =
  &lt;fun&gt;

# let mmult rows cols m1 m2 m3 =
  let last_col = cols - 1
  and last_row = rows - 1 in
    for i = 0 to last_row do
      let m1i = m1.(i) and m3i = m3.(i) in
      for j = 0 to last_col do
        m3i.(j) &lt;- inner_loop last_row 0 m1i m2 j
      done;
    done
val mmult :
  int -&gt; int -&gt; int array array -&gt; int array array -&gt; int array array -&gt; unit =
  &lt;fun&gt;

# let () =
  let n =
    try int_of_string Sys.argv.(1)
    with Invalid_argument _ -&gt; 1
  and m1 = mkmatrix size size
  and m2 = mkmatrix size size
  and m3 = Array.make_matrix size size 0 in
    for i = 1 to n - 1 do
      mmult size size m1 m2 m3
    done;
    mmult size size m1 m2 m3;
    Printf.printf &quot;%d %d %d %d\n&quot; m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)
Exception: Failure &quot;int_of_string&quot;.
</code></pre>
<h2 id="mutually-recursive-functions">Mutually recursive functions</h2>
<p>Suppose I want to define two functions which call each other. This is
actually not a very common thing to do, but it can be useful sometimes.
Here's a contrived example (thanks to Ryan Tarpine): The number 0 is
even. Other numbers greater than 0 are even if their predecessor is odd.
Hence:</p>
<pre><code class="language-ocaml"># let rec even n =
  match n with
  | 0 -&gt; true
  | x -&gt; odd (x - 1)
Line 4, characters 10-13:
Error: Unbound value odd
</code></pre>
<p>The code above doesn't compile because we haven't defined the function
<code>odd</code> yet! That's easy though. Zero is not odd, and other numbers
greater than 0 are odd if their predecessor is even. So to make this
complete we need that function too:</p>
<pre><code class="language-ocaml"># let rec even n =
  match n with
  | 0 -&gt; true
  | x -&gt; odd (x - 1)
Line 4, characters 10-13:
Error: Unbound value odd
# let rec odd n =
  match n with
  | 0 -&gt; false
  | x -&gt; even (x - 1)
Line 4, characters 10-14:
Error: Unbound value even
</code></pre>
<p>The only problem is... this program doesn't compile. In order to compile
the <code>even</code> function, we already need the definition of <code>odd</code>, and to
compile <code>odd</code> we need the definition of <code>even</code>. So swapping the two
definitions around won't help either.</p>
<p>There are no &quot;forward prototypes&quot; (as seen in languages descended
from C) in OCaml but there is a special syntax
for defining a set of two or more mutually recursive functions, like
<code>odd</code> and <code>even</code>:</p>
<pre><code class="language-ocaml"># let rec even n =
  match n with
  | 0 -&gt; true
  | x -&gt; odd (x - 1)
Line 4, characters 10-13:
Error: Unbound value odd
</code></pre>
<p>You can also
use similar syntax for writing mutually recursive class definitions and
modules.</p>
</div></div></div></div></div></main><div class="relative"><footer aria-labelledby="footerHeading" class="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8"><h2 class="sr-only" id="footerHeading">Footer</h2><div class="xl:grid xl:grid-cols-3 xl:gap-8"><div class="space-y-8 xl:col-span-1"><img class="h-10" alt="OCaml" src="/static/ocaml-logo.jpeg"/><p class="text-gray-500 text-base ">Innovation. Community. Security.</p><div class="flex space-x-6"><a aria-label="Discourse" class="text-gray-400 hover:text-gray-500" href="https://discuss.ocaml.org" target="_blank"><img aria-hidden="true" class="h-6 w-6" alt="" src="/static/discourselogo.png"/></a><a aria-label="GitHub" class="text-gray-400 hover:text-gray-500" href="https://sourcegraph.com/search?q=repo:ocaml/ocaml%24+or+repo:janestreet/base+or+repo:gitlab.com/tezos/tezos%24+or+repo:c-cube/ocaml-containers+or+repo:ocaml-batteries-team/batteries-included+or+repo:mirage/mirage%24+or+repo:ocsigen/lwt+or+repo:janestreet/async%24&amp;patternType=literal" target="_blank"><svg aria-hidden="true" class="h-6 w-6" fill="currentColor" viewBox="0 0 24 24"><path clip-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" fill-rule="evenodd"></path></svg></a><a aria-label="Twitter" class="text-gray-400 hover:text-gray-500" href="https://fosstodon.org/tags/ocaml" target="_blank"><svg aria-hidden="true" class="h-6 w-6" fill="currentColor" viewBox="0 0 24 24"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg></a></div></div><div class="grid grid-cols-2 gap-8 mt-12 xl:mt-0 xl:col-span-2"><div class="md:grid md:grid-cols-2 md:gap-8"><div class=""><h3 class="text-sm font-semibold text-gray-400 tracking-wider uppercase">Principles</h3><ul class="mt-4 space-y-4"><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/principles/whatisocaml/">Why OCaml</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/principles/users/">Industrial Users</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/principles/academic/">Academic Excellence</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/principles/successes/">Success Stories</a></li></ul></div><div class="mt-12 md:mt-0"><h3 class="text-sm font-semibold text-gray-400 tracking-wider uppercase">Resources</h3><ul class="mt-4 space-y-4"><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/resources/language/">Language</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/packages/">Packages</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/resources/applications/">Applications</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/resources/bestpractices/">Best Practices</a></li></ul></div></div><div class="md:grid md:grid-cols-2 md:gap-8"><div class=""><h3 class="text-sm font-semibold text-gray-400 tracking-wider uppercase">Community</h3><ul class="mt-4 space-y-4"><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/community/opportunities/">Opportunities</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/community/blog/">News</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/community/aroundweb/">Around the Web</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/resources/archive/">Archive</a></li></ul></div><div class="mt-12 md:mt-0"><h3 class="text-sm font-semibold text-gray-400 tracking-wider uppercase">Legal</h3><ul class="mt-4 space-y-4"><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/legal/privacy/">Privacy</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/legal/terms/">Terms</a></li><li><a class="text-base text-gray-500 hover:text-gray-900" href="/en/legal/carbonfootprint/">Carbon Footprint</a></li></ul></div></div></div></div><p class="text-gray-500 text-base mt-10">Thank you to our <a class="text-orangedark underline" href="/en/legal/carbonfootprint/#hostingproviders">Hosting Providers</a></p></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"content":{"source":"\u003ch2 id=\"if-statements-actually-these-are-if-expressions\"\u003eIf statements (actually, these are if expressions)\u003c/h2\u003e\n\u003cp\u003eOCaml has an \u003ccode\u003eif\u003c/code\u003e statement with two variations, and the obvious meaning:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif boolean-condition then expression\n  \nif boolean-condition then expression else other-expression\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-mdx-error\"\u003eLine 3, characters 3-5:\nError: Syntax error\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnlike in the conventional languages you'll be used to, \u003ccode\u003eif\u003c/code\u003e statements\nare really expressions. In other words, they're much more like\n\u003ccode\u003eboolean-condition ? expression : other-expression\u003c/code\u003e in C than like the if\nstatements you may be used to.\u003c/p\u003e\n\u003cp\u003eHere's a simple example of an \u003ccode\u003eif\u003c/code\u003e statement:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let max a b =\n  if a \u0026gt; b then a else b\nval max : 'a -\u0026gt; 'a -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs a short aside, if you type this into the OCaml\ninteractive toplevel (as above), you'll\nnotice that OCaml decides that this function is polymorphic, with the\nfollowing type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# max\n- : 'a -\u0026gt; 'a -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd indeed OCaml lets you use \u003ccode\u003emax\u003c/code\u003e on any type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# max 3 5\n- : int = 5\n# max 3.5 13.0\n- : float = 13.\n# max \u0026quot;a\u0026quot; \u0026quot;b\u0026quot;\n- : string = \u0026quot;b\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is because \u003ccode\u003e\u0026gt;\u003c/code\u003e is in fact polymorphic. It works on any type, even\nobjects (it does a binary comparison).\u003c/p\u003e\n\u003cp\u003e[Note that the \u003ccode\u003eStdlib\u003c/code\u003e module defines \u003ccode\u003emin\u003c/code\u003e and \u003ccode\u003emax\u003c/code\u003e for you.]\u003c/p\u003e\n\u003cp\u003eLet's look a bit more closely at the \u003ccode\u003eif\u003c/code\u003e expression. Here's the \u003ccode\u003erange\u003c/code\u003e\nfunction which I showed you earlier without much explanation. You should\nbe able to combine your knowledge of recursive functions, lists and if\nexpressions to see what it does:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range a b =\n    if a \u0026gt; b then []\n    else a :: range (a + 1) b\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's examine some typical calls to this function. Let's start with the\neasy case of \u003ccode\u003ea \u0026gt; b\u003c/code\u003e. A call to \u003ccode\u003erange 11 10\u003c/code\u003e returns \u003ccode\u003e[]\u003c/code\u003e (the empty\nlist) and that's it.\u003c/p\u003e\n\u003cp\u003eWhat about calling \u003ccode\u003erange 10 10\u003c/code\u003e? Since \u003ccode\u003e10 \u0026gt; 10\u003c/code\u003e is false, the\n\u003ccode\u003eelse\u003c/code\u003e-clause is evaluated, which is: \u003ccode\u003e10 :: (range 11 10)\u003c/code\u003e (I've added\nthe brackets to make the order of evaluation more clear). We've just\nworked out that \u003ccode\u003erange 11 10\u003c/code\u003e = \u003ccode\u003e[]\u003c/code\u003e, so this is: \u003ccode\u003e10 :: []\u003c/code\u003e. Remember\nour formal description of lists and the \u003ccode\u003e::\u003c/code\u003e (cons) operator? \u003ccode\u003e10 :: []\u003c/code\u003e\nis just the same as \u003ccode\u003e[10]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLet's try \u003ccode\u003erange 9 10\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003erange 9 10\n 9 :: (range 10 10)\n 9 :: [10]\n [9; 10]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt should be fairly clear that \u003ccode\u003erange 1 10\u003c/code\u003e evaluates to\n\u003ccode\u003e[1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhat we've got here is a simple case of recursion. Functional\nprogramming can be said to prefer recursion over loops, but I'm jumping\nahead of myself. We'll discuss recursion more at the end of this\nchapter.\u003c/p\u003e\n\u003cp\u003eBack, temporarily, to \u003ccode\u003eif\u003c/code\u003e statements. What does this function do?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let f x y =\n    x + if y \u0026gt; 0 then y else 0\nval f : int -\u0026gt; int -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eClue: add brackets around the whole of the if expression. It clips \u003ccode\u003ey\u003c/code\u003e\nlike an \u003ca href=\"https://en.wikipedia.org/wiki/Diode#Current.E2.80.93voltage_characteristic\"\u003eelectronic diode\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eabs\u003c/code\u003e (absolute value) function is defined in \u003ccode\u003eStdlib\u003c/code\u003e as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let abs x =\n    if x \u0026gt;= 0 then x else -x\nval abs : int -\u0026gt; int = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlso in \u003ccode\u003eStdlib\u003c/code\u003e, the \u003ccode\u003estring_of_float\u003c/code\u003e function contains a complex\npair of nested \u003ccode\u003eif\u003c/code\u003e expressions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let string_of_float f =\n  let s = format_float \u0026quot;%.12g\u0026quot; f in\n  let l = string_length s in\n  let rec loop i =\n    if i \u0026gt;= l then s ^ \u0026quot;.\u0026quot;\n    else if s.[i] = '.' || s.[i] = 'e' then s\n    else loop (i + 1)\n  in\n    loop 0\nLine 2, characters 11-23:\nError: Unbound value format_float\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's examine this function. Suppose the function is called with \u003ccode\u003ef\u003c/code\u003e =\n12.34. Then \u003ccode\u003es\u003c/code\u003e = \u0026quot;12.34\u0026quot;, and \u003ccode\u003el\u003c/code\u003e = 5. We call \u003ccode\u003eloop\u003c/code\u003e the first time\nwith \u003ccode\u003ei\u003c/code\u003e = 0.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ei\u003c/code\u003e is not greater than or equal to \u003ccode\u003el\u003c/code\u003e, and \u003ccode\u003es.[i]\u003c/code\u003e (the\n\u003ccode\u003ei\u003c/code\u003e\u003csup\u003eth\u003c/sup\u003e character in \u003ccode\u003es\u003c/code\u003e) is not a period or \u003ccode\u003e'e'\u003c/code\u003e. So\n\u003ccode\u003eloop (i + 1)\u003c/code\u003e is called, ie. \u003ccode\u003eloop 1\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe go through the same dance for \u003ccode\u003ei\u003c/code\u003e = 1, and end up calling \u003ccode\u003eloop 2\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor \u003ccode\u003ei\u003c/code\u003e = 2, however, \u003ccode\u003es.[i]\u003c/code\u003e is a period (refer to the original string,\n\u003ccode\u003es\u003c/code\u003e = \u0026quot;12.34\u0026quot;). So this immediately returns \u003ccode\u003es\u003c/code\u003e, and the function\n\u003ccode\u003estring_of_float\u003c/code\u003e returns \u0026quot;12.34\u0026quot;.\u003c/p\u003e\n\u003cp\u003eWhat is \u003ccode\u003eloop\u003c/code\u003e doing? In fact it's checking whether the string returned\nfrom \u003ccode\u003eformat_float\u003c/code\u003e contains a period (or \u003ccode\u003e'e'\u003c/code\u003e). Suppose that we called\n\u003ccode\u003estring_of_float\u003c/code\u003e with \u003ccode\u003e12.0\u003c/code\u003e. \u003ccode\u003eformat_float\u003c/code\u003e would return the string\n\u0026quot;12\u0026quot;, but \u003ccode\u003estring_of_float\u003c/code\u003e must return \u0026quot;12.\u0026quot; or \u0026quot;12.0\u0026quot; (because\nfloating point constants in OCaml must contain a period to differentiate\nthem from integer constants). Hence the check.\u003c/p\u003e\n\u003cp\u003eThe strange use of recursion in this function is almost certainly for\nefficiency. OCaml supports for loops, so why didn't the authors use for\nloops? We'll see in the next section that OCaml's for loops are limited\nin a way which prevents them from being used in \u003ccode\u003estring_of_float\u003c/code\u003e. Here,\nhowever, is a more straightforward, but approximately twice as slow, way\nof writing \u003ccode\u003estring_of_float\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let string_of_float f =\n  let s = format_float \u0026quot;%.12g\u0026quot; f in\n    if String.contains s '.' || String.contains s 'e'\n      then s\n      else s ^ \u0026quot;.\u0026quot;\nLine 2, characters 11-23:\nError: Unbound value format_float\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"using-begin--end\"\u003eUsing begin ... end\u003c/h2\u003e\n\u003cp\u003eHere is some code from lablgtk:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif GtkBase.Object.is_a obj cls then\n  fun _ -\u0026gt; f obj\nelse begin\n  eprintf \u0026quot;Glade-warning: %s expects a %s argument.\\n\u0026quot; name cls;\n  raise Not_found\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebegin\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e are what is known as \u003cstrong\u003esyntactic sugar\u003c/strong\u003e for open and\nclose parentheses. In the example above, all they do is group the two\nstatements in the \u003ccode\u003eelse\u003c/code\u003e-clause together. Suppose the author had written\nthis instead:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eif GtkBase.Object.is_a obj cls then\n  fun _ -\u0026gt; f obj\nelse\n  eprintf \u0026quot;Glade-warning: %s expects a %s argument.\\n\u0026quot; name cls;\n  raise Not_found\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFully bracketing and properly indenting the above expression gives:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(if GtkBase.Object.is_a obj cls then\n   fun _ -\u0026gt; f obj\n else\n   eprintf \u0026quot;Glade-warning: %s expects a %s argument.\\n\u0026quot; name cls\n);\nraise Not_found\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNot what was intended at all. So the \u003ccode\u003ebegin\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e are necessary to\ngroup together multiple statements in a \u003ccode\u003ethen\u003c/code\u003e or \u003ccode\u003eelse\u003c/code\u003e clause of an if\nexpression. You can also use plain ordinary parentheses \u003ccode\u003e( ... )\u003c/code\u003e if you\nprefer (and I do prefer, because I \u003cstrong\u003eloathe\u003c/strong\u003e Pascal :-). Here are two\nsimple examples:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# if 1 = 0 then\n    print_endline \u0026quot;THEN\u0026quot;\n  else begin\n    print_endline \u0026quot;ELSE\u0026quot;;\n    failwith \u0026quot;else clause\u0026quot;\n  end\nException: Failure \u0026quot;else clause\u0026quot;.\nELSE\n# if 1 = 0 then\n    print_endline \u0026quot;THEN\u0026quot;\n  else (\n    print_endline \u0026quot;ELSE\u0026quot;;\n    failwith \u0026quot;else clause\u0026quot;\n  )\nException: Failure \u0026quot;else clause\u0026quot;.\nELSE\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"for-loops-and-while-loops\"\u003eFor loops and while loops\u003c/h2\u003e\n\u003cp\u003eOCaml supports a rather limited form of the familiar \u003ccode\u003efor\u003c/code\u003e loop:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003efor variable = start_value to end_value do\n  expression\ndone\n  \nfor variable = start_value downto end_value do\n  expression\ndone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA simple but real example from lablgtk:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003efor i = 1 to n_jobs () do\n  do_next_job ()\ndone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn OCaml, \u003ccode\u003efor\u003c/code\u003e loops are just shorthand for writing:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet i = 1 in\ndo_next_job ();\nlet i = 2 in\ndo_next_job ();\nlet i = 3 in\ndo_next_job ();\n  ...\nlet i = n_jobs () in\ndo_next_job ();\n()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOCaml doesn't support the concept of breaking out of a \u003ccode\u003efor\u003c/code\u003e loop early\ni.e. it has no \u003ccode\u003ebreak\u003c/code\u003e, \u003ccode\u003econtinue\u003c/code\u003e or \u003ccode\u003elast\u003c/code\u003e statements. (You \u003cem\u003ecould\u003c/em\u003e\nthrow an exception and catch it outside, and this would run fast but\noften looks clumsy.)\u003c/p\u003e\n\u003cp\u003eThe expression inside an OCaml for loop should evaluate to \u003ccode\u003eunit\u003c/code\u003e\n(otherwise you'll get a warning), and the for loop expression as a whole\nreturns \u003ccode\u003eunit\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# for i = 1 to 10 do i done\nLine 1, characters 20-21:\nWarning 10: this expression should have type unit.\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFunctional programmers tend to use recursion instead of explicit loops,\nand regard \u003cstrong\u003efor\u003c/strong\u003e loops with suspicion since it can't return anything,\nhence OCaml's relatively powerless \u003cstrong\u003efor\u003c/strong\u003e loop. We talk about recursion\nbelow.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhile loops\u003c/strong\u003e in OCaml are written:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003ewhile boolean-condition do\n  expression\ndone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs with for loops, there is no way provided by the language to break out\nof a while loop, except by throwing an exception, and this means that\nwhile loops have fairly limited use. Again, remember that functional\nprogrammers like recursion, and so while loops are second-class citizens\nin the language.\u003c/p\u003e\n\u003cp\u003eIf you stop to consider while loops, you may see that they aren't really\nany use at all, except in conjunction with our old friend references.\nLet's imagine that OCaml didn't have references for a moment:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet quit_loop = false in\n  while not quit_loop do\n    print_string \u0026quot;Have you had enough yet? (y/n) \u0026quot;;\n    let str = read_line () in\n      if str.[0] = 'y' then\n        (* how do I set quit_loop to true ?!? *)\n  done\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRemember that \u003ccode\u003equit_loop\u003c/code\u003e is not a real \u0026quot;variable\u0026quot; - the let-binding\njust makes \u003ccode\u003equit_loop\u003c/code\u003e a shorthand for \u003ccode\u003efalse\u003c/code\u003e. This means the while\nloop condition (shown in red) is always true, and the loop runs on\nforever!\u003c/p\u003e\n\u003cp\u003eLuckily OCaml \u003cem\u003edoes have\u003c/em\u003e references, so we can write the code above if\nwe want. Don't get confused and think that the \u003ccode\u003e!\u003c/code\u003e (exclamation mark)\nmeans \u0026quot;not\u0026quot; as in C/Java. It's used here to mean \u0026quot;dereference the\npointer\u0026quot;, similar in fact to Forth. You're better off reading \u003ccode\u003e!\u003c/code\u003e as\n\u0026quot;get\u0026quot; or \u0026quot;deref\u0026quot;.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet quit_loop = ref false in\n  while not !quit_loop do\n    print_string \u0026quot;Have you had enough yet? (y/n) \u0026quot;;\n    let str = read_line () in\n      if str.[0] = 'y' then quit_loop := true\n  done;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"looping-over-lists\"\u003eLooping over lists\u003c/h2\u003e\n\u003cp\u003eIf you want to loop over a list, don't be an imperative programmer and\nreach for your trusty six-shooter Mr. For Loop! OCaml has some better\nand faster ways to loop over lists, and they are all located in the\n\u003ccode\u003eList\u003c/code\u003e module. There are in fact dozens of good functions in \u003ccode\u003eList\u003c/code\u003e, but\nI'll only talk about the most useful ones here.\u003c/p\u003e\n\u003cp\u003eFirst off, let's define a list for us to use:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let my_list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\nval my_list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you want to call a function once on every element of the list, use\n\u003ccode\u003eList.iter\u003c/code\u003e, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let f elem =\n    Printf.printf \u0026quot;I'm looking at element %d now\\n\u0026quot; elem\n  in\n    List.iter f my_list\nI'm looking at element 1 now\nI'm looking at element 2 now\nI'm looking at element 3 now\nI'm looking at element 4 now\nI'm looking at element 5 now\nI'm looking at element 6 now\nI'm looking at element 7 now\nI'm looking at element 8 now\nI'm looking at element 9 now\nI'm looking at element 10 now\n- : unit = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eList.iter\u003c/code\u003e is in fact what you should think about using first every\ntime your cerebellum suggests you use a for loop.\u003c/p\u003e\n\u003cp\u003eIf you want to \u003cem\u003etransform\u003c/em\u003e each element separately in the list - for\nexample, doubling each element in the list - then use \u003ccode\u003eList.map\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# List.map (( * ) 2) my_list\n- : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe function \u003ccode\u003eList.filter\u003c/code\u003e collects only those elements of a list which satisfy\nsome condition - e.g. returning all even numbers in a list.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let is_even i =\n    i mod 2 = 0\n  in\n    List.filter is_even my_list\n- : int list = [2; 4; 6; 8; 10]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo find out if a list contains some element, use \u003ccode\u003eList.mem\u003c/code\u003e (short for\nmember):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# List.mem 12 my_list\n- : bool = false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eList.for_all\u003c/code\u003e and \u003ccode\u003eList.exists\u003c/code\u003e are the same as the \u0026quot;forall\u0026quot; and\n\u0026quot;exist\u0026quot; operators in predicate logic.\u003c/p\u003e\n\u003cp\u003eFor operating over two lists at the same time, there are \u0026quot;-2\u0026quot; variants\nof some of these functions, namely \u003ccode\u003eiter2\u003c/code\u003e, \u003ccode\u003emap2\u003c/code\u003e, \u003ccode\u003efor_all2\u003c/code\u003e,\n\u003ccode\u003eexists2\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003emap\u003c/code\u003e and \u003ccode\u003efilter\u003c/code\u003e functions operate on individual list elements in\nisolation. \u003cstrong\u003eFold\u003c/strong\u003e is a more unusual operation that is best\nthought about as \u0026quot;inserting an operator between each element of the\nlist\u0026quot;. Suppose I wanted to add all the numbers in my list together. In\nhand-waving terms what I want to do is insert a plus sign between the\nelements in my list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10\n- : int = 55\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe fold operation does this, although the exact details are a little\nbit more tricky. First of all, what happens if I try to fold an empty\nlist? In the case of summing the list it would be nice if the answer was\nzero, instead of error. However if I was trying to find the product of\nthe list, I'd like the answer to be one instead. So I obviously have to\nprovide some sort of \u0026quot;default\u0026quot; argument to my fold. The second issue\ndoesn't arise with simple operators like \u003ccode\u003e+\u003c/code\u003e and \u003ccode\u003e*\u003c/code\u003e: what happens if\nthe operator I'm using isn't associative, ie. (a \u003cem\u003eop\u003c/em\u003e b) \u003cem\u003eop\u003c/em\u003e c not\nequal to a \u003cem\u003eop\u003c/em\u003e (b \u003cem\u003eop\u003c/em\u003e c)? In that case it would matter if I started\nfrom the left hand end of the list and worked right, versus if I started\nfrom the right and worked left. For this reason there are two versions\nof fold, called \u003ccode\u003eList.fold_left\u003c/code\u003e (works left to right) and\n\u003ccode\u003eList.fold_right\u003c/code\u003e (works right to left, and is also less efficient).\u003c/p\u003e\n\u003cp\u003eLet's use \u003ccode\u003eList.fold_left\u003c/code\u003e to define \u003ccode\u003esum\u003c/code\u003e and \u003ccode\u003eproduct\u003c/code\u003e functions for\ninteger lists:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let sum = List.fold_left ( + ) 0\nval sum : int list -\u0026gt; int = \u0026lt;fun\u0026gt;\n# let product = List.fold_left ( * ) 1\nval product : int list -\u0026gt; int = \u0026lt;fun\u0026gt;\n# sum my_list\n- : int = 55\n# product my_list\n- : int = 3628800\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat was easy! Notice that I've accidentally come up with a way to do\nmathematical factorials:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let fact n = product (range 1 n)\nval fact : int -\u0026gt; int = \u0026lt;fun\u0026gt;\n# fact 10\n- : int = 3628800\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Notice that this factorial function isn't very useful because it\noverflows the integers and gives wrong answers even for quite small\nvalues of \u003ccode\u003en\u003c/code\u003e.)\u003c/p\u003e\n\u003ch2 id=\"looping-over-strings\"\u003eLooping over strings\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eString\u003c/code\u003e module also contains many dozens of useful string-related\nfunctions, and some of them are concerned with looping over strings.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eString.copy\u003c/code\u003e copies a string, like \u003ccode\u003estrdup\u003c/code\u003e. There is also a \u003ccode\u003eString.iter\u003c/code\u003e\nfunction which works like \u003ccode\u003eList.iter\u003c/code\u003e, except over the characters of the\nstring.\u003c/p\u003e\n\u003ch2 id=\"recursion\"\u003eRecursion\u003c/h2\u003e\n\u003cp\u003eNow we come to a hard topic - recursion. Functional programmers are\ndefined by their love of recursive functions, and in many ways recursive\nfunctions in f.p. are the equivalent of loops in imperative programming.\nIn functional languages loops are second-class citizens, whilst\nrecursive functions get all the best support.\u003c/p\u003e\n\u003cp\u003eWriting recursive functions requires a change in mindset from writing\nfor loops and while loops. So what I'll give you in this section will be\njust an introduction and examples.\u003c/p\u003e\n\u003cp\u003eIn the first example we're going to read the whole of a file into memory\n(into a long string). There are essentially three possible approaches to\nthis:\u003c/p\u003e\n\u003ch3 id=\"approach-1\"\u003eApproach 1\u003c/h3\u003e\n\u003cp\u003eGet the length of the file, and read it all in one go using the\n\u003ccode\u003ereally_input\u003c/code\u003e method. This is the simplest, but it might not work on\nchannels which are not really files (eg. reading keyboard input) which\nis why we look at the other two approaches.\u003c/p\u003e\n\u003ch3 id=\"approach-2\"\u003eApproach 2\u003c/h3\u003e\n\u003cp\u003eThe imperative approach, using a while loop which is broken out of using\nan exception.\u003c/p\u003e\n\u003ch3 id=\"approach-3\"\u003eApproach 3\u003c/h3\u003e\n\u003cp\u003eA recursive loop, breaking out of the recursion again using an\nexception.\u003c/p\u003e\n\u003cp\u003eWe're going to introduce a few new concepts here. Our second two\napproaches will use the \u003ccode\u003eBuffer\u003c/code\u003e module - an expandable buffer which you\ncan think of like a string onto which you can efficiently append more\ntext at the end. We're also going to be catching the \u003ccode\u003eEnd_of_file\u003c/code\u003e\nexception which the input functions throw when they reach the end of the\ninput. Also we're going to use \u003ccode\u003eSys.argv.(1)\u003c/code\u003e to get the first command\nline parameter.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Read whole file: Approach 1 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let len = in_channel_length chan in\n  let result = (Bytes.create len) in\n    really_input chan result 0 len;\n    (Bytes.to_string result)\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n    printf \u0026quot;I read %d characters from %s\\n\u0026quot; (String.length str) filename\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eApproach 1 works but is not very satisfactory because \u003ccode\u003eread_whole_chan\u003c/code\u003e\nwon't work on non-file channels like keyboard input or sockets. Approach\n2 involves a while loop:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Read whole file: Approach 2 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let buf = Buffer.create 4096 in\n  try\n    while true do\n      let line = input_line chan in\n        Buffer.add_string buf line;\n        Buffer.add_char buf '\\n'\n    done;\n    assert false (* This is never executed\n\t                (always raises Assert_failure). *)\n  with\n    End_of_file -\u0026gt; Buffer.contents buf\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n    printf \u0026quot;I read %d characters from %s\\n\u0026quot; (String.length str) filename\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe key to approach 2 is to look at the central while loop. Remember\nthat I said the only way to break out of a while loop early was with an\nexception? This is exactly what we're doing here. Although I haven't\ncovered exceptions yet, you probably won't have any trouble\nunderstanding the \u003ccode\u003eEnd_of_file\u003c/code\u003e exception thrown in the code above by\n\u003ccode\u003einput_line\u003c/code\u003e when it hits the end of the file. The buffer \u003ccode\u003ebuf\u003c/code\u003e\naccumulates the contents of the file, and when we hit the end of the\nfile we return it (\u003ccode\u003eBuffer.contents buf\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eOne curious point about this is the apparently superfluous statement\n(\u003ccode\u003eassert false\u003c/code\u003e) just after the while loop. What is it for?  Remember\nthat while loops, like for loops, are just expressions, and they return\nthe \u003ccode\u003eunit\u003c/code\u003e object (\u003ccode\u003e()\u003c/code\u003e). However OCaml demands that the return type\ninside a \u003ccode\u003etry\u003c/code\u003e matches the return type of each caught exception. In this\ncase because \u003ccode\u003eEnd_of_file\u003c/code\u003e results in a \u003ccode\u003estring\u003c/code\u003e, the main body of the\n\u003ccode\u003etry\u003c/code\u003e must also \u0026quot;return\u0026quot; a string  even though because of the infinite\nwhile loop the string could never actually be returned.  \u003ccode\u003eassert false\u003c/code\u003e\nhas a polymorphic type, so will unify with whatever value is returned\nby the \u003ccode\u003ewith\u003c/code\u003e branch.\u003c/p\u003e\n\u003cp\u003eHere's our recursive version. Notice that it's \u003cem\u003eshorter\u003c/em\u003e than approach\n2, but not so easy to understand for imperative programmers at least:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e(* Read whole file: Approach 3 *)\nopen Printf\n  \nlet read_whole_chan chan =\n  let buf = Buffer.create 4096 in\n  let rec loop () =\n    let line = input_line chan in\n      Buffer.add_string buf line;\n      Buffer.add_char buf '\\n';\n      loop ()\n  in\n    try loop () with\n      End_of_file -\u0026gt; Buffer.contents buf\n  \nlet read_whole_file filename =\n  let chan = open_in filename in\n    read_whole_chan chan\n  \nlet main () =\n  let filename = Sys.argv.(1) in\n  let str = read_whole_file filename in\n  printf \u0026quot;I read %d characters from %s\\n\u0026quot; (String.length str) filename\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgain we have an infinite loop - but in this case done using recursion.\n\u003ccode\u003eloop\u003c/code\u003e calls itself at the end of the function. The infinite recursion\nis broken when \u003ccode\u003einput_line\u003c/code\u003e throws an \u003ccode\u003eEnd_of_file\u003c/code\u003e exception.\u003c/p\u003e\n\u003cp\u003eIt looks like approach 3 might overflow the stack if you gave it a\nparticularly large file, but this is in fact not the case. Because of\ntail recursion (discussed below) the compiler will turn the recursive\n\u003ccode\u003eloop\u003c/code\u003e function into a real while loop (!) which runs in constant stack\nspace.\u003c/p\u003e\n\u003cp\u003eIn the next example we will show how recursion is great for constructing\nor examining certain types of data structures, particularly trees. Let's\nhave a recursive type to represent files in a filesystem:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type filesystem = File of string | Directory of filesystem list\ntype filesystem = File of string | Directory of filesystem list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eopendir\u003c/code\u003e and \u003ccode\u003ereaddir\u003c/code\u003e functions are used to open a directory and\nread elements from the directory. I'm going to define a handy\n\u003ccode\u003ereaddir_no_ex\u003c/code\u003e function which hides the annoying \u003ccode\u003eEnd_of_file\u003c/code\u003e\nexception that \u003ccode\u003ereaddir\u003c/code\u003e throws when it reaches the end of the\ndirectory:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# #load \u0026quot;unix.cma\u0026quot;\n# open Unix\n# let readdir_no_ex dirh =\n  try\n    Some (readdir dirh)\n  with\n    End_of_file -\u0026gt; None\nval readdir_no_ex : dir_handle -\u0026gt; string option = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe type of \u003ccode\u003ereaddir_no_ex\u003c/code\u003e is this. Recall our earlier discussion about\nnull pointers.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# readdir_no_ex\n- : dir_handle -\u0026gt; string option = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI'm also going to define a simple recursive function which I can use to\nconvert the \u003ccode\u003efilesystem\u003c/code\u003e type into a string for (eg) printing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec string_of_filesystem fs =\n  match fs with\n  | File filename -\u0026gt; filename ^ \u0026quot;\\n\u0026quot;\n  | Directory fs_list -\u0026gt;\n      List.fold_left (^) \u0026quot;\u0026quot; (List.map string_of_filesystem fs_list)\nval string_of_filesystem : filesystem -\u0026gt; string = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the use of \u003ccode\u003efold_left\u003c/code\u003e and \u003ccode\u003emap\u003c/code\u003e. The \u003ccode\u003emap\u003c/code\u003e is used to\n(recursively) convert each \u003ccode\u003efilesystem\u003c/code\u003e in the list into a \u003ccode\u003estring\u003c/code\u003e.\nThen the \u003ccode\u003efold_left (^) \u0026quot;\u0026quot;\u003c/code\u003e concatenates the list together into one big\nstring. Notice also the use of pattern matching. (The library defines a\nfunction called \u003ccode\u003eString.concat\u003c/code\u003e which is essentially equivalent to\n\u003ccode\u003efold_left (^) \u003c/code\u003e, but implemented more efficiently).\u003c/p\u003e\n\u003cp\u003eNow let's define a function to read a directory structure, recursively,\nand return a recursive \u003ccode\u003efilesystem\u003c/code\u003e data structure. I'm going to show\nthis function in steps, but I'll print out the entire function at the\nend of this section. First the outline of the function:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec read_directory path =\n  let dirh = opendir path in\n  let rec loop () =\n    (* ..... *) in\n  Directory (loop ())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe call to \u003ccode\u003eopendir\u003c/code\u003e opens up the given path and returns a \u003ccode\u003edir_handle\u003c/code\u003e\nfrom which we will be able to read the names using \u003ccode\u003ereaddir_no_ex\u003c/code\u003e\nlater. The return value of the function is going to be a\n\u003ccode\u003eDirectory fs_list\u003c/code\u003e, so all we need to do to complete the function is to\nwrite our function \u003ccode\u003eloop\u003c/code\u003e which returns a list of \u003ccode\u003efilesystem\u003c/code\u003es. The\ntype of \u003ccode\u003eloop\u003c/code\u003e will be:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003eloop : unit -\u0026gt; filesystem list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHow do we define loop? Let's take it in steps again.\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec loop () =\n  let filename = readdir_no_ex dirh in\n  (* ..... *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFirst we read the next filename from the directory handle. \u003ccode\u003efilename\u003c/code\u003e\nhas type \u003ccode\u003estring option\u003c/code\u003e, in other words it could be \u003ccode\u003eNone\u003c/code\u003e or\n\u003ccode\u003eSome \u0026quot;foo\u0026quot;\u003c/code\u003e where \u003ccode\u003efoo\u003c/code\u003e is the name of the next filename in the\ndirectory. We also need to ignore the \u003ccode\u003e\u0026quot;.\u0026quot;\u003c/code\u003e and \u003ccode\u003e\u0026quot;..\u0026quot;\u003c/code\u003e files (ie. the\ncurrent directory and the parent directory). We can do all this with a\nnice pattern match:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec loop () =\n  let filename = readdir_no_ex dirh in\n    match filename with\n    | None -\u0026gt; []\n    | Some \u0026quot;.\u0026quot; -\u0026gt; loop ()\n    | Some \u0026quot;..\u0026quot; -\u0026gt; loop ()\n    | Some filename -\u0026gt;\n        (* ..... *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eNone\u003c/code\u003e case is easy. Thinking recursively (!) if \u003ccode\u003eloop\u003c/code\u003e is called\nand we've reached the end of the directory, \u003ccode\u003eloop\u003c/code\u003e needs to return a\nlist of entries - and there's no entries - so it returns the empty list\n(\u003ccode\u003e[]\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eFor \u003ccode\u003e\u0026quot;.\u0026quot;\u003c/code\u003e and \u003ccode\u003e\u0026quot;..\u0026quot;\u003c/code\u003e we just ignore the file and call \u003ccode\u003eloop\u003c/code\u003e again.\u003c/p\u003e\n\u003cp\u003eWhat do we do when \u003ccode\u003eloop\u003c/code\u003e reads a real filename (the \u003ccode\u003eSome filename\u003c/code\u003e\nmatch below)? Let \u003ccode\u003epathname\u003c/code\u003e be the full path to the file. We 'stat' the\nfile to see if it's really a directory. If it \u003cem\u003eis\u003c/em\u003e a directory, we set\n\u003ccode\u003ethis\u003c/code\u003e by recursively calling \u003ccode\u003eread_directory\u003c/code\u003e which will return\n\u003ccode\u003eDirectory something\u003c/code\u003e. Notice that the overall result of\n\u003ccode\u003eread_directory\u003c/code\u003e is \u003ccode\u003eDirectory (loop ())\u003c/code\u003e. If the file is really a file\n(not a directory) then we let \u003ccode\u003ethis\u003c/code\u003e be \u003ccode\u003eFile pathname\u003c/code\u003e. Then we do\nsomething clever: we return \u003ccode\u003ethis :: loop ()\u003c/code\u003e. This is the recursive\ncall to \u003ccode\u003eloop ()\u003c/code\u003e to calculate the remaining directory members (a list),\nto which we prepend \u003ccode\u003ethis\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec read_directory path =\n  let dirh = opendir path in\n  let rec loop () =\n    let filename = readdir_no_ex dirh in\n      match filename with\n      | None -\u0026gt; []\n      | Some \u0026quot;.\u0026quot; -\u0026gt; loop ()\n      | Some \u0026quot;..\u0026quot; -\u0026gt; loop ()\n      | Some filename -\u0026gt;\n          let pathname = path ^ \u0026quot;/\u0026quot; ^ filename in\n          let stat = lstat pathname in\n          let this =\n            if stat.st_kind = S_DIR then\n              read_directory pathname\n            else\n              File pathname\n          in\n            this :: loop ()\n  in\n    Directory (loop ())\nval read_directory : string -\u0026gt; filesystem = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat's quite a complex bit of recursion, but although this is a made-up\nexample, it's fairly typical of the complex patterns of recursion found\nin real-world functional programs. The two important lessons to take\naway from this are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe use of recursion to build a list:\u003c/p\u003e\n  \u003c!-- $MDX skip --\u003e\n  ```ocaml\n  let rec loop () =\n    a match or if statement\n    | base case -\u003e []\n    | recursive case -\u003e element :: loop ()\n  ```\n  Compare this to our previous `range` function. The pattern of recursion\n  is exactly the same:\n    \n  ```ocaml\n  # let rec range a b =\n    if a \u003e b then []            (* Base case *)\n    else a :: range (a + 1) b     (* Recursive case *)\n  ```\n\t\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe use of recursion to build up trees:\u003c/p\u003e\n  \u003c!-- $MDX skip --\u003e\n  ```ocaml\n  let rec read_directory path =\n    (* blah blah *)\n    if file-is-a-directory then\n      read_directory path-to-file\n    else\n      Leaf file\n  ```\n  All that remains now to make this a working program is a little bit of\n  code to call `read_directory` and display the result:\n    \n  \u003c!-- $MDX skip --\u003e\n  ```ocaml\n  let path = Sys.argv.(1) in\n  let fs = read_directory path in\n  print_endline (string_of_filesystem fs)\n  ```\n\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"recursion-example-maximum-element-in-a-list\"\u003eRecursion example: maximum element in a list\u003c/h3\u003e\n\u003cp\u003eRemember the basic recursion pattern for lists:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec loop () =\n  a match or if statement\n  | base case -\u0026gt; []\n  | recursive case -\u0026gt; element :: loop ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe key here is actually the use of the match / base case / recursive\ncase pattern. In this example - finding the maximum element in a list -\nwe're going to have two base cases and one recursive case. But before I\njump ahead to the code, let's just step back and think about the\nproblem. By thinking about the problem, the solution will appear \u0026quot;as if\nby magic\u0026quot; (I promise you :-)\u003c/p\u003e\n\u003cp\u003eFirst of all, let's be clear that the maximum element of a list is just\nthe biggest one, e.g. the maximum element of the list \u003ccode\u003e[1; 2; 3; 4; 1]\u003c/code\u003e\nis \u003ccode\u003e4\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAre there any special cases? Yes, there are. What's the maximum element\nof the empty list \u003ccode\u003e[]\u003c/code\u003e? There \u003cem\u003eisn't one\u003c/em\u003e. If we are passed an empty\nlist, we should throw an error.\u003c/p\u003e\n\u003cp\u003eWhat's the maximum element of a single element list such as \u003ccode\u003e[4]\u003c/code\u003e?\nThat's easy: it's just the element itself. So \u003ccode\u003elist_max [4]\u003c/code\u003e should\nreturn \u003ccode\u003e4\u003c/code\u003e, or in the general case, \u003ccode\u003elist_max [x]\u003c/code\u003e should return \u003ccode\u003ex\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhat's the maximum element of the general list \u003ccode\u003ex :: remainder\u003c/code\u003e (this is\nthe \u0026quot;cons\u0026quot; notation for the list, so \u003ccode\u003eremainder\u003c/code\u003e is the tail - also a\nlist)?\u003c/p\u003e\n\u003cp\u003eThink about this for a while. Suppose you know the maximum element of\n\u003ccode\u003eremainder\u003c/code\u003e, which is, say, \u003ccode\u003ey\u003c/code\u003e. What's the maximum element of\n\u003ccode\u003ex :: remainder\u003c/code\u003e? It depends on whether \u003ccode\u003ex \u0026gt; y\u003c/code\u003e or \u003ccode\u003ex \u0026lt;= y\u003c/code\u003e. If \u003ccode\u003ex\u003c/code\u003e is\nbigger than \u003ccode\u003ey\u003c/code\u003e, then the overall maximum is \u003ccode\u003ex\u003c/code\u003e, whereas conversely if\n\u003ccode\u003ex\u003c/code\u003e is less than \u003ccode\u003ey\u003c/code\u003e, then the overall maximum is \u003ccode\u003ey\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eDoes this really work? Consider \u003ccode\u003e[1; 2; 3; 4; 1]\u003c/code\u003e again. This is\n\u003ccode\u003e1 :: [2; 3; 4; 1]\u003c/code\u003e. Now the maximum element of the remainder,\n\u003ccode\u003e[2; 3; 4; 1]\u003c/code\u003e, is \u003ccode\u003e4\u003c/code\u003e. So now we're interested in \u003ccode\u003ex = 1\u003c/code\u003e and \u003ccode\u003ey = 4\u003c/code\u003e.\nThat head element \u003ccode\u003ex = 1\u003c/code\u003e doesn't matter because \u003ccode\u003ey = 4\u003c/code\u003e is bigger, so\nthe overall maximum of the whole list is \u003ccode\u003ey = 4\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLet's now code those rules above up, to get a working function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec list_max xs =\n  match xs with\n  | [] -\u0026gt; (* empty list: fail *)\n      failwith \u0026quot;list_max called on empty list\u0026quot;\n  | [x] -\u0026gt; (* single element list: return the element *)\n      x\n  | x :: remainder -\u0026gt; (* multiple element list: recursive case *)\n      max x (list_max remainder)\nval list_max : 'a list -\u0026gt; 'a = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI've added comments so you can see how the rules / special cases we\ndecided upon above really correspond to lines of code.\u003c/p\u003e\n\u003cp\u003eDoes it work?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# list_max [1; 2; 3; 4; 1]\n- : int = 4\n# list_max []\nException: Failure \u0026quot;list_max called on empty list\u0026quot;.\n# list_max [5; 4; 3; 2; 1]\n- : int = 5\n# list_max [5; 4; 3; 2; 1; 100]\n- : int = 100\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice how the solution proposed is both (a) very different from the\nimperative for-loop solution, and (b) much more closely tied to the\nproblem specification. Functional programmers will tell you that this is\nbecause the functional style is much higher level than the imperative\nstyle, and therefore better and simpler. Whether you believe them is up\nto you. It's certainly true that it's much simpler to reason logically\nabout the functional version, which is useful if you wanted to formally\nprove that \u003ccode\u003elist_max\u003c/code\u003e is correct (\u0026quot;correct\u0026quot; being the mathematical way\nto say that a program is provably bug-free, useful for space shuttles,\nnuclear power plants and higher quality software in general).\u003c/p\u003e\n\u003ch3 id=\"tail-recursion\"\u003eTail recursion\u003c/h3\u003e\n\u003cp\u003eLet's look at the \u003ccode\u003erange\u003c/code\u003e function again for about the twentieth time:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range a b =\n  if a \u0026gt; b then []\n  else a :: range (a+1) b\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI'm going to rewrite it slightly to make something about the structure\nof the program clearer (still the same function however):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range a b =\n  if a \u0026gt; b then [] else\n    let result = range (a+1) b in\n      a :: result\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's call it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# List.length (range 1 10)\n- : int = 10\n# List.length (range 1 1000000)\nStack overflow during evaluation (looping recursion?).\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHmmm ... at first sight this looks like a problem with recursive\nprogramming, and hence with the whole of functional programming! If you\nwrite your code recursively instead of iteratively then you necessarily\nrun out of stack space on large inputs, right?\u003c/p\u003e\n\u003cp\u003eIn fact, wrong. Compilers can perform a simple optimisation on certain\ntypes of recursive functions to turn them into while loops. These\ncertain types of recursive functions therefore run in constant stack\nspace, and with the equivalent efficiency of imperative while loops.\nThese functions are called \u003cstrong\u003etail-recursive functions\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn tail-recursive functions, the recursive call happens last of all.\nRemember our \u003ccode\u003eloop ()\u003c/code\u003e functions above? They all had the form:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec loop () =\n  (* do something *)\n  loop ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBecause the recursive call to \u003ccode\u003eloop ()\u003c/code\u003e happens as the very last thing,\n\u003ccode\u003eloop\u003c/code\u003e is tail-recursive and the compiler will turn the whole thing into\na while loop.\u003c/p\u003e\n\u003cp\u003eUnfortunately \u003ccode\u003erange\u003c/code\u003e is not tail-recursive, and the longer version\nabove shows why. The recursive call to \u003ccode\u003erange\u003c/code\u003e doesn't happen as the\nvery last thing. In fact the last thing to happen is the \u003ccode\u003e::\u003c/code\u003e (cons)\noperation. As a result, the compiler doesn't turn the recursion into a\nwhile loop, and the function is not efficient in its use of stack space.\u003c/p\u003e\n\u003cp\u003eThe use of an accumulating argument or \u003ccode\u003eaccumulator\u003c/code\u003e allows one to write\nfunctions such as \u003ccode\u003erange\u003c/code\u003e above in a tail-recursive manner, which means they\nwill be efficient and work properly on large inputs. Let's plan our rewritten\n\u003ccode\u003erange\u003c/code\u003e function which will use an accumulator argument to store the \u0026quot;result so\nfar\u0026quot;:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec range2 a b accum =\n  (* ... *)\n  \nlet range a b =\n  range2 a b []\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eaccum\u003c/code\u003e argument is going to accumulate the result. It's the \u0026quot;result\nso far\u0026quot;. We pass in the empty list (\u0026quot;no result so far\u0026quot;). The easy case\nis when \u003ccode\u003ea \u0026gt; b\u003c/code\u003e:\u003c/p\u003e\n\u003c!-- $MDX skip --\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003elet rec range2 a b accum =\n  if a \u0026gt; b then accum\n  else\n    (* ... *)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf \u003ccode\u003ea \u0026gt; b\u003c/code\u003e (i.e. if we've reached the end of the recursion), then stop\nand return the result (\u003ccode\u003eaccum\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eNow the trick is to write the \u003ccode\u003eelse\u003c/code\u003e-clause and make sure that the call\nto \u003ccode\u003erange2\u003c/code\u003e is the very last thing that we do, so the function is\ntail-recursive:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range2 a b accum =\n  if a \u0026gt; b then accum\n  else range2 (a + 1) b (a :: accum)\nval range2 : int -\u0026gt; int -\u0026gt; int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere's only one slight problem with this function: it constructs the\nlist backwards! However, this is easy to rectify by redefining range as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let range a b = List.rev (range2 a b [])\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt works this time, although it's a bit slow to run because it really\ndoes have to construct a list with a million elements in it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# List.length (range 1 1000000)\n- : int = 1000000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe following implementation is twice as fast as the previous one,\nbecause it does not need to reverse a list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec range2 a b accum =\n  if b \u0026lt; a then accum\n  else range2 a (b - 1) (b :: accum)\nval range2 : int -\u0026gt; int -\u0026gt; int list -\u0026gt; int list = \u0026lt;fun\u0026gt;\n# let range a b =\n  range2 a b []\nval range : int -\u0026gt; int -\u0026gt; int list = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat was a brief overview of tail recursion, but in real world\nsituations determining if a function is tail recursive can be quite\nhard. What did we really learn here? One thing is that recursive\nfunctions have a dangerous trap for inexperienced programmers. Your\nfunction can appear to work for small inputs (during testing), but fail\ncatastrophically in the field when exposed to large inputs. This is one\nargument \u003cem\u003eagainst\u003c/em\u003e using recursive functions, and for using explicit\nwhile loops when possible.\u003c/p\u003e\n\u003ch2 id=\"mutable-records-references-again-and-arrays\"\u003eMutable records, references (again!) and arrays\u003c/h2\u003e\n\u003cp\u003ePreviously we mentioned records in passing. These are like C \u003ccode\u003estruct\u003c/code\u003es:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type pair_of_ints = {a : int; b : int}\ntype pair_of_ints = { a : int; b : int; }\n# {a = 3; b = 5}\n- : pair_of_ints = {a = 3; b = 5}\n# {a = 3}\nLine 1, characters 1-8:\nError: Some record fields are undefined: b\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne feature which I didn't cover: OCaml records can have mutable fields.\nNormally an expression like \u003ccode\u003e{a = 3; b = 5}\u003c/code\u003e is an immutable, constant\nobject. However if the record has \u003cstrong\u003emutable fields\u003c/strong\u003e, then\nthere is a way to change those fields in the record. This is an\nimperative feature of OCaml, because functional languages don't normally\nallow mutable objects (or references or mutable arrays, which we'll look\nat in a moment).\u003c/p\u003e\n\u003cp\u003eHere is an object defined with a mutable field. This field is used to\ncount how many times the object has been accessed. You could imagine\nthis being used in a caching scheme to decide which objects you'd evict\nfrom memory.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# type name = {name : string; mutable access_count : int}\ntype name = { name : string; mutable access_count : int; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is a function defined on names which prints the \u003ccode\u003ename\u003c/code\u003e field and\nincrements the mutable \u003ccode\u003eaccess_count\u003c/code\u003e field:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let print_name name =\n  print_endline (\u0026quot;The name is \u0026quot; ^ name.name);\n  name.access_count \u0026lt;- name.access_count + 1\nval print_name : name -\u0026gt; unit = \u0026lt;fun\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice a strange, and very non-functional feature of \u003ccode\u003eprint_name\u003c/code\u003e: it modifies\nits \u003ccode\u003eaccess_count\u003c/code\u003e parameter. This function is not \u0026quot;pure\u0026quot;. OCaml is a\nfunctional language, but not to the extent that it forces functional\nprogramming down your throat.\u003c/p\u003e\n\u003cp\u003eAnyway, let's see \u003ccode\u003eprint_name\u003c/code\u003e in action:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let n = {name = \u0026quot;Richard Jones\u0026quot;; access_count = 0}\nval n : name = {name = \u0026quot;Richard Jones\u0026quot;; access_count = 0}\n# n\n- : name = {name = \u0026quot;Richard Jones\u0026quot;; access_count = 0}\n# print_name n\nThe name is Richard Jones\n- : unit = ()\n# n\n- : name = {name = \u0026quot;Richard Jones\u0026quot;; access_count = 1}\n# print_name n\nThe name is Richard Jones\n- : unit = ()\n# n\n- : name = {name = \u0026quot;Richard Jones\u0026quot;; access_count = 2}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnly fields explicitly marked as \u003ccode\u003emutable\u003c/code\u003e can be assigned to using the\n\u003ccode\u003e\u0026lt;-\u003c/code\u003e operator. If you try to assign to a non-mutable field, OCaml won't\nlet you:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# n.name \u0026lt;- \u0026quot;John Smith\u0026quot;\nLine 1, characters 1-23:\nError: The record field name is not mutable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReferences, with which we should be familiar by now, are implemented\nusing records with a mutable \u003ccode\u003econtents\u003c/code\u003e field. Check out the definition\nin \u003ccode\u003eStdlib\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003etype 'a ref = {mutable contents : 'a}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd look closely at what the OCaml toplevel prints out for the value of\na reference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let r = ref 100\nval r : int Stdlib.ref = {Stdlib.contents = 100}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArrays are another sort of mutable structure provided by OCaml. In\nOCaml, plain lists are implemented as linked lists, and linked lists are\nslow for some types of operation. For example, getting the head of a\nlist, or iterating over a list to perform some operation on each element\nis reasonably fast. However, jumping to the n\u003csup\u003eth\u003c/sup\u003e element of a\nlist, or trying to randomly access a list - both are slow operations.\nThe OCaml \u003ccode\u003eArray\u003c/code\u003e type is a real array, so random access is fast, but\ninsertion and deletion of elements is slow. \u003ccode\u003eArray\u003c/code\u003es are also mutable so\nyou can randomly change elements too.\u003c/p\u003e\n\u003cp\u003eThe basics of arrays are simple:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let a = Array.create 10 0\nLine 1, characters 9-21:\nAlert deprecated: Stdlib.Array.create\nUse Array.make instead.\nval a : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]\n# for i = 0 to Array.length a - 1 do\n  a.(i) \u0026lt;- i\nLine 3, characters 1-3:\nError: Syntax error\n# a\n- : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice the syntax for writing arrays: \u003ccode\u003e[| element; element; ... |]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe OCaml compiler was designed with heavy numerical processing in mind\n(the sort of thing that FORTRAN is traditionally used for), and so it\ncontains various optimisations specifically for arrays of numbers,\nvectors and matrices. Here is some benchmark code for doing dense matrix\nmultiplication. Notice that it uses for-loops and is generally very\nimperative in style:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let size = 30\nval size : int = 30\n\n# let mkmatrix rows cols =\n  let count = ref 1\n  and last_col = cols - 1\n  and m = Array.make_matrix rows cols 0 in\n    for i = 0 to rows - 1 do\n      let mi = m.(i) in\n        for j = 0 to last_col do\n          mi.(j) \u0026lt;- !count;\n          incr count\n        done;\n    done;\n    m\nval mkmatrix : int -\u0026gt; int -\u0026gt; int array array = \u0026lt;fun\u0026gt;\n\n# let rec inner_loop k v m1i m2 j =\n  if k \u0026lt; 0 then v\n  else inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j\nval inner_loop : int -\u0026gt; int -\u0026gt; int array -\u0026gt; int array array -\u0026gt; int -\u0026gt; int =\n  \u0026lt;fun\u0026gt;\n\n# let mmult rows cols m1 m2 m3 =\n  let last_col = cols - 1\n  and last_row = rows - 1 in\n    for i = 0 to last_row do\n      let m1i = m1.(i) and m3i = m3.(i) in\n      for j = 0 to last_col do\n        m3i.(j) \u0026lt;- inner_loop last_row 0 m1i m2 j\n      done;\n    done\nval mmult :\n  int -\u0026gt; int -\u0026gt; int array array -\u0026gt; int array array -\u0026gt; int array array -\u0026gt; unit =\n  \u0026lt;fun\u0026gt;\n\n# let () =\n  let n =\n    try int_of_string Sys.argv.(1)\n    with Invalid_argument _ -\u0026gt; 1\n  and m1 = mkmatrix size size\n  and m2 = mkmatrix size size\n  and m3 = Array.make_matrix size size 0 in\n    for i = 1 to n - 1 do\n      mmult size size m1 m2 m3\n    done;\n    mmult size size m1 m2 m3;\n    Printf.printf \u0026quot;%d %d %d %d\\n\u0026quot; m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)\nException: Failure \u0026quot;int_of_string\u0026quot;.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"mutually-recursive-functions\"\u003eMutually recursive functions\u003c/h2\u003e\n\u003cp\u003eSuppose I want to define two functions which call each other. This is\nactually not a very common thing to do, but it can be useful sometimes.\nHere's a contrived example (thanks to Ryan Tarpine): The number 0 is\neven. Other numbers greater than 0 are even if their predecessor is odd.\nHence:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec even n =\n  match n with\n  | 0 -\u0026gt; true\n  | x -\u0026gt; odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe code above doesn't compile because we haven't defined the function\n\u003ccode\u003eodd\u003c/code\u003e yet! That's easy though. Zero is not odd, and other numbers\ngreater than 0 are odd if their predecessor is even. So to make this\ncomplete we need that function too:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec even n =\n  match n with\n  | 0 -\u0026gt; true\n  | x -\u0026gt; odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n# let rec odd n =\n  match n with\n  | 0 -\u0026gt; false\n  | x -\u0026gt; even (x - 1)\nLine 4, characters 10-14:\nError: Unbound value even\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe only problem is... this program doesn't compile. In order to compile\nthe \u003ccode\u003eeven\u003c/code\u003e function, we already need the definition of \u003ccode\u003eodd\u003c/code\u003e, and to\ncompile \u003ccode\u003eodd\u003c/code\u003e we need the definition of \u003ccode\u003eeven\u003c/code\u003e. So swapping the two\ndefinitions around won't help either.\u003c/p\u003e\n\u003cp\u003eThere are no \u0026quot;forward prototypes\u0026quot; (as seen in languages descended\nfrom C) in OCaml but there is a special syntax\nfor defining a set of two or more mutually recursive functions, like\n\u003ccode\u003eodd\u003c/code\u003e and \u003ccode\u003eeven\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ocaml\"\u003e# let rec even n =\n  match n with\n  | 0 -\u0026gt; true\n  | x -\u0026gt; odd (x - 1)\nLine 4, characters 10-13:\nError: Unbound value odd\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can also\nuse similar syntax for writing mutually recursive class definitions and\nmodules.\u003c/p\u003e\n","title":"If Statements, Loops and Recursions","pageDescription":"Learn basic control-flow and recusion in OCaml\n","tableOfContents":"\u003cul\u003e\n\u003cli\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#if-statements-actually-these-are-if-expressions\"\u003eIf statements (actually, these are if expressions)\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#using-begin--end\"\u003eUsing begin ... end\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#for-loops-and-while-loops\"\u003eFor loops and while loops\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#looping-over-lists\"\u003eLooping over lists\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#looping-over-strings\"\u003eLooping over strings\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#recursion\"\u003eRecursion\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mutable-records-references-again-and-arrays\"\u003eMutable records, references (again!) and arrays\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mutually-recursive-functions\"\u003eMutually recursive functions\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"},"params":{"lang":"en","tutorial":"if-statements-loops-and-recursions"}},"__N_SSG":true},"page":"/[lang]/resources/[tutorial]","query":{"lang":"en","tutorial":"if-statements-loops-and-recursions"},"buildId":"5vwEGiEdVvGQoOBpMUVkF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>