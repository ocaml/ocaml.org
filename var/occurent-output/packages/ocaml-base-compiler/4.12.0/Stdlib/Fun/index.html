<div><h2 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h2><div class="odoc-spec"><div class="spec value external" id="val-id" class="anchored"><a href="#val-id" class="anchor"></a><code><span><span class="keyword">val</span> id : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>id</code> is the identity function. For any argument <code>x</code>, <code>id x</code> is <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const" class="anchored"><a href="#val-const" class="anchor"></a><code><span><span class="keyword">val</span> const : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">_</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>const c</code> is a function that always returns the value <code>c</code>. For any argument <code>x</code>, <code>(const c) x</code> is <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flip" class="anchored"><a href="#val-flip" class="anchor"></a><code><span><span class="keyword">val</span> flip : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>flip f</code> reverses the argument order of the binary function <code>f</code>. For any arguments <code>x</code> and <code>y</code>, <code>(flip f) x y</code> is <code>f y x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-negate" class="anchored"><a href="#val-negate" class="anchor"></a><code><span><span class="keyword">val</span> negate : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>negate p</code> is the negation of the predicate function <code>p</code>. For any argument <code>x</code>, <code>(negate p) x</code> is <code>not (p x)</code>.</p></div></div><h2 id="exception"><a href="#exception" class="anchor"></a>Exception handling</h2><div class="odoc-spec"><div class="spec value" id="val-protect" class="anchored"><a href="#val-protect" class="anchor"></a><code><span><span class="keyword">val</span> protect : <span>finally:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>protect ~finally work</code> invokes <code>work ()</code> and then <code>finally ()</code> before <code>work ()</code> returns with its value or an exception. In the latter case the exception is re-raised after <code>finally ()</code>. If <code>finally ()</code> raises an exception, then the exception <a href="#exception-Finally_raised"><code>Finally_raised</code></a> is raised instead.</p><p><code>protect</code> can be used to enforce local invariants whether <code>work ()</code> returns normally or raises an exception. However, it does not protect against unexpected exceptions raised inside <code>finally ()</code> such as <a href="../index.html#exception-Out_of_memory"><code>Stdlib.Out_of_memory</code></a>, <a href="../index.html#exception-Stack_overflow"><code>Stdlib.Stack_overflow</code></a>, or asynchronous exceptions raised by signal handlers (e.g. <a href="../Sys/index.html#exception-Break"><code>Sys.Break</code></a>).</p><p>Note: It is a <em>programming error</em> if other kinds of exceptions are raised by <code>finally</code>, as any exception raised in <code>work ()</code> will be lost in the event of a <a href="#exception-Finally_raised"><code>Finally_raised</code></a> exception. Therefore, one should make sure to handle those inside the finally.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Finally_raised" class="anchored"><a href="#exception-Finally_raised" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Finally_raised</span> <span class="keyword">of</span> exn</span></code></div><div class="spec-doc"><p><code>Finally_raised exn</code> is raised by <code>protect ~finally work</code> when <code>finally</code> raises an exception <code>exn</code>. This exception denotes either an unexpected exception or a programming error. As a general rule, one should not catch a <code>Finally_raised</code> exception except as part of a catch-all handler.</p></div></div></div>