<div><div class="odoc-spec"><div class="spec type" id="type-extern_flags" class="anchored"><a href="#type-extern_flags" class="anchor"></a><code><span><span class="keyword">type</span> extern_flags</span><span> = </span></code><table><tr id="type-extern_flags.No_sharing" class="anchored"><td class="def variant constructor"><a href="#type-extern_flags.No_sharing" class="anchor"></a><code><span>| </span><span><span class="constructor">No_sharing</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Don't preserve sharing</p><span class="comment-delim">*)</span></td></tr><tr id="type-extern_flags.Closures" class="anchored"><td class="def variant constructor"><a href="#type-extern_flags.Closures" class="anchor"></a><code><span>| </span><span><span class="constructor">Closures</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Send function closures</p><span class="comment-delim">*)</span></td></tr><tr id="type-extern_flags.Compat_32" class="anchored"><td class="def variant constructor"><a href="#type-extern_flags.Compat_32" class="anchor"></a><code><span>| </span><span><span class="constructor">Compat_32</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Ensure 32-bit compatibility</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>The flags to the <code>Marshal.to_*</code> functions below.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_channel" class="anchored"><a href="#val-to_channel" class="anchor"></a><code><span><span class="keyword">val</span> to_channel : <span><a href="../index.html#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-extern_flags">extern_flags</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>Marshal.to_channel chan v flags</code> writes the representation of <code>v</code> on channel <code>chan</code>. The <code>flags</code> argument is a possibly empty list of flags that governs the marshaling behavior with respect to sharing, functional values, and compatibility between 32- and 64-bit platforms.</p><p>If <code>flags</code> does not contain <code>Marshal.No_sharing</code>, circularities and sharing inside the value <code>v</code> are detected and preserved in the sequence of bytes produced. In particular, this guarantees that marshaling always terminates. Sharing between values marshaled by successive calls to <code>Marshal.to_channel</code> is neither detected nor preserved, though. If <code>flags</code> contains <code>Marshal.No_sharing</code>, sharing is ignored. This results in faster marshaling if <code>v</code> contains no shared substructures, but may cause slower marshaling and larger byte representations if <code>v</code> actually contains sharing, or even non-termination if <code>v</code> contains cycles.</p><p>If <code>flags</code> does not contain <code>Marshal.Closures</code>, marshaling fails when it encounters a functional value inside <code>v</code>: only 'pure' data structures, containing neither functions nor objects, can safely be transmitted between different programs. If <code>flags</code> contains <code>Marshal.Closures</code>, functional values will be marshaled as a the position in the code of the program together with the values corresponding to the free variables captured in the closure. In this case, the output of marshaling can only be read back in processes that run exactly the same program, with exactly the same compiled code. (This is checked at un-marshaling time, using an MD5 digest of the code transmitted along with the code position.)</p><p>The exact definition of which free variables are captured in a closure is not specified and can vary between bytecode and native code (and according to optimization flags). In particular, a function value accessing a global reference may or may not include the reference in its closure. If it does, unmarshaling the corresponding closure will create a new reference, different from the global one.</p><p>If <code>flags</code> contains <code>Marshal.Compat_32</code>, marshaling fails when it encounters an integer value outside the range <code>[-2{^30}, 2{^30}-1]</code> of integers that are representable on a 32-bit platform. This ensures that marshaled data generated on a 64-bit platform can be safely read back on a 32-bit platform. If <code>flags</code> does not contain <code>Marshal.Compat_32</code>, integer values outside the range <code>[-2{^30}, 2{^30}-1]</code> are marshaled, and can be read back on a 64-bit platform, but will cause an error at un-marshaling time when read back on a 32-bit platform. The <code>Mashal.Compat_32</code> flag only matters when marshaling is performed on a 64-bit platform; it has no effect if marshaling is performed on a 32-bit platform.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-to_bytes" class="anchored"><a href="#val-to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> to_bytes : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-extern_flags">extern_flags</a> list</span> <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>Marshal.to_bytes v flags</code> returns a byte sequence containing the representation of <code>v</code>. The <code>flags</code> argument has the same meaning as for <a href="#val-to_channel"><code>Marshal.to_channel</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.02.0</li></ul></div></div><div class="odoc-spec"><div class="spec value external" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-extern_flags">extern_flags</a> list</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Same as <code>to_bytes</code> but return the result as a string instead of a byte sequence.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_buffer" class="anchored"><a href="#val-to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-extern_flags">extern_flags</a> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>Marshal.to_buffer buff ofs len v flags</code> marshals the value <code>v</code>, storing its byte representation in the sequence <code>buff</code>, starting at index <code>ofs</code>, and writing at most <code>len</code> bytes. It returns the number of bytes actually written to the sequence. If the byte representation of <code>v</code> does not fit in <code>len</code> characters, the exception <code>Failure</code> is raised.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_channel" class="anchored"><a href="#val-from_channel" class="anchor"></a><code><span><span class="keyword">val</span> from_channel : <span><a href="../index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>Marshal.from_channel chan</code> reads from channel <code>chan</code> the byte representation of a structured value, as produced by one of the <code>Marshal.to_*</code> functions, and reconstructs and returns the corresponding value.</p><p>It raises <code>End_of_file</code> if the function has already reached the end of file when starting to read from the channel, and raises <code>Failure &quot;input_value: truncated object&quot;</code> if it reaches the end of file later during the unmarshalling.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_bytes" class="anchored"><a href="#val-from_bytes" class="anchor"></a><code><span><span class="keyword">val</span> from_bytes : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>Marshal.from_bytes buff ofs</code> unmarshals a structured value like <a href="#val-from_channel"><code>Marshal.from_channel</code></a> does, except that the byte representation is not read from a channel, but taken from the byte sequence <code>buff</code>, starting at position <code>ofs</code>. The byte sequence is not mutated.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.02.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-from_string" class="anchored"><a href="#val-from_string" class="anchor"></a><code><span><span class="keyword">val</span> from_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Same as <code>from_bytes</code> but take a string as argument instead of a byte sequence.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-header_size" class="anchored"><a href="#val-header_size" class="anchor"></a><code><span><span class="keyword">val</span> header_size : int</span></code></div><div class="spec-doc"><p>The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header. <a href="#val-header_size"><code>Marshal.header_size</code></a> is the size, in bytes, of the header. <a href="#val-data_size"><code>Marshal.data_size</code></a><code> buff ofs</code> is the size, in bytes, of the data part, assuming a valid header is stored in <code>buff</code> starting at position <code>ofs</code>. Finally, <a href="#val-total_size"><code>Marshal.total_size</code></a> <code>buff ofs</code> is the total size, in bytes, of the marshaled value. Both <a href="#val-data_size"><code>Marshal.data_size</code></a> and <a href="#val-total_size"><code>Marshal.total_size</code></a> raise <code>Failure</code> if <code>buff</code>, <code>ofs</code> does not contain a valid header.</p><p>To read the byte representation of a marshaled value into a byte sequence, the program needs to read first <a href="#val-header_size"><code>Marshal.header_size</code></a> bytes into the sequence, then determine the length of the remainder of the representation using <a href="#val-data_size"><code>Marshal.data_size</code></a>, make sure the sequence is large enough to hold the remaining data, then read it, and finally call <a href="#val-from_bytes"><code>Marshal.from_bytes</code></a> to unmarshal the value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-data_size" class="anchored"><a href="#val-data_size" class="anchor"></a><code><span><span class="keyword">val</span> data_size : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>See <a href="#val-header_size"><code>Marshal.header_size</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-total_size" class="anchored"><a href="#val-total_size" class="anchor"></a><code><span><span class="keyword">val</span> total_size : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>See <a href="#val-header_size"><code>Marshal.header_size</code></a>.</p></div></div></div>