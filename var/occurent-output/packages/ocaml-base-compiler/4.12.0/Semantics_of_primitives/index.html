<div><p>Description of the semantics of primitives, to be used for optimization purposes.</p><p>&quot;No effects&quot; means that the primitive does not change the observable state of the world. For example, it must not write to any mutable storage, call arbitrary external functions or change control flow (e.g. by raising an exception). Note that allocation is not &quot;No effects&quot; (see below).</p><p>It is assumed in the compiler that applications of primitives with no effects, whose results are not used, may be eliminated. It is further assumed that applications of primitives with no effects may be duplicated (and thus possibly executed more than once).</p><p>(Exceptions arising from allocation points, for example &quot;out of memory&quot; or exceptions propagated from finalizers or signal handlers, are treated as &quot;effects out of the ether&quot; and thus ignored for our determination here of effectfulness. The same goes for floating point operations that may cause hardware traps on some platforms.)</p><p>&quot;Only generative effects&quot; means that a primitive does not change the observable state of the world save for possibly affecting the state of the garbage collector by performing an allocation. Applications of primitives that only have generative effects and whose results are unused may be eliminated by the compiler. However, unlike &quot;No effects&quot; primitives, such applications will never be eligible for duplication.</p><p>&quot;Arbitrary effects&quot; covers all other primitives.</p><p>&quot;No coeffects&quot; means that the primitive does not observe the effects (in the sense described above) of other expressions. For example, it must not read from any mutable storage or call arbitrary external functions.</p><p>It is assumed in the compiler that, subject to data dependencies, expressions with neither effects nor coeffects may be reordered with respect to other expressions.</p><div class="odoc-spec"><div class="spec type" id="type-effects" class="anchored"><a href="#type-effects" class="anchor"></a><code><span><span class="keyword">type</span> effects</span><span> = </span></code><table><tr id="type-effects.No_effects" class="anchored"><td class="def variant constructor"><a href="#type-effects.No_effects" class="anchor"></a><code><span>| </span><span><span class="constructor">No_effects</span></span></code></td></tr><tr id="type-effects.Only_generative_effects" class="anchored"><td class="def variant constructor"><a href="#type-effects.Only_generative_effects" class="anchor"></a><code><span>| </span><span><span class="constructor">Only_generative_effects</span></span></code></td></tr><tr id="type-effects.Arbitrary_effects" class="anchored"><td class="def variant constructor"><a href="#type-effects.Arbitrary_effects" class="anchor"></a><code><span>| </span><span><span class="constructor">Arbitrary_effects</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-coeffects" class="anchored"><a href="#type-coeffects" class="anchor"></a><code><span><span class="keyword">type</span> coeffects</span><span> = </span></code><table><tr id="type-coeffects.No_coeffects" class="anchored"><td class="def variant constructor"><a href="#type-coeffects.No_coeffects" class="anchor"></a><code><span>| </span><span><span class="constructor">No_coeffects</span></span></code></td></tr><tr id="type-coeffects.Has_coeffects" class="anchored"><td class="def variant constructor"><a href="#type-coeffects.Has_coeffects" class="anchor"></a><code><span>| </span><span><span class="constructor">Has_coeffects</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-for_primitive" class="anchored"><a href="#val-for_primitive" class="anchor"></a><code><span><span class="keyword">val</span> for_primitive : <span><a href="../Clambda_primitives/index.html#type-primitive">Clambda_primitives.primitive</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-effects">effects</a> * <a href="#type-coeffects">coeffects</a></span></code></div><div class="spec-doc"><p>Describe the semantics of a primitive. This does not take into account of the (non-)(co)effectfulness of the arguments in a primitive application. To determine whether such an application is (co)effectful, the arguments must also be analysed.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-return_type" class="anchored"><a href="#type-return_type" class="anchor"></a><code><span><span class="keyword">type</span> return_type</span><span> = </span></code><table><tr id="type-return_type.Float" class="anchored"><td class="def variant constructor"><a href="#type-return_type.Float" class="anchor"></a><code><span>| </span><span><span class="constructor">Float</span></span></code></td></tr><tr id="type-return_type.Other" class="anchored"><td class="def variant constructor"><a href="#type-return_type.Other" class="anchor"></a><code><span>| </span><span><span class="constructor">Other</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-return_type_of_primitive" class="anchored"><a href="#val-return_type_of_primitive" class="anchor"></a><code><span><span class="keyword">val</span> return_type_of_primitive : <span><a href="../Clambda_primitives/index.html#type-primitive">Clambda_primitives.primitive</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-return_type">return_type</a></span></code></div></div></div>