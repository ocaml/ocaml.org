---
packages:
- name: "caqti"
  version: "1.9.0"
- name: "caqti-lwt"
  version: "1.9.0"
- name: "caqti-driver-sqlite"
  version: "1.9.0"
- name: "ppx_rapper"
  version: "3.1.0"
- name: "ppx_rapper_lwt"
  version: "3.1.0"
sections:
- filename: main.ml
  language: ocaml
  code_blocks:
  - explanation: |
      The `Caqti/ppx_rapper` combo uses a Lwt environment (see concurency cookbook). Let operators `(let*)` and `(let*?)` are defined and permits the Lwt promise sequencing. `(let*?)` add an error handling: it extracts the result from a returned `Ok result` or stops the execution in case of an `Error err` value.
    code: |
      let (let*) = Lwt.bind
      let (let*?) = Lwt_result.bind
  - explanation: |
      The following function will be used later in this cookbook. It schedules sequentialy a set of queries. Each query from the list `queries` is a function which has an argument which is the connection handle of the database.
    code: |
      let iter_queries queries cnx =
        List.fold_left
          (fun a f -> Lwt_result.bind a (fun () -> f cnx))
          (Lwt.return (Ok ()))
          queries
  - explanation: |
      Table creation: the `CREATE` query is simple: no data in input nor in output. The `execute` type indicates the absence of result. Then when this query is called, `()` is returned (`Ok ()` to be accurate).
    code: |
      let create_query =
        [%rapper
            execute {sql|CREATE TABLE personal
                         (name VARCHAR, firstname VARCHAR, age INTEGER)
                     |sql}
        ]
  - explanation: |
      Insertion query: the `INSERT` query is a query which has some parameters which should be used during the execution of the query. `name`, `firstname`, `age` will be replaced by the values from the parameter (presented as record because of the `record_out` tag). The `%` notation tell the `ppx_rapper` preprocessor which conversions should be performed.
    code: |
      type person = { name:string; firstname:string; age:int }
      let persons = [ {name="Dupont"; firstname="Jacques"; age=36};
                      {name="Legendre"; firstname="Patrick"; age=42} ]
      let insert_query =
        [%rapper
            execute {sql|INSERT INTO personal VALUES
                         (%string{name}, %string{firstname}, %int{age})
                     |sql}
            record_in
        ]
  - explanation: |
      Select query: the first `SELECT` query has a `get_many` type, then, it will return a list of values. Each item of the list is a record, as specified by the `record_out` tag. Output values (generated by the query) are annotated with a `@` notation. A second query has output values and also an input value used in the `WHERE` clause. Here the absence of `record_in` implies passing input values as named arguments instead of a record, the `get_opt` tag indicates it will return an option type: `None` if nothing is found, `Some r` if a row match the criteria.
    code: |
      let select_query =
        [%rapper
            get_many {sql|SELECT @string{name}, @string{firstname}, @int{age}
                          FROM personal
                      |sql}
            record_out
        ]
      let select_query_with_where_clause =
        [%rapper
            get_opt {sql|SELECT @string{name}, @string{firstname}, @int{age}
                         FROM personal
                         WHERE name=%string{name}
                     |sql}
            record_out
        ]
  - explanation: |
      The main program starts by establishing an Lwt environment. The function `with_connexion` opens the database, executes a function with `cnx` database handle. And catches exception to ensure the closure of the database.
    code: |
      let () =
        match Lwt_main.run @@
                Caqti_lwt.with_connection (Uri.of_string "sqlite3:essai.sqlite")
                  (fun cnx ->
  - explanation: |
      Executing queries uses `()` and `cnx` parameters when no values should be passed to the query. The `insert_query` must be called with `record_of_person` and `cnx`. If multiple records from a list should be inserted, `List.map` creates a list of functions. Each of these functions will execute its associated query when called. The `iter_queries` schedule the queries in sequence.
    code: |
                    let*? () = create_query () cnx in
                    let*? () = iter_queries (List.map insert_query persons) cnx in
                    let*? persons = select_query () cnx in
                    persons |> List.iter (fun person ->
                                   Printf.printf "name=%s, firstname=%s, age=%d\n"
                                     person.name  person.firstname  person.age);
                    let*? person = select_query_with_where_clause ~name:"Dupont" cnx in
                    begin
                      match person with
                      | Some person' ->
                         Printf.printf "found:name=%s, firstname=%s, age=%d\n"
                           person'.name  person'.firstname  person'.age
                      | None -> print_string "Not found"
                    end;
                    Lwt_result.return ())
  - explanation:
      The error handling just matches the result with `Ok` or `Error`. The `Lwt_result.bind` called by each `(let*?)` stops the chain of queries at the first error. We just have to check the presence of error. `Caqti_error.show` can be used to convert the error into a text.
    code:
        with
        | Result.Ok () ->
             print_string "OK\n"
        | Result.Error err ->
             print_string (Caqti_error.show err)
- filename: dune
  language: dune
  code_blocks:
  - explanation: |
      Multiple libraries are involved.
    code: |
      (executable
        (name main)
        (libraries
            ppx_rapper_lwt
            lwt lwt.unix
            caqti-lwt
            caqti-driver-sqlite3)
        (preprocess (pps ppx_rapper)))
---

- **Understanding `Caqti` and `ppx_rapper`:** The `Caqti` library permits a portable programming with SQLite, MariaDB and PostgreSQL. The declaration of its queries is a bit complex, however the the `ppx_rapper` can be used to convert annotated SQL strings into `Caqti` queries. This preprocessor makes all type conversion transparent and leverage the strong typing of OCaml. It also checks the SQL syntax of the given query. The `Lwt` library is a scheduling library which permits concurrent tasks. It has been used because of `ppx_rapper` constraints. See [the Caqti reference page](https://github.com/paurkedal/ocaml-caqti) and [the ppx_rapper reference page](https://github.com/roddyyaga/ppx_rapper).
- **Alternative Libraries:** There are multiple alternatives to `Caqti`, but this library proposed a unified interface to 3 databases. `gensqlite` and `ppx_sqlexpr` are comparable to `ppx_rapper` but only work with SQLite libraries. `Petrol` supports SQLite and PostgreSQL and permits the type safety by declaring the database schema with OCaml structures (SQL statements are generated).
