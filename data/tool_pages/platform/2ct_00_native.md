---
id: "native-target"
short_title: "Compilation Targets: Native Code"
title: "Compilation Targets: Native Code"
description: "Compile OCaml to high-performance native code with ocamlopt. Maximum runtime performance with optimized machine code for production deployments."
category: "Compilation Targets"
---

OCaml can compile to native code, delivering high-performance executables with optimized machine code for production environments.

## What is OCaml Native Code?

OCaml native code is generated by ocamlopt, the high-performance native-code compiler that compiles OCaml source files to native code object files and links them to produce standalone executables. The native code system consists of:

- **ocamlopt** - The native-code compiler (analogous to gcc or clang for C/C++)
- **Native executables** - Stand-alone executable files that can be invoked directly without depending on the ocamlrun bytecode runtime system
- **Runtime system** - Integrated directly into each executable, including the garbage collector

Native code produces faster-running programs than bytecode, at the cost of increased compilation time and executable code size. Key characteristics:

- Faster runtime performance than bytecode
- Stand-alone executables requiring no external runtime
- Cross-module inlining and optimization
- Production-ready deployments

## When to Use Native Code

**Use native code** (ocamlopt) when you need faster runtime performance in production, want standalone executables, or are deploying to end users.

**Use bytecode** (ocamlc) for fast iteration during development, CI/testing environments where compilation speed matters, or maximum portability.

The typical OCaml workflow: develop with bytecode for fast compile times, switch to native code for production releases. The same source code compiles to both targets without modification.

## Platform Support

The native-code compiler is only available on certain platforms. From OCaml 5.0 onwards, native compilation is available only on 64-bit systems.

### Supported Platforms (OCaml 5.x)

- **x86-64 (AMD64)** - Linux, macOS, Windows
- **ARM64 (AArch64)** - Linux, macOS (including Apple Silicon)
- **RISC-V** - Linux
- **IBM Z (s390x)** - Linux (OCaml 5.1+)

Native compilation on 32-bit systems is no longer available, nor are there plans to bring it back.

**Windows specifics:** Native compilation is supported via MSVC, MinGW, or Cygwin toolchains. See [OCaml on Windows](https://ocaml.org/docs/ocaml-on-windows) for setup details.

If your target platform lacks native code support, the bytecode compiler provides a highly portable fallback.

## Getting Started

To compile OCaml programs to native code, use the ocamlopt compiler. For single files, specify the source file and output executable name. For projects with multiple modules, list them in dependency order. When using libraries, specify both the library archive and your source files.

In practice, most developers use build systems like [Dune](https://dune.build/) rather than invoking ocamlopt directly. Dune handles compilation, dependency management, and build orchestration.

For comprehensive compiler details, see the [OCaml Manual: Native-code Compilation (ocamlopt)](https://ocaml.org/manual/latest/native.html). For practical build workflows, see [Using the OCaml Compiler Toolchain](https://ocaml.org/docs/using-the-ocaml-compiler-toolchain).

## Compilation Model & File Extensions

OCaml's compilation model separates interface and implementation:

- **.ml** - Module implementation (source)
- **.mli** - Module interface/signature (source)
- **.cmi** - Compiled interface (used by both bytecode and native)
- **.cmx** - Compiled native object with cross-module optimization metadata
- **.o** / **.obj** - Native machine code object file
- **.cmxa** - Native library archive (collection of .cmx files)
- **.a** / **.lib** - Native static library (collection of .o files)

The .cmx files contain information for cross-module inlining and optimization. Unlike bytecode, these optimization metadata files must be available at link time for best performance.

## Compatibility with Bytecode

Compatibility with the bytecode compiler is extremely high: the same source code should run identically when compiled with ocamlc and ocamlopt.

Key constraints:

- It is not possible to mix native-code object files produced by ocamlopt with bytecode object files produced by ocamlc: a program must be compiled entirely with ocamlopt or entirely with ocamlc.
- Native-code object files produced by ocamlopt cannot be loaded in the toplevel system.

This binary compatibility means you can develop and test with bytecode for fast iteration, then deploy with native code for performance, using the same source code for both compilation targets.

## Debugging and Profiling

Native executables integrate with standard system tools:

**Debugging:**
- Compile with -g flag for debug symbols
- Produces stack backtraces when the program terminates on an uncaught exception
- Use gdb, lldb, or other native debuggers
- OCaml and C frames appear in the same stack trace

**Profiling:**
- Use perf (Linux), Instruments (macOS), or similar native profilers
- Compile with -g for accurate symbol resolution
- gprof support via -p flag

The native compiler maintains C calling conventions, making OCaml code visible to standard profiling and debugging tools.

## Dynamic Loading

The -shared option builds plugins (usually .cmxs files) that can be dynamically loaded with the Dynlink module. This provides a plugin system similar to shared libraries and DLLs, allowing runtime loading of OCaml code. Platform support variesâ€”consult the manual for specifics.

## Learn More

- [OCaml Manual: Native-code Compilation](https://ocaml.org/manual/latest/native.html) - Complete ocamlopt reference
- [Using the OCaml Compiler Toolchain](https://ocaml.org/docs/using-the-ocaml-compiler-toolchain) - Practical compilation guide
- [The Compiler Backend: Bytecode and Native code](https://ocaml.org/docs/compiler-backend) - Deep dive: lambda form, optimization, assembly output
