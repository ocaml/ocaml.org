<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>http://www.blogger.com/feeds/17133288/posts/default/-/ocaml</id><title type="text">dbaelde</title><updated>2023-06-07T05:45:50-00:00</updated><entry><link href="https://misterpingouin.blogspot.com/2010/10/randomselfinit.html" rel="alternate"/><contributor><uri>http://www.blogger.com/feeds/17133288/posts/default/-/ocaml</uri><name>dbaelde</name></contributor><content type="html">Maintenant que je travaille un peu dans le domaine de la s&amp;eacute;curit&amp;eacute;, je pense notamment aux g&amp;eacute;n&amp;eacute;rateurs de nombres al&amp;eacute;atoires. Apr&amp;egrave;s quelques lectures &lt;a href=&quot;http://en.wikipedia.org/wiki/Pseudorandom_number_generator&quot;&gt;sur&lt;/a&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator&quot;&gt;le sujet&lt;/a&gt;, je me suis demand&amp;eacute; comment fonctionnait le module &lt;code&gt;Random&lt;/code&gt; de Caml.&lt;br/&gt;
&lt;br/&gt;
Il y a s&amp;ucirc;rement beaucoup de choses &amp;agrave; dire, mais mon attention a &amp;eacute;t&amp;eacute; retenue par un truc simple: &lt;code&gt;self_init&lt;/code&gt; initialise le g&amp;eacute;n&amp;eacute;rateur de fa&amp;ccedil;on tr&amp;egrave;s simple, &amp;agrave; partir de l'heure et de l'identifiant du processus, donn&amp;eacute;es pour le moins al&amp;eacute;atoires. Il faut donc vraiment se m&amp;eacute;fier de cela si on souhaite utiliser le module &lt;code&gt;Random&lt;/code&gt; &amp;agrave; des fins cryptographiques. En pratique, le petit bout de code suivant devine assez rapidement la graine g&amp;eacute;n&amp;eacute;r&amp;eacute;e, en supposant connu l'identifiant du processus (ce n'est pas bien dur &amp;agrave; deviner sinon) et en supposant approximativement connue l'heure de l'initialisation:&lt;br/&gt;
&lt;br/&gt;
&lt;pre&gt;(** Random.self_init relies on caml_sys_random_seed
  * which returns an int.
  * That integer is sec ^ usec ^ ppid&amp;lt;&amp;lt;16 ^ pid.
  * We try to guess the seed to reproduce the output of
  * the random generator.
  * The PID and PPID are supposed to be known,
  * the time in seconds and micro-seconds is supposed
  * to be known resp. with precision 1s and 1000ms.
  * With that knowledge it's really fast;
  * with less it'd take longer. *)

let gen sec usec pid ppid =
  sec lxor usec lxor pid lxor (ppid lsl 16)

let random _ = Random.int 100

(** Given a leaked sequence of numbers consecutively
  * generated by [random] _immediately after_
  * [Random.self_init], call [k] with seeds that allow
  * to reproduce that sequence. *)
let crack leak k =
  let t = Unix.gettimeofday () in
  let sec = int_of_float t in
  let usec = int_of_float (fst (modf t) *. 1_000_000.) in
  let pid = Unix.getpid () in
  let ppid = Unix.getppid () in
    (* Since we sec and usec are xored, trying sec and
     * sec-1 would be useless: all we'd be doing is
     * flipping a bit that is flipped anyway when
     * enumerating posssible values for usec. *)
    for usec = usec - 10000 to usec do
      let seed = gen sec usec pid ppid in
        Random.init seed ;
        if Array.init (Array.length leak) random = leak then
          k seed
    done

let () =
  let leak,valid =
    Random.self_init () ;
    let leak = Array.init 1000 random in
    let valid = Array.init 5000 random in
      leak, valid
  in
  let k seed =
    let guess =
      Random.init seed ;
      ignore (Array.init (Array.length leak) random) ;
      Array.init (Array.length valid) random
    in
      Printf.printf
        &amp;quot;Guessed seed: %d. Validated: %b.\n&amp;quot;
        seed (guess=valid)
  in
    crack leak k ;
    Printf.printf &amp;quot;Search space exhausted.\n&amp;quot;
&lt;/pre&gt;&lt;br/&gt;
Quand on le lance, on a quelque chose comme &amp;ccedil;a en quelques secondes:&lt;br/&gt;
&lt;pre&gt;$ ocamlopt unix.cmxa crack.ml -o crack &amp;amp;&amp;amp; ./crack
Guessed seed: 262818353. Validated: true.
Search space exhausted.&lt;/pre&gt;&lt;br/&gt;
Il y a diverses variations possible. Ce qui m'int&amp;eacute;resse, et qui est encore assez obscur pour moi, c'est la g&amp;eacute;n&amp;eacute;ration (r&amp;eacute;p&amp;eacute;titive) de graines &amp;agrave; partir d'une partie priv&amp;eacute;e et d'une partie publique, utilis&amp;eacute;e pour &amp;eacute;viter d'avoir des s&amp;eacute;quences g&amp;eacute;n&amp;eacute;r&amp;eacute;es identiques (ce qui exposerait &amp;agrave; des attaques dans certains cas). A quel point on affaiblit ou compromet son secret, en fonction du g&amp;eacute;n&amp;eacute;rateur utilis&amp;eacute;, etc?</content><id>https://misterpingouin.blogspot.com/2010/10/randomselfinit.html</id><title type="text">Random.self_init</title><updated>2010-10-20T13:15:00-00:00</updated><author><name>mrpingouin</name></author></entry><entry><link href="https://misterpingouin.blogspot.com/2010/02/quel-effet-ca-fait.html" rel="alternate"/><contributor><uri>http://www.blogger.com/feeds/17133288/posts/default/-/ocaml</uri><name>dbaelde</name></contributor><content type="html">Quelle diff&amp;eacute;rence entre &lt;code&gt;a&amp;rarr;b&amp;rarr;c&lt;/code&gt; et &lt;code&gt;a&amp;rarr;b&amp;rarr;c&lt;/code&gt;? Pour le savoir, lisez ce qui suit.&lt;br/&gt;&lt;br/&gt;De temps en temps, je regarde un article scientifique, ou un bout de code, et je n'en suis pas satisfait. Un truc me chiffonne, &amp;ccedil;a peut se r&amp;eacute;parer, mais ya autre chose qui cloche, et au fond c'est tout bancal, &amp;ccedil;a n'en finit pas, et il vaut mieux tout remettre &amp;agrave; plat. Ceci est arriv&amp;eacute; r&amp;eacute;cemment dans liquidsoap avec le module de d&amp;eacute;codage de fichier. Ce n'est pas int&amp;eacute;ressant de d&amp;eacute;tailler, il y a juste un point dont je voulais parler. Mais avant, je trouve que c'est important de dire qu'il faut remettre les choses &amp;agrave; plat de temps en temps.&lt;br/&gt;&lt;br/&gt;Donc, il s'agit de d&amp;eacute;codage. Premi&amp;egrave;re question: qu'est ce que c'est un d&amp;eacute;codeur? J'ai mis un peu de temps &amp;agrave; essayer plusieurs styles, pour finalement d&amp;eacute;cider &lt;code&gt;input -&amp;gt; buffer -&amp;gt; unit&lt;/code&gt;, une fonction qui prend en entr&amp;eacute;e une m&amp;eacute;thode pour lire des donn&amp;eacute;es, et un buffer pour &amp;eacute;crire le r&amp;eacute;sultat du d&amp;eacute;codage, et qui ne renvoie rien mais remplit le buffer un peu plus &amp;agrave; chaque fois qu'on l'appelle.&lt;br/&gt;&lt;br/&gt;A c&amp;ocirc;t&amp;eacute; de cette notion tr&amp;egrave;s g&amp;eacute;n&amp;eacute;rique on a des notions plus sp&amp;eacute;cialis&amp;eacute;es comme le &lt;code&gt;type file_decoder = { fill : Frame.t -&amp;gt; unit ; close : unit -&amp;gt; unit }&lt;/code&gt;. C'est un enregistrement qui contient une fonction de remplissage de flux (on lui donne une frame (un morceau de flux) &amp;agrave; remplir) et une fonction de fermeture/nettoyage o&amp;ugrave; l'on lib&amp;egrave;re les ressources allou&amp;eacute;es pour le d&amp;eacute;codage.&lt;br/&gt;&lt;br/&gt;Ceci &amp;eacute;tant d&amp;eacute;cid&amp;eacute;, j'&amp;eacute;cris un bout de code g&amp;eacute;n&amp;eacute;rique qui emballe un d&amp;eacute;codeur pour construire un d&amp;eacute;codeur_de_fichier:&lt;pre&gt;let file_decoder filename decoder =&lt;br/&gt;  let input = input_from_file filename in&lt;br/&gt;  let buffer = create_buffer () in&lt;br/&gt;  let fill frame =&lt;br/&gt;    while not_enough_data_in buffer do&lt;br/&gt;      decoder input buffer&lt;br/&gt;    done ;&lt;br/&gt;    fill_frame_from_buffer frame buffer&lt;br/&gt;  in&lt;br/&gt;    { fill = fill ; close = fun () -&amp;gt; close input }&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;Vous me suivez? Maintenant, j'impl&amp;eacute;mente un d&amp;eacute;codeur, pour le format MP3 en utilisant la biblioth&amp;egrave;que mad:&lt;pre&gt;let create_decoder input =&lt;br/&gt;  let resampler = create_resampler () in&lt;br/&gt;  let mad_stream = Mad.openstream input in&lt;br/&gt;    (fun buffer -&amp;gt;&lt;br/&gt;       let data = Mad.decode_frame_float mad_stream in&lt;br/&gt;       let sample_freq,_,_ = Mad.get_output_format fd in&lt;br/&gt;       let content,length =&lt;br/&gt;         resampler ~audio_src_rate:(float sample_freq) data&lt;br/&gt;       in&lt;br/&gt;         put_audio_in_buffer buffer content length)&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;PAF! Vous voyez le bug? Je parie que non, en tout cas moi je l'avais rat&amp;eacute;. J'ai r&amp;eacute;ussi &amp;agrave; ne pas &amp;ecirc;tre d'accord avec moi m&amp;ecirc;me, penser &lt;code&gt;a&amp;rarr;b&amp;rarr;c&lt;/code&gt; ici et &lt;code&gt;a&amp;rarr;b&amp;rarr;c&lt;/code&gt; l&amp;agrave;!...&lt;br/&gt;&lt;br/&gt;Le probl&amp;egrave;me, c'est &lt;em&gt;les effets&lt;/em&gt;. En math&amp;eacute;matiques, une fonction prend un argument et renvoie un r&amp;eacute;sultat. On ne sait pas comment &amp;ccedil;a se passe &amp;quot;dedans&amp;quot;, en tout cas &amp;ccedil;a n'interagit pas sur le &amp;quot;dehors&amp;quot;, et &amp;ccedil;a se passe pareil &amp;agrave; chaque fois: m&amp;ecirc;me entr&amp;eacute;e, m&amp;ecirc;me sortie. En informatique, c'est bien plus compliqu&amp;eacute;. La fonction interagit avec le monde, elle peut afficher quelquechose &amp;agrave; l'&amp;eacute;cran, elle peut aller chercher un r&amp;eacute;sultat sur internet, dans un fichier, ou simplement dans une case m&amp;eacute;moire qu'elle partage avec d'autres fonctions. On est ainsi habitu&amp;eacute; &amp;agrave; avoir tout un paquet de fonctions de type &lt;code&gt;a&amp;rarr;b&lt;/code&gt;, puisqu'il ne s'agit pas seulement de prendre un objet de type &lt;code&gt;a&lt;/code&gt; pour calculer un objet de type &lt;code&gt;b&lt;/code&gt; mais aussi potentiellement de se livrer &amp;agrave; tout un tas d'interactions avec le monde.&lt;br/&gt;&lt;br/&gt;Mon code utilise cela, mais se prend les pieds dedans. Ce qui est joli, c'est que j'ai une &amp;quot;solution&amp;quot;. Mais voyons d'abord le probl&amp;egrave;me. Notre d&amp;eacute;codeur prend un canal d'entr&amp;eacute;e (&lt;code&gt;input&lt;/code&gt;), un canal de sortie (&lt;code&gt;buffer&lt;/code&gt;), et est suppos&amp;eacute; avoir comme &lt;em&gt;effet&lt;/em&gt; de lire un peu de donn&amp;eacute;es en entr&amp;eacute;e, de les convertir et les &amp;eacute;crire en sortie. Il ne renvoie rien d'utile (&lt;code&gt;unit&lt;/code&gt;), tout son interet r&amp;eacute;side dans l'effet; si on l'appelle un assez grand nombre de fois, on finit par avoir assez de donn&amp;eacute;es dans notre buffer -- c'est ce qu'on a fait plus haut. On peut cacher un certains nombres d'informations dans le d&amp;eacute;codeur, c'&amp;eacute;tait mon intention, par exemple j'y ai allou&amp;eacute; un &lt;em&gt;resampler&lt;/em&gt; pour convertir les donn&amp;eacute;es vers la bonne fr&amp;eacute;quence d'&amp;eacute;chantillonage: cet outil doit &amp;ecirc;tre (et est bien) cr&amp;eacute;e une fois et une seule pour chaque d&amp;eacute;codeur.&lt;br/&gt;&lt;br/&gt;Ce resampler maintient un &amp;eacute;tat interne, tout comme le d&amp;eacute;codeur mad (&lt;code&gt;mad_stream&lt;/code&gt;). Allouer ces objets est aussi un effet! Mais &amp;agrave; quel moment a-t-il lieu? Le type ne l'indique pas: dans &lt;code&gt;input-&amp;gt;buffer-&amp;gt;unit&lt;/code&gt;, apr&amp;egrave;s quel argument un effet peut-il avoir lieu? Dans le code de &lt;code&gt;file_decoder&lt;/code&gt; j'utilise un d&amp;eacute;codeur comme si le seul effet &amp;eacute;tait le d&amp;eacute;codage, qui a lieu une fois qu'on a renseign&amp;eacute; l'input et l'output. Mais dans le code du d&amp;eacute;codeur MP3, pas le choix, je m'autorise un effet entre le moment o&amp;ugrave; on m'a donn&amp;eacute; l'input et le moment o&amp;ugrave; on me donne le d&amp;eacute;codeur. R&amp;eacute;sultat, quand on utilise &lt;code&gt;file_decoder&lt;/code&gt; avec le &lt;code&gt;create_decoder&lt;/code&gt; MP3, on a un son tout hach&amp;eacute;, car le d&amp;eacute;codeur et le resampleur sont reinitialis&amp;eacute;s sans arr&amp;ecirc;t, ce qui provoque la perte d'une partie des donn&amp;eacute;es m&amp;eacute;moris&amp;eacute;es dans leurs buffers internes.&lt;br/&gt;&lt;br/&gt;Ces probl&amp;egrave;mes sont tr&amp;egrave;s vicieux, et sont toujours un sujet de recherche active. Mais concr&amp;egrave;tement, que peut-on y faire avec les outils d'aujourd'hui? Documenter, esp&amp;eacute;rer que tout le monde se comprend? Pas terrible, j'ai r&amp;eacute;ussi &amp;agrave; &amp;ecirc;tre en d&amp;eacute;saccord avec moi-m&amp;ecirc;me sur une courte p&amp;eacute;riode de temps. Comme d'habitude, &lt;em&gt;ce serait bien si le syst&amp;egrave;me de type nous servait de garde fou&lt;/em&gt;.&lt;br/&gt;&lt;br/&gt;En logique, la notion de focalisation (&lt;em&gt;focusing&lt;/em&gt;) est li&amp;eacute;e &amp;agrave; la question des effets. Une formule logique est vue comme un jeu entre deux joueurs: un qui prouve l'autre qui r&amp;eacute;fute, ou encore, l'environnement qui fournit une entr&amp;eacute;e (argument) et la machine qui renvoie une sortie (valeur de retour). Les connecteurs logiques sont attribu&amp;eacute;s &amp;agrave; l'un ou &amp;agrave; l'autre joueur: dans &lt;code&gt;(int*int)&amp;rarr;(int*int)&lt;/code&gt; c'est d'abord l'environnement qui donne un argument, directement compos&amp;eacute; de deux entiers; puis la machine calcule un r&amp;eacute;sultat, directement compos&amp;eacute; de deux entiers. Ici je dis directement, car on ne peut pas demander une r&amp;eacute;ponse partielle &amp;agrave; la machine, tout ceci vient d'un coup, une unique r&amp;eacute;ponse &amp;agrave; une seule question. La dynamique associ&amp;eacute;e au type &lt;code&gt;int&amp;rarr;int&amp;rarr;(int*int)&lt;/code&gt; est exactement la m&amp;ecirc;me: il n'y a pas deux questions &amp;agrave; l'environnement, mais une seule, les deux entiers en entr&amp;eacute;e arrivent d'un coup. L&amp;agrave; dedans, les seuls effets ne peuvent donc se situer qu'&amp;agrave; l'interface entre les deux joueurs, dans le calcul qui se passe entre une question et une r&amp;eacute;ponse.&lt;br/&gt;&lt;br/&gt;Commen&amp;ccedil;ons &amp;agrave; redescendons sur terre. Pour introduire la possibilit&amp;eacute; d'un effet, en focalisation, on peut introduire un d&amp;eacute;lai. Par exemple, si on veut une paire d'entiers paresseuse (dont le contenu n'est calcul&amp;eacute; que si n&amp;eacute;cessaire), on retarde le calcul des &lt;code&gt;int&lt;/code&gt;: &lt;code&gt;(unit-&amp;gt;int)*(unit-&amp;gt;int)&lt;/code&gt;. Dans l'autre sens, on peut aussi vouloir retarder le moment o&amp;ugrave; un argument est pass&amp;eacute;, par exemple avec &lt;code&gt;a-&amp;gt;(unit*(b-&amp;gt;c))&lt;/code&gt;... c'est ce qu'il nous faut!&lt;br/&gt;&lt;br/&gt;On la refait avec un d&amp;eacute;lai autour du d&amp;eacute;codeur, impl&amp;eacute;ment&amp;eacute; non pas comme &lt;code&gt;(unit*...)&lt;/code&gt; mais plus agr&amp;eacute;ablement avec un type variant:&lt;pre&gt;type decoder = Decoder of (buffer -&amp;gt; unit)&lt;br/&gt;type file_decoder = input -&amp;gt; decoder&lt;br/&gt;&lt;br/&gt;let file_decoder filename decoder =&lt;br/&gt;  let input = input_from_file filename in&lt;br/&gt;  let buffer = create_buffer () in&lt;br/&gt;  let Decoder f = decoder input in&lt;br/&gt;  let fill frame =&lt;br/&gt;    while not_enough_data_in buffer do&lt;br/&gt;      f buffer&lt;br/&gt;    done ;&lt;br/&gt;    fill_frame_from_buffer frame buffer&lt;br/&gt;  in&lt;br/&gt;    { fill = fill ; close = fun () -&amp;gt; close input }&lt;br/&gt;&lt;br/&gt;let create_decoder input =&lt;br/&gt;  let resampler = create_resampler () in&lt;br/&gt;  let mad_stream = Mad.openstream input in&lt;br/&gt;    Decoder (fun buffer -&amp;gt;&lt;br/&gt;       let data = Mad.decode_frame_float mad_stream in&lt;br/&gt;       let sample_freq,_,_ = Mad.get_output_format fd in&lt;br/&gt;       let content,length =&lt;br/&gt;         resampler ~audio_src_rate:(float sample_freq) data&lt;br/&gt;       in&lt;br/&gt;         put_audio_in_buffer buffer content length)&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;Le code du d&amp;eacute;codeur MP3 n'a chang&amp;eacute; que d'un iota, mais cela suffit &amp;agrave; forcer sa bonne utilisation dans &lt;code&gt;file_decoder&lt;/code&gt;, c'est &amp;agrave; dire &amp;agrave; passer l'input une fois pour toute, et ne plus passer que le buffer dans les appels suivants. Vraiment? Non, &amp;agrave; vrai dire, on peut toujours se prendre les pieds dedans, ne serait-ce que parce que c'est possible de traduire entre le vieux type de d&amp;eacute;codeur et le nouveau, en violant ainsi la logique qu'on a tent&amp;eacute; de forcer. Mais en pratique, ce petit garde fou pousse &amp;agrave; faire naturellement la bonne chose, ou au moins &amp;agrave; se poser la question.&lt;br/&gt;&lt;br/&gt;Tout est bien qui fini bien. Cette histoire pourrait aussi s'intituler &amp;quot;&amp;agrave; quoi diable pourrait bien servir un type variant avec un seul constructeur?&amp;quot; Ou encore, &amp;quot;c'est fou comme de belles id&amp;eacute;es th&amp;eacute;oriques ont du sens m&amp;ecirc;me en dehors de leur strict cadre th&amp;eacute;orique.&amp;quot;</content><id>https://misterpingouin.blogspot.com/2010/02/quel-effet-ca-fait.html</id><title type="text">Quel effet ça fait</title><updated>2010-02-08T19:04:00-00:00</updated><author><name>mrpingouin</name></author></entry><entry><link href="https://misterpingouin.blogspot.com/2009/07/illumination.html" rel="alternate"/><contributor><uri>http://www.blogger.com/feeds/17133288/posts/default/-/ocaml</uri><name>dbaelde</name></contributor><content type="html">For some reason, I've found myself implementing bits of a text-mode &lt;a href=&quot;http://en.wikipedia.org/wiki/Roguelike&quot;&gt;rogue-like&lt;/a&gt; game. In a nutshell, this is a turn-based kind of game where the player moves on a grid which usually depicts a dungeon or a cave. Some cells of that grid/map might contain a wall/rock, in which case the player cannot see or walk through them. All this is rather straightforward to implement, but the computation of what the player sees deserves some attention.&lt;br/&gt;&lt;br/&gt;I started thinking of casting rays, but only found clumsy, costly solutions. So I did a little research. Some people (including &lt;a href=&quot;http://www.google.com/codesearch/p?hl=fr&amp;amp;sa=N&amp;amp;cd=2&amp;amp;ct=rc#ds1vKBNOpqs/stone_soup-0.2.5-src/source/view.cc%26q=monstuff%20crawl%26l=994&quot;&gt;crawl&lt;/a&gt;) actually developed algorithms along these lines for computing what is called a &lt;a href=&quot;http://roguebasin.roguelikedevelopment.org/index.php?title=Permissive_Field_of_View&quot;&gt;permissive field of view&lt;/a&gt;: &lt;blockquote&gt;A destination square is visible from a source square if there is any unobstructed line from some point in the source square to some point in the destination square.&lt;/blockquote&gt;&lt;br/&gt;It's apparently a modern notion of field of view, that has one advantage over older techniques: it ensures symmetry, i.e., if I can see you, you can see me.&lt;br/&gt;&lt;br/&gt;The same article on roguebasin points to several algorithms, including the one implemented in crawl. They all seemed unsatisfyingly complicated to me. I eventually came up with a different idea that looks good and ensures symmetry. It might have been considered already and discarded for some of its funny aspects, but those are interested to look at.&lt;br/&gt;&lt;br/&gt;The basic idea is to forget about those lines. We are talking about a discrete universe, let's try to make its physics discrete too. &lt;a href=&quot;http://en.wikipedia.org/wiki/Geometrical_optics&quot;&gt;Geometrical optics&lt;/a&gt; is only a convenient metaphor, that is justified by more elementary principles such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Fermat's_principle&quot;&gt;Fermat's&lt;/a&gt;: &lt;blockquote&gt;The path taken between two points of a ray of light is the path that can be traversed in the least time.&lt;/blockquote&gt;&lt;br/&gt;This is in fact a definition of a ray of light that we can take literally in our discrete rogue world: &lt;blockquote&gt;A cell is visible from another if one of the shortest paths between them is unobstructed.&lt;/blockquote&gt;&lt;br/&gt;&lt;br/&gt;Let's look at a simple example. For now, suppose that the movements are only allowed along the axis (no diagonals):&lt;br/&gt;&lt;center&gt;&lt;pre&gt;.# &lt;br/&gt;@#y&lt;br/&gt;.x.&lt;/pre&gt;&lt;/center&gt;&lt;br/&gt;The player is represented by &lt;code&gt;@&lt;/code&gt;, and &lt;code&gt;#&lt;/code&gt; are walls/rocks. The cell marked &lt;code&gt;y&lt;/code&gt; is not visible: it is at distance 2, there is only one path of length 2 that connects it to the player but it is obstructed. Cell &lt;code&gt;x&lt;/code&gt; is also at distance 2, but it is visible since one of the two paths of length 2 that connects it to the player is not obstructed.&lt;br/&gt;&lt;br/&gt;A funny thing happens when you consider the traditional rogue movements which include diagonals: cell &lt;code&gt;y&lt;/code&gt; becomes visible! Indeed, the light can take a path of length 2 through &lt;code&gt;x&lt;/code&gt;.&lt;br/&gt;&lt;br/&gt;I would tend to adopt rules where the topology is the same for players and light. Either embrace the diagonal movements but accept the surprising effect on light, or remove them both for the light and the player. I chose the less experimental way for now. But it is also possible to use different topologies for the two entities.&lt;br/&gt;&lt;br/&gt;To finish, I will give the last reason why I like this solution: the code is stupid simple. Assuming that the radius of the field of view will always be within a fixed bound, we can compute once and for all the map of shortest paths with their dependencies.&lt;br/&gt;&lt;pre&gt;(** The maps will be used to associate&lt;br/&gt;  * the coordinates of the destination of a path&lt;br/&gt;  * to the lists of the coordinates of possible previous step&lt;br/&gt;  * in shortest paths leading to that destination. *)&lt;br/&gt;module M = Map.Make (struct type t = int*int let compare = compare end)&lt;br/&gt;&lt;br/&gt;let neighbors (x,y) =&lt;br/&gt;  [ x-1,y ;&lt;br/&gt;    x,y-1 ;&lt;br/&gt;    x+1,y ;&lt;br/&gt;    x,y+1 ]&lt;br/&gt;&lt;br/&gt;let shortest_paths max =&lt;br/&gt;  (** Map of distances to the center of the matrix. *)&lt;br/&gt;  let dist = Array.make_matrix (2*max+1) (2*max+1) max_int in&lt;br/&gt;  (** At each step we compute the shortests paths to cells&lt;br/&gt;    * at distance [d=n+1] from those for distance [n]. *)&lt;br/&gt;  let step d paths_n =&lt;br/&gt;    M.fold&lt;br/&gt;      (fun (x,y) _ m -&amp;gt;&lt;br/&gt;         List.fold_left&lt;br/&gt;           (fun m (x',y') -&amp;gt;&lt;br/&gt;              if dist.(max+x').(max+y') &amp;lt; d then&lt;br/&gt;                (* Seen in a previous iteration. *)&lt;br/&gt;                m&lt;br/&gt;              else if dist.(max+x').(max+y') = d then&lt;br/&gt;                (* We already found a path of length n+1,&lt;br/&gt;                 * but we need to keep track of this new one too. *)&lt;br/&gt;                M.add (x',y') ((x,y)::M.find (x',y') m) m&lt;br/&gt;              else begin&lt;br/&gt;                (* First time we see it: first shortest path. *)&lt;br/&gt;                dist.(max+x').(max+y') &amp;lt;- d ;&lt;br/&gt;                M.add (x',y') [x,y] m&lt;br/&gt;              end)&lt;br/&gt;           m&lt;br/&gt;           (neighbors (x,y)))&lt;br/&gt;      paths_n&lt;br/&gt;      M.empty&lt;br/&gt;  in&lt;br/&gt;  let rec aux d frontiers =&lt;br/&gt;    if d=max then frontiers else&lt;br/&gt;      aux (d+1) (step d (List.hd frontiers) :: frontiers)&lt;br/&gt;  in&lt;br/&gt;    List.rev (aux 1 [M.add (0,0) [] M.empty])&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;&lt;br/&gt;Then, it only remains to parse dependencies:&lt;br/&gt;&lt;pre&gt;(** Takes a radius (d) and returns a field of view function&lt;br/&gt;  * for that radius. *)&lt;br/&gt;let fov d =&lt;br/&gt;  let frontiers = shortest_paths d in&lt;br/&gt;    (* The field of view function,&lt;br/&gt;     * which takes a function and calls it on each visible cell.&lt;br/&gt;     * The function [f] returns whether a cell is transparent or not. *)&lt;br/&gt;    fun f -&amp;gt;&lt;br/&gt;      let transparent = Array.make_matrix (2*d+1) (2*d+1) false in&lt;br/&gt;        transparent.(d).(d) &amp;lt;- true ;&lt;br/&gt;        List.iter&lt;br/&gt;          (fun frontier -&amp;gt;&lt;br/&gt;             M.iter&lt;br/&gt;               (fun (x',y') deps -&amp;gt;&lt;br/&gt;                  if&lt;br/&gt;                    List.exists (fun (x,y) -&amp;gt; transparent.(d+x).(d+y)) deps&lt;br/&gt;                  then&lt;br/&gt;                    transparent.(d+x').(d+y') &amp;lt;- f x' y')&lt;br/&gt;               frontier)&lt;br/&gt;          (List.tl frontiers)&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;&lt;br/&gt;Hurray to (impure) functional programming! I leave it to you to glue this to whatever testing code you want. I'll finish with &amp;quot;screenshots&amp;quot;.&lt;br/&gt;&lt;br/&gt;Without diagonal moves, notice that it is possible to see through a wall on a diagonal:&lt;br/&gt;&lt;center&gt;&lt;pre&gt;              .&lt;br/&gt;       .      ..&lt;br/&gt;      ..    ##...&lt;br/&gt;     #.. ###...# .&lt;br/&gt;     #..#......##.#&lt;br/&gt;     #.....@......#&lt;br/&gt;     #...##........&lt;br/&gt;     ...#.........&lt;br/&gt;      ###........&lt;br/&gt;        #.......&lt;br/&gt;        ..####.&lt;br/&gt;         .&lt;br/&gt;&lt;/pre&gt;&lt;/center&gt;&lt;br/&gt;&lt;br/&gt;With diagonal moves, we now have shadows along the diagonals, but we can see around walls placed along the axis:&lt;br/&gt;&lt;center&gt;&lt;pre&gt;        ..#..#...&lt;br/&gt;         .......&lt;br/&gt;   .######.....&lt;br/&gt;   ...........&lt;br/&gt;   .##.......&lt;br/&gt;    #.......#&lt;br/&gt;    #.......####   #&lt;br/&gt;    #..........## ..&lt;br/&gt;   .##..##.@....#...&lt;br/&gt;   #...  ##...##..##&lt;br/&gt;   ###    .......###&lt;br/&gt;         ...........&lt;br/&gt;        ............&lt;br/&gt;       .............&lt;br/&gt;      ###...........&lt;br/&gt;        ............&lt;br/&gt;       .##.####.....&lt;br/&gt;&lt;/pre&gt;&lt;/center&gt;</content><id>https://misterpingouin.blogspot.com/2009/07/illumination.html</id><title type="text">Illumination</title><updated>2009-07-16T06:13:00-00:00</updated><author><name>mrpingouin</name></author></entry><entry><link href="https://misterpingouin.blogspot.com/2009/06/mise-en-boite.html" rel="alternate"/><contributor><uri>http://www.blogger.com/feeds/17133288/posts/default/-/ocaml</uri><name>dbaelde</name></contributor><content type="html">Depuis un bon moment, liquidsoap dispose d'un langage de configuration/script fonctionnel, fortement et statiquement typ&amp;eacute;, qui inf&amp;egrave;re des types &amp;agrave; la ML, le tout &amp;agrave; l'insu de la plupart des utilisateurs. Pour liquidsoap 1.0 nous irons plus loin dans l'utilisation de concepts avanc&amp;eacute;s avec (un peu) de vrai polymorphisme.&lt;br/&gt;&lt;br/&gt;&lt;em&gt;J'ai &lt;b&gt;&amp;eacute;dit&amp;eacute;&lt;/b&gt; ce post deux ou trois dans les jours suivant sa publication. Peut-&amp;ecirc;tre que le blog n'&amp;eacute;tait pas le format id&amp;eacute;al.&lt;/em&gt;&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Pourquoi?&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;Dans une conf liquidsoap, les fonctions sont parfois utiles pour &amp;eacute;viter de recopier du code, ou pour sp&amp;eacute;cifier une action &amp;agrave; effectuer en r&amp;eacute;action &amp;agrave; certains &amp;eacute;venements. Mais au coeur m&amp;ecirc;me de la g&amp;eacute;n&amp;eacute;ration du flux, les fonctions sont utilis&amp;eacute;es pour repr&amp;eacute;senter les transitions entre pistes audio. (D&amp;eacute;tails &lt;a href=&quot;http://www.lix.polytechnique.fr/~dbaelde/productions/pool/jfla08.pdf&quot;&gt;ici&lt;/a&gt;.)&lt;br/&gt;&lt;br/&gt;Cette m&amp;ecirc;me notion de transition pose des probl&amp;egrave;mes quant &amp;agrave; l'&amp;eacute;coulement du temps. Actuellement dans liquidsoap, toutes les sources de flux audio &amp;eacute;voluent &amp;agrave; la m&amp;ecirc;me vitesse, cadenc&amp;eacute;es par une unique horloge. Pour calculer une transition entre deux pistes d'une m&amp;ecirc;me source, l'op&amp;eacute;rateur &lt;code&gt;cross&lt;/code&gt; doit obtenir en avance le d&amp;eacute;but de la piste suivante, et le combiner avec la fin de la piste en cours. Cela requiert d'acc&amp;eacute;l&amp;eacute;rer cette source.&lt;br/&gt;&lt;br/&gt;L'impl&amp;eacute;mentation actuelle n'est pas une solution: Les op&amp;eacute;rateurs qui en ont besoin simulent l'action de l'horloge aupr&amp;egrave;s de leur source, afin de l'acc&amp;eacute;l&amp;eacute;rer. Cela marche souvent, mais il se peut que deux op&amp;eacute;rateurs lisent une m&amp;ecirc;me source &amp;agrave; des vitesses diff&amp;eacute;rentes. Le r&amp;eacute;sultat est inattendu, &amp;agrave; &amp;eacute;viter. Notre mission est d'&amp;eacute;viter cela statiquement, avant m&amp;ecirc;me la construction des sources. Nous allons donc attacher un param&amp;egrave;tre au type des sources, qui repr&amp;eacute;sentera son horloge, et sp&amp;eacute;cifier dans le type des op&amp;eacute;rateurs s'ils requi&amp;egrave;rent des horloges particuli&amp;egrave;res.&lt;br/&gt;&lt;br/&gt;S'il est assez facile de bricoler le syst&amp;egrave;me de type pour obtenir l'effet d&amp;eacute;sir&amp;eacute;, il faut d'abord identifier les concepts &amp;quot;logiques&amp;quot; mis en jeux. J'ai honte, mais &amp;ccedil;a m'a pris du temps, car j'ai &lt;a href=&quot;http://savonet.rastageeks.org/wiki/FutureBoxes&quot;&gt;commenc&amp;eacute;&lt;/a&gt; par chercher dans des contr&amp;eacute;es exotiques alors que c'est assez connu, bien que pointu.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Polymorphisme&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;Le polymorphisme est la possibilit&amp;eacute; de former une quantification universelle sur les types. Si on a un objet de type &lt;code&gt;&amp;forall;x. x-&amp;gt;x&lt;/code&gt;, on peut l'instantier en une fonction de type &lt;code&gt;int-&amp;gt;int&lt;/code&gt; aussi bien que &lt;code&gt;(bool-&amp;gt;bool)-&amp;gt;(bool-&amp;gt;bool)&lt;/code&gt;.&lt;br/&gt;&lt;br/&gt;Dans les langages d&amp;eacute;riv&amp;eacute;s de ML, le polymorphisme est limit&amp;eacute; &amp;agrave; une quantification externe. On peut avoir &lt;code&gt;&amp;forall;x. x-&amp;gt;x&lt;/code&gt; mais pas &lt;code&gt;(&amp;forall;x. x-&amp;gt;x)-&amp;gt;int-&amp;gt;int&lt;/code&gt;. Le polymorphisme dans toute sa g&amp;eacute;n&amp;eacute;ralit&amp;eacute;, par exemple dans le syst&amp;egrave;me F, rend en effet l'inf&amp;eacute;rence de type ind&amp;eacute;cidable.&lt;br/&gt;&lt;br/&gt;OCaml permet cependant d'aller un peu plus loin. La cl&amp;eacute; est que la cr&amp;eacute;ation d'un type polymorphe doit &amp;ecirc;tre explicite dans le programme (cf. &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.4858&quot;&gt;ce papier&lt;/a&gt;), par exemple associ&amp;eacute;e &amp;agrave; la cr&amp;eacute;ation d'un enregistrement. Consid&amp;eacute;rons la signature suivante:&lt;br/&gt;&lt;div class=&quot;code&quot;&gt;(** Une source associ&amp;eacute;e &amp;agrave; l'horloge 'a *)&lt;br/&gt;type 'a src&lt;br/&gt;&lt;br/&gt;(** Une fonction qui renvoie une source qu'on peut&lt;br/&gt;  * associer &amp;agrave; n'importe quelle horloge. *)&lt;br/&gt;type boxed = { c : 'a. unit -&amp;gt; 'a src }&lt;br/&gt;&lt;br/&gt;(** Cet op&amp;eacute;rateur prend une source en bo&amp;icirc;te,&lt;br/&gt;  * cela pourrait &amp;ecirc;tre le cross() de liquidsoap. *)&lt;br/&gt;val box  : boxed -&amp;gt; 'a src&lt;br/&gt;&lt;br/&gt;val leaf : unit -&amp;gt; 'a src            (* en gros, single *)&lt;br/&gt;val node : 'a src list -&amp;gt; 'a src     (* en gros, fallback *)&lt;br/&gt;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;Voyons voir ce qu'on peut et ne peut pas faire avec ce syst&amp;egrave;me. On peut cr&amp;eacute;er un certain nombre de sources avec &lt;code&gt;leaf ()&lt;/code&gt; initialement, elles auront le type &lt;code&gt;'_a src&lt;/code&gt;: leur horloge est ind&amp;eacute;finie, mais pas g&amp;eacute;n&amp;eacute;ralisable. On est content de ne pas voir de &lt;code&gt;'a src&lt;/code&gt;: cela correspondrait &amp;agrave; une source qui peut se brancher sur toutes les horloges &lt;em&gt;&amp;agrave; la fois&lt;/em&gt;, non-sens. (C'est aussi pour cela qu'on n'a pas &amp;eacute;crit &lt;code&gt;boxed = { c : 'a. 'a src }&lt;/code&gt;, on n'aurait jamais pu construire de bo&amp;icirc;te.)&lt;br/&gt;&lt;br/&gt;On peut passer une source de type &lt;code&gt;'_a src&lt;/code&gt; &amp;agrave; notre op&amp;eacute;rateur &lt;code&gt;node&lt;/code&gt;, on obtient une autre source &amp;agrave; la m&amp;ecirc;me horloge &lt;code&gt;'_a&lt;/code&gt;. Si on passe deux sources &amp;agrave; &lt;code&gt;node&lt;/code&gt;, le syst&amp;egrave;me de type requiert que leurs horloges soient les m&amp;ecirc;mes (des inconnues &lt;code&gt;'_a&lt;/code&gt; et &lt;code&gt;'_b&lt;/code&gt; sont unifi&amp;eacute;es).&lt;br/&gt;&lt;br/&gt;Maintenant, tentons de former des bo&amp;icirc;tes:&lt;br/&gt;&lt;div class=&quot;code&quot;&gt;let b = box { c = leaf }&lt;br/&gt;(* Gagn&amp;eacute;:&lt;br/&gt; * une bo&amp;icirc;te qui nous donne une nouvelle feuille &amp;agrave; chaque fois,&lt;br/&gt; * horloge au choix. *)&lt;br/&gt;&lt;br/&gt;let a = leaf ()&lt;br/&gt;let b = box { c = fun () -&amp;gt; b }&lt;br/&gt;(* Rat&amp;eacute;, erreur de type:&lt;br/&gt; * la source a est de type '_a src,&lt;br/&gt; * la fonction (fun () -&amp;gt; b) est de type unit -&amp;gt; '_a src,&lt;br/&gt; * qu'on ne peut g&amp;eacute;n&amp;eacute;raliser en 'a. unit -&amp;gt; 'a src. *)&lt;br/&gt;&lt;br/&gt;let b =&lt;br/&gt;  box { c = fun () -&amp;gt;&lt;br/&gt;              let a = leaf () in&lt;br/&gt;                 node [a;a] }&lt;br/&gt;(* Gagn&amp;eacute;, on a une bo&amp;icirc;te qui nous renvoie une source compos&amp;eacute;e,&lt;br/&gt; * dont on peut choisir l'horloge. *)&lt;br/&gt;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;On tient clairement le bon concept: le polymorphisme assure que l'horloge peut &amp;ecirc;tre choisie. En particulier on va pouvoir cr&amp;eacute;er des nouvelles horloges d&amp;eacute;di&amp;eacute;es &amp;agrave; certaines sources (et leurs sous-sources). Reste &amp;agrave; transf&amp;eacute;rer ce petit exemple en quelquechose d'agr&amp;eacute;able &amp;agrave; utiliser dans liquidsoap.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Liquidsoap 1.0&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;Actuellement dans liquidsoap, on &amp;eacute;crit des choses comme:&lt;br/&gt;&lt;div class=&quot;code&quot;&gt;music = playlist(&amp;quot;list.txt&amp;quot;)&lt;br/&gt;backup = single(&amp;quot;default.ogg&amp;quot;)&lt;br/&gt;source = fallback([music,backup])&lt;br/&gt;transition = fun (a,b) -&amp;gt; ...&lt;br/&gt;source = cross(transition,source)&lt;br/&gt;output.icecast(source)&lt;br/&gt;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;En collant au style de notre exemple en OCaml, nous devrions r&amp;eacute;&amp;eacute;crire les choses ainsi:&lt;br/&gt;&lt;div class=&quot;code&quot;&gt;transition = fun (a,b) -&amp;gt; ...&lt;br/&gt;source =&lt;br/&gt;  cross(transition, {&lt;br/&gt;    music = playlist(&amp;quot;list.txt&amp;quot;)&lt;br/&gt;    backup = single(&amp;quot;default.ogg&amp;quot;)&lt;br/&gt;    fallback([music,backup])&lt;br/&gt;  })&lt;br/&gt;output.icecast(source)&lt;br/&gt;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;C'est trop lourd, et ma solution ne va diff&amp;eacute;rer que d'un epsilon du style courant:&lt;br/&gt;&lt;div class=&quot;code&quot;&gt;music = playlist(&amp;quot;list.txt&amp;quot;)&lt;br/&gt;backup = single(&amp;quot;default.ogg&amp;quot;)&lt;br/&gt;source = fallback([music,backup])&lt;br/&gt;transition = fun (a,b) -&amp;gt; ...&lt;br/&gt;source = cross(transition,{source})&lt;br/&gt;output.icecast(source)&lt;br/&gt;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;Un point cl&amp;eacute; qui permet cette simplification est qu'on n'a besoin que d'une partie du polymorphisme: on veut la g&amp;eacute;n&amp;eacute;ricit&amp;eacute;, mais une seule fois. Pas besoin d'une fonction qui &amp;agrave; chaque appel pond une source, comme dans l'exemple en Caml. Il suffit d'une seule source, tant que son horloge est g&amp;eacute;n&amp;eacute;rique.&lt;br/&gt;&lt;br/&gt;Je pense qu'on ne peut pas se passer ais&amp;eacute;ment du marqueur &lt;code&gt;{source}&lt;/code&gt; qui indique qu'on g&amp;eacute;n&amp;eacute;ralise cette source. Il me semble acceptable de demander &amp;agrave; l'utilisateur de marquer le coup quand il utilise cette notion complexe. (Par contre il va nous falloir choisir une syntaxe qui ne rentre pas en conflit avec l'actuel &lt;code&gt;{...}&lt;/code&gt;, raccourci pour &lt;code&gt;fun () -&amp;gt; ...&lt;/code&gt;.)&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Comment &amp;ccedil;a marche&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;J'ai une &lt;a href=&quot;http://www.lix.polytechnique.fr/~dbaelde/productions/pool/boxes.ml.html&quot;&gt;impl&amp;eacute;mentation&lt;/a&gt; en OCaml qui me semble transposable &amp;agrave; liquidsoap.&lt;br/&gt;&lt;br/&gt;Comment OCaml v&amp;eacute;rifie-t-il que &lt;code&gt;{ c = fun () -&amp;gt; blah }&lt;/code&gt; est bien typ&amp;eacute;? Il introduit une nouvelle variable de type &lt;code&gt;n&lt;/code&gt; pour repr&amp;eacute;senter le &lt;code&gt;'a&lt;/code&gt; de &lt;code&gt;'a. unit -&amp;gt; 'a src&lt;/code&gt;, et v&amp;eacute;rifie qu'on peut donner le type &lt;code&gt;n src&lt;/code&gt; &amp;agrave; &lt;code&gt;blah&lt;/code&gt;.&lt;br/&gt;&lt;br/&gt;Nous allons faire la m&amp;ecirc;me chose, mais dans le d&amp;eacute;sordre, pour permettre le genre d'&amp;eacute;criture promis plus haut. Pour former une bo&amp;icirc;te (un type universel) sur une source, il faut que son horloge soit encore ind&amp;eacute;termin&amp;eacute;e. On v&amp;eacute;rifie cela en unifiant le type de cette source avec &lt;code&gt;n src&lt;/code&gt; pour une nouvelle variable de type &lt;code&gt;n&lt;/code&gt; comme OCaml faisait. Et une fois qu'on a ainsi r&amp;eacute;ussit &amp;agrave; former une bo&amp;icirc;te, on affecte cette variable &amp;agrave; type &amp;agrave; une valeur interdite &lt;code&gt;Boom&lt;/code&gt; pour emp&amp;ecirc;cher son utilisation ailleurs. Au lieu de cr&amp;eacute;er les sources dans une zone prot&amp;eacute;g&amp;eacute;e, on les cr&amp;eacute;e en dehors, et on les y affecte apr&amp;egrave;s coup, ce qui rend alors leur horloge d&amp;eacute;nu&amp;eacute;e de sens &amp;agrave; l'ext&amp;eacute;rieur.&lt;br/&gt;&lt;br/&gt;Un difficult&amp;eacute; essentielle du polymorphisme vient du fait que pour inf&amp;eacute;rer, on a besoin de savoir quel type universel on forme. Dans le cas de liquidsoap ma solution est tr&amp;egrave;s simple: on ne forme que &lt;code&gt;&amp;forall;x. x src&lt;/code&gt;. On pourrait avoir d'autres types polymorphes, mais chacun aurait son constructeur particulier.&lt;br/&gt;&lt;br/&gt;Ces m&amp;eacute;canismes fonctionnent bien sur quelques exemples disponibles dans mon code:&lt;br/&gt;&lt;div class=&quot;code&quot;&gt;ex0 = single ()&lt;br/&gt;ex0 : '_a src   # pas de g&amp;eacute;n&amp;eacute;ralisation, c'est comme avec ref&lt;br/&gt;&lt;br/&gt;ex00 = let x = single () in {x}&lt;br/&gt;ex00 : 'a. 'a src&lt;br/&gt;&lt;br/&gt;ex1 = fun (x) -&amp;gt; cross(x)&lt;br/&gt;ex1 : 'b. ('a. 'a src) -&amp;gt; 'b src&lt;br/&gt;&lt;br/&gt;ex4 = fun (_) -&amp;gt; cross({single(&amp;quot;blah.ogg&amp;quot;)})&lt;br/&gt;ex4 : 'a.'b. 'a -&amp;gt; 'b src&lt;br/&gt;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;Un exemple plus subtil est &lt;code&gt;ex2 = fun (x) -&amp;gt; {x}&lt;/code&gt;, ou la variation &lt;code&gt;ex4 = fun (x) -&amp;gt; cross({x})&lt;/code&gt; qui se rapproche de &lt;code&gt;ex1&lt;/code&gt;. Ici une bo&amp;icirc;te est form&amp;eacute;e sur l'argument de la fonction, qui doit donc &amp;ecirc;tre une source. Ce genre de construction est probl&amp;eacute;matique: la source doit &amp;ecirc;tre introduite avant son horloge. En pratique, cela se traduit par l'impossibilit&amp;eacute; de former le type de la fonction o&amp;ugrave; devrait apparaitre le symbole interdit: &lt;code&gt;Boom src -&amp;gt; 'a. 'a src&lt;/code&gt;.</content><id>https://misterpingouin.blogspot.com/2009/06/mise-en-boite.html</id><title type="text">Mise en boîte</title><updated>2009-06-04T11:38:00-00:00</updated><author><name>mrpingouin</name></author></entry><entry><link href="https://misterpingouin.blogspot.com/2008/10/exercice.html" rel="alternate"/><contributor><uri>http://www.blogger.com/feeds/17133288/posts/default/-/ocaml</uri><name>dbaelde</name></contributor><content type="html">Il me reste treize jours pour finir de r&amp;eacute;diger ma th&amp;egrave;se. Pendant ce temps l&amp;agrave;, pour que je ne sois pas le seul &amp;agrave; bosser, voici un petit exercice de prog qui m'est pass&amp;eacute; par la t&amp;ecirc;te. On peut repr&amp;eacute;senter du texte par le type &lt;code&gt;string&lt;/code&gt; en Caml. On veut ensuite repr&amp;eacute;senter du texte annot&amp;eacute;, quand les annotations forment un arbre: soit deux annotations sont disjointes, soit l'une est incluse dans l'autre. Pensez par exemple &amp;agrave; la grammaire au coll&amp;egrave;ge, &amp;quot;sujet&amp;quot; , &amp;quot;verbe&amp;quot;, &amp;quot;compl&amp;eacute;ment&amp;quot; sont regroup&amp;eacute;s pour former une &amp;quot;phrase&amp;quot;:&lt;br/&gt;&lt;br/&gt;&lt;div class=&quot;code&quot;&gt;type annot =&lt;br/&gt;  (* Par exemple.. *)&lt;br/&gt;  | Sujet | Verbe | Compl&amp;eacute;ment | Phrase&lt;br/&gt;type t =&lt;br/&gt;  | Text of string&lt;br/&gt;  | Annot of string * t&lt;br/&gt;  | Concat of t list&lt;br/&gt;&lt;/div&gt;&lt;br/&gt;Il est ais&amp;eacute; de travailler avec ce type. Et il repr&amp;eacute;sente exactement ce qu'on veut, il y a bijection. Maintenant, je veux une solution aussi satisfaisante quand les annotations ne forment plus un arbre mais peuvent se recouvrir partiellement. Pensez par exemple &amp;agrave; du HTML mal form&amp;eacute;: &lt;code&gt;&amp;lt;red&amp;gt;b&amp;lt;b&amp;gt;a&amp;lt;/red&amp;gt;b&amp;lt;/b&amp;gt;i&lt;/code&gt;. Sauf que moi j'ai une utilisation moins crade en t&amp;ecirc;te, mais c'est une autre histoire. Vos id&amp;eacute;es sont bienvenues, sinon je posterai peut &amp;ecirc;tre une solution plus tard...</content><id>https://misterpingouin.blogspot.com/2008/10/exercice.html</id><title type="text">Exercice</title><updated>2008-10-13T13:15:00-00:00</updated><author><name>mrpingouin</name></author></entry><entry><link href="https://misterpingouin.blogspot.com/2008/02/ocaml-write-only.html" rel="alternate"/><contributor><uri>http://www.blogger.com/feeds/17133288/posts/default/-/ocaml</uri><name>dbaelde</name></contributor><content type="html">J'ai d&amp;eacute;couvert un petit site sympa suite &amp;agrave; une annonce sur la Caml-list: &lt;a href=&quot;http://golf.shinh.org/&quot;&gt;Anarchy Golf&lt;/a&gt;. Au golf, on fini un parcours en un nombre minimum de coups. Ici, on r&amp;eacute;sout un probl&amp;egrave;me en un nombre minimum d'octets de code. De nombreux langages sont disponibles, dont OCaml.&lt;br/&gt;&lt;br/&gt;Le probl&amp;egrave;me annonc&amp;eacute; sur la Caml-list laisse r&amp;ecirc;veur: trouver un &lt;em&gt;Quine&lt;/em&gt; qui soit aussi un palindrome. En clair: un programme dont l'ex&amp;eacute;cution affiche le code du programme, et dont le code est un palindrome, i.e. identique qu'on le lise de droite &amp;agrave; gauche ou le contraire. Il est assez simple d'&amp;eacute;crire un Quine, quel que soit le langage. J'ai &amp;eacute;crit un palindrome en Caml, c'est d&amp;eacute;ja un peu plus ardu. Mais satisfaire aux deux contraintes en m&amp;ecirc;me temps est d&amp;eacute;courageant. Alors j'ai perdu mon temps sur d'autres probl&amp;egrave;mes plus simples, en attendant de voir les solutions &amp;agrave; celui-ci (le 08 F&amp;eacute;vrier, 01:46:39 heure japonaise).&lt;br/&gt;&lt;br/&gt;La contrainte de concision force &amp;agrave; faire des choses illisibles. Par exemple, ma solution pour le probl&amp;egrave;me &lt;a href=&quot;http://golf.shinh.org/p.rb?rot13&quot;&gt;rot13&lt;/a&gt;:&lt;br/&gt;&lt;pre&gt;let rec(!)?(c=input_byte stdin)x=output_byte stdout[|c;c;65+c mod x;97+(c-6)mod x|].(c/32);!x;;!26&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;&amp;Agrave; ce stade vient l'expression consacr&amp;eacute;e &amp;agrave; Perl: ce code est &lt;em&gt;write-only&lt;/em&gt;. Et encore c'est assez lisible compar&amp;eacute; aux solutions du champion de Golf en OCaml: &lt;code&gt;ksk&lt;/code&gt;.&lt;br/&gt;&lt;br/&gt;La concision force &amp;agrave; faire des choses qu'on ne pourrait qualifier de bonnes pratiques de programmation. Cela dit, il faut en g&amp;eacute;n&amp;eacute;ral r&amp;eacute;fl&amp;eacute;chir &amp;agrave; un algorithme pas trop con pour pouvoir pr&amp;eacute;tendre au podium. Par exemple, m&amp;ecirc;me en d&amp;eacute;ployant toutes les ruses de compression possibles, je sentais bien que je n'atteindrais pas les 54 octets de &lt;code&gt;ksk&lt;/code&gt; pour &amp;eacute;crire un &lt;a href=&quot;http://golf.shinh.org/p.rb?Minimal%20scheme%20interpreter&quot;&gt;interp&amp;eacute;teur Scheme minimal&lt;/a&gt;. Apr&amp;egrave;s la fin du d&amp;eacute;fi, quand &lt;a href=&quot;http://golf.shinh.org/reveal.rb?Minimal%20scheme%20interpreter/ksk/1201104485&amp;amp;ml&quot;&gt;son code&lt;/a&gt; a &amp;eacute;t&amp;eacute; publi&amp;eacute;, j'ai pu constater qu'il avait rus&amp;eacute;:&lt;br/&gt;&lt;pre&gt;print_string[|&amp;quot;3&amp;quot;;&amp;quot;24&amp;quot;;&amp;quot;5&lt;br/&gt;8&lt;br/&gt;58&amp;quot;|].(-Obj.magic(@)mod 3)&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;De l&amp;agrave; &amp;agrave; comprendre la ruse, ce n'est pas si simple. Tout repose sur le fait que le code ne doit pas vraiment impl&amp;eacute;menter un interpr&amp;eacute;teur Scheme: il suffit qu'il donne les bonnes r&amp;eacute;ponses pour trois entr&amp;eacute;es diff&amp;eacute;rentes, toujours les m&amp;ecirc;mes. La plupart des participants ont utilis&amp;eacute; cette &amp;quot;faille&amp;quot; pour r&amp;eacute;pondre, par exemple &lt;code&gt;m.ukai&lt;/code&gt;, class&amp;eacute; second en OCaml:&lt;br/&gt;&lt;pre&gt;print_string[|&amp;quot;24&amp;quot;;&amp;quot;3&amp;quot;;&amp;quot;5&lt;br/&gt;8&lt;br/&gt;58&amp;quot;|].(String.length(read_line())-16)&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;Ici, la r&amp;eacute;ponse est choisie en fonction de la longueur de la premi&amp;egrave;re ligne de l'entr&amp;eacute;e, cette information &amp;eacute;tant suffisante pour distinguer les tests. La solution de &lt;code&gt;ksk&lt;/code&gt; reste incompr&amp;eacute;hensible: il n'y a aucune instruction de lecture, aucun test d&amp;eacute;pendant de l'entr&amp;eacute;e. Pire: si vous prenez son code et le compilez (en natif ou &lt;em&gt;bytecode&lt;/em&gt;) vous obtiendrez un programme d&amp;eacute;terministe (il affiche toujours &lt;code&gt;3&lt;/code&gt; chez moi).&lt;br/&gt;&lt;br/&gt;La cl&amp;eacute; du myst&amp;egrave;re ? Ex&amp;eacute;cut&amp;eacute; dans la boucle d'interaction &lt;code&gt;ocaml&lt;/code&gt; comme le fait la proc&amp;eacute;dure de v&amp;eacute;rification du Code Golf, ce code a une sortie al&amp;eacute;atoire. Selon les ex&amp;eacute;cutions de &lt;code&gt;ocaml ksk.ml&lt;/code&gt;, on re&amp;ccedil;oit la r&amp;eacute;ponse de l'un des trois tests. Le hasard r&amp;eacute;side dans l'initialisation de la boucle d'interaction, qui fait que l'op&amp;eacute;rateur de concat&amp;eacute;nation &lt;code&gt;(@)&lt;/code&gt;, transtyp&amp;eacute; en un &lt;code&gt;int&lt;/code&gt; par &lt;code&gt;Obj.magic&lt;/code&gt; va avoir une valeur grosso-modo al&amp;eacute;atoire. Je ne fais que constater, je ne comprends pas.&lt;br/&gt;&lt;br/&gt;Mais cela ne r&amp;eacute;pond toujours pas au probl&amp;egrave;me... enfin, pas toujours. Il aura probablement fallu &amp;agrave; &lt;code&gt;ksk&lt;/code&gt; pas mal de patience pour soumettre et re-soumettre son code jusqu'&amp;agrave; ce que le hasard renvoie les bonnes r&amp;eacute;ponses aux bons tests, et le classe premier! Cette solution est vraiment &lt;em&gt;write-only&lt;/em&gt;: c'est illisible, et m&amp;ecirc;me son ex&amp;eacute;cution laisse &amp;agrave; d&amp;eacute;sirer :)&lt;br/&gt;&lt;br/&gt;Moi je trouve &amp;ccedil;a un peu trop immoral, mais il faut avouer que &amp;ccedil;a respecte les r&amp;egrave;gles du jeu. Et on aura appris quelquechose. C'est moche, mais &amp;ccedil;a marche.</content><id>https://misterpingouin.blogspot.com/2008/02/ocaml-write-only.html</id><title type="text">OCaml write-only</title><updated>2008-02-03T21:23:00-00:00</updated><author><name>mrpingouin</name></author></entry><entry><link href="https://misterpingouin.blogspot.com/2007/11/enigme.html" rel="alternate"/><contributor><uri>http://www.blogger.com/feeds/17133288/posts/default/-/ocaml</uri><name>dbaelde</name></contributor><content type="html">Quand on pose une &amp;eacute;nigme math&amp;eacute;matique, &amp;agrave; moiti&amp;eacute; formalis&amp;eacute;e, on finit toujours par avoir une r&amp;eacute;ponse type: &amp;quot;on enl&amp;egrave;ve le bandeau qu'on a sur les yeux&amp;quot;, &amp;quot;on casse la gueule au bourreau&amp;quot;, etc. D'o&amp;ugrave; l'id&amp;eacute;e de formaliser vraiment, sous forme d'un exercice de programmation... (qui a dit &amp;quot;maniaque&amp;quot; ?)&lt;br/&gt;&lt;br/&gt;Un groupe de &lt;code&gt;n&lt;/code&gt; prisonniers se trouve en mauvaise posture. Ils vont &amp;ecirc;tre mis en file indienne, chaque prisonnier voyant seulement les prisonniers devant lui. Puis on leur mettra sur la t&amp;ecirc;te un chapeau bleu, blanc ou rouge, qu'ils ne peuvent voir. Un bourreau proc&amp;egrave;de alors comme suit: en partant du dernier prisonnier il demande &amp;quot;Quelle est la couleur de ton chapeau ?&amp;quot;, et le prisonnier n'a le droit qu'&amp;agrave; une r&amp;eacute;ponse, qui doit &amp;ecirc;tre une couleur. A la fin, les prisonniers qui ont devin&amp;eacute; la couleur de leur chapeau sont &amp;eacute;pargn&amp;eacute;s, les autres ex&amp;eacute;cut&amp;eacute;s. Les prisonniers peuvent se concerter avant l'&amp;eacute;preuve sur la strat&amp;eacute;gie &amp;agrave; adopter. Quelle est la meilleure strat&amp;eacute;gie ?&lt;br/&gt;&lt;br/&gt;Voici maintenant l'&amp;eacute;nonc&amp;eacute; compl&amp;egrave;tement formalis&amp;eacute;. Un prisonnier est repr&amp;eacute;sent&amp;eacute; par une fonction qui prend deux listes de couleurs (celles qu'il voit devant lui, celles qui ont &amp;eacute;t&amp;eacute; prononc&amp;eacute;es comme r&amp;eacute;ponses derri&amp;egrave;re lui), et renvoie une couleur (sa r&amp;eacute;ponse). Dans la liste des r&amp;eacute;ponses pr&amp;eacute;c&amp;eacute;dentes, la r&amp;eacute;ponse du dernier de la file est la derni&amp;egrave;re de la liste. Trouver une fonction &lt;code&gt;prisonniers&lt;/code&gt; qui &amp;agrave; un entier &lt;code&gt;n&lt;/code&gt; associe une liste de &lt;code&gt;n&lt;/code&gt; fonctions/prisonniers telle que le nombre de morts calcul&amp;eacute; par &lt;code&gt;(execution (prisonniers n))&lt;/code&gt; soit le plus petit possible dans le pire cas. La fonction d'ex&amp;eacute;cution est la suivante:&lt;br/&gt;&lt;pre&gt;type couleur = Bleu | Blanc | Rouge&lt;br/&gt;type prisonnier = couleur list -&amp;gt; couleur list -&amp;gt; couleur&lt;br/&gt;&lt;br/&gt;let random_couleur () =&lt;br/&gt;  let n = Random.int 3 in&lt;br/&gt;    if n = 0 then Bleu else if n = 1 then Blanc else Rouge&lt;br/&gt;&lt;br/&gt;let execution (prisonniers : prisonnier list) =&lt;br/&gt;  let prisonniers =&lt;br/&gt;    List.map (fun p -&amp;gt; p, random_couleur ()) prisonniers&lt;br/&gt;  in&lt;br/&gt;  let rec morts avant = function&lt;br/&gt;    | (p,c)::l -&amp;gt;&lt;br/&gt;        let reponse = p (List.map snd l) avant in&lt;br/&gt;          (if reponse = c then 0 else 1) +&lt;br/&gt;          (morts (reponse::avant) l)&lt;br/&gt;    | [] -&amp;gt; 0&lt;br/&gt;  in&lt;br/&gt;    morts [] prisonniers&lt;/pre&gt;&lt;br/&gt;Amusez-vous bien, et postez vos r&amp;eacute;ponses dans le langage de votre choix...&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Edit&lt;/b&gt;: une autre &amp;eacute;nigme beaucoup plus &amp;eacute;tonnante, que Florent et Julien m'ont racont&amp;eacute;e. Vous avez devant vous sur une table 7 pi&amp;egrave;ces c&amp;ocirc;t&amp;eacute; pile et 19 pi&amp;egrave;ces c&amp;ocirc;t&amp;eacute; face. Mais vos yeux sont band&amp;eacute;s (et vous portez des moufles) de sorte que vous ne pouvez savoir l'&amp;eacute;tat d'une pi&amp;egrave;ce. Tout ce que vous pouvez faire c'est en retourner certaines, autant que vous voulez, et les d&amp;eacute;placer. Il vous faut les s&amp;eacute;parer en deux groupes qui contiennent le m&amp;ecirc;me nombre de pi&amp;egrave;ces c&amp;ocirc;t&amp;eacute; pile.&lt;br/&gt;&lt;br/&gt;La solution sera une fonction qui prend le nombre de piles et le nombre de faces (je vous aide bien en g&amp;eacute;n&amp;eacute;ralisant) et qui renvoie deux tableaux de taille &lt;code&gt;piles+faces&lt;/code&gt;: le premier indique les indices des pi&amp;egrave;ces choisies, le second indique les pi&amp;egrave;ces qu'il faut retourner. La fonction sera pass&amp;eacute;e &amp;agrave; la fonction de test suivantes:&lt;br/&gt;&lt;pre&gt;(** Perfect Fisher-Yates shuffle&lt;br/&gt;  * (http://www.nist.gov/dads/HTML/fisherYatesShuffle.html). *)&lt;br/&gt;let randomize a =&lt;br/&gt;  let permute i j =&lt;br/&gt;    let tmp = a.(i) in&lt;br/&gt;      a.(i) &amp;lt;- a.(j);&lt;br/&gt;      a.(j) &amp;lt;- tmp&lt;br/&gt;  in&lt;br/&gt;  let l = Array.length a in&lt;br/&gt;    if l&amp;gt;=2 then&lt;br/&gt;      for i=0 to l-2 do&lt;br/&gt;        permute i (i + Random.int (l-i))&lt;br/&gt;      done&lt;br/&gt;&lt;br/&gt;let test nb_piles nb_faces joueur =&lt;br/&gt;  let choix,retourne = joueur nb_piles nb_faces in&lt;br/&gt;  let n = nb_piles + nb_faces in&lt;br/&gt;  let a = Array.init n (fun i -&amp;gt; i&amp;lt;nb_piles) in&lt;br/&gt;  (* Nombre de piles &amp;agrave; gauche - nombre de piles &amp;agrave; droite *)&lt;br/&gt;  let d = ref 0 in&lt;br/&gt;    randomize a ;&lt;br/&gt;    for i = 0 to n-1 do&lt;br/&gt;      if retourne.(i) then a.(i) &amp;lt;- not a.(i) ;&lt;br/&gt;      d := (if choix.(i) then (+) else (-)) !d (if a.(i) then 1 else 0)&lt;br/&gt;    done ;&lt;br/&gt;    !d = 0&lt;/pre&gt;&lt;br/&gt;A suivre: les solutions comment&amp;eacute;es...</content><id>https://misterpingouin.blogspot.com/2007/11/enigme.html</id><title type="text">Enigmes</title><updated>2007-11-21T14:33:00-00:00</updated><author><name>mrpingouin</name></author></entry><entry><link href="https://misterpingouin.blogspot.com/2007/07/application.html" rel="alternate"/><contributor><uri>http://www.blogger.com/feeds/17133288/posts/default/-/ocaml</uri><name>dbaelde</name></contributor><content type="html">Je suis en conf&amp;eacute;rence, ce qui me laisse plein de temps pour bosser pendant la plupart des expos&amp;eacute;s... Bremen est plut&amp;ocirc;t une jolie ville, le campus est super agr&amp;eacute;able et il fait beau. Blogger s'est mis &amp;agrave; me parler en Allemand. Ici j'ai vu Al. Bundy, pour ceux qui connaissent...&lt;br/&gt;&lt;br/&gt;Bon sinon, un petit exemple simple m'est venu pour montrer que l'application en Caml n'est pas aussi simple qu'on le pense en pr&amp;eacute;sence d'arguments optionels. L'&amp;eacute;quation &lt;code&gt;f x y&lt;/code&gt; = &lt;code&gt;(f x) y&lt;/code&gt;, n'est pas toujours v&amp;eacute;rifi&amp;eacute;e. En fait, on n'a pas seulement une notion d'application mais bien une multi-application. Si je parle de &amp;ccedil;a c'est pour mettre au clair l'origine de la multi-abstraction du langage de script de liquidsoap.&lt;br/&gt;&lt;br/&gt;&lt;pre&gt;# let f ?(a=false) () = a ;;&lt;br/&gt;val f : ?a:bool -&amp;gt; unit -&amp;gt; bool = &lt;fun&gt;&lt;br/&gt;# f () ~a:true ;;&lt;br/&gt;- : bool = true&lt;br/&gt;# (f ()) ~a:true ;;&lt;br/&gt;This expression is not a function, it cannot be applied&lt;br/&gt;# f () ;;&lt;br/&gt;- : bool = false&lt;/fun&gt;&lt;/pre&gt;</content><id>https://misterpingouin.blogspot.com/2007/07/application.html</id><title type="text">Application</title><updated>2007-07-18T10:21:00-00:00</updated><author><name>mrpingouin</name></author></entry></feed>