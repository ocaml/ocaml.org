---
title: "Mise en bo\xEEte"
description:
url: https://misterpingouin.blogspot.com/2009/06/mise-en-boite.html
date: 2009-06-04T11:38:00-00:00
preview_image:
authors:
- mrpingouin
source:
---

Depuis un bon moment, liquidsoap dispose d'un langage de configuration/script fonctionnel, fortement et statiquement typ&eacute;, qui inf&egrave;re des types &agrave; la ML, le tout &agrave; l'insu de la plupart des utilisateurs. Pour liquidsoap 1.0 nous irons plus loin dans l'utilisation de concepts avanc&eacute;s avec (un peu) de vrai polymorphisme.<br/><br/><em>J'ai <b>&eacute;dit&eacute;</b> ce post deux ou trois dans les jours suivant sa publication. Peut-&ecirc;tre que le blog n'&eacute;tait pas le format id&eacute;al.</em><br/><br/><b>Pourquoi?</b><br/><br/>Dans une conf liquidsoap, les fonctions sont parfois utiles pour &eacute;viter de recopier du code, ou pour sp&eacute;cifier une action &agrave; effectuer en r&eacute;action &agrave; certains &eacute;venements. Mais au coeur m&ecirc;me de la g&eacute;n&eacute;ration du flux, les fonctions sont utilis&eacute;es pour repr&eacute;senter les transitions entre pistes audio. (D&eacute;tails <a href="http://www.lix.polytechnique.fr/~dbaelde/productions/pool/jfla08.pdf">ici</a>.)<br/><br/>Cette m&ecirc;me notion de transition pose des probl&egrave;mes quant &agrave; l'&eacute;coulement du temps. Actuellement dans liquidsoap, toutes les sources de flux audio &eacute;voluent &agrave; la m&ecirc;me vitesse, cadenc&eacute;es par une unique horloge. Pour calculer une transition entre deux pistes d'une m&ecirc;me source, l'op&eacute;rateur <code>cross</code> doit obtenir en avance le d&eacute;but de la piste suivante, et le combiner avec la fin de la piste en cours. Cela requiert d'acc&eacute;l&eacute;rer cette source.<br/><br/>L'impl&eacute;mentation actuelle n'est pas une solution: Les op&eacute;rateurs qui en ont besoin simulent l'action de l'horloge aupr&egrave;s de leur source, afin de l'acc&eacute;l&eacute;rer. Cela marche souvent, mais il se peut que deux op&eacute;rateurs lisent une m&ecirc;me source &agrave; des vitesses diff&eacute;rentes. Le r&eacute;sultat est inattendu, &agrave; &eacute;viter. Notre mission est d'&eacute;viter cela statiquement, avant m&ecirc;me la construction des sources. Nous allons donc attacher un param&egrave;tre au type des sources, qui repr&eacute;sentera son horloge, et sp&eacute;cifier dans le type des op&eacute;rateurs s'ils requi&egrave;rent des horloges particuli&egrave;res.<br/><br/>S'il est assez facile de bricoler le syst&egrave;me de type pour obtenir l'effet d&eacute;sir&eacute;, il faut d'abord identifier les concepts &quot;logiques&quot; mis en jeux. J'ai honte, mais &ccedil;a m'a pris du temps, car j'ai <a href="http://savonet.rastageeks.org/wiki/FutureBoxes">commenc&eacute;</a> par chercher dans des contr&eacute;es exotiques alors que c'est assez connu, bien que pointu.<br/><br/><b>Polymorphisme</b><br/><br/>Le polymorphisme est la possibilit&eacute; de former une quantification universelle sur les types. Si on a un objet de type <code>&forall;x. x-&gt;x</code>, on peut l'instantier en une fonction de type <code>int-&gt;int</code> aussi bien que <code>(bool-&gt;bool)-&gt;(bool-&gt;bool)</code>.<br/><br/>Dans les langages d&eacute;riv&eacute;s de ML, le polymorphisme est limit&eacute; &agrave; une quantification externe. On peut avoir <code>&forall;x. x-&gt;x</code> mais pas <code>(&forall;x. x-&gt;x)-&gt;int-&gt;int</code>. Le polymorphisme dans toute sa g&eacute;n&eacute;ralit&eacute;, par exemple dans le syst&egrave;me F, rend en effet l'inf&eacute;rence de type ind&eacute;cidable.<br/><br/>OCaml permet cependant d'aller un peu plus loin. La cl&eacute; est que la cr&eacute;ation d'un type polymorphe doit &ecirc;tre explicite dans le programme (cf. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.4858">ce papier</a>), par exemple associ&eacute;e &agrave; la cr&eacute;ation d'un enregistrement. Consid&eacute;rons la signature suivante:<br/><div class="code">(** Une source associ&eacute;e &agrave; l'horloge 'a *)<br/>type 'a src<br/><br/>(** Une fonction qui renvoie une source qu'on peut<br/>  * associer &agrave; n'importe quelle horloge. *)<br/>type boxed = { c : 'a. unit -&gt; 'a src }<br/><br/>(** Cet op&eacute;rateur prend une source en bo&icirc;te,<br/>  * cela pourrait &ecirc;tre le cross() de liquidsoap. *)<br/>val box  : boxed -&gt; 'a src<br/><br/>val leaf : unit -&gt; 'a src            (* en gros, single *)<br/>val node : 'a src list -&gt; 'a src     (* en gros, fallback *)<br/></div><br/><br/>Voyons voir ce qu'on peut et ne peut pas faire avec ce syst&egrave;me. On peut cr&eacute;er un certain nombre de sources avec <code>leaf ()</code> initialement, elles auront le type <code>'_a src</code>: leur horloge est ind&eacute;finie, mais pas g&eacute;n&eacute;ralisable. On est content de ne pas voir de <code>'a src</code>: cela correspondrait &agrave; une source qui peut se brancher sur toutes les horloges <em>&agrave; la fois</em>, non-sens. (C'est aussi pour cela qu'on n'a pas &eacute;crit <code>boxed = { c : 'a. 'a src }</code>, on n'aurait jamais pu construire de bo&icirc;te.)<br/><br/>On peut passer une source de type <code>'_a src</code> &agrave; notre op&eacute;rateur <code>node</code>, on obtient une autre source &agrave; la m&ecirc;me horloge <code>'_a</code>. Si on passe deux sources &agrave; <code>node</code>, le syst&egrave;me de type requiert que leurs horloges soient les m&ecirc;mes (des inconnues <code>'_a</code> et <code>'_b</code> sont unifi&eacute;es).<br/><br/>Maintenant, tentons de former des bo&icirc;tes:<br/><div class="code">let b = box { c = leaf }<br/>(* Gagn&eacute;:<br/> * une bo&icirc;te qui nous donne une nouvelle feuille &agrave; chaque fois,<br/> * horloge au choix. *)<br/><br/>let a = leaf ()<br/>let b = box { c = fun () -&gt; b }<br/>(* Rat&eacute;, erreur de type:<br/> * la source a est de type '_a src,<br/> * la fonction (fun () -&gt; b) est de type unit -&gt; '_a src,<br/> * qu'on ne peut g&eacute;n&eacute;raliser en 'a. unit -&gt; 'a src. *)<br/><br/>let b =<br/>  box { c = fun () -&gt;<br/>              let a = leaf () in<br/>                 node [a;a] }<br/>(* Gagn&eacute;, on a une bo&icirc;te qui nous renvoie une source compos&eacute;e,<br/> * dont on peut choisir l'horloge. *)<br/></div><br/><br/>On tient clairement le bon concept: le polymorphisme assure que l'horloge peut &ecirc;tre choisie. En particulier on va pouvoir cr&eacute;er des nouvelles horloges d&eacute;di&eacute;es &agrave; certaines sources (et leurs sous-sources). Reste &agrave; transf&eacute;rer ce petit exemple en quelquechose d'agr&eacute;able &agrave; utiliser dans liquidsoap.<br/><br/><b>Liquidsoap 1.0</b><br/><br/>Actuellement dans liquidsoap, on &eacute;crit des choses comme:<br/><div class="code">music = playlist(&quot;list.txt&quot;)<br/>backup = single(&quot;default.ogg&quot;)<br/>source = fallback([music,backup])<br/>transition = fun (a,b) -&gt; ...<br/>source = cross(transition,source)<br/>output.icecast(source)<br/></div><br/><br/>En collant au style de notre exemple en OCaml, nous devrions r&eacute;&eacute;crire les choses ainsi:<br/><div class="code">transition = fun (a,b) -&gt; ...<br/>source =<br/>  cross(transition, {<br/>    music = playlist(&quot;list.txt&quot;)<br/>    backup = single(&quot;default.ogg&quot;)<br/>    fallback([music,backup])<br/>  })<br/>output.icecast(source)<br/></div><br/><br/>C'est trop lourd, et ma solution ne va diff&eacute;rer que d'un epsilon du style courant:<br/><div class="code">music = playlist(&quot;list.txt&quot;)<br/>backup = single(&quot;default.ogg&quot;)<br/>source = fallback([music,backup])<br/>transition = fun (a,b) -&gt; ...<br/>source = cross(transition,{source})<br/>output.icecast(source)<br/></div><br/><br/>Un point cl&eacute; qui permet cette simplification est qu'on n'a besoin que d'une partie du polymorphisme: on veut la g&eacute;n&eacute;ricit&eacute;, mais une seule fois. Pas besoin d'une fonction qui &agrave; chaque appel pond une source, comme dans l'exemple en Caml. Il suffit d'une seule source, tant que son horloge est g&eacute;n&eacute;rique.<br/><br/>Je pense qu'on ne peut pas se passer ais&eacute;ment du marqueur <code>{source}</code> qui indique qu'on g&eacute;n&eacute;ralise cette source. Il me semble acceptable de demander &agrave; l'utilisateur de marquer le coup quand il utilise cette notion complexe. (Par contre il va nous falloir choisir une syntaxe qui ne rentre pas en conflit avec l'actuel <code>{...}</code>, raccourci pour <code>fun () -&gt; ...</code>.)<br/><br/><b>Comment &ccedil;a marche</b><br/><br/>J'ai une <a href="http://www.lix.polytechnique.fr/~dbaelde/productions/pool/boxes.ml.html">impl&eacute;mentation</a> en OCaml qui me semble transposable &agrave; liquidsoap.<br/><br/>Comment OCaml v&eacute;rifie-t-il que <code>{ c = fun () -&gt; blah }</code> est bien typ&eacute;? Il introduit une nouvelle variable de type <code>n</code> pour repr&eacute;senter le <code>'a</code> de <code>'a. unit -&gt; 'a src</code>, et v&eacute;rifie qu'on peut donner le type <code>n src</code> &agrave; <code>blah</code>.<br/><br/>Nous allons faire la m&ecirc;me chose, mais dans le d&eacute;sordre, pour permettre le genre d'&eacute;criture promis plus haut. Pour former une bo&icirc;te (un type universel) sur une source, il faut que son horloge soit encore ind&eacute;termin&eacute;e. On v&eacute;rifie cela en unifiant le type de cette source avec <code>n src</code> pour une nouvelle variable de type <code>n</code> comme OCaml faisait. Et une fois qu'on a ainsi r&eacute;ussit &agrave; former une bo&icirc;te, on affecte cette variable &agrave; type &agrave; une valeur interdite <code>Boom</code> pour emp&ecirc;cher son utilisation ailleurs. Au lieu de cr&eacute;er les sources dans une zone prot&eacute;g&eacute;e, on les cr&eacute;e en dehors, et on les y affecte apr&egrave;s coup, ce qui rend alors leur horloge d&eacute;nu&eacute;e de sens &agrave; l'ext&eacute;rieur.<br/><br/>Un difficult&eacute; essentielle du polymorphisme vient du fait que pour inf&eacute;rer, on a besoin de savoir quel type universel on forme. Dans le cas de liquidsoap ma solution est tr&egrave;s simple: on ne forme que <code>&forall;x. x src</code>. On pourrait avoir d'autres types polymorphes, mais chacun aurait son constructeur particulier.<br/><br/>Ces m&eacute;canismes fonctionnent bien sur quelques exemples disponibles dans mon code:<br/><div class="code">ex0 = single ()<br/>ex0 : '_a src   # pas de g&eacute;n&eacute;ralisation, c'est comme avec ref<br/><br/>ex00 = let x = single () in {x}<br/>ex00 : 'a. 'a src<br/><br/>ex1 = fun (x) -&gt; cross(x)<br/>ex1 : 'b. ('a. 'a src) -&gt; 'b src<br/><br/>ex4 = fun (_) -&gt; cross({single(&quot;blah.ogg&quot;)})<br/>ex4 : 'a.'b. 'a -&gt; 'b src<br/></div><br/><br/>Un exemple plus subtil est <code>ex2 = fun (x) -&gt; {x}</code>, ou la variation <code>ex4 = fun (x) -&gt; cross({x})</code> qui se rapproche de <code>ex1</code>. Ici une bo&icirc;te est form&eacute;e sur l'argument de la fonction, qui doit donc &ecirc;tre une source. Ce genre de construction est probl&eacute;matique: la source doit &ecirc;tre introduite avant son horloge. En pratique, cela se traduit par l'impossibilit&eacute; de former le type de la fonction o&ugrave; devrait apparaitre le symbole interdit: <code>Boom src -&gt; 'a. 'a src</code>.
