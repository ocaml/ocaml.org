---
title: Illumination
description:
url: https://misterpingouin.blogspot.com/2009/07/illumination.html
date: 2009-07-16T06:13:00-00:00
preview_image:
authors:
- mrpingouin
source:
---

For some reason, I've found myself implementing bits of a text-mode <a href="http://en.wikipedia.org/wiki/Roguelike">rogue-like</a> game. In a nutshell, this is a turn-based kind of game where the player moves on a grid which usually depicts a dungeon or a cave. Some cells of that grid/map might contain a wall/rock, in which case the player cannot see or walk through them. All this is rather straightforward to implement, but the computation of what the player sees deserves some attention.<br/><br/>I started thinking of casting rays, but only found clumsy, costly solutions. So I did a little research. Some people (including <a href="http://www.google.com/codesearch/p?hl=fr&amp;sa=N&amp;cd=2&amp;ct=rc#ds1vKBNOpqs/stone_soup-0.2.5-src/source/view.cc%26q=monstuff%20crawl%26l=994">crawl</a>) actually developed algorithms along these lines for computing what is called a <a href="http://roguebasin.roguelikedevelopment.org/index.php?title=Permissive_Field_of_View">permissive field of view</a>: <blockquote>A destination square is visible from a source square if there is any unobstructed line from some point in the source square to some point in the destination square.</blockquote><br/>It's apparently a modern notion of field of view, that has one advantage over older techniques: it ensures symmetry, i.e., if I can see you, you can see me.<br/><br/>The same article on roguebasin points to several algorithms, including the one implemented in crawl. They all seemed unsatisfyingly complicated to me. I eventually came up with a different idea that looks good and ensures symmetry. It might have been considered already and discarded for some of its funny aspects, but those are interested to look at.<br/><br/>The basic idea is to forget about those lines. We are talking about a discrete universe, let's try to make its physics discrete too. <a href="http://en.wikipedia.org/wiki/Geometrical_optics">Geometrical optics</a> is only a convenient metaphor, that is justified by more elementary principles such as <a href="http://en.wikipedia.org/wiki/Fermat's_principle">Fermat's</a>: <blockquote>The path taken between two points of a ray of light is the path that can be traversed in the least time.</blockquote><br/>This is in fact a definition of a ray of light that we can take literally in our discrete rogue world: <blockquote>A cell is visible from another if one of the shortest paths between them is unobstructed.</blockquote><br/><br/>Let's look at a simple example. For now, suppose that the movements are only allowed along the axis (no diagonals):<br/><center><pre>.# <br/>@#y<br/>.x.</pre></center><br/>The player is represented by <code>@</code>, and <code>#</code> are walls/rocks. The cell marked <code>y</code> is not visible: it is at distance 2, there is only one path of length 2 that connects it to the player but it is obstructed. Cell <code>x</code> is also at distance 2, but it is visible since one of the two paths of length 2 that connects it to the player is not obstructed.<br/><br/>A funny thing happens when you consider the traditional rogue movements which include diagonals: cell <code>y</code> becomes visible! Indeed, the light can take a path of length 2 through <code>x</code>.<br/><br/>I would tend to adopt rules where the topology is the same for players and light. Either embrace the diagonal movements but accept the surprising effect on light, or remove them both for the light and the player. I chose the less experimental way for now. But it is also possible to use different topologies for the two entities.<br/><br/>To finish, I will give the last reason why I like this solution: the code is stupid simple. Assuming that the radius of the field of view will always be within a fixed bound, we can compute once and for all the map of shortest paths with their dependencies.<br/><pre>(** The maps will be used to associate<br/>  * the coordinates of the destination of a path<br/>  * to the lists of the coordinates of possible previous step<br/>  * in shortest paths leading to that destination. *)<br/>module M = Map.Make (struct type t = int*int let compare = compare end)<br/><br/>let neighbors (x,y) =<br/>  [ x-1,y ;<br/>    x,y-1 ;<br/>    x+1,y ;<br/>    x,y+1 ]<br/><br/>let shortest_paths max =<br/>  (** Map of distances to the center of the matrix. *)<br/>  let dist = Array.make_matrix (2*max+1) (2*max+1) max_int in<br/>  (** At each step we compute the shortests paths to cells<br/>    * at distance [d=n+1] from those for distance [n]. *)<br/>  let step d paths_n =<br/>    M.fold<br/>      (fun (x,y) _ m -&gt;<br/>         List.fold_left<br/>           (fun m (x',y') -&gt;<br/>              if dist.(max+x').(max+y') &lt; d then<br/>                (* Seen in a previous iteration. *)<br/>                m<br/>              else if dist.(max+x').(max+y') = d then<br/>                (* We already found a path of length n+1,<br/>                 * but we need to keep track of this new one too. *)<br/>                M.add (x',y') ((x,y)::M.find (x',y') m) m<br/>              else begin<br/>                (* First time we see it: first shortest path. *)<br/>                dist.(max+x').(max+y') &lt;- d ;<br/>                M.add (x',y') [x,y] m<br/>              end)<br/>           m<br/>           (neighbors (x,y)))<br/>      paths_n<br/>      M.empty<br/>  in<br/>  let rec aux d frontiers =<br/>    if d=max then frontiers else<br/>      aux (d+1) (step d (List.hd frontiers) :: frontiers)<br/>  in<br/>    List.rev (aux 1 [M.add (0,0) [] M.empty])<br/></pre><br/><br/>Then, it only remains to parse dependencies:<br/><pre>(** Takes a radius (d) and returns a field of view function<br/>  * for that radius. *)<br/>let fov d =<br/>  let frontiers = shortest_paths d in<br/>    (* The field of view function,<br/>     * which takes a function and calls it on each visible cell.<br/>     * The function [f] returns whether a cell is transparent or not. *)<br/>    fun f -&gt;<br/>      let transparent = Array.make_matrix (2*d+1) (2*d+1) false in<br/>        transparent.(d).(d) &lt;- true ;<br/>        List.iter<br/>          (fun frontier -&gt;<br/>             M.iter<br/>               (fun (x',y') deps -&gt;<br/>                  if<br/>                    List.exists (fun (x,y) -&gt; transparent.(d+x).(d+y)) deps<br/>                  then<br/>                    transparent.(d+x').(d+y') &lt;- f x' y')<br/>               frontier)<br/>          (List.tl frontiers)<br/></pre><br/><br/>Hurray to (impure) functional programming! I leave it to you to glue this to whatever testing code you want. I'll finish with &quot;screenshots&quot;.<br/><br/>Without diagonal moves, notice that it is possible to see through a wall on a diagonal:<br/><center><pre>              .<br/>       .      ..<br/>      ..    ##...<br/>     #.. ###...# .<br/>     #..#......##.#<br/>     #.....@......#<br/>     #...##........<br/>     ...#.........<br/>      ###........<br/>        #.......<br/>        ..####.<br/>         .<br/></pre></center><br/><br/>With diagonal moves, we now have shadows along the diagonals, but we can see around walls placed along the axis:<br/><center><pre>        ..#..#...<br/>         .......<br/>   .######.....<br/>   ...........<br/>   .##.......<br/>    #.......#<br/>    #.......####   #<br/>    #..........## ..<br/>   .##..##.@....#...<br/>   #...  ##...##..##<br/>   ###    .......###<br/>         ...........<br/>        ............<br/>       .............<br/>      ###...........<br/>        ............<br/>       .##.####.....<br/></pre></center>
