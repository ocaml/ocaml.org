---
title: "Quel effet \xE7a fait"
description:
url: https://misterpingouin.blogspot.com/2010/02/quel-effet-ca-fait.html
date: 2010-02-08T19:04:00-00:00
preview_image:
authors:
- mrpingouin
source:
---

Quelle diff&eacute;rence entre <code>a&rarr;b&rarr;c</code> et <code>a&rarr;b&rarr;c</code>? Pour le savoir, lisez ce qui suit.<br/><br/>De temps en temps, je regarde un article scientifique, ou un bout de code, et je n'en suis pas satisfait. Un truc me chiffonne, &ccedil;a peut se r&eacute;parer, mais ya autre chose qui cloche, et au fond c'est tout bancal, &ccedil;a n'en finit pas, et il vaut mieux tout remettre &agrave; plat. Ceci est arriv&eacute; r&eacute;cemment dans liquidsoap avec le module de d&eacute;codage de fichier. Ce n'est pas int&eacute;ressant de d&eacute;tailler, il y a juste un point dont je voulais parler. Mais avant, je trouve que c'est important de dire qu'il faut remettre les choses &agrave; plat de temps en temps.<br/><br/>Donc, il s'agit de d&eacute;codage. Premi&egrave;re question: qu'est ce que c'est un d&eacute;codeur? J'ai mis un peu de temps &agrave; essayer plusieurs styles, pour finalement d&eacute;cider <code>input -&gt; buffer -&gt; unit</code>, une fonction qui prend en entr&eacute;e une m&eacute;thode pour lire des donn&eacute;es, et un buffer pour &eacute;crire le r&eacute;sultat du d&eacute;codage, et qui ne renvoie rien mais remplit le buffer un peu plus &agrave; chaque fois qu'on l'appelle.<br/><br/>A c&ocirc;t&eacute; de cette notion tr&egrave;s g&eacute;n&eacute;rique on a des notions plus sp&eacute;cialis&eacute;es comme le <code>type file_decoder = { fill : Frame.t -&gt; unit ; close : unit -&gt; unit }</code>. C'est un enregistrement qui contient une fonction de remplissage de flux (on lui donne une frame (un morceau de flux) &agrave; remplir) et une fonction de fermeture/nettoyage o&ugrave; l'on lib&egrave;re les ressources allou&eacute;es pour le d&eacute;codage.<br/><br/>Ceci &eacute;tant d&eacute;cid&eacute;, j'&eacute;cris un bout de code g&eacute;n&eacute;rique qui emballe un d&eacute;codeur pour construire un d&eacute;codeur_de_fichier:<pre>let file_decoder filename decoder =<br/>  let input = input_from_file filename in<br/>  let buffer = create_buffer () in<br/>  let fill frame =<br/>    while not_enough_data_in buffer do<br/>      decoder input buffer<br/>    done ;<br/>    fill_frame_from_buffer frame buffer<br/>  in<br/>    { fill = fill ; close = fun () -&gt; close input }<br/></pre><br/>Vous me suivez? Maintenant, j'impl&eacute;mente un d&eacute;codeur, pour le format MP3 en utilisant la biblioth&egrave;que mad:<pre>let create_decoder input =<br/>  let resampler = create_resampler () in<br/>  let mad_stream = Mad.openstream input in<br/>    (fun buffer -&gt;<br/>       let data = Mad.decode_frame_float mad_stream in<br/>       let sample_freq,_,_ = Mad.get_output_format fd in<br/>       let content,length =<br/>         resampler ~audio_src_rate:(float sample_freq) data<br/>       in<br/>         put_audio_in_buffer buffer content length)<br/></pre><br/>PAF! Vous voyez le bug? Je parie que non, en tout cas moi je l'avais rat&eacute;. J'ai r&eacute;ussi &agrave; ne pas &ecirc;tre d'accord avec moi m&ecirc;me, penser <code>a&rarr;b&rarr;c</code> ici et <code>a&rarr;b&rarr;c</code> l&agrave;!...<br/><br/>Le probl&egrave;me, c'est <em>les effets</em>. En math&eacute;matiques, une fonction prend un argument et renvoie un r&eacute;sultat. On ne sait pas comment &ccedil;a se passe &quot;dedans&quot;, en tout cas &ccedil;a n'interagit pas sur le &quot;dehors&quot;, et &ccedil;a se passe pareil &agrave; chaque fois: m&ecirc;me entr&eacute;e, m&ecirc;me sortie. En informatique, c'est bien plus compliqu&eacute;. La fonction interagit avec le monde, elle peut afficher quelquechose &agrave; l'&eacute;cran, elle peut aller chercher un r&eacute;sultat sur internet, dans un fichier, ou simplement dans une case m&eacute;moire qu'elle partage avec d'autres fonctions. On est ainsi habitu&eacute; &agrave; avoir tout un paquet de fonctions de type <code>a&rarr;b</code>, puisqu'il ne s'agit pas seulement de prendre un objet de type <code>a</code> pour calculer un objet de type <code>b</code> mais aussi potentiellement de se livrer &agrave; tout un tas d'interactions avec le monde.<br/><br/>Mon code utilise cela, mais se prend les pieds dedans. Ce qui est joli, c'est que j'ai une &quot;solution&quot;. Mais voyons d'abord le probl&egrave;me. Notre d&eacute;codeur prend un canal d'entr&eacute;e (<code>input</code>), un canal de sortie (<code>buffer</code>), et est suppos&eacute; avoir comme <em>effet</em> de lire un peu de donn&eacute;es en entr&eacute;e, de les convertir et les &eacute;crire en sortie. Il ne renvoie rien d'utile (<code>unit</code>), tout son interet r&eacute;side dans l'effet; si on l'appelle un assez grand nombre de fois, on finit par avoir assez de donn&eacute;es dans notre buffer -- c'est ce qu'on a fait plus haut. On peut cacher un certains nombres d'informations dans le d&eacute;codeur, c'&eacute;tait mon intention, par exemple j'y ai allou&eacute; un <em>resampler</em> pour convertir les donn&eacute;es vers la bonne fr&eacute;quence d'&eacute;chantillonage: cet outil doit &ecirc;tre (et est bien) cr&eacute;e une fois et une seule pour chaque d&eacute;codeur.<br/><br/>Ce resampler maintient un &eacute;tat interne, tout comme le d&eacute;codeur mad (<code>mad_stream</code>). Allouer ces objets est aussi un effet! Mais &agrave; quel moment a-t-il lieu? Le type ne l'indique pas: dans <code>input-&gt;buffer-&gt;unit</code>, apr&egrave;s quel argument un effet peut-il avoir lieu? Dans le code de <code>file_decoder</code> j'utilise un d&eacute;codeur comme si le seul effet &eacute;tait le d&eacute;codage, qui a lieu une fois qu'on a renseign&eacute; l'input et l'output. Mais dans le code du d&eacute;codeur MP3, pas le choix, je m'autorise un effet entre le moment o&ugrave; on m'a donn&eacute; l'input et le moment o&ugrave; on me donne le d&eacute;codeur. R&eacute;sultat, quand on utilise <code>file_decoder</code> avec le <code>create_decoder</code> MP3, on a un son tout hach&eacute;, car le d&eacute;codeur et le resampleur sont reinitialis&eacute;s sans arr&ecirc;t, ce qui provoque la perte d'une partie des donn&eacute;es m&eacute;moris&eacute;es dans leurs buffers internes.<br/><br/>Ces probl&egrave;mes sont tr&egrave;s vicieux, et sont toujours un sujet de recherche active. Mais concr&egrave;tement, que peut-on y faire avec les outils d'aujourd'hui? Documenter, esp&eacute;rer que tout le monde se comprend? Pas terrible, j'ai r&eacute;ussi &agrave; &ecirc;tre en d&eacute;saccord avec moi-m&ecirc;me sur une courte p&eacute;riode de temps. Comme d'habitude, <em>ce serait bien si le syst&egrave;me de type nous servait de garde fou</em>.<br/><br/>En logique, la notion de focalisation (<em>focusing</em>) est li&eacute;e &agrave; la question des effets. Une formule logique est vue comme un jeu entre deux joueurs: un qui prouve l'autre qui r&eacute;fute, ou encore, l'environnement qui fournit une entr&eacute;e (argument) et la machine qui renvoie une sortie (valeur de retour). Les connecteurs logiques sont attribu&eacute;s &agrave; l'un ou &agrave; l'autre joueur: dans <code>(int*int)&rarr;(int*int)</code> c'est d'abord l'environnement qui donne un argument, directement compos&eacute; de deux entiers; puis la machine calcule un r&eacute;sultat, directement compos&eacute; de deux entiers. Ici je dis directement, car on ne peut pas demander une r&eacute;ponse partielle &agrave; la machine, tout ceci vient d'un coup, une unique r&eacute;ponse &agrave; une seule question. La dynamique associ&eacute;e au type <code>int&rarr;int&rarr;(int*int)</code> est exactement la m&ecirc;me: il n'y a pas deux questions &agrave; l'environnement, mais une seule, les deux entiers en entr&eacute;e arrivent d'un coup. L&agrave; dedans, les seuls effets ne peuvent donc se situer qu'&agrave; l'interface entre les deux joueurs, dans le calcul qui se passe entre une question et une r&eacute;ponse.<br/><br/>Commen&ccedil;ons &agrave; redescendons sur terre. Pour introduire la possibilit&eacute; d'un effet, en focalisation, on peut introduire un d&eacute;lai. Par exemple, si on veut une paire d'entiers paresseuse (dont le contenu n'est calcul&eacute; que si n&eacute;cessaire), on retarde le calcul des <code>int</code>: <code>(unit-&gt;int)*(unit-&gt;int)</code>. Dans l'autre sens, on peut aussi vouloir retarder le moment o&ugrave; un argument est pass&eacute;, par exemple avec <code>a-&gt;(unit*(b-&gt;c))</code>... c'est ce qu'il nous faut!<br/><br/>On la refait avec un d&eacute;lai autour du d&eacute;codeur, impl&eacute;ment&eacute; non pas comme <code>(unit*...)</code> mais plus agr&eacute;ablement avec un type variant:<pre>type decoder = Decoder of (buffer -&gt; unit)<br/>type file_decoder = input -&gt; decoder<br/><br/>let file_decoder filename decoder =<br/>  let input = input_from_file filename in<br/>  let buffer = create_buffer () in<br/>  let Decoder f = decoder input in<br/>  let fill frame =<br/>    while not_enough_data_in buffer do<br/>      f buffer<br/>    done ;<br/>    fill_frame_from_buffer frame buffer<br/>  in<br/>    { fill = fill ; close = fun () -&gt; close input }<br/><br/>let create_decoder input =<br/>  let resampler = create_resampler () in<br/>  let mad_stream = Mad.openstream input in<br/>    Decoder (fun buffer -&gt;<br/>       let data = Mad.decode_frame_float mad_stream in<br/>       let sample_freq,_,_ = Mad.get_output_format fd in<br/>       let content,length =<br/>         resampler ~audio_src_rate:(float sample_freq) data<br/>       in<br/>         put_audio_in_buffer buffer content length)<br/></pre><br/>Le code du d&eacute;codeur MP3 n'a chang&eacute; que d'un iota, mais cela suffit &agrave; forcer sa bonne utilisation dans <code>file_decoder</code>, c'est &agrave; dire &agrave; passer l'input une fois pour toute, et ne plus passer que le buffer dans les appels suivants. Vraiment? Non, &agrave; vrai dire, on peut toujours se prendre les pieds dedans, ne serait-ce que parce que c'est possible de traduire entre le vieux type de d&eacute;codeur et le nouveau, en violant ainsi la logique qu'on a tent&eacute; de forcer. Mais en pratique, ce petit garde fou pousse &agrave; faire naturellement la bonne chose, ou au moins &agrave; se poser la question.<br/><br/>Tout est bien qui fini bien. Cette histoire pourrait aussi s'intituler &quot;&agrave; quoi diable pourrait bien servir un type variant avec un seul constructeur?&quot; Ou encore, &quot;c'est fou comme de belles id&eacute;es th&eacute;oriques ont du sens m&ecirc;me en dehors de leur strict cadre th&eacute;orique.&quot;
