---
title: Random.self_init
description:
url: https://misterpingouin.blogspot.com/2010/10/randomselfinit.html
date: 2010-10-20T13:15:00-00:00
preview_image:
authors:
- mrpingouin
source:
---

Maintenant que je travaille un peu dans le domaine de la s&eacute;curit&eacute;, je pense notamment aux g&eacute;n&eacute;rateurs de nombres al&eacute;atoires. Apr&egrave;s quelques lectures <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator">sur</a> <a href="http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">le sujet</a>, je me suis demand&eacute; comment fonctionnait le module <code>Random</code> de Caml.<br/>
<br/>
Il y a s&ucirc;rement beaucoup de choses &agrave; dire, mais mon attention a &eacute;t&eacute; retenue par un truc simple: <code>self_init</code> initialise le g&eacute;n&eacute;rateur de fa&ccedil;on tr&egrave;s simple, &agrave; partir de l'heure et de l'identifiant du processus, donn&eacute;es pour le moins al&eacute;atoires. Il faut donc vraiment se m&eacute;fier de cela si on souhaite utiliser le module <code>Random</code> &agrave; des fins cryptographiques. En pratique, le petit bout de code suivant devine assez rapidement la graine g&eacute;n&eacute;r&eacute;e, en supposant connu l'identifiant du processus (ce n'est pas bien dur &agrave; deviner sinon) et en supposant approximativement connue l'heure de l'initialisation:<br/>
<br/>
<pre>(** Random.self_init relies on caml_sys_random_seed
  * which returns an int.
  * That integer is sec ^ usec ^ ppid&lt;&lt;16 ^ pid.
  * We try to guess the seed to reproduce the output of
  * the random generator.
  * The PID and PPID are supposed to be known,
  * the time in seconds and micro-seconds is supposed
  * to be known resp. with precision 1s and 1000ms.
  * With that knowledge it's really fast;
  * with less it'd take longer. *)

let gen sec usec pid ppid =
  sec lxor usec lxor pid lxor (ppid lsl 16)

let random _ = Random.int 100

(** Given a leaked sequence of numbers consecutively
  * generated by [random] _immediately after_
  * [Random.self_init], call [k] with seeds that allow
  * to reproduce that sequence. *)
let crack leak k =
  let t = Unix.gettimeofday () in
  let sec = int_of_float t in
  let usec = int_of_float (fst (modf t) *. 1_000_000.) in
  let pid = Unix.getpid () in
  let ppid = Unix.getppid () in
    (* Since we sec and usec are xored, trying sec and
     * sec-1 would be useless: all we'd be doing is
     * flipping a bit that is flipped anyway when
     * enumerating posssible values for usec. *)
    for usec = usec - 10000 to usec do
      let seed = gen sec usec pid ppid in
        Random.init seed ;
        if Array.init (Array.length leak) random = leak then
          k seed
    done

let () =
  let leak,valid =
    Random.self_init () ;
    let leak = Array.init 1000 random in
    let valid = Array.init 5000 random in
      leak, valid
  in
  let k seed =
    let guess =
      Random.init seed ;
      ignore (Array.init (Array.length leak) random) ;
      Array.init (Array.length valid) random
    in
      Printf.printf
        &quot;Guessed seed: %d. Validated: %b.\n&quot;
        seed (guess=valid)
  in
    crack leak k ;
    Printf.printf &quot;Search space exhausted.\n&quot;
</pre><br/>
Quand on le lance, on a quelque chose comme &ccedil;a en quelques secondes:<br/>
<pre>$ ocamlopt unix.cmxa crack.ml -o crack &amp;&amp; ./crack
Guessed seed: 262818353. Validated: true.
Search space exhausted.</pre><br/>
Il y a diverses variations possible. Ce qui m'int&eacute;resse, et qui est encore assez obscur pour moi, c'est la g&eacute;n&eacute;ration (r&eacute;p&eacute;titive) de graines &agrave; partir d'une partie priv&eacute;e et d'une partie publique, utilis&eacute;e pour &eacute;viter d'avoir des s&eacute;quences g&eacute;n&eacute;r&eacute;es identiques (ce qui exposerait &agrave; des attaques dans certains cas). A quel point on affaiblit ou compromet son secret, en fonction du g&eacute;n&eacute;rateur utilis&eacute;, etc?
