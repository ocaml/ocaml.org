---
title: Enigmes
description:
url: https://misterpingouin.blogspot.com/2007/11/enigme.html
date: 2007-11-21T14:33:00-00:00
preview_image:
authors:
- mrpingouin
source:
---

Quand on pose une &eacute;nigme math&eacute;matique, &agrave; moiti&eacute; formalis&eacute;e, on finit toujours par avoir une r&eacute;ponse type: &quot;on enl&egrave;ve le bandeau qu'on a sur les yeux&quot;, &quot;on casse la gueule au bourreau&quot;, etc. D'o&ugrave; l'id&eacute;e de formaliser vraiment, sous forme d'un exercice de programmation... (qui a dit &quot;maniaque&quot; ?)<br/><br/>Un groupe de <code>n</code> prisonniers se trouve en mauvaise posture. Ils vont &ecirc;tre mis en file indienne, chaque prisonnier voyant seulement les prisonniers devant lui. Puis on leur mettra sur la t&ecirc;te un chapeau bleu, blanc ou rouge, qu'ils ne peuvent voir. Un bourreau proc&egrave;de alors comme suit: en partant du dernier prisonnier il demande &quot;Quelle est la couleur de ton chapeau ?&quot;, et le prisonnier n'a le droit qu'&agrave; une r&eacute;ponse, qui doit &ecirc;tre une couleur. A la fin, les prisonniers qui ont devin&eacute; la couleur de leur chapeau sont &eacute;pargn&eacute;s, les autres ex&eacute;cut&eacute;s. Les prisonniers peuvent se concerter avant l'&eacute;preuve sur la strat&eacute;gie &agrave; adopter. Quelle est la meilleure strat&eacute;gie ?<br/><br/>Voici maintenant l'&eacute;nonc&eacute; compl&egrave;tement formalis&eacute;. Un prisonnier est repr&eacute;sent&eacute; par une fonction qui prend deux listes de couleurs (celles qu'il voit devant lui, celles qui ont &eacute;t&eacute; prononc&eacute;es comme r&eacute;ponses derri&egrave;re lui), et renvoie une couleur (sa r&eacute;ponse). Dans la liste des r&eacute;ponses pr&eacute;c&eacute;dentes, la r&eacute;ponse du dernier de la file est la derni&egrave;re de la liste. Trouver une fonction <code>prisonniers</code> qui &agrave; un entier <code>n</code> associe une liste de <code>n</code> fonctions/prisonniers telle que le nombre de morts calcul&eacute; par <code>(execution (prisonniers n))</code> soit le plus petit possible dans le pire cas. La fonction d'ex&eacute;cution est la suivante:<br/><pre>type couleur = Bleu | Blanc | Rouge<br/>type prisonnier = couleur list -&gt; couleur list -&gt; couleur<br/><br/>let random_couleur () =<br/>  let n = Random.int 3 in<br/>    if n = 0 then Bleu else if n = 1 then Blanc else Rouge<br/><br/>let execution (prisonniers : prisonnier list) =<br/>  let prisonniers =<br/>    List.map (fun p -&gt; p, random_couleur ()) prisonniers<br/>  in<br/>  let rec morts avant = function<br/>    | (p,c)::l -&gt;<br/>        let reponse = p (List.map snd l) avant in<br/>          (if reponse = c then 0 else 1) +<br/>          (morts (reponse::avant) l)<br/>    | [] -&gt; 0<br/>  in<br/>    morts [] prisonniers</pre><br/>Amusez-vous bien, et postez vos r&eacute;ponses dans le langage de votre choix...<br/><br/><b>Edit</b>: une autre &eacute;nigme beaucoup plus &eacute;tonnante, que Florent et Julien m'ont racont&eacute;e. Vous avez devant vous sur une table 7 pi&egrave;ces c&ocirc;t&eacute; pile et 19 pi&egrave;ces c&ocirc;t&eacute; face. Mais vos yeux sont band&eacute;s (et vous portez des moufles) de sorte que vous ne pouvez savoir l'&eacute;tat d'une pi&egrave;ce. Tout ce que vous pouvez faire c'est en retourner certaines, autant que vous voulez, et les d&eacute;placer. Il vous faut les s&eacute;parer en deux groupes qui contiennent le m&ecirc;me nombre de pi&egrave;ces c&ocirc;t&eacute; pile.<br/><br/>La solution sera une fonction qui prend le nombre de piles et le nombre de faces (je vous aide bien en g&eacute;n&eacute;ralisant) et qui renvoie deux tableaux de taille <code>piles+faces</code>: le premier indique les indices des pi&egrave;ces choisies, le second indique les pi&egrave;ces qu'il faut retourner. La fonction sera pass&eacute;e &agrave; la fonction de test suivantes:<br/><pre>(** Perfect Fisher-Yates shuffle<br/>  * (http://www.nist.gov/dads/HTML/fisherYatesShuffle.html). *)<br/>let randomize a =<br/>  let permute i j =<br/>    let tmp = a.(i) in<br/>      a.(i) &lt;- a.(j);<br/>      a.(j) &lt;- tmp<br/>  in<br/>  let l = Array.length a in<br/>    if l&gt;=2 then<br/>      for i=0 to l-2 do<br/>        permute i (i + Random.int (l-i))<br/>      done<br/><br/>let test nb_piles nb_faces joueur =<br/>  let choix,retourne = joueur nb_piles nb_faces in<br/>  let n = nb_piles + nb_faces in<br/>  let a = Array.init n (fun i -&gt; i&lt;nb_piles) in<br/>  (* Nombre de piles &agrave; gauche - nombre de piles &agrave; droite *)<br/>  let d = ref 0 in<br/>    randomize a ;<br/>    for i = 0 to n-1 do<br/>      if retourne.(i) then a.(i) &lt;- not a.(i) ;<br/>      d := (if choix.(i) then (+) else (-)) !d (if a.(i) then 1 else 0)<br/>    done ;<br/>    !d = 0</pre><br/>A suivre: les solutions comment&eacute;es...
