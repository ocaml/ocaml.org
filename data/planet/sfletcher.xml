<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</id><title type="text">sfletcher</title><updated>2023-06-30T05:47:26-00:00</updated><entry><link href="http://blog.shaynefletcher.org/2018/06/bucket-sort.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">&lt;html&gt;&lt;head&gt;

&lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;/&gt;
&lt;title&gt;Bucket Sort&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;
Bucket sort assumes input generated by a random process that distributes elements uniformly over the interval &lt;i&gt;[0, 1)&lt;/i&gt;.
&lt;/p&gt;
&lt;p&gt;
The idea of bucket sort is to divide &lt;i&gt;[0, 1)&lt;/i&gt; into &lt;i&gt;n&lt;/i&gt; equal-sized subintervals or &lt;i&gt;buckets&lt;/i&gt;, and then distribute the &lt;i&gt;n&lt;/i&gt; input numbers into the buckets. To produce the output, sort the numbers in each bucket and then go through the buckets in order. Sorting a bucket can be done with insertion sort.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; insert x = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; [] &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; [x]
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; h :: tl &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; ls &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x &amp;lt; h &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; x :: ls &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; h :: insert x tl

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; insertion_sort = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; [] &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; [_] &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; ls &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; ls
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; h :: tl &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; insert h (insertion_sort tl)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;
&lt;/p&gt;&lt;p&gt;This code for bucket sort assumes the input is an &lt;i&gt;n&lt;/i&gt;-element array &lt;code class=&quot;code&quot;&gt;a&lt;/code&gt; and that each element &lt;i&gt;0 &amp;le; &lt;code class=&quot;code&quot;&gt;a.(i)&lt;/code&gt; &amp;lt; 1&lt;/i&gt;. The code requires an auxillary array &lt;code class=&quot;code&quot;&gt;b&lt;/code&gt;.(&lt;i&gt;0 .. n - 1&lt;/i&gt;) of lists (buckets).
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bucket_sort a =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; n = &lt;span class=&quot;constructor&quot;&gt;Array&lt;/span&gt;.length a &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = &lt;span class=&quot;constructor&quot;&gt;Array&lt;/span&gt;.make n [] &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;constructor&quot;&gt;Array&lt;/span&gt;.iter
    (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i =
         int_of_float (
           floor (float_of_int n *. x)
         ) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;constructor&quot;&gt;Array&lt;/span&gt;.set b i (x :: &lt;span class=&quot;constructor&quot;&gt;Array&lt;/span&gt;.get b i)
      ) a;
  &lt;span class=&quot;constructor&quot;&gt;Array&lt;/span&gt;.iteri
    (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; i l &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;constructor&quot;&gt;Array&lt;/span&gt;.set b i (insertion_sort l)
    ) b;
  &lt;span class=&quot;constructor&quot;&gt;Array&lt;/span&gt;.fold_left (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; acc bucket &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; acc @ bucket) [] b
;;
bucket_sort [| 0.78; 0.17; 0.39; 0.26; 0.72; 0.94
             ; 0.21; 0.12; 0.23; 0.68|]
&lt;/code&gt;&lt;/pre&gt;
Bucket sort runs in linear time on the average.
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;
&lt;/p&gt;&lt;hr/&gt;
&lt;p&gt;
References:&lt;br/&gt;
[1] &amp;quot;Introduction to Algorithms&amp;quot; Section 9.4:Bucket Sort -- Cormen et. al. (Second ed.) 2001.&lt;br/&gt;
&lt;/p&gt;


&lt;/body&gt;&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2018/06/bucket-sort.html</id><title type="text">Bucket Sort</title><updated>2018-06-10T18:29:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2018/05/dijkstras-algorithm.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
    
    &lt;title&gt;Shortest Path&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;This article assumes familiarity with Dijkstra's shortest path algorithm. For a refresher, see [1]. The code assumes &lt;code class=&quot;code&quot;&gt;open Core&lt;/code&gt; is in effect and is online &lt;a href=&quot;https://github.com/shayne-fletcher/zen/tree/master/ocaml/dijkstra&quot;&gt;here&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;The first part of the program organizes our thoughts about what we are setting out to compute. The signature summarizes the notion (for our purposes) of a graph definition in modular form. A module implementing this signature defines a type &lt;code class=&quot;code&quot;&gt;vertex_t&lt;/code&gt; for vertices, a type &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt; for graphs and type &lt;code class=&quot;code&quot;&gt;extern_t&lt;/code&gt; : a representation of a &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt; for interaction between an implemening module and its &amp;quot;outside world&amp;quot;.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Graph_sig&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; vertex_t [@@deriving sexp]
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t [@@deriving sexp]
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; extern_t

  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; load_error = [ &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Duplicate_vertex&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; vertex_t ] [@@deriving sexp]
  &lt;span class=&quot;keyword&quot;&gt;exception&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Load_error&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; load_error [@@deriving sexp]

  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; of_adjacency : extern_t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; [ &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Ok&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; t &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Load_error&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; load_error ]
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; to_adjacency : t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; extern_t

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Dijkstra&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; state

    &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; error = [
      &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Relax&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; vertex_t
    ] [@@deriving sexp]
    &lt;span class=&quot;keyword&quot;&gt;exception&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; error [@@deriving sexp]

    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; dijkstra : vertex_t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; [ &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Ok&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; state &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; error ]
    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; d : state &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (vertex_t * float) list
    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; shortest_paths : state &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (vertex_t * vertex_t list) list
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;A realization of &lt;code class=&quot;code&quot;&gt;Graph_sig&lt;/code&gt; provides &amp;quot;conversion&amp;quot; functions &lt;code class=&quot;code&quot;&gt;of_adjacency&lt;/code&gt;/&lt;code class=&quot;code&quot;&gt;to_adjacency&lt;/code&gt; between the types &lt;code class=&quot;code&quot;&gt;extern_t&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt; and nests a module &lt;code class=&quot;code&quot;&gt;Dijkstra&lt;/code&gt;. The signature of the sub-module &lt;code class=&quot;code&quot;&gt;Dijkstra&lt;/code&gt; requires concrete modules provide a type &lt;code class=&quot;code&quot;&gt;state&lt;/code&gt; and an implementation of Dijkstra's algorithm in terms of the function signature &lt;code class=&quot;code&quot;&gt;val dijkstra : vertex_t -&amp;gt; t -&amp;gt; [ `Ok of state | `Error of error ]&lt;/code&gt;.
    
    &lt;p&gt;For reusability, the strategy for implementing graphs will be generic programming via functors over modules implementing s vertex type.&lt;/p&gt;
    &lt;p&gt;An implementation of the module type &lt;code class=&quot;code&quot;&gt;GRAPH&lt;/code&gt; defines a module type &lt;code class=&quot;code&quot;&gt;VERT&lt;/code&gt; which is required to provide a comparable type &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt;. It further defines a module type &lt;code class=&quot;code&quot;&gt;S&lt;/code&gt; that is exactly module type &lt;code class=&quot;code&quot;&gt;Graph_sig&lt;/code&gt; above. Lastly, modules of type &lt;code class=&quot;code&quot;&gt;GRAPH&lt;/code&gt; provide a functor &lt;code class=&quot;code&quot;&gt;Make&lt;/code&gt; that maps any module of type &lt;code class=&quot;code&quot;&gt;VERT&lt;/code&gt; to new module of type &lt;code class=&quot;code&quot;&gt;S&lt;/code&gt; fixing &lt;code class=&quot;code&quot;&gt;extern_t&lt;/code&gt; to an adjacency list representation in terms of the native OCaml type &lt;code class=&quot;code&quot;&gt;'a list&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;float&lt;/code&gt; to represent weights on edges.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;GRAPH&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;VERT&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t[@@deriving sexp]
    &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Comparable&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t := t
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;S&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Graph_sig&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Make&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;functor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;VERT&lt;/span&gt;) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;constructor&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; vertex_t = &lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.t
       &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; extern_t = (&lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.t * (&lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.t * float) list) list
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
The two module types &lt;code class=&quot;code&quot;&gt;Graph_sig&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;GRAPH&lt;/code&gt; together provide the specification for the program. &lt;code class=&quot;code&quot;&gt;module Graph&lt;/code&gt; in the next section implements this specification.
    
    &lt;p&gt;Implementation of module &lt;code class=&quot;code&quot;&gt;Graph&lt;/code&gt; is in outline this.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Graph&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;GRAPH&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;VERT&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t[@@deriving sexp]
    &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Comparable&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t := t
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;S&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Graph_sig&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Make&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;functor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;VERT&lt;/span&gt;) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;constructor&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; vertex_t = &lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.t
       &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; extern_t = (&lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.t * (&lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.t * float) list) list
    =

    &lt;span class=&quot;keyword&quot;&gt;functor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;VERT&lt;/span&gt;) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
       ...
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
As per the requirements of &lt;code class=&quot;code&quot;&gt;GRAPH&lt;/code&gt; the module types &lt;code class=&quot;code&quot;&gt;VERT&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;S&lt;/code&gt; are provided as is the functor &lt;code class=&quot;code&quot;&gt;Make&lt;/code&gt;. It is the code that is ellided by the &lt;code class=&quot;code&quot;&gt;...&lt;/code&gt; above in the definition of &lt;code class=&quot;code&quot;&gt;Make&lt;/code&gt; that is now the focus.
    
    &lt;p&gt;Modules produced by applications of &lt;code class=&quot;code&quot;&gt;Make&lt;/code&gt; satisfy &lt;code class=&quot;code&quot;&gt;S&lt;/code&gt;. This requires suitable definitions of types &lt;code class=&quot;code&quot;&gt;vertext_t&lt;/code&gt;, &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;extern_t&lt;/code&gt;. The modules &lt;code class=&quot;code&quot;&gt;Map&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;Set&lt;/code&gt; are available due to modules of type &lt;code class=&quot;code&quot;&gt;VERT&lt;/code&gt; being comparable in their type &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt;.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Set&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Set&lt;/span&gt;

      &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; vertex_t = &lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.t [@@deriving sexp]
      &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = (vertex_t * float) list &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.t [@@deriving sexp]
      &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; extern_t = (vertex_t * (vertex_t * float) list) list
      &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; load_error = [ &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Duplicate_vertex&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; vertex_t ] [@@deriving sexp]
      &lt;span class=&quot;keyword&quot;&gt;exception&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Load_error&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; load_error [@@deriving sexp]
&lt;/code&gt;&lt;/pre&gt;
    
    &lt;p&gt;While the external representation &lt;code class=&quot;code&quot;&gt;extern_t&lt;/code&gt; of graphs is chosen to be an adjacency list representation in terms of association lists, the internal representation &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt; is a vertex map of adjacency lists providing logarithmic loookup complexity. The conversion functions between the two representations &amp;quot;come for free&amp;quot; via module &lt;code class=&quot;code&quot;&gt;Map&lt;/code&gt;.

&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; to_adjacency g = &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.to_alist g

      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; of_adjacency_exn l =  &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.of_alist l &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
        &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Ok&lt;/span&gt; t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; t
        &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Duplicate_key&lt;/span&gt; c &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; raise (&lt;span class=&quot;constructor&quot;&gt;Load_error&lt;/span&gt; (&lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Duplicate_vertex&lt;/span&gt; c))

      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; of_adjacency l =
        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;
          &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Ok&lt;/span&gt; (of_adjacency_exn l)
        &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
        &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Load_error&lt;/span&gt; err &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Load_error&lt;/span&gt; err
&lt;/code&gt;&lt;/pre&gt;
    
&lt;p&gt;At this point the &amp;quot;scaffolding&amp;quot; for Dijkstra's algorithm, that part of &lt;code class=&quot;code&quot;&gt;GRAPH&lt;/code&gt; dealing with the representation of graphs is implemented.&lt;/p&gt;
&lt;p&gt;The interpretation of Dijkstra's algorithm we adopt is functional : the idea is we loop over vertices relaxing their edges until all shortest paths are known. What we know on any recursive iteration of the loop is a current &amp;quot;state&amp;quot; (of the computation) and each iteration produces a new state. This next definition is the formal definition of &lt;code class=&quot;code&quot;&gt;type state&lt;/code&gt;.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Dijkstra&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;

        &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; state = {
          src    :                  vertex_t
        ; g      :                         t
        ; d      :               float &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.t
        ; pred   :            vertex_t &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.t
        ; s      :                     &lt;span class=&quot;constructor&quot;&gt;Set&lt;/span&gt;.t
        ; v_s    : (vertex_t * float) &lt;span class=&quot;constructor&quot;&gt;Heap&lt;/span&gt;.t
        }
&lt;/code&gt;&lt;/pre&gt;
The fields of this record are:
&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;code&quot;&gt;src : vertex_t&lt;/code&gt;, the source vertex;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;g : t&lt;/code&gt;, &lt;i&gt;G&lt;/i&gt; the graph;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;d : float Map.t&lt;/code&gt;, &lt;i&gt;d&lt;/i&gt; the shortest path weight estimates;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;pre : vertex_t Map.t&lt;/code&gt;, &lt;i&gt;&amp;pi;&lt;/i&gt; the predecessor relation;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;s : Set.t&lt;/code&gt;, the set &lt;i&gt;S&lt;/i&gt; of nodes for which the lower bound shortest path weight is known;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;v_s : (vertex_t * float) Heap.t&lt;/code&gt;, &lt;i&gt;V - {S}, &lt;/i&gt; , the set of nodes of &lt;code class=&quot;code&quot;&gt;g&lt;/code&gt; for which the lower bound of the shortest path weight is not yet known ordered on their estimates.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Function invocation &lt;code class=&quot;code&quot;&gt;init src g&lt;/code&gt; compuates an initial state for the graph &lt;code class=&quot;code&quot;&gt;g&lt;/code&gt; containing the source node &lt;code class=&quot;code&quot;&gt;src&lt;/code&gt;. In the initial state, &lt;code class=&quot;code&quot;&gt;d&lt;/code&gt; is everywhere &lt;i&gt;&amp;infin;&lt;/i&gt; except for &lt;code class=&quot;code&quot;&gt;src&lt;/code&gt; which is &lt;i&gt;0&lt;/i&gt;. Set &lt;i&gt;S&lt;/i&gt; (i.e. &lt;code class=&quot;code&quot;&gt;s&lt;/code&gt;) and the predecessor relation &lt;i&gt;&amp;pi;&lt;/i&gt; (i.e. &lt;code class=&quot;code&quot;&gt;pred&lt;/code&gt;) are empty and the set &lt;i&gt;V - {S}&lt;/i&gt; (i.e. &lt;code class=&quot;code&quot;&gt;v_s&lt;/code&gt;) contains all nodes.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; init src g =
          &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; init x = &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.equal src x &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; 0.0 &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Float&lt;/span&gt;.infinity &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
          &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; d = &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.fold (&lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.keys g) ~init:&lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.empty
              ~f:(&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; acc x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.set acc ~key:x ~data:(init x)) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
          {
            src
          ; g
          ; s = &lt;span class=&quot;constructor&quot;&gt;Set&lt;/span&gt;.empty
          ; d
          ; pred = &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.empty
          ; v_s = &lt;span class=&quot;constructor&quot;&gt;Heap&lt;/span&gt;.of_list (&lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.to_alist d)
                ~cmp:(&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; (_, e1) (_, e2) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Float&lt;/span&gt;.compare e1 e2)
          }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Relaxing an edge &lt;i&gt;(u, v)&lt;/i&gt; with weight &lt;i&gt;w (u, v)&lt;/i&gt; tests whether the shortest path to &lt;i&gt;v&lt;/i&gt; so far can be improved by going through &lt;i&gt;u&lt;/i&gt; and if so, updating &lt;i&gt;d (v)&lt;/i&gt; and &lt;i&gt;&amp;pi; (v)&lt;/i&gt; accordingly.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; error = [
          &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Relax&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; vertex_t
        ] [@@deriving sexp]
        &lt;span class=&quot;keyword&quot;&gt;exception&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; error [@@deriving sexp]

        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; relax state (u, v, w) =
          &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; {d; pred; v_s; _} = state &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
          &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dv = &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.find d v &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; dv &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; dv
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; raise (&lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; (&lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Relax&lt;/span&gt; v)) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
          &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; du = &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.find d u &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; du &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; du
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; raise (&lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; (&lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Relax&lt;/span&gt; u)) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
          &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; dv &amp;gt; du +. w &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dv = du +. w &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
            (&lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Heap&lt;/span&gt;.find_elt v_s ~f:(&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; (n, _) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.equal n v) &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; tok &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; ignore (&lt;span class=&quot;constructor&quot;&gt;Heap&lt;/span&gt;.update v_s tok (v, dv))
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; raise (&lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; (&lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Relax&lt;/span&gt; v))
            );
            { state &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
              d = &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.change d v
                  ~f:(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
                      &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; dv
                      &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; raise (&lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; (&lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Relax&lt;/span&gt; v))
                    )
            ; pred = &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.set (&lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.remove pred v) ~key:v ~data:u
            }
          &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; state
&lt;/code&gt;&lt;/pre&gt;
Here, relaxation can result in a linear heap update operation. A better implementation might seek to avoid that.

&lt;p&gt;One iteration of the body of the loop of Dijkstra's algorithm consists of the node in &lt;i&gt;V - {S}&lt;/i&gt; with the least shortest path weight estimate being moved to &lt;i&gt;S&lt;/i&gt; and its edges relaxed.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dijkstra_exn src g =
          &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; loop ({s; v_s; _} &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; state) =
            &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Heap&lt;/span&gt;.is_empty v_s &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; state
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
              &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; u = fst (&lt;span class=&quot;constructor&quot;&gt;Heap&lt;/span&gt;.pop_exn v_s) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
              loop (
                &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.fold (&lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.find_exn g u)
                  ~init:{ state &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; s = &lt;span class=&quot;constructor&quot;&gt;Set&lt;/span&gt;.add s u }
                  ~f:(&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; state (v, w) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; relax state (u, v, w))
              )
          &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; loop (init src g)

        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dijkstra src g =
          &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;
            &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Ok&lt;/span&gt; (dijkstra_exn src g)
          &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
          &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; err &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; err
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;The shortest path estimates contained by a value of &lt;code class=&quot;code&quot;&gt;state&lt;/code&gt; is given by the projection &lt;code class=&quot;code&quot;&gt;d&lt;/code&gt;.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; d state = &lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.to_alist (state.d)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The shortest paths themselves are easily computed as,
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; path state n =
          &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; loop acc x =
            (&lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;V&lt;/span&gt;.equal x state.src &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; x :: acc
            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; loop (x :: acc) (&lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.find_exn state.pred x)
            ) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
          loop [] n

        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; shortest_paths state =
          &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map (&lt;span class=&quot;constructor&quot;&gt;Map&lt;/span&gt;.keys state.g) ~f:(&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; n &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (n, path state n))
      &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
which completes the implementation of &lt;code class=&quot;code&quot;&gt;Make&lt;/code&gt;.
&lt;p&gt;The following program produces a concrete instance of the shortest path problem (with some evaluation output from the top-level).
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;Graph&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; vertex_t = char &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; extern_t = (char * (char * float) list) list
  =
  &lt;span class=&quot;constructor&quot;&gt;Graph&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Make&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Char&lt;/span&gt;)

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; g : &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.t =
  &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.of_adjacency
          [ &lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;'u'&lt;/span&gt;,  3.0; &lt;span class=&quot;string&quot;&gt;'x'&lt;/span&gt;, 5.0]
          ; &lt;span class=&quot;string&quot;&gt;'u'&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;'x'&lt;/span&gt;,  2.0; &lt;span class=&quot;string&quot;&gt;'v'&lt;/span&gt;, 6.0]
          ; &lt;span class=&quot;string&quot;&gt;'x'&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;'v'&lt;/span&gt;,  4.0; &lt;span class=&quot;string&quot;&gt;'y'&lt;/span&gt;, 6.0; &lt;span class=&quot;string&quot;&gt;'u'&lt;/span&gt;, 1.0]
          ; &lt;span class=&quot;string&quot;&gt;'v'&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;'y'&lt;/span&gt;,  2.0]
          ; &lt;span class=&quot;string&quot;&gt;'y'&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;'v'&lt;/span&gt;,  7.0]
          ]
  &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Ok&lt;/span&gt; g &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; g
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Load_error&lt;/span&gt; e &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; failwiths &lt;span class=&quot;string&quot;&gt;&amp;quot;Graph load error : %s&amp;quot;&lt;/span&gt; e &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.sexp_of_load_error
;;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; s = &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Dijkstra&lt;/span&gt;.dijkstra &lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt; g) &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Ok&lt;/span&gt; s &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; s
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; e &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; failwiths &lt;span class=&quot;string&quot;&gt;&amp;quot;Error : %s&amp;quot;&lt;/span&gt; e &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Dijkstra&lt;/span&gt;.sexp_of_error

;; &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Dijkstra&lt;/span&gt;.d s
- : (char * float) list =
[(&lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt;, 0.); (&lt;span class=&quot;string&quot;&gt;'u'&lt;/span&gt;, 3.); (&lt;span class=&quot;string&quot;&gt;'v'&lt;/span&gt;, 9.); (&lt;span class=&quot;string&quot;&gt;'x'&lt;/span&gt;, 5.); (&lt;span class=&quot;string&quot;&gt;'y'&lt;/span&gt;, 11.)]

;; &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Dijkstra&lt;/span&gt;.shortest_paths s
- : (char * char list) list =
[(&lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt;]); (&lt;span class=&quot;string&quot;&gt;'u'&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'u'&lt;/span&gt;]); (&lt;span class=&quot;string&quot;&gt;'v'&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'u'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'v'&lt;/span&gt;]); (&lt;span class=&quot;string&quot;&gt;'x'&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'x'&lt;/span&gt;]);
 (&lt;span class=&quot;string&quot;&gt;'y'&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'x'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'y'&lt;/span&gt;])]
&lt;/code&gt;&lt;/pre&gt;


    &lt;p&gt;
    &lt;/p&gt;&lt;hr/&gt;
    &lt;p&gt;
      References:&lt;br/&gt;
      [1] &amp;quot;Introduction to Algorithms&amp;quot; Section 24.3:Dijkstra's algorithm -- Cormen et. al. (Second ed.) 2001.&lt;br/&gt;
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2018/05/dijkstras-algorithm.html</id><title type="text">Dijkstra's algorithm</title><updated>2018-05-20T18:26:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/12/how-to-migrate-your-ppx-to-ocaml.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
    
    &lt;title&gt;OCaml migrate parse tree&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;h2&gt;OCaml migrate parse tree&lt;/h2&gt;

  &lt;p&gt;Earlier this
  year, &lt;a href=&quot;http://blog.shaynefletcher.org/2017/05/preprocessor-extensions-for-code.html&quot;&gt;this
  blog post&lt;/a&gt; [2] explored the implementation of a small
  preprocessor extension (ppx).
  &lt;/p&gt;
  &lt;p&gt;The code of the above article worked well enough at the time but
  as written, exhibits a problem : new releases of the OCaml compiler
  are generally accompanied by evolutions of the OCaml parse tree. The
  effect of this is, a ppx written against a specific version of the
  compiler will &amp;quot;break&amp;quot; in the presence of later releases of the
  compiler. As pointed out in [3], the use of ppx's in the OCaml
  eco-system these days is ubiquitous. If each new release of the
  OCaml compiler required sychronized updates of each and every ppx
  in &lt;a href=&quot;http://opam.ocaml.org/&quot;&gt;opam&lt;/a&gt;, getting new releases
  of the compiler out would soon become a near impossibilty.
  &lt;/p&gt;
  &lt;p&gt;Mitigation of the above problem is provided by
  the &lt;a href=&quot;http://opam.ocaml.org/packages/ocaml-migrate-parsetree/&quot;&gt;&lt;code&gt;ocaml-migrate-parsetree&lt;/code&gt;
  &lt;/a&gt; library. The library provides the means to convert parsetrees
  from one OCaml version to another. This allows the ppx rewriter to
  write against a specific version of the parsetree and lets the
  library take care of rolling parsetrees backwards and forwards in
  versions as necessary.  In this way, the resulting ppx is &amp;quot;forward
  compatible&amp;quot; with newer OCaml versions without requiring ppx code
  updates.
  &lt;/p&gt;
  &lt;p&gt;To get the &lt;code&gt;ppx_id_of&lt;/code&gt; code from the earlier blog post
  usable with &lt;code&gt;ocaml-migrate-parsetree&lt;/code&gt; required a couple
  of small tweaks to make it OCaml 4.02.0 compatible. The changes from
  the original code were slight and not of significant enough interest
  to be worth presenting here. What is worth looking at is what it
  then took to switch the code to
  use &lt;code&gt;ocaml-migrate-parsetree&lt;/code&gt;. The answer is : very
  little!
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Migrate_parsetree&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;OCaml_402&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Ast&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Ast_mapper&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Ast_helper&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Asttypes&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Parsetree&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Longident&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;(* The original ppx as written before goes here!
   .                    .                   .
   .                    .                   .
   .                    .                   .
*)&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; () = &lt;span class=&quot;constructor&quot;&gt;Driver&lt;/span&gt;.register ~name:&lt;span class=&quot;string&quot;&gt;&amp;quot;id_of&amp;quot;&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;OCaml_402&lt;/span&gt;) id_of_mapper
&lt;/code&gt;&lt;/pre&gt; The complete code for this article is available
online &lt;a href=&quot;https://github.com/shayne-fletcher/zen/tree/master/ocaml/ppx_id_of/v2&quot;&gt;here&lt;/a&gt;
and as a bonus, includes a
minimal &lt;a href=&quot;https://jbuilder.readthedocs.io/en/latest/&quot;&gt;&lt;code&gt;jbuilder&lt;/code&gt;&lt;/a&gt;
build system demonstrating just how well the OCaml tool-chain comes
together these days.
  
  &lt;hr/&gt;
  &lt;p&gt;
    References:&lt;br/&gt;
     [1] &lt;a href=&quot;https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/&quot;&gt;&amp;quot;A
     Guide to Extension Points in OCaml&amp;quot; -- Whitequark (blog post
     2014)&lt;/a&gt;&lt;br/&gt;
     [2] &lt;a href=&quot;http://blog.shaynefletcher.org/2017/05/preprocessor-extensions-for-code.html&quot;&gt;&amp;quot;Preprocessor
     extensions for code generation&amp;quot; -- Shayne Fletcher (blog post
     2017)&lt;/a&gt;&lt;br/&gt;
     [3] &lt;a href=&quot;http://rgrinberg.com/posts/extension-points-3-years-later/&quot;&gt;&amp;quot;Extension
     Points - 3 Years Later&amp;quot; -- Rudi Grinberg (blog post 2017)&lt;/a&gt;&lt;br/&gt;
  &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2017/12/how-to-migrate-your-ppx-to-ocaml.html</id><title type="text">How to migrate your ppx to OCaml migrate parsetree</title><updated>2017-12-09T15:40:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/11/towers-of-hanoi.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
    
    &lt;title&gt;Towers of Hanoi&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-uIdWt5l_kzY/WgcJ2KR3ScI/AAAAAAAABxw/ZOp900ZzLNQd2Zs5wxAZQHStnjWVK1hQgCLcBGAs/s1600/tower_of_hanoi_fig1_600.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img src=&quot;https://4.bp.blogspot.com/-uIdWt5l_kzY/WgcJ2KR3ScI/AAAAAAAABxw/ZOp900ZzLNQd2Zs5wxAZQHStnjWVK1hQgCLcBGAs/s320/tower_of_hanoi_fig1_600.jpg&quot; border=&quot;0&quot; width=&quot;320&quot; height=&quot;159&quot; data-original-width=&quot;600&quot; data-original-height=&quot;298&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;
The &amp;quot;towers of Hanoi&amp;quot; problem is stated like this. There are three
pegs labelled &lt;i&gt;a&lt;/i&gt;, &lt;i&gt;b&lt;/i&gt; and &lt;i&gt;c&lt;/i&gt;. On peg &lt;i&gt;a&lt;/i&gt; there
is a stack of &lt;i&gt;n&lt;/i&gt; disks of increasing size, the largest at the
bottom, each with a hole in the middle to accomodate the peg. The
problem is to transfer the stack of disks to peg &lt;i&gt;c&lt;/i&gt;, one disk at
a time, in such a way as to ensure that no disk is ever placed on top
of a smaller disk.
&lt;/p&gt;
&lt;p&gt;The problem is amenable to a divide and conquer strategy : &amp;quot;Move
the top &lt;i&gt;n - 1&lt;/i&gt; disks from peg &lt;i&gt;a&lt;/i&gt; to peg &lt;i&gt;b&lt;/i&gt;, move the
remaining largest disk from peg &lt;i&gt;a&lt;/i&gt; to peg &lt;i&gt;c&lt;/i&gt; then, move
the &lt;i&gt;n - 1&lt;/i&gt; disks on peg &lt;i&gt;b&lt;/i&gt; to peg &lt;i&gt;c&lt;/i&gt;.&amp;quot;
&lt;/p&gt;
&lt;p&gt;
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; towers n from to_ spare =
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n &amp;gt; 0 &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;
      towers (n - 1) from spare to_;
      &lt;span class=&quot;constructor&quot;&gt;Printf&lt;/span&gt;.printf  &lt;span class=&quot;string&quot;&gt;
               &amp;quot;Move the top disk from peg %c to peg %c\n&amp;quot;&lt;/span&gt; from to_;
      towers (n - 1) spare to_ from
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;
  ()
;;
&lt;/code&gt;&lt;/pre&gt;
For example, the
invocation &lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; () =
towers
3 &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'c'&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;&lt;/code&gt;
will generate the recipie
&lt;pre&gt;Move the top disk from peg a to peg c
Move the top disk from peg a to peg b
Move the top disk from peg c to peg b
Move the top disk from peg a to peg c
Move the top disk from peg b to peg a
Move the top disk from peg b to peg c
Move the top disk from peg a to peg c
&lt;/pre&gt;

&lt;p&gt;Let &lt;i&gt;T(n)&lt;/i&gt; be the time complexity of &lt;code&gt;towers (x, y,
z)&lt;/code&gt;, when the characteristic operation is the moving of a disk
from one peg to another. The time complexity of &lt;code&gt;towers(n - 1, x,
y z)&lt;/code&gt; is &lt;i&gt;T(n - 1)&lt;/i&gt; by definition and no further
investigation is needed. &lt;i&gt;T(0) = 0&lt;/i&gt; because the test &lt;code&gt;n &amp;gt;
0&lt;/code&gt; fails and no disks are moved. For larger &lt;code&gt;n&lt;/code&gt;, the
expression &lt;code&gt;towers (n - 1, from, spare, to_)&lt;/code&gt; is evaluated
with cost &lt;i&gt;T(n - 1)&lt;/i&gt; followed by &lt;code&gt;&lt;span class=&quot;constructor&quot;&gt;Printf&lt;/span&gt;.printf  &lt;span class=&quot;string&quot;&gt;&amp;quot;Move the top disk from peg %c to peg %c\n&amp;quot;&lt;/span&gt; from to_
&lt;/code&gt; with cost &lt;i&gt;1&lt;/i&gt; and finally, &lt;code&gt;towers(n - 1, spare,
to_, from)&lt;/code&gt; again with cost &lt;i&gt;T(n - 1)&lt;/i&gt;.
&lt;/p&gt;
&lt;p&gt;
Summing these contributions gives the recurrence relation &lt;i&gt;T(n) =
2T(n - 1) + 1&lt;/i&gt; where &lt;i&gt;T(0) = 0&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;Repeated substituition can be used to arrive at a closed form
for &lt;i&gt;T(n)&lt;/i&gt;, since, &lt;i&gt;T(n) = 2T(n - 1) + 1 = 2[2T(n - 2) + 1] + 1
= 2[2[2T(n - 3) +1] + 1] + 1 = 2&lt;sup&gt;3&lt;/sup&gt;T(n - 3) + 2&lt;sup&gt;2&lt;/sup&gt; +
2&lt;sup&gt;1&lt;/sup&gt; + 2&lt;sup&gt;0&lt;/sup&gt;&lt;/i&gt; (provided &lt;i&gt;n &amp;ge;&lt;/i&gt; 3),
expanding the brackets in a way that elucidates the emerging
pattern. If this substitution is repeated &lt;i&gt;i&lt;/i&gt; times then clearly
the result is &lt;i&gt;T(n) = 2&lt;sup&gt;i&lt;/sup&gt;T(n - i) + 2&lt;sup&gt;i - 1&lt;/sup&gt; +
2&lt;sup&gt;i - 2&lt;/sup&gt; + &amp;middot;&amp;middot;&amp;middot; + 2&lt;sup&gt;0&lt;/sup&gt;&lt;/i&gt; (&lt;i&gt;n
&amp;ge; i&lt;/i&gt;). The largest possible value &lt;i&gt;i&lt;/i&gt; can take is &lt;i&gt;n&lt;/i&gt;
and if &lt;i&gt;i = n&lt;/i&gt; then &lt;i&gt;T(n - i) = T(0) = 0&lt;/i&gt; and so we arrive
at &lt;i&gt;T(n) = 2&lt;sup&gt;n&lt;/sup&gt;0 + 2&lt;sup&gt;n - 1&lt;/sup&gt; +
&amp;middot;&amp;middot;&amp;middot; + 2&lt;sup&gt;0&lt;/sup&gt;&lt;/i&gt;. This is the sum of a
geometric series with the well known solution &lt;i&gt;2&lt;sup&gt;n&lt;/sup&gt; - 1&lt;/i&gt;
(use induction to establish that last result or more directly, just
compute &lt;i&gt;2T(n) - T(n)&lt;/i&gt;). And so, the time complexity (the number
of disk moves needed) for &lt;i&gt;n&lt;/i&gt; disks is &lt;i&gt;T(n) = 2&lt;sup&gt;n&lt;/sup&gt; -
1&lt;/i&gt;.
&lt;/p&gt;
    &lt;hr/&gt;
   &lt;p&gt;
     References:&lt;br/&gt;
     &lt;cite&gt;Algorithms and Data Structures Design, Correctness, Analysis&lt;/cite&gt; by Jeffrey Kingston, 2nd ed. 1998
   &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2017/11/towers-of-hanoi.html</id><title type="text">Towers of Hanoi</title><updated>2017-11-11T14:32:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/10/nesting-quoted-strings-in-ocaml.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
    
    &lt;title&gt;Quoting&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;
According to the lexical conventions of OCaml, characters different from &lt;code class=&quot;code&quot;&gt;\&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;&amp;quot;&lt;/code&gt; can be enclosed in single quotes and appear in strings. The special characters &lt;code class=&quot;code&quot;&gt;\&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;&amp;quot;&lt;/code&gt; are represented in these contexts by their &lt;em&gt;escape sequences&lt;/em&gt;. The 
escape sequence &lt;code class=&quot;code&quot;&gt;\\&lt;/code&gt; denotes the character &lt;code class=&quot;code&quot;&gt;\&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;\&amp;quot;&lt;/code&gt; denotes the character &lt;code&gt;&amp;quot;&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Here we print the string &lt;code class=&quot;code&quot;&gt;&amp;quot;Hello world!&lt;/code&gt;&amp;quot;. The quotes delimit the string and are not themselves part of the string.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;utop[0]&amp;gt; &lt;span class=&quot;constructor&quot;&gt;Caml&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Printf&lt;/span&gt;.printf &lt;span class=&quot;string&quot;&gt;&amp;quot;Hello world!&amp;quot;&lt;/span&gt;;;
&lt;span class=&quot;string&quot;&gt;Hello world!&lt;/span&gt;- : unit = ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
To capture the quotes we need to write them into the string by their escape sequence.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;utop[1]&amp;gt; &lt;span class=&quot;constructor&quot;&gt;Caml&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Printf&lt;/span&gt;.printf &lt;span class=&quot;string&quot;&gt;&amp;quot;\&amp;quot;Hello world!\&amp;quot;&amp;quot;&lt;/span&gt;;;
&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello world!&amp;quot;&lt;/span&gt;- : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
What now if we wish to quote a string within a string?
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;utop[3]&amp;gt; &lt;span class=&quot;constructor&quot;&gt;Caml&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Printf&lt;/span&gt;.printf 
&lt;span class=&quot;string&quot;&gt;&amp;quot;\&amp;quot;A quoted string with \\\&amp;quot;a nested quoted string\\\&amp;quot;\&amp;quot;&amp;quot;&lt;/span&gt;;;
&lt;span class=&quot;string&quot;&gt;&amp;quot;A quoted string with \&amp;quot;a nested quoted
string\&amp;quot;&amp;quot;&lt;/span&gt;- : unit = ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
We see that in rendering the above string, &lt;code class=&quot;code&quot;&gt;printf&lt;/code&gt; has rendered the escape sequence &lt;code class=&quot;code&quot;&gt;\&amp;quot;&lt;/code&gt; as &lt;code class=&quot;code&quot;&gt;&amp;quot;&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;\\\&amp;quot;&lt;/code&gt; as &lt;code class=&quot;code&quot;&gt;\&amp;quot;&lt;/code&gt; as required. The pattern continues if we now wish to quote a string within a quoted string within a quoted string.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;utop[4]&amp;gt; &lt;span class=&quot;constructor&quot;&gt;Caml&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Printf&lt;/span&gt;.printf 
&lt;span class=&quot;string&quot;&gt;&amp;quot;\&amp;quot;A quoted string with \\\&amp;quot;a nested \\\\\\\&amp;quot;nested\\\\\\\&amp;quot;
quoted string\\\&amp;quot;\&amp;quot;&amp;quot;&lt;/span&gt;;;
&lt;span class=&quot;string&quot;&gt;&amp;quot;A quoted string with \&amp;quot;a nested \\\&amp;quot;nested\\\&amp;quot;
quoted string\&amp;quot;&amp;quot;&lt;/span&gt;- : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, things get crazy pretty quickly and you can easily drive yourself mad working out the correct escape sequences to get the desired nesting!
&lt;/p&gt;
&lt;p&gt;Here's a hack : If the string has &lt;i&gt;k&lt;/i&gt; levels of quoting, then count how many occurences of &lt;code class=&quot;code&quot;&gt;\&lt;/code&gt;s precede the &lt;code class=&quot;code&quot;&gt;&amp;quot;&lt;/code&gt; at that level. Let that number be &lt;i&gt;n&lt;/i&gt; say. To get the next level of quoting you need to concatenate a sequence of &lt;i&gt;n + 1&lt;/i&gt; &lt;code class=&quot;code&quot;&gt;\&lt;/code&gt;s to them to get a total of &lt;i&gt;2n + 1&lt;/i&gt; &lt;code class=&quot;code&quot;&gt;\&lt;/code&gt;s. To illustrate, look again at the last example:
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;utop[4]&amp;gt; &lt;span class=&quot;constructor&quot;&gt;Caml&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Printf&lt;/span&gt;.printf 
&lt;span class=&quot;string&quot;&gt;&amp;quot;\&amp;quot;A quoted string with \\\&amp;quot;a nested \\\\\\\&amp;quot;nested\\\\\\\&amp;quot;
quoted string\\\&amp;quot;\&amp;quot;&amp;quot;&lt;/span&gt;;;
&lt;span class=&quot;string&quot;&gt;&amp;quot;A quoted string with \&amp;quot;a nested \\\&amp;quot;nested\\\&amp;quot;
quoted string\&amp;quot;&amp;quot;&lt;/span&gt;- : unit = ()
&lt;/code&gt;&lt;/pre&gt;
That's three level of quoting. At the third level we have the sequence &lt;code class=&quot;code&quot;&gt;\\\\\\\&amp;quot;&lt;/code&gt;. That's &lt;i&gt;7&lt;/i&gt; &lt;code class=&quot;code&quot;&gt;\&lt;/code&gt;s. To quote to the fourth level then we need &lt;i&gt;8 + 7 = 15&lt;/i&gt; &lt;code class=&quot;code&quot;&gt;\&lt;/code&gt;s:
&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;utop[5]&amp;gt; &lt;span class=&quot;constructor&quot;&gt;Caml&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Printf&lt;/span&gt;.printf 
&lt;span class=&quot;string&quot;&gt;&amp;quot;\&amp;quot;A quoted string with \\\&amp;quot;a nested \\\\\\\&amp;quot;nested
\\\\\\\\\\\\\\\&amp;quot;nested\\\\\\\\\\\\\\\&amp;quot; \\\\\\\&amp;quot; quoted string\\\&amp;quot;\&amp;quot;&amp;quot;&lt;/span&gt;;;
&lt;span class=&quot;string&quot;&gt;&amp;quot;A quoted string with \&amp;quot;a nested \\\&amp;quot;nested
\\\\\\\&amp;quot;nested\\\\\\\&amp;quot; \\\&amp;quot; quoted string\&amp;quot;&amp;quot;&lt;/span&gt;- : unit = ()
&lt;/code&gt;&lt;/pre&gt;
      
&lt;p&gt;In general, the number of &lt;code class=&quot;code&quot;&gt;\&lt;/code&gt;s required for &lt;i&gt;n&lt;/i&gt; levels of quoting is &lt;i&gt;2&lt;sup&gt;n&lt;/sup&gt; - 1&lt;/i&gt; (that is, an exponential function). The solution follows from the recurrence relation &lt;i&gt;Q&lt;sub&gt;0&lt;/sub&gt; = 0&lt;/i&gt; and &lt;i&gt;Q&lt;sub&gt;n&lt;/sub&gt; = 2Q&lt;sub&gt;n - 1&lt;/sub&gt; + 1&lt;/i&gt; which in fact establishes a connection to the &amp;quot;Towers of Hanoi&amp;quot; problem.
&lt;/p&gt;
    &lt;hr/&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2017/10/nesting-quoted-strings-in-ocaml.html</id><title type="text">Nesting quoted strings in OCaml</title><updated>2017-10-28T00:53:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/10/how-to-render-trees-like-unix-tree.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
    
    &lt;title&gt;How to render trees like Unix 'tree'&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;The Unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_(Unix)&quot;&gt;&lt;code&gt;tree&lt;/code&gt;&lt;/a&gt; utility produces a pretty rendering of a filesystem. Implementing an algorithm to produce output like &lt;code&gt;tree&lt;/code&gt; is a little harder than one might expect! This short example program illustrates one way of doing it.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;comment&quot;&gt;(* A type of non-empty trees of strings. *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; tree = [
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; string * tree list
]
;;

&lt;span class=&quot;comment&quot;&gt;(* [print_tree tree] prints a rendering of [tree]. *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; print_tree
          ?(pad : (string * string)= (&lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;))
          (tree : tree) : unit =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pd, pc = pad &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; tree &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; (tag, cs) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;constructor&quot;&gt;Printf&lt;/span&gt;.printf &lt;span class=&quot;string&quot;&gt;&amp;quot;%s%s\n&amp;quot;&lt;/span&gt; pd tag;
     &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; n = &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.length cs - 1 &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
     &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.iteri (
         &lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; i c &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pad =
           (pc ^ (&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i = n &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;`-- &amp;quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;|-- &amp;quot;&lt;/span&gt;),
            pc ^ (&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i = n &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;    &amp;quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;|   &amp;quot;&lt;/span&gt;)) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
         print_tree ~pad c
       ) cs
;;

&lt;span class=&quot;comment&quot;&gt;(* An example tree. *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; tree =
  &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;
        , [
            &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;S&amp;quot;&lt;/span&gt;, [
                      &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;T&amp;quot;&lt;/span&gt;, [
                                &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;U&amp;quot;&lt;/span&gt;, [])]);
                      &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;V&amp;quot;&lt;/span&gt;, [])])
          ;  &lt;span class=&quot;keywordsign&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;W&amp;quot;&lt;/span&gt;, [])
          ])
;;

&lt;span class=&quot;comment&quot;&gt;(* Print the example tree. *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; () =  print_tree tree
;;
&lt;/code&gt;&lt;/pre&gt;    
    
    &lt;p&gt;The output of the above looks like this:
      &lt;/p&gt;&lt;pre&gt;.
|-- S
|   |-- T
|   |   `-- U
|   `-- V
`-- W&lt;/pre&gt;
    
    &lt;hr/&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2017/10/how-to-render-trees-like-unix-tree.html</id><title type="text">How to render trees like the Unix tree command</title><updated>2017-10-14T19:20:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/08/transpose.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
  
  &lt;meta content=&quot;text/html; charset=iso-8859-1&quot; http-equiv=&quot;Content-Type&quot;/&gt;
  
  &lt;title&gt;Transpose&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;p&gt;
    If we are to represent a row of a matrix as a list of numbers,
    then a matrix can naturally be represented as a list of lists of
    numbers.
  &lt;/p&gt;
  &lt;p&gt;The transpose of a matrix $\mathbf{A}$ is a new matrix denoted
    $\mathbf{A^{T}}$. The traditional mathematical definition of
    $\mathbf{A^{T}}$ is expressed as saying the $i$ th row, $j$ th
    column element of $\mathbf{A^{T}}$ is the $j$ th row, $i$ th
    column element of $\mathbf{A}$:
    &lt;/p&gt;&lt;div align=&quot;center&quot;&gt;
    $\left[\mathbf{A}\right]_{ij} = \left[\mathbf{A^{T}}\right]_{ji}$.
    &lt;/div&gt;
  
  &lt;p&gt;
    As definitions go, this isn't terribly helpful in
    explaining &lt;em&gt;how&lt;/em&gt; to compute a transpose. A better
    equivalent definition for the functional programmer is : the
    matrix obtained by writing the columns of $\mathbf{A}$ as the
    rows of $\mathbf{A^{T}}$.
  &lt;/p&gt;
  &lt;p&gt;
    An elegant program for computing a transpose follows from a
    direct translation of that last definition.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; transpose (ls : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list list) : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list list =
  &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; ls &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; [] &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; [] :: _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; []
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; ls &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map (&lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.hd) ls :: transpose (&lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map (&lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.tl) ls)
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
  It is not at all hard to understand how the program works when
  you've seen an example:
  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;transpose [[1; 2]; [3; 4;]; [5; 6]]
  = [1; 3; 5] :: transpose [[2]; [4;]; [6]]
  = [1; 3; 5] :: [2; 4; 6] :: transpose [[]; []; []]
  = [1; 3; 5] :: [2; 4; 6] :: []
  = [[1; 3; 5]; [2; 4; 6]]&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    Being as pretty as it is, one is inclined to leave things be but,
    as a practical matter it should be rephrased to be tail-recursive.
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; transpose (ls : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list list) : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list list  =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; transpose_rec acc = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; [] &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; [] :: _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.rev acc
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; ls &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; transpose_rec (&lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map (&lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.hd) ls :: acc) (&lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map (&lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.tl) ls)
  &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; transpose_rec [] ls
&lt;/code&gt;&lt;/pre&gt;   
  
  &lt;hr/&gt;
  &lt;p&gt;
    References:&lt;br/&gt;
    &amp;quot;An Introduction to Functional Programming Systems Using Haskell&amp;quot; -- Davie A J T., 1992
  &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2017/08/transpose.html</id><title type="text">Transpose</title><updated>2017-08-12T19:38:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/05/more-type-classes-in-ocaml.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">&lt;html&gt; &lt;head&gt;  &lt;title&gt;More type classes in OCaml&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;More type classes&lt;/h1&gt;&lt;p&gt;&lt;i&gt;&lt;b&gt;Author:&lt;/b&gt; Joel Bj&amp;ouml;rnson&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;About the author: &lt;/b&gt;Joel has been enjoying functional programming ever since being introduced to Haskell at Chalmers University (Sweden). Since then he's been dabbling in F# and more recently OCaml. He's currently based in London, working at the intersection of functional programming and finance.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;As demonstrated in previous articles on this blog, OCaml comes with a rich module system. Among other things it enables developers to write code that is polymorphic over module signatures.  As such, parameterized modules (aka functors) play a similar role to what type classes do in Haskell, and as explained &lt;a href=&quot;http://blog.shaynefletcher.org/2016/10/implementing-type-classes-as-ocaml.html&quot;&gt;here&lt;/a&gt;, it is straightforward to map simple type classes to modules in OCaml. In Haskell, type classes are often used as design patterns for structuring programs and over the years a taxonomy of type classes inspired by &lt;a href=&quot;https://en.wikipedia.org/wiki/Category_theory&quot;&gt;Category Theory&lt;/a&gt; has evolved.  Standard patterns such as &lt;i&gt;functor&lt;/i&gt;, &lt;i&gt;monad&lt;/i&gt; and &lt;i&gt;monoid&lt;/i&gt; have had a strong influence on the design of common APIs.  In OCaml there is less focus on such idioms. In this post we explore how some of the Haskell patterns implemented in terms of type classes can be ported to OCaml and how that impacts program design. In particular we cover four commonly used type classes that ships with standard Haskell distributions: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Functor&lt;/li&gt;
&lt;li&gt;Monoid&lt;/li&gt;
&lt;li&gt;Applicative Functor&lt;/li&gt;
&lt;li&gt;Traversable&lt;/li&gt;
&lt;/ul&gt;For a more comprehensive guide to these patterns and others &lt;a href=&quot;https://wiki.haskell.org/Typeclassopedia&quot;&gt;Typclassopedia&lt;/a&gt; serves as a good resource. Before tackling the technical aspects it may be worth  elaborating a bit on the motivation behind introducing these types of  abstractions in the first place. Justifications fall under different categories: &lt;ol&gt;&lt;li&gt;API design&lt;/li&gt;
&lt;li&gt;Code reusability&lt;/li&gt;
&lt;li&gt;Testability&lt;/li&gt;
&lt;/ol&gt;The first one is about program design - by mapping a data type to a pattern such as applicative functor, we obtain a set of combinators for operating on values of that type. Ideally that means less time spent on inventing custom operators and figuring out their semantics. When multiple libraries share patterns it also increases the likelihood that consumers of anyone of those libraries already are familiar with the corresponding combinators. For example looking at the &lt;code class=&quot;code&quot;&gt;map&lt;/code&gt; function over some custom data type, one should expect it to have similar properties to the function &lt;code class=&quot;code&quot;&gt;List.map&lt;/code&gt; operating on lists.  The second point is about code reuse. By writing functions that are expressed solely in terms of other module signatures they become reusable in different contexts; For instance by implementing the primitive operators for a monoid we get additional combinators (such as &lt;code class=&quot;code&quot;&gt;concat&lt;/code&gt;) defined generically for any monoid for free!  Thirdly, these patterns all come with a set of theoretically well founded properties. As demonstrated by some of the examples below, it is also possible to write generic tests that can be used to validate concrete implementations of the patterns for different underlying data types. &lt;h2&gt;Prerequisites and conventions&lt;/h2&gt;&lt;p&gt;From now on we'll be using lowercase names such as &lt;i&gt;applicative functor&lt;/i&gt; to describe the patterns themselves. Names starting with uppercase, for instance &lt;code&gt;Applicative&lt;/code&gt; refers to the Haskell name of the type class, while signature names in OCaml are all uppercase (e.g &lt;code class=&quot;code&quot;&gt;APPLICATIVE&lt;/code&gt; ).  To avoid confusion between the terms &lt;i&gt;functor&lt;/i&gt; as in the &lt;i&gt;functor pattern&lt;/i&gt; and OCaml functors referring to parameterized modules, we use the name &lt;i&gt;ocaml-functor&lt;/i&gt; to mean the latter.  Basic familiarity with Haskell syntax is also be assumed. Importantly, note that Haskell uses the infix operator &lt;code&gt;(.)&lt;/code&gt; for function composition: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;f . g = \x -&amp;gt; f (g x)
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
In the OCaml code below we instead use &lt;code class=&quot;code&quot;&gt;( &amp;lt;&amp;lt; )&lt;/code&gt; to be defined similarly along with (the more idiomatic) pattern of forward composition &lt;code class=&quot;code&quot;&gt;( &amp;gt;&amp;gt; )&lt;/code&gt; , an identity function &lt;code class=&quot;code&quot;&gt;id&lt;/code&gt; and a function &lt;code class=&quot;code&quot;&gt;const&lt;/code&gt;:  &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( &amp;lt;&amp;lt; ) f g x = f (g x);;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( &amp;gt;&amp;gt; ) f g = g &amp;lt;&amp;lt; f;;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id x       = x;;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; const x _  = x;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
We also deviate slightly from the naming conventions in Haskell for operations, for instance &lt;code&gt;fmap&lt;/code&gt; becomes &lt;code class=&quot;code&quot;&gt;map&lt;/code&gt; and &lt;code&gt;mconcat&lt;/code&gt; is named &lt;code class=&quot;code&quot;&gt;concat&lt;/code&gt;. &lt;h2&gt;Representing the patterns&lt;/h2&gt;&lt;p&gt;We use a standard approach for mapping type classes in Haskell to module signatures in OCaml. &lt;/p&gt;&lt;h3&gt;Functors&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;Functor&lt;/code&gt; type class captures the pattern of mapping over the value(s) of some parameterized data type. In Haskell it can be defined as: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;class  Functor f  where
  fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
In OCaml we may instead construct a corresponding module signature: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;FUNCTOR&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; map : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order for a type to qualify as a functor, one need to provide an implementation for &lt;code class=&quot;code&quot;&gt;map&lt;/code&gt; (&lt;code&gt;fmap&lt;/code&gt; in Haskell) that satisfies the signature.  For instance, the &lt;code&gt;Functor&lt;/code&gt; instance for the list type in Haskell is given by: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;instance Functor [] where
  fmap = map
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
Here, &lt;code&gt;map&lt;/code&gt; is the standard map function over lists.  In OCaml we create a module implementing the &lt;code class=&quot;code&quot;&gt;FUNCTOR&lt;/code&gt; signature, which for lists may look like: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ListFunctor&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;FUNCTOR&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; map f = &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map f
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One difference is that the module is named which allows for multiple instances of the same signature for the same type to coexist. The &lt;code class=&quot;code&quot;&gt;with type&lt;/code&gt; construct is required in order to be able to export the type &lt;code class=&quot;code&quot;&gt;'a t&lt;/code&gt; specified by the signature. It makes the fact that &lt;code class=&quot;code&quot;&gt;ListFunctor.t&lt;/code&gt; is indeed the type &lt;code class=&quot;code&quot;&gt;list&lt;/code&gt; transparent, allowing us to apply &lt;code class=&quot;code&quot;&gt;ListFunctor.map&lt;/code&gt; to ordinary lists. &lt;/p&gt;&lt;p&gt;Type classes in Haskell often come with a set of &lt;i&gt;laws&lt;/i&gt;. These are specifications that any instance of the type class must obey. However they are not enforced by the type system and thus need to be considered when writing the implementation. For &lt;code&gt;Functor&lt;/code&gt;s, any instances should satisfy the following constraints: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;fmap id = id fmap (f . g)  = fmap f . fmap g
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
These invariants state that the map function must be &lt;i&gt;structure preserving&lt;/i&gt;, i.e. is not allowed to change the shape of the given value mapped over. They also have a deeper theoretical justification when described in terms of &lt;a href=&quot;https://en.wikipedia.org/wiki/Functor&quot;&gt;Functors in Category Theory&lt;/a&gt;.  From a practical point of view it is sufficient to note that violating this constraint leads to code that is difficult to reason about and refactor. Consider for instance a function: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; increment_twice xs =
  xs
  |&amp;gt; &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; x + 1)
  |&amp;gt; &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; x + 1)
;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
One should expect that applying the following optimization: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; increment_twice xs = &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; x + 2) xs;;

&lt;/code&gt;&lt;/pre&gt;does not impact its semantics. &lt;p&gt;An immediate advantage of capturing the functor pattern explicitly via a signature (&lt;code class=&quot;code&quot;&gt;FUNCTOR&lt;/code&gt;) is that it enables us to to define an additional parameterized module with tests for validating any concrete implementation of the signature: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TestFunctor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;FUNCTOR&lt;/span&gt;) = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test_id x = &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.map id x = x

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test_compose xs =
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f x = x &lt;span class=&quot;keyword&quot;&gt;mod&lt;/span&gt; 2 &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; g x = x - 1 &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.map (g &amp;gt;&amp;gt; f) xs = &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.map f (&lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.map g xs)

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
The tests here correspond to the two &lt;i&gt;functor laws&lt;/i&gt; stated above. &lt;p&gt;For instance to test &lt;code class=&quot;code&quot;&gt;ListFunctor&lt;/code&gt; we first apply &lt;code class=&quot;code&quot;&gt;TestFunctor&lt;/code&gt; to this module in order to retrieve a specialized version: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TFL&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;TestFunctor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;ListFunctor&lt;/span&gt;);;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here are a few examples of using the module: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;constructor&quot;&gt;TFL&lt;/span&gt;.test_id [];;
&lt;span class=&quot;constructor&quot;&gt;TFL&lt;/span&gt;.test_id [1;2];;
&lt;span class=&quot;constructor&quot;&gt;TFL&lt;/span&gt;.test_compose [];;
&lt;span class=&quot;constructor&quot;&gt;TFL&lt;/span&gt;.test_compose [1;2;3];;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code class=&quot;code&quot;&gt;option&lt;/code&gt; type in OCaml also forms a functor: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;OptionFunctor&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;FUNCTOR&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a option = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a option
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; map f = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; x  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (f x)
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;    &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
And similar to the list example, we get a test module for free: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TOF&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;TestFunctor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;OptionFunctor&lt;/span&gt;);;

&lt;span class=&quot;constructor&quot;&gt;TOF&lt;/span&gt;.test_id (&lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; 42);;
&lt;span class=&quot;constructor&quot;&gt;TOF&lt;/span&gt;.test_id &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;;;
&lt;span class=&quot;constructor&quot;&gt;TOF&lt;/span&gt;.test_compose (&lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; 42);;
&lt;span class=&quot;constructor&quot;&gt;TOF&lt;/span&gt;.test_compose &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As will be illustrated by some of the examples below, functors are not only applicable to container like types and also not all containers form functors. &lt;/p&gt;&lt;h3&gt;Monoids&lt;/h3&gt;&lt;p&gt;Monoid is another example of a common pattern where instances can be found for a variety of types. In Haskell it's defined as: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;class Monoid m where
  mempty :: m
  mappend :: m -&amp;gt; m -&amp;gt; m
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
Any type qualifying as a monoid must have identity value (&lt;code&gt;mempty&lt;/code&gt;) and a binary operator (&lt;code&gt;mappend&lt;/code&gt;) for composing any two elements. &lt;p&gt;The OCaml version can be specified by the following module type: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;MONOID&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; empty : t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; append : t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; t
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also a few laws that instances should obey: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;mappend mempty x        = x
mappend x mempty        = x
mappend x (mappend y z) = mappend (mappend x y) z
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first two state that &lt;code&gt;mempty&lt;/code&gt; is an identity element with respect to &lt;code&gt;mappend&lt;/code&gt; and the second one that &lt;code&gt;mappend&lt;/code&gt; must be associative. Again, this can be captured by a test module: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TestMonoid&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;MONOID&lt;/span&gt;) = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test_left_id x = &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.append &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.empty x = x

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test_right_id x = &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.append x &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.empty = x

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test_assoc x y z =
    &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.append x (&lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.append y z) = &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.append (&lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.append x y) z

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One of the more famous monoids is given by the natural numbers with addition and identity element &lt;i&gt;0&lt;/i&gt;: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;IntAddMonoid&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;MONOID&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = int = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = int
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; empty = 0
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; append = ( + )
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another advantage of formalizing patterns by explicit signatures is that it enables us to define derived combinators generically. For example, the &lt;code class=&quot;code&quot;&gt;append&lt;/code&gt; operation from &lt;code class=&quot;code&quot;&gt;IntAddMonoid&lt;/code&gt; can be lifted to a sum function accepting a list of integers, adding them together or defaulting to 0 if the empty list is given: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;IntAddMonoid&lt;/span&gt;;;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sum xs = &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.fold_left append empty xs;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The scheme can be generalized to operate on any list of monoids. To avoid having to specify the implementation manually for each monoid instance, one may construct a module-functor for generating extension functions: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;MonoidUtils&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;MONOID&lt;/span&gt;) = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( &amp;lt;+&amp;gt; ) x y = append x y
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; concat xs = &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.fold_left ( &amp;lt;+&amp;gt; ) empty xs
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here &lt;code class=&quot;code&quot;&gt;MonoidUtils&lt;/code&gt; takes a &lt;code class=&quot;code&quot;&gt;MONOID&lt;/code&gt; module and re-exports its definition along with two additional utility functions, an infix version of append &lt;code class=&quot;code&quot;&gt;( &amp;lt;+&amp;gt; )&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;concat&lt;/code&gt;. &lt;/p&gt;&lt;p&gt;Another example of a monoid is a list, parameterized over any type. In Haskell the instance is given by: &lt;/p&gt;&lt;pre&gt;instance Monoid [a] where
  mempty = []
  mappend x y = x ++ y
&lt;/pre&gt;&lt;br/&gt;
Where &lt;code&gt;(++)&lt;/code&gt; is the concatenation operator for lists. In OCaml one could imagine attempting something like: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;comment&quot;&gt;(* Pseudo-code - not valid OCaml! *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ListMonoid&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;MONOID&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; empty = []
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; append xs ys = xs @ ys
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
However it is not possible to directly parameterize modules by types. A work around can be achieved by first introducing a dummy module for wrapping the type and passing it along as a module parameter: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TYPE&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;

&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ListMonoid&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TYPE&lt;/span&gt;) : &lt;span class=&quot;constructor&quot;&gt;MONOID&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.t list = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.t list
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; empty = []
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; append xs ys = xs @ ys
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This comes with an obvious disadvantage of having to create specialized versions for each concrete list type. Some of the inconvenience is compensated for by explicit type parameters and support for local modules, created at run-time.  Here's an example implementing &lt;code class=&quot;code&quot;&gt;concat&lt;/code&gt; for lists in terms of the generic list monoid: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; concat (&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; a) xs =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;MU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;MonoidUtils&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;ListMonoid&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = a &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;)) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;constructor&quot;&gt;MU&lt;/span&gt;.concat xs;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Its signature is inferred as: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; concat : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list list &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Applicative Functors&lt;/h3&gt;&lt;p&gt;An applicative functor has more structure than a regular functor. In Haskell it can be defined as: &lt;/p&gt;&lt;pre&gt;class (Functor f) =&amp;gt; Applicative f where
    pure  :: a -&amp;gt; f a
    (&amp;lt;*&amp;gt;) :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b
&lt;/pre&gt;&lt;br/&gt;
The function &lt;code class=&quot;code&quot;&gt;pure&lt;/code&gt; turns a (pure) value into an applicative value and &lt;code class=&quot;code&quot;&gt;( &amp;lt;*&amp;gt; )&lt;/code&gt; takes a function wrapped inside an applicative along with an applicative value and returns an applicative result corresponding to applying the value to the function. The additional constraint (&lt;code&gt;(Functor f) =&amp;gt; Applicative f&lt;/code&gt; enforces that any type that instantiates the &lt;code&gt;Applicative&lt;/code&gt; type class must also be an instance of &lt;code&gt;Functor&lt;/code&gt;. &lt;p&gt;In OCaml we can achieve something similar by including the &lt;code class=&quot;code&quot;&gt;FUNCTOR&lt;/code&gt; signature within a new signature &lt;code class=&quot;code&quot;&gt;APPLICATIVE&lt;/code&gt; as in: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;FUNCTOR&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; pure : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; apply : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b) t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
Here the infix operator &lt;code class=&quot;code&quot;&gt;( &amp;lt;*&amp;gt; )&lt;/code&gt; is named &lt;code class=&quot;code&quot;&gt;apply&lt;/code&gt;. &lt;p&gt;For a concrete example consider the applicative instance for the list type. Using the &lt;code class=&quot;code&quot;&gt;ListFunctor&lt;/code&gt; module from above: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ListApplicative&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ListFunctor&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pure x = [x]

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; apply fs xs =
    concat @@ map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; f &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; f x) xs) fs

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
&lt;code class=&quot;code&quot;&gt;ListApplicative&lt;/code&gt; simply re-exports the implementation of &lt;code class=&quot;code&quot;&gt;ListFunctor&lt;/code&gt; to satisfy the functor part of the signature, also mirroring the constraint from the Haskell version. &lt;p&gt;&lt;code class=&quot;code&quot;&gt;pure&lt;/code&gt; wraps a value in a list. &lt;code class=&quot;code&quot;&gt;apply&lt;/code&gt; takes a list of functions, a list of values and applies each function to all elements of the list. Once again we may construct a &lt;i&gt;utility module&lt;/i&gt; with some extra operators implemented using the primitive functions: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ApplicativeUtils&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;) = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( &amp;lt;$&amp;gt; ) f     = map f
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( &amp;lt;*&amp;gt; ) f     = apply f
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( &amp;lt;* ) x y    = const &amp;lt;$&amp;gt; x &amp;lt;*&amp;gt; y
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( *&amp;gt; ) x y    = (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; _ y &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; y) &amp;lt;$&amp;gt; x &amp;lt;*&amp;gt; y
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; liftA2 f x y  = f &amp;lt;$&amp;gt; x &amp;lt;*&amp;gt; y
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The infix operators are variations of apply and map, &lt;code class=&quot;code&quot;&gt;liftA2&lt;/code&gt; is for conveniently &lt;em&gt;lifting&lt;/em&gt; a regular function of two arguments into a function operating on two applicative values. &lt;/p&gt;&lt;p&gt;By applying &lt;code class=&quot;code&quot;&gt;ListApplicative&lt;/code&gt; to the &lt;code&gt;ApplicativeUtils&lt;/code&gt; functor we obtain a concrete module for operating on lists: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;LAU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ApplicativeUtils&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;ListApplicative&lt;/span&gt;);;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
Its full signature can be listed by: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt;show_module &lt;span class=&quot;constructor&quot;&gt;LAU&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
Producing the following output: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;LAU&lt;/span&gt; :
    &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;ListApplicative&lt;/span&gt;.t
      &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; map : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
      &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; pure : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
      &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; apply : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b) t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
      &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; ( &amp;lt;$&amp;gt; ) : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
      &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; ( &amp;lt;* ) : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
      &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; ( *&amp;gt; ) : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
      &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; liftA2 : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;c) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;c t
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally let's a take a look at a concrete example to see what the applicative interface actually brings in terms of functionality. Say we want to generate some mock data to be used for testing. Given the following types: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; offer = &lt;span class=&quot;constructor&quot;&gt;Ask&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Bid&lt;/span&gt;;;

&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; quote =
  {
    time : int;
    offer : offer;
    ticker : string;
    value : float;
  };;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The snippet below produces a list of all possible combinations of some example data by combining a set of properties: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; quotes =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;LAU&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; time offer ticker value &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; { time; offer; ticker; value })
  &amp;lt;$&amp;gt; [1;2;3;4;5]
  &amp;lt;*&amp;gt; [&lt;span class=&quot;constructor&quot;&gt;Ask&lt;/span&gt;; &lt;span class=&quot;constructor&quot;&gt;Bid&lt;/span&gt;]
  &amp;lt;*&amp;gt; [&lt;span class=&quot;string&quot;&gt;&amp;quot;XYZ&amp;quot;&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;&amp;quot;ZYK&amp;quot;&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;&amp;quot;ABC&amp;quot;&lt;/span&gt;;&lt;span class=&quot;string&quot;&gt;&amp;quot;CDE&amp;quot;&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;&amp;quot;QRZ&amp;quot;&lt;/span&gt;]
  &amp;lt;*&amp;gt; [100.; 90.; 80.; 70.];;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
By composing applications of &lt;code class=&quot;code&quot;&gt;pure&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;( &amp;lt;*&amp;gt; )&lt;/code&gt; we lift functions of arbitrary arity into applicative versions. For the list applicative, that means a generalized version of Cartesian products. &lt;p&gt;Another useful instance of an applicative functor is the &lt;code class=&quot;code&quot;&gt;option&lt;/code&gt; type: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;OptionApplicative&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a option =
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;OptionFunctor&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pure x = &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; x

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; apply fo xo =
    &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; fo, xo &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; f, &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; x  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (f x)
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _               &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we rely on the &lt;code class=&quot;code&quot;&gt;OptionFunctor&lt;/code&gt; module to manage the functor part. &lt;code class=&quot;code&quot;&gt;pure&lt;/code&gt; returns a value wrapped by the &lt;code class=&quot;code&quot;&gt;Some&lt;/code&gt; constructor and &lt;code class=&quot;code&quot;&gt;apply&lt;/code&gt; only produces a value if neither of its arguments are &lt;code class=&quot;code&quot;&gt;None&lt;/code&gt; values. As with many other examples of instances, there is basically only one feasible implementation to choose from given the type constraints of the function signature. &lt;/p&gt;&lt;p&gt;With the implementation of the core interface, utilities come for free: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;OAU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ApplicativeUtils&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;OptionApplicative&lt;/span&gt;);;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now use it to conveniently lift operations into versions accepting optional arguments. Consider the following (safe) versions of division and square-root functions: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( //. ) n d = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; d = 0. &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (n /. d);;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ssqrt x = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x &amp;lt; 0. &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (sqrt x);;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Say we want to implement the formula &lt;code class=&quot;code&quot;&gt;f(x,y,z) = (x / y) + sqrt(x) - sqrt(y)&lt;/code&gt;. The obvious approach is to use pattern matching as in: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f x y z =
  &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; x //. y, ssqrt x, ssqrt y &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; z, &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; r1, &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; r2  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (z +. r1 -. r2)
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _                         &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using the applicative operators from the &lt;code class=&quot;code&quot;&gt;OAU&lt;/code&gt; module enables an alternative (more succinct) definition: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;OAU&lt;/span&gt;;;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f x y z =
 (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; z r1 r2 &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; z +. r1 -. r2) &amp;lt;$&amp;gt; (x //. y) &amp;lt;*&amp;gt; ssqrt x &amp;lt;*&amp;gt; ssqrt y
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Applicative functors also come with a set of laws. In Haskell expressed as: &lt;/p&gt;&lt;pre&gt;-- Identity
pure id &amp;lt;*&amp;gt; v                 = v

-- Homomorphism
pure f &amp;lt;*&amp;gt; pure x             = pure (f x)

-- Interchange
u &amp;lt;*&amp;gt; pure y                  = pure ($ y) &amp;lt;*&amp;gt; u

--- Composition
pure (.) &amp;lt;*&amp;gt; u &amp;lt;*&amp;gt; v &amp;lt;*&amp;gt; w   = u &amp;lt;*&amp;gt; (v &amp;lt;*&amp;gt; w)
&lt;/pre&gt;&lt;p&gt;These may again be turned into a generic testing module: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TestApplicative&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;) = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;AU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ApplicativeUtils&lt;/span&gt;(&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;)

  &lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;AU&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test_id x = (pure id &amp;lt;*&amp;gt; x) = x

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test_hom f x = pure f &amp;lt;*&amp;gt; pure x = pure (f x)

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test_interchange u y =
    (u &amp;lt;*&amp;gt; pure y) = (pure (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; f &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; f y) &amp;lt;*&amp;gt; u)

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test_composition u v w =
    (pure ( &amp;lt;&amp;lt; ) &amp;lt;*&amp;gt; u &amp;lt;*&amp;gt; v &amp;lt;*&amp;gt; w) = (u &amp;lt;*&amp;gt; (v &amp;lt;*&amp;gt; w))

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
and be used to validate arbitrary instances of this pattern. &lt;p&gt;For example to test the list instance, we first construct a concrete module using the &lt;code class=&quot;code&quot;&gt;TestApplicative&lt;/code&gt; functor: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TAL&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;TestApplicative&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;ListApplicative&lt;/span&gt;);;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
This may be used as in: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;constructor&quot;&gt;TAL&lt;/span&gt;.test_hom &lt;span class=&quot;constructor&quot;&gt;String&lt;/span&gt;.length &lt;span class=&quot;string&quot;&gt;&amp;quot;Homomorphism&amp;quot;&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Traversables&lt;/h3&gt;&lt;p&gt;Traversable is an interesting type class which also brings a couple of additional challenges to our effort of mapping Haskell patterns to OCaml. It may be described as a generalization of the &lt;i&gt;iterator pattern&lt;/i&gt; and is defined in Haskell as: &lt;/p&gt;&lt;pre&gt;class (Functor t, Foldable t) =&amp;gt; Traversable t where
  traverse  :: Applicative f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; t a -&amp;gt; f (t b)
  sequenceA :: Applicative f =&amp;gt; t (f a) -&amp;gt; f (t a)
  mapM      ::       Monad m =&amp;gt; (a -&amp;gt; m b) -&amp;gt; t a -&amp;gt; m (t b)
  sequence  ::       Monad m =&amp;gt; t (m a) -&amp;gt; m (t a)
&lt;/pre&gt;&lt;p&gt;Concrete instances can be written by implementing any one of the above functions as they can all be expressed in terms of each other. We could potentially replicate this flexibility in OCaml by a set of different module-functors with signatures wrapping each function. However, for the purpose of this exercise we settle on &lt;code class=&quot;code&quot;&gt;traverse&lt;/code&gt; as the defining implementation. Traverse is also parameterized over an &lt;code class=&quot;code&quot;&gt;Applicative&lt;/code&gt; functor. A first attempt in OCaml might be something along the lines of: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;comment&quot;&gt;(*Psuedo-code - not valid OCaml!*)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; traverse :  (&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; a)
                  (&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a a)
                  (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b a) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
                  &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
                  (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t) a
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However here the type &lt;code class=&quot;code&quot;&gt;a&lt;/code&gt; would itself require a type parameter.  In Haskell lingo it is said to have kind &lt;code&gt;(* -&amp;gt; *)&lt;/code&gt;.  Unfortunately OCaml does not support higher-kinded polymorphism. &lt;/p&gt;&lt;p&gt;Instead of passing &lt;code class=&quot;code&quot;&gt;APPLICATIVE&lt;/code&gt; as an argument to each invocation of &lt;code class=&quot;code&quot;&gt;traverse&lt;/code&gt; we can embed it in the module signature: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; traverse : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t) &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
To mimic the Haskell constraints it is tempting to also require the &lt;code class=&quot;code&quot;&gt;FUNCTOR&lt;/code&gt; interface by throwing in a extra &lt;code class=&quot;code&quot;&gt;include FUNCTOR&lt;/code&gt;. However, there's a technical reason for why this may not be a good idea which we'll return to in a bit. &lt;p&gt;Even though the signature references a specific implementation of an &lt;code class=&quot;code&quot;&gt;APPLICATIVE&lt;/code&gt; we can recover genericity by relying on module-functors to specify the implementation of a traversable for any applicative argument.  Let's consider the functor for list traversables: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ListTraversable&lt;/span&gt;  (&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;) :
                        &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list
                            &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t =
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; traverse f xs =
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;AU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ApplicativeUtils&lt;/span&gt;(&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;AU&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; xs &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; []      &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.pure []
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; x :: xs &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; y ys &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; y :: ys) &amp;lt;$&amp;gt; f x &amp;lt;*&amp;gt; traverse f xs

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here one has to accept some extra verbosity compared to the Haskell version, although the code itself is fairly straightforward.  The functor argument &lt;code class=&quot;code&quot;&gt;A&lt;/code&gt; of type &lt;code class=&quot;code&quot;&gt;APPLICATIVE&lt;/code&gt; serves to fulfil the requirement of having to export the &lt;code class=&quot;code&quot;&gt;APPLICATIVE&lt;/code&gt; module.  The implementation of &lt;code class=&quot;code&quot;&gt;traverse&lt;/code&gt; is the interesting bit. Note that it is indeed defined generically for any applicative functor. The &lt;code class=&quot;code&quot;&gt;ApplicativeUtils&lt;/code&gt; module constructor comes in handy for accessing the infix versions of the operators. &lt;/p&gt;&lt;p&gt;To give &lt;code class=&quot;code&quot;&gt;ListTraversable&lt;/code&gt; a try, consider how it can be used for option effects: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;LTO&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ListTraversable&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;OptionApplicative&lt;/span&gt;);;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This results in a module with the following signature: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;LTO&lt;/span&gt; :
  &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list
    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; map : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
    &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; traverse : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
where we also know that the &lt;code class=&quot;code&quot;&gt;Applicative&lt;/code&gt; sub-module is in fact our &lt;code class=&quot;code&quot;&gt;OptionApplicative&lt;/code&gt;. &lt;p&gt;&lt;code class=&quot;code&quot;&gt;traverse&lt;/code&gt; in this context is a function that allows us to map each element of a list to an optional value where the computation produces a list with all values collected, only in case every element was successfully mapped to a &lt;code class=&quot;code&quot;&gt;Some&lt;/code&gt; value. &lt;/p&gt;&lt;p&gt;For example using the safe square root function from above we can transform it into a version operating on lists: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; all_roots = &lt;span class=&quot;constructor&quot;&gt;LTO&lt;/span&gt;.traverse ssqrt;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It only returns a list of values with the results in case each element produced a valid square root. A few examples: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; all_roots [4.;9.;16.];;
- : float &lt;span class=&quot;constructor&quot;&gt;LTO&lt;/span&gt;.t &lt;span class=&quot;constructor&quot;&gt;LTO&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; [2.; 3.; 4.]

&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; all_roots [4.;-9.; 16.];;
- : float &lt;span class=&quot;constructor&quot;&gt;LTO&lt;/span&gt;.t &lt;span class=&quot;constructor&quot;&gt;LTO&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, let's consider a custom type (&lt;code class=&quot;code&quot;&gt;'a tree&lt;/code&gt;) for which we are also able to implement the traversable interface: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a tree =
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Leaf&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a tree * &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a * &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a tree
;;

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; node l x r = &lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; (l,x,r);;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Following is an instance of traversable for &lt;code class=&quot;code&quot;&gt;tree&lt;/code&gt;s: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TreeTraversable&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;) :
                        &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a tree
                                  &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t =
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a tree
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a a = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; traverse f t =
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;AU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ApplicativeUtils&lt;/span&gt;(&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;AU&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Leaf&lt;/span&gt;          &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; pure &lt;span class=&quot;constructor&quot;&gt;Leaf&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Node&lt;/span&gt; (l,x,r)  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; node &amp;lt;$&amp;gt; traverse f l &amp;lt;*&amp;gt; f x &amp;lt;*&amp;gt; traverse f r

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;From the Haskell specification we know that any traversable must be a functor.  Comparing the signatures for &lt;code class=&quot;code&quot;&gt;map&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;traverse&lt;/code&gt; also reveals their similarities: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; map       : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; b)       &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; traverse  : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;t &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t)  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t) &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
However, embedding &lt;code class=&quot;code&quot;&gt;map&lt;/code&gt; in the module signature for &lt;code class=&quot;code&quot;&gt;TRAVERSABLE&lt;/code&gt; forces the user to define it manually. Would it be possible to achieve a generic implementation expressed in terms of the traverse function? &lt;p&gt;It can be done by choosing a suitable &lt;code&gt;Applicative&lt;/code&gt; where the effect does not impact the result. The simplest possible type forming an applicative functor is the identity type: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a id = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
for which a trivial &lt;code&gt;APPLICATIVE&lt;/code&gt; instance exist: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;IdApplicative&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a id = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t     = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a id
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pure x    = x
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; map f     = f
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; apply f   = map f
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using &lt;code class=&quot;code&quot;&gt;IdApplicative&lt;/code&gt; for the effect, &lt;code class=&quot;code&quot;&gt;traverse&lt;/code&gt; collapses into &lt;code class=&quot;code&quot;&gt;map&lt;/code&gt;: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TreeTraversableId&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;TreeTraversable&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;IdApplicative&lt;/span&gt;);;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; map f = &lt;span class=&quot;constructor&quot;&gt;TreeTraversableId&lt;/span&gt;.traverse f;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Similar to the pattern of utility modules for extending the interface with additional functions we may implement another module-functor &lt;code class=&quot;code&quot;&gt;TraversableFunctor&lt;/code&gt; that produces a functor instance given a module-functor for building traversables: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TraversableFunctor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;functor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t) =
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TI&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt;(&lt;span class=&quot;constructor&quot;&gt;IdApplicative&lt;/span&gt;)
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; map f = &lt;span class=&quot;constructor&quot;&gt;TI&lt;/span&gt;.traverse f
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Following is an example creating a functor for trees derived from its traversable implementation: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TTU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;TraversableFunctor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;TreeTraversable&lt;/span&gt;);;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
Its map function can be used as in: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;constructor&quot;&gt;TTU&lt;/span&gt;.map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; x * x) (node &lt;span class=&quot;constructor&quot;&gt;Leaf&lt;/span&gt; 3 (node &lt;span class=&quot;constructor&quot;&gt;Leaf&lt;/span&gt; 5 &lt;span class=&quot;constructor&quot;&gt;Leaf&lt;/span&gt;));;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We could also define another utility module for deriving the &lt;code&gt;sequence&lt;/code&gt; operator, in order to recover some of the functionality from Haskell, where &lt;code&gt;sequence&lt;/code&gt; can be defined by instantiating &lt;code&gt;Traversable&lt;/code&gt; and only implementing &lt;code&gt;traverse&lt;/code&gt;: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TraversableSequence&lt;/span&gt;  (&lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; ) = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sequence xs = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.traverse id xs
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The Haskell documentation for &lt;code&gt;Applicative&lt;/code&gt; also dictates a set of laws: &lt;/p&gt;&lt;pre&gt;-- Naturality
t . traverse f = traverse (t . f)

-- Identity
traverse Identity = Identity

-- Composition
traverse (Compose . fmap g . f) = Compose . fmap (traverse g) . traverse f
&lt;/pre&gt;&lt;p&gt;The &lt;em&gt;naturality law&lt;/em&gt; assumes that &lt;code&gt;t&lt;/code&gt; is a &lt;em&gt;natural transformation&lt;/em&gt; from one applicative functor to another. Porting it to OCaml requires a couple of further tricks. First we dedicate a specific module functor for the task which takes two arguments for the applicatives mapped between, along with a traversable constructor. In order to also connect the types, an additional module &lt;code class=&quot;code&quot;&gt;TYPE2&lt;/code&gt; representing types of kind &lt;code&gt;(* -&amp;gt; *)&lt;/code&gt; is introduced: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TYPE2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;

&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TestTraversableNat&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TYPE2&lt;/span&gt;)
                          (&lt;span class=&quot;constructor&quot;&gt;A1&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;)
                          (&lt;span class=&quot;constructor&quot;&gt;A2&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;)
                          (&lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;functor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
                            &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
                                  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t
                                            &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt;.t ) =
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;T1&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
     &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A1&lt;/span&gt;.t &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt;.t = &lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;A1&lt;/span&gt;)

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
     &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A2&lt;/span&gt;.t &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt;.t = &lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;A2&lt;/span&gt;)

  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; nat = { t : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a. &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A1&lt;/span&gt;.t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A2&lt;/span&gt;.t }

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test f {t} x = t (&lt;span class=&quot;constructor&quot;&gt;T1&lt;/span&gt;.traverse f x) = &lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt;.traverse ( f &amp;gt;&amp;gt; t) x
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, &lt;code class=&quot;code&quot;&gt;nat&lt;/code&gt; represents the mapping from &lt;code class=&quot;code&quot;&gt;A1&lt;/code&gt; to &lt;code class=&quot;code&quot;&gt;A2&lt;/code&gt; and the type is introduced in order to be able to express that the transformation is existentially quantified over all type parameters to &lt;code class=&quot;code&quot;&gt;A1.t&lt;/code&gt;. &lt;/p&gt;&lt;p&gt;Here's an example of a concrete realization of a test module: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TTN&lt;/span&gt; =
    &lt;span class=&quot;constructor&quot;&gt;TestTraversableNat&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;)
                       (&lt;span class=&quot;constructor&quot;&gt;IdApplicative&lt;/span&gt;)
                       (&lt;span class=&quot;constructor&quot;&gt;OptionApplicative&lt;/span&gt;)
                       (&lt;span class=&quot;constructor&quot;&gt;ListTraversable&lt;/span&gt;)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The second law, &lt;em&gt;identity&lt;/em&gt;, is expressed in terms of the type &lt;code&gt;Identity&lt;/code&gt; and its functor and applicative instances in Haskell. &lt;code&gt;Identity&lt;/code&gt; in haskell is defined as: &lt;/p&gt;&lt;pre&gt;newtype Identity a = Identity a

instance Functor Identity where
  fmap f (Identity x)  = Identity (f x)

instance Applicative Identity where
  pure = Identity
  (Identity f) &amp;lt;*&amp;gt; (Identity x) = Identity (f x)
&lt;/pre&gt;&lt;p&gt;We've already seen its corresponding OCaml type &lt;code class=&quot;code&quot;&gt;'a id&lt;/code&gt; and the applicative instance, &lt;code&gt;IdApplicative&lt;/code&gt;. Using that we may create another test module for the &lt;em&gt;identity&lt;/em&gt; law: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TestTraversableId&lt;/span&gt; ( &lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;functor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
                      &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t) =
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TI&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;IdApplicative&lt;/span&gt;)
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test x = &lt;span class=&quot;constructor&quot;&gt;TI&lt;/span&gt;.traverse id x = x
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The following example shows how it can be used to test the &lt;code class=&quot;code&quot;&gt;ListTraversable&lt;/code&gt; module-functor: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TTIL&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;TestTraversableId&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;ListTraversable&lt;/span&gt;);;
&lt;span class=&quot;constructor&quot;&gt;TTIL&lt;/span&gt;.test [1;2;3];;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The final law, &lt;i&gt;composibility&lt;/i&gt;, relies on the type &lt;code&gt;Compose&lt;/code&gt; which takes two higher-kinded type arguments and composes them: &lt;/p&gt;&lt;pre&gt;newtype Compose f g a = Compose (f (g a))
&lt;/pre&gt;&lt;p&gt;Its functor and applicative functor instances are achieved by: &lt;/p&gt;&lt;pre&gt;instance (Functor f, Functor g) =&amp;gt; Functor (Compose f g) where
  fmap f (Compose x) = Compose (fmap (fmap f) x)

instance (Applicative f, Applicative g) =&amp;gt; Applicative (Compose f g) where
  pure x = Compose (pure (pure x))
  Compose f &amp;lt;*&amp;gt; Compose x = Compose ((&amp;lt;*&amp;gt;) &amp;lt;$&amp;gt; f &amp;lt;*&amp;gt; x)
&lt;/pre&gt;&lt;p&gt;Once again to circumvent the higher-kinded type restriction we need to resort to modules in OCaml. The following module-functor takes two applicatives as arguments and produces an &lt;code class=&quot;code&quot;&gt;APPLICATIVE&lt;/code&gt; module for the composed type: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ComposeApplicative&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;)
                          (&lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;)
                          : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.t) &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.t =
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.t) &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.t

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pure x = &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.pure (&lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.pure x)

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; map f = &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.map (&lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.map f)

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; apply f x =
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;FU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ApplicativeUtils&lt;/span&gt;(&lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;FU&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    (&lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.apply) &amp;lt;$&amp;gt; f &amp;lt;*&amp;gt; x

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally tackling the law expressed using the &lt;code&gt;Compose&lt;/code&gt; type: &lt;/p&gt;&lt;pre&gt;traverse (Compose . fmap g . f) = Compose . fmap (traverse g) . traverse f
&lt;/pre&gt;&lt;br/&gt;
requires some even heavier plumbing. To demonstrate that it's possible, here's an implementation: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TestTraversableCompose&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TYPE2&lt;/span&gt;)
                              (&lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;  : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;)
                              (&lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;  : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;)
                              (&lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;functor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
                              &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t
                                                    &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt;.t) =
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;AC&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.t &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.t = &lt;span class=&quot;constructor&quot;&gt;ComposeApplicative&lt;/span&gt;(&lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;) (&lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;)

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TF&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.t
          &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt;.t = &lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;)

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TG&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.t
          &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt;.t = &lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;)

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TC&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;G&lt;/span&gt;.t &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.t
          &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;T2&lt;/span&gt;.t = &lt;span class=&quot;constructor&quot;&gt;MT&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;AC&lt;/span&gt;)

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test f g x =
    &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.map (&lt;span class=&quot;constructor&quot;&gt;TG&lt;/span&gt;.traverse g) (&lt;span class=&quot;constructor&quot;&gt;TF&lt;/span&gt;.traverse f x) = &lt;span class=&quot;constructor&quot;&gt;TC&lt;/span&gt;.traverse (f &amp;gt;&amp;gt; &lt;span class=&quot;constructor&quot;&gt;F&lt;/span&gt;.map g) x

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It can be used for testing various combinations of traversables and applicatives. For example: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;TTCL&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;TestTraversableCompose&lt;/span&gt;  (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;)
                                      (&lt;span class=&quot;constructor&quot;&gt;ListApplicative&lt;/span&gt;)
                                      (&lt;span class=&quot;constructor&quot;&gt;OptionApplicative&lt;/span&gt;)
                                      (&lt;span class=&quot;constructor&quot;&gt;ListTraversable&lt;/span&gt;);;
&lt;span class=&quot;constructor&quot;&gt;TTCL&lt;/span&gt;.test (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; [x; x + 1])
          (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x &amp;gt; 10 &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (-x) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;)
          [1;2;3;5];;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Using the patterns&lt;/h2&gt;&lt;p&gt;Now that we've laid the ground and introduced formalized interfaces for some common patterns, the next sections provide a couple of more examples of how these idioms can be used in practice when designing libraries and programs. &lt;/p&gt;&lt;h3&gt;A minimal parsing library&lt;/h3&gt;&lt;p&gt;In the following example we implement a simple parsing library and see how monoids and applicative functors guide the design of the API. &lt;/p&gt;&lt;p&gt;First consider a suitable definition of a parser type: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a p = char list &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a * char list) option;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A parser &lt;code class=&quot;code&quot;&gt;'a p&lt;/code&gt; is a function from a list of characters (input) to an option of a tuple of a value of type &lt;code class=&quot;code&quot;&gt;'a&lt;/code&gt;, produced by the parser along with the remaining tokens of the input. The type is similar in spirit to parsing combinator libraries such as Haskell's &lt;a href=&quot;https://hackage.haskell.org/package/parsec&quot;&gt;Parsec&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;To be able to define parsers that parses a single character, here's a function that takes a mapping function from a character to an optional value and returns a parser that, when successful, produces a value and consumes one element of the input: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; token f = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; []      &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; x :: xs &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;OptionFunctor&lt;/span&gt;.map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; y &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (y, xs)) @@ f x
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It can be used to implement a specialized version &lt;code class=&quot;code&quot;&gt;char&lt;/code&gt; for matching characters: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; char c = token (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; c' &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; c = c' &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; c &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;);;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another useful parser is the one matching an empty list of input: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; empty = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; []  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; ((), [])
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _   &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to compose parsers, either by sequencing them - one parser followed by another, or choosing between multiple parsers, we need to come up with a set of suitable combinators. &lt;/p&gt;&lt;p&gt;Rather than trying to derive such functions directly one can start by looking at existing patterns and identify the ones applicable to parsers. &lt;/p&gt;&lt;p&gt;Doing that requires little thinking besides coming up with feasible implementations and ensuring that the implementation is compliant with the corresponding set of constraints (laws). &lt;/p&gt;&lt;p&gt;For instance, with the parser definition above, we are able to to define an applicative functor interface: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ParserApplicative&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a p = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a p

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; map f p = p &amp;gt;&amp;gt; &lt;span class=&quot;constructor&quot;&gt;OptionFunctor&lt;/span&gt;.map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; (x, cs) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (f x, cs))

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pure x cs = &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (x, cs)

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; apply f x cs =
    &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; f cs &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (f, cs)  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; map f x cs
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;          &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To convince ourselves that the implementation is sound we can use &lt;a href=&quot;https://wiki.haskell.org/Equational_reasoning_examples&quot;&gt; equational reasoning&lt;/a&gt; to prove the laws explicitly. Relying on the &lt;code class=&quot;code&quot;&gt;TestApplicative&lt;/code&gt; module in this case is problematic since it requires comparing for equality and our parser type is a function.  A better implementation of the test modules would also allow parameterization of a comparator module. &lt;/p&gt;&lt;p&gt;The &lt;code class=&quot;code&quot;&gt;ParserApplicative&lt;/code&gt; module grants us access to the functions &lt;code class=&quot;code&quot;&gt;( &amp;lt;*&amp;gt; )&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;( &amp;lt;$&amp;gt; )&lt;/code&gt; for composing parsers of different types: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;APU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ApplicativeUtils&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;ParserApplicative&lt;/span&gt;);;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To give an example, here is a parser that parses the input &lt;code class=&quot;code&quot;&gt;['a';'b';'c']&lt;/code&gt; and produces a unit result: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;APU&lt;/span&gt;;;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; abc = (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; _ _ _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; ()) &amp;lt;$&amp;gt; char &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt; &amp;lt;*&amp;gt; char &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt; &amp;lt;*&amp;gt; char &lt;span class=&quot;string&quot;&gt;'c'&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to represent grammars that allow alternative parsing constructs, we need a way to choose between a set of potential parsers. That is, collapsing a set of parsers into a single parser. Phrased differently, we are looking for a monoid: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ParserMonoid&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TYPE&lt;/span&gt;) : &lt;span class=&quot;constructor&quot;&gt;MONOID&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.t p = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.t p

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; empty _ = &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; append p q  cs =
    &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; p cs &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; x  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; x
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;    &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; q cs

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
Here, &lt;code class=&quot;code&quot;&gt;empty&lt;/code&gt; is the parser that always fails and &lt;code class=&quot;code&quot;&gt;append&lt;/code&gt; takes two parsers and returns a parser that for any input first attempts to run the first parser and in case it fails resorts to the second one. &lt;p&gt;We can now use the &lt;code class=&quot;code&quot;&gt;ParserMonoid&lt;/code&gt; to define a few utility functions: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; fail (&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; a) =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ParserMonoid&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = a &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.empty
;;

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; choose (&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; a) ps =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;MU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;MonoidUtils&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;ParserMonoid&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = a &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;)) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;constructor&quot;&gt;MU&lt;/span&gt;.concat ps
;;

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( &amp;lt;|&amp;gt; ) p q = choose [p; q];;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The functor, applicative functor and a monoid combinators for the parser type, form the baseline of the API.  They are also sufficient for implementing a function for turning any parser into one that applies the parser recursively and collects the results in a list: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;APU&lt;/span&gt;;;

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; delay f cs = f () cs;;

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; many p =
  &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.cons &amp;lt;$&amp;gt; p &amp;lt;*&amp;gt; (delay @@ &lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; many p)
  &amp;lt;|&amp;gt;
  pure []
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The purpose of the function &lt;code class=&quot;code&quot;&gt;delay&lt;/code&gt; is to avoid infinite recursion by allowing to construct parsers lazily (ones that are only realized on demand). &lt;/p&gt;&lt;p&gt;The definition of &lt;code class=&quot;code&quot;&gt;many&lt;/code&gt; states that it is a parser that either parses one result of the given parser &lt;code class=&quot;code&quot;&gt;p&lt;/code&gt; followed by many results; Or in case it fails, consumes no input and returns an empty list (&lt;code class=&quot;code&quot;&gt;pure []&lt;/code&gt;). &lt;/p&gt;&lt;p&gt;Another handy combinator is &lt;code class=&quot;code&quot;&gt;filter&lt;/code&gt; that takes a predicate function for &lt;i&gt;filtering&lt;/i&gt; a parser by only allowing it to succeed when its result satisfies the predicate: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; filter f p cs =
  &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; p cs &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (x, cs) &lt;span class=&quot;keyword&quot;&gt;when&lt;/span&gt; f x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (x,cs)
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _                     &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can use it to define a variation of &lt;code class=&quot;code&quot;&gt;many&lt;/code&gt; for parsing one or more elements: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; many_one p = filter ((&amp;lt;&amp;gt;) []) @@ many p;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When it comes to actually exposing the API for a parser combinator library we may still choose to shield users from any references to modules such as &lt;code class=&quot;code&quot;&gt;ParserApplicative&lt;/code&gt; or &lt;code class=&quot;code&quot;&gt;ParserMonoid&lt;/code&gt; and also include a sub-set of the derived utility functions. &lt;/p&gt;&lt;p&gt;Here is an example of such a module signature: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;PARSER&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sig&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t

  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; empty : unit t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; run : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; string &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a option
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; map : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; pure : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; apply : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b) t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; ( &amp;lt;$&amp;gt; ) : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; ( &amp;lt;*&amp;gt; ) : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b) t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; ( &amp;lt;*  ) : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; ( *&amp;gt;  ) : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; token : (char &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a option) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; char : char &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; char t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; fail : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; choose : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t list &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; ( &amp;lt;|&amp;gt; ) : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; many : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; many_one : &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list t
  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; filter : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; bool) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that it also makes the parser type itself abstract and instead exposes a run function that takes a string as input rather than a list of characters.  To turn a string into a list of characters, access to a function such as: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; list_of_string s =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; aux i l = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &amp;lt; 0 &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; l &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; aux (i - 1) (s.[i] :: l) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  aux (&lt;span class=&quot;constructor&quot;&gt;String&lt;/span&gt;.length s - 1) []
;;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
is assumed. &lt;p&gt;The following implementation realizes the signature using the &lt;code class=&quot;code&quot;&gt;ParserMonoid&lt;/code&gt; and applicative utils (&lt;code class=&quot;code&quot;&gt;APU&lt;/code&gt;) as defined above: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Parser&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;PARSER&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;APU&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; run p s = &lt;span class=&quot;constructor&quot;&gt;OptionFunctor&lt;/span&gt;.map fst @@ p @@ list_of_string s

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; empty = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; []  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; ((), [])
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _   &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; token f = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; []      &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; x :: xs &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;OptionFunctor&lt;/span&gt;.map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; y &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (y, xs)) @@ f x

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; char c = token (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; c' &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; c = c' &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; c &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;)

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; fail (&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; a) =
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ParserMonoid&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = a &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.empty

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; choose (&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; a) ps =
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;MU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;MonoidUtils&lt;/span&gt;(&lt;span class=&quot;constructor&quot;&gt;ParserMonoid&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = a &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;)) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;constructor&quot;&gt;MU&lt;/span&gt;.concat ps

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( &amp;lt;|&amp;gt; ) p q = choose [p; q]

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; delay f cs = f () cs

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; many p =
    &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.cons &amp;lt;$&amp;gt; p &amp;lt;*&amp;gt; (delay @@ &lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; many p)
    &amp;lt;|&amp;gt;
    pure []

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; filter f p cs =
    &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; p cs &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (x, cs) &lt;span class=&quot;keyword&quot;&gt;when&lt;/span&gt; f x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (x,cs)
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _                     &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; many_one p = filter ((&amp;lt;&amp;gt;) []) @@ many p

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally for an example of how to use the library, consider a parser for parsing dates of the format &lt;code&gt;YYYY-MM-DD&lt;/code&gt;: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Parser&lt;/span&gt;;;

&lt;span class=&quot;comment&quot;&gt;(* Parser for a single digit *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; digit = &lt;span class=&quot;string&quot;&gt;&amp;quot;0123456789&amp;quot;&lt;/span&gt; |&amp;gt; list_of_string |&amp;gt; &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map char |&amp;gt; choose;;

&lt;span class=&quot;comment&quot;&gt;(* Integer parser *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; int =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; string_of_list = &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.map (&lt;span class=&quot;constructor&quot;&gt;String&lt;/span&gt;.make 1) &amp;gt;&amp;gt; &lt;span class=&quot;constructor&quot;&gt;String&lt;/span&gt;.concat &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  (string_of_list &amp;gt;&amp;gt; int_of_string) &amp;lt;$&amp;gt; many_one digit;;

&lt;span class=&quot;comment&quot;&gt;(* Integers in a given range *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; int_range mn mx = filter (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; n &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; mn &amp;lt;= n &lt;span class=&quot;keywordsign&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; n &amp;lt;= mx) int;;

&lt;span class=&quot;comment&quot;&gt;(* Parser for digit prefixed by '0'. Ex &amp;quot;07&amp;quot; *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; zero_digit = char &lt;span class=&quot;string&quot;&gt;'0'&lt;/span&gt; *&amp;gt; int_range 1 9;;

&lt;span class=&quot;comment&quot;&gt;(* Years between 1700 and 2400 *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; year  = int_range 1700 2400;;

&lt;span class=&quot;comment&quot;&gt;(* Month as in '01, 02, .. , 11' *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; month = zero_digit &amp;lt;|&amp;gt; int_range 11 12;;

&lt;span class=&quot;comment&quot;&gt;(* Day as in '01, 02, .. 31 *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; day = zero_digit &amp;lt;|&amp;gt; int_range 11 31;;

&lt;span class=&quot;comment&quot;&gt;(* Parser for date of format &amp;quot;YYYY-MM-DD&amp;quot; *)&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; date =
  (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; y m d &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (y,m,d))
  &amp;lt;$&amp;gt; (year &amp;lt;* char &lt;span class=&quot;string&quot;&gt;'-'&lt;/span&gt;)
  &amp;lt;*&amp;gt; (month &amp;lt;* char &lt;span class=&quot;string&quot;&gt;'-'&lt;/span&gt;)
  &amp;lt;*&amp;gt; day
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here are a few examples of running the &lt;code class=&quot;code&quot;&gt;date&lt;/code&gt; parser with different string inputs: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; run date &lt;span class=&quot;string&quot;&gt;&amp;quot;2019-01-23&amp;quot;&lt;/span&gt;;;
- : (int * int * int) option = &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (2019, 1, 23)

&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; run date &lt;span class=&quot;string&quot;&gt;&amp;quot;2019-1-23&amp;quot;&lt;/span&gt;;;
- : (int * int * int) option = &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;

&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; run date &lt;span class=&quot;string&quot;&gt;&amp;quot;999-1-23&amp;quot;&lt;/span&gt;;;
- : (int * int * int) option = &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Analyzing boolean expressions&lt;/h3&gt;&lt;p&gt;In the next example we consider designing a library for representing and operating on boolean expressions. It naturally generalizes to other forms of deeply embedded domain specific languages (EDSLs). &lt;/p&gt;&lt;p&gt;Consider the following data type for representing a boolean expression with variables, parameterized over the variable type. &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a exp =
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;True&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;False&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a exp * &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a exp
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a exp * &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a exp
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a exp
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For convenience we define some helper functions corresponding to the expression constructors: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; etrue           = &lt;span class=&quot;constructor&quot;&gt;True&lt;/span&gt;;;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; efalse          = &lt;span class=&quot;constructor&quot;&gt;False&lt;/span&gt;;;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( &amp;lt;&amp;amp;&amp;gt; ) e1 e2   = &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (e1, e2);;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ( &amp;lt;|&amp;gt; ) e1 e2   = &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (e1, e2);;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; enot e          = &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; e;;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; var x           = &lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; x;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What patterns are applicable to the &lt;code class=&quot;code&quot;&gt;'a exp&lt;/code&gt; type? There are two monoid instances corresponding to the boolean operators &lt;code class=&quot;code&quot;&gt;and&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;or&lt;/code&gt;.  Expressions form a monoid with identity &lt;code class=&quot;code&quot;&gt;false&lt;/code&gt; and the append function &lt;code class=&quot;code&quot;&gt;or&lt;/code&gt;: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;MonoidOrFalse&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TYPE&lt;/span&gt;) : &lt;span class=&quot;constructor&quot;&gt;MONOID&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.t exp = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.t exp
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; empty = efalse &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; append = ( &amp;lt;|&amp;gt; )
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The other monoid is for &lt;code class=&quot;code&quot;&gt;true&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;and&lt;/code&gt;: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;MonoidAndTrue&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TYPE&lt;/span&gt;) : &lt;span class=&quot;constructor&quot;&gt;MONOID&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.t exp = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.t exp
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; empty = etrue &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; append = ( &amp;lt;&amp;amp;&amp;gt; )
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As demonstrated previously, monoids can be promoted to operate on lists. In this case for composing a list of expression values: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; any (&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; a) es =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;MonoidUtils&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;MonoidOrFalse&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = a &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;)) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.concat es;;

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; all (&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; a) es =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;MonoidUtils&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;MonoidAndTrue&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = a &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;)) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt;.concat es;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Continuing through the list of patterns - the expression type naturally forms a traversable: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;ExpTraversable&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt;) :
             &lt;span class=&quot;constructor&quot;&gt;TRAVERSABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a exp
                 &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t =
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a a = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.t
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a exp

  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; traverse f exp =
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;AU&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ApplicativeUtils&lt;/span&gt;(&lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;AU&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; exp &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;True&lt;/span&gt;          &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.pure etrue
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;False&lt;/span&gt;         &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;.pure efalse
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (e1, e2)  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (&amp;lt;&amp;amp;&amp;gt;) &amp;lt;$&amp;gt; traverse f e1 &amp;lt;*&amp;gt; traverse f e2
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (e1, e2)   &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; (&amp;lt;|&amp;gt;) &amp;lt;$&amp;gt; traverse f e1 &amp;lt;*&amp;gt; traverse f e2
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; e         &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; enot  &amp;lt;$&amp;gt; traverse f e
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; v         &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; var   &amp;lt;$&amp;gt; f v

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using this module we also obtain the functor instance for free and are able to implement a map function for expressions via: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;EF&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;TraversableFunctor&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;ExpTraversable&lt;/span&gt;);;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; map f = &lt;span class=&quot;constructor&quot;&gt;EF&lt;/span&gt;.map f;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For example we may use &lt;code class=&quot;code&quot;&gt;map&lt;/code&gt; to create a function that adds a prefix to each variable for values of type &lt;code class=&quot;code&quot;&gt;string exp&lt;/code&gt;: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; add_var_prefix p = map (&lt;span class=&quot;constructor&quot;&gt;Printf&lt;/span&gt;.sprintf &lt;span class=&quot;string&quot;&gt;&amp;quot;%s%s&amp;quot;&lt;/span&gt; p);;
&lt;/code&gt;&lt;/pre&gt;The traversable instance may also be utilized when it comes to evaluating expressions. First consider the following function for evaluating expressions parameterized by a boolean value, that is expressions where each variable is realized as concrete boolean value: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rec&lt;/span&gt; eval_bool_exp = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;True&lt;/span&gt;          &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;False&lt;/span&gt;         &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (e1, e2)  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; eval_bool_exp e1 &lt;span class=&quot;keywordsign&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; eval_bool_exp e2
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (e1, e2)   &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; eval_bool_exp e1 &lt;span class=&quot;keywordsign&quot;&gt;||&lt;/span&gt; eval_bool_exp e2
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; e         &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; not (eval_bool_exp e)
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; x         &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; x
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to write a more generic version that evaluates expressions parameterized by an arbitrary type we need to pass an environment for mapping variables to boolean values. The task can be solved by considering the traversable instance for expressions where the effect is given by the option applicative, and then map over the result and evaluate with &lt;code class=&quot;code&quot;&gt;eval_bool_exp&lt;/code&gt;: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; eval env =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ExpTraversable&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;OptionApplicative&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.traverse env &amp;gt;&amp;gt; &lt;span class=&quot;constructor&quot;&gt;OptionFunctor&lt;/span&gt;.map eval_bool_exp
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To test, assume an environment with two variables (&lt;code&gt;x&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;y&lt;/code&gt;): &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; env = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;   &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;   &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _     &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here are a couple of examples of evaluation expressions using the environment: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; eval env (var &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; &amp;lt;|&amp;gt; enot (var &lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt; &amp;lt;&amp;amp;&amp;gt; var &lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;));;
- : bool &lt;span class=&quot;constructor&quot;&gt;OptionFunctor&lt;/span&gt;.t = &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;

&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; eval env (var &lt;span class=&quot;string&quot;&gt;&amp;quot;z&amp;quot;&lt;/span&gt; &amp;lt;|&amp;gt; enot (var &lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt; &amp;lt;&amp;amp;&amp;gt; var &lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;));;
- : bool &lt;span class=&quot;constructor&quot;&gt;OptionFunctor&lt;/span&gt;.t = &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, say we're asked to write a function that extracts all variables from an expression. Could we leverage the traversable instance for this task as well? &lt;/p&gt;&lt;p&gt;At a first glance this may seem like a stretch as traverse maps over an expression and rebuilds it. This time we're only interested in collecting the variables traversed over. The trick is to pick an appropriate applicative instance; In this case where the effect is accumulating the results. Following is a module-functor, for creating an applicative functor that accumulates results of some type in a list: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;BagApplicative&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt; : &lt;span class=&quot;constructor&quot;&gt;TYPE&lt;/span&gt;) : &lt;span class=&quot;constructor&quot;&gt;APPLICATIVE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.t list =
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a t = &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.t list
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pure _ = []
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; map _ x = x
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; apply f = (@) f
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the type parameter &lt;code class=&quot;code&quot;&gt;'a&lt;/code&gt; in &lt;code class=&quot;code&quot;&gt;'a t&lt;/code&gt; is not actually used and its only purpose is to satisfy the signature of &lt;code class=&quot;code&quot;&gt;APPLICATIVE&lt;/code&gt;. The function &lt;code class=&quot;code&quot;&gt;pure&lt;/code&gt; creates an empty list ignoring its argument. &lt;code class=&quot;code&quot;&gt;map&lt;/code&gt; is effectively a no-op and &lt;code class=&quot;code&quot;&gt;apply&lt;/code&gt; simply concatenates the results of both arguments (which are both lists of accumulated items). &lt;/p&gt;&lt;p&gt;With &lt;code class=&quot;code&quot;&gt;BagApplicative&lt;/code&gt; at our disposal, extracting the variables is a matter of traversing an expression and for each variable encountered putting it in the bag: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; variables (&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; a) exp =
  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ExpTraversable&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;BagApplicative&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t = a &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;)) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;constructor&quot;&gt;T&lt;/span&gt;.traverse &lt;span class=&quot;constructor&quot;&gt;ListApplicative&lt;/span&gt;.pure exp
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This works for any expression type as the explicit type parameter &lt;code class=&quot;code&quot;&gt;a&lt;/code&gt; is used to instantiate the &lt;code&gt;BagApplicative&lt;/code&gt; module-functor. The purpose of &lt;code&gt;ListApplicative.pure&lt;/code&gt; is to wrap a variable in a singleton list, synonymous with &lt;code class=&quot;code&quot;&gt;fun x -&amp;gt; [x]&lt;/code&gt;. &lt;/p&gt;&lt;p&gt;Here's an example of using it to collect variables of a &lt;code class=&quot;code&quot;&gt;string exp&lt;/code&gt;: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; variables (var &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;  &amp;lt;|&amp;gt; (var &lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt; &amp;lt;&amp;amp;&amp;gt; (enot (var &lt;span class=&quot;string&quot;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;))));;
- : string list = [&lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's take a look at yet another exercise for where traversables prove to be useful. Say we wish to expand an expression with variables into all possible realizations.  For example, the expression &lt;code class=&quot;code&quot;&gt;var &amp;quot;x&amp;quot; &amp;lt;|&amp;gt; (var &amp;quot;y&amp;quot; &amp;lt;&amp;amp;&amp;gt; (enot (var &amp;quot;z&amp;quot;)))&lt;/code&gt; contains three variables so there are &lt;i&gt;2&lt;sup&gt;3&lt;/sup&gt;&lt;/i&gt; different realizations corresponding to each permutation of &lt;code class=&quot;code&quot;&gt;true/false&lt;/code&gt; assignments to &lt;code class=&quot;code&quot;&gt;x&lt;/code&gt;, &lt;code class=&quot;code&quot;&gt;y&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;z&lt;/code&gt;. &lt;/p&gt;&lt;p&gt;Every one of them gives rise to an expression where the variable is replaced with a boolean value. The &lt;code&gt;variables&lt;/code&gt; function above already allows us to extract the list but how can we generate all permutations? &lt;/p&gt;&lt;p&gt;For traversing a list (in this case of variables, we may use &lt;code class=&quot;code&quot;&gt;ListTraversable&lt;/code&gt;.  Since each variable yields two possible values (variable and bool pair) we can collect them using the &lt;code&gt;ListApplicative&lt;/code&gt;: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;LTLA&lt;/span&gt; = &lt;span class=&quot;constructor&quot;&gt;ListTraversable&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;ListApplicative&lt;/span&gt;);;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The module &lt;code class=&quot;code&quot;&gt;LTLA&lt;/code&gt; now contains a traverse function: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; traverse : (&lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;b list) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;'&lt;/span&gt;a list list
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
Given that &lt;code class=&quot;code&quot;&gt;ListApplicative&lt;/code&gt; corresponds to the Cartesian product, the effect of &lt;code class=&quot;code&quot;&gt;traverse&lt;/code&gt; is to generate all permutations. &lt;p&gt;For instance: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;LTLA&lt;/span&gt;.traverse (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;]) [1;2;3];;
-: char &lt;span class=&quot;constructor&quot;&gt;LTLA&lt;/span&gt;.t &lt;span class=&quot;constructor&quot;&gt;LTLA&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t = [[&lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;]]
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
Here, each value &lt;i&gt;1&lt;/i&gt;, &lt;i&gt;2&lt;/i&gt; and &lt;i&gt;3&lt;/i&gt;, can replaced with exactly one value &lt;code class=&quot;code&quot;&gt;a&lt;/code&gt; producing a list with a single permutation. &lt;p&gt;Allowing each number to be mapped to two possible values yields &lt;i&gt;8&lt;/i&gt; results: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;LTLA&lt;/span&gt;.traverse (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;]) [1;2;3];;
  - : char &lt;span class=&quot;constructor&quot;&gt;LTLA&lt;/span&gt;.t &lt;span class=&quot;constructor&quot;&gt;LTLA&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Applicative&lt;/span&gt;.t =
  [[&lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;]; [&lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;]; [&lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;]; [&lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;];
   [&lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;]; [&lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;]; [&lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;]; [&lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;]]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In our case we're interested in mapping the unique set of collected variables to the values &lt;code class=&quot;code&quot;&gt;true&lt;/code&gt; or &lt;code class=&quot;code&quot;&gt;false&lt;/code&gt; for which each resulting permutation yields a lookup function. The function &lt;code class=&quot;code&quot;&gt;realizations&lt;/code&gt; below also maps over the lookup function to replace the variables with their corresponding boolean values for the given expression: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; realizations exp =
  variables exp
  |&amp;gt; &lt;span class=&quot;constructor&quot;&gt;LTLA&lt;/span&gt;.traverse (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; [(x,&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;); (x,&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;)])
  |&amp;gt; &lt;span class=&quot;constructor&quot;&gt;ListFunctor&lt;/span&gt;.map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; xs &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; map (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.assoc x xs) exp)
;;
&lt;/code&gt;&lt;/pre&gt;Here's an example of using it: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; realizations (var &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;  &amp;lt;|&amp;gt; (var &lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt; &amp;lt;&amp;amp;&amp;gt; (enot (var &lt;span class=&quot;string&quot;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;))));;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
returning the following result: &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;[
  &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)));
  &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;)));
  &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)));
  &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;)));
  &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)));
  &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;)));
  &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)));
  &lt;span class=&quot;constructor&quot;&gt;Or&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;And&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;constructor&quot;&gt;Not&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;)))
]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To see why such a function may be useful, consider how it can be used for evaluating all expanded versions of an expression in order to deduce whether or not an expression always evaluates to true or false, irrespective of the choice of variables: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; always_true exp =
  realizations exp
  |&amp;gt; all
  |&amp;gt; eval_bool_exp
;;

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; always_false exp =
  realizations exp
  |&amp;gt; any
  |&amp;gt; eval_bool_exp
  |&amp;gt; not
;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At last, a few examples to demonstrate their behavior: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; always_true (var &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;);;
- : bool = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;

&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; always_true (var &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; &amp;lt;|&amp;gt; etrue);;
- : bool = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;

&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; always_true (var &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; &amp;lt;|&amp;gt; (enot (var &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;)));;
- : bool = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;

&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; always_false (var &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;);;
- : bool = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;

&lt;span class=&quot;keywordsign&quot;&gt;#&lt;/span&gt; always_false (var &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; &amp;lt;&amp;amp;&amp;gt; (enot (var &lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;)));;
- : bool = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Summary&lt;/h2&gt;&lt;p&gt;Many Haskell patterns implemented in terms of type classes may indeed be ported to OCaml. As demonstrated by the introduction of functor, monoid, applicative functor and traversable module signatures, and the examples, there is a case to be made for why leveraging patterns can help with guiding the specification of APIs and enable code reuse. &lt;/p&gt;&lt;p&gt;On a more philosophical level - thinking in terms of patterns changes the methodology of writing programs. Under this regime, rather than solving isolated problems one starts by implementing generic functionality and later focus on how to make use of it for addressing more specific problems. &lt;/p&gt;&lt;p&gt;In the parser example we saw how two patterns, monoid and applicative functor, were sufficient for describing the primitive set of base combinators (&lt;code class=&quot;code&quot;&gt;(&amp;lt;|&amp;gt;&lt;/code&gt;, &lt;code class=&quot;code&quot;&gt;&amp;lt;*&amp;gt;&lt;/code&gt; etc), out of which others could be inferred (e.g. &lt;code class=&quot;code&quot;&gt;many&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;many_one&lt;/code&gt;). &lt;/p&gt;&lt;p&gt;In the example for representing and operating on boolean expressions, defining a traversable instance formed the cornerstone from which a variety of functionality was derived, including: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Mapping over expression&lt;/li&gt;
&lt;li&gt;Evaluating expressions&lt;/li&gt;
&lt;li&gt;Collecting variables from expressions&lt;/li&gt;
&lt;/ul&gt;This was all accomplished by customizing the &lt;em&gt;effect&lt;/em&gt; of &lt;code class=&quot;code&quot;&gt;traverse&lt;/code&gt; by varying the applicative functor argument. &lt;/body&gt; &lt;/html&gt;  </content><id>http://blog.shaynefletcher.org/2017/05/more-type-classes-in-ocaml.html</id><title type="text">More type classes in OCaml</title><updated>2017-05-22T16:34:00-00:00</updated><author><name>Unknown</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/05/proving-mem-map-property.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">&amp;amp;#60;!DOCTYPE HTML PUBLIC &amp;amp;#34;-//W3C//DTD HTML 4.01//EN&amp;amp;#34;
          &amp;amp;#34;http://www.w3.org/TR/html4/strict.dtd&amp;amp;#34;&amp;amp;#62;
&amp;amp;#60;html&amp;amp;#62;
  &amp;amp;#60;head&amp;amp;#62;
&amp;amp;#60;style&amp;amp;#62;
.keyword { font-weight : bold ; color : Red }
.keywordsign { color : #C04600 }
.comment { color : Green }
.constructor { color : Blue }
.type { color : #5C6585 }
.string { color : Maroon }
.warning { color : Red ; font-weight : bold }
.info { margin-left : 3em; margin-right: 3em }
.param_info { margin-top: 4px; margin-left : 3em; margin-right : 3em }
.code { color : #465F91 ; }
pre { margin-bottom: 4px; font-family: monospace; }
pre.verbatim, pre.codepre { }&amp;amp;#60;/style&amp;amp;#62;
    &amp;amp;#60;title&amp;amp;#62;&amp;amp;#60;/title&amp;amp;#62;
  &amp;amp;#60;/head&amp;amp;#62;
  &amp;amp;#60;body&amp;amp;#62;
    &amp;amp;#60;p&amp;amp;#62;
      Here are two well known &amp;amp;#34;classic&amp;amp;#34; functions over polymorphic
      lists.
    &amp;amp;#60;/p&amp;amp;#62;
    &amp;amp;#60;p&amp;amp;#62;
      &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;map f l&amp;amp;#60;/code&amp;amp;#62; computes a new list from &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62;
      by applying &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f&amp;amp;#60;/code&amp;amp;#62; to each of its elements.
&amp;amp;#60;pre&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;&amp;amp;#60;span class=&amp;amp;#34;keyword&amp;amp;#34;&amp;amp;#62;let&amp;amp;#60;/span&amp;amp;#62; &amp;amp;#60;span class=&amp;amp;#34;keyword&amp;amp;#34;&amp;amp;#62;rec&amp;amp;#60;/span&amp;amp;#62; map (f : &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;'&amp;amp;#60;/span&amp;amp;#62;a &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;-&amp;amp;#38;gt;&amp;amp;#60;/span&amp;amp;#62; &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;'&amp;amp;#60;/span&amp;amp;#62;b) : &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;'&amp;amp;#60;/span&amp;amp;#62;a list &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;-&amp;amp;#38;gt;&amp;amp;#60;/span&amp;amp;#62; &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;'&amp;amp;#60;/span&amp;amp;#62;b list = &amp;amp;#60;span class=&amp;amp;#34;keyword&amp;amp;#34;&amp;amp;#62;function&amp;amp;#60;/span&amp;amp;#62;
        &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;|&amp;amp;#60;/span&amp;amp;#62; [] &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;-&amp;amp;#38;gt;&amp;amp;#60;/span&amp;amp;#62; []
        &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;|&amp;amp;#60;/span&amp;amp;#62; h :: t &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;-&amp;amp;#38;gt;&amp;amp;#60;/span&amp;amp;#62; f h :: map f t
        ;;
&amp;amp;#60;/code&amp;amp;#62;&amp;amp;#60;/pre&amp;amp;#62;
    &amp;amp;#60;/p&amp;amp;#62;

    &amp;amp;#60;p&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem x l&amp;amp;#60;/code&amp;amp;#62; returns &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;true&amp;amp;#60;/code&amp;amp;#62; is &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x&amp;amp;#60;/code&amp;amp;#62;
      is an element of &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62; and returns &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;false&amp;amp;#60;/code&amp;amp;#62; if it
      is not.
&amp;amp;#60;pre&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;&amp;amp;#60;span class=&amp;amp;#34;keyword&amp;amp;#34;&amp;amp;#62;let&amp;amp;#60;/span&amp;amp;#62; &amp;amp;#60;span class=&amp;amp;#34;keyword&amp;amp;#34;&amp;amp;#62;rec&amp;amp;#60;/span&amp;amp;#62; mem (a : &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;'&amp;amp;#60;/span&amp;amp;#62;a) : &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;'&amp;amp;#60;/span&amp;amp;#62;a list &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;-&amp;amp;#38;gt;&amp;amp;#60;/span&amp;amp;#62; bool  = &amp;amp;#60;span class=&amp;amp;#34;keyword&amp;amp;#34;&amp;amp;#62;function&amp;amp;#60;/span&amp;amp;#62;
        &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;|&amp;amp;#60;/span&amp;amp;#62; [] &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;-&amp;amp;#38;gt;&amp;amp;#60;/span&amp;amp;#62; &amp;amp;#60;span class=&amp;amp;#34;keyword&amp;amp;#34;&amp;amp;#62;false&amp;amp;#60;/span&amp;amp;#62;
        &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;|&amp;amp;#60;/span&amp;amp;#62; x :: l &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;-&amp;amp;#38;gt;&amp;amp;#60;/span&amp;amp;#62; a = x &amp;amp;#60;span class=&amp;amp;#34;keywordsign&amp;amp;#34;&amp;amp;#62;||&amp;amp;#60;/span&amp;amp;#62; mem a l
        ;;
&amp;amp;#60;/code&amp;amp;#62;&amp;amp;#60;/pre&amp;amp;#62;
    &amp;amp;#60;/p&amp;amp;#62;
    &amp;amp;#60;p&amp;amp;#62;
      If &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;y&amp;amp;#60;/code&amp;amp;#62; is an element of the list obtained by
      mapping &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f&amp;amp;#60;/code&amp;amp;#62; over &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62; then there must be an
      element &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x&amp;amp;#60;/code&amp;amp;#62; in &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62; such that 
      &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x = y&amp;amp;#60;/code&amp;amp;#62;. Conversely, if there exists an &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x&amp;amp;#60;/code&amp;amp;#62;
      in &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62; such that &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;y = f x&amp;amp;#60;/code&amp;amp;#62;,
      then &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;y&amp;amp;#60;/code&amp;amp;#62; must be a member of the list obtained by
      mapping &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f&amp;amp;#60;/code&amp;amp;#62; over &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62;.
   &amp;amp;#60;/p&amp;amp;#62;
    &amp;amp;#60;p&amp;amp;#62;
      We attempt a proof of correctness of the given definitions with
      respect to this property.
    &amp;amp;#60;/p&amp;amp;#62;

    &amp;amp;#60;b&amp;amp;#62;Lemma&amp;amp;#60;/b&amp;amp;#62; &amp;amp;#60;code&amp;amp;#62;mem_map_iff&amp;amp;#60;/code&amp;amp;#62;:
    &amp;amp;#60;pre&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;
    &amp;amp;#38;forall; (f : &amp;amp;#38;alpha; &amp;amp;#38;rarr; &amp;amp;#38;beta;) (l : &amp;amp;#38;alpha; list) (y : &amp;amp;#38;beta;),
        mem y (map f l) &amp;amp;#38;iff; &amp;amp;#38;exist;(x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; mem x l.
    &amp;amp;#60;/code&amp;amp;#62;&amp;amp;#60;/pre&amp;amp;#62;
    &amp;amp;#60;b&amp;amp;#62;Proof:&amp;amp;#60;/b&amp;amp;#62;&amp;amp;#60;br/&amp;amp;#62;
    &amp;amp;#60;ul&amp;amp;#62;

      &amp;amp;#60;li&amp;amp;#62;We first treat the forward implication
        &amp;amp;#60;pre&amp;amp;#62;
          &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;
    &amp;amp;#38;forall; (f : &amp;amp;#38;alpha; &amp;amp;#38;rarr; &amp;amp;#38;beta;) (l : &amp;amp;#38;alpha; list) (y : &amp;amp;#38;beta;),
      mem y (map f l) &amp;amp;#38;Implies; &amp;amp;#38;exist;(x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; mem x l
        &amp;amp;#60;/code&amp;amp;#62;&amp;amp;#60;/pre&amp;amp;#62;
        and proceed by induction on &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62;.
        &amp;amp;#60;br/&amp;amp;#62;
        &amp;amp;#60;br/&amp;amp;#62;

        &amp;amp;#60;ul&amp;amp;#62;
          &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l = []&amp;amp;#60;/code&amp;amp;#62;:
            &amp;amp;#60;ul&amp;amp;#62;
              &amp;amp;#60;li&amp;amp;#62;Show &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem y (map f []) &amp;amp;#38;Implies; &amp;amp;#38;exist;(x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; mem x []&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
              &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem y (map f []) &amp;amp;#38;equiv; False&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
              &amp;amp;#60;li&amp;amp;#62;Proof follows &amp;amp;#60;i&amp;amp;#62;(ex falso quodlibet)&amp;amp;#60;/i&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
            &amp;amp;#60;/ul&amp;amp;#62;
            &amp;amp;#60;br/&amp;amp;#62;
          &amp;amp;#60;/li&amp;amp;#62; &amp;amp;#60;!-- l is empty --&amp;amp;#62;

        &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62; has form &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x' :: l&amp;amp;#60;/code&amp;amp;#62; (use &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62; now to refer to the tail):
            &amp;amp;#60;ul&amp;amp;#62;
              &amp;amp;#60;li&amp;amp;#62;Assume the induction hypothesis:
                &amp;amp;#60;ul&amp;amp;#62;&amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem y (map f l) &amp;amp;#38;Implies; &amp;amp;#38;exist;x, f x = y &amp;amp;#38;and; mem x l&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;&amp;amp;#60;/ul&amp;amp;#62;&amp;amp;#60;/li&amp;amp;#62;
              &amp;amp;#60;li&amp;amp;#62;We are required to show for an arbitrary &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;(x' : &amp;amp;#38;alpha;)&amp;amp;#60;/code&amp;amp;#62;:
                &amp;amp;#60;ul&amp;amp;#62;&amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem y (map f (x' :: l)) &amp;amp;#38;Implies; &amp;amp;#38;exist;(x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; mem x (x' :: l)&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;&amp;amp;#60;/ul&amp;amp;#62;
              &amp;amp;#60;/li&amp;amp;#62;
              &amp;amp;#60;li&amp;amp;#62;By simplification, we can rewrite the above to:
                &amp;amp;#60;ul&amp;amp;#62;&amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x' = y &amp;amp;#38;or; mem y (map f l) &amp;amp;#38;Implies; &amp;amp;#38;exist;(x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; (x' = x &amp;amp;#38;or; mem x l).&amp;amp;#60;/code&amp;amp;#62;&amp;amp;#60;/li&amp;amp;#62;&amp;amp;#60;/ul&amp;amp;#62;
              &amp;amp;#60;/li&amp;amp;#62;
              &amp;amp;#60;li&amp;amp;#62;We assume then an &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;(x' : &amp;amp;#38;alpha;)&amp;amp;#60;/code&amp;amp;#62; and a &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;(y : &amp;amp;#38;beta;)&amp;amp;#60;/code&amp;amp;#62; such
                that:
                &amp;amp;#60;ol&amp;amp;#62;
                  &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x' = y &amp;amp;#38;or; mem y (map f l)&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
                  &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem y (map f l) &amp;amp;#38;Implies; &amp;amp;#38;exist;(x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; mem x l&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
                &amp;amp;#60;/ol&amp;amp;#62;
              &amp;amp;#60;/li&amp;amp;#62;
              &amp;amp;#60;li&amp;amp;#62;Show &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;&amp;amp;#38;exist;(x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; (x' = x &amp;amp;#38;or; mem x l)&amp;amp;#60;/code&amp;amp;#62;:
                &amp;amp;#60;ul&amp;amp;#62;
                  &amp;amp;#60;li&amp;amp;#62;First consider &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x' = y&amp;amp;#60;/code&amp;amp;#62; in (1).
                    &amp;amp;#60;ul&amp;amp;#62;
                      &amp;amp;#60;li&amp;amp;#62;Take &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x = x'&amp;amp;#60;/code&amp;amp;#62; in the goal.&amp;amp;#60;/li&amp;amp;#62;
                      &amp;amp;#60;li&amp;amp;#62;Then by (1) &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x = y &amp;amp;#38;and; x = x'&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
                      &amp;amp;#60;li&amp;amp;#62;So &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x'&amp;amp;#60;/code&amp;amp;#62; is a witness.&amp;amp;#60;/li&amp;amp;#62;
                    &amp;amp;#60;/ul&amp;amp;#62;
                  &amp;amp;#60;/li&amp;amp;#62;
                  &amp;amp;#60;li&amp;amp;#62;Now consider &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem y (map f l)&amp;amp;#60;/code&amp;amp;#62; in (1).
                    &amp;amp;#60;ul&amp;amp;#62;
                      &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;&amp;amp;#38;exist;(x&amp;amp;#60;sup&amp;amp;#62;*&amp;amp;#60;/sup&amp;amp;#62; : &amp;amp;#38;alpha;), f x&amp;amp;#60;sup&amp;amp;#62;*&amp;amp;#60;/sup&amp;amp;#62; = y &amp;amp;#38;and; mem x&amp;amp;#60;sup&amp;amp;#62;*&amp;amp;#60;/sup&amp;amp;#62; l&amp;amp;#60;/code&amp;amp;#62; by (2).&amp;amp;#60;/li&amp;amp;#62;
                      &amp;amp;#60;li&amp;amp;#62;Take &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x = x&amp;amp;#60;sup&amp;amp;#62;*&amp;amp;#60;/sup&amp;amp;#62;&amp;amp;#60;/code&amp;amp;#62; in the goal.&amp;amp;#60;/li&amp;amp;#62;
                      &amp;amp;#60;li&amp;amp;#62;By the above &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x&amp;amp;#60;sup&amp;amp;#62;*&amp;amp;#60;/sup&amp;amp;#62; = y &amp;amp;#38;and; mem x&amp;amp;#60;sup&amp;amp;#62;*&amp;amp;#60;/sup&amp;amp;#62; l&amp;amp;#60;/code&amp;amp;#62;&amp;amp;#60;/li&amp;amp;#62;
                      &amp;amp;#60;li&amp;amp;#62;So &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x&amp;amp;#60;sup&amp;amp;#62;*&amp;amp;#60;/sup&amp;amp;#62;&amp;amp;#60;/code&amp;amp;#62; is a witness&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
                    &amp;amp;#60;/ul&amp;amp;#62;
                  &amp;amp;#60;/li&amp;amp;#62;
                &amp;amp;#60;/ul&amp;amp;#62;
              &amp;amp;#60;/li&amp;amp;#62;
            &amp;amp;#60;/ul&amp;amp;#62;
          &amp;amp;#60;/li&amp;amp;#62; &amp;amp;#60;!-- l is non-empty --&amp;amp;#62;
        &amp;amp;#60;/ul&amp;amp;#62;
        &amp;amp;#60;br/&amp;amp;#62;&amp;amp;#60;/br&amp;amp;#62;
      &amp;amp;#60;/li&amp;amp;#62;&amp;amp;#60;!-- Forward implication --&amp;amp;#62;

      &amp;amp;#60;li&amp;amp;#62;
      We now work on the reverse implication. We want to show that
      &amp;amp;#60;pre&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;
    &amp;amp;#38;forall; (f : &amp;amp;#38;alpha; &amp;amp;#38;rarr; &amp;amp;#38;beta;) (l : &amp;amp;#38;alpha; list) (y : &amp;amp;#38;beta;),
       &amp;amp;#38;exist;(x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; mem x l &amp;amp;#38;Implies; mem y (map f l)
      &amp;amp;#60;/code&amp;amp;#62;&amp;amp;#60;/pre&amp;amp;#62;
      and proceed by induction on &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62;.
      &amp;amp;#60;br/&amp;amp;#62;&amp;amp;#60;br/&amp;amp;#62;
      &amp;amp;#60;ul&amp;amp;#62;
        &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l = []&amp;amp;#60;/code&amp;amp;#62;:
        &amp;amp;#60;ul&amp;amp;#62;
          &amp;amp;#60;li&amp;amp;#62;Assume &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x&amp;amp;#60;/code&amp;amp;#62;, &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;y&amp;amp;#60;/code&amp;amp;#62; with &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x = y &amp;amp;#38;and; mem x []&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
          &amp;amp;#60;li&amp;amp;#62;Show &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem y (map f [])&amp;amp;#60;/code&amp;amp;#62;:&amp;amp;#60;/li&amp;amp;#62;
           &amp;amp;#60;ul&amp;amp;#62;
             &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem x [] &amp;amp;#38;equiv; false&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
             &amp;amp;#60;li&amp;amp;#62;Proof follows &amp;amp;#60;i&amp;amp;#62;(ex falso quodlibet)&amp;amp;#60;/i&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
           &amp;amp;#60;/ul&amp;amp;#62;
        &amp;amp;#60;/ul&amp;amp;#62;
        &amp;amp;#60;/li&amp;amp;#62;&amp;amp;#60;!-- l = [] --&amp;amp;#62;

        &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62; has form &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x' :: l&amp;amp;#60;/code&amp;amp;#62; (use &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;l&amp;amp;#60;/code&amp;amp;#62; now to refer to the tail):
          &amp;amp;#60;ul&amp;amp;#62;
            &amp;amp;#60;li&amp;amp;#62;Assume the induction hypothesis:
            &amp;amp;#60;ul&amp;amp;#62;&amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;&amp;amp;#38;exist;(x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; mem x l &amp;amp;#38;Implies; mem y (map f l)&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;&amp;amp;#60;/ul&amp;amp;#62;
            &amp;amp;#60;/li&amp;amp;#62;
            &amp;amp;#60;li&amp;amp;#62;We are required to show for an arbitrary &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;(x' : &amp;amp;#38;alpha;)&amp;amp;#60;/code&amp;amp;#62;:
              &amp;amp;#60;ul&amp;amp;#62;&amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;&amp;amp;#38;exist; (x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; mem x (x' :: l) &amp;amp;#38;Implies; mem y (map f (x' :: l))&amp;amp;#60;/code&amp;amp;#62;&amp;amp;#60;/li&amp;amp;#62;&amp;amp;#60;/ul&amp;amp;#62;
            &amp;amp;#60;/li&amp;amp;#62;
            &amp;amp;#60;li&amp;amp;#62;By simplification, we can rewrite the above to:
              &amp;amp;#60;ul&amp;amp;#62;&amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;&amp;amp;#38;exist; (x : &amp;amp;#38;alpha;), f x = y &amp;amp;#38;and; x = x' &amp;amp;#38;or; mem x l &amp;amp;#38;Implies; f x' = y &amp;amp;#38;or; mem y (map f l)&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;&amp;amp;#60;/ul&amp;amp;#62;
            &amp;amp;#60;/li&amp;amp;#62;
            &amp;amp;#60;li&amp;amp;#62;Assume the goal and induction hypotheses:
              &amp;amp;#60;ul&amp;amp;#62;
                &amp;amp;#60;li&amp;amp;#62;There is &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;(x : &amp;amp;#38;alpha;)&amp;amp;#60;/code&amp;amp;#62; and &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;(y : &amp;amp;#38;beta;)&amp;amp;#60;/code&amp;amp;#62; such that:
                  &amp;amp;#60;ol&amp;amp;#62;
                    &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x = y &amp;amp;#38;and; (x = x' &amp;amp;#38;or; mem x l)&amp;amp;#60;/code&amp;amp;#62;&amp;amp;#60;/li&amp;amp;#62;
                    &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x = y &amp;amp;#38;and; mem x l &amp;amp;#38;Implies; mem y (map f l)&amp;amp;#60;/code&amp;amp;#62;&amp;amp;#60;/li&amp;amp;#62;
                  &amp;amp;#60;/ol&amp;amp;#62;
                &amp;amp;#60;/li&amp;amp;#62;
              &amp;amp;#60;/ul&amp;amp;#62;
            &amp;amp;#60;/li&amp;amp;#62;
            &amp;amp;#60;li&amp;amp;#62;Show &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x' = y &amp;amp;#38;or; mem y (map f l)&amp;amp;#60;/code&amp;amp;#62;:
              &amp;amp;#60;ul&amp;amp;#62;
                &amp;amp;#60;li&amp;amp;#62;Assume &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;x = x'&amp;amp;#60;/code&amp;amp;#62; in (1) and show &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x' = y&amp;amp;#60;/code&amp;amp;#62;:
                  &amp;amp;#60;ul&amp;amp;#62;
                   &amp;amp;#60;li&amp;amp;#62;Since, &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x = y&amp;amp;#60;/code&amp;amp;#62; is given by (1.), &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x' = y&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
                  &amp;amp;#60;/ul&amp;amp;#62;
                &amp;amp;#60;/li&amp;amp;#62;
                &amp;amp;#60;li&amp;amp;#62;Assume &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem x l&amp;amp;#60;/code&amp;amp;#62; in (1) and show &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem y (map f l)&amp;amp;#60;/code&amp;amp;#62;:
                  &amp;amp;#60;ul&amp;amp;#62;
                    &amp;amp;#60;li&amp;amp;#62;Rewrite &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem y (map f l)&amp;amp;#60;/code&amp;amp;#62; via (2) to &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x = y &amp;amp;#38;and; mem x l&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
                    &amp;amp;#60;li&amp;amp;#62;&amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;f x = y&amp;amp;#60;/code&amp;amp;#62; by (1) so &amp;amp;#60;code class=&amp;amp;#34;code&amp;amp;#34;&amp;amp;#62;mem y (map f l)&amp;amp;#60;/code&amp;amp;#62;.&amp;amp;#60;/li&amp;amp;#62;
                  &amp;amp;#60;/ul&amp;amp;#62;
                &amp;amp;#60;/li&amp;amp;#62;
              &amp;amp;#60;/ul&amp;amp;#62;
            &amp;amp;#60;/li&amp;amp;#62;
          &amp;amp;#60;/ul&amp;amp;#62;
        &amp;amp;#60;/li&amp;amp;#62;&amp;amp;#60;!-- l is non-empty --&amp;amp;#62;
      &amp;amp;#60;/ul&amp;amp;#62;
      &amp;amp;#60;/li&amp;amp;#62;&amp;amp;#60;!-- Reverse implication --&amp;amp;#62;
    &amp;amp;#60;/ul&amp;amp;#62;
&amp;amp;#38;#8718;
    &amp;amp;#60;hr/&amp;amp;#62;
    &amp;amp;#60;p&amp;amp;#62;
    References:&amp;amp;#60;br/&amp;amp;#62;
    &amp;amp;#60;a href=&amp;amp;#34;https://www.cis.upenn.edu/~bcpierce/sf/current/index.html&amp;amp;#34;&amp;amp;#62;&amp;amp;#34;Sofware Foundations&amp;amp;#34;&amp;amp;#60;/a&amp;amp;#62; -- Pierce et. al.
    &amp;amp;#60;/p&amp;amp;#62;
  &amp;amp;#60;/body&amp;amp;#62;
&amp;amp;#60;/html&amp;amp;#62;
</content><id>http://blog.shaynefletcher.org/2017/05/proving-mem-map-property.html</id><title type="text">Proving a mem/map property</title><updated>2017-05-11T20:17:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/05/preprocessor-extensions-for-code.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
    
    &lt;title&gt;PPX&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;h2&gt;Preprocessor extensions for code generation&lt;/h2&gt;
  &lt;p&gt;&amp;quot;A Guide to Extension Points in OCaml&amp;quot;[1] provides a great
  &amp;quot;quick-start&amp;quot; on using the OCaml extension points API to implement
  preprocessor extensions for abstract syntax tree rewrites. This post
  picks up where that tutorial leaves off by showing how to write a
  ppx that does code generation.
  &lt;/p&gt;
  &lt;p&gt;The problem treated here is one posed in Whitequark's blog :
  &amp;quot;Implement a syntax extension that would accept type declarations of
  the form 
  &lt;code class=&quot;code&quot;&gt;type t = A [@id 1] | B of int [@id 4] [@@id_of]&lt;/code&gt; 
  to generate a function mapping a value of type &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt; to its
  integer representation.&amp;quot;
  &lt;/p&gt;

  &lt;h2&gt;Implementing the &amp;quot;&lt;code class=&quot;code&quot;&gt;id_of&lt;/code&gt;&amp;quot; ppx&lt;/h2&gt;

  &lt;h3&gt;The basic strategy&lt;/h3&gt;
  &lt;p&gt;In the OCaml parse tree, structures are lists of structure
  items. Type declarations are structure items as are let-bindings to
  functions.
  &lt;/p&gt;
  &lt;p&gt;In this program, analysis of an inductive type declaration &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt; 
  may result in the production of a new structure item, the AST of an &lt;code class=&quot;code&quot;&gt;of_id&lt;/code&gt; function
  to be appended to the structure containing &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt;.
  &lt;/p&gt;
  &lt;p&gt;Now the general strategy in writing a ppx is to provide a record
  of type &lt;code class=&quot;code&quot;&gt;Ast_mapper.mapper&lt;/code&gt;. That record is based on
  the &lt;code class=&quot;code&quot;&gt;Ast_mapper.default_mapper&lt;/code&gt; record but selectively
  overriding those fields for those sytactic categories that the ppx
  is intending to transform.
  &lt;/p&gt;
  &lt;p&gt;Now, as we determined above, the effect of the ppx is to provide
  a function from a structure to a new structure. Accordingly, at a
  minimum then we'll want to override the &lt;code class=&quot;code&quot;&gt;structure&lt;/code&gt; field
  of the default mapper. Schematically then our ppx code will take on
  the following shape.
  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Ast_mapper&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Ast_helper&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Asttypes&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Parsetree&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Longident&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; structure_mapper mapper structure =
  ...

 &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id_of_mapper =  {
   default_mapper &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; structure = structure_mapper
}

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; () = register &lt;span class=&quot;string&quot;&gt;&amp;quot;id_of&amp;quot;&lt;/span&gt; id_of_mapper&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;
  This program goes just a little bit further
  though. Any &lt;code class=&quot;code&quot;&gt;@id&lt;/code&gt; or &lt;code class=&quot;code&quot;&gt;@@id_of&lt;/code&gt; attributes that
  get as far as the OCaml compiler would be ignored. So, it's not
  neccessary that they be removed by our ppx once they've been acted
  upon but it seems tidy to do so. Accordingly, there are two more
  syntactic constructs that this ppx operates on.
  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Ast_mapper&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Ast_helper&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Asttypes&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Parsetree&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Longident&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; structure_mapper mapper structure =
  ...

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; type_declaration_mapper mapper decl =
  ...

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; constructor_declaration_mapper mapper decl =
  ...

&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id_of_mapper argv = {
  default_mapper &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
    structure = structure_mapper;
    type_declaration = type_declaration_mapper;
    constructor_declaration = constructor_declaration_mapper
}&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h3&gt;Implementing the mappings&lt;/h3&gt;
  &lt;p&gt;To warm up, lets start with the easy mappers.&lt;/p&gt;
  &lt;p&gt;The role of &lt;code class=&quot;code&quot;&gt;type_declaration_mapper&lt;/code&gt; is a function
  from a &lt;code class=&quot;code&quot;&gt;type_declaration&lt;/code&gt; argument to
  a &lt;code class=&quot;code&quot;&gt;type_declaration&lt;/code&gt; result that is the argument in all
  but that any &lt;code class=&quot;code&quot;&gt;@@id_of&lt;/code&gt; attribute has been removed.
  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; type_declaration_mapper
    (mapper : mapper)
    (decl : type_declaration) : type_declaration  =
  &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; decl &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;(*Case of an inductive type &amp;quot;t&amp;quot;*)&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; {ptype_name = {txt = &lt;span class=&quot;string&quot;&gt;&amp;quot;t&amp;quot;&lt;/span&gt;; _};
     ptype_kind = &lt;span class=&quot;constructor&quot;&gt;Ptype_variant&lt;/span&gt; constructor_declarations;
     ptype_attributes;_} &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; (_, attrs) =
      &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.partition (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; ({txt;_},_) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;txt=&lt;span class=&quot;string&quot;&gt;&amp;quot;id_of&amp;quot;&lt;/span&gt;) ptype_attributes &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    {(default_mapper.type_declaration mapper decl)
    &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; ptype_attributes=attrs}
  &lt;span class=&quot;comment&quot;&gt;(*Not an inductive type named &amp;quot;t&amp;quot;*)&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; default_mapper.type_declaration mapper decl&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;&lt;code class=&quot;code&quot;&gt;constructor_declaration_mapper&lt;/code&gt; is analogous
  to &lt;code class=&quot;code&quot;&gt;type_declaration_mapper&lt;/code&gt; above but this time
  its &lt;code class=&quot;code&quot;&gt;@id&lt;/code&gt; attributes that are removed.
  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; constructor_declaration_mapper
    (mapper : mapper)
    (decl : constructor_declaration) : constructor_declaration =
  &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; decl &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; {pcd_name={loc; _}; pcd_attributes; _} &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; (_, attrs) =
      &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.partition (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; ({txt;_}, _) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; txt=&lt;span class=&quot;string&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;) pcd_attributes  &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    {(default_mapper.constructor_declaration mapper decl)
    &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; pcd_attributes=attrs}&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;Now to the raison d'etre of the
  ppx, &lt;code class=&quot;code&quot;&gt;structure_mapper&lt;/code&gt;. 
  &lt;/p&gt;
  &lt;p&gt;First, a utility function that computes from
  a &lt;code class=&quot;code&quot;&gt;constructor_declaration&lt;/code&gt; with an &lt;code class=&quot;code&quot;&gt;@id&lt;/code&gt;
  attribute, a (function) &lt;code class=&quot;code&quot;&gt;case&lt;/code&gt; for it. For example,
  suppose &amp;quot;&lt;code class=&quot;code&quot;&gt;Bar of int [@id 4]&lt;/code&gt;&amp;quot; is the constructor
  declaration, then the &lt;code class=&quot;code&quot;&gt;case&lt;/code&gt; to be computed is the AST
  corresponding to the code &amp;quot;&lt;code class=&quot;code&quot;&gt;| Bar _ -&amp;gt; 4&lt;/code&gt;&amp;quot;.
  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; case_of_constructor_declaration :
      constructor_declaration &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; case =  &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;
    &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; {pcd_name={txt;loc};pcd_args;pcd_attributes; _} &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.filter (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; ({txt;_}, _) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; txt=&lt;span class=&quot;string&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;) pcd_attributes &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
      &lt;span class=&quot;comment&quot;&gt;(*No &amp;quot;@id&amp;quot;*)&lt;/span&gt;
      &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; [] &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
        raise (&lt;span class=&quot;constructor&quot;&gt;Location&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Location&lt;/span&gt;.error ~loc &lt;span class=&quot;string&quot;&gt;&amp;quot;[@id] : Missing&amp;quot;&lt;/span&gt;))
      &lt;span class=&quot;comment&quot;&gt;(*Single &amp;quot;@id&amp;quot;*)&lt;/span&gt;
      &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; [(_, payload)] &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; payload &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
          &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;PStr&lt;/span&gt; [{pstr_desc=&lt;span class=&quot;constructor&quot;&gt;Pstr_eval&lt;/span&gt; ({pexp_desc=
              &lt;span class=&quot;constructor&quot;&gt;Pexp_constant&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Pconst_integer&lt;/span&gt; (id, &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;)); _}, _)
            }] &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;constructor&quot;&gt;Exp&lt;/span&gt;.case
              (&lt;span class=&quot;constructor&quot;&gt;Pat&lt;/span&gt;.construct
                 {txt=&lt;span class=&quot;constructor&quot;&gt;Lident&lt;/span&gt; txt; loc=(!default_loc)}
                 (&lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; pcd_args &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
                 &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Pcstr_tuple&lt;/span&gt; [] &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Some&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Pat&lt;/span&gt;.any ())))
              (&lt;span class=&quot;constructor&quot;&gt;Exp&lt;/span&gt;.constant (&lt;span class=&quot;constructor&quot;&gt;Pconst_integer&lt;/span&gt; (id, &lt;span class=&quot;constructor&quot;&gt;None&lt;/span&gt;)))
          &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
            raise (&lt;span class=&quot;constructor&quot;&gt;Location&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Location&lt;/span&gt;.error ~loc
            &lt;span class=&quot;string&quot;&gt;&amp;quot;[@id] : Bad (or missing) argument (should be int e.g. [@id 4])&amp;quot;&lt;/span&gt;))
        &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;comment&quot;&gt;(*Many &amp;quot;@id&amp;quot;s*)&lt;/span&gt;
      &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; (_ :: _) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
        raise (&lt;span class=&quot;constructor&quot;&gt;Location&lt;/span&gt;.&lt;span class=&quot;constructor&quot;&gt;Error&lt;/span&gt; (&lt;span class=&quot;constructor&quot;&gt;Location&lt;/span&gt;.error ~loc
        &lt;span class=&quot;string&quot;&gt;&amp;quot;[@id] : Multiple occurences&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;One more utility function is required.&lt;/p&gt;
  &lt;p&gt;&lt;code class=&quot;code&quot;&gt;eval_structure_item item acc&lt;/code&gt; computes structure
  items to push on the front of &lt;code class=&quot;code&quot;&gt;acc&lt;/code&gt;. If &lt;code class=&quot;code&quot;&gt;item&lt;/code&gt;
  is a single declaration of an inductive type &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt;
  attributed with &lt;code class=&quot;code&quot;&gt;@@id_of&lt;/code&gt;, then two structure items will
  be produced : one for &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt; and one synthesized
  for &lt;code class=&quot;code&quot;&gt;t&lt;/code&gt;'s &lt;code class=&quot;code&quot;&gt;of_id&lt;/code&gt; function. In all other
  cases, just one structure item will be pushed onto &lt;code class=&quot;code&quot;&gt;acc&lt;/code&gt;.
  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; eval_structure_item
    (mapper : mapper)
    (item : structure_item)
    (acc : structure) : structure =
  &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;(*Case of a single inductive type declaration*)&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; { pstr_desc = &lt;span class=&quot;constructor&quot;&gt;Pstr_type&lt;/span&gt; (_, [type_decl]); pstr_loc} &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; type_decl &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
      &lt;span class=&quot;comment&quot;&gt;(*Case where the type identifer is [t]*)&lt;/span&gt;
      &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; {ptype_name = {txt = &lt;span class=&quot;string&quot;&gt;&amp;quot;t&amp;quot;&lt;/span&gt;; _};
         ptype_kind = &lt;span class=&quot;constructor&quot;&gt;Ptype_variant&lt;/span&gt; constructor_declarations;
         ptype_attributes;
         _} &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;
          &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.filter (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; ({txt;_},_) &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;txt=&lt;span class=&quot;string&quot;&gt;&amp;quot;id_of&amp;quot;&lt;/span&gt;)
            ptype_attributes
          &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;
          &lt;span class=&quot;comment&quot;&gt;(*No [@@id_of]*)&lt;/span&gt;
          &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; [] &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; default_mapper.structure_item mapper item :: acc

          &lt;span class=&quot;comment&quot;&gt;(*At least one [@@id_of] (treat multiple occurences as if
            one)*)&lt;/span&gt;
          &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;comment&quot;&gt;(*Cases of an [id_of] function for [t], one for each
              of its constructors*)&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; cases=
              &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.fold_right
                (&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; x acc &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt;
                  case_of_constructor_declaration x :: acc)
                constructor_declarations [] &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;comment&quot;&gt;(*The [id_of] function itself*)&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id_of : structure_item =
              &lt;span class=&quot;constructor&quot;&gt;Str&lt;/span&gt;.value &lt;span class=&quot;constructor&quot;&gt;Nonrecursive&lt;/span&gt; [
                &lt;span class=&quot;constructor&quot;&gt;Vb&lt;/span&gt;.mk
                  (&lt;span class=&quot;constructor&quot;&gt;Pat&lt;/span&gt;.var {txt=&lt;span class=&quot;string&quot;&gt;&amp;quot;id_of&amp;quot;&lt;/span&gt;; loc=(!default_loc)})
                  (&lt;span class=&quot;constructor&quot;&gt;Exp&lt;/span&gt;.function_ cases)] &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;

            default_mapper.structure_item mapper item :: id_of :: acc
        &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;comment&quot;&gt;(*Case the type identifier is something other than [t]*)&lt;/span&gt;
      &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; default_mapper.structure_item mapper item :: acc
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;(*Case this structure item is something other than a single type
    declaration*)&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; default_mapper.structure_item mapper item :: acc&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;Finally we can write &lt;code class=&quot;code&quot;&gt;structure_mapper&lt;/code&gt; itself as a
  simple fold over a structure.
  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; structure_mapper
    (mapper : mapper)
    (structure : structure) : structure =
  &lt;span class=&quot;constructor&quot;&gt;List&lt;/span&gt;.fold_right (eval_structure_item mapper)structure []&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;Building and testing&lt;/h3&gt;
  &lt;p&gt;So that's it, this preprocessor extension is complete. Assuming
  the code is contained in a file called &lt;code class=&quot;code&quot;&gt;ppx_id_of.ml&lt;/code&gt; it
  can be compiled with a command along the lines of the following.
  &lt;/p&gt;&lt;pre&gt;ocamlc -o ppx_id_of.exe  -I +compiler-libs ocamlcommon.cma ppx_id_of.ml&lt;/pre&gt;
  When built, it can be tested with a command like
  &lt;code class=&quot;code&quot;&gt; ocamlc -dsource -ppx ppx_id_of.exe test.ml&lt;/code&gt;.
  
  &lt;p&gt;
  For example, when invoked on the following program,
&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t =
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt; [@id 2]
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; int [@id 4] [@@id_of]

&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t =
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; int [@id 42]
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Bar&lt;/span&gt; [@id 43] [@@id_of]

  &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;N&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
     &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t =
     &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Baz&lt;/span&gt; [@id 8]
     &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Quux&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; string * int [@id 7] [@@id_of]

    &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Q&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t =
        &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;U&lt;/span&gt; [@id 0] [@@id_of]
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  the resulting output is,
  &lt;pre&gt;&lt;code class=&quot;code&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t =
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;
  &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; int
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id_of = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;A&lt;/span&gt;  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; 2 &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;B&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; 4
&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;M&lt;/span&gt; =
  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t =
      &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; int
      &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Bar&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id_of = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Foo&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; 42 &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Bar&lt;/span&gt;  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; 43
    &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;N&lt;/span&gt; =
      &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t =
          &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Baz&lt;/span&gt;
          &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Quux&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; string * int
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id_of = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Baz&lt;/span&gt;  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; 8 &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Quux&lt;/span&gt; _ &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; 7
        &lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;Q&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; t =
                            &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;U&lt;/span&gt;
                          &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id_of = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;keywordsign&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;constructor&quot;&gt;U&lt;/span&gt;  &lt;span class=&quot;keywordsign&quot;&gt;-&amp;gt;&lt;/span&gt; 0  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  &lt;hr/&gt;
  &lt;p&gt;
    References:&lt;br/&gt;
     [1] &lt;a href=&quot;https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/&quot;&gt;&amp;quot;A
     Guide to Extension Points in OCaml&amp;quot; -- Whitequark (blog post
     2014)&lt;/a&gt;
  &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;


</content><id>http://blog.shaynefletcher.org/2017/05/preprocessor-extensions-for-code.html</id><title type="text">Preprocessor extensions for code generation</title><updated>2017-05-04T20:27:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/03/dealing-with-source-code-locations-in.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Locations&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;p&gt;Writing compilers and interpreters requires rigorous management
    of source code locations harvested during syntax analysis and
    associated error handling mechanisms that involve reporting those
    locations along with details of errors they associate to.
    &lt;/p&gt;

    &lt;p&gt;
    This article does a &amp;quot;deep dive&amp;quot; into the the &lt;code&gt;Location&lt;/code&gt;
    module of the OCaml compiler. The original source can be found in
    the &lt;code&gt;ocaml/parsing&lt;/code&gt; directory of an OCaml distribution
    (copyright &lt;a href=&quot;https://en.wikipedia.org/wiki/Xavier_Leroy&quot;&gt;Xavier
    Leroy&lt;/a&gt;).
    &lt;/p&gt;

    &lt;p&gt;
    &lt;code&gt;Location&lt;/code&gt; is a &lt;font size=&quot;5&quot;&gt;masterclass&lt;/font&gt; in
    using the standard library &lt;code&gt;Format&lt;/code&gt; module. If you have
    had difficulties understanding &lt;code&gt;Format&lt;/code&gt; and what it
    provides the OCaml programmer, then this is for
    you. Furthermore, &lt;code&gt;Location&lt;/code&gt; contains invaluable idioms
    for error reporting &amp;amp; exception handling. Learn them here to be
    able to apply them in your own programs.
    &lt;/p&gt;

    &lt;h2&gt;Describing locations&lt;/h2&gt;
    &lt;p&gt;
    A location corresponds to a range of characters in a source file.
    &lt;code&gt;Location&lt;/code&gt; defines this type and a suite of functions
    for the production of location values.
    &lt;/p&gt;&lt;pre&gt;
type t = { 
  loc_start : Lexing.position;
  loc_end : Lexing.position;
  loc_ghost : bool
}

val none : t
val in_file : string &amp;rarr; t
val init : Lexing.lexbuf &amp;rarr; string &amp;rarr; unit
val curr : Lexing.lexbuf &amp;rarr; t

val symbol_rloc : unit &amp;rarr; t
val symbol_gloc : unit &amp;rarr; t
val rhs_loc : int &amp;rarr; t

type 'a loc = { 
  txt : 'a;
  loc : t; 
}

val mkloc : 'a &amp;rarr; t &amp;rarr; 'a loc
val mknoloc : 'a &amp;rarr; 'a loc
    &lt;/pre&gt;
    

    &lt;p&gt;
    A value of the (standard library)
    type &lt;code&gt;Lexing.position&lt;/code&gt; describes a point in a source
    file.
    &lt;/p&gt;&lt;pre&gt;
    type position = {
      pos_fname : string;
      pos_lnum : int;
      pos_bol : int;
      pos_cnum : int
    }
    &lt;/pre&gt;
    The fields of this record have the following meanings:
    &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;pos_fname&lt;/code&gt; is the file name&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;pos_lnum&lt;/code&gt; is the line number&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;pos_bol&lt;/code&gt; is the offset of the beginning of the
    line (the number of characters between the beginning of the lexbuf
    and the beginning of the line)&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;pos_cnum&lt;/code&gt; is the offset of the position (number of
    characters between the beginning of the lexbuf (details below) and
    the position)&lt;/li&gt;
    &lt;/ul&gt;
    The difference between &lt;code&gt;pos_cnum&lt;/code&gt;
    and &lt;code&gt;pos_bol&lt;/code&gt; is the character offset within the line
    (i.e. the column number, assuming each character is one column
    wide).
    

    &lt;p&gt;
    A location in a source file is defined by two positions : where
    the location starts and where the location ends.
    &lt;/p&gt;&lt;pre&gt;
type t = {
  loc_start : position;
  loc_end : position;
  loc_ghost : bool
}
    &lt;/pre&gt;
    The third field &lt;code&gt;loc_ghost&lt;/code&gt; is used to disambiguate
    locations that do not appear explicitly in the source file. A
    location will &lt;em&gt;not&lt;/em&gt; be marked as ghost if it contains a
    piece of code that is syntactically valid and corresponds to an
    AST node and will be marked as a ghost location otherwise.
    

    &lt;p&gt;
    There is a specific value denoting a null position. It is
    called &lt;code&gt;none&lt;/code&gt; and it is defined by the
    function &lt;code&gt;in_file&lt;/code&gt;.
    &lt;/p&gt;&lt;pre&gt;
let in_file (name : string) : t =
  let loc : position = {
    pos_fname = name; (*The name of the file*)
    pos_lnum = 1; (*The line number of the position*)
    pos_bol = 0; (*Offset from the beginning of the lexbuf of the line*)
    pos_cnum = -1; (*Offset of the position from the beginning of the lexbuf*)
  } in
  { loc_start = loc; loc_end = loc; loc_ghost = true }

let none : t = in_file &amp;quot;_none_&amp;quot;
    &lt;/pre&gt;
    

    &lt;p&gt;&lt;code&gt;Lexing.lexbuf&lt;/code&gt; is the (standard library) type of
    lexer buffers. A lexer buffer is the argument passed to the
    scanning functions defined by generated scanners (lexical
    analyzers). The lexer buffer holds the current state of the
    scanner plus a function to refill the buffer from the input.
    &lt;/p&gt;&lt;pre&gt;
type lexbuf = {
  refill_buff : lexbuf &amp;rarr; unit;
  mutable lex_buffer : bytes;
  mutable lex_buffer_len : int;
  mutable lex_abs_pos : int;
  mutable lex_start_pos : int;
  mutable lex_curr_pos : int;
  mutable lex_last_pos : int;
  mutable lex_last_action : int;
  mutable lex_eof_reached : bool;
  mutable lex_mem : int array;
  mutable lex_start_p : position;
  mutable lex_curr_p : position;
}
    &lt;/pre&gt;
    At each token, the lexing engine will copy &lt;code&gt;lex_curr_p&lt;/code&gt;
    to &lt;code&gt;lex_start_p&lt;/code&gt; then change the &lt;code&gt;pos_cnum&lt;/code&gt;
    field of &lt;code&gt;lex_curr_p&lt;/code&gt; by updating it with the number of
    characters read since the start of the &lt;code&gt;lexbuf&lt;/code&gt;. The
    other fields are left unchanged by the the lexing engine. In order
    to keep them accurate, they must be initialized before the first
    use of the lexbuf and updated by the relevant lexer actions.
    &lt;pre&gt;
(*Set the file name and line number of the [lexbuf] to be the start
   of the named file*)
let init (lexbuf : Lexing.lexbuf) (fname : string) : unit =
  let open Lexing in
  lexbuf.lex_curr_p &amp;lt;- {
    pos_fname = fname;
    pos_lnum = 1;
    pos_bol = 0;
    pos_cnum = 0;
  }
    &lt;/pre&gt;
    The location of the current token in a lexbuf is computed by the
    function &lt;code&gt;curr&lt;/code&gt;.
    &lt;pre&gt;
(*Get the location of the current token from the [lexbuf]*)
let curr (lexbuf : Lexing.lexbuf) : t = 
  let open Lexing in {
    loc_start = lexbuf.lex_start_p;
    loc_end = lexbuf.lex_curr_p;
    loc_ghost = false;
  }
    &lt;/pre&gt;
    

    &lt;p&gt;
    &lt;code&gt;Parsing&lt;/code&gt; is the run-time library for parsers generated
    by &lt;code&gt;ocamlyacc&lt;/code&gt;. The functions &lt;code&gt;symbol_start&lt;/code&gt;
    and &lt;code&gt;symbol_end&lt;/code&gt; are to be called in the action part of
    a grammar rule (only). They return the offset of the string that
    matches the left-hand-side of the rule : &lt;code&gt;symbol_start&lt;/code&gt;
    returns the offset of the first character; &lt;code&gt;symbol_end&lt;/code&gt;
    returns the offset &lt;em&gt;after&lt;/em&gt; the last character. The first
    character in a file is at offset 0.
    &lt;/p&gt;
    
    &lt;p&gt;
    &lt;code&gt;symbol_start_pos&lt;/code&gt; and &lt;code&gt;symbol_end_pos&lt;/code&gt; are
    like &lt;code&gt;symbol_start&lt;/code&gt; and &lt;code&gt;symbol_end&lt;/code&gt; but
    return &lt;code&gt;Lexing.position&lt;/code&gt; values instead of offsets.
    &lt;/p&gt;&lt;pre&gt;
(*Compute the span of the left-hand-side of the matched rule in the
   program source*)
let symbol_rloc () : t = {
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = false
}

(*Same as [symbol_rloc] but designates the span as a ghost range*)
let symbol_gloc () : t =  { 
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = true
}
    &lt;/pre&gt;
    

    &lt;p&gt;
     The &lt;code&gt;Parsing&lt;/code&gt; functions &lt;code&gt;rhs_start&lt;/code&gt;
     and &lt;code&gt;rhs_end&lt;/code&gt; are the same
     as &lt;code&gt;symbol_start&lt;/code&gt; and &lt;code&gt;symbol_end&lt;/code&gt; but
     return the offset of the string matching the &lt;code&gt;n&lt;/code&gt;-th
     item on the right-hand-side of the rule where &lt;code&gt;n&lt;/code&gt; is
     the integer parameter to &lt;code&gt;rhs_start&lt;/code&gt;
     and &lt;code&gt;rhs_end&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; is 1 for the leftmost
     item. &lt;code&gt;rhs_start_pos&lt;/code&gt; and &lt;code&gt;rhs_end_pos&lt;/code&gt;
     return a position instead of an offset.
     &lt;/p&gt;&lt;pre&gt;
(*Compute the span of the [n]th item of the right-hand-side of the
   matched rule*)
let rhs_loc n = {
  loc_start = Parsing.rhs_start_pos n;
  loc_end = Parsing.rhs_end_pos n;
  loc_ghost = false;
}
     &lt;/pre&gt;
    

    &lt;p&gt;The type &lt;code&gt;'a&lt;/code&gt; loc associates a value with a
    location.
    &lt;/p&gt;&lt;pre&gt;
(*A type for the association of a value with a location*)
type 'a loc = { 
  txt : 'a;
  loc : t; 
}

(*Create an ['a loc] value from an ['a] value and location*)
let mkloc (txt : 'a) (loc : t) : 'a loc = { txt ; loc }

(*Create an ['a loc] value bound to the distinguished location called
   [none]*)
let mknoloc (txt : 'a) : 'a loc = mkloc txt none
    &lt;/pre&gt;
    

    &lt;h2&gt;Error reporting with locations&lt;/h2&gt;
    &lt;p&gt;
    &lt;code&gt;Location&lt;/code&gt; has a framework for error reporting across
    modules concerned with locations (think lexer, parser,
    type-checker, etc).
    &lt;/p&gt;&lt;pre&gt;
open Format

type error =
{
  loc : t;
  msg : string;
  sub : error list;
}

val error_of_printer : t &amp;rarr;  (formatter &amp;rarr; 'a &amp;rarr; unit) &amp;rarr; 'a &amp;rarr; error
val errorf_prefixed : ?loc : t &amp;rarr; ?sub : error list &amp;rarr; ('a, Format.formatter, unit, error) format4 &amp;rarr; 'a
    &lt;/pre&gt;
    So, in the definition of the &lt;code&gt;error&lt;/code&gt;
    record, &lt;code&gt;loc&lt;/code&gt; is a location in the source
    code, &lt;code&gt;msg&lt;/code&gt; an explanation of the error
    and &lt;code&gt;sub&lt;/code&gt; a list of related errors.  We deal here with
    the error formatting functions. The utility
    function &lt;code&gt;print_error_prefix&lt;/code&gt; simply writes an error
    prefix to a formatter.
    &lt;pre&gt;
let error_prefix = &amp;quot;Error&amp;quot;

let warning_prefix = &amp;quot;Warning&amp;quot;

let print_error_prefix (ppf : formatter) () : unit =
  fprintf ppf &amp;quot;@{&amp;lt;error&amp;gt;%s@}:&amp;quot; error_prefix;
  ()
    &lt;/pre&gt;
    The syntax, &amp;quot;&lt;code&gt;@{&amp;lt;error&amp;gt;%s}@&lt;/code&gt;&amp;quot; associates the embedded text
    with the named tag &amp;quot;error&amp;quot;.
  

  &lt;p&gt;
  Next another utility, &lt;code&gt;pp_ksprintf&lt;/code&gt;.
  &lt;/p&gt;&lt;pre&gt;
let pp_ksprintf 
    ?(before : (formatter &amp;rarr; unit) option) 
    (k : string &amp;rarr; 'd)
    (fmt : ('a, formatter, unit, 'd) format4) : 'a =
  let buf = Buffer.create 64 in
  let ppf = Format.formatter_of_buffer buf in
  begin match before with
    | None &amp;rarr; ()
    | Some f &amp;rarr; f ppf
  end;
  kfprintf
    (fun (_ : formatter) : 'd &amp;rarr;
      pp_print_flush ppf ();
      let msg = Buffer.contents buf in
      k msg)
    ppf fmt
    &lt;/pre&gt;
    It proceeds as follows. A buffer and a formatter over that buffer
    is created. When presented with all of the arguments of the format
    operations implied by the &lt;code&gt;fmt&lt;/code&gt; argument, if
    the &lt;code&gt;before&lt;/code&gt; argument is non-empty, call it on the
    formatter. Finally, call &lt;code&gt;kfprintf&lt;/code&gt; (from the standard
    library &lt;code&gt;Format&lt;/code&gt; module) which performs the format
    operations on the buffer before handing control to a function that
    retrieves the contents of the now formatted buffer and passes them
    to the user provided continuation &lt;code&gt;k&lt;/code&gt;.
    

    &lt;p&gt;With &lt;code&gt;pp_ksprintf&lt;/code&gt; at our disposal, one can write
    the function &lt;code&gt;errorf_prefixed&lt;/code&gt;.
    &lt;/p&gt;&lt;pre&gt;
let errorf_prefixed 
    ?(loc:t = none) 
    ?(sub : error list = []) 
    (fmt : ('a, Format.formatter, unit, error) format4) : 'a =
  let e : 'a =
    pp_ksprintf
      ~before:(fun ppf &amp;rarr; fprintf ppf &amp;quot;%a &amp;quot; print_error_prefix ())
      (fun (msg : string) : error &amp;rarr; {loc; msg; sub})
    fmt
  in e
    &lt;/pre&gt;
    &lt;code&gt;errorf_prefixed&lt;/code&gt; computes a function. The function it
    computes provides the means to produce &lt;code&gt;error&lt;/code&gt; values
    by way of formatting operations to produce the &lt;code&gt;msg&lt;/code&gt;
    field of the &lt;code&gt;error&lt;/code&gt; result value. The formatting
    operations include prefixing the &lt;code&gt;msg&lt;/code&gt; field with
    the &lt;code&gt;error_prefix&lt;/code&gt; string. The type of the arguments of
    the computed function unifies with the type
    variable &lt;code&gt;'a&lt;/code&gt;. In other words, the type of the computed
    function is &lt;code&gt;'a &amp;rarr; error&lt;/code&gt;. For example, the type
    of &lt;code&gt;errorf_prefixed &amp;quot;%d %s&amp;quot;&lt;/code&gt; is &lt;code&gt;int &amp;rarr; string &amp;rarr;
    error&lt;/code&gt;.
    

    &lt;p&gt;
    The groundwork laid with &lt;code&gt;errorf_prefixed&lt;/code&gt; above means
    a polymorphic function &lt;code&gt;error_of_printer&lt;/code&gt; can now be
    produced.
    &lt;/p&gt;&lt;pre&gt;
let error_of_printer 
    (loc : t) 
    (printer : formatter &amp;rarr; 'error_t &amp;rarr; unit) 
    (x : 'error_t) : error =
  let mk_err : 'error_t &amp;rarr; error = 
    errorf_prefixed ~loc &amp;quot;%a@?&amp;quot; printer in
  mk_err x
      &lt;/pre&gt;
    The idea is that &lt;code&gt;error_of_printer&lt;/code&gt; is provided a
    function that can format a value of type &lt;code&gt;'error&lt;/code&gt;. This
    function is composed with &lt;code&gt;errorf_prefixed&lt;/code&gt; thereby
    producing a function of type &lt;code&gt;'error &amp;rarr; error&lt;/code&gt;. For
    example, we can illustrate how this works by making an error of a
    simple integer with code like the following:
    &lt;pre&gt;
# error_of_printer none (fun ppf x &amp;rarr; Format.fprintf ppf &amp;quot;Code %d&amp;quot; x) 3;;
- : error =
{loc =
  {loc_start =
    {pos_fname = &amp;quot;_none_&amp;quot;; pos_lnum = 1; pos_bol = 0; pos_cnum = -1};
   loc_end = {pos_fname = &amp;quot;_none_&amp;quot;; pos_lnum = 1; pos_bol = 0; pos_cnum = -1};
   loc_ghost = true};
 msg = &amp;quot;Error: Code 3&amp;quot;; sub = []}
    &lt;/pre&gt;
    
    &lt;p&gt;So, that's &lt;code&gt;error_of_printer&lt;/code&gt;. The following utility
    function is much simpler - it simply writes a given filename to a
    formatter.
    &lt;/p&gt;&lt;pre&gt;
let print_filename (ppf : formatter) (file : string) : unit =
  fprintf ppf &amp;quot;%s&amp;quot; file
    &lt;/pre&gt;
    Next, a set of constants for consistent messages that involve
    locations and a function to get the file, line and column of a
    position.
    &lt;pre&gt;
let (msg_file, msg_line, msg_chars, msg_to, msg_colon) =
    (&amp;quot;File \&amp;quot;&amp;quot;,        (*'msg file'*)
     &amp;quot;\&amp;quot;, line &amp;quot;,      (*'msg line'*)
     &amp;quot;, characters &amp;quot;,  (*'msg chars'*)
     &amp;quot;-&amp;quot;,              (*'msg to'*)
     &amp;quot;:&amp;quot;)              (*'msg colon'*)

let get_pos_info pos = (pos.pos_fname, pos.pos_lnum, pos.pos_cnum - pos.pos_bol)
    &lt;/pre&gt;
    Making use of the above we have now &lt;code&gt;print_loc&lt;/code&gt; : a
    function to print a location on a formatter in terms of file, line
    and character numbers.
    &lt;pre&gt;
let print_loc (ppf : formatter) (loc : t) : unit  =
  let (file, line, startchar) = get_pos_info loc.loc_start in
  let endchar = loc.loc_end.pos_cnum - loc.loc_start.pos_cnum + startchar in
  if file = &amp;quot;//toplevel//&amp;quot; then
    fprintf ppf &amp;quot;Characters %i-%i&amp;quot;
      loc.loc_start.pos_cnum loc.loc_end.pos_cnum
  else begin
    fprintf ppf &amp;quot;%s@{&amp;lt;loc&amp;gt;%a%s%i&amp;quot; msg_file print_filename file msg_line line;
    if startchar &amp;gt;= 0 then
      fprintf ppf &amp;quot;%s%i%s%i&amp;quot; msg_chars startchar msg_to endchar;
    fprintf ppf &amp;quot;@}&amp;quot;
  end
&lt;/pre&gt;
Locations generally speaking come out in a
    format along the lines of: &lt;code&gt;File &amp;quot;&amp;lt;string&amp;gt;, line 1,
    characters 0-10:&amp;quot;&lt;/code&gt;
&lt;pre&gt;
let print (ppf : formatter) (loc : t) : unit =
  (* The syntax, [@{&amp;lt;loc&amp;gt;%a@}] associates the embedded text with the
     named tag 'loc'*)
  fprintf ppf &amp;quot;@{&amp;lt;loc&amp;gt;%a@}%s@.&amp;quot; print_loc loc msg_colon
    &lt;/pre&gt;
    That last function, &lt;code&gt;print&lt;/code&gt; is just a small wrapper
    over &lt;code&gt;print_loc&lt;/code&gt; that appends a colon to the location.
    

    &lt;h2&gt;Exception handling involving errors with locations&lt;/h2&gt;
    &lt;p&gt;This section is concerned with the following section of
    the &lt;code&gt;Location&lt;/code&gt;'s signature.
    &lt;/p&gt;&lt;pre&gt;
val register_error_of_exn : (exn &amp;rarr; error option) &amp;rarr; unit
val error_of_exn : exn &amp;rarr; error option
val error_reporter : (formatter &amp;rarr; error &amp;rarr; unit) ref
val report_error : formatter &amp;rarr; error &amp;rarr; unit
val report_exception : formatter &amp;rarr; exn &amp;rarr; unit
    &lt;/pre&gt;
    &lt;code&gt;Location&lt;/code&gt; contains a mutable list of exception
    handlers where an exception handler is a function of
    type &lt;code&gt;exn &amp;rarr; error option&lt;/code&gt;.
    &lt;pre&gt;
let error_of_exn : (exn &amp;rarr; error option) list ref = ref []
    &lt;/pre&gt;
    A function is provided that adds an exception handler to the above
    list.
    &lt;pre&gt;
let register_error_of_exn f = error_of_exn := f :: !error_of_exn
    &lt;/pre&gt;
    The next function &lt;code&gt;error_of_exn&lt;/code&gt; (yes, it is the only
    remaining function that manipulates the
    list &lt;code&gt;error_exn&lt;/code&gt; previously defined directly) walks the
    list looking for a handler returning the contents of the result of
    the first such function that doesn't return a &lt;code&gt;None&lt;/code&gt;
    value.
    &lt;pre&gt;
let error_of_exn exn =
  let rec loop = function
    | [] &amp;rarr; None
    | f :: rest &amp;rarr;
      match f exn with
      | Some _ as r &amp;rarr; r
      | None &amp;rarr; loop rest
  in
  loop !error_of_exn
    &lt;/pre&gt;
    
    &lt;p&gt;We define now a &amp;quot;default&amp;quot; error reporting function. Given a
    formatter and an error, write the error location, an explanation
    of the error to the formatter and the same for any associated
    &amp;quot;sub&amp;quot; errors.
    &lt;/p&gt;&lt;pre&gt;
let rec default_error_reporter 
    (ppf : formatter) ({loc; msg; sub} : error) : unit =
  print ppf loc;
  Format.pp_print_string ppf msg;
  List.iter (Format.fprintf ppf &amp;quot;@\n@[&amp;lt;2&amp;gt;%a@]&amp;quot; default_error_reporter) sub
    &lt;/pre&gt;
    Now, &lt;code&gt;error_reporter&lt;/code&gt; itself is a reference cell with
    default value &lt;code&gt;default_error_reporter&lt;/code&gt;.
    &lt;pre&gt;
let error_reporter = ref default_error_reporter
    &lt;/pre&gt;
    This next function, &lt;code&gt;print_updating_num_loc_lines&lt;/code&gt;
    looks more complicated than it is but does demonstrate a rather
    advanced usage of &lt;code&gt;Format&lt;/code&gt; by containing calls to the
    functions &lt;code&gt;pp_get_formatter_out_functions&lt;/code&gt;,
    &lt;code&gt;pp_set_formatter_out_functions&lt;/code&gt; to tempoarily replace
    the default function for writing strings. The semantic of the
    function is to print an error on a formatter incidentally
    recording the number of lines required to do so.
    &lt;pre&gt;
(* A mutable line count*)
let num_loc_lines : int ref = ref 0

(*Prints an error on a formatter incidentally recording the number of
  lines required to do so*)
let print_updating_num_loc_lines 
    (ppf : formatter) 
    (f : formatter &amp;rarr; error &amp;rarr; unit) 
    (arg : error) : unit =
  (*A record of functions of output primitives*)
  let out_functions : formatter_out_functions
      = pp_get_formatter_out_functions ppf () in
  (*The strategoy is to temporarily replace the basic function for
    writing a string with this one*)
  let out_string (str : string) (start : int) (len : int) : unit =
    (*A function for counting line breaks in [str]. [c] is the current
      count, [i] is the current char under consideration*)
    let rec count (i : int) (c : int) : int=
      if i = start + len then c
      else if String.get str i = '\n' then count (succ i) (succ c)
      else count (succ i) c 
    in
    (*Update the count*)
    num_loc_lines := !num_loc_lines + count start 0;
    (*Write the string to the formatter*)
    out_functions.out_string str start len 
  in
  (*Replace the standard string output primitive with the one just
    defined *)
  pp_set_formatter_out_functions ppf 
    {out_functions with out_string} ;
  (*Write the error to the formatter*)
  f ppf arg ;
  pp_print_flush ppf ();
  (*Restore the standard primitive*)
  pp_set_formatter_out_functions ppf out_functions
    &lt;/pre&gt;
    The function &lt;code&gt;report_error&lt;/code&gt; uses the currently
    installed error reporter to write an error report for a given
    error and formatter incidentally updating a count indicating the
    number of lines written.
    &lt;pre&gt;
let report_error (ppf : formatter) (err : error) : unit=
  print_updating_num_loc_lines ppf !error_reporter err
    &lt;/pre&gt;
    
    &lt;p&gt;This next function, &lt;code&gt;report_exception_rec&lt;/code&gt; tries a
    number of times to find a handler for a given error and if
    successful formats it. In the worst case a handler is never found
    and the exception propogates.
    &lt;/p&gt;&lt;pre&gt;
let rec report_exception_rec (n : int) (ppf : formatter) (exn : exn) : unit =
  (*Try to find a handler for the exception*)
  try match error_of_exn exn with
  | Some err &amp;rarr; 
    (*Format the resulting error using the current error reporter*)
    fprintf ppf &amp;quot;@[%a@]@.&amp;quot; report_error err 
  (*The syntax @[%a@]@ writes function output in a box followed by a
    'cut' break hint*)
  | None &amp;rarr; raise exn (*A handler could not be found*)
  with exn when n &amp;gt; 0 &amp;rarr;
    (*A handler wasn't found. Try again*)
    report_exception_rec (n - 1) ppf exn
    &lt;/pre&gt;
    The last piece is &lt;code&gt;report_exception&lt;/code&gt;. It attempts to
    write an error report for the given exception on the provided
    formatter. The exception can be re-raised if no handler is found.
    &lt;pre&gt;
let report_exception (ppf : formatter) (exn : exn) : unit = 
  report_exception_rec 5 ppf exn
    &lt;/pre&gt;
    

    &lt;h3&gt;Usage&lt;/h3&gt;

    &lt;p&gt;In this section we see how an example of how the above
    machinery is used. Consider defining a lexical analyzer as an
    example. Suppose the scanner is defined by the
    file &lt;code&gt;lexer.mll&lt;/code&gt; (the input file
    to &lt;code&gt;ocamllex&lt;/code&gt;). We can imagine its header containing
    code like the following.
    &lt;/p&gt;&lt;pre&gt;
     {
        (*The cases of lexer errors*)
        type error =
          | Illegal_character of char
          | Unterminated_comment of Location.t

        (*The lexer exception type*)
        exception Error of error * Location.t

        (*This function takes a formatter and an instance of type
          [error] and writes a message to the formatter explaining the
          meaning. This is a &amp;quot;printer&amp;quot;*)
        let report_error (ppf : Format.formatter) : error &amp;rarr; unit = function
         | Illegal_character c &amp;rarr; 
            Format.fprintf ppf &amp;quot;Illegal character (%s)&amp;quot; (Char.escaped c)
         | Unterminated_comment _ &amp;rarr; 
            Format.fprintf ppf &amp;quot;Comment not terminated&amp;quot;

        (*Note that [report_error] is a function that unifies with
          the [formatter &amp;rarr; 'a &amp;rarr; unit] parameter of
          [error_of_printer]*)

        (*Register an exception handler for the lexer exception type*)
        let () =
         Location.register_error_of_exn
          (function
           | Error (err, loc) &amp;rarr;
              Some (Location.error_of_printer loc report_error err)
           | _ &amp;rarr;  None
          )
     }

     /*...*/
     rule token = ...
    &lt;/pre&gt;
    A function to handle errors with attached locations (in a REPL for
    example) is expressible as an idiom as simple as something like
    this.
    &lt;pre&gt;
let handle_interpreter_error ?(finally=(fun () &amp;rarr; ())) ex =
  finally ();
  Location.report_exception (Format.std_formatter) ex

let safe_proc ?finally f =
  try f ()
  with exn &amp;rarr; handle_interpreter_error ?finally exn
    &lt;/pre&gt;
    
    &lt;hr/&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2017/03/dealing-with-source-code-locations-in.html</id><title type="text">Dealing with source code locations (in lexical and syntax analysis)</title><updated>2017-03-30T19:58:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/03/polynomials-over-rings.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
     
    
    &lt;title&gt;Polynomials over rings&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;This post provides a workout in generic programming using modules &amp;amp;
    functors.
    &lt;/p&gt;
    &lt;p&gt;The program presented here models
    univariate &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;
    over &lt;a href=&quot;https://en.wikipedia.org/wiki/Ring_(mathematics)&quot;&gt;rings&lt;/a&gt;
    based on an exercise in &amp;quot;The Module Language&amp;quot; chapter, of
    &lt;a href=&quot;http://gallium.inria.fr/~remy/&quot;&gt;Didier R&amp;eacute;my's&lt;/a&gt;
    book, &lt;a href=&quot;https://caml.inria.fr/pub/docs/u3-ocaml/index.html&quot;&gt;Using,
    Understanding and Unraveling the OCaml Lanaguage&lt;/a&gt;.
    &lt;/p&gt;

    &lt;h3&gt;Arithmetics and rings&lt;/h3&gt;
    &lt;p&gt;We begin with a type for modules implementing arithmetic.
    &lt;/p&gt;&lt;pre&gt;
    module type ARITH = sig
      type t
      val of_int : int -&amp;gt; t            val to_int : t -&amp;gt; int
      val of_string : string -&amp;gt; t      val to_string : t -&amp;gt; string
      val zero : t                     val one : t
      val add : t -&amp;gt; t -&amp;gt; t            val sub : t -&amp;gt; t -&amp;gt; t
      val mul : t -&amp;gt; t -&amp;gt; t            val div : t -&amp;gt; t -&amp;gt; t
      val compare : t -&amp;gt; t -&amp;gt; int      val equal : t -&amp;gt; t -&amp;gt; bool
    end;;
    &lt;/pre&gt;
    A ring is a set equipped with two binary operations that
    generalize the arithmetic operations of addition and
    multiplication.
    &lt;pre&gt;
    module type RING = sig
      type t
      type extern_t
      val print : t -&amp;gt; unit
      val make : extern_t -&amp;gt; t         val show : t -&amp;gt; extern_t
      val zero : t                     val one : t
      val add : t -&amp;gt; t -&amp;gt; t            val mul : t -&amp;gt; t -&amp;gt; t
      val equal : t -&amp;gt; t -&amp;gt; bool
    end;;
    &lt;/pre&gt;
    We can build rings over arithmetics with functors. This particular
    one fixes the external representation of the elements of the ring
    to &lt;code&gt;int&lt;/code&gt;.
    &lt;pre&gt;
    module Ring (A : ARITH) :
      RING  with type t = A.t and type extern_t = int =
    struct
      include A
      type extern_t = int
      let make = of_int                let show = to_int
      let print x = print_int (show x)
    end;;
    &lt;/pre&gt;
    Thus, here for example are rings over various specific arithmetic
    modules.
    &lt;pre&gt;
    module Ring_int32 = Ring (Int32);;
    module Ring_int64 = Ring (Int64);;
    module Ring_nativeint = Ring (Nativeint);;
    module Ring_int = Ring (
      struct
        type t = int
        let of_int x = x                   let to_int x = x
        let of_string = int_of_string      let to_string = string_of_int
        let zero = 0                       let one = 1
        let add = ( + )                    let sub = ( - )
        let mul = ( * )                    let div = ( / )
        let compare = Pervasives.compare   let equal = ( = )
      end
    );;
    &lt;/pre&gt;
    
    &lt;h3&gt;Polynomials&lt;/h3&gt;
    &lt;p&gt;We define now the type of polynomials.
    &lt;/p&gt;&lt;pre&gt;
    module type POLYNOMIAL = sig
      type coeff (*Type of coefficients*)
      type coeff_extern_t (*Type of coeff. external rep*)

      (*Polynomials satisfy the ring interface*)
      include RING (*Declares a type [t] and [extern_t]*)

      (*Function to evaluate a polynomial at a point*)
      val eval : t -&amp;gt; coeff -&amp;gt; coeff
    end;;
    &lt;/pre&gt;
    Given a module implementing a ring, we can generate a module
    implementing polynomials with coefficients drawn from the ring.
    &lt;pre&gt;
    module Polynomial (R : RING) :
      POLYNOMIAL with type coeff = R.t
      and type coeff_extern_t = R.extern_t
      and type extern_t = (R.extern_t * int) list =
    struct
    
      type coeff = R.t (*Coefficient type*)
      type coeff_extern_t = R.extern_t (*External coeff. rep*)
      type extern_t = (coeff_extern_t * int) list (*External polynomial rep*)
    
      (*List of coefficients and their powers*)
      type t = (coeff * int) list (*Invariant : Ordered by powers,
                                    lower order terms at the front*)

      (* ... *)

    end;;
    &lt;/pre&gt;
    As the comments indicate, the polynomial data structure is a list
    of pairs of coefficients and powers, ordered so that lower powers
    come before higher ones. Here's a simple printing utility to aid
    visualization.
    &lt;pre&gt;
    let print p =
      List.iter
        (fun (c, k) -&amp;gt; Printf.printf &amp;quot;+ (&amp;quot;;
          R.print c;
          Printf.printf &amp;quot;)X^%d &amp;quot; k)
        p
    &lt;/pre&gt;
    In order that we get a canonical representation, null
    coefficients are eliminated. In particular, the null monomial is
    simply the empty list.
    &lt;pre&gt;
    let zero = []
    &lt;/pre&gt;
    The multiplicative identity &lt;code&gt;one&lt;/code&gt; is not really
    necessary as it is just a particular monomial however, its
    presence makes polynomials themselves satisfy the interface of
    rings.
    &lt;pre&gt;
    let one = [R.one, 0]
    &lt;/pre&gt;
    This helper function constructs monomials.
    &lt;pre&gt;
    let monomial (a : coeff) (k : int) =
      if k &amp;lt; 0 then
        failwith &amp;quot;monomial : negative powers not supported&amp;quot;
      else if R.equal a R.zero then [] else [a, k]
    &lt;/pre&gt;
    Next up, we define addition of polynomials by the following
    function. Care is taken to ensure the representation invariant is
    respected.
    &lt;pre&gt;
    let rec add u v =
      match u, v with
      | [], _ -&amp;gt; v
      | _, [] -&amp;gt; u
      | ((c1, k1) :: r1 as p1), ((c2, k2) :: r2 as p2) -&amp;gt;
        if k1 &amp;lt; k2 then
          (c1, k1) :: (add r1 p2)
        else if k1 = k2 then
          let c = R.add c1 c2 in
          if R.equal c R.zero then add r1 r2
          else (c, k1) :: (add r1 r2)
        else (c2, k2) :: (add p1 r2)
    &lt;/pre&gt;
    With &lt;code&gt;monomial&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; avaialable, we can
    now write &lt;code&gt;make&lt;/code&gt; that computes a polynomial from an
    external representation. We also give the inverse
    function &lt;code&gt;show&lt;/code&gt; here too.
    &lt;pre&gt;
    let make l =
      List.fold_left (fun acc (c, k) -&amp;gt;
        add (monomial (R.make c) k) acc) zero l

    let show p =
      List.fold_right (fun (c, k) acc -&amp;gt; (R.show c, k) :: acc) p []
    &lt;/pre&gt;
    The module private function &lt;code&gt;times&lt;/code&gt; left-multiplies a
    polynomial by a monomial.
    &lt;pre&gt;
    let rec times (c, k) = function
      | [] -&amp;gt; []
      | (c1, k1) :: q -&amp;gt;
        let c2 = R.mul c c1 in
        if R.equal c2 R.zero then times (c, k) q
        else (c2, k + k1) :: times (c, k) q
    &lt;/pre&gt;
    Given the existence of &lt;code&gt;times&lt;/code&gt;, polynomial
    multiplication can be expressed in a &amp;quot;one-liner&amp;quot;.
    &lt;pre&gt;
    let mul p = List.fold_left (fun r m -&amp;gt; add r (times m p)) zero
    &lt;/pre&gt;
    Comparing two polynomials for equality is achieved with the
    following predicate.
    &lt;pre&gt;
    let rec equal p1 p2 =
      match p1, p2 with
      | [], [] -&amp;gt; true
      | (c1, k1) :: q1, (c2, k2) :: q2 -&amp;gt;
        k1 = k2 &amp;amp;&amp;amp; R.equal c1 c2 &amp;amp;&amp;amp; equal q1 q2
      | _ -&amp;gt; false
    &lt;/pre&gt;
    In the course of evaluating polynomials for a specific value of
    their indeterminate, we'll require a function for computing
    powers. The following routine uses
    the &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponentiation_by_squaring&quot;&gt;exponentiation
    by squaring&lt;/a&gt; technique.
    &lt;pre&gt;
    let rec pow c = function
      | 0 -&amp;gt; R.one
      | 1 -&amp;gt; c
      | k -&amp;gt;
        let l = pow c (k lsr 1) in
        let l2 = R.mul l l in
        if k land 1 = 0 then l2 else R.mul c l2
    &lt;/pre&gt;
    Finally, the function &lt;code&gt;eval&lt;/code&gt; for evaluation of a
    polynomial at a specific point. The implementation
    uses &lt;a href=&quot;https://en.wikipedia.org/wiki/Horner's_method&quot;&gt;Horner's
    rule&lt;/a&gt; for computationally efficient evaluation.
    &lt;pre&gt;
    let eval p c = match List.rev p with
      | [] -&amp;gt; R.zero
      | (h :: t) -&amp;gt;
        let reduce (a, k) (b, l) =
          let n = pow c (k - l) in
          let t = R.add (R.mul a n) b in
          (t, l)  in
        let a, k = List.fold_left reduce h t in
        R.mul (pow c k) a
      &lt;/pre&gt;
    
    &lt;h3&gt;Testing and example usage&lt;/h3&gt;
    &lt;p&gt;The following interactive session creates a polynomial with
    integer coefficients module and uses it to confirm the equivalence
    of $(1 + x)(1 - x)$ with $(1 - x^{2})$.
    &lt;/p&gt;&lt;pre&gt;
    # #use &amp;quot;polynomial.ml&amp;quot;;;
    # module R = Ring_int;;
    # module P = Polynomial (R);;
    # let p = P.mul (P.make [(1, 0); (1, 1)]) (P.make [(1, 0); (-1, 1)]);;
    # let q = P.make [(1, 0); (-1, 2)];;
    # P.equal p q;;
    - : bool = true
    &lt;/pre&gt;
    Polynomials in two variables, can be treated as univariate
    polynomials with polynomial coefficients. For example, the
    polynomial $(X + Y)$ can be regarded as $(1 \times X^{1})Y^{0} +
    (1 \times X^{0})Y^{1}$. Similarly we can write $X - Y$ as $(1
    \times X^{1})Y^{0} + (-1 \times X^{0}) Y^1$ and now check the
    equivalence $(X + Y)(X - Y) = (X^{2} - Y^{2})$.
    
    &lt;pre&gt;
    #module Y = Polynomial (P);;
    
    #(* (X + Y) *)
    #let r = Y.make [
    #  ([1, 1], 0); (*(1 X^1) Y^0*)
    #  ([1, 0], 1)  (*(1 X^0) Y^1*)
    #];;

    #(* (X - Y) *)
    #let s = Y.make [
    #  ([1, 1], 0); (*(1 X^1) Y^0*)
    #  ([-1, 0], 1) (*((-1) X^0) Y^1*)
    #];;

    #(* (X^2 - Y^2) *)
    #let t = Y.make [
    #  ([1, 2], 0);   (*(1 X^2) Y^0*)
    #  ([-1, 0], 2)  (* (-1 X^0) Y^2*)
    #];;

    #Y.equal (Y.mul r s) t;;
    - : bool = true
    &lt;/pre&gt;
    
   &lt;hr/&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2017/03/polynomials-over-rings.html</id><title type="text">Polynomials over rings</title><updated>2017-03-21T19:43:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/03/universal-type.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">    &lt;h2&gt;Universal type&lt;/h2&gt;
    &lt;p&gt;A universal type is a type into which all other types can be
    embedded. A module implementing such a type here will satisfy the
    following signature.
      &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
module type UNIVERSAL = sig
  type t
  val embed : unit &amp;rarr; (&amp;alpha; &amp;rarr; t) * (t &amp;rarr; &amp;alpha; option)
end;;
      &lt;/pre&gt;
      The &lt;code&gt;type t&lt;/code&gt; is the universal type and each call
      to &lt;code&gt;embed&lt;/code&gt; returns a pair of functions : an injection
      function for embedding a value into the universal type and, a
      projection function for extracting the value from its embedding
      in the universal type. The following code demonstrates intended
      usage.
      &lt;pre class=&quot;prettyprint ml&quot;&gt;
module type TEST = sig
  val run : unit &amp;rarr; unit
end;;

module type UNIVERSAL_TEST = functor (U : UNIVERSAL) &amp;rarr; TEST;;

module Basic_usage : UNIVERSAL_TEST = 
  functor (U : UNIVERSAL) &amp;rarr; struct
    let run () =
      let ((of_int : int &amp;rarr; U.t)
         , (to_int : U.t &amp;rarr; int option)) = U.embed () in
      let ((of_string : string &amp;rarr; U.t)
         , (to_string : U.t &amp;rarr; string option)) = U.embed () in

      let r : U.t ref = ref (of_int 13) in

      begin
        assert (to_int !r = Some 13);
        assert (to_string !r = None);

        r := of_string &amp;quot;foo&amp;quot;;

        assert (to_string !r = Some &amp;quot;foo&amp;quot;);
        assert (to_int !r = None);
      end
  end;;
      &lt;/pre&gt;
    
    &lt;p&gt;One possible implementation is via the use of exceptions
    together with local modules. The core idea exploits the fact that
    the primitive type &lt;code&gt;exn&lt;/code&gt; is an open extensible
    sum. Here's the complete implementation. We'll break it down
    later.
    &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
module Universal_exn : UNIVERSAL = struct

  type t = exn

  module type ANY = sig
    type c
    exception E of c
  end

  type &amp;alpha; any = (module ANY with type c = &amp;alpha;)

  let mk : unit &amp;rarr; &amp;alpha; any =
    fun (type s) () &amp;rarr;
      (module struct
        type c = s
        exception E of c
      end : ANY with type c = s)

  let inj (type s) (p : s any) (x : s) : t =
    let module Any = (val p : ANY with type c = s) in
    Any.E x

  let proj (type s) (p : s any) (y : t) : s option =
    let module Any = (val p : ANY with type c = s) in
    match y with
    | Any.E x &amp;rarr; Some x
    | _ as e &amp;rarr;  None

  let embed () = let p = mk () in inj p, proj p

end;;
    &lt;/pre&gt;
    Before delving into an explanation of the program, one can verify
    it satisfies the basic test.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
# module Test_basic = Mk_universal_test(Universal_exn);;
# Test_basic.run ();;
- : unit = ()
   &lt;/pre&gt;
   
   &lt;p&gt;The definition of the universal type &lt;code&gt;t&lt;/code&gt; is an alias
   to the predefined type &lt;code&gt;exn&lt;/code&gt;.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
type t = exn
   &lt;/pre&gt;
   A module type &lt;code&gt;ANY&lt;/code&gt; is introduced. Modules that
   implement this signature define an abstract type &lt;code&gt;c&lt;/code&gt; and
   introduce an &lt;code&gt;exn&lt;/code&gt; constructor &lt;code&gt;E of c&lt;/code&gt;.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
module type ANY = sig
  type c
  exception E of c
end
   &lt;/pre&gt;
   An alias for the type of a module value satisfying this signature
   comes next. Using aliases of this kind are helpful in reducing
   &amp;quot;syntactic verbosity&amp;quot; in code accepting and returning module values.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
type &amp;alpha; any = (module ANY with type c = &amp;alpha;)
   &lt;/pre&gt;
   Next follow a set of functions that are private to the
   implementation of the module. The first of these
   is &lt;code&gt;mk&lt;/code&gt;.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
let mk : unit &amp;rarr; &amp;alpha; any =
  fun (type s) () &amp;rarr;
    (module struct
      type c = s
      exception E of c
    end : ANY with type c = s)
   &lt;/pre&gt;
   This function &lt;code&gt;mk&lt;/code&gt; takes the &lt;code&gt;unit&lt;/code&gt; argument
   and each invocation computes a new module instance which is packed
   as a first class value and returned. The locally abstract
   type &lt;code&gt;s&lt;/code&gt; connects to the &lt;code&gt;&amp;alpha;&lt;/code&gt; in the
   return type.
   
   &lt;p&gt;
   The next function to be defined is &lt;code&gt;inj&lt;/code&gt; which computes
   a universal type value from its argument.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let inj (type s) (p : s any) (x : s) : t =
  let module Any = (val p : ANY with type c = s) in
  Any.E x
   &lt;/pre&gt;
    As was the case for &lt;code&gt;mk&lt;/code&gt;, a locally abstract type is
    used in the definition of &lt;code&gt;inj&lt;/code&gt; and observe how that
    type ensures a coherence between the module
    parameter &lt;code&gt;p&lt;/code&gt; and the type of the parameter to be
    embedded &lt;code&gt;x&lt;/code&gt;.
   
   &lt;p&gt;
   The projection function &lt;code&gt;proj&lt;/code&gt; comes next and also uses
   a locally abstract type ensuring coherence among its parameters.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let proj (type s) (p : s any) (y : t) : s option =
  let module Any = (val p : ANY with type c = s) in
  match y with
  | Any.E x &amp;rarr; Some x
  | _ as e &amp;rarr;  None
   &lt;/pre&gt;
   The body of &lt;code&gt;proj&lt;/code&gt; unpacks the module value parameter into
   a module named &lt;code&gt;Any&lt;/code&gt; and then attempts to
   match &lt;code&gt;y&lt;/code&gt; against the constructor defined
   by &lt;code&gt;Any&lt;/code&gt;. Recall, at the end of the day, &lt;code&gt;y&lt;/code&gt;
   is of type &lt;code&gt;exn&lt;/code&gt;. The match contains two cases : the
   first matching the constructor &lt;code&gt;Any.E x&lt;/code&gt;
   with &lt;code&gt;x&lt;/code&gt; having type &lt;code&gt;s&lt;/code&gt;, the second anything
   else (that is, &lt;code&gt;proj&lt;/code&gt; is total).
   
   &lt;p&gt;Finally we come to the public function &lt;code&gt;embed&lt;/code&gt;.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let embed () = let p = mk () in inj p, proj p
   &lt;/pre&gt;
   &lt;code&gt;embed&lt;/code&gt; calls &lt;code&gt;mk&lt;/code&gt; to produce a new
   embedding &lt;code&gt;p&lt;/code&gt; and returns the pair of partial
   applications &lt;code&gt;(inj p, proj p)&lt;/code&gt;.
   
   &lt;p&gt;Our examination of the implementation is concluded. There are
   however various implications of the implementation we are now in a
   position to understand that are not immediately obvious from the
   specification. As a first example, consider the inferred type of a
   call to &lt;code&gt;embed&lt;/code&gt;.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
# module U = Universal_exn;;
# let inj, proj = U.embed ();;
val inj : '_a &amp;rarr; U.t = &lt;fun&gt;
val proj : U.t &amp;rarr; '_a option = &lt;fun&gt;
   &lt;/fun&gt;&lt;/fun&gt;&lt;/pre&gt;
   &lt;b&gt;Property 1 : &lt;/b&gt;&lt;code&gt;embed&lt;/code&gt; produces weakly polymorphic
   functions.
   &lt;br/&gt;
   &lt;br/&gt;
   Consider the following scenario:
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
# let of_int, to_int = U.embed ();;
# let of_string, to_string = U.embed ();;
   &lt;/pre&gt;
   At this point all
   of &lt;code&gt;of_int&lt;/code&gt;, &lt;code&gt;to_int&lt;/code&gt;, &lt;code&gt;of_string&lt;/code&gt;
   and &lt;code&gt;to_string&lt;/code&gt; are weakly polymorphic.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
# let r : U.t ref = ref (of_int 13);;
   &lt;/pre&gt;
   The call to &lt;code&gt;of_int&lt;/code&gt; fixes it's type to &lt;code&gt;int &amp;rarr;
   U.t&lt;/code&gt; and that of &lt;code&gt;to_int&lt;/code&gt; to &lt;code&gt;U.t &amp;rarr; int
   option&lt;/code&gt;. The types of &lt;code&gt;of_string&lt;/code&gt;
   and &lt;code&gt;to_string&lt;/code&gt; remain unfixed.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
# to_string !r = Some 13;;
- : bool = false
   &lt;/pre&gt;
   The programmer has mistakenly used a projection function from a
   different embedding.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
# r := of_string &amp;quot;foo&amp;quot;;;
Error: This expression has type string but an expression was expected of
type int
   &lt;/pre&gt;
   The erroneous usage of &lt;code&gt;to_string&lt;/code&gt; incidentally fixed
   the type of &lt;code&gt;of_string&lt;/code&gt; to &lt;code&gt;int &amp;rarr; U.t&lt;/code&gt;! One
   can imagine errors of this kind being difficult to diagnose.
   
   &lt;p&gt;
   &lt;b&gt;Property 2 :&lt;/b&gt; Injection/projection functions of different
   embeddings may not be mixed.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
# let ((of_int : int &amp;rarr; U.t), (to_int : U.t &amp;rarr; int option)) = U.embed ();;
# let ((of_int' : int &amp;rarr; U.t), (to_int' : U.t &amp;rarr; int option)) = U.embed ();;
   &lt;/pre&gt;
   Two embeddings have been created, the programmer has fixed the
   types of the injection/projection functions &lt;i&gt;a priori&lt;/i&gt;
   (presumably as a defense against the problems of the preceding
   example).
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
# let r : U.t ref = ref (of_int 13);;
# to_int !r = Some 13;;
- : bool = true
   &lt;/pre&gt;
   The first embedding is used to inject an integer. That integer can
   be extracted using the projection function of that embedding.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
#  to_int' !r = Some 13;;
- : bool = false
   &lt;/pre&gt;
   We cannot extract the integer from the universal type value using
   the projection function from the other embedding despite all of the
   types involved being the same. One can imagine that also as being
   quite the source of bugs and confusion to the unknowing programmer.
   
   &lt;p&gt;
   The constraint of property 2 is beyond the ability of the type
   system to enforce. About the best one can do is to enhance the
   specification of the type with documentation.
    &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
module type UNIV = sig
  type t

  val embed : unit &amp;rarr; (&amp;alpha; &amp;rarr; t) * (t &amp;rarr; &amp;alpha; option)
 
  (* A pair [(inj, proj)] returned by [embed] works together in that
     [proj u] will return [Some v] if and only if [u] was created by
     [inj v]. If [u] was created by a different function then [proj u] 
     will return [None]. *)

end;;
    &lt;/pre&gt;
   &lt;hr/&gt;
</content><id>http://blog.shaynefletcher.org/2017/03/universal-type.html</id><title type="text">Universal type</title><updated>2017-03-10T18:06:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2017/03/polymorphic-variants-subtyping-and.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
     
    
    &lt;title&gt;Polymorphic variants : subtyping and variance&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;Polymorphic variants : Subtyping and variance&lt;/h2&gt;
    &lt;p&gt;
    Here are some expressions in the top-level involving polymorphic
    variant types.
    &lt;/p&gt;&lt;pre&gt;
    # let x = [ `On; `Off ];;
    val x : [&amp;gt; `Off | `On ] list = [ `On; `Off ]
    &lt;/pre&gt;
    The notation &lt;code&gt;[&amp;gt; `Off | `On ]&lt;/code&gt; represents a type
    that &lt;b&gt;at least&lt;/b&gt; contains the constructors &lt;code&gt;`Off&lt;/code&gt;
    and &lt;code&gt;`On&lt;/code&gt;. Of course, there are an unlimited number of
    such types so &lt;code&gt;[&amp;gt; `Off | `On ]&lt;/code&gt; is a set in fact.
    
    &lt;p&gt;
    &lt;/p&gt;&lt;pre&gt;
    # let n = `Number 1;;
    val n : [&amp;gt; `Number of int ] = `Number 1
    &lt;/pre&gt;
    The value &lt;code&gt;n&lt;/code&gt; is of a type that &lt;b&gt;at least&lt;/b&gt;
    contains the constructor &lt;code&gt;`Number of int&lt;/code&gt;.
    
    &lt;p&gt;
    &lt;/p&gt;&lt;pre&gt;
    # let f = function | `On &amp;rarr; 1 | `Off &amp;rarr; 0 | `Number n &amp;rarr; n;;
    val f : [&amp;lt; `Number of int | `Off | `On ] &amp;rarr; int = &amp;lt;fun&amp;gt;
    &lt;/pre&gt;
    The function &lt;code&gt;f&lt;/code&gt; accomodates exactly three cases
    corresponding to the
    constructors &lt;code&gt;`Off&lt;/code&gt;, &lt;code&gt;`On&lt;/code&gt; and &lt;code&gt;`Number
    of int&lt;/code&gt;. This informs us that &lt;code&gt;[&amp;lt; `Number of int |
    `Off | `On ]&lt;/code&gt; is of a type that &lt;b&gt;at most&lt;/b&gt; has the
    constructors &lt;code&gt;`Off&lt;/code&gt;, &lt;code&gt;`On&lt;/code&gt; and &lt;code&gt;`Number
    of int&lt;/code&gt;.
    
    &lt;p&gt;
    The expression &lt;code&gt;(&lt;/code&gt;$expr$&lt;code&gt;
    :&amp;gt; &lt;/code&gt;$typexpr$&lt;code&gt;)&lt;/code&gt; coerces the expression $expr$ to
    type $typexpr$. The expression &lt;code&gt;(&lt;/code&gt;$expr$ &lt;code&gt;:&lt;/code&gt;
    $typ_{1}$ &lt;code&gt;:&amp;gt;&lt;/code&gt; $typ_{2}$ &lt;code&gt;)&lt;/code&gt; coerces the
    exprssion $expr$ from $typ_{1}$ to $typ_{2}$. It is only possible
    to coerce an expression $expr$ from type $typ_{1}$ to type
    $typ_{2}$, if the type of $expr$ is an instance of $typ_{1}$ and
    $typ_{1}$ is a subtype of $typ_{2}$.
    &lt;/p&gt;
    &lt;p&gt;
    &lt;/p&gt;&lt;pre&gt;
    # let f x = (x :&amp;gt; [ `A | `B ]);;
    val f : [&amp;lt; `A | `B ] &amp;rarr; [ `A | `B ] = &amp;lt;fun&amp;gt;
    &lt;/pre&gt;
    We see &lt;code&gt;x&lt;/code&gt; needs to be coercible to type &lt;code&gt;[ `A |
     `B ]&lt;/code&gt;. So, we read &lt;code&gt;[&amp;lt; `A | `B ]&lt;/code&gt; as a type
     that at most contains the constructors &lt;code&gt;`A&lt;/code&gt;
     and &lt;code&gt;`B&lt;/code&gt;. &lt;code&gt;[ `A ]&lt;/code&gt;, &lt;code&gt;[ `B ]&lt;/code&gt;
     and &lt;code&gt;[ `A | `B ]&lt;/code&gt; are the subtypes of &lt;code&gt;[ `A | `B
     ]&lt;/code&gt;. It follows then that &lt;code&gt;[&amp;lt; `A | `B ]&lt;/code&gt; is
     the set of subtypes of &lt;code&gt;[ `A | `B ]&lt;/code&gt;.
    
    &lt;p&gt;
    &lt;/p&gt;&lt;pre&gt;
    # let f x = (x :&amp;gt; [ `A | `B ] * [ `C | `D ]);;
    val f : [&amp;lt; `A | `B ] * [&amp;lt; `C | `D ] &amp;rarr; [ `A | `B ] * [ `C | `D ] = &amp;lt;fun&amp;gt;
    &lt;/pre&gt;
    We see &lt;code&gt;x&lt;/code&gt; needs to be coercible to &lt;code&gt;[ `A | `B ] *
    [ `C | `D ]&lt;/code&gt;. This coercion can only proceed
    if &lt;code&gt;x&lt;/code&gt; designates a pair with first component a subtype
    of &lt;code&gt;[ `A | `B ]&lt;/code&gt; and second component a subtype
    of &lt;code&gt;[ `C | `D ]&lt;/code&gt;. So we see, &lt;code&gt;[&amp;lt; `A | `B ] *
    [&amp;lt; `C | `D ]&lt;/code&gt; is the set of subtypes of &lt;code&gt;[ `A | `B ]
    * [ `C | `D ]&lt;/code&gt;.
    
    &lt;p&gt;
    &lt;/p&gt;&lt;pre&gt;
    # let f x = (x  :&amp;gt; [ `A ] &amp;rarr; [ `C | `D ]);;
    val f : ([&amp;gt; `A ] &amp;rarr; [&amp;lt; `C | `D ]) &amp;rarr; [ `A ] &amp;rarr; [ `C | `D ] = &amp;lt;fun&amp;gt;
    &lt;/pre&gt;
    We see &lt;code&gt;x&lt;/code&gt; needs to be coercible to &lt;code&gt;[ `A ] &amp;rarr; [
    `C | `D ]&lt;/code&gt;. This coercion can only proceed if &lt;code&gt;x&lt;/code&gt;
    designates an arrow where the argument is of a type that at least
    contains the constructor &lt;code&gt;`A&lt;/code&gt;. That is &lt;code&gt;[ `A
    ]&lt;/code&gt;, &lt;code&gt;[ `A | ... ]&lt;/code&gt; where the &amp;quot;&lt;code&gt;...&lt;/code&gt;&amp;quot;
    represent more constructors. From this we see that &lt;code&gt;[&amp;gt;
    `A]&lt;/code&gt; is the set of supertypes of &lt;code&gt;[ `A ]&lt;/code&gt;. The
    return value of &lt;code&gt;x&lt;/code&gt; (by logic we've already
    established) is a subtype of &lt;code&gt;[ `C | `D
    ]&lt;/code&gt;. So, &lt;code&gt;[&amp;gt; `A ] &amp;rarr; [&amp;lt; `C | `D ]&lt;/code&gt; is the
    set of subtypes of &lt;code&gt;[ `A ] &amp;rarr; [ `C | `D ]&lt;/code&gt;.
    
    &lt;p&gt;The transformation represented by &lt;code&gt;f&lt;/code&gt; above, has
    coerced an arrow &lt;code&gt;x&lt;/code&gt; to a new arrow. The type of the
    argument of &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;[&amp;gt; `A ]&lt;/code&gt; and the
    type of the argument of the resulting arrow is &lt;code&gt;[ `A
    ]&lt;/code&gt;. That is, for the argument, the transformation between
    types has taken a supertype to a subtype. The argument type is
    said to be in a &amp;quot;contravariant&amp;quot; position. On the other hand, the
    result type of &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;[&amp;lt; `C | `D ]&lt;/code&gt; and
    the arrow that is produced from it, &lt;code&gt;f x&lt;/code&gt;, has result
    type &lt;code&gt;[ `C | `D ]&lt;/code&gt;. That is, the coercion for the
    result type has taken a subtype to a supertype : the result type
    in &lt;code&gt;x&lt;/code&gt; is said to be in &amp;quot;covariant&amp;quot; position.
    &lt;/p&gt;
    &lt;p&gt;
    In the following, the type &lt;code&gt;&amp;alpha; t&lt;/code&gt; is abstract.
    &lt;/p&gt;&lt;pre&gt;
    # type &amp;alpha; t;;
    # let f (x : [ `A ] t) = (x :&amp;gt; [ `A | `B ] t);;
    Error: Type [ `A ] t is not a subtype of [ `A | `B ] t 
    &lt;/pre&gt;
    Indeed, &lt;code&gt;[ `A ]&lt;/code&gt; is a subtype of &lt;code&gt;[ `A | `B
    ]&lt;/code&gt; but that, &lt;i&gt;a priori&lt;/i&gt;, does not say anything about
    the subtyping relationship between &lt;code&gt;[ `A ] t&lt;/code&gt;
    and &lt;code&gt;[ `A | `B ] t&lt;/code&gt;. For this coercion to be legal, the
    parameter &lt;code&gt;&amp;alpha;&lt;/code&gt; must be given a covariant
    annotation:
    &lt;pre&gt;
    # type +&amp;alpha; t;;
    # let f (x : [ `A ] t) = (x :&amp;gt; [ `A | `B ] t);;
    val f : [ `A ] t &amp;rarr; [ `A | `B ] t = &amp;lt;fun&amp;gt;
    &lt;/pre&gt;
    The declaration &lt;code&gt;type +&amp;alpha; t&lt;/code&gt; declares that the
    abstract type is covariant in its parameter : if the type $\tau$
    is a subtype of $\sigma$, then $\tau\;t$ is a subtype of
    $\sigma\;t$. Here, $\tau = $&lt;code&gt;[ `A ]&lt;/code&gt;, $\sigma =
    $&lt;code&gt;[ `A | `B ]&lt;/code&gt;, $\tau$ is a subtype of $\sigma$
    and &lt;code&gt;[ `A ] t&lt;/code&gt; is a subtype of &lt;code&gt;[ `A | `B]
    t&lt;/code&gt;.
    
    &lt;p&gt;
    Here is a similar example, but this time, in the other direction.
    &lt;/p&gt;&lt;pre&gt;
    # type &amp;alpha; t;;
    # let f (x : [ `A | `B ] t) = (x :&amp;gt; [ `A ] t);;
    Error: This expression cannot be coerced to type [ `A ] t
    &lt;/pre&gt;
    The type variable can be annotated as contravariant however, and
    the coercion function typechecks.
    &lt;pre&gt;
    # type -&amp;alpha; t;;
    # let f (x : [`A | `B] t) = (x :&amp;gt; [ `A ] t);;
    val f : [ `A | `B ] t &amp;rarr; [ `A ] t = &amp;lt;fun&amp;gt;
    &lt;/pre&gt;
    The declaration &lt;code&gt;type -&amp;alpha; t&lt;/code&gt; declares that the abstract
    type &lt;code&gt;t&lt;/code&gt; is contravariant in its parameter : if $\tau$
    is a subtype of $\sigma$ then $\sigma\;t$ is a subtype of
    $\tau\;t$. In this example, $\tau = $&lt;code&gt;[ `A ]&lt;/code&gt; and
    $\sigma = $&lt;code&gt;[`A | `B]&lt;/code&gt;, $\tau$ is a subtype of $\sigma$
    and
    &lt;code&gt;[ `A | `B ] t&lt;/code&gt; is a subtype of &lt;code&gt;[ `A ] t&lt;/code&gt;.
    
    &lt;p&gt;
    In the following, &lt;code&gt;type &amp;alpha; t&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt;
    abstract and variance can be inferred.
    &lt;/p&gt;&lt;pre&gt;
    # type &amp;alpha; t = {x : &amp;alpha;} ;;
    # let f x = (x : [`A] t :&amp;gt; [`A | `B] t);;
    val f : [ `A ] t &amp;rarr; [ `A | `B ] t = &amp;lt;fun&amp;gt;
    &lt;/pre&gt;
    Introducing a constraint however inhibits variance inference.
    &lt;pre&gt;
    # type &amp;alpha; t = {x : &amp;alpha;} constraint &amp;alpha; = [&amp;lt; `A | `B ];;
    # let f x = (x : [ `A ] t :&amp;gt; [ `A | `B ] t);;
    Error: Type [ `A ] t is not a subtype of [ `A | `B ] t 
    &lt;/pre&gt;
    This situation can be overcome by introducing a covariance
    annotation.
    &lt;pre&gt;
    # type +&amp;alpha; t = {x : &amp;alpha;} constraint &amp;alpha; = [&amp;lt; `A | `B ];;
    # let f x = (x : [ `A ] t :&amp;gt; [ `A | `B ] t);;
    val f : [ `A ] t &amp;rarr; [ `A | `B ] t = &amp;lt;fun&amp;gt;
    &lt;/pre&gt;
    In the following example, &lt;code&gt;&amp;alpha;&lt;/code&gt; does not
    participate in the definition of &lt;code&gt;type &amp;alpha; t&lt;/code&gt;.
    &lt;pre&gt;
    # type &amp;alpha; t = {x : int};;
    # let f x = (x : [ `A ] t :&amp;gt; [ `B ] t);;
    val f : [ `A ] t &amp;rarr; [ `B ] t = &amp;lt;fun&amp;gt;
    &lt;/pre&gt;
    In this case, any conversion between &lt;code&gt;&amp;delta; t&lt;/code&gt;
    and &lt;code&gt;&amp;epsilon; t&lt;/code&gt; is legal : the
    types &lt;code&gt;&amp;delta;&lt;/code&gt; and &lt;code&gt;&amp;epsilon;&lt;/code&gt; are not
    required to have a subtyping relation between them.
    
   &lt;hr/&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2017/03/polymorphic-variants-subtyping-and.html</id><title type="text">Polymorphic variants : Subtyping and variance</title><updated>2017-03-07T20:05:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/10/implementing-type-classes-as-ocaml.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
     
    
    &lt;title&gt;Implementing type-classes as OCaml modules&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;Modular type classes&lt;/h2&gt;
    &lt;p&gt;
     We revisit the idea of type-classes first explored
     in &lt;a href=&quot;http://blog.shaynefletcher.org/2016/10/haskell-type-classes-in-ocaml-and-c.html&quot;&gt;this
     post&lt;/a&gt;. This time though, the implementation technique will be
     by via OCaml modules inspired by the paper &amp;quot;Modular Type Classes&amp;quot;
     [2] by Harper et. al.
    &lt;/p&gt;

    &lt;p&gt;Starting with the basics, consider the class of types whose
    values can be compared for equality. Call this
    type-class &lt;b&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/b&gt;. We represent the class as a
    module signature.
    &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
    module type EQ = sig
      type t

      val eq : t * t &amp;rarr; bool
    end
    &lt;/pre&gt;
    Specific instances of &lt;b&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/b&gt; are modules that
    implement this signature. Here are two examples.
    &lt;pre class=&quot;prettyprint ml&quot;&gt;
    module Eq_bool : EQ with type t = bool = struct
      type t = bool
    
      let eq (a, b) = a = b
    end
    
    module Eq_int : EQ with type t = int = struct
      type t = int
    
      let eq (a, b) = a = b
    end
    &lt;/pre&gt;
    
    &lt;p&gt;Given instances of class &lt;b&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/b&gt; (&lt;code&gt;X&lt;/code&gt;
    and &lt;code&gt;Y&lt;/code&gt; say,) we realize that products of those
    instances are also in &lt;b&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/b&gt;. This idea can be
    expressed as a functor with the following type.
    &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
    module type EQ_PROD =
      functor (X : EQ) (Y : EQ) &amp;rarr; EQ with type t = X.t * Y.t
    &lt;/pre&gt;
    The implementation of this functor is simply stated as the
    following.
    &lt;pre class=&quot;prettyprint ml&quot;&gt;
    module Eq_prod : EQ_PROD =
      functor (X : EQ) (Y : EQ) &amp;rarr; struct
        type t = X.t * Y.t

        let eq ((x1, y1), (x2, y2)) =  X.eq (x1, x2) &amp;amp;&amp;amp; Y.eq(y1, y2)
    end
    &lt;/pre&gt;
    With this functor we can build concrete instances for
    products. Here's one example.
    &lt;pre class=&quot;prettyprint ml&quot;&gt;
    module Eq_bool_int : 
       EQ with type t = (bool * int) = Eq_prod (Eq_bool) (Eq_int)
    &lt;/pre&gt;
    &lt;p&gt;The class &lt;b&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/b&gt; can be used as a building
    block for the construction of new type classes. For example, we
    might define a new type-class &lt;b&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/b&gt; that admits
    types that are equality comparable and whose values can be ordered
    with a &amp;quot;less-than&amp;quot; relation. We introduce a new module type to
    describe this class.
    &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
    module type ORD = sig
      include EQ

      val lt : t * t &amp;rarr; bool
    end
    &lt;/pre&gt;
    Here's an example instance of this class.
    &lt;pre class=&quot;prettyprint ml&quot;&gt;
    module Ord_int : ORD with type t = int = struct
      include Eq_int
    
      let lt (x, y) = Pervasives.( &amp;lt; ) x y
    end
    &lt;/pre&gt;
    As before, given two instances of this class, we observe that
    products of these instances also reside in the class. Accordingly,
    we have this functor type
    &lt;pre class=&quot;prettyprint ml&quot;&gt;
    module type ORD_PROD =
      functor (X : ORD) (Y : ORD) &amp;rarr; ORD with type t = X.t * Y.t
    &lt;/pre&gt;
    with the following implementation.
    &lt;pre class=&quot;prettyprint ml&quot;&gt;
    module Ord_prod : ORD_PROD =
      functor (X : ORD) (Y : ORD) &amp;rarr; struct
        include Eq_prod (X) (Y)
    
        let lt ((x1, y1), (x2, y2)) =
          X.lt (x1, x2) || X.eq (x1, x2) &amp;amp;&amp;amp; Y.lt (y1, y2)
      end
    &lt;/pre&gt;
    This is the corresponding instance for pairs of intgers.
    &lt;pre class=&quot;prettyprint ml&quot;&gt;
    module Ord_int_int = Ord_prod (Ord_int) (Ord_int)
    &lt;/pre&gt;
    Here's a simple usage example.
    &lt;pre class=&quot;prettyprint ml&quot;&gt;
    let test_ord_int_int = 
      let x = (1, 2) and y = (1, 4) in
      assert ( not (Ord_int_int.eq (x, y)) &amp;amp;&amp;amp; Ord_int_int.lt (x, y))
    &lt;/pre&gt;
    
    &lt;h2&gt;Using type-classes to implement parameteric polymorphism&lt;/h2&gt;

    &lt;p&gt;This section begins with the &lt;b&gt;&lt;code&gt;Show&lt;/code&gt;&lt;/b&gt; type-class.
    &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
     module type SHOW = sig
      type t

      val show : t &amp;rarr; string
    end
   &lt;/pre&gt;
   In what follows, it is convenient to make an alias for module
   values of this type.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
   type &amp;alpha; show_impl = (module SHOW with type t = &amp;alpha;)
   &lt;/pre&gt;
   Here are two instances of this class...
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
    module Show_int : SHOW with type t = int = struct
      type t = int
    
      let show = Pervasives.string_of_int
    end

    module Show_bool : SHOW with type t = bool = struct
      type t = bool

      let show = function | true &amp;rarr; &amp;quot;True&amp;quot; | false &amp;rarr; &amp;quot;False&amp;quot;
    end
   &lt;/pre&gt;
   ... and here these instances are &amp;quot;packed&amp;quot; as values.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
    let show_int : int show_impl = 
      (module Show_int : SHOW with type t = int)

    let show_bool : bool show_impl = 
      (module Show_bool : SHOW with type t = bool)
   &lt;/pre&gt;
   The existence of the &lt;b&gt;&lt;code&gt;Show&lt;/code&gt;&lt;/b&gt; class is all that is
   required to enable the writing of our first parametrically
   polymorphic function.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
    let print : &amp;alpha; show_impl &amp;rarr; &amp;alpha; &amp;rarr; unit =
      fun (type a) (show : a show_impl) (x : a) &amp;rarr;
      let module Show = (val show : SHOW with type t = a) in
      print_endline@@ Show.show x
    
    let test_print_1 : unit = print show_bool true
    let test_print_2 : unit = print show_int 3
   &lt;/pre&gt;
   The function &lt;code&gt;print&lt;/code&gt; can be used with values of any
   type &lt;code&gt;&amp;alpha;&lt;/code&gt; as long as the caller can produce
   evidence of &lt;code&gt;&amp;alpha;&lt;/code&gt;'s membership
   in &lt;b&gt;&lt;code&gt;Show&lt;/code&gt;&lt;/b&gt; (in the form of a compatible instance).
   
   &lt;p&gt;The next example begins with the definition of a
   type-class &lt;b&gt;&lt;code&gt;Num&lt;/code&gt;&lt;/b&gt; (the class of additive numbers)
   together with some example instances.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
    module type NUM = sig
      type t
    
      val from_int : int &amp;rarr; t
      val ( + ) : t &amp;rarr; t &amp;rarr; t
    end
    
    module Num_int : NUM with type t = int = struct
      type t = int
    
      let from_int x = x
      let ( + ) = Pervasives.( + )
    end
    
    let num_int = (module Num_int : NUM with type t = int)
    
    module Num_bool : NUM with type t = bool = struct
      type t = bool
    
      let from_int = function | 0 &amp;rarr; false | _ &amp;rarr; true
      let ( + ) = function | true &amp;rarr; fun _ &amp;rarr; true | false &amp;rarr; fun x &amp;rarr; x
    end
    
    let num_bool = (module Num_bool : NUM with type t = bool)
   &lt;/pre&gt;
   The existence of &lt;b&gt;&lt;code&gt;Num&lt;/code&gt;&lt;/b&gt; admits writing a
   polymorphic function &lt;code&gt;sum&lt;/code&gt; that will work for
   any &lt;code&gt;&amp;alpha; list&lt;/code&gt; of values if only &lt;code&gt;&amp;alpha;&lt;/code&gt;
   can be shown to be in &lt;b&gt;&lt;code&gt;Num&lt;/code&gt;&lt;/b&gt;.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
    let sum : &amp;alpha; num_impl &amp;rarr; &amp;alpha; list &amp;rarr; &amp;alpha; =
      fun (type a) (num : a num_impl) (ls : a list) &amp;rarr;
        let module Num = (val num : NUM with type t = a) in
        List.fold_right Num.( + ) ls (Num.from_int 0)
    
    let test_sum = sum num_int [1; 2; 3; 4]
   &lt;/pre&gt;
   This next function requires evidence of membership in two classes.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
    let print_incr : (&amp;alpha; show_impl * &amp;alpha; num_impl) &amp;rarr; &amp;alpha; &amp;rarr; unit =
      fun (type a) ((show : a show_impl), (num : a num_impl)) (x : a) &amp;rarr;
        let module Num = (val num : NUM with type t = a) in
        let open Num
        in print show (x + from_int 1)
    
    (*An instantiation*)
    let print_incr_int (x : int) : unit = print_incr (show_int, num_int) x
   &lt;/pre&gt;
   
   &lt;p&gt;If &lt;code&gt;&amp;alpha;&lt;/code&gt; is in &lt;b&gt;&lt;code&gt;Show&lt;/code&gt;&lt;/b&gt; then we
   can easily extend &lt;b&gt;&lt;code&gt;Show&lt;/code&gt;&lt;/b&gt; to include the
   type &lt;code&gt;&amp;alpha; list&lt;/code&gt;. As we saw earlier, this kind of
   thing can be done with an approriate functor.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
    module type LIST_SHOW =
      functor (X : SHOW) &amp;rarr; SHOW with type t = X.t list
    
    module List_show : LIST_SHOW =
      functor (X : SHOW) &amp;rarr; struct
        type t = X.t list
    
        let show =
            fun xs &amp;rarr;
              let rec go first = function
                | [] &amp;rarr; &amp;quot;]&amp;quot;
                | h :: t &amp;rarr;
                  (if (first) then &amp;quot;&amp;quot; else &amp;quot;, &amp;quot;) ^ X.show h ^ go false t 
              in &amp;quot;[&amp;quot; ^ go true xs
      end
   &lt;/pre&gt;
   There is also another way : one can write a function to dynamically
   compute an &lt;code&gt;&amp;alpha; list show_impl&lt;/code&gt; from an &lt;code&gt;&amp;alpha;
   show_impl&lt;/code&gt;.
  &lt;pre class=&quot;prettyprint ml&quot;&gt;
  let show_list : &amp;alpha; show_impl &amp;rarr; &amp;alpha; list show_impl =
    fun (type a) (show : a show_impl) &amp;rarr;
      let module Show = (val show : SHOW with type t = a) in
      (module struct
        type t = a list
  
        let show : t &amp;rarr; string =
          fun xs &amp;rarr;
            let rec go first = function
              | [] &amp;rarr; &amp;quot;]&amp;quot;
              | h :: t &amp;rarr;
                (if (first) then &amp;quot;&amp;quot; else &amp;quot;, &amp;quot;) ^ Show.show h ^ go false t
            in &amp;quot;[&amp;quot; ^ go true xs
      end : SHOW with type t = a list)
    
   let testls : string = let module Show =
       (val (show_list show_int) : SHOW with type t = int list) in
      Show.show (1 :: 2 :: 3 :: [])
  &lt;/pre&gt;
   
   &lt;p&gt;The type-class &lt;b&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/b&gt; is an aggregation of the
   type-classes &lt;b&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/b&gt; and &lt;b&gt;&lt;code&gt;Num&lt;/code&gt;&lt;/b&gt;
   together with a function to perform multiplication.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
   module type MUL = sig
      include EQ
      include NUM with type t := t
    
      val mul : t &amp;rarr; t &amp;rarr; t
   end
    
   type &amp;alpha; mul_impl = (module MUL with type t = &amp;alpha;)
    
   module type MUL_F =
     functor (E : EQ) (N : NUM with type t = E.t) &amp;rarr; MUL with type t = E.t
   &lt;/pre&gt;
   A default instance of &lt;b&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/b&gt; can be provided given
   compatible instances of &lt;b&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/b&gt;
   and &lt;b&gt;&lt;code&gt;Num&lt;/code&gt;&lt;/b&gt;.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
    module Mul_default : MUL_F =
      functor (E : EQ) (N : NUM with type t = E.t)  &amp;rarr; struct
        include (E : EQ with type t = E.t)
        include (N : NUM with type t := E.t)
    
        let mul : t &amp;rarr; t &amp;rarr; t =
          let rec loop x y = begin match () with
            | () when eq (x, (from_int 0)) &amp;rarr; from_int 0
            | () when eq (x, (from_int 1)) &amp;rarr; y
            | () &amp;rarr; y + loop (x + (from_int (-1))) y
          end in loop
    
    end
    
    module Mul_bool : MUL with type t = bool = 
      Mul_default (Eq_bool) (Num_bool)
   &lt;/pre&gt;
   Specific instances can be constructed as needs demand.
   &lt;pre class=&quot;prettyprint ml&quot;&gt;
   module Mul_int : MUL with type t = int = struct
     include (Eq_int : EQ with type t = int)
     include (Num_int : NUM with type t := int)
    
     let mul = Pervasives.( * )
   end
    
   let dot : &amp;alpha; mul_impl &amp;rarr; &amp;alpha; list &amp;rarr; &amp;alpha; list &amp;rarr; &amp;alpha; =
     fun (type a) (mul : a mul_impl) &amp;rarr;
       fun xs ys &amp;rarr;
         let module M = (val mul : MUL with type t = a) in
         sum (module M : NUM with type t = a)@@ List.map2 M.mul xs ys
    
   let test_dot =
     dot (module Mul_int : MUL with type t = int) [1; 2; 3] [4; 5; 6]
   &lt;/pre&gt;
   Note that in this definition of &lt;code&gt;dot&lt;/code&gt;, coercision of the
   provided &lt;b&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/b&gt; instance to its
   base &lt;b&gt;&lt;code&gt;Num&lt;/code&gt;&lt;/b&gt; instance is performed.
   
   &lt;p&gt;This last section provides an example of polymorphic recursion
   utilizing the dynamic production of evidence by way of
   the &lt;code&gt;show_list&lt;/code&gt; function presented earlier.
   &lt;/p&gt;&lt;p&gt;
   &lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
   let rec replicate : int &amp;rarr; &amp;alpha; &amp;rarr; &amp;alpha; list =
     fun n x &amp;rarr; if n &amp;lt;= 0 then [] else x :: replicate (n - 1) x
   
   let rec print_nested : &amp;alpha;. &amp;alpha; show_impl &amp;rarr; int &amp;rarr; &amp;alpha; &amp;rarr; unit =
     fun show_mod &amp;rarr; function
     | 0 &amp;rarr; fun x &amp;rarr; print show_mod x
     | n &amp;rarr; fun x &amp;rarr; print_nested (show_list show_mod) (n - 1) (replicate n x)
   
   let test_nested =
     let n = read_int () in
     print_nested (module Show_int : SHOW with type t = int) n 5
   &lt;/pre&gt;
   
   
   &lt;hr/&gt;
   &lt;p&gt;
     References:&lt;br/&gt;
     [1] &lt;a href=&quot;http://okmij.org/ftp/Computation/typeclass.html&quot;&gt;Implementing, and Understanding Type Classes&lt;/a&gt; -- Oleg Kiselyov
     [2] &lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/mtc-popl.pdf&quot;&gt;Modular Type Classes&lt;/a&gt; -- Harper et. al.
   &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2016/10/implementing-type-classes-as-ocaml.html</id><title type="text">Implementing type-classes as OCaml modules</title><updated>2016-10-29T16:35:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/10/haskell-type-classes-in-ocaml-and-c.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
     
    
    &lt;title&gt;Haskell type-classes in OCaml and C++&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;This article examines the emulation of Haskell like
       type-classes in OCaml and C++. It follows [1] closely
       (recommended for further reading), extending on some of the
       example code given there to include C++.
    &lt;/p&gt;
    &lt;p&gt;First stop, a simplified version of the &lt;code&gt;Show&lt;/code&gt;
       type-class with a couple of simple instances.
    &lt;/p&gt;&lt;pre class=&quot;prettyprint haskell&quot;&gt;
    class Show a where
      show :: a -&amp;gt; string

    instance Show Int where
      show x = Prelude.show x -- internal

    instance Show Bool where
      str True = &amp;quot;True&amp;quot;
      str False = &amp;quot;False&amp;quot;
    &lt;/pre&gt;
    The OCaml equivalent shown here uses the &amp;quot;dictionary passing&amp;quot;
    technique for implementation. The type-class
    declaration &lt;code&gt;Show&lt;/code&gt; in Haskell translates to a data-type
    declaration for a polymorphic record &lt;code&gt;&amp;alpha; show&lt;/code&gt; in
    OCaml.
    &lt;pre class=&quot;prettyprint ocaml&quot;&gt;
    type &amp;alpha; show = {
      show : &amp;alpha; &amp;rarr; string
    }

    let show_bool : bool show = {
      show = function | true &amp;rarr; &amp;quot;True&amp;quot; | false &amp;rarr; &amp;quot;False&amp;quot;
    }

    let show_int : int show = {
      show = string_of_int
    }
    &lt;/pre&gt;
    In C++ we can use a template class to represent the type-class and
    specializations to represent the instances.
    &lt;pre class=&quot;prettyprint c++&quot;&gt;
      template &amp;lt;class A&amp;gt; struct Show {};

      template &amp;lt;&amp;gt;
      struct Show&amp;lt;int&amp;gt; {
        static std::string (*show)(int);
      };
      std::string(*Show&amp;lt;int&amp;gt;::show)(int) = &amp;amp;std::to_string;

      template &amp;lt;&amp;gt;
      struct Show&amp;lt;bool&amp;gt; {
        static std::string show (bool);
      };
      std::string Show&amp;lt;bool&amp;gt;::show (bool b) { return b ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot;; }
    &lt;/pre&gt;
    
    &lt;p&gt;
    Next up &lt;code&gt;print&lt;/code&gt;, a parametrically polymorphic function.
    &lt;/p&gt;&lt;pre class=&quot;prettyprint haskell&quot;&gt;
      print :: Show a =&amp;gt; a -&amp;gt; IO ()
      print x = putStrLn$ show x
    &lt;/pre&gt;
    According to our dictionary passing scheme in OCaml, this renders as the following.
    &lt;pre class=&quot;prettyprint ocaml&quot;&gt;
      let print : &amp;alpha; show &amp;rarr; &amp;alpha; &amp;rarr; unit = 
        fun {show} &amp;rarr; fun x &amp;rarr; print_endline@@ show x
    &lt;/pre&gt;
    The key point to note here is that in OCaml, evidence of
    the &lt;code&gt;&amp;alpha;&lt;/code&gt; value's membership in
    the &lt;code&gt;Show&lt;/code&gt; class must be produced explicitly by the
    programmer. In C++, like Haskell, no evidence of the argument's
    membership is required, the compiler keeps track of that
    implicitly.
    &lt;pre class=&quot;prettyprint c++&quot;&gt;
    template &amp;lt;class A&amp;gt;
    void print (A const&amp;amp; a) {
      std::cout &amp;lt;&amp;lt; Show&amp;lt;A&amp;gt;::show (a) &amp;lt;&amp;lt; std::endl;
    }
    &lt;/pre&gt;
    
    &lt;p&gt;This next simplified type-class shows a different pattern of
    overloading : the function &lt;code&gt;fromInt&lt;/code&gt; is overloaded on
    the result type and the &lt;code&gt;(+)&lt;/code&gt; function is binary.
    &lt;/p&gt;&lt;pre class=&quot;prettyprint haskell&quot;&gt;
    class Num a where
      fromInt :: Int -&amp;gt; a
      (+)     :: a -&amp;gt; a -&amp;gt; a

    sum :: Num a =&amp;gt; [a] -&amp;gt; a
    sum ls = foldr (+) (fromInt 0) ls
    &lt;/pre&gt;
    Translation into OCaml is as in the following.
    &lt;pre class=&quot;prettyprint ocaml&quot;&gt;
    type &amp;alpha; num = {
      from_int : int &amp;rarr; &amp;alpha;;
      add      : &amp;alpha; &amp;rarr; &amp;alpha; &amp;rarr; &amp;alpha;;
    }

    let sum : &amp;alpha; num &amp;rarr; &amp;alpha; list &amp;rarr; &amp;alpha; = 
      fun {from_int; add= ( + )} &amp;rarr; 
        fun ls &amp;rarr;
          List.fold_right ( + ) ls (from_int 0)
    &lt;/pre&gt;
    Translation into C++, reasonably mechanical. One slight
    disappointment is that it doesn't seem possible to get the
    operator '&lt;code&gt;+&lt;/code&gt;' syntax as observed in both the Haskell
    and OCaml versions.
    &lt;pre class=&quot;prettyprint c++&quot;&gt;
    template &amp;lt;class A&amp;gt;
    struct Num {};
    
    namespace detail {
      template &amp;lt;class F, class A, class ItT&amp;gt;
      A fold_right (F f, A z, ItT begin, ItT end) {
        if (begin == end) return z;
        return f (fold_right (f, z, std::next (begin), end), *begin);
      }
    }//namespace&amp;lt;detail&amp;gt; 
    
    template &amp;lt;class ItT&amp;gt;
    typename std::iterator_traits&amp;lt;ItT&amp;gt;::value_type 
    sum (ItT begin, ItT end) {
      using A = typename std::iterator_traits&amp;lt;ItT&amp;gt;::value_type;
      auto add = Num&amp;lt;A&amp;gt;::add;
      auto from_int = Num&amp;lt;A&amp;gt;::from_int;
      return detail::fold_right (add, from_int (0), begin, end);
    }
    &lt;/pre&gt;
    In Haskell, &lt;code&gt;Int&lt;/code&gt; is made a member of &lt;code&gt;Num&lt;/code&gt;
    with this declaration.
    &lt;pre class=&quot;prettyprint haskell&quot;&gt;
     instance Num Int where
       fromInt x = x
       (+)       = (Prelude.+)
   &lt;/pre&gt;
   Returning to OCaml, we can define a couple of instances including the one above like this.
   &lt;pre class=&quot;prettyprint ocaml&quot;&gt;
    let int_num  : int num  = { 
      from_int = (fun x &amp;rarr; x); 
      add      = Pervasives.( + ); 
    }
    
    let bool_num : bool num = {
      from_int = (function | 0 &amp;rarr; false | _ &amp;rarr; true);
      add = function | true &amp;rarr; fun _ &amp;rarr; true | false &amp;rarr; fun x &amp;rarr; x
    }
   &lt;/pre&gt;
   The code defining those above instances in C++ follows.
   &lt;pre class=&quot;prettyprint c++&quot;&gt;
    template &amp;lt;&amp;gt;
    struct Num&amp;lt;int&amp;gt; {
      static int from_int (int);
      static int add (int, int);
    };
    
    int Num&amp;lt;int&amp;gt;::from_int (int i) { return i; }
    int Num&amp;lt;int&amp;gt;::add (int x, int y) { return x + y; }
    
    template &amp;lt;&amp;gt;
    struct Num&amp;lt;bool&amp;gt; {
      static bool from_int (int);
      static bool add (bool, bool);
    };
    
    bool Num&amp;lt;bool&amp;gt;::from_int (int i) { return i != 0; }
    bool Num&amp;lt;bool&amp;gt;::add (bool x, bool y) { if (x) return true; return y; }
   &lt;/pre&gt;
   Here now is a function with two type-class constraints.
   &lt;pre class=&quot;prettyprint haskell&quot;&gt;
    print_incr :: (Show a, Num a) =&amp;gt; a -&amp;gt; IO ()
    print_incr x = print$ x + fromInt 1
   &lt;/pre&gt;
   In OCaml this can be written like so.
   &lt;pre class=&quot;prettyprint ocaml&quot;&gt;
    let print_incr : (&amp;alpha; show * &amp;alpha; num) &amp;rarr; &amp;alpha; &amp;rarr; unit = 
      fun (show, {from_int; add= ( + )}) &amp;rarr; 
        fun x &amp;rarr; print show (x + (from_int 1))
   &lt;/pre&gt;
   In C++, this is said as you see below.
   &lt;pre class=&quot;prettyprint c++&quot;&gt;
    template &amp;lt;class A&amp;gt;
    void print_incr (A x) {
      print (Num&amp;lt;A&amp;gt;::add (x, Num&amp;lt;A&amp;gt;::from_int (1)));
    }
   &lt;/pre&gt;
   Naturally, the above function will only be defined for
   types &lt;code&gt;A&lt;/code&gt; that are members of both the &lt;code&gt;Show&lt;/code&gt;
   and &lt;code&gt;Num&lt;/code&gt; classes and will yield compile errors for
   types that are not.
   
   &lt;p&gt;Moving on, we now look at another common pattern, an instance
   with a constraint : a &lt;code&gt;Show&lt;/code&gt; instance for all list
   types &lt;code&gt;[a]&lt;/code&gt; when the element instance &lt;code&gt;&lt;/code&gt; is a
   member of &lt;code&gt;Show&lt;/code&gt;.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint haskell&quot;&gt;
    instance Show a =&amp;gt; Show [a] where
      show xs = &amp;quot;[&amp;quot; ++ go True xs
        where
          go _ [] = &amp;quot;]&amp;quot;
          go first (h:t) =
            (if first then &amp;quot;&amp;quot; else &amp;quot;, &amp;quot;) ++ show h ++ go False t
   &lt;/pre&gt;
   
   In OCaml, this takes the form of a function. The idea is, given
   evidence of a type &lt;code&gt;&amp;alpha;&lt;/code&gt;'s membership
   in &lt;code&gt;Show&lt;/code&gt; the function produces evidence that the
   type &lt;code&gt;&amp;alpha; list&lt;/code&gt; is also in &lt;code&gt;Show&lt;/code&gt;.
   &lt;pre class=&quot;prettyprint ocaml&quot;&gt;
    let show_list : &amp;alpha; show &amp;rarr; &amp;alpha; list show =
      fun {show} &amp;rarr;
        {show = fun xs &amp;rarr;
          let rec go first = function
            | [] &amp;rarr; &amp;quot;]&amp;quot;
            | h :: t &amp;rarr;
              (if (first) then &amp;quot;&amp;quot; else &amp;quot;, &amp;quot;) ^ show h ^ go false t in
          &amp;quot;[&amp;quot; ^ go true xs
        }
   &lt;/pre&gt;
   It might be possible to do better than the following partial
   specialization over &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; in C++ (that is, to
   write something generic, just once, that works for a wider set
   ofsequence types) using some advanced meta-programming &amp;quot;hackery&amp;quot;, I
   don't really know. I suspect finding out might be a bit of a rabbit
   hole best avoided for now.
   &lt;pre class=&quot;prettyprint c++&quot;&gt;
    template &amp;lt;class A&amp;gt;
    struct Show&amp;lt;std::vector&amp;lt;A&amp;gt;&amp;gt; {
      static std::string show (std::vector&amp;lt;A&amp;gt; const&amp;amp; ls);
    };
    
    template &amp;lt;class A&amp;gt;
    std::string Show&amp;lt;std::vector&amp;lt;A&amp;gt;&amp;gt;::show (std::vector&amp;lt;A&amp;gt; const&amp;amp; ls) {
      bool first=true;
      typename std::vector&amp;lt;A&amp;gt;::const_iterator begin=ls.begin (), end=ls.end ();
      std::string s=&amp;quot;[&amp;quot;;
      while (begin != end) {
        if (first) first = false;
        else s += &amp;quot;, &amp;quot;;
        //A compile time error will result here if if there is no
        //evidence that `A` is in `Show`
        s += Show&amp;lt;A&amp;gt;::show (*begin++);
      }
      s += &amp;quot;]&amp;quot;;
    
      return s;
    }
   &lt;/pre&gt;
   

   &lt;p&gt;In this next example, we need a type-class describing types that
      can be compared for equality, &lt;code&gt;Eq&lt;/code&gt;. That property and
      the &lt;code&gt;Num&lt;/code&gt; class can be combined to produce a
      type-class with a super-class and a default.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint haskell&quot;&gt;
    class Eq where
      (==) :: a -&amp;gt; a -&amp;gt; bool
      (/=) :: a -&amp;gt; a -&amp;gt; bool
  
    deriving instance Eq Bool
    deriving instance Eq Int

    class (Eq a, Num a) =&amp;gt; Mul a where
      (*) :: a -&amp;gt; a -&amp;gt; a
      x * _ | x == fromInt 0 = fromInt 0
      x * y | x == fromInt 1 = y
      x * y | y + (x + (fromInt (-1))) * y

    dot :: Mul a =&amp;gt; [a] -&amp;gt; [a] -&amp;gt; a
    dot xs ys = sum$ zipWith ( * ) xs ys
   &lt;/pre&gt;
   Modeling the above in OCaml is done with a dictionary for
   the &lt;code&gt;Mul&lt;/code&gt; type-class and a function to generate
   instances from super-class instances.
   &lt;pre class=&quot;prettyprint ocaml&quot;&gt;
    type &amp;alpha; mul = {
      mul_super : &amp;alpha; eq * &amp;alpha; num;
      mul : &amp;alpha; &amp;rarr; &amp;alpha; &amp;rarr; &amp;alpha;
    }
    
    let mul_default : &amp;alpha; eq * &amp;alpha; num &amp;rarr; &amp;alpha; mul = 
      fun (({eq}, {from_int; add = ( + )}) as super) &amp;rarr; 
        {
          mul_super = super;
          mul = let rec loop x y = begin match () with
          | () when eq x (from_int 0) &amp;rarr; from_int 0
          | () when eq x (from_int 1) &amp;rarr; y
          | () &amp;rarr; y + loop (x + (from_int (-1))) y 
          end in loop
        }
    
    let bool_mul : bool mul = 
      mul_default (bool_eq, bool_num)
    
    let int_mul : int mul = {
      mul_super = (int_eq, int_num);
      mul = Pervasives.( * )
    }

    let dot : &amp;alpha; mul &amp;rarr; &amp;alpha; list &amp;rarr; &amp;alpha; list &amp;rarr; &amp;alpha; = 
      fun {mul_super = (eq, num); mul} &amp;rarr;
        fun xs ys &amp;rarr; sum num@@ List.map2 mul xs ys
   &lt;/pre&gt;
   As one would expect, expressing the base class/derived class
   relationships in C++ is playing to its strengths.
   &lt;pre class=&quot;prettyprint c++&quot;&gt;
    template &amp;lt;class A&amp;gt; struct Eq {};
    
    template &amp;lt;&amp;gt;
    struct Eq&amp;lt;bool&amp;gt; {
      static bool eq (bool, bool);
      static bool neq (bool, bool);
    };
    
    bool Eq&amp;lt;bool&amp;gt;::eq (bool s, bool t) { return s == t; }
    bool Eq&amp;lt;bool&amp;gt;::neq (bool s, bool t) { return s != t; }
    
    template &amp;lt;&amp;gt;
    struct Eq&amp;lt;int&amp;gt; {
      static int eq (int, int);
      static int neq (int, int);
    };
    
    int Eq&amp;lt;int&amp;gt;::eq (int s, int t) { return s == t; }
    int Eq&amp;lt;int&amp;gt;::neq (int s, int t) { return s != t; }

    template &amp;lt;class A&amp;gt;
    struct Mul : Eq&amp;lt;A&amp;gt;, Num &amp;lt;A&amp;gt; {
      using Eq&amp;lt;A&amp;gt;::eq;
      using Num&amp;lt;A&amp;gt;::add;
      using Num&amp;lt;A&amp;gt;::from_int;
    
      static A mul (A x, A y);
    };
    
    template &amp;lt;class A&amp;gt;
    A Mul&amp;lt;A&amp;gt;::mul (A x, A y) {
      if (eq (x, from_int (0))) return from_int (0);
      if (eq (x, from_int (1))) return y;
      return add (y, mul ((add (x, from_int (-1))), y));
    }
    
    template struct Mul&amp;lt;bool&amp;gt;;
    template &amp;lt;&amp;gt; int Mul&amp;lt;int&amp;gt;::mul (int x, int y) { return x * y; }
    
    namespace detail{
    
      template &amp;lt;class F, class It, class Acc&amp;gt;
      Acc map2 (F f
       , It xs_begin, It xs_end, It ys_begin, It ys_end, Acc acc) {
        if ((xs_begin == xs_end) || (ys_begin == ys_end)) return acc;
        return map2 (f
              , std::next (xs_begin)
              , xs_end
              , std::next (ys_begin)
              , ys_end
              , *acc++ = f (*xs_begin, *ys_begin));
      }
    
    }//namespace detail
    
    template &amp;lt;class A&amp;gt;
    A dot (std::vector&amp;lt;A&amp;gt; const&amp;amp; xs, std::vector&amp;lt;A&amp;gt; const&amp;amp; ys) {
      std::vector&amp;lt;A&amp;gt; buf;
      detail::map2 (
         Mul&amp;lt;A&amp;gt;::mul
       , xs.begin (), xs.end()
       , ys.begin (), ys.end ()
       , std::back_inserter(buf));
      return sum (buf.begin (), buf.end ());
    }
   &lt;/pre&gt;
   
   &lt;p&gt;This very last example is in polymorphic recursion. The Haskell reads as follows.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint haskell&quot;&gt;
   print_nested :: Show a =&amp;gt; Int -&amp;gt; a -&amp;gt; IO ()
   print_nested 0 x = print x
   print_nested n x = print_nested (n - 1) (replicate n x)

   test_nested = do
     n &amp;lt;- getLine
     print_nested (read n) (5::Int)
   &lt;/pre&gt;
   
   Those two functions are very interesting! Translating it to OCaml
   yields the following.
   &lt;pre class=&quot;prettyprint ocaml&quot;&gt;
    let rec replicate : int &amp;rarr; &amp;alpha; &amp;rarr; &amp;alpha; list = 
      fun n x &amp;rarr; if n &amp;gt;= 0 then [] else x :: replicate (n - 1) x
    
    let rec print_nested : &amp;alpha;. &amp;alpha; show &amp;rarr; int &amp;rarr; &amp;alpha; &amp;rarr; unit =
      fun show_dict &amp;rarr; function
      | 0 &amp;rarr;
          fun x &amp;rarr;
            print show_dict x
      | n &amp;rarr; 
          fun x &amp;rarr;
            print_nested (show_list show_dict) (n - 1) (replicate n x)

    let test_nested =
      let n = read_int () in
      print_nested show_int n 5
   &lt;/pre&gt;
   Now if you examine the output of the above if '4' (say) was
   entered, you'll see something like this:
   &lt;pre&gt;
   [[[[5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5]], [[5, 5, 5, 5], [5, 5,
   5, 5], [5, 5, 5, 5]]]]
   &lt;/pre&gt;
   You can see, looking at this, that the type of the printed list is
   not determinable at compile-time. It is dependent on a runtime
   parameter! It follows that the evidence that the type is in
   the &lt;code&gt;Show&lt;/code&gt; class can not be produced statically. It has
   to be computed dynamically which is what you see there in the
   application of &lt;code&gt;show_list&lt;/code&gt; to the
   current &lt;code&gt;show_dict&lt;/code&gt; in the &lt;code&gt;n &amp;lt;&amp;gt; 0&lt;/code&gt;
   branch of the &lt;code&gt;print_nested&lt;/code&gt; function. Note also the
   requirement for the universal quantifier in the function
   signature. It's mandatory.
   
   &lt;p&gt;OK, so how about the above code in C++? Well a naive
   transliteration gives the following.
   &lt;/p&gt;&lt;pre class=&quot;prettyprint c++&quot;&gt;
    namespace detail {
      template&amp;lt;class A, class ItT&amp;gt;
      ItT replicate (int n, A x, ItT dst) {
        if (n &amp;lt;= 0) return dst;
        return replicate ((n - 1), x, *dst++ = x);
      }
    
    }//namespace detail
    
    template &amp;lt;class A&amp;gt;
    void print_nested (int n, A const&amp;amp; x) {
      if (n == 0)
        print (x);
      else {
        std::vector&amp;lt;A&amp;gt; buf;
        detail::replicate(n, x, std::back_inserter(buf));
        print_nested (n - 1, buf);
      }
    }
    
    void test_nested () {
      int n;
      std::cin &amp;gt;&amp;gt; n;
      print_nested (n, 5);
    }
   &lt;/pre&gt;
   Unfortunately though, this program though exhibits unbounded
   compile time recursion (compilation doesn't terminate).
   
   &lt;hr/&gt;
   &lt;p&gt;
     References:&lt;br/&gt;
     [1] &lt;a href=&quot;http://okmij.org/ftp/Computation/typeclass.html&quot;&gt;Implementing, and Understanding Type Classes&lt;/a&gt; -- Oleg Kiselyov
   &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2016/10/haskell-type-classes-in-ocaml-and-c.html</id><title type="text">Haskell type-classes in OCaml and C++</title><updated>2016-10-26T19:25:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/10/monty-hall.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">&lt;p&gt;Suppose you're on a game show, and you're given the choice of three doors : Behind one door is a car; behind the others, goats. You pick a door, say No. 1, and the host, who knows what's behind the doors, opens another door, say No.3 which has a goat. He then says to you, &amp;quot;Do you want to pick door No. 2?&amp;quot; Is it to your advantage to switch your choice?
&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

&lt;p&gt;This problem is known as the &amp;quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Hall_problem&quot;&gt;Monty Hall&lt;/a&gt;&amp;quot; problem. It's named after the host of the American television game show &amp;quot;Let's make a deal&amp;quot;.
&lt;/p&gt;

&lt;p&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Paul_Erd%C5%91s&quot;&gt;Paul Erd&amp;#337;s&lt;/a&gt;, one of the most prolific mathematicians in history remained unconvinced (of the correct answer to the above problem) until he was shown a computer simulation confirming the predicted result.&lt;/p&gt;

&lt;p&gt;
Here's a simulation in OCaml one hopes, may have convinced Paul!
&lt;/p&gt;

&lt;pre class=&quot;prettyprint ocaml&quot;&gt;
module Monty = struct

  (*[dtr w p n] where [n] is the number of doors, selects which door
    to remain (closed) given the winning door [w] and the player
    chosen door [p]*)
  let rec dtr w p n =
    if p &amp;lt;&amp;gt; w then  w 
    else if p = 0 then n - 1 else 0

  (*[gen_game d] generates a game with [d] doors and returns a game
    with a winning door, a player selected door and a door to keep
    closed before if the player wants to switch*)
  let gen_game (d : int) : (int * int * int) =
    let w = Random.int d and p = Random.int d in 
    (w, p, dtr w p d)

  let num_wins = ref 0 (*To keep track of scores*)
  type strategy = Hold | Switch (*The type of strategies*)

  (*Play a single game*)
  let play_game (d : int) (s : strategy) : unit =
    let w, p, r = gen_game d in
    match s with
    | Hold &amp;rarr; num_wins := !num_wins + if p = w then 1 else 0
    | Switch &amp;rarr; num_wins := !num_wins + if r = w then 1 else 0

  (*Play a set of [n] games*)
  let play_games (d : int) (n : int) (s : strategy ) : unit = 
    let rec loop (i : int) : unit = 
      if i = n then ()
      else  begin
        play_game d s;
        loop (i + 1)
      end 
    in loop 0

end

open Monty

(*Initialized from the command line*)
let version       = ref false
let num_doors     = ref 0
let num_sims      = ref 0
let read_args () =
  let specification =
    [(&amp;quot;-v&amp;quot;, Arg.Set version, &amp;quot;Print the version number&amp;quot;);
     (&amp;quot;-d&amp;quot;, Arg.Set_int num_doors, &amp;quot;Number of doors (&amp;gt;= 3)&amp;quot; );
     (&amp;quot;-n&amp;quot;, Arg.Set_int num_sims, &amp;quot;Number of simulations (&amp;gt;= 1)&amp;quot;);
    ]
  in Arg.parse specification
  (fun s &amp;rarr;
    Printf.printf &amp;quot;Warning : Ignoring unrecognized argument \&amp;quot;%s\&amp;quot;\n&amp;quot; s)
  &amp;quot;Usage : monty -d &amp;lt;number of doors&amp;gt; -n &amp;lt;number of simulations&amp;gt;&amp;quot;

(*[fabs e] computes the absolute value of [e]*)
let fabs (e : float) : float = if e &amp;lt; 0. then ~-.e else e

(*Driver*)
let () = 
  try
    read_args ();
    if !version then Printf.printf &amp;quot;1.0.0\n&amp;quot;
    else
      let n = !num_sims and d = !num_doors in
      if d &amp;lt; 3 then
        raise (Invalid_argument &amp;quot;Number of doors must be &amp;gt;= than 3&amp;quot;);
      if n &amp;lt; 1 then
        raise (Invalid_argument &amp;quot;Number of simulations must be &amp;gt;= 1&amp;quot;);
      begin
        (*Hold*)
        num_wins := 0;
        play_games d n Hold;
        Printf.printf &amp;quot;Num wins (hold): %d\n&amp;quot; !num_wins;
        let err=fabs (float_of_int (!num_wins) /. 
                    (float_of_int n) -. 1.0 /. (float_of_int d)) in
        Printf.printf &amp;quot;Error %f\n&amp;quot; err;
        (*Switch*)
        num_wins := 0;
        play_games d n Switch;
        Printf.printf &amp;quot;Num wins (switch): %d\n&amp;quot; !num_wins;
        let err=fabs (float_of_int (!num_wins) /. 
                   (float_of_int n) -. (float_of_int (d - 1) /. 
                                                (float_of_int d))) in
        Printf.printf &amp;quot;Error %f\n&amp;quot; err ;
      end

  with 
  | Invalid_argument s &amp;rarr; Printf.printf &amp;quot;%s\n&amp;quot; s
&lt;/pre&gt;</content><id>http://blog.shaynefletcher.org/2016/10/monty-hall.html</id><title type="text">Monty Hall</title><updated>2016-10-12T16:05:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/10/conversion-operations-of-lambda-calculus.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">
&lt;html&gt;
  &lt;head&gt;
     
    
    &lt;title&gt;Conversion&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h4&gt;Abstract&lt;/h4&gt;
    &lt;p&gt;
    This note provides a super lightweight explanation of the three
    conversion operations of the $\lambda$-calculus known
    (cryptically) as $\alpha$, $\beta$ and $\eta$ conversions
    respectively (borrowed fairly freely from the delightful reference
    given at the bottom.)
    &lt;/p&gt;

    &lt;h4&gt;Syntax vs. semantics&lt;/h4&gt;
    &lt;p&gt;
      The $\textbf{syntax}$ of the language of $\textit{$\lambda$-
      expressions}$ is
      \[
      \begin{eqnarray}
      &amp;lt;exp&amp;gt; &amp;amp; ::= &amp;amp; &amp;lt;constant&amp;gt;\;\; &amp;amp; \text{Constants} \nonumber \\
                  &amp;amp; \mid &amp;amp; &amp;lt;variable&amp;gt;\;\; &amp;amp; \text{Variables} \nonumber \\
                  &amp;amp; \mid &amp;amp; &amp;lt;exp&amp;gt; &amp;lt;exp&amp;gt;\;\; &amp;amp; \text{Applications} \nonumber \\
                  &amp;amp; \mid &amp;amp; \lambda&amp;lt;variable&amp;gt;.&amp;lt;exp&amp;gt;\;\; &amp;amp; \text{Abstractions} \nonumber
      \end{eqnarray}
      \]
    The $\textbf{semantics}$ of the the $\lambda$-calculus is defined
    by three $\textit{conversion rules}$. To understand them 
    requires the terminology of $\textit{free}$ and
    $\textit{bound}$ variables. An occurence of a variable in a
    $\lambda$-expression is bound if there is an enclosing abstraction
    that binds it, and is free otherwise. For example, in $\lambda x.+\;
    ((\lambda y. +\;y\; z)\;7)\;x$, $x$ and $y$ appear bound whereas $z$
    appears free.
    &lt;/p&gt;

    &lt;h4&gt;$\beta$-conversion&lt;/h4&gt;
    &lt;p&gt;
      $\beta$-reduction describes how to apply a function to an
      argument. For example, $\left(\lambda x.+\;x\;1\right)\; 4$
      denotes the application of a particular $\lambda$-abstraction to
      the argument $4$. The result of applying a $\lambda$-abstraction
      to an argument is an instance of the body of the
      $\lambda$-abstraction in which (free) occurences of the formal
      parameter in the body are replaced with (copies of) the
      argument. Thus, $\left(\lambda x.+\;x\;1\right)\; 4 \rightarrow
      +\;4\;1 \rightarrow 5$. In the event there are no occurences of
      the formal parameter in the abstraction body, the argument is
      discarded unused so, $(\lambda x.\;3)\;4 \rightarrow 3$. Care is
      needed when formal parameter names are not unique. For example,

      \[
      \begin{eqnarray}
      &amp;amp; &amp;amp; \left(\lambda x.\;\left(\lambda x.+ \left(-\;x\;1\right)\right)\;x\;3\right)\; 9 \nonumber \\
      &amp;amp; \rightarrow &amp;amp; \left(\lambda x.+ \left(-\;x\;1\right)\right)\;9\;3 \nonumber \\
      &amp;amp; \rightarrow &amp;amp; +\;\left(-\;9\;1\right)\;3 \nonumber \\
      &amp;amp; \rightarrow &amp;amp; +\;8\;3 \nonumber \\
      &amp;amp; \rightarrow &amp;amp; 11 \nonumber
      \end{eqnarray}
      \]

      The key point of that example is that we did not substitue for
      the inner $x$ in the first reduction because it was not free in
      the body of the outer $\lambda x$ abstraction. Indeed, in the
      OCaml top-level we observe
      &lt;/p&gt;&lt;pre&gt;
       # (fun x -&amp;gt; (fun x -&amp;gt; ( + ) (( - ) x 1)) x 3) 9 ;;
       - : int = 11
      &lt;/pre&gt;
      or equivalently, in C++,
      &lt;pre&gt;
      auto add = [](int x) { return [=](int y) { return x + y; }; };
      auto sub = [](int x) { return [=](int y) { return x - y; }; };
      [=](int x) { 
        return [=](int x) {
          return add (sub (x) (1)); 
          } (x) (3); 
      } (9) ; //is the value '11'
      &lt;/pre&gt;

    The $\beta$-rule applied backwards is called $\beta$-abstraction
    and written with a backwards reduction arrow '$\leftarrow$'. Thus,
    $+\;4\;1 \leftarrow (\lambda x.\;+\;1\;x)\;4$. $\beta$-conversion
    means reduction or abstraction and is written with a double-ended
    arrow augmented with a $\beta$ (in order to distinguish it from
    other forms of conversion). So, $+\;4\;1
    \underset{\beta}{\leftrightarrow} (\lambda x.\;+\;1\;x)\;4$.  One
    way to look at $\beta$ conversion is that it is saying something
    about $\lambda$-expressions that look different but mean the same
    thing.
    

    &lt;h4&gt;$\alpha$-conversion&lt;/h4&gt;
    &lt;p&gt;
    It seems obvious that the two abstractions $\lambda x.+\;x\;1$ and
    $\lambda y.+\;y\;1$ &amp;quot;ought&amp;quot; to be equivalent. $\alpha$-conversion
    allows us to change the name of a formal parameter as long as it
    is done consistently. So we write $\lambda x.+\;x\;1
    \underset{\alpha}{\leftrightarrow} \lambda y.+\;y\;1$. Of course,
    the newly introduced name must not occur free in the body of the
    original $\lambda$-abstraction.
    &lt;/p&gt;

    &lt;h4&gt;$\eta$-conversion&lt;/h4&gt;
    &lt;p&gt;
      This last conversion rule exists to to complete our intuition
      about what $\lambda$-abstractions &amp;quot;ought&amp;quot; to be equivalent. The
      rule is this : If $f$ denotes a function, $x$ a variable that
      does not occur free in $f$, then $\lambda x.f\;x
      \underset{\eta}{\leftrightarrow} f$. For example, in OCaml if we
      define &lt;code&gt;f&lt;/code&gt; by
      &lt;code&gt;let f x = x + 1&lt;/code&gt; then clearly 
      &lt;code&gt;fun x -&amp;gt; f x&lt;/code&gt; produces the same results for
      all values &lt;code&gt;x&lt;/code&gt; in the domain of &lt;code&gt;f&lt;/code&gt;.
    &lt;/p&gt;

    &lt;h4&gt;Summary&lt;/h4&gt;
    &lt;p&gt;
    The first section provides a set of formal rules for constructing
    expressions (the BNF grammar). Using the notation
    $E\;\left[M/x\right]$ to mean the expression $E$ with $M$
    substituted for free occurrences of $x$ we can succintly state the
    the rules for converting one expression into an equivalent one as
    \[
    \begin{eqnarray}
    x\;\left[M/x\right] &amp;amp; = &amp;amp; M \nonumber \\
    c\;\left[M/x\right] &amp;amp; = &amp;amp; c\;\;\text{where $c$ is any variable or constant other than $x$} \nonumber  \\
    \left(E\;F\right)\;\left[M/x\right] &amp;amp; = &amp;amp; E\left[M/x\right]\; F\left[M/x\right]\; \nonumber \\
    \left(\lambda x.E\right)\;\left[M/x\right] &amp;amp; = &amp;amp; \lambda x.E \nonumber \\
    \left(\lambda y.E\right)\;\left[M/x\right] &amp;amp;   &amp;amp; \text{where $y$ is any variable other than $x$} \nonumber \\
                                               &amp;amp; = &amp;amp; \lambda y.E\left[M/x\right]\;\text{if $x$ does not occur free in E or $y$ does not occur free in $M$} \nonumber \\
                                               &amp;amp; = &amp;amp; \lambda z.\left(E\left[z/y\right]\right)\left[M/x\right]\;\text{otherwise}\nonumber \\

    \end{eqnarray}
    \]
    &lt;/p&gt;
    &lt;hr/&gt;
    &lt;p&gt;
      References:&lt;br/&gt;
      [1] &lt;cite&gt;The Implementation of Functional Programming Languages&lt;/cite&gt; by Simon L. Peyton Jones. 1987.&lt;/p&gt;
    
  &lt;/body&gt;
&lt;/html&gt;
</content><id>http://blog.shaynefletcher.org/2016/10/conversion-operations-of-lambda-calculus.html</id><title type="text">Conversion operations of the lambda-calculus </title><updated>2016-10-05T20:27:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/09/the-fixpoint-combinator.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">    &lt;p&gt; Consider the following recursive definition of the factorial
        function. 
        \[ 
            FAC = \lambda n.\;IF \left(=\;n\;0\right)\;1\;\left(*\;n\;\left(FAC\;\left(-\;n\;1\right)\right)\right) \nonumber
        \] 

       The definition relies on the ability to name a $\lambda$-abstraction
        and then to refer to this name inside the
        $\lambda$-abstraction itself. No such facility is provided by
        the $\lambda$-calculus. $\beta$-abstraction is applying
        $\beta$-reduction backwards to introduce new
        $\lambda$-abstractions, thus $+\;4\;1\leftarrow \left(\lambda
        x.\;+\;x\;1\right)\; 4$. By $\beta$-abstraction on $FAC$, its
        definition can be written 

        \[ 
          FAC = \left(\lambda fac.\;\left(\lambda  n.\;IF\left(=\;n\;0\right)\;1\;\left(*\;n\;\left(fac\;\left(-\;n\;1\right)\right)\right)\right)\right) FAC \nonumber
        \] 

         This definition has taken the form $FAC = g\;FAC$ where $g =
        \left(\lambda fac.\;\left(\lambda
        n.\;IF\left(=\;n\;0\right)\;1\;\left(*\;n\;\left(fac\;\left(-\;n\;1\right)\right)\right)\right)\right)$
        is without recursion. We see also that $FAC$ is a fixed point
        (&amp;quot;fixpoint&amp;quot;) of $g$. It is clear this fixed point can only
        depend on $g$ so supposing there were a function $Y$ which
        takes a function and delivers a fixpoint of the function as
        the result, we'd have $FAC = Y\;g = g\;(Y\;g)$. Under the
        assumption such a function exists, in order to build
        confidence this definition of $FAC$ works, we will try to
        compute $FAC\;1$. Recall

        \[
          \begin{eqnarray}
           &amp;amp;FAC&amp;amp; = Y\;g \nonumber \\
           &amp;amp;g&amp;amp; = \lambda fac.\;\left(\lambda n.\;IF\left(=\;n\;0\right)\;1\;\left(*\;n\;\left(fac\;\left(-\;n\;1\right)\right)\right)\right) \nonumber
          \end{eqnarray}
        \]

        So,

        \[
          \begin{eqnarray}
            FAC\;1 &amp;amp;\rightarrow&amp;amp; (Y\;g)\; 1 \nonumber \\
                   &amp;amp;\rightarrow&amp;amp; (g\;(Y\;g))\;1 \nonumber \\
                   &amp;amp;\rightarrow&amp;amp; (\left(\lambda fac.\;\left(\lambda n.\;IF\left(=\;n\;0\right)\;1\;\left(*\;n\;\left(fac\;\left(-\;n\;1\right)\right)\right)\right)\right) (Y\;g))\; 1 \nonumber \\
                   &amp;amp;\rightarrow&amp;amp; \left(\lambda n.\;IF\left(=\;n\;0\right)\;1\;\left(*\;n\;\left(\left(Y\;g\right)\;\left(-\;n\;1\right)\right)\right)\right)\; 1 \nonumber \\
                   &amp;amp;\rightarrow&amp;amp; *\;1\;\left(\left(Y\;g\right)\;0\right) \nonumber \\
                   &amp;amp;\rightarrow&amp;amp; *\;1\;\left(\left(g\;\left(Y\;g\right)\right)\;0\right) \nonumber \\
                   &amp;amp;\rightarrow&amp;amp; *\;1\;\left(\left(\left(\lambda fac.\;\left(\lambda n.\;IF\left(=\;n\;0\right)\;1\;\left(*\;n\;\left(fac\;\left(-\;n\;1\right)\right)\right)\right)\right)\;\left(Y\;g\right)\right)\;0\right) \nonumber \\
                   &amp;amp;\rightarrow&amp;amp; *\;1\;\left(\left(\lambda n.\;IF\left(=\;n\;0\right)\;1\;\left(*\;n\;\left(\left(Y\;g\right)\;\left(-\;n\;1\right)\right)\right)\right)\;0\right) \nonumber \\
                   &amp;amp;\rightarrow&amp;amp; *\;1\;1 \nonumber \\
                   &amp;amp;=&amp;amp; 1 \nonumber
          \end{eqnarray}
         \]

    &lt;/p&gt;

    &lt;p&gt;The $Y$ combinator of the $\lambda$-calculus is defined as the
        $\lambda$-term $Y = \lambda f.\;\left(\lambda
        x.\;f\;\left(x\;x\right)\right)\left(\lambda
        x.\;f\;\left(x\;x\right)\right)$.  $\beta$ reduction of this
        term applied to an arbitrary function $g$ proceeds like this:

        \[
          \begin{eqnarray} 
             Y\;g &amp;amp;\rightarrow&amp;amp; \left(\lambda f.\;\left(\lambda x.\;f\;\left(x\;x\right)\right) \left(\lambda x.\;f\;\left(x\;x\right)\right)\right)\;g  \nonumber \\
                  &amp;amp;\rightarrow&amp;amp; \left(\lambda x.\;g\;\left(x\;x\right)\right) \left(\lambda x.\;g\;\left(x\;x\right)\right) \nonumber \\ 
                  &amp;amp;\rightarrow&amp;amp; g\;\left(\left(\lambda x.\;g\;\left(x\;x\right)\right)\;\left(\lambda  x.\;g\;\left(x\;x\right)\right)\right) \nonumber \\
                  &amp;amp;=&amp;amp; g\;\left(Y\;g\right) 
           \end{eqnarray} 
         \]

        The application of this term has produced a fixpoint of
        $g$. That is, we are satisfied that this term will serve as a
        definition for $Y$ having the property we need and call it the
        &amp;quot;fixpoint combinator&amp;quot;.
    &lt;/p&gt;

    &lt;p&gt;In the untyped $\lambda$-calculus, $Y$ can be defined and that
       is sufficient for expressing all the functions that can be
       computed without having to add a special construction to get
       recursive functions. In typed $\lambda$-calculus, $Y$ cannot be
       defined as the term $\lambda x.\;f\;(x\;x)$ does not have a
       finite type. Thus, when implementing recursion in a functional
       programming language it is usual to implement $Y$ as a built-in
       function with the reduction rule $Y\;g \rightarrow g\;(Y\;g)$
       or, in a strict language, $(Y\; g)\;x \rightarrow
       (g\;(Y\;g))\;x$ to avoid infinite recursion.
    &lt;/p&gt;

    &lt;p&gt;For an OCaml like language, the idea then is to introduce a
       built-in constant $\mathbf{Y}$ and to denote the function
       defined by $\mathbf{let\;rec}\;f\;x = e$ as
       $\mathbf{Y}(\mathbf{fun}\;f\;x \rightarrow e)$. Intuitivly,
       $\mathbf{Y}$ is a fixpoint operator that associates a
       functional $F$ of type $\alpha \rightarrow \beta$ with a fixpoint $Y(F)$
       of type $\alpha \rightarrow \beta \rightarrow \alpha$, that is, a value having the property
       $\mathbf{Y}\;F = F\;\left(\mathbf{Y}\;F\right)$. The relevant
       deduction rules involving this constant are:

      \[
        \begin{equation}
          \frac{\vdash f\;(Y\;f)\;x \Rightarrow v}
            {\vdash (Y\;f)\;x \Rightarrow v} \tag{App-rec}
        \end{equation}
      \]

      \[
        \begin{equation}
          \frac{\vdash e_{2}\left[Y(\mathbf{fun}\;f\;x \rightarrow e_{1})/f\right] \Rightarrow v}
           {\vdash \mathbf{let\;rec}\;f\;x=e_{1}\;\mathbf{in}\;e_{2} \Rightarrow v} \nonumber \tag {Let-rec} 
        \end{equation}
      \]
    &lt;/p&gt;
    &lt;hr/&gt;
    &lt;p&gt;
      References:&lt;br/&gt;
      [1] &lt;cite&gt;The Implementation of Functional Programming Languages&lt;/cite&gt;,Simon Peyton Jones, 1987.&lt;br/&gt;
      [2] &lt;cite&gt;The Functional Approach to Programming&lt;/cite&gt;, Guy Cousineau, Michel Mauny, 1998.
    &lt;/p&gt;

</content><id>http://blog.shaynefletcher.org/2016/09/the-fixpoint-combinator.html</id><title type="text">The fixpoint combinator</title><updated>2016-09-27T15:38:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/09/custom-operators-in-ocaml.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">&lt;p&gt;
If like me, you've always been a little hazy on the rules for defining OCaml operators then, this little post might help!
&lt;/p&gt;
&lt;p&gt;
It is possible to &amp;quot;inject&amp;quot; user-defined operator syntax into OCaml programs. Here's how it works. First we define a set of characters called &amp;quot;symbol characters&amp;quot;.
&lt;/p&gt;

&lt;h2&gt;Symbol character (definition)&lt;/h2&gt;
&lt;p&gt;
A character that is one of 
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
! $ % &amp;amp; * + - . / : &amp;lt; = &amp;gt; ? @ ^ | ~
&lt;/pre&gt;


&lt;h2&gt;Prefix operators&lt;/h2&gt;

&lt;p&gt;
The &lt;code&gt;!&lt;/code&gt; (&amp;quot;bang&amp;quot;) prefix operator, has a predefined semantic as the operation of &amp;quot;de-referencing&amp;quot; a reference cell. A custom prefix operator can made by from a &lt;code&gt;!&lt;/code&gt; followed by one or more symbol characters.
&lt;/p&gt;

&lt;p&gt;
So, to give some examples, one can define prefix operators like &lt;code&gt;!!&lt;/code&gt;, &lt;code&gt;!~&lt;/code&gt; or even something as exotic as &lt;code&gt;!::&amp;gt;&lt;/code&gt;. For example, one might write something like
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let ( !+ ) x : int ref &amp;rarr; unit = incr x
&lt;/pre&gt;
as a syntactic sugar equivalent to &lt;code&gt;fun x &amp;rarr; incr x&lt;/code&gt;


&lt;p&gt;
Additionally, prefix operators can begin with one of &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; and, as in the case of &lt;code&gt;!&lt;/code&gt;, must be followed by one or more symbol characters. So, in summary, a prefix operator begins with one of 
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
! ~ ?
&lt;/pre&gt;
and is followed by one or more symbol characters.


&lt;p&gt;
For example &lt;code&gt;let ( ~! ) x = incr x&lt;/code&gt; defines an alternative syntax equivalent to the &lt;code&gt;!+&lt;/code&gt; operator presented earlier.
&lt;/p&gt;

&lt;p&gt;
Prefix operators have the highest possible precedence.
&lt;/p&gt;

&lt;h2&gt;Infix operators&lt;/h2&gt;
&lt;p&gt;
It is in fact possible to define operators in 5 different categories. What distinguish these categories from each other are their associativity and precedence properties.
&lt;/p&gt;
&lt;h3&gt;Level 0&lt;/h3&gt;
&lt;p&gt;
Level 0 operators are left associative with the same precedence as &lt;code&gt;=&lt;/code&gt;. A level 0 operator starts with one of
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
= &amp;lt; &amp;gt; | &amp;amp; $
&lt;/pre&gt;

and is followed by zero or more symbol chars. For example, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; is an operator much beloved by monadic programmers and &lt;code&gt;|&amp;gt;&lt;/code&gt; (pipe operator) is a builtin equivalent to &lt;code&gt;let ( |&amp;gt; ) x f = f x&lt;/code&gt;.


&lt;h3&gt;Level 1&lt;/h3&gt;
&lt;p&gt;
Level 1 operators are right associative, have a precedence just above &lt;code&gt;=&lt;/code&gt; and start with one of 
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
@ ^
&lt;/pre&gt;. That is, these operators are consistent with operations involving joining things. &lt;code&gt;@@&lt;/code&gt; (the &amp;quot;command&amp;quot; operator) of course has a predefined semantic as function
application, that is, equivalent to the definition &lt;code&gt;let ( @@ ) f x = f x&lt;/code&gt;.


&lt;h3&gt;Level 2&lt;/h3&gt;
&lt;p&gt;
Level 2 operators are left associative have a precedence level shared with &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; and indeed, are defined with a leading (one of)
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
+ -
&lt;/pre&gt;
and, as usual, followed by a sequence of symbol characters. These operators are consistent for usage with operations generalizing addition or difference like operations. Some potential operators of this kind are &lt;code&gt;+~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and so on.


&lt;h3&gt;Level 3&lt;/h3&gt;
&lt;p&gt;
Level 3 operators are also left associative and have a precedence level shared with &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;. Operators of this kind start with one of 
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
* / %
&lt;/pre&gt;
followed by zero or more symbol characters and are evocative of operations akin to multiplication, division. For example, &lt;code&gt;*~&lt;/code&gt; might make a good companion for &lt;code&gt;+~&lt;/code&gt; of the previous section.


&lt;h3&gt;Level 4&lt;/h3&gt;
&lt;p&gt;
Level 4 operators are right associative and have a precedence above &lt;code&gt;*&lt;/code&gt;. The level 4 operators begin with 
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
**
&lt;/pre&gt;
and are followed by zero or more symbol characters. The operation associated with &lt;code&gt;**&lt;/code&gt; is exponentiation (binds tight and associates to the right). The syntax &lt;code&gt;**~&lt;/code&gt; would fit nicely into the &lt;code&gt;+~&lt;/code&gt;, &lt;code&gt;*~&lt;/code&gt; set of the earlier sections.

</content><id>http://blog.shaynefletcher.org/2016/09/custom-operators-in-ocaml.html</id><title type="text">Custom operators in OCaml</title><updated>2016-09-20T20:08:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/08/perfectly-balanced-binary-search-trees.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">&lt;p&gt;
The type of &amp;quot;association tables&amp;quot; (binary search trees).
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
type (&amp;alpha;, &amp;beta;) t =
| Empty
| Node of (&amp;alpha; , &amp;beta;) t * &amp;alpha; * &amp;beta; * (&amp;alpha;, &amp;beta;) t * int
&lt;/pre&gt;
There are two cases : a tree that is empty or, a node consisting of a left sub-tree, a key, the value associated with that key, a right sub-tree and, an integer representing the &amp;quot;height&amp;quot; of the tree (the number of nodes to traverse before reaching the most distant leaf).

&lt;p&gt;The binary search tree invariant will be made to apply in that for any non empty tree $n$, every node in the left sub-tree is ordered less than $n$ and every node in the right sub-tree of $n$ is ordered greater than $n$ (in this program, ordering of keys is performed using the &lt;code&gt;Pervasives.compare&lt;/code&gt; function).
&lt;/p&gt;
&lt;p&gt;This function, &lt;code&gt;height&lt;/code&gt;, given a tree, extracts its height.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let height : (&amp;alpha;, &amp;beta;) t -&amp;gt; int = function
  | Empty -&amp;gt; 0
  | Node (_, _, _, _, h) -&amp;gt; h
&lt;/pre&gt;

&lt;p&gt;The value &lt;code&gt;empty&lt;/code&gt;, is a constant, the empty tree.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let empty : (&amp;alpha;, &amp;beta;) t = Empty
&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;create l x d r&lt;/code&gt; creates a new non-empty tree with left sub-tree &lt;code&gt;l&lt;/code&gt;, right sub-tree &lt;code&gt;r&lt;/code&gt; and the binding of key &lt;code&gt;x&lt;/code&gt; to the data &lt;code&gt;d&lt;/code&gt;. The height of the tree created is computed from the heights of the two sub-trees.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let create (l : (&amp;alpha;, &amp;beta;) t) (x : &amp;alpha;) (d : &amp;beta;) (r : (&amp;alpha;, &amp;beta;) t) : (&amp;alpha;, &amp;beta;) t =
  let hl = height l and hr = height r in
  Node (l, x, d, r, (max hl hr) + 1)
&lt;/pre&gt;

&lt;p&gt;This next function, &lt;code&gt;balance&lt;/code&gt; is where all the action is at. Like the preceding function &lt;code&gt;create&lt;/code&gt;, it is a factory function for interior nodes and so takes the same argument list as &lt;code&gt;create&lt;/code&gt;. It has an additional duty though in that the tree that it produces takes balancing into consideration.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let balance (l : (&amp;alpha;, &amp;beta;) t) (x : &amp;alpha;) (d : &amp;beta;) (r : (&amp;alpha;, &amp;beta;) t) : (&amp;alpha;, &amp;beta;) t =
  let hl = height l and hr = height r in
  if hl &amp;gt; hr + 1 then
    match l with
&lt;/pre&gt;
In this branch of the program, it has determined that production of a node with the given left and right sub-trees (denoted $l$ and $r$ respectively) would be unbalanced because $h(l) &amp;gt; hr(1) + 1$ (where $h$ denotes the height function).

&lt;p&gt;There are two possible reasons to account for this. They are considered in turn.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
    (*Case 1*)
    | Node (ll, lv, ld, lr, _) when height ll &amp;gt;= height lr -&amp;gt;
      create ll lv ld (create lr x d r)
&lt;/pre&gt;
So here, we find that $h(l) &amp;gt; h(r) + 1$, because of the height of the left sub-tree of $l$.
&lt;pre class=&quot;prettyprint ml&quot;&gt;
    (*Case 2*)
    | Node (ll, lv, ld, Node (lrl, lrv, lrd, lrr, _), _) -&amp;gt;
      create (create ll lv ld lrl) lrv lrd (create lrr x d r)
&lt;/pre&gt;
In this case, $h(l) &amp;gt; h(r) + 1$ because of the height of the right sub-tree of $l$.
&lt;pre class=&quot;prettyprint ml&quot;&gt;
    | _ -&amp;gt; assert false
&lt;/pre&gt;
We &lt;code&gt;assert false&lt;/code&gt; for all other patterns as we aim to admit by construction no further possibilities.

&lt;p&gt;We now consider the case $h(r) &amp;gt; h(l) + 1$, that is the right sub-tree being &amp;quot;too long&amp;quot;.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
  else if hr &amp;gt; hl + 1 then
    match r with
&lt;/pre&gt;

&lt;p&gt;There are two possible reasons.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
    (*Case 3*)
    | Node (rl, rv, rd, rr, _) when height rr &amp;gt;= height rl -&amp;gt;
      create (create l x d rl) rv rd rr
&lt;/pre&gt;
Here $h(r) &amp;gt; h(l) + 1$ because of the right sub-tree of $r$.
&lt;pre class=&quot;prettyprint ml&quot;&gt;
    (*Case 4*)
    | Node (Node (rll, rlv, rld, rlr, _), rv, rd, rr, _) -&amp;gt;
      create (create l x d rll) rlv rld (create rlr rv rd rr)
&lt;/pre&gt;
Lastly, $h(r) &amp;gt; h(l) + 1$ because of the left sub-tree of $r$.
&lt;pre class=&quot;prettyprint ml&quot;&gt;
    | _ -&amp;gt; assert false
&lt;/pre&gt;
Again, all other patterns are (if we write this program correctly according to our intentions,) impossible and so, &lt;code&gt;assert false&lt;/code&gt; as there are no further possibilities.

&lt;p&gt;In the last case, neither $h(l) &amp;gt; h(r) + 1$ or $h(r) &amp;gt; h(l) + 1$ so no rotation is required.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
  else
    create l x d r
&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;add x data t&lt;/code&gt; computes a new tree from &lt;code&gt;t&lt;/code&gt; containing a binding of &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;data&lt;/code&gt;. It resembles standard insertion into a binary search tree except that it propagates rotations through the tree to maintain balance after the insertion.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let rec add (x : &amp;alpha;) (data : &amp;beta;) : (&amp;alpha;, &amp;beta;) t -&amp;gt; (&amp;alpha;, &amp;beta;) t = function
    | Empty -&amp;gt; Node (Empty, x, data, Empty, 1)
    | Node (l, v, d, r, h) -&amp;gt;
      let c = compare x v in
      if c = 0 then
        Node (l, x, data, r, h)
      else if c &amp;lt; 0 then
        balance (add x data l) v d r
      else 
        balance l v d (add x data r)
&lt;/pre&gt;

&lt;p&gt;To implement removal of nodes from a tree, we'll find ourselves needing a function to &amp;quot;merge&amp;quot; two binary searchtrees $l$ and $r$ say where we can assume that all the elements of $l$ are ordered before the elements of $r$.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let rec merge (l : (&amp;alpha;, &amp;beta;) t) (r : (&amp;alpha;, &amp;beta;) t) : (&amp;alpha;, &amp;beta;) t = 
  match (l, r) with
  | Empty, t -&amp;gt; t
  | t, Empty -&amp;gt; t
  | Node (l1, v1, d1, r1, h1), Node (l2, v2, d2, r2, h2) -&amp;gt;
    balance l1 v1 d1 (balance (merge r1 l2) v2 d2 r2)
&lt;/pre&gt;
Again, rotations are propagated through the tree to ensure the result of the merge results in a balanced tree.

&lt;p&gt;With &lt;code&gt;merge&lt;/code&gt; available, implementing &lt;code&gt;remove&lt;/code&gt; becomes tractable.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let remove (id : &amp;alpha;) (t : (&amp;alpha;, &amp;beta;) t) : (&amp;alpha;, &amp;beta;) t = 
  let rec remove_rec = function
    | Empty -&amp;gt; Empty
    | Node (l, k, d, r, _) -&amp;gt;
      let c = compare id k in
      if c = 0 then merge l r else
        if c &amp;lt; 0 then balance (remove_rec l) k d r
        else balance l k d (remove_rec r) in
  remove_rec t
&lt;/pre&gt;

&lt;p&gt;The remaining algorithms below are &amp;quot;stock&amp;quot; algorithms for binary search trees with no particular consideration of balancing necessary and so we won't dwell on them here.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
let rec find (x : &amp;alpha;) : (&amp;alpha;, &amp;beta;) t -&amp;gt; &amp;beta; = function
  | Empty -&amp;gt;  raise Not_found
  | Node (l, v, d, r, _) -&amp;gt;
    let c = compare x v in
    if c = 0 then d
    else find x (if c &amp;lt; 0 then l else r)

let rec mem (x : &amp;alpha;) : (&amp;alpha;, &amp;beta;) t -&amp;gt; bool = function
  | Empty -&amp;gt; false
  | Node (l, v, d, r, _) -&amp;gt;
    let c = compare x v in
    c = 0 || mem x (if c &amp;lt; 0 then l else r)
    
let rec iter (f : &amp;alpha; -&amp;gt; &amp;beta; -&amp;gt; unit) : (&amp;alpha;, &amp;beta;) t -&amp;gt; unit = function
  | Empty -&amp;gt; ()
  | Node (l, v, d, r, _) -&amp;gt;
    iter f l; f v d; iter f r

let rec map (f : &amp;alpha; -&amp;gt; &amp;beta; -&amp;gt; &amp;gamma;) : (&amp;alpha;, &amp;beta;) t -&amp;gt; (&amp;alpha;, &amp;gamma;) t = function
  | Empty -&amp;gt; Empty
  | Node (l, k, d, r, h) -&amp;gt; 
    Node (map f l, k, f k d, map f r, h)

let rec fold (f : &amp;alpha; -&amp;gt; &amp;beta; -&amp;gt; &amp;gamma; -&amp;gt; &amp;gamma;) (m : (&amp;alpha;, &amp;beta;) t) (acc : &amp;gamma;) : &amp;gamma; =
  match m with
  | Empty -&amp;gt; acc
  | Node (l, k, d, r, _) -&amp;gt; fold f r (f k d (fold f l acc))

open Format

let print 
    (print_key : formatter -&amp;gt; &amp;alpha; -&amp;gt; unit)
    (print_data : formatter -&amp;gt; &amp;beta; -&amp;gt; unit)
    (ppf : formatter)
    (tbl : (&amp;alpha;, &amp;beta;) t) : unit =
  let print_tbl ppf tbl =
    iter (fun k d -&amp;gt; 
           fprintf ppf &amp;quot;@[&amp;lt;2&amp;gt;%a -&amp;gt;@ %a;@]@ &amp;quot; print_key k print_data d)
      tbl in
  fprintf ppf &amp;quot;@[&lt;hv&gt;[[%a]]@]&amp;quot; print_tbl tbl
&lt;/hv&gt;&lt;/pre&gt;
&lt;p&gt;The source code for this post can be found in the file 'ocaml/misc/tbl.ml' in the OCaml source distribution. More information on balanced binary search trees including similar but different implementation techniques and complexity analyses can be found in &lt;a href=&quot;https://www.cs.cornell.edu/courses/cs3110/2009sp/lectures/lec11.html&quot;&gt;this Cornell lecture&lt;/a&gt; and &lt;a href=&quot;http://www.cs.cornell.edu/courses/cs3110/2008fa/lectures/lec20.html&quot;&gt;this one&lt;/a&gt;.
&lt;/p&gt;
</content><id>http://blog.shaynefletcher.org/2016/08/perfectly-balanced-binary-search-trees.html</id><title type="text">Balanced binary search trees</title><updated>2016-08-27T13:18:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/06/generic-mappings-over-pairs.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">&lt;h2&gt;&lt;/h2&gt;
&lt;p&gt;Browsing around on &lt;a href=&quot;http://okmij.org/ftp/&quot;&gt;Oleg Kiselyov's&lt;/a&gt; excellent site, I came across a very interesting paper about &amp;quot;&lt;a href=&quot;http://okmij.org/ftp/Computation/extra-polymorphism.html&quot;&gt;Advanced Polymorphism in Simpler-Typed Languages&lt;/a&gt;&amp;quot;. One of the neat examples I'm about to present is concerned with expressing mappings over pairs that are generic not only in the datatypes involved but also over the number of arguments. The idea is to produce a family of functions $pair\_map_{i}$ such that
&lt;/p&gt;&lt;pre&gt;
pair_map_1 f g (x, y) (x', y') &amp;rarr; (f x, g y) 
pair_map_2 f g (x, y) (x', y') &amp;rarr; (f x x', g y y') 
pair_map_3 f g (x, y) (x', y') (x'', y'', z'') &amp;rarr; (f x x' x'', g y y' y'')
       .
       .
       .
&lt;/pre&gt;
The technique used to achieve this brings a whole bunch of functional programming ideas together : higher order functions, combinators and continuation passing style (and also leads into topics like the &amp;quot;value restriction&amp;quot; typing rules in the Hindley-Milner system).
&lt;pre class=&quot;prettyprint ml&quot;&gt;
let ( ** ) app k = fun x y -&amp;gt; k (app x y)
let pc k a b = k (a, b)
let papp (f1, f2) (x1, x2) = (f1 x1, f2 x2)
let pu x = x
&lt;/pre&gt;
With the above definitions, $pair\_map_{i}$ is generated like so.
&lt;pre class=&quot;prettyprint ml&quot;&gt;
(*The argument [f] in the below is for the sake of value restriction*)
let pair_map_1 f = pc (papp ** pu) (f : &amp;alpha; -&amp;gt; &amp;beta;)
let pair_map_2 f = pc (papp ** papp ** pu) (f : &amp;alpha; -&amp;gt; &amp;beta; -&amp;gt; &amp;gamma;)
let pair_map_3 f = pc (papp ** papp ** papp ** pu) (f : &amp;alpha; -&amp;gt; &amp;beta; -&amp;gt; &amp;gamma; -&amp;gt; &amp;delta;)
&lt;/pre&gt;
For example,
&lt;pre&gt;
# pair_map_2 ( + ) ( - ) (1, 2) (3, 4) ;;
- : int * int = (4, -2)
&lt;/pre&gt;

&lt;p&gt;Reverse engineering how this works requires a bit of algebra.
&lt;/p&gt;
&lt;p&gt;Let's tackle $pair\_map_{1}$. First
&lt;/p&gt;&lt;pre&gt;
pc (papp ** pu) = (&amp;lambda;k f g. k (f, g)) (papp ** pu) = &amp;lambda;f g. (papp ** pu) (f, g)
&lt;/pre&gt;
and,
&lt;pre&gt;
papp ** pu = &amp;lambda;x y. pu (papp x y) = &amp;lambda;x y. papp x y
&lt;/pre&gt;
so,
&lt;pre&gt;
&amp;lambda;f g. (papp ** pu) (f, g) =
    &amp;lambda;f g. (&amp;lambda;(a, b) (x, y). (a x, b y)) (f, g) =
    &amp;lambda;f g (x, y). (f x, g y)
&lt;/pre&gt;
that is,
&lt;code&gt;pair_map_1 = pc (papp ** pu) = &amp;lambda;f g (x, y). (f x, g y)&lt;/code&gt; and, we can read the type off from that last equation as &lt;code&gt;(&amp;alpha; &amp;rarr; &amp;beta;) &amp;rarr; (&amp;gamma; &amp;rarr; &amp;delta;) &amp;rarr; &amp;alpha; * &amp;gamma; &amp;rarr; &amp;beta; * &amp;delta;&lt;/code&gt;.

&lt;p&gt;Now for $pair\_map_{2}$. We have
&lt;/p&gt;&lt;pre&gt;
pc (papp ** papp ** pu) =
    (&amp;lambda;k f g. k (f, g)) (papp ** papp ** pu) =
    &amp;lambda;f g. (papp ** papp ** pu) (f, g)
&lt;/pre&gt;
where,
&lt;pre&gt;
papp ** papp ** pu = papp ** (papp ** pu) =
    papp ** (&amp;lambda;a' b'. pu (papp a' b')) =
    papp ** (&amp;lambda;a' b'. papp a' b') = 
    &amp;lambda;a b. (&amp;lambda;a' b'. papp a' b') (papp a b)
&lt;/pre&gt;
which means,
&lt;pre&gt;
pc (papp ** papp ** pu) = 
    &amp;lambda;f g. (papp ** papp ** pu) (f, g) =
    &amp;lambda;f g. (&amp;lambda;a b.(&amp;lambda;a' b'. papp a' b') (papp a b)) (f, g) =
    &amp;lambda;f g. (&amp;lambda;b. (&amp;lambda;a' b'. papp a' b') (papp (f, g) b)) =
    &amp;lambda;f g. &amp;lambda;(x, y). &amp;lambda;a' b'. (papp a' b') (papp (f, g) (x, y)) =
    &amp;lambda;f g. &amp;lambda;(x, y). &amp;lambda;a' b'. (papp a' b') (f x, g y) =
    &amp;lambda;f g. &amp;lambda;(x, y). &amp;lambda;b'. papp (f x, g y) b' =
    &amp;lambda;f g. &amp;lambda;(x, y). &amp;lambda;(x', y'). papp (f x, g y) (x', y') =
    &amp;lambda;f g (x, y) (x', y'). (f x x', g y y')
&lt;/pre&gt;
that is, a function in two binary functions and two pairs as we expect. Phew! The type in this instance is &lt;code&gt;(&amp;alpha; &amp;rarr; &amp;beta; &amp;rarr; &amp;gamma;) &amp;rarr; (&amp;delta; &amp;rarr; &amp;epsilon; &amp;rarr; &amp;zeta;) &amp;rarr; &amp;alpha; * &amp;delta; &amp;rarr; &amp;beta; * &amp;epsilon; &amp;rarr; &amp;gamma; * &amp;zeta;&lt;/code&gt;.

&lt;p&gt;
To finish off, here's the program transliterated into C++(14).
&lt;/p&gt;&lt;pre class=&quot;prettyprint c++&quot;&gt;
#include &amp;lt;utility&amp;gt;
#include &amp;lt;iostream&amp;gt;

//let pu x = x
auto pu = [](auto x) { return x; };

//let ( ** ) app k  = fun x y -&amp;gt; k (app x y)
template &amp;lt;class F, class K&amp;gt;
auto operator ^ (F app, K k) {
  return [=](auto x) {
    return [=] (auto y) {
      return k ((app (x)) (y));
    };
  };
}

//let pc k a b = k (a, b)
auto pc = [](auto k) {
  return [=](auto a) {
    return [=](auto b) { 
      return k (std::make_pair (a, b)); };
  };
};

//let papp (f, g) (x, y) = (f x, g y)
auto papp = [](auto f) { 
  return [=](auto x) { 
    return std::make_pair (f.first (x.first), f.second (x.second)); };
};

int main () {

  auto pair = &amp;amp;std::make_pair&amp;lt;int, int&amp;gt;;

  {
  auto succ= [](int x){ return x + 1; };
  auto pred= [](int x){ return x - 1; };
  auto p  = (pc (papp ^ pu)) (succ) (pred) (pair (1, 2));
  std::cout &amp;lt;&amp;lt; p.first &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; p.second &amp;lt;&amp;lt; std::endl;
  }

  {
  auto add = [](int x) { return [=](int y) { return x + y; }; };
  auto sub = [](int x) { return [=](int y) { return x - y; }; };
  auto p = pc (papp ^ papp ^ pu) (add) (sub) (pair(1, 2)) (pair (3, 4));
  std::cout &amp;lt;&amp;lt; p.first &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; p.second &amp;lt;&amp;lt; std::endl;
  }

  return 0;
}
&lt;/pre&gt;

</content><id>http://blog.shaynefletcher.org/2016/06/generic-mappings-over-pairs.html</id><title type="text">Generic mappings over pairs</title><updated>2016-06-17T19:39:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/04/oh-pascal.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">&lt;p&gt;
I can't help but want to share my joy at coming across this pearl of a program from the &amp;quot;Pascal User Manual and Report&amp;quot; - Jensen and Wirth (circa 1974). In my edition, it's program 4.7 (graph1.pas).
&lt;/p&gt;
&lt;p&gt;
This is it, rephrased in OCaml.
&lt;/p&gt;&lt;pre class=&quot;prettyprint ml&quot;&gt;
(* Graph of f x = exp (-x) * sin (2 * pi * x)

  Program 4.7, Pascal User Manual and Report, Jensen &amp;amp; Wirth
*)

let round (x : float) : int =
  let f, i = 
    let t = modf x in 
    (fst t, int_of_float@@ snd t) in
  if f = 0.0 then i
  else if i &amp;gt;= 0 then
    if f &amp;gt;= 0.5 then i + 1 else i
  else if -.f &amp;gt;= 0.5 then i - 1 else i

let graph (oc : out_channel) : unit =
  (*The x-axis runs vertically...*)
  let s = 32. in (*32 char widths for [y, y + 1]*)
  let h = 34 in (*char position of x-axis*)
  let d = 0.0625 in (*1/16, 16 lines for [x, x + 1]*)
  let c = 6.28318 in (* 2pi *)
  let lim = 32 in
  for i = 0 to lim do
    let x = d *. (float_of_int i) in
    let y = exp (-.x) *. sin (c *. x) in
    let n = round (s *. y) + h in
    for _ = n downto 0 do output_char oc ' '; done;
    output_string oc &amp;quot;*\n&amp;quot;
  done

let () = print_newline (); graph stdout; print_newline ()
&lt;/pre&gt;

&lt;p&gt;The output from the above is wonderful :)
&lt;/p&gt;&lt;pre&gt;
                                   *
                                               *
                                                       *
                                                            *
                                                            *
                                                         *
                                                   *
                                           *
                                   *
                            *
                       *
                    *
                    *
                      *
                          *
                              *
                                   *
                                       *
                                          *
                                            *
                                            *
                                           *
                                         *
                                      *
                                   *
                                *
                               *
                              *
                             *
                              *
                                *
                                 *
                                   *
&lt;/pre&gt;
</content><id>http://blog.shaynefletcher.org/2016/04/oh-pascal.html</id><title type="text">Oh! Pascal!</title><updated>2016-04-21T15:31:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/04/dictionaries-as-functions.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">&amp;amp;#60;h2&amp;amp;#62;&amp;amp;#60;/h2&amp;amp;#62;
&amp;amp;#60;p&amp;amp;#62;
This is an &amp;amp;#34;oldie but a goodie&amp;amp;#34;. It's super easy.
&amp;amp;#60;/p&amp;amp;#62;
&amp;amp;#60;p&amp;amp;#62;
A dictionary is a data structure that represents a map from keys to values. The question is, can this data structure and its characteristic operations be encoded using only functions?
&amp;amp;#60;/p&amp;amp;#62;
&amp;amp;#60;p&amp;amp;#62;
The answer of course is yes and indeed, here's one such an encoding in OCaml.
&amp;amp;#60;p&amp;amp;#62;
&amp;amp;#60;pre class=&amp;amp;#34;prettyprint ml&amp;amp;#34;&amp;amp;#62;
(*The type of a dictionary with keys of type [&amp;amp;#38;alpha;] and values of type
  [&amp;amp;#38;beta;]*)
type (&amp;amp;#38;alpha;, &amp;amp;#38;beta;) dict = &amp;amp;#38;alpha; -&amp;amp;#62; &amp;amp;#38;beta; option

(*The empty dictionary maps every key to [None]*)
let empty (k : &amp;amp;#38;alpha;) : &amp;amp;#38;beta; option = None

(*[add d k v] is the dictionary [d] together with a binding of [k] to
  [v]*)
let add (d : (&amp;amp;#38;alpha;, &amp;amp;#38;beta;) dict) (k : &amp;amp;#38;alpha;) (v : &amp;amp;#38;beta;) : (&amp;amp;#38;alpha;, &amp;amp;#38;beta;) dict = 
  fun l -&amp;amp;#62; 
    if l = k then Some v else d l

(*[find d k] retrieves the value bound to [k]*)
let find (d : (&amp;amp;#38;alpha;, &amp;amp;#38;beta;) dict) (k : &amp;amp;#38;alpha;) : &amp;amp;#38;beta; option = d k
&amp;amp;#60;/pre&amp;amp;#62;
Test it like this.
&amp;amp;#60;pre class=&amp;amp;#34;prettyprint ml&amp;amp;#34;&amp;amp;#62;
(*e.g.

  Name                            &amp;amp;#38;#124; Age
  ================================+====
  &amp;amp;#34;Felonius Gru&amp;amp;#34;                  &amp;amp;#38;#124;  53
  &amp;amp;#34;Dave the Minion&amp;amp;#34;               &amp;amp;#38;#124; 4.54e9
  &amp;amp;#34;Dr. Joseph Albert Nefario&amp;amp;#34;     &amp;amp;#38;#124;  80

*)
let despicable = 
  add 
    (add 
       (add 
          empty &amp;amp;#34;Felonius Gru&amp;amp;#34; 53
       ) 
       &amp;amp;#34;Dave the Minion&amp;amp;#34; (int_of_float 4.54e9)
    )
    &amp;amp;#34;Dr. Nefario&amp;amp;#34; 80 

let _ = 
  find despicable &amp;amp;#34;Dave the Minion&amp;amp;#34; &amp;amp;#38;#124;&amp;amp;#62; 
      function &amp;amp;#38;#124; Some x -&amp;amp;#62; x &amp;amp;#38;#124; _ -&amp;amp;#62; failwith &amp;amp;#34;Not found&amp;amp;#34;
&amp;amp;#60;/pre&amp;amp;#62;
&amp;amp;#60;/p&amp;amp;#62;
&amp;amp;#60;p&amp;amp;#62;Moving on, can we implement this in C++? Sure. Here's one way.
&amp;amp;#60;pre class=&amp;amp;#34;prettyprint ml&amp;amp;#34;&amp;amp;#62;
#include &amp;amp;#38;lt;pgs/pgs.hpp&amp;amp;#38;gt;

#include &amp;amp;#38;lt;functional&amp;amp;#38;gt;
#include &amp;amp;#38;lt;iostream&amp;amp;#38;gt;
#include &amp;amp;#38;lt;cstdint&amp;amp;#38;gt;

using namespace pgs;

// -- A rough and ready `'a option` (given the absence of
// `std::experimental::optional`

struct None {};

template &amp;amp;#38;lt;class A&amp;amp;#38;gt;
struct Some { 
  A val;
  template &amp;amp;#38;lt;class Arg&amp;amp;#38;gt;
  explicit Some (Arg&amp;amp;#38;&amp;amp;#38; s) : val { std::forward&amp;amp;#38;lt;Arg&amp;amp;#38;gt; (s) }
  {}
};

template &amp;amp;#38;lt;class B&amp;amp;#38;gt;
using option = sum_type&amp;amp;#38;lt;None, Some&amp;amp;#38;lt;B&amp;amp;#38;gt;&amp;amp;#38;gt;;

template &amp;amp;#38;lt;class B&amp;amp;#38;gt;
std::ostream&amp;amp;#38; operator &amp;amp;#38;lt;&amp;amp;#38;lt; (std::ostream&amp;amp;#38; os, option&amp;amp;#38;lt;B&amp;amp;#38;gt; const&amp;amp;#38; o) {
  return o.match&amp;amp;#38;lt;std::ostream&amp;amp;#38;&amp;amp;#38;gt;(
    [&amp;amp;#38;](Some&amp;amp;#38;lt;B&amp;amp;#38;gt; const&amp;amp;#38; a) -&amp;amp;#38;gt; std::ostream&amp;amp;#38; { return os &amp;amp;#38;lt;&amp;amp;#38;lt; a.val; },
    [&amp;amp;#38;](None) -&amp;amp;#38;gt; std::ostream&amp;amp;#38; { return os &amp;amp;#38;lt;&amp;amp;#38;lt; &amp;amp;#34;&amp;amp;#38;lt;empty&amp;amp;#38;gt;&amp;amp;#34;; }
  );
}

//-- Encoding of dictionaries as functions

template &amp;amp;#38;lt;class K, class V&amp;amp;#38;gt;
using dict_type = std::function&amp;amp;#38;lt;option&amp;amp;#38;lt;V&amp;amp;#38;gt;(K)&amp;amp;#38;gt;;

//`empty` is a dictionary constant (a function that maps any key to
//`None`)
template &amp;amp;#38;lt;class A, class B&amp;amp;#38;gt;
dict_type&amp;amp;#38;lt;A, B&amp;amp;#38;gt; empty = 
  [](A const&amp;amp;#38;) { 
    return option&amp;amp;#38;lt;B&amp;amp;#38;gt;{ constructor&amp;amp;#38;lt;None&amp;amp;#38;gt;{} }; 
};

//`add (d, k, v)` extends `d` with a binding of `k` to `v`
template &amp;amp;#38;lt;class A, class B&amp;amp;#38;gt;
dict_type&amp;amp;#38;lt;A, B&amp;amp;#38;gt; add (dict_type&amp;amp;#38;lt;A, B&amp;amp;#38;gt; const&amp;amp;#38; d, A const&amp;amp;#38; k, B const&amp;amp;#38; v) {
  return [=](A const&amp;amp;#38; l) {
    return (k == l) ? option&amp;amp;#38;lt;B&amp;amp;#38;gt;{ constructor&amp;amp;#38;lt;Some&amp;amp;#38;lt;B&amp;amp;#38;gt;&amp;amp;#38;gt;{}, v} : d (l);
  };
}

//`find (d, k)` searches for a binding in `d` for `k`
template &amp;amp;#38;lt;class A, class B&amp;amp;#38;gt;
option&amp;amp;#38;lt;B&amp;amp;#38;gt; find (dict_type&amp;amp;#38;lt;A, B&amp;amp;#38;gt; const&amp;amp;#38; d, A const&amp;amp;#38; k) {
  return d (k);
}

//-- Test driver

int main () {

  using dict_t = dict_type&amp;amp;#38;lt;std::string, std::int64_t&amp;amp;#38;gt;;

  auto nil = empty&amp;amp;#38;lt;std::string, std::int64_t&amp;amp;#38;gt;;
  dict_t(*insert)(dict_t const&amp;amp;#38;, std::string const&amp;amp;#38;, std::int64_t const&amp;amp;#38;) = &amp;amp;#38;add;


  dict_t despicable = 
    insert (
      insert (
        insert (nil
           , std::string {&amp;amp;#34;Felonius Gru&amp;amp;#34;}, std::int64_t{53})
           , std::string {&amp;amp;#34;Dave the Minion&amp;amp;#34;}, std::int64_t{4530000000})
          , std::string {&amp;amp;#34;Dr. Joseph Albert Nefario&amp;amp;#34;}, std::int64_t{80})
     ;

  std::cout &amp;amp;#38;lt;&amp;amp;#38;lt; 
    find (despicable, std::string {&amp;amp;#34;Dave the Minion&amp;amp;#34;}) &amp;amp;#38;lt;&amp;amp;#38;lt; std::endl;

  return 0;
}
&amp;amp;#60;/pre&amp;amp;#62;
&amp;amp;#60;/p&amp;amp;#62;</content><id>http://blog.shaynefletcher.org/2016/04/dictionaries-as-functions.html</id><title type="text">Dictionaries as functions</title><updated>2016-04-13T16:58:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry><entry><link href="http://blog.shaynefletcher.org/2016/04/streams-in-c.html" rel="alternate"/><contributor><uri>http://blog.shaynefletcher.org/feeds/posts/default/-/OCaml</uri><name>sfletcher</name></contributor><content type="html">&lt;h2&gt;&lt;/h2&gt;
&lt;p&gt;
In &lt;a href=&quot;http://blog.shaynefletcher.org/2016/04/rotate.html&quot;&gt;this blog post&lt;/a&gt;, types and functions were presented in OCaml for modeling streams. This post takes the action to C++.
&lt;/p&gt;
&lt;p&gt;
First, the type definition for a stream.
&lt;/p&gt;&lt;pre class=&quot;prettyprint c++&quot;&gt;
struct Nil {};
template &amp;lt;class T&amp;gt; class Cons;

template &amp;lt;class T&amp;gt;
using stream = sum_type &amp;lt;
    Nil
  , recursive_wrapper&amp;lt;Cons&amp;lt;T&amp;gt;&amp;gt;
&amp;gt;;
&lt;/pre&gt;
The definition is in terms of the &lt;code&gt;sum_type&amp;lt;&amp;gt;&lt;/code&gt; type from the &amp;quot;pretty good sum&amp;quot; library talked about &lt;a href=&quot;http://blog.shaynefletcher.org/2015/11/c-sums-with-constructors.html&quot;&gt;here&lt;/a&gt;.

&lt;p&gt;The definition of &lt;code&gt;Cons&amp;lt;&amp;gt;&lt;/code&gt;, will be in terms of &amp;quot;thunks&amp;quot; (suspensions). They're modeled as procedures that when evaluated, compute streams.
&lt;/p&gt;&lt;pre class=&quot;prettyprint c++&quot;&gt;
template &amp;lt;class T&amp;gt;
using stream_thunk = std::function&amp;lt;stream&amp;lt;T&amp;gt;()&amp;gt;;
&lt;/pre&gt;
To complete the abstraction, a function that given a suspension, &amp;quot;thaws&amp;quot; it.
&lt;pre class=&quot;prettyprint c++&quot;&gt;
template &amp;lt;class T&amp;gt; inline 
stream&amp;lt;T&amp;gt; force (stream_thunk&amp;lt;T&amp;gt; const&amp;amp; s) { 
  return s (); 
}
&lt;/pre&gt;
&lt;p&gt;
The above choices made, here is the definition for &lt;code&gt;Cons&amp;lt;&amp;gt;&lt;/code&gt;.
&lt;/p&gt;&lt;pre class=&quot;prettyprint c++&quot;&gt;
template &amp;lt;class T&amp;gt;
class Cons {
public:
  using value_type = T;
  using reference = value_type&amp;amp;;
  using const_reference = value_type const&amp;amp;;
  using stream_type = stream&amp;lt;value_type&amp;gt;;

private:
  using stream_thunk_type = stream_thunk&amp;lt;value_type&amp;gt;;

public:
  template &amp;lt;class U, class V&amp;gt;
  Cons (U&amp;amp;&amp;amp; h, V&amp;amp;&amp;amp; t) : 
    h {std::forward&amp;lt;U&amp;gt; (h)}, t {std::forward&amp;lt;V&amp;gt; (t)}
  {}

  const_reference hd () const { return h; }
  stream_type tl () const { return force (t); }

private:
  value_type h;
  stream_thunk_type t;
};
&lt;/pre&gt;

&lt;p&gt;
Next, utility functions for working with streams.
&lt;/p&gt;
&lt;p&gt;
The function &lt;code&gt;hd ()&lt;/code&gt; gets the head of a stream and &lt;code&gt;tl ()&lt;/code&gt; gets the stream that remains when the head is stripped off.
&lt;/p&gt;&lt;pre class=&quot;prettyprint c++&quot;&gt;
template &amp;lt;class T&amp;gt;
T const hd (stream&amp;lt;T&amp;gt; const&amp;amp; s) {
  return s.template match&amp;lt;T const&amp;amp;&amp;gt; (
      [](Cons&amp;lt;T&amp;gt; const&amp;amp; l) -&amp;gt; T const&amp;amp; { return l.hd (); }
    , [](otherwise) -&amp;gt; T const &amp;amp; { throw std::runtime_error { &amp;quot;hd&amp;quot; }; }
  );
}

template &amp;lt;class T&amp;gt;
stream&amp;lt;T&amp;gt; tl (stream&amp;lt;T&amp;gt; const&amp;amp; l) {
  return l.template match &amp;lt;stream&amp;lt;T&amp;gt;&amp;gt; (
    [] (Cons&amp;lt;T&amp;gt; const&amp;amp; s) -&amp;gt; stream &amp;lt;T&amp;gt; { return s.tl (); }
  , [] (otherwise) -&amp;gt; stream&amp;lt;T&amp;gt; { throw std::runtime_error{&amp;quot;tl&amp;quot;}; }
  );
}
&lt;/pre&gt;
 
&lt;p&gt;
The function &lt;code&gt;take ()&lt;/code&gt; returns the the first $n$ values of a stream.
&lt;/p&gt;&lt;pre class=&quot;prettyprint c++&quot;&gt;
template &amp;lt;class T, class D&amp;gt;
D take (unsigned int n, stream &amp;lt;T&amp;gt; const&amp;amp; s, D dst) {
  return (n == 0) ? dst :
    s.template match&amp;lt;D&amp;gt;(
       [&amp;amp;](Nil const&amp;amp; _) -&amp;gt; D { return  dst; },
       [&amp;amp;](Cons&amp;lt;T&amp;gt; const&amp;amp; l) -&amp;gt; D { 
         return take (n - 1, l.tl (), *dst++ = l.hd ()); }
    );
}
&lt;/pre&gt;
&lt;p&gt;
It's time to share a little &amp;quot;hack&amp;quot; I picked up for writing infinite lists.
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;To start, forget about streams;&lt;/li&gt;
&lt;li&gt;Write your list using regular lists;&lt;/li&gt;
&lt;li&gt;Ignore the fact that it won't terminate;&lt;/li&gt;
&lt;li&gt;Rewrite in terms of Cons and convert the tail to a thunk.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
For example, in OCaml the (non-terminating!) code
&lt;/p&gt;&lt;pre&gt;
  let naturals = 
    let rec loop x = x :: loop (x + 1) in
  next 0
&lt;/pre&gt;
leads to this definition of the stream of natural numbers.
&lt;pre class=&quot;prettyprint ml&quot;&gt;
let naturals =
 let rec loop x = Cons (x, lazy (loop (x + 1))) in
loop 0
&lt;/pre&gt;

&lt;p&gt;
Putting the above to work, a generator for the stream of natural numbers can be written like this.
&lt;/p&gt;&lt;pre class=&quot;prettyprint c++&quot;&gt;
class natural_numbers_gen {
private:
  using int_stream = stream&amp;lt;int&amp;gt;;
    
private:
  int start;

private:
  int_stream from (int x) const {
    return int_stream{
      constructor&amp;lt;Cons&amp;lt;int&amp;gt;&amp;gt;{}, x, [=]() { return this-&amp;gt;from (x + 1); }
    };
  }
  
public:
  explicit natural_numbers_gen (int start) : start (start) 
  {}

  explicit operator int_stream() const { return from (start); }
};
&lt;/pre&gt;
The first $10$ (say) natural numbers can then be harvested like this.
&lt;pre class=&quot;prettyprint c++&quot;&gt;
std::vector&amp;lt;int&amp;gt; s;
take (10, stream&amp;lt;int&amp;gt; (natural_numbers_gen{0}), std::back_inserter (s));
&lt;/pre&gt;

&lt;p&gt;
The last example, a generator of the Fibonacci sequence. Applying the hack, start with the following OCaml code.
&lt;/p&gt;&lt;pre&gt;
  let fibonacci_numbers = 
    let rec fib a b = a :: fib b (a + b) in
    fib 0 1
&lt;/pre&gt;
The rewrite of this code into streams then leads to this definition.
&lt;pre class=&quot;prettyprint ml&quot;&gt;
let fibonnaci_sequence = 
  let rec fib a b = Cons (a, lazy (fib b (a + b))) in
fib 0 1
&lt;/pre&gt;
Finally, casting the above function into C++ yields the following.
&lt;pre class=&quot;prettyprint c++&quot;&gt;
class fibonacci_numbers_gen {
private:
  using int_stream = stream&amp;lt;int&amp;gt;;
    
private:
  int start;

private:
  int_stream loop (int a, int b) const {
    return int_stream{
      constructor&amp;lt;Cons&amp;lt;int&amp;gt;&amp;gt;{}, a, [=]() {return this-&amp;gt;loop (b, a + b); }
    };
  }
    
public:
  explicit fibonacci_numbers_gen () 
  {}

  explicit operator int_stream() const { return loop (0, 1); }
  };
&lt;/pre&gt;

</content><id>http://blog.shaynefletcher.org/2016/04/streams-in-c.html</id><title type="text">C++ : Streams</title><updated>2016-04-03T15:00:00-00:00</updated><author><name>Shayne Fletcher</name></author></entry></feed>