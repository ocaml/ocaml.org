---
title: Programming FPGAs using OCaml
description: Learn FPGA programming with OCaml using HardCaml.
url: https://anil.recoil.org/notes/fpgas-hardcaml
date: 2025-02-07T00:00:00-00:00
preview_image:
authors:
- Anil Madhavapeddy
source:
---

<p>With the vast amount of data we have these days for our <a href="https://anil.recoil.org/projects/plancomp">planetary computing</a> processing, it's naturally tempting to use more hardware offload. The obvious choice, GPGPUs, are not a great fit for the problem due to the difficulty of unlocking high data parallelism for geospatial data. So it's back to an old technology I worked on <a href="https://anil.recoil.org/papers/2011-fccm-cloudfpga">twelve years ago</a> in the form of <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGAs</a>!</p>
<p>FPGAs are a very flexible way to execute boolean combinatorial logic, but are notoriously difficult to program. We have two possible angles to explore to address this. One is to design more declarative DSLs for data processing that compile to the FPGAs, such as <a href="https://mynameismwd.org" class="contact">Michael Dales</a> work on <a href="https://github.com/quantifyearth/yirgacheffe">Yirgacheffe</a> or <a href="https://github.com/omarathon" class="contact">Omar Tanner</a>'s work on in-memory <a href="https://anil.recoil.org/ideas/compressive-geospatial">compressive computation</a>.  The other angle is to work on the low-level API to programming the FPGAs, to get away from <a href="https://danluu.com/why-hardware-development-is-hard/">Verilog</a> and program in our favourite high-level language...OCaml!  <a href="https://kcsrk.info" class="contact">KC Sivaramakrishnan</a> and I have started making a list of resources for programming FPGAs in OCaml for our own education.</p>
<p>HardCaml was originally a side project by <a href="https://www.ujamjar.com">Andy Ray</a>. He gave a great presentation about it at <a href="https://www.ujamjar.com/presentations/orconf2015.html">ORConf 2015</a>. Later on in the project's lifecycle, he moved it to being maintained by <a href="https://janestreet.com">Jane Street</a>, where is used in production and is <a href="https://github.com/janestreet/hardcaml">open source</a>.  The first two resources to learn about HardCaml are to listen to the <a href="https://www.youtube.com/watch?v=GJX5VbKvh90">Signals and Threads episode with Andy</a>, and then to <a href="https://arxiv.org/pdf/2312.15035">read the 2023 paper</a>:</p>
<blockquote>
<p>Unlike high level synthesis (HLS), Hardcaml allows for low level control of the underlying hardware for maximum productivity, while abstracting away many of the tedious aspects of traditional hardware definition languages (HDLs) such as Verilog or VHDL. The richness of OCaml’s type system combined with Hardcaml’s fast circuit elaboration checks reduces the chance of user-introduced bugs and erroneous connections with features like custom type defining, type-safe parameterized modules and elaboration-time bit-width inference and validation.</p>
<p>Hardcaml tooling emphasizes fast feedback through simulation, testing, and verification. It includes both a native OCaml cycle-accurate and an event-driven simulator. Unit tests can live in the source code and include digital ASCII waveforms representing the simulator’s output. Hardcaml also provides tools for SAT proving and formal verification. Hardcaml is industrially proven, and has been used at Jane Street internally for many large FPGA designs.</p>
</blockquote>
<p>Let's look at the <a href="https://github.com/janestreet/hardcaml">source code repository</a> next to see some more code.
HardCaml is easily installable via <a href="https://opam.ocaml.org">opam</a>, so there appears to be few barriers to getting the software up and running. For the development lifecycle, there are a few other packages to ease the interfacing with the FPGA hardware:</p>
<ul>
<li><a href="https://github.com/janestreet/hardcaml_waveterm">Hardcaml_waveterm</a> is a terminal-based digital waveform viewer. These are usable in <a href="https://dev.realworldocaml.org/testing.html">expect tests</a> or from an interactive terminal application. I love a good terminal user interface, particularly now that I've shifted to <a href="https://ghostty.org/">Ghostty</a> with extremely good UTF-8 and colour support, so this is a very good sign.</li>
<li><a href="https://github.com/janestreet/hardcaml_c">Hardcaml_c</a> then converts a Hardcaml design over to C, where it can be compiled into a cycle-accurate simulation model and <a href="https://github.com/janestreet/hardcaml_verilator">Hardcaml_verilator</a> does the same except for the open-source <a href="https://www.veripool.org/verilator/">verilator</a> Verilog emulator.</li>
</ul>
<p>Let's look at some examples. There is a <a href="https://github.com/janestreet/hardcaml_circuits">hardcaml_circuits</a> repository with some interesting designs in HardCaml. Picking some at random:</p>
<ul>
<li>There's a <a href="https://github.com/janestreet/hardcaml_circuits/blob/master/src/sorting_network.mli">sorting network</a> that arranges a fixed configuration of compare-and-swaps to sort data. The network's structure is static (so it can be implemented easily in hardware), but the library abstracts its implementation to allow plugging in different compare-and-swap and data structures.  Looking at the OCaml interface, it's an <a href="https://dev.realworldocaml.org/functors.html">OCaml functor</a> over the compare-and-swap function, and has implementations in the module for a <a href="https://github.com/janestreet/hardcaml_circuits/blob/master/src/sorting_network.ml#L140">merge sort</a> and a <a href="https://github.com/janestreet/hardcaml_circuits/blob/master/src/sorting_network.ml#L65">bitonic merge</a>. This is already quite instructive to compare vs a software implementation, as for my <a href="https://anil.recoil.org/notes/focs">Foundations of CS</a> course where I teach <a href="https://www.cl.cam.ac.uk/teaching/2324/FoundsCS/slides/FoCS-202324-5.pdf">merge strategies</a> quite early on.</li>
<li>For floating point calculations, we generally do <a href="https://www.allaboutcircuits.com/technical-articles/an-introduction-to-the-cordic-algorithm/">CORDIC</a> algorithms which perform vector rotations iteratively to solve trig functions.  The <a href="https://github.com/janestreet/hardcaml_circuits/blob/master/src/cordic_reference.mli">cordic.mli</a> interface here is very readable, with nice use of OCaml features such as <a href="https://dev.realworldocaml.org/variants.html#variants">algebraic data types</a> to express the equations themselves. The implementation of <a href="https://github.com/janestreet/hardcaml_circuits/blob/master/src/cordic_reference.ml#L97-L101">arctan</a> shows how elegantly the OCaml implementation expresses the CORDIC equation as a higher level function.</li>
</ul>
<h2>Is HardCaml worth learning?</h2>
<p>I was curious to see what HardCaml's been used for recently. Most notably, it took home awards at the <a href="https://zprize.hardcaml.com/">ZPrize</a> in 2022, winning the multi-scalar multiplication track. So this thing is right up there with other HDLs in terms of producing high performing circuits!</p>
<p>There are two good blog posts about each of the implementations:</p>
<ul>
<li>The <a href="https://zprize.hardcaml.com/msm-overview.html">multi-scalar multiplication post</a> looks to multiply 2<sup>26</sup> points on the <a href="https://neuromancer.sk/std/bls/BLS12-377">BLS12-377</a> <a href="https://en.wikipedia.org/wiki/Elliptic_curve">elliptic curve</a> by scalars from the associated 253-bit scalar field and add them all as fast as possible.  This is difficult as the full set of transforms can't fit within a single FPGA's RAM, and so needs to call out to the host DRAM.  There's an <a href="https://dl.acm.org/doi/10.1145/3626202.3637577">paper</a> with all the details on the evaluation, which was done on an <a href="https://fpga-development-on-ec2.workshop.aws/en/4-f1-application-development-flow/introduction-to-f1-development-environment.html">Amazon F1</a> FPGA instance.</li>
<li>The <a href="https://zprize.hardcaml.com/ntt-overview.html">number-theoretic transform post</a> describes what's going on there as something similar to fourier transforms but working over a <a href="https://en.wikipedia.org/wiki/Finite_field">Galois field</a>. An extremely cool <a href="https://zprize.hardcaml.com/apps/ntt/ntt-core-with-rams-app">web based interaction visualisation</a> allows you to step through the NTT implementation.
They used an <a href="https://www.amd.com/en/products/accelerators/alveo.html">AMD Alveo</a> for this; I think that team are formerly Xilinx and based locally here in Cambridge!</li>
</ul>
<p></p><figure class="image-center"><img src="https://anil.recoil.org/images/hardcaml-webterm-1.webp" loading="lazy" class="content-image" alt="The web-based waveform view for the NTT transformer" srcset="/images/hardcaml-webterm-1.1024.webp 1024w,/images/hardcaml-webterm-1.1280.webp 1280w,/images/hardcaml-webterm-1.1440.webp 1440w,/images/hardcaml-webterm-1.1600.webp 1600w,/images/hardcaml-webterm-1.1920.webp 1920w,/images/hardcaml-webterm-1.2560.webp 2560w,/images/hardcaml-webterm-1.320.webp 320w,/images/hardcaml-webterm-1.480.webp 480w,/images/hardcaml-webterm-1.640.webp 640w,/images/hardcaml-webterm-1.768.webp 768w" title="The web-based waveform view for the NTT transformer" sizes="(max-width: 768px) 100vw, 33vw"><figcaption>The web-based waveform view for the NTT transformer</figcaption></figure>
<p></p>
<p>More relevantly to my interested in geospatial processing, there is a <a href="https://github.com/hardcamls/video-coding/tree/main/jpeg">JPEG decoder in HardCaml</a> which looks rather exciting. It implements the <a href="https://stackoverflow.com/questions/26523504/what-is-the-baseline-architecture-of-jpeg">JPEG baseline profile</a> with arbitrary huffman tables for encoding, along with a more work-in-progress decoder. A <a href="https://github.com/geocaml/ocaml-tiff">GeoTIFF</a> implementation would be a fun starter project to port to HardCaml!</p>
<h2>Some ideas for student projects</h2>
<p>Moving on from prizes, there is also a <a href="https://github.com/askvortsov1/hardcaml-mips">MIPS processor in HardCaml</a> designed by a couple of students at <a href="https://www.psu.edu/">Penn State</a>. They've also written a series of great <a href="https://ceramichacker.com/blog/34-1412-hardcaml-mips-and-io">blog posts</a> about their adventures in learning HardCaml as students.</p>
<p><a href="https://toao.com" class="contact">Sadiq Jaffer</a> and I have also been discussing the possibility of using <a href="https://anil.recoil.org/ideas/computational-storage-for-vector-dbs">computational SSDs to accelerate vector databases</a>, which would be a game-changer for the <a href="https://anil.recoil.org/projects/rsn">huge datasets</a> we're throwing around at the moment.</p>
<p>I'm going to continue to explore this further, and will update this note with any more resources I found. Please do send me any ideas you might have! <em>(Update 2025/02/07):</em> Immediately after <a href="https://amok.recoil.org/@avsm/113962272067656593">posting</a> this, two interesting responses came up:</p>
<ul>
<li><a href="https://github.com/edwintorok">Török Edwin</a> from the <a href="https://anil.recoil.org/projects/xen">Xen</a> team <a href="https://amok.recoil.org/@edwintorok@discuss.systems/113962395735439060">reports</a> that he experimented with <a href="https://tinytapeout.com/runs/ttihp0p2/tt_um_edwintorok">TinyTapeout</a> in HardCaml to implement a raytracer:</li>
</ul>
<blockquote>
<p>The VGA controller is <a href="https://github.com/edwintorok/roundingerror-ihp/blob/main/src/generator/vga.ml">here</a> and the hardcaml output works nicely with yosys and open lane tooling and verilator. So far it seems to work in simulation and on an FPGA (output <a href="https://www.youtube.com/watch?v=K9mu3getxhU&amp;t=42s">recording video</a>, see bottom of <a href="https://tinytapeout.com/competitions/demoscene-tt08-entries/">this</a> on how it got recorded).</p>
<p>Yet to find out whether it'll work in a physical chip (they say the tape out will be done in April). I particularly like the waveforms in source code for unit test (see the above VGA example).</p>
</blockquote>
<ul>
<li>My colleague <a href="https://albert.rierol.net/">Albert Cordona</a> works on analysing the <a href="https://www.science.org/doi/full/10.1126/science.add9330">connectomes of insect brains</a> (among other brains), which involves a lot of image processing over vast datasets as well.  I <a href="https://amok.recoil.org/@avsm/113962390567495016">pointed</a> him at an <a href="https://hackaday.io/project/27550-the-hobbyists-guide-to-fpgas">FPGA overview</a>; any other good beginner "FPGA for programmers" ones I could also use?</li>
</ul>
<p>Thanks also to <a href="https://ujamjar.com">Andy Ray</a> and <a href="https://anil.recoil.org/news.xml" class="contact">Andrew W. Moore</a> for feedback and corrections to this post.</p>

