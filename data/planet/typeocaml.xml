<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>http://typeocaml.com/rss/</id><title type="text">typeocaml</title><updated>2023-06-07T05:45:51-00:00</updated><entry><link href="http://typeocaml.com/2017/10/19/pearl-no-4-double-binary-search/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2017/10/cube-2-1.jpg#hero&quot; alt=&quot;hero&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Here is the Pearl No.4:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Let A and B be two disjoint ordered collections with distinct elements inside. Their combined size is greater than k. &lt;/p&gt;
  
  &lt;ol&gt;
  &lt;li&gt;A and B are sorted, but the underlying data structures are not specified as they are collections.&lt;/li&gt;
  &lt;li&gt;A and B do not have common elements, since they are &lt;em&gt;disjoint&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;All elements in A and B are distinct&lt;/li&gt;
  &lt;li&gt;The total number of all elements is larger than k&lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;&lt;strong&gt;Find the kth smallest element of A &amp;cup; B.&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;By definition, the kth smallest element of a collection is one for which there are exactly k elements smaller than it, so the 0th smallest is the smallest, i.e., &lt;strong&gt;k starts from 0&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let's have a look at an example.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/12/example-4.jpg&quot; alt=&quot;example&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;Easy Solution - Merge&lt;/h1&gt;

&lt;p&gt;I believe it is easy enough to come out with the &lt;strong&gt;merge&lt;/strong&gt; solution. Since both A and B are sorted, we can just start from the beginning of A and B and do the regular &lt;a href=&quot;http://typeocaml.com/2014/12/04/recursion-reloaded/&quot;&gt;merge operation&lt;/a&gt; until we reach &lt;code&gt;kth&lt;/code&gt;. (In fact, when I tried to produce the example figure above with &lt;code&gt;k = 7&lt;/code&gt;, I did use &lt;em&gt;merge&lt;/em&gt; in my head to find the target element &lt;code&gt;36&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Say A and B are &lt;em&gt;lists&lt;/em&gt;, we can have the following solution in OCaml:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let kth_merge a b k =  
  let rec merge i = function
    | x::_, y::_ when i = k -&amp;gt; min x y
    | m::_, [] | [], m::_ when i = k -&amp;gt; m
    | _::ms, [] | [], _::ms when i &amp;lt; k -&amp;gt; merge (i+1) ([], ms)
    | x::xs, y::ys when i &amp;lt; k -&amp;gt; 
      merge (i+1) (if x &amp;lt; y then xs, y::ys else x::xs, ys)
    | _ -&amp;gt; assert false
  in
  merge 0 (a,b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The time complexity of this is obviously &lt;code&gt;O(n)&lt;/code&gt; or more precisely &lt;code&gt;O(k)&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;This approach assumes A and B being lists and &lt;em&gt;merge&lt;/em&gt; should be a quite optimal solution. However, the problem doesn't force us to use &lt;em&gt;list&lt;/em&gt; only. If we assume A and B to be &lt;em&gt;array&lt;/em&gt;, can we do better?&lt;/p&gt;

&lt;h1&gt;Recall Binary Search&lt;/h1&gt;

&lt;p&gt;As described in &lt;a href=&quot;http://typeocaml.com/2015/01/20/mutable/&quot;&gt;Mutable&lt;/a&gt;, when looking for an element in a &lt;em&gt;sorted array&lt;/em&gt;, we can use &lt;em&gt;binary search&lt;/em&gt; to obtain &lt;code&gt;O(log(n))&lt;/code&gt; performance, instead of linear searching.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For binary search, we just go to the middle and then turn left or right depending on the comparison of the middle value and our target.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/12/binary_search.jpg&quot; alt=&quot;binary search&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Coming back to our current problem, &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We are searching for something (a value with a rank instead of a particular value itself though)  &lt;/li&gt;
&lt;li&gt;The data structures of A and B are not limited to &lt;em&gt;lists&lt;/em&gt;, but also can be &lt;em&gt;arrays&lt;/em&gt;.  &lt;/li&gt;
&lt;li&gt;Both A and B are sorted.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These characteristics present &lt;em&gt;nothing directly&lt;/em&gt; towards a classic binary search problem, however, they seem hinting us that &lt;em&gt;binary search&lt;/em&gt; is worth trying. &lt;/p&gt;

&lt;p&gt;Let's have a go.&lt;/p&gt;

&lt;h1&gt;Double Binary Rank Search&lt;/h1&gt;

&lt;p&gt;So here is the A and B, we want to find the &lt;code&gt;kth&lt;/code&gt; smallest value&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2017/10/ds_1-2.jpg&quot; alt=&quot;ds_1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Since we are trying &lt;em&gt;binary search&lt;/em&gt;, we can just split A and B by their middle values respectively.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2017/10/ds_2.jpg&quot; alt=&quot;ds_2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;So what now? &lt;/p&gt;

&lt;p&gt;In single binary search, we can compare the middle value with the target varlue. And if target is larger, then we go right; otherwise, we go left. &lt;/p&gt;

&lt;p&gt;But in this double binary rank search problem, it is a little trickier:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We have 2 sorted arrays instead of 1  &lt;/li&gt;
&lt;li&gt;We are not searching for an element with a particular value, instead, with a particular rank (kth smallest)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;From point 1 above, the middle values split the two arrays into four parts; From point 2 above, we have to find out which part (out of the four) the kth would fall into. In addition, since its about rank instead of a value, it must be related to the lengths of the parts.&lt;/p&gt;

&lt;p&gt;Let's assume &lt;em&gt;a &amp;lt; b&lt;/em&gt; (if not, then we can simply swap A and B).&lt;/p&gt;

&lt;p&gt;So if a &amp;lt; b, what we can induct?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2017/10/ds_3-9.jpg&quot; alt=&quot;ds_3&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The relationships between all the parts (including &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;) are demonstrated as above. The position of &lt;code&gt;ha&lt;/code&gt; is dynamic as we only know the middle points a &amp;lt; b. However, the relationship between &lt;code&gt;la, a, lb&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is determined and we know for sure that there are definitely at least &lt;code&gt;la + lb + 1 (lenth of a is 1)&lt;/code&gt; numbers smaller than &lt;code&gt;b&lt;/code&gt;. Thus considering the rank &lt;code&gt;k&lt;/code&gt;, if &lt;code&gt;k &amp;lt;= la + lb + 1&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;From Case 1 and 2, the kth element must be in &lt;code&gt;la&lt;/code&gt;, or &lt;code&gt;a&lt;/code&gt;, or &lt;code&gt;ha&lt;/code&gt;, or &lt;code&gt;lb&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;From Case 3, it must be in &lt;code&gt;la&lt;/code&gt;, or &lt;code&gt;a&lt;/code&gt;, or &lt;code&gt;lb&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We therefore can know simply that &lt;strong&gt;if k &amp;lt;= la + lb + 1, the kth smallest number definitely won't be in &lt;code&gt;hb&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2017/10/ds_4-3.jpg&quot; alt=&quot;ds_4&quot;/&gt;&lt;/p&gt;

&lt;p&gt;What if k &amp;gt; la + lb + 1? Going back to the 3 cases:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The kth element might be in &lt;code&gt;hb&lt;/code&gt; because k can be big enough.  &lt;/li&gt;
&lt;li&gt;From Case 1, it might be in &lt;code&gt;ha&lt;/code&gt; if &lt;code&gt;ha&lt;/code&gt; are all larger than &lt;code&gt;lb&lt;/code&gt; otherwise, it might be in &lt;code&gt;lb&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;From Case 2, it might be in &lt;code&gt;ha&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;From Case 3, it is obviously that &lt;code&gt;la&lt;/code&gt; doesn't have a chance to have the kth element.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus &lt;strong&gt;if k &amp;gt; la + lb + 1, the kth smallest number definitely won't be in &lt;code&gt;la&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2017/10/ds_5.jpg&quot; alt=&quot;ds_5&quot;/&gt;&lt;/p&gt;

&lt;p&gt;So every time we compare &lt;code&gt;k&lt;/code&gt; with &lt;code&gt;la + lb + 1&lt;/code&gt; and at least one part can be eliminated out. If a &amp;lt; b, then either &lt;code&gt;la&lt;/code&gt; or &lt;code&gt;hb&lt;/code&gt; is removed; otherwise, either &lt;code&gt;lb&lt;/code&gt; or &lt;code&gt;ha&lt;/code&gt; is removed (as said, we can simply swap A and B).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let kth_union k a b =  
  let sa = Array.length a and sb = Array.length b in
  let rec kth k (a, la, ha) (b, lb, hb) =
    if la &amp;gt;= ha+1 then b.(k+lb)
    else if lb &amp;gt;= hb+1 then a.(k+la)
    else  
      let ma = (ha+la)/2 and mb = (hb+lb)/2 in
      match a.(ma) &amp;lt; b.(mb), k &amp;gt;= ma-la+1+mb-lb with 
      | true, true -&amp;gt; kth (k-(ma-la+1)) (a, ma+1, ha) (b, lb, hb)
      | true, false -&amp;gt; kth k (a, la, ha) (b, lb, mb-1)
      | _ -&amp;gt; kth k (b, lb, hb) (a, la, ha) (* swap *)
  in 
  kth k (a, 0, sa-1) (b, 0, sb-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since every time we remove &lt;code&gt;1 / 4&lt;/code&gt; elements, the complexity is &lt;code&gt;O(2*log(N))&lt;/code&gt;, i.e., &lt;code&gt;O(log(N))&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Remark&lt;/h1&gt;

&lt;p&gt;This pearl is comparatively not difficult, however, the idea of process of elimination is worth noting. Instead of choosing which part is positive towards our answer, we can remove parts that is impossible and eventually we can achieve similar algorithmic complexity. &lt;/p&gt;

&lt;h1&gt;A further slight improvement&lt;/h1&gt;

&lt;p&gt;From a reply in &lt;a href=&quot;https://news.ycombinator.com/reply?id=15514451&quot;&gt;hackernews&lt;/a&gt;, it was suggested that&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If the data structures can be split (as it seems), then the first step should be to get the head k element of both collections, so we only have to work with a maximum of 2k elements. Then the solution is not O(2 * log(N)) but O(2 * log(min(N,2k))).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This would not significantly improve the performance however it makes sense especially when &lt;code&gt;k&lt;/code&gt; is smaller than the lengths of both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. &lt;/p&gt;</content><id>http://typeocaml.com/2017/10/19/pearl-no-4-double-binary-search/</id><title type="text">Pearl No.4 - Kth Smallest in the Union of 2 Sorted Collections</title><updated>2017-10-19T13:37:30-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2015/11/22/visualise_random/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/11/visual_random-1.jpg#hero&quot; alt=&quot;heor&quot;/&gt;&lt;/p&gt;

&lt;p&gt;It has been almost half year since my last blog post on OCaml. Well, actually I haven't even touched OCaml for that long time. My current job (in Python) got much busier. But finally, things &lt;s&gt;camls&lt;/s&gt; calms down a bit now. I can at least have time sitting in front of my 2008 macbook pro, opening terminal, doing &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;opam update

opam upgrade

opam switch 4.02.3

eval `opam config env`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmmmm, I like this feeling. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;typeocaml&lt;/strong&gt; is back now. I digged my typeocaml notebook from one of our 78 packing boxes, and went through the list of &lt;em&gt;many things about OCaml&lt;/em&gt; that I planned to write about. Those items still look familiar but obviously not very clear in my mind now. One should never put a vacuum space in things beloved. They would fade.&lt;/p&gt;

&lt;p&gt;Anyway, enough chit-chat, back to the topic.&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;This post is about visualising the randomness of random number generators. It will be lightweight and is just something I did for fun with OCaml. We will know a good way to test randomness and also learn how to create a &lt;em&gt;jpg&lt;/em&gt; picture using an OCaml image library: &lt;strong&gt;camlimages&lt;/strong&gt;. I hope it would be tiny cool.&lt;/p&gt;

&lt;h1&gt;What is randomness?&lt;/h1&gt;

&lt;p&gt;Say, we got a function &lt;code&gt;var ran_gen : int -&amp;gt; int&lt;/code&gt; from nowhere. It claims to be a good random integer generator with uniform distribution, which takes a bound and &amp;quot;perfectly&amp;quot; generates a random integer within [0, bound). The usage is simple but the question is &lt;em&gt;can you trust it&lt;/em&gt; or &lt;em&gt;will the numbers it generates be really random&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;For example, here is a rather simple &lt;code&gt;ran_gen_via_time&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let decimal_only f = f -. (floor f)  
let ran_via_time bound =  
  ((Unix.gettimeofday() |&amp;gt; decimal_only) *. 100,000,000. |&amp;gt; int_of_float) mod bound
(*
  Unix.gettimeofday() returns float like 1447920488.92716193 in second. 
  We get the decimal part and then amplify it to be integer like, i.e., 1447920488.92716193 ==&amp;gt; 0.92716193 ==&amp;gt; 92716193.
  Then we mod it by bound to get the final &amp;quot;random&amp;quot; number.
*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This generator is based on the &lt;em&gt;timestamp&lt;/em&gt; when it is called and then mod by the &lt;em&gt;bound&lt;/em&gt;. Will it be a good generator? My gut tells me &lt;em&gt;not really&lt;/em&gt;. If the calls to the function has some patterns, then eaily the numbers become constant. &lt;/p&gt;

&lt;p&gt;For example, if the &lt;em&gt;bound&lt;/em&gt; is 10, then at &lt;em&gt;t&lt;/em&gt; I make first call, I will get &lt;code&gt;t mod 10&lt;/code&gt;. If I call at &lt;em&gt;t + 10&lt;/em&gt; again, I will get &lt;code&gt;(t+10) mod 10&lt;/code&gt; which is actually &lt;code&gt;t mod 10&lt;/code&gt;. If I call it every 10 seconds, then I get a constant. Thus this generator's randomness would not be as good as it claims to be.&lt;/p&gt;

&lt;p&gt;For any given random number generator, we have to really make sure its randomness is good enough to suite our goal, especially when we have to rely on them for trading strategies, gaming applications, online gambling hosting, etc. &lt;/p&gt;

&lt;p&gt;However, we also need to be aware of that most of random generators are not perfect (&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_number_generation&quot;&gt;Random number generator&lt;/a&gt;&lt;/em&gt; and &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Pseudorandom_number_generator&quot;&gt;Pseudorandom number generator&lt;/a&gt;&lt;/em&gt;). What we often do is just to see whether the randomness of a given generator can reach a certain level or not.&lt;/p&gt;

&lt;h1&gt;Test randomness using statistics&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Chi-squared_test&quot;&gt;Chi-squared test&lt;/a&gt; is a fairly simple and common methodology to test randomness mathematically.&lt;/p&gt;

&lt;p&gt;Say, we have a generator producing random integers between [0, 10) with uniform distribution. So ideally, if the generator is perfect, and if we ran 1000 times, then there would be 100 of &lt;em&gt;0&lt;/em&gt;, 100 of &lt;em&gt;1&lt;/em&gt;, ..., 100 of &lt;em&gt;9&lt;/em&gt; , right? For the test, we can just try the generator &lt;em&gt;N&lt;/em&gt; times, and see whether the frequency of each number generated somehow matches or is close to &lt;em&gt;N / bound&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Of course, the frquencies of numbers would not exactly match expectation. So we need some mathematics to measure the level of matching.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;k&lt;/em&gt; is the number of possible candidates - e.g., &lt;em&gt;k = 10&lt;/em&gt; for [0, 10)  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Ei&lt;/em&gt; is the expected frequency for each candidate - &lt;em&gt;i = 1, 2, k&lt;/em&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Oi&lt;/em&gt; is the frequency for each candidate produced by the generator - &lt;em&gt;i = 1, 2, k&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus we can get &lt;code&gt;X^2 = (O1-E1)^2/E1 + ... + (Ok-Ek)^2/Ek&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Essentially, the bigger &lt;code&gt;X^2&lt;/code&gt; is, the matching is more unlikely. If we really want to see how unlikely or likely they match each other, then we need to check &lt;code&gt;X^2&lt;/code&gt; against the &lt;em&gt;chi square distribution table&lt;/em&gt; like below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://faculty.elgin.edu/dkernler/statistics/ch09/images/chi-square-table.gif&quot; alt=&quot;chi square distribution table&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;em&gt;Degrees of Freedom&lt;/em&gt; is our &lt;code&gt;k-1&lt;/code&gt; (if &lt;em&gt;k = 1&lt;/em&gt;, then our freedom is &lt;em&gt;0&lt;/em&gt;, which means we just have one to choose all the time and don't have any freedom).  &lt;/li&gt;
&lt;li&gt;The bold headings of columns are the probabilities that the observations match the expectations.  &lt;/li&gt;
&lt;li&gt;The many numbers in those cells are values of &lt;code&gt;X^2&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For example, say in our case above, &lt;code&gt;k = 10&lt;/code&gt;, so &lt;em&gt;Degree of freedom is 9&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;If we get &lt;code&gt;X^2&lt;/code&gt; as &lt;em&gt;2&lt;/em&gt;, which is less than &lt;em&gt;2.088&lt;/em&gt;, then we can say we have more than &lt;em&gt;0.99&lt;/em&gt; probability that the observations match the expectations, i.e., our random generator follows uniform distribution very well. &lt;/p&gt;

&lt;p&gt;If we get &lt;code&gt;X^2&lt;/code&gt; as &lt;em&gt;23&lt;/em&gt;, which is bigger than &lt;em&gt;21.666&lt;/em&gt;, the probability of matching is less than &lt;em&gt;0.01&lt;/em&gt;, so our generator at least is not following uniform distribution.&lt;/p&gt;

&lt;p&gt;This is roughly how we could use Chi-squared test for randomness checking. Of course, the description above is amateur and I am just trying to put it in a way for easier understanding. &lt;/p&gt;

&lt;h1&gt;Test randomness via visualisation&lt;/h1&gt;

&lt;p&gt;Let's admit one thing first: Math can be boring. Although math can describe things most precisely, it does not make people like me feel intuitive, or say, straightforward. If I can directly see problems and the solutions via my eyes, I would be much happier and this was the reason why I tried to visualise the randomness of generators.&lt;/p&gt;

&lt;p&gt;The way of the visualisation is fairly simple.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We create a canvas.  &lt;/li&gt;
&lt;li&gt;Each pixel on the canvas is a candidate random number that the generator can produce.  &lt;/li&gt;
&lt;li&gt;We run the generator for lots of times.  &lt;/li&gt;
&lt;li&gt;The more times a pixel gets hit, we draw a deeper color on it.  &lt;/li&gt;
&lt;li&gt;In the end, we can directly feel the randomness depending on the color distribution on the canvas.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;A trivial example&lt;/h2&gt;

&lt;p&gt;Initially we have such a canvas.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/11/randomness_canvas.jpg&quot; alt=&quot;canvas&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We use the random generator generating numbers. If a slot get a hit, we put a color on it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/11/randomness_1.jpg&quot; alt=&quot;random_1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;If any slot keeps been hit, we put deeper and deeper color on it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/11/randomness_2.jpg&quot; alt=&quot;random_2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;When the generator finishes, we can get a final image.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/11/randomness_3.jpg&quot; alt=&quot;random_3&quot;/&gt;&lt;/p&gt;

&lt;p&gt;From the resulting image, we can see that several numbers are really much deeper than others, and we can directly get a feeling about the generator. &lt;/p&gt;

&lt;p&gt;Of course, this is just trivial. Normally, we can get much bigger picture and see the landscape of the randomness, instead of just some spots. Let's get our hands dirty then.&lt;/p&gt;

&lt;h2&gt;Preparation&lt;/h2&gt;

&lt;p&gt;Assuming the essentials of OCaml, such as &lt;em&gt;ocaml&lt;/em&gt; itself, &lt;em&gt;opam&lt;/em&gt; and &lt;em&gt;ocamlbuild&lt;/em&gt;, have been installed, the only 3rd party library we need to get now is &lt;a href=&quot;https://bitbucket.org/camlspotter/camlimages&quot;&gt;camlimagges&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Before invoke &lt;code&gt;opam install camlimages&lt;/code&gt;, we need to make sure &lt;a href=&quot;http://stackoverflow.com/questions/24805385/camlimages-fatal-error-exception-failureunsupported&quot;&gt;&lt;em&gt;libjpeg&lt;/em&gt; being installed first in your system&lt;/a&gt;. Basically, &lt;em&gt;camlimages&lt;/em&gt; relies on system libs of &lt;em&gt;libjpeg&lt;/em&gt;, &lt;em&gt;libpng&lt;/em&gt;, etc to save image files in respective formats. In this post, we will save our images to &lt;code&gt;.jpg&lt;/code&gt;, so depending on the operating system, we can just directly try installing it by the keyword of &lt;em&gt;libjpeg&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;For example, &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;mac&lt;/em&gt; -&amp;gt; &lt;code&gt;brew install libjpeg&lt;/code&gt;; &lt;/li&gt;
&lt;li&gt;&lt;em&gt;ubuntu&lt;/em&gt; -&amp;gt; &lt;code&gt;apt-get install libjpeg&lt;/code&gt;; &lt;/li&gt;
&lt;li&gt;&lt;em&gt;redhat&lt;/em&gt; -&amp;gt; &lt;code&gt;yum install libjpeg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After &lt;em&gt;libjpeg&lt;/em&gt; is installed, we can then invoke &lt;code&gt;opam install camlimages&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In addition, for easier compiling or testing purposes, maybe &lt;a href=&quot;https://ocaml.org/learn/tutorials/ocamlbuild/&quot;&gt;ocamlbuild&lt;/a&gt; &lt;code&gt;opam install ocamlbuild&lt;/code&gt; and &lt;a href=&quot;https://opam.ocaml.org/blog/about-utop/&quot;&gt;utop&lt;/a&gt; &lt;code&gt;opam install utop&lt;/code&gt; could be installed, but it is up to you.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install libjpeg  
opam install camlimages  
opam install ocamlbuild  
opam install utop  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;The general process&lt;/h2&gt;

&lt;p&gt;The presentation of an &lt;em&gt;RGB&lt;/em&gt; image in memory is a bitmap, which is fairly simple: just an 2-d array (&lt;em&gt;width&lt;/em&gt; x &lt;em&gt;height&lt;/em&gt;) with each slot holding a color value, in a form like &lt;em&gt;(red, green, blue)&lt;/em&gt;. Once we have such a bitmap, we can just save it to the disk in various formats (different commpression techniques).&lt;/p&gt;

&lt;p&gt;So the process could be like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a matrix array, with certain size (&lt;em&gt;width&lt;/em&gt; and &lt;em&gt;height&lt;/em&gt;)  &lt;/li&gt;
&lt;li&gt;Manipulate the values (colors) of all slots via random generated numbers  &lt;/li&gt;
&lt;li&gt;Convert the matrix bitmap to a real image  &lt;/li&gt;
&lt;li&gt;Save the image to a &lt;em&gt;jpg&lt;/em&gt; file&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Fill the matrix&lt;/h2&gt;

&lt;p&gt;First, let's create a matrix.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;open Camlimages

(* w is the width and h is the height *)
let bitmap = Array.make_matrix w h {Color.r = 255; g = 255; b = 255}  
(* 
  Color is a type in camlimages for presenting RGB colors,
  and initially white here.
*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we generate a random number, we need to map it to a slot. Our image is a rectangle, i.e., having rows and columns. Our random numbers are within a bound &lt;em&gt;[0, b)&lt;/em&gt;, i.e., 1-d dimension. A usual way to convert from 1-d to 2-d is just divide the number by the width to get the row and modulo the number by the width to get the col.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let to_row_col ~w ~v = v / w, v mod w  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we get a random number, we now need to fill its belonging slot darker. Initially, each slot can be pure white, i.e., &lt;code&gt;{Color.r = 255; g = 255; b = 255}&lt;/code&gt;. In order to make it darker, we simply just to make the &lt;em&gt;rgb&lt;/em&gt; equally smaller.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let darker {Color.r = r;g = g;b = b} =  
  let d c = if c-30 &amp;gt;= 0 then c-30 else 0 
  in 
  {Color.r = d r;g = d g;b = d b}
(*
  The decrement `30` really depends on how many times you would like to run the generator 
  and also how obvious you want the color difference to be.
*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we can integrate the major random number genrations in.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(*
  ran_f: the random number generator function, produce number within [0, bound)
         fun: int -&amp;gt; int
  w, h:  the width and height
         int
  n:     the expected times of same number generated
         int

  Note in total, the generator will be called w * h * n times.
*)
let random_to_bitmap ~ran_f ~w ~h ~n =  
  let bitmap = Array.make_matrix w h {Color.r = 255; g = 255; b = 255} in
  let to_row_col ~w ~v = v / w, v mod w in
  let darker {Color.r = r;g = g;b = b} = let d c = if c-30 &amp;gt;= 0 then c-30 else 0 in {Color.r = d r;g = d g;b = d b} 
  in
  for i = 1 to w * h * n do
    let row, col = to_row_col ~w ~v:(ran_f (w * h)) in
    bitmap.(row).(col) &amp;lt;- darker bitmap.(row).(col);
  done;
  bitmap
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Convert the matrix to an image&lt;/h2&gt;

&lt;p&gt;We will use the module &lt;em&gt;Rgb24&lt;/em&gt; in &lt;em&gt;camlimages&lt;/em&gt; to map the matrix to an image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let bitmap_to_img ~bitmap =  
  let w = Array.length bitmap in
  let h = if w = 0 then 0 else Array.length bitmap.(0) in
  let img = Rgb24.create w h in
  for i = 0 to w-1 do
    for j = 0 to h-1 do
      Rgb24.set img i j bitmap.(i).(j)
    done
  done;
  img
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Save the image&lt;/h2&gt;

&lt;p&gt;Module &lt;em&gt;Jpeg&lt;/em&gt; will do the trick perfectly, as long as you remembered to install &lt;em&gt;libjpeg&lt;/em&gt; before &lt;em&gt;camlimages&lt;/em&gt; arrives.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let save_img ~filename ~img = Jpeg.save filename [] (Images.Rgb24 img)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Our master function&lt;/h2&gt;

&lt;p&gt;By grouping them all together, we get our master function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let random_plot ~filename ~ran_f ~w ~h ~n =  
  let bitmap = random_to_bitmap ~ran_f ~w ~h ~n in
  let img = bitmap_to_img ~bitmap in
  save_img ~filename ~img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All source code is in here &lt;a href=&quot;https://github.com/MassD/typeocaml_code/tree/master/visualise_randomness&quot;&gt;https://github.com/MassD/typeocaml_code/tree/master/visualise_randomness&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Result - standard Random.int&lt;/h2&gt;

&lt;p&gt;OCaml standard lib provides a &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Random.html&quot;&gt;random integer genertor&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;val int : int -&amp;gt; int

Random.int bound returns a random integer between 0 (inclusive) and bound (exclusive). bound must be greater than 0 and less than 2^30.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let's have a look what it looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let _ = random_plot ~filename:&amp;quot;random_plot_int.jpg&amp;quot; ~ran_f:Random.int ~w:1024 ~h:1024 ~n:5  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/MassD/typeocaml_code/master/visualise_randomness/random_plot_int.jpg&quot; alt=&quot;ran_int&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Is it satisfying? Well, I guess so.&lt;/p&gt;

&lt;h2&gt;Result - ran_gen_via_time&lt;/h2&gt;

&lt;p&gt;Let's try it on the &lt;code&gt;ran_gen_via_time&lt;/code&gt; generator we invented before:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let decimal_only f = f -. (floor f)  
let ran_via_time bound =  
  ((Unix.gettimeofday() |&amp;gt; decimal_only) *. 100,000,000. |&amp;gt; int_of_float) mod bound

let _ = random_plot ~filename:&amp;quot;random_plot_time.jpg&amp;quot; ~ran_f:ran_via_time ~w:1024 ~h:1024 ~n:5  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/MassD/typeocaml_code/master/visualise_randomness/random_plot_time.jpg&quot; alt=&quot;ran_time&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Is it satisfying? Sure not.&lt;/p&gt;

&lt;p&gt;Apparently, there are quite some patterns on images. Can you identify them?&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/11/random_plot_time.jpg&quot; alt=&quot;ran_time_patr&quot;/&gt;&lt;/p&gt;

&lt;p&gt;One pattern is the diagonal lines there (parrallel to the red lines I've added).&lt;/p&gt;

&lt;h1&gt;Only quick and fun&lt;/h1&gt;

&lt;p&gt;Of course, visualisation of randomness is nowhere near accurately assess the quality of random geneators. It is just a fun way to feel its randomness.&lt;/p&gt;

&lt;p&gt;I hope you enjoy it.&lt;/p&gt;

&lt;hr/&gt;

&lt;h1&gt;JPG vs PNG&lt;/h1&gt;

&lt;p&gt;Pointed by &lt;a href=&quot;https://news.ycombinator.com/item?id=10609990&quot;&gt;Ono-Sendai on hacker news&lt;/a&gt;, it might be better to use &lt;code&gt;png&lt;/code&gt; rather than &lt;code&gt;jpg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I've tried and the results for the bad &lt;code&gt;ran_gen_via_time&lt;/code&gt; are like:&lt;/p&gt;

&lt;h2&gt;JPG&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/MassD/typeocaml_code/master/visualise_randomness/random_plot_time.jpg&quot; alt=&quot;jpg&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;PNG&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/MassD/typeocaml_code/master/visualise_randomness/random_plot_time.png&quot; alt=&quot;png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Seems not that different from my eyes. But anyway it was a good point.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/MassD/typeocaml_code/blob/master/visualise_randomness/plot_random.ml&quot;&gt;https://github.com/MassD/typeocaml_code/blob/master/visualise_randomness/plot_random.ml&lt;/a&gt; has been updated for &lt;code&gt;png&lt;/code&gt; support. &lt;strong&gt;Please remember to install libpng-devel for your OS for png saving support&lt;/strong&gt;.&lt;/p&gt;

&lt;h1&gt;Fortuna random generator from nocrypto&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/h4nnes&quot;&gt;@h4nnes&lt;/a&gt; has suggested me to try the &lt;em&gt;fortuna generator&lt;/em&gt; from &lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto&quot;&gt;nocrypto&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;opam install nocrypto  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let _ = Nocrypto_entropy_unix.initialize()  
let _ = random_plot ~filename:&amp;quot;random_plot_fortuna&amp;quot; ~ran_f:Nocrypto.Rng.Int.gen ~w:1024 ~h:1024 ~n:5  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we get&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/MassD/typeocaml_code/master/visualise_randomness/random_plot_fortuna.jpg&quot; alt=&quot;fortuna&quot;/&gt;&lt;/p&gt;

&lt;p&gt;It is a very nice generator, isn't it?&lt;/p&gt;</content><id>http://typeocaml.com/2015/11/22/visualise_random/</id><title type="text">Visualise Randomness</title><updated>2015-11-22T13:14:20-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2015/05/05/permutation/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/permutation3.jpg#hero&quot; alt=&quot;hero&quot;/&gt;&lt;/p&gt;

&lt;p&gt;In this post, we will talk about producing permuations using OCaml. Generating permutations was actually one of my first self-homeworks when I started to learn OCaml years ago. It can be a good exercise to train our skills on &lt;em&gt;list&lt;/em&gt;, &lt;em&gt;recursion&lt;/em&gt;, foundamental &lt;em&gt;fold&lt;/em&gt;, &lt;em&gt;map&lt;/em&gt;, etc, in OCaml. Also it shows the conciseness of the OCaml as a language.&lt;/p&gt;

&lt;p&gt;We will first present &lt;strong&gt;2 common approaches&lt;/strong&gt; for generating all permutations of a list of elements. &lt;/p&gt;

&lt;p&gt;Then we introduce the &lt;a href=&quot;http://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm&quot;&gt;Johnson Trotter algorithm&lt;/a&gt; which enable us to generate one permutation at a time. &lt;/p&gt;

&lt;p&gt;Although Johnson Trotter algorithm uses imperative array, it provides us the opportunity to implement a stream (using &lt;a href=&quot;http://typeocaml.com/2014/11/09/magic-of-thunk-stream-list/&quot;&gt;stream list&lt;/a&gt; or built-in &lt;code&gt;Stream&lt;/code&gt; module) of permutations, i.e., we generate a permutation only when we need. We will describe that as last.&lt;/p&gt;

&lt;h1&gt;The insert-into-all-positions solution&lt;/h1&gt;

&lt;p&gt;We can generate permutations using &lt;em&gt;recursion&lt;/em&gt; technique. As we descriped in &lt;a href=&quot;http://typeocaml.com/2014/12/04/recursion-reloaded/&quot;&gt;Recursion Reloaded&lt;/a&gt;, let's first assume we already get a function that can produce all permuations. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/permutations_function0.jpg&quot; alt=&quot;permutation_function0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;What exactly &lt;code&gt;f&lt;/code&gt; will generate is not our concern for now, but we are sure that given a list (say 3 distinct elements), &lt;code&gt;f&lt;/code&gt; will produce a list of permutations (totally 6 in this example). &lt;/p&gt;

&lt;p&gt;So now what if our original list has one more new element?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/permutations_function1.jpg&quot; alt=&quot;permutation_function1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;What should we do to combine the new element together with the old list of permutations, in order to generate a new list of permuatations?&lt;/p&gt;

&lt;p&gt;Let's first take a look at how to combine the new element with one permutation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/permutations_function2-1.jpg&quot; alt=&quot;permutation_function2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;A good way, like shown above, is to insert the new element into all possible positions. Easy, right?&lt;/p&gt;

&lt;p&gt;So for the new list of permutations, we just insert the new element into all possible positions of all old permutations.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/permutations_function3.jpg&quot; alt=&quot;permutation_function3&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;code&lt;/h2&gt;

&lt;p&gt;First let's implement the function that combines an element with a permutation (which is actually a normal list).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* note that in order to preserve certain order and also show the conciseness of the implementation, no tail-recursive is used *)
let ins_all_positions x l =  
  let rec aux prev acc = function
    | [] -&amp;gt; (prev @ [x]) :: acc |&amp;gt; List.rev
    | hd::tl as l -&amp;gt; aux (prev @ [hd]) ((prev @ [x] @ l) :: acc) tl
  in
  aux [] [] l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the main permutations generator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec permutations = function  
  | [] -&amp;gt; []
  | x::[] -&amp;gt; [[x]] (* we must specify this edge case *)
  | x::xs -&amp;gt; List.fold_left (fun acc p -&amp;gt; acc @ ins_all_positions x p ) [] (permutations xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the &lt;a href=&quot;https://gist.github.com/MassD/fa79de3a5ee88c9c5a8e&quot;&gt;Gist&lt;/a&gt;.&lt;/p&gt;

&lt;h1&gt;The fixed-head solution&lt;/h1&gt;

&lt;p&gt;There is another way to look at the permutations.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/permutations_function4.jpg&quot; alt=&quot;permutation_function4&quot;/&gt;&lt;/p&gt;

&lt;p&gt;For a list of 3 elements, each element can be the head of all permutations of the rest elements. For example, &lt;em&gt;blue&lt;/em&gt; is the head of the permutations of &lt;em&gt;green&lt;/em&gt; and &lt;em&gt;yellow&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;So what we can do is&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Get an element out  &lt;/li&gt;
&lt;li&gt;Generate all permutations on all other elements  &lt;/li&gt;
&lt;li&gt;Stick the element as the head of every permutation  &lt;/li&gt;
&lt;li&gt;We repeat all above until we all elements have got their chances to be heads&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/permutations_function5-1.jpg&quot; alt=&quot;permutation_function5&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Code&lt;/h2&gt;

&lt;p&gt;First we need a function to remove an element from a list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rm x l = List.filter ((&amp;lt;&amp;gt;) x) l  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;rm&lt;/code&gt; above is not a must, but it will make the meaning of our following &lt;code&gt;permutations&lt;/code&gt; clearer. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec permutations = function  
  | [] -&amp;gt; []
  | x::[] -&amp;gt; [[x]]
  | l -&amp;gt; 
    List.fold_left (fun acc x -&amp;gt; acc @ List.map (fun p -&amp;gt; x::p) (permutations (rm x l))) [] l

(* The List.fold_left makes every element have their oppotunities to be a head *)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the &lt;a href=&quot;https://gist.github.com/MassD/22950955c5efa8f8af88&quot;&gt;Gist&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;No tail-recusive?&lt;/h1&gt;

&lt;p&gt;So far in all our previous posts, the tail-recusive has always been considered in the codes. However, when we talk about permutations, tail-recusive has been ignored. There are two reasons:&lt;/p&gt;

&lt;p&gt;At first, it is not possible to make recusion tail-recusive everywhere for the two solutions. The best we can do is just make certain parts tail-recusive.&lt;/p&gt;

&lt;p&gt;Secondly, permutation generation is a &lt;em&gt;P&lt;/em&gt; problem and it is slow. If one tries to generate all permutations at once for a huge list, it would not be that feasible. Thus, when talking about permutations here, it is assumed that no long list would be given as an argument; hence, we assume no stackoverflow would ever occur.&lt;/p&gt;

&lt;p&gt;In addition, ignoring tail-recusive makes the code cleaner.&lt;/p&gt;

&lt;h1&gt;What if the list is huge?&lt;/h1&gt;

&lt;p&gt;If a list is huge indeed and we have to somehow use possibly all its permutations, then we can think of making the permutations as a &lt;em&gt;stream&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;Each time we just generate one permutation, and then we apply our somewhat &lt;code&gt;use_permuatation&lt;/code&gt; function. If we need to continue, then we ask the stream to give us one more permutation. If we get what we want in the middle, then we don't need to generate more permutations and time is saved.&lt;/p&gt;

&lt;p&gt;If we still have to go through all the permutations, time-wise the process will still cost us much. However, we are able to avoid putting all permutations in the memory or potentiall stackoverflow.&lt;/p&gt;

&lt;p&gt;In order to achieve &lt;em&gt;a stream of permutations&lt;/em&gt;, we need &lt;a href=&quot;http://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm&quot;&gt;Johnson Trotter algorithm&lt;/a&gt; and a stream.&lt;/p&gt;

&lt;h1&gt;Johnson Trotter algorithm&lt;/h1&gt;

&lt;p&gt;The advantage of this algorithm is its ability to generate a new permutation based on the previous one, via simple &lt;code&gt;O(n)&lt;/code&gt; operations (the very first permutation is the list itself). This is ideal for our adoption of stream.&lt;/p&gt;

&lt;p&gt;The disadvantage, epecially for OCaml, is that it needs an mutable array. Fortunately, we can encapsulate the array in a module or inside a function, without exposing it to the outside world. Thus, certain level of safety will be maintained. &lt;/p&gt;

&lt;p&gt;Personally I think this algorithm is very clever. Johnson must have spent quit much time on observing the changes through all permutations and set a group of well defined laws to make the changes happen naturally. &lt;/p&gt;

&lt;h2&gt;An assumption - sorted&lt;/h2&gt;

&lt;p&gt;The first assumption of this algorithm is that the array of elements are initially sorted in ascending order (&lt;em&gt;[1]&lt;/em&gt;). &lt;/p&gt;

&lt;p&gt;If in some context we cannot sort the original array, then we can attach additional keys, such as simple integers starting from &lt;code&gt;1&lt;/code&gt;, to every element. And carry on the algorithm based on that key.&lt;/p&gt;

&lt;p&gt;For example, if we have &lt;code&gt;[|e1; e2; e3; e4|]&lt;/code&gt; and we do not want to sort it, then we just put an integer in front of each element like &lt;code&gt;[|(1, e1); (2, e2); (3, e3); (4, e4)|]&lt;/code&gt;. All the following process can target on the key, and only when return a permutation, we output the &lt;code&gt;e&lt;/code&gt; in the tuple.&lt;/p&gt;

&lt;p&gt;For simplicity, we will have an example array &lt;code&gt;[|1; 2; 3; 4|]&lt;/code&gt;, which is already sorted.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/johnson1.jpg&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Direction: L or R&lt;/h2&gt;

&lt;p&gt;The key idea behind the algorithm is to move an element (or say, switch two elements) at a time and after the switching, we get our new permutation.&lt;/p&gt;

&lt;p&gt;For any element, it might be able to move either &lt;em&gt;Left&lt;/em&gt; or &lt;em&gt;Right&lt;/em&gt;, i.e., switch position with either &lt;em&gt;Left&lt;/em&gt; neighbour or &lt;em&gt;Right&lt;/em&gt; one. &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;So we will attach a &lt;em&gt;direction&lt;/em&gt; - &lt;em&gt;L&lt;/em&gt; (initially) or &lt;em&gt;R&lt;/em&gt; - to every element.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/johnson2.jpg&quot; alt=&quot;johnson2&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Movable&lt;/h2&gt;

&lt;p&gt;Even if an element has a direction, it might be able to move towards that direction. Only if the element has a &lt;strong&gt;smaller&lt;/strong&gt; neighbour on that direction, it can move.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/johnson3_0-1.jpg&quot; alt=&quot;jonhson3_0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;4&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; are movable, because the neighbours on their &lt;em&gt;left&lt;/em&gt; are smaller.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;3&lt;/code&gt; is not movable, because &lt;code&gt;4&lt;/code&gt; is not smaller.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1&lt;/code&gt; is not movable, because it doesn't have any neighbour on its &lt;em&gt;left&lt;/em&gt;.&lt;/p&gt;

&lt;h2&gt;Scan for largest movable element&lt;/h2&gt;

&lt;p&gt;As we described before, the algorithm makes a new permutation by moving an element, i.e., switch an element with the neighbour on its &lt;em&gt;direction&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What if there are more than one elmeent is movable? We will choose the largest one.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each time, when we are about to generate a new permutation, we simply scan the array, find the largest movable element, and move it.&lt;/p&gt;
  
  &lt;p&gt;If we cannot find such an element, it means we have generated all possible permutations and we can end now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/johnson4-2.jpg&quot; alt=&quot;johnson4&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Although in the above case, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; are all movable, we will move only &lt;code&gt;4&lt;/code&gt; since it is largest.&lt;/p&gt;

&lt;p&gt;The whole process will end if no element is movable.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/johnson4_0.jpg&quot; alt=&quot;johnson4_0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Note that &lt;strong&gt;this scan is before the movement&lt;/strong&gt;.&lt;/p&gt;

&lt;h2&gt;Scan to flip directions of larger element&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;After we make a movement&lt;/strong&gt;, immediately we need to scan the whole array and flip the directions of elements that are larger than the element which is just moved.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/johnson5.jpg&quot; alt=&quot;johnson5&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;A complete example&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/05/johnson6.jpg&quot; alt=&quot;johnson6&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Code&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Direction&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type direction = L | R

let attach_direction a = Array.map (fun x -&amp;gt; (x, L)) a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Move&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let swap a i j = let tmp = a.(j) in a.(j) &amp;lt;- a.(i); a.(i) &amp;lt;- tmp

let is_movable a i =  
  let x,d = a.(i) in
  match d with
    | L -&amp;gt; if i &amp;gt; 0 &amp;amp;&amp;amp; x &amp;gt; (fst a.(i-1)) then true else false
    | R -&amp;gt; if i &amp;lt; Array.length a - 1 &amp;amp;&amp;amp; x &amp;gt; (fst a.(i+1)) then true else false

let move a i =  
  let x,d = a.(i) in
  if is_movable a i then 
    match d with
      | L -&amp;gt; swap a i (i-1)
      | R -&amp;gt; swap a i (i+1)
  else
    failwith &amp;quot;not movable&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Scan for the larget movable element&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let scan_movable_largest a =  
  let rec aux acc i =
    if i &amp;gt;= Array.length a then acc
    else if not (is_movable a i) then aux acc (i+1)
    else
      let x,_ = a.(i) in
      match acc with
        | None -&amp;gt; aux (Some i) (i+1)
        | Some j -&amp;gt; aux (if x &amp;lt; fst(a.(j)) then acc else Some i) (i+1)
  in
  aux None 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Scan to flip larger&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let flip = function | L -&amp;gt; R | R -&amp;gt; L

let scan_flip_larger x a =  
  Array.iteri (fun i (y, d) -&amp;gt; if y &amp;gt; x then a.(i) &amp;lt;- y,flip d) a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Permutations generator&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let permutations_generator l =  
  let a = Array.of_list l |&amp;gt; attach_direction in
  let r = ref (Some l) in
  let next () = 
    let p = !r in
    (match scan_movable_largest a with (* find largest movable *)
      | None -&amp;gt; r := None (* no more permutations *)
      | Some i -&amp;gt; 
        let x, _ = a.(i) in (
        move a i; (* move *)
        scan_flip_larger x a; (* after move, scan to flip *)
        r := Some (Array.map fst a |&amp;gt; Array.to_list)));
    p
  in
  next

(* an example of permutation generator of [1;2;3].
   Every time called, generator() will give either next permutation or None*)
let generator = permutations_generator [1;2;3]

&amp;gt; generator();;
&amp;gt; Some [1; 2; 3]

&amp;gt; generator();;
&amp;gt; Some [1; 3; 2]

&amp;gt; generator();;
&amp;gt; Some [3; 1; 2]

&amp;gt; generator();;
&amp;gt; Some [3; 2; 1]

&amp;gt; generator();;
&amp;gt; Some [2; 3; 1]

&amp;gt; generator();;
&amp;gt; Some [2; 1; 3]

&amp;gt; generator();;
&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the &lt;a href=&quot;https://gist.github.com/MassD/be3f6571967662b9d3c6&quot;&gt;Gist&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;The imperative part inside&lt;/h2&gt;

&lt;p&gt;Like said before, although we use array and &lt;code&gt;ref&lt;/code&gt; for the impelmentation, we can hide them from the interface &lt;code&gt;permutations_generator&lt;/code&gt;. This makes our code less fragile, which is good. However, for OCaml code having imperative parts, we should not forget to put &lt;code&gt;Mutex&lt;/code&gt; locks for thread safety. &lt;/p&gt;

&lt;h1&gt;A stream of permutations&lt;/h1&gt;

&lt;p&gt;Now it is fairly easy to produce a stream of permutations via built-in &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Stream.html&quot;&gt;Stream&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let stream_of_permutations l =  
  let generator = permutations_generator l in
  Stream.from (fun _ -&amp;gt; generator())
&lt;/code&gt;&lt;/pre&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;[1]&lt;/strong&gt;. The array can be descending order, which means later on we need to put all initial directions as &lt;em&gt;R&lt;/em&gt;.&lt;/p&gt;</content><id>http://typeocaml.com/2015/05/05/permutation/</id><title type="text">Permutations</title><updated>2015-05-05T19:15:23-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2015/03/31/pearl-no-3-saddleback-search/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/pearl_3_easter_1-2.jpg#hero&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;Happy Easter&lt;/h1&gt;

&lt;p&gt;Our easter egg happens to be Pearl 3.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A function $ f $ can have the following properties:&lt;/p&gt;
  
  &lt;ol&gt;
  &lt;li&gt;$ f $ takes two arguments: $ x $ and $ y $&lt;/li&gt;
  &lt;li&gt;Both $ x $ and $ y $ are natural numbers, i.e., non-negative integers  &lt;/li&gt;
  &lt;li&gt;$ f $ also returns natural numbers  &lt;/li&gt;
  &lt;li&gt;$ f $ is strictly increasing in each argument. This means if $ x $ increases or descreases, the according result of $ f $  will also increase or descrease. The same applies on $ y $.&lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;Now we are given such a function $ f $ and a natural number &lt;code&gt;z&lt;/code&gt;, and we want to find out all pairs of $ x $ and $ y $ that makes $ f (x, y) = z $.&lt;/p&gt;
  
  &lt;p&gt;In OCaml world, this problem requires us to write a function &lt;code&gt;let find_all f z = ...&lt;/code&gt; which returns a list of &lt;code&gt;(x, y)&lt;/code&gt; that satisfy &lt;code&gt;f x y = z&lt;/code&gt;, assuming the supplied &lt;code&gt;f&lt;/code&gt; meets the requirements above.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Basic Math Analysis&lt;/h1&gt;

&lt;p&gt;This problem seems not that difficult. A trivial brute-force solution comes out immediately. We can simply try every possible value for $ x $ and $ y $ on $ f $, and accumulate all $ (x, y) $ satisfying $ f (x, y) = z $ to the list. There is just one silly question:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Can we try all infinite $ x $ and $ y $?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Of course we cannot. We should try to set a range for both $ x $ and $ y $, otherwise, our solution would run forever. Then how? From some simple math analysis, we can conclude something about $ f $, even if we won't know what $ f $ will be exactly.&lt;/p&gt;

&lt;p&gt;Here are what we know so far:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$ x &amp;gt;= 0 $  &lt;/li&gt;
&lt;li&gt;$ y &amp;gt;= 0 $  &lt;/li&gt;
&lt;li&gt;$ z &amp;gt;= 0 $  &lt;/li&gt;
&lt;li&gt;$ x, y, z $ are all integers, which means the unit of increment or decrement is $ 1 $  &lt;/li&gt;
&lt;li&gt;$ f $ goes up or down whenever $ x $ or $ y $ goes up or down.  &lt;/li&gt;
&lt;li&gt;$ f (x, y) = z $&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;From first 4 points, if we pick a value $ X $ for $ x $, we know we can descrease $ x $ from $ X $ at most $ X $ times. It is also true for $ y $ and $ z $.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/x_descrease.jpg&quot; alt=&quot;decrease_x&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Then let's assume $ X $ and $ Y $ makes $ f $ equal to $ Z $ ($ X, Y, Z $ are assumed to be values), i.e., &lt;/p&gt;

&lt;p&gt;$$ f (X, Y) = Z $$&lt;/p&gt;

&lt;p&gt;Let's now fix $ Y $ and try descreasing $ x $ to $ X-1 $. From point 5, we know &lt;/p&gt;

&lt;p&gt;$$ f (X-1, Y) = Z_{X-1} &amp;lt; f (X, Y) = Z $$&lt;/p&gt;

&lt;p&gt;We can continue to decrease $ x $ until $ 0 $:&lt;/p&gt;

&lt;p&gt;$$ f (0, Y) = Z_0 &amp;lt; f (1, Y) = Z_1 &amp;lt; ... &amp;lt; f (X-2, Y) = Z_{X-2} &amp;lt; f (X-1, Y) = Z_{X-1} &amp;lt; f (X, Y) = Z $$&lt;/p&gt;

&lt;p&gt;Together with point 3 ($ z &amp;gt;= 0 $), we can simplify the above inequalities like:&lt;/p&gt;

&lt;p&gt;$$ 0 &amp;lt;= Z_0 &amp;lt; Z_1 &amp;lt; ... &amp;lt; Z_{X-2} &amp;lt; Z_{X-1} &amp;lt; Z $$&lt;/p&gt;

&lt;p&gt;We can see that through this descreasing of $ x $, the number of results ($ Z_0, Z_1, ..., Z_{X-1} $) is $ X $. How many possible values between $ 0 $ (inclusive) and $ Z $ (exclusive)?  Of course the answer is $ Z $, right? So we can get $$ 0 &amp;lt;= X &amp;lt;= Z $$ and similarly, $$ 0 &amp;lt;= Y &amp;lt;= Z $$.&lt;/p&gt;

&lt;p&gt;Thus, for any given $ x, y, z $, their relationship is&lt;/p&gt;

&lt;p&gt;$$ 0 &amp;lt;= x, y &amp;lt;= Z $$&lt;/p&gt;

&lt;p&gt;We obtained the range and now our brute-force solution will work.&lt;/p&gt;

&lt;h1&gt;Brute-force solution&lt;/h1&gt;

&lt;p&gt;It is simple enough.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let find_all_bruteforce f z =  
  let rec aux acc x y =
    if y &amp;gt; z then aux acc (x+1) 0
    else if x &amp;gt; z then acc
    else 
      let r = f x y in
      if r = z then aux ((x, y)::acc) x (y+1)
      else aux acc x (y+1)
  in
  aux [] 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The time complexity is $ O(log(z^2)) $. To be exact, we need $ (z + 1)^2 $ calculation of $ f $. It will be a bit slow and we should seek for a better solution&lt;/p&gt;

&lt;h1&gt;A Matrix&lt;/h1&gt;

&lt;p&gt;The fact that $ f $ is an increasing function on $ x $ and $ y $ has been used to retrieve the range of $ x $ and $ y $. We actually can extract more from it.&lt;/p&gt;

&lt;p&gt;If we fix the somewhat value of $ y $, then increase $ x $ from $ 0 $, then the result of $ f $ will increase and naturally be sorted. If we fix $ x $, and increase $ y $ from $ 0 $, the same will happen that $ f $ will increase and be sorted. &lt;/p&gt;

&lt;p&gt;We also know $ 0 &amp;lt;= x, y &amp;lt;= Z $; thus, we can create a matrix that has $ z + 1 $ rows and $ z + 1 $ columns. And each cell will be the result of $ f (x, y) $, where $ x $ is the row number and $ y $ is the column number.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/matrix-1.jpg&quot; alt=&quot;matrix&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The best thing from this matrix is that &lt;strong&gt;all rows are sorted and so are all columns&lt;/strong&gt;. The reason is that $ f $ is a strictly increasing function on $ x $ and $ y $.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/sorted_matrix.jpg&quot; alt=&quot;sorted_matrix&quot;/&gt;&lt;/p&gt;

&lt;p&gt;This matrix converts the original problem to the one that &lt;strong&gt;now we have a board of unrevealed cards and we need to seek for an efficient strategy to find all cards that we want&lt;/strong&gt;. &lt;/p&gt;

&lt;p&gt;The trivial solution in the previous section has a simplest strategy: simply reveal all cards one by one and collect all that are satisfying.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/trivial.jpg&quot; alt=&quot;trivial&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;Zig-zag&lt;/h1&gt;

&lt;p&gt;Let's take an example simple function $ f (x, y) = x * y $ and assume $ z = 6 $. &lt;/p&gt;

&lt;p&gt;If we employ the trivial solution, then of course we will find all cards we want.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/zig_zag_1.jpg&quot; alt=&quot;zig_zag_1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;However, we can see that we need to reveal $ 36 $ cards for $ 4 $ targets. &lt;br/&gt;
&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/zig_zag_2.jpg&quot; alt=&quot;zig_zag_2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;What a waste! But how can we improve it?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Maybe just start from somewhere, reveal one card, depend on its value and then decide which next card to reveal?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let's just try starting from the most natural place - the top-left corn, where $ x = 0, y = 0 $.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/zig_zag_3-2.jpg&quot; alt=&quot;zig_zag_3&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We get $ R $.  &lt;/li&gt;
&lt;li&gt;If $ R &amp;gt; z $, our problem is solved. This is because the 3 possible next cards must be bigger than $ R $ as the bigger $ x $ or $ y $ are the larger the results are. So we do not need to move any more.  &lt;/li&gt;
&lt;li&gt;What if $ R &amp;lt; z $? then we have to try to reveal all 3 cards, which makes not much sense since we may still anyway reveal all cards.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We need a better way.&lt;/p&gt;

&lt;h2&gt;Target sum of two sorted lists&lt;/h2&gt;

&lt;p&gt;Before we continue to think, let's try another simpler problem first.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a value &lt;code&gt;k&lt;/code&gt; and two sorted lists of integers (all being distinct), find all pairs of integers &lt;code&gt;(i, j)&lt;/code&gt; where &lt;code&gt;i + j == k&lt;/code&gt;.&lt;/p&gt;
  
  &lt;p&gt;For example, &lt;code&gt;[1; 2; 8; 12; 20]&lt;/code&gt; and &lt;code&gt;[3; 6; 9; 14; 19]&lt;/code&gt; and &lt;code&gt;k = 21&lt;/code&gt; is given, we should return &lt;code&gt;[(2, 19); (12, 9)]&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Of course, we can just scan all possible pairs to see. But it is not efficient and we waste the execellent hint: &lt;em&gt;sorted&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;Since sorted list is the fundamental condition for &lt;em&gt;merge&lt;/em&gt;, how about we try to do something similar? Let's put two sorted lists in parallel and for the first two elements $ 1 $ and $ 3 $, we know $ 1 + 3 = 4 &amp;lt; 21 $. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/sorted_list_1-3.jpg&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;It is too small at this moment, what should we do? We know we should move rightwards to increase, but do we move along &lt;code&gt;list 1&lt;/code&gt; or &lt;code&gt;list 2&lt;/code&gt; or both? &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/sorted_list_2-2.jpg&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We don't know actually, because each possible movement may give us chances to find good pairs. If we just take all possible movements, then it makes no sense as in the end as it will just try every possible pair. Hence, we just need to find a way to restrict our choices of movements.&lt;/p&gt;

&lt;p&gt;How about we put one list in its natural order and put the other in its reversed order?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/sorted_list_3-3.jpg&quot; alt=&quot;3&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Now, $ 1 + 19 = 20 &amp;lt; 21 $. It is again too small. What shall we do? Can we move along &lt;code&gt;list 2&lt;/code&gt;? We cannot, because the next element there is definitely smaller and if we move along, we will get even smaller sum. So moving along &lt;code&gt;list 1&lt;/code&gt; is our only option.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;i + j = k&lt;/code&gt;, then good, we collect &lt;code&gt;(i, j)&lt;/code&gt;. How about the next move? We cannot just move along any single list because the future sum will forever be either bigger than &lt;code&gt;k&lt;/code&gt;  or smaller. Thus, we move along both because only through increasing &lt;code&gt;i&lt;/code&gt; and decreasing &lt;code&gt;j&lt;/code&gt; may give us changes to find the target sum again.&lt;/p&gt;

&lt;p&gt;What if &lt;code&gt;i + j &amp;gt; k&lt;/code&gt;? It is easy to see that the only option for us is the next element in &lt;code&gt;list 2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/sorted_list_4-1.jpg&quot; alt=&quot;4&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;One ascending and the other descending, always&lt;/h2&gt;

&lt;p&gt;Let's come back to our &lt;em&gt;sorted&lt;/em&gt; matrix problem. We do not have simple two sorted lists any more, but it is not difficult to see that we should &lt;strong&gt;start from bottom-left corner&lt;/strong&gt; (rows are descending and columns are ascending). And depending on what we get from $ R = f (x, y) $, we just change direction (either up, right-up or right), and towards the top-right corner:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We move &lt;em&gt;right&lt;/em&gt; along $ y $ until we reach the &lt;em&gt;ceiling&lt;/em&gt; (the smallest number that is bigger than $ z $), and then change to &lt;em&gt;up&lt;/em&gt;  &lt;/li&gt;
&lt;li&gt;We move &lt;em&gt;up&lt;/em&gt; along $ x $ until we reach the &lt;em&gt;floor&lt;/em&gt; (the bigger number that is smaller than $ z $), and then change to &lt;em&gt;right&lt;/em&gt;  &lt;/li&gt;
&lt;li&gt;Whenever we reach $ R = f (x, y) = z $, we change to &lt;em&gt;right-up&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We can use an example to explain why we want the &lt;em&gt;ceiling&lt;/em&gt; (similarly explaining why the &lt;em&gt;floor&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/zigzag_binarysearch_y.jpg&quot; alt=&quot;binary_search_1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;When we reach the &lt;em&gt;ceiling&lt;/em&gt;, we know all cells on its left can be dicarded because those are definitely smaller than $ z $.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/zig_zag_4.jpg&quot; alt=&quot;start_point&quot;/&gt;&lt;/p&gt;

&lt;p&gt;In this way, the card revealing process for $ f (x, y) = x * y $ looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/matrix_example.jpg&quot; alt=&quot;example&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let find_all_zigzag f z =  
  let rec aux acc x y =
    if x &amp;lt; 0 || y &amp;gt; z then acc
    else
      let r = f x y in
      if r &amp;lt; z then aux acc x (y+1) 
      else if r&amp;gt; z then aux acc (x-1) y
      else aux (r::acc) (x-1) (y+1)
  in
  aux [] z 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The time complexity is $ O(Z) $ and in the worst case, we need to calculate $ 2 * Z + 1 $ times of $ f $.&lt;/p&gt;

&lt;p&gt;This solution is a linear one and there is still room for improvement.&lt;/p&gt;

&lt;h2&gt;A same problem with slightly different appearance&lt;/h2&gt;

&lt;p&gt;There is a quite popular interview question which is very similar to the pearl 3.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;We have a matrix of numbers. All rows are sorted and so are all columns. Find the coordinates of a given number.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Although it seems all numbers are already computed and put in the matrix, both this problem and pearl 3 are actually identical.&lt;/p&gt;

&lt;h1&gt;Zig-zag + Binary Search&lt;/h1&gt;

&lt;p&gt;Zig-zag solution is actually scan along $ x $ axis and $ y $ axis by turns. The scan on each turn is linear. But wait, each row and column are sorted, right? Does it ring a bell?&lt;/p&gt;

&lt;p&gt;When a sequence of elements are sorted, and if we have a target to find, then we of course can try &lt;em&gt;binary search&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Simply say, in order to improve the &lt;em&gt;zig-zag&lt;/em&gt; solution, we just replace the &lt;em&gt;linear scan&lt;/em&gt; part with &lt;em&gt;binary search&lt;/em&gt;. &lt;/p&gt;

&lt;h2&gt;Targets of binary search&lt;/h2&gt;

&lt;p&gt;For each round of binary search, we cannot just search for the given value of $ z $ only. Instead, &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Our target is the &lt;strong&gt;ceiling&lt;/strong&gt; when we binary search &lt;strong&gt;horizontally&lt;/strong&gt;, i.e., along $ y $, from left to right.  &lt;/li&gt;
&lt;li&gt;Our target is the &lt;strong&gt;floor&lt;/strong&gt; when we binary search &lt;strong&gt;vertically&lt;/strong&gt;, i.e., along $ x $, from down to up.  &lt;/li&gt;
&lt;li&gt;During our search, if we find a target card, we can simply stop.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Eventually stops at ceiling or floor or equal&lt;/h2&gt;

&lt;p&gt;The next question is &lt;em&gt;when a round of binary search stops?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When we reach an card equal to $ z $, of course we can stop immediately.&lt;/p&gt;

&lt;p&gt;If we never reach an ideal card, then anyway the search will stop because there will eventually be no room on either left side or right side to continue. And that stop point will definitely be the &lt;em&gt;ceiling&lt;/em&gt; or the &lt;em&gt;floor&lt;/em&gt; of $ z $. &lt;/p&gt;

&lt;p&gt;Again, because we need the &lt;em&gt;ceiling&lt;/em&gt; for &lt;em&gt;horizon&lt;/em&gt; and &lt;em&gt;floor&lt;/em&gt; for &lt;em&gt;vertical&lt;/em&gt;, we need to adjust it after we finish the binary search.&lt;/p&gt;

&lt;h2&gt;Code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type direction = H | V

let rec binary_search z g p q =  
  if p + 1 &amp;gt;= q then p
  else
    let m = (p + q) / 2 in
    let r = g m in
    if r = z then m
    else if r &amp;gt; z then binary_search z g p (m-1)
    else binary_search z g (m+1) q

(* adjust ceiling or floor *)
let next_xy z f x y direction =  
  let r = f x y in
  match direction with
    | _ when r = z -&amp;gt; x, y
    | H when r &amp;gt; z -&amp;gt; x-1, y
    | H -&amp;gt; x-1, y+1
    | V when r &amp;lt; z -&amp;gt; x, y+1
    | V -&amp;gt; x-1, y+1

let find_all_zigzag_bs f z =  
  let rec aux acc (x, y) =
    if x &amp;lt; 0 || y &amp;gt; z then acc
    else 
      let r = f x y in
      if r = z then aux (f x y::acc) (x-1, y+1)
      else if r &amp;lt; z then 
        let k = binary_search z (fun m -&amp;gt; f x m) y z in
        aux acc (next_xy z f x k H)
      else
        let k = binary_search z (fun m -&amp;gt; f m y) 0 x in
        aux acc (next_xy z f k y V)
  in
  aux [] (z, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Why called Saddleback&lt;/h1&gt;

&lt;p&gt;The reason why this pearl is called &lt;em&gt;Saddleback Search&lt;/em&gt; is (quoted from the &lt;a href=&quot;http://www.amazon.co.uk/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383/ref=sr_1_1?ie=UTF8&amp;amp;qid=1427413337&amp;amp;sr=8-1&amp;amp;keywords=pearls%20functional&quot;&gt;book&lt;/a&gt;), &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(It is) an important search strategy, dubbed saddleback search by David Gries... &lt;/p&gt;
  
  &lt;p&gt;I imagine Gries called it that because the shape of the three-dimensional plot of f , with the smallest element at the bottom left, the largest at the top right and two wings, is a bit like a saddle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, if we plot $ f (x, y) = x * y $ , we can see &lt;a href=&quot;http://www.livephysics.com/tools/mathematical-tools/online-3-d-function-grapher/?xmin=-1&amp;amp;xmax=1&amp;amp;ymin=-1&amp;amp;ymax=1&amp;amp;zmin=Auto&amp;amp;zmax=Auto&amp;amp;f=x*y&quot;&gt;this&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/plot.jpg&quot; alt=&quot;plot&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Does it look like a saddle?&lt;/p&gt;</content><id>http://typeocaml.com/2015/03/31/pearl-no-3-saddleback-search/</id><title type="text">Pearl No.3 - Saddleback Search</title><updated>2015-03-31T17:30:00-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2015/03/17/binomial-heap/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/binomial_heap.jpg#hero&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;As we described in the previous post, leftist tree is a binary tree based functional heap. It manipulates the tree structure so that the left branches are always the longest and operations follow the right branches only. It is a clever and simple data structure that fulfills the purpose of heap. &lt;/p&gt;

&lt;p&gt;In this post, we present another functional heap called &lt;a href=&quot;http://en.wikipedia.org/wiki/Binomial_heap&quot;&gt;Binomial Heap&lt;/a&gt; (&lt;em&gt;[1]&lt;/em&gt;). Instead of being a single tree strucutre, it is a list of &lt;em&gt;binomial tree&lt;/em&gt;s and it provides better performance than leftist tree on &lt;em&gt;insert&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;However, the reason I would like to talk about it here is not because of its efficiency. The fascination of binomial heap is that &lt;strong&gt;if there are N elements inside it, then it will have a determined shape, no matter how it ended up with the N elements&lt;/strong&gt;. Personally I find this pretty cool. This is not common in tree related data structures. For example, we can not predict the shape of a leftist tree with N elements and the form of a binary search tree can be arbitrary even if it is somehow balanced. &lt;/p&gt;

&lt;p&gt;Let's have a close look at it.&lt;/p&gt;

&lt;h1&gt;Binomial Tree&lt;/h1&gt;

&lt;p&gt;Binomial tree is the essential element of binomial heap. Its special structure is why binomial heap exists. Understanding binomial tree makes it easier to understand binomial heap.&lt;/p&gt;

&lt;p&gt;Binomial tree's definition does not involve the values associated with the nodes, but just the structure:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It has a rank &lt;em&gt;r&lt;/em&gt; and &lt;em&gt;r&lt;/em&gt; is a natural number.  &lt;/li&gt;
&lt;li&gt;Its form is &lt;em&gt;a root node&lt;/em&gt; with &lt;em&gt;a list of binomial trees&lt;/em&gt;, whose ranks are strictly &lt;em&gt;r-1&lt;/em&gt;, &lt;em&gt;r-2&lt;/em&gt;, ..., &lt;em&gt;0&lt;/em&gt;.  &lt;/li&gt;
&lt;li&gt;A binomial tree with rank &lt;em&gt;0&lt;/em&gt; has only one root, with an empty list.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let's try producing some examples.&lt;/p&gt;

&lt;p&gt;From point 3, we know the base case:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/rank_0.jpg&quot; alt=&quot;rank_0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Now, how about &lt;em&gt;rank 1&lt;/em&gt;? It should be a root node with a sub binomial tree with rank &lt;code&gt;1 - 1 = 0&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/rank_1-1.jpg&quot; alt=&quot;rank_1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Let's continue for &lt;em&gt;rank 2&lt;/em&gt;, which should have &lt;em&gt;rank 1&lt;/em&gt; and &lt;em&gt;rank 0&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/rank_2.jpg&quot; alt=&quot;rank_2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Finally &lt;em&gt;rank 3&lt;/em&gt;, can you draw it?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/rank_3.jpg&quot; alt=&quot;rank_3&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;$ 2^r $ nodes&lt;/h2&gt;

&lt;p&gt;If we pull up the left most child of the root, we can see:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/r_2_r-1-3.jpg&quot; alt=&quot;r_2_r-1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;This means a binomial tree with rank &lt;em&gt;r&lt;/em&gt; can be seen as &lt;em&gt;two&lt;/em&gt; binomial trees with the same rank &lt;em&gt;r-1&lt;/em&gt;. Furthermore, because that &lt;em&gt;two&lt;/em&gt;, and rank &lt;em&gt;0&lt;/em&gt; has one node, then in term of the number of nodes, for a binomial tree with &lt;strong&gt;rank &lt;em&gt;r&lt;/em&gt;, it must have $ 2^r $ nodes, no more, no less&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;For example, rank &lt;em&gt;0&lt;/em&gt; has 1 node. Rank &lt;em&gt;1&lt;/em&gt; is 2 &lt;em&gt;rank 0&lt;/em&gt;, so rank &lt;em&gt;1&lt;/em&gt; has $ 2 * 1 = 2 $ nodes, right? Rank &lt;em&gt;2&lt;/em&gt; then has $ 2 * 2 = 4 $ nodes, and so on so forth.&lt;/p&gt;

&lt;p&gt;Note that $ 2^r = 1 + 2^r-1 + 2^r-2 + ... + 2^0 $ and we can see that a rank &lt;em&gt;r&lt;/em&gt; tree's structure fits exactly to this equation (the &lt;em&gt;1&lt;/em&gt; is the root and the rest is the children list). &lt;/p&gt;

&lt;h2&gt;Two &lt;em&gt;r-1&lt;/em&gt; is the way to be &lt;em&gt;r&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;The definition tells us that a rank &lt;em&gt;r&lt;/em&gt; tree is a root plus a list of trees of rank &lt;em&gt;r-1&lt;/em&gt;, &lt;em&gt;r-2&lt;/em&gt;, ..., and &lt;em&gt;0&lt;/em&gt;. So if we have a binomial tree with an arbitrary rank, can we just insert it to another target tree to form a rank &lt;em&gt;r&lt;/em&gt; tree?&lt;/p&gt;

&lt;p&gt;For example, suppose we have a rank &lt;em&gt;1&lt;/em&gt; tree, can we insert it to the target tree below for a rank &lt;em&gt;3&lt;/em&gt; tree?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/wrong_way.jpg&quot; alt=&quot;wrong&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately we cannot, because the target tree won't be able to exist in the first place and it is not a valid binomial tree, is it?&lt;/p&gt;

&lt;p&gt;Thus in order to have a rank &lt;em&gt;r&lt;/em&gt; tree, we must have two &lt;em&gt;r-1&lt;/em&gt; trees and link them together. When linking, we need to decide which tree is the new root, depending on the context. For the purpose of building a &lt;em&gt;min heap&lt;/em&gt; later, we assume we always let the root with the &lt;em&gt;smaller&lt;/em&gt; key be the root of the new tree.&lt;/p&gt;

&lt;h2&gt;code&lt;/h2&gt;

&lt;p&gt;Defining a binomial tree type is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* Node of key * child_list * rank *)
type 'a binomial_t = Node of 'a * 'a binomial_t list * int  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also we can have a function for a singleton tree with rank &lt;em&gt;0&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let singleton_tree k = Node (k, [], 0)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we must have &lt;code&gt;link&lt;/code&gt; function which promote two trees with same ranks to a higher rank tree.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let link ((Node (k1, c1, r1)) as t1) ((Node (k2, c2, r2)) as t2) =  
  if r1 &amp;lt;&amp;gt; r2 then failwith &amp;quot;Cannot link two binomial trees with different ranks&amp;quot;
  else if k1 &amp;lt; k2 then Node (k1, t2::c1, r1+1)
  else Node (k2, t1::c2, r2+1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One possibly interesting problem can be:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a list of $ 2^r $ elements, how to construct a binomial tree with rank &lt;em&gt;r&lt;/em&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can borrow the idea of &lt;em&gt;merging from bottom to top&lt;/em&gt; for this problem.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/from_list_2-1.jpg&quot; alt=&quot;from_list&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let link_pair l =  
  let rec aux acc = function
    | [] -&amp;gt; acc
    | _::[] -&amp;gt; failwith &amp;quot;the number of elements must be 2^r&amp;quot;
    | t1::t2::tl -&amp;gt; aux (link t1 t2 :: acc) tl
  in
  aux [] l

let to_binomial_tree l =  
  let singletons = List.map singleton_tree l in
  let rec aux = function
    | [] -&amp;gt; failwith &amp;quot;Empty list&amp;quot;
    | t::[] -&amp;gt; t
    | l -&amp;gt; aux (link_pair l)
  in
  aux singletons
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Binomial coefficient&lt;/h2&gt;

&lt;p&gt;If we split a binomial tree into levels and pay attention to the number of nodes on each level, we can see:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/binomial_coefficiency.jpg&quot; alt=&quot;binomial coefficient&quot;/&gt;&lt;/p&gt;

&lt;p&gt;So from top to bottom, the numbers of nodes on levels are &lt;em&gt;1&lt;/em&gt;, &lt;em&gt;3&lt;/em&gt;, &lt;em&gt;3&lt;/em&gt; and &lt;em&gt;1&lt;/em&gt;. It happens to be the coefficients of $ (x+y)^3 $ .&lt;/p&gt;

&lt;p&gt;Let's try rank &lt;em&gt;4&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/binomial_coefficiency_2.jpg&quot; alt=&quot;binomial_coefficient_2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;They are &lt;em&gt;1&lt;/em&gt;, &lt;em&gt;4&lt;/em&gt;, &lt;em&gt;6&lt;/em&gt;, &lt;em&gt;4&lt;/em&gt; and &lt;em&gt;1&lt;/em&gt;, which are the coefficients of $ (x+y)^4 $ .&lt;/p&gt;

&lt;p&gt;The number of nodes on level &lt;em&gt;k&lt;/em&gt; ( 0 &amp;lt;= &lt;em&gt;k&lt;/em&gt; &amp;lt;= &lt;em&gt;r&lt;/em&gt;) matches $ {r}\choose{k} $, which in turn matches &lt;strong&gt;the kth binomial coefficient of $ (x+y)^r $. This is how the name &lt;em&gt;binomial&lt;/em&gt; tree came from&lt;/strong&gt;.&lt;/p&gt;

&lt;h1&gt;Binomial Heap&lt;/h1&gt;

&lt;p&gt;A binomial heap is essentially a list of binomial trees with distinct ranks. It has two characteristics:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If a binomial heap has &lt;em&gt;n&lt;/em&gt; nodes, then its shape is determined, no matter what operations have been gone through it.  &lt;/li&gt;
&lt;li&gt;If a binomial heap has &lt;em&gt;n&lt;/em&gt; nodes, then the number of trees inside is &lt;code&gt;O(logn)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The reason for the above points is explained as follows.&lt;/p&gt;

&lt;p&gt;As we already knew, a binomial tree with rank &lt;em&gt;r&lt;/em&gt; has $ 2^r $ nodes. If we move to the context of binary presentation of numbers, then a rank &lt;em&gt;r&lt;/em&gt; tree stands for the case where there is a list of bits with only the &lt;em&gt;rth&lt;/em&gt; slot turned on.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/binary.jpg&quot; alt=&quot;binary&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Thus, for &lt;em&gt;n&lt;/em&gt; number of nodes, it can be expressed as a list of binomial trees with distinct ranks, because the number &lt;em&gt;n&lt;/em&gt; is actually a list of bits with various slots being &lt;em&gt;1&lt;/em&gt;. For example, suppose we have 5 nodes (ignoring their values for now), mapping to a list of binomial trees, we will have:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/binomial_heap_origin-2.jpg&quot; alt=&quot;origin&quot;/&gt;&lt;/p&gt;

&lt;p&gt;This is where binomial heap comes from. &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Since a number &lt;em&gt;n&lt;/em&gt; has determined binary presentation, a binomial heap also has fixed shape as long as it has &lt;em&gt;n&lt;/em&gt; nodes.  &lt;/li&gt;
&lt;li&gt;In addition, because &lt;em&gt;n&lt;/em&gt; has &lt;code&gt;O(logn)&lt;/code&gt; effective bits, a binomial heap has &lt;code&gt;O(logn)&lt;/code&gt; binomial trees.  &lt;/li&gt;
&lt;li&gt;If we keep each binomial tree having the min as the root, then for a binomial heap, the overall minimum elements is on of those roots.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let's now implement it.&lt;/p&gt;

&lt;h2&gt;Type and singleton&lt;/h2&gt;

&lt;p&gt;It is easy.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type 'a binomial_heap_t = 'a binomial_t list
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;insert&lt;/h2&gt;

&lt;p&gt;When we &lt;em&gt;insert&lt;/em&gt; a key &lt;code&gt;k&lt;/code&gt;, we just create a singleton binomial tree and try to insert the tree to the heap list. The rule is like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If the heap doesn't have a rank &lt;em&gt;0&lt;/em&gt; tree, then directly insert the new singleton tree (with rank &lt;em&gt;0&lt;/em&gt;) to the head of the list.  &lt;/li&gt;
&lt;li&gt;If the heap has a rank &lt;em&gt;0&lt;/em&gt; tree, then the two rank &lt;em&gt;0&lt;/em&gt; tree need to be linked and promoted to a new rank &lt;em&gt;1&lt;/em&gt; tree. And we have to continue to try to insert the rank &lt;em&gt;1&lt;/em&gt; tree with the rest of the list that potentiall starts with a existing rank &lt;em&gt;1&lt;/em&gt; tree.  &lt;/li&gt;
&lt;li&gt;If there is already a rank &lt;em&gt;1&lt;/em&gt; tree, then link and promot to rank &lt;em&gt;2&lt;/em&gt;... so on so forth, until the newly promoted tree has a slot to fit in.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here are two examples:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/insert.jpg&quot; alt=&quot;insert_1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/insert_2.jpg&quot; alt=&quot;insert_2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;insert&lt;/em&gt; operation is actually the addition between &lt;em&gt;1&lt;/em&gt; and &lt;em&gt;n&lt;/em&gt; in binary presentation, in a revered order. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let insert k h =  
  let rec aux acc (Node (_, _, r1) as bt1) = function
    | [] -&amp;gt; List.rev (bt1::acc)
    | (Node (_, _, r2) as bt2)::tl -&amp;gt;
      if r1 = r2 then aux acc (link bt1 bt2) tl
      else if r1 &amp;lt; r2 then List.rev_append acc (bt1::bt2::tl)
      else aux (bt2::acc) bt1 tl
  in
  aux [] (singleton_tree k) h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the heap is full as having a consecutive series of ranks of trees starting from rank &lt;em&gt;0&lt;/em&gt;, we need &lt;code&gt;O(logn)&lt;/code&gt; operations to finish the &lt;em&gt;insert&lt;/em&gt;. However, once it is done, most of the lower rank slots are empty (like shown in the above figure). And for later new &lt;em&gt;insert&lt;/em&gt;, it won't need &lt;code&gt;O(logn)&lt;/code&gt; any more. Thus, The time complexity of &lt;em&gt;insert&lt;/em&gt; seems to be &lt;code&gt;O(logn)&lt;/code&gt;, but &lt;strong&gt;actually amortised &lt;code&gt;O(1)&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Note the above &lt;em&gt;insert&lt;/em&gt; description is just for demonstration purpose. Like in &lt;a href=&quot;http://typeocaml.com/2015/03/12/heap-leftist-tree/&quot;&gt;Leftist tree&lt;/a&gt;, &lt;em&gt;merge&lt;/em&gt; is the most important operation for binomial heap and &lt;em&gt;insert&lt;/em&gt; is just a simpler &lt;em&gt;merge&lt;/em&gt;. &lt;/p&gt;

&lt;h2&gt;merge&lt;/h2&gt;

&lt;p&gt;The &lt;em&gt;merge&lt;/em&gt; is like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Get the two heads (&lt;code&gt;bt1&lt;/code&gt; and &lt;code&gt;bt2&lt;/code&gt;) out of two heaps (&lt;code&gt;h1&lt;/code&gt; and &lt;code&gt;h2&lt;/code&gt;).  &lt;/li&gt;
&lt;li&gt;If &lt;code&gt;rank bt1 &amp;lt; rank bt2&lt;/code&gt;, then &lt;code&gt;bt1&lt;/code&gt; leaves first and continue to merge &lt;code&gt;the rest of h1&lt;/code&gt; and &lt;code&gt;h2&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;If &lt;code&gt;rank bt1 &amp;gt; rank bt2&lt;/code&gt;, then &lt;code&gt;bt2&lt;/code&gt; leaves first and continue to merge &lt;code&gt;h1&lt;/code&gt; and &lt;code&gt;the rest of h2&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;If &lt;code&gt;rank bt1 = rank bt2&lt;/code&gt;, then &lt;code&gt;link bt1 bt2&lt;/code&gt;, add the new tree to &lt;code&gt;the rest of h1&lt;/code&gt; and merge the new &lt;code&gt;h1&lt;/code&gt; and &lt;code&gt;the rest of h2&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I will skip the digram and directly present the code here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec merge h1 h2 =  
  match h1, h2 with
  | h, [] | [], h -&amp;gt; h
  | (Node (_, _, r1) as bt1)::tl1, (Node (_, _, r2) as bt2)::tl2 -&amp;gt;
    if r1 &amp;lt; r2 then bt1::merge tl1 h2
    else if r1 &amp;gt; r2 then bt2::merge h1 tl2
    else merge (link bt1 bt2::tl1) tl2

(* a better and simpler version of insert *)
let insert' k h = merge [singleton_tree k] h  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The time complexity is &lt;code&gt;O(logn)&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;get_min&lt;/h2&gt;

&lt;p&gt;We just need to scan all roots and get the min key.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let get_min = function  
  | [] -&amp;gt; failwith &amp;quot;Empty heap&amp;quot;
  | Node (k1, _, _)::tl -&amp;gt;
    List.fold_left (fun acc (Node (k, _, _)) -&amp;gt; min acc k) k1 tl
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;For achieve &lt;code&gt;O(1)&lt;/code&gt;, we can attach a &lt;code&gt;minimum&lt;/code&gt; property to the heap's type. It will always record the min and can be returned immediately if requested. However, we need to update this property when &lt;em&gt;insert&lt;/em&gt;, &lt;em&gt;merge&lt;/em&gt; and &lt;em&gt;delete_min&lt;/em&gt;. Like every other book does, this modification is left to the readers as an exercise.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;delete_min&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;delete_min&lt;/em&gt; appears as a little bit troublesome but actually very neat. &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We need to locate the binomial tree with &lt;em&gt;min&lt;/em&gt;.  &lt;/li&gt;
&lt;li&gt;Then we need to merge &lt;code&gt;the trees on its left&lt;/code&gt; and &lt;code&gt;the trees on its right&lt;/code&gt; to get a new list.  &lt;/li&gt;
&lt;li&gt;It is not done yet as we need to deal with the &lt;em&gt;min&lt;/em&gt; binomial tree.  &lt;/li&gt;
&lt;li&gt;We are lucky that &lt;strong&gt;a binomial tree's child list is a heap indeed&lt;/strong&gt;. So we just need to merge &lt;code&gt;the child list&lt;/code&gt; with the new list from point 2.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let key (Node (k, _, _)) = k  
let child_list (Node (_, c, _)) = c

let split_by_min h =  
  let rec aux pre (a, m, b) = function
    | [] -&amp;gt; List.rev a, m, b
    | x::tl -&amp;gt;
      if key x &amp;lt; key m then aux (x::pre) (pre, x, tl) tl
      else aux (x::pre) (a, m, b) tl
  in
  match h with 
    | [] -&amp;gt; failwith &amp;quot;Empty heap&amp;quot;
    | bt::tl -&amp;gt; aux [bt] ([], bt, []) tl

let delete_min h =  
  let a, m, b = split_by_min h in
  merge (merge a b) (child_list m |&amp;gt; List.rev)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Binomial Heap vs Leftist Tree&lt;/h1&gt;

&lt;pre&gt;
|               | get_min                                 | insert         | merge   | delete_min |
|---------------|-----------------------------------------|----------------|---------|------------|
| Leftist tree  | O(1)                                    | O(logn)        | O(logn) | O(logn)    |
| Binomial heap | O(logn), but can be improved to be O(1) | Amortised O(1) | O(logn) | O(logn)    |

&lt;/pre&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;[1]&lt;/strong&gt; Binomial Heap is also introduced in &lt;a href=&quot;http://www.amazon.co.uk/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&amp;amp;qid=1426283477&amp;amp;sr=8-1&amp;amp;keywords=functional%20data%20structure&quot;&gt;Purely Functional Data Structures&lt;/a&gt;.&lt;/p&gt;</content><id>http://typeocaml.com/2015/03/17/binomial-heap/</id><title type="text">Binomial Heap</title><updated>2015-03-18T00:07:39-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2015/03/12/heap-leftist-tree/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/leftist.jpg#hero&quot; alt=&quot;leftist&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;Heap&lt;/a&gt; is one of most important data structure, where the minimum of all elements can always be easily and efficiently retrieved. &lt;/p&gt;

&lt;h1&gt;Binary Heap&lt;/h1&gt;

&lt;p&gt;In imperative world, &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_heap&quot;&gt;binary heap&lt;/a&gt; (implemented via &lt;em&gt;array&lt;/em&gt;) is frequently used. Here is an example:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/binary_heap-2.jpg&quot; alt=&quot;binary_heap&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The (min) heap on the right hand side is a full binary tree indeed. The root is always the min and recursively, a root (of any sub tree) is always smaller than its two children. Note that &lt;strong&gt;we just need to keep partial order for heap&lt;/strong&gt;, not total order like binary search tree. For example, &lt;code&gt;1&lt;/code&gt; needs to be smaller than its two children, but the relationship between the two children does not matter. Thus, the left child and right child can be either &lt;code&gt;10&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;. Moreover, the big node &lt;code&gt;17&lt;/code&gt; can be in the right branch of &lt;code&gt;1&lt;/code&gt; while its parent &lt;code&gt;3&lt;/code&gt; is smaller than &lt;code&gt;10&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;The array based implementation is actually beautiful. Essentially, it uses two tricks to simulate the binary heap tree:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If the index of a root is &lt;code&gt;i&lt;/code&gt;, then its left child index is &lt;code&gt;2*i+1&lt;/code&gt; and right child index is &lt;code&gt;2*i+2&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;The relationship of left child and right child is not important, so the two child slots in the array for a root can be fully used. (&lt;em&gt;Can we use array to implement a binary search tree?&lt;/em&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The time complexities on operations are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;get_min&lt;/em&gt;: &lt;code&gt;O(1)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;insert&lt;/em&gt;: &lt;code&gt;O(logn)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;delete_min&lt;/em&gt;: &lt;code&gt;O(logn)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;merge&lt;/em&gt;: &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Although its &lt;code&gt;merge&lt;/code&gt; is not satisfying, this data structure is adorable and gives us the most compact space usage on array. &lt;/p&gt;

&lt;p&gt;However, unfortunately we cannot have it in pure functional world where mutable array is not recommended. &lt;/p&gt;

&lt;h1&gt;List based heap&lt;/h1&gt;

&lt;p&gt;I would like to first explore two possible functional approaches for heap (the list based in this section and the direct binary tree based in next section) . They are trivial or even incomplete, but the ideas behind may lead to the invention of leftist tree. &lt;/p&gt;

&lt;p&gt;List is basically the replacement of array in functional world and of course, we can use it for heap. The idea is simple:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;When &lt;em&gt;insert&lt;/em&gt; &lt;code&gt;x&lt;/code&gt;, linearly compare &lt;code&gt;x&lt;/code&gt; with all existing elements one by one and insert it to the appropriate place where the element on its left hand side is smaller and the element on its right is equal or bigger.  &lt;/li&gt;
&lt;li&gt;When &lt;em&gt;get_min&lt;/em&gt;, it is as simple as returning the head.  &lt;/li&gt;
&lt;li&gt;When &lt;em&gt;delete_min&lt;/em&gt;, remove the head.  &lt;/li&gt;
&lt;li&gt;When &lt;em&gt;merge&lt;/em&gt;, do a standard &lt;em&gt;merge&lt;/em&gt; like in &lt;em&gt;mergesort&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The time complexities are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;get_min&lt;/em&gt;: &lt;code&gt;O(1)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;insert&lt;/em&gt;: &lt;code&gt;O(n)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;delete_min&lt;/em&gt;: &lt;code&gt;O(1)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;merge&lt;/em&gt;: &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/list_based-2.jpg&quot; alt=&quot;list_based&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We can see that in this design, the list is fully sorted all the time. And also it is a tree, with just one branch always. &lt;/p&gt;

&lt;p&gt;Of course, the performance of &lt;em&gt;insert&lt;/em&gt; and &lt;em&gt;merge&lt;/em&gt; is &lt;code&gt;O(n)&lt;/code&gt; which is unacceptable. This is due to the adoption of just one leg which is crowded with elements and all elements have to be in their natural order to fit in (remember a parent must be smaller than its kid(s)?). Eventually the fact of &lt;em&gt;total order is not necessary&lt;/em&gt; is not leveraged at all. &lt;/p&gt;

&lt;p&gt;Hence, we need &lt;strong&gt;at least two branches&lt;/strong&gt; so that we may be able to spread some elements into different branches and the comparisons of the children of a root may be avoided. &lt;/p&gt;

&lt;h1&gt;Binary Heap not using array&lt;/h1&gt;

&lt;p&gt;Since the array based binary heap is a binary tree, how about implementing it directly in a binary tree form?&lt;/p&gt;

&lt;p&gt;We can define a binary tree heap like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type 'a bt_heap_t =  
  | Leaf
  | Node of 'a * 'a bt_heap_t * 'a bt_heap_t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The creation of the type is easy, but it is hard to implement those operations. Let's take &lt;em&gt;insert&lt;/em&gt; as an example.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/binary_tree_heap.jpg&quot; alt=&quot;insert&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;attempt 1&lt;/em&gt; in the diagram above illustrates the idea behind the array based binary heap. When we insert an element, ideally we should put it in the last available place at the bottom level or the first place at a brand new level if already full, then we do a &lt;em&gt;pull up&lt;/em&gt; by comparing and swapping with parents one by one. Obviously, we cannot do it in a pure tree structure since it is not efficient to find the initial place.&lt;/p&gt;

&lt;p&gt;So let's try &lt;em&gt;attempt 2&lt;/em&gt; by directly try to insert from top to bottom. So in the example, &lt;code&gt;2 &amp;lt; 6&lt;/code&gt; so &lt;code&gt;2&lt;/code&gt; stays and &lt;code&gt;6&lt;/code&gt; should continue going down. However, the question now is &lt;strong&gt;which branch it should take?&lt;/strong&gt; &lt;code&gt;10&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;? This is not trivial to decide and we have to find a good rule.  &lt;/p&gt;

&lt;p&gt;We will also have problem in &lt;em&gt;delete_min&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/binary_tree_heap_delete.jpg&quot; alt=&quot;delete_min&quot;/&gt;&lt;/p&gt;

&lt;p&gt;If we delete the root (min), then we will have two binary trees. Then the question is how to merge them? Do we just take all elements of one of the trees, and insert every element into the other tree? Will this way be efficient even if we are able to design a good &lt;em&gt;insert&lt;/em&gt;? &lt;/p&gt;

&lt;p&gt;If we consider &lt;em&gt;insert&lt;/em&gt; as &lt;em&gt;merge&lt;/em&gt; with a single node tree, then the problem of &lt;em&gt;insert&lt;/em&gt; becomes the problem of &lt;em&gt;merge&lt;/em&gt;, just like &lt;em&gt;delete_min&lt;/em&gt;. &lt;strong&gt;Should we design a good &lt;em&gt;merge&lt;/em&gt; so that both &lt;em&gt;insert&lt;/em&gt; and &lt;em&gt;delete_min&lt;/em&gt; are naturally solved&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;Bear all those questions in mind, and now we can start look at leftist tree.&lt;/p&gt;

&lt;h1&gt;Leftist Tree&lt;/h1&gt;

&lt;p&gt;The concerns in answering those questions in the previous section are majorly about the performance. We are dealing with a tree. How the tree getting structure or transformed along the time is very important and it affects the performance a lot.&lt;/p&gt;

&lt;p&gt;For example, for the question of &lt;em&gt;which branch to take when inserting&lt;/em&gt;, if we just always go left, then the left branch will be longer and longer if we insert lots of elements, and the time complexity becomes &lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also when merging, the two trees are already heaps, i.e., the elements and structure of either tree obeys the principle that a parent must be smaller than its children. Why do we need to destory one tree completely? Why not try to keep the structures of two trees untouched as much as possible? If we can somehow attach a root from one tree directly under a root of another tree, then all children under the first root can stay still and no operations are necessary for them. &lt;/p&gt;

&lt;p&gt;Let's see how leftist tree is designed to make sure the good performance.&lt;/p&gt;

&lt;h2&gt;Left always longer&lt;/h2&gt;

&lt;p&gt;Leftist tree always keeps the left branches of all roots being the longer and in worst case, they are as long as the right branches. In other word, all right branches of all roots are shortest. This makes sense. When we decide which branch to go, if we know one branch is always shorter than the other, then we should take it. This is because shorter branch means potentially less nodes and the number of future possible operations intends to be smaller. &lt;/p&gt;

&lt;p&gt;In order to maintain this property, each node has a &lt;strong&gt;rank&lt;/strong&gt;, which indidates &lt;strong&gt;the length of the path between the node and the right most leaf&lt;/strong&gt;. For example, &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/leftist_rank.jpg&quot; alt=&quot;rank&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The way of keep ranks up-to-date is like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We always assume &lt;code&gt;the rank of the right child &amp;lt;= the rank of the left child&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;So we always go right.  &lt;/li&gt;
&lt;li&gt;If we reach a leaf, then we replace the leaf with our &lt;em&gt;element&lt;/em&gt; and update the ranks of all the parents back to the root. Note that the &lt;em&gt;element&lt;/em&gt; in this context is not necessarily the original new element which is being inserted and we will explain it soon.  &lt;/li&gt;
&lt;li&gt;When updating the rank of a parent, we first compare the rank of left &lt;code&gt;rank_left&lt;/code&gt; and the rank of right &lt;code&gt;rank_right&lt;/code&gt;. If &lt;code&gt;rank_left &amp;lt; rank_right&lt;/code&gt;, then we swap the left child and the right child and update the rank of the parent to be &lt;code&gt;rank_left + 1&lt;/code&gt;; other wise &lt;code&gt;rank_right + 1&lt;/code&gt; &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A diagram is better than hundreds of words. Let's build a leftist by inserting two elements.&lt;/p&gt;

&lt;h2&gt;Insert&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/leftist_insert-2.jpg&quot; alt=&quot;insert&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We can see that by always putting the higher rank to the left can make the right branch being shortest all the time. Actually, this strategy is how this design of tree based heap got the name &lt;em&gt;leftist&lt;/em&gt;, i.e., more nodes intend to be on the left side. &lt;/p&gt;

&lt;p&gt;But this is not the full story of leftist. Actually, although the diagram above describes &lt;em&gt;insert&lt;/em&gt;, it is just for the purpose of demonstration of how ranks are updated. &lt;/p&gt;

&lt;p&gt;In leftist tree, the most important operation is &lt;em&gt;merge&lt;/em&gt; and an &lt;em&gt;insert&lt;/em&gt; is just a &lt;em&gt;merge&lt;/em&gt; with a singleton tree that has only the new element and two leaves.&lt;/p&gt;

&lt;h2&gt;Merge&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Merge&lt;/em&gt; is a recursive operation.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We have two trees to merge: &lt;code&gt;merge t1 t2&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Compare two roots, if &lt;code&gt;k1 &amp;gt; k2&lt;/code&gt;, we simply switch two trees by &lt;code&gt;merge t2 t1&lt;/code&gt;. This is to make sure the tree on the left always has smaller key, for conveniences.  &lt;/li&gt;
&lt;li&gt;Since &lt;code&gt;t1&lt;/code&gt; has smaller key, its root should stay as the new root.  &lt;/li&gt;
&lt;li&gt;Because &lt;code&gt;t1&lt;/code&gt;'s right branch &lt;code&gt;r&lt;/code&gt; is always shortest, we then do &lt;code&gt;merge r t2&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;If one of the two trees is leaf, we simply returns the other. And begin the rank updating process back to the root.  &lt;/li&gt;
&lt;li&gt;The rank updating is the same as we described in the previous section.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Again, let's see an example.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/03/leftist_merge.jpg&quot; alt=&quot;merge&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Code&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type 'a leftist =  
  | Leaf 
  | Node of 'a leftist * 'a * 'a leftist * int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;essentials&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let singleton k = Node (Leaf, k, Leaf, 1)

let rank = function Leaf -&amp;gt; 0 | Node (_,_,_,r) -&amp;gt; r  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;merge&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec merge t1 t2 =  
  match t1,t2 with
    | Leaf, t | t, Leaf -&amp;gt; t
    | Node (l, k1, r, _), Node (_, k2, _, _) -&amp;gt;
      if k1 &amp;gt; k2 then merge t2 t1 (* switch merge if necessary *)
      else 
        let merged = merge r t2 in (* always merge with right *)
        let rank_left = rank l and rank_right = rank merged in
        if rank_left &amp;gt;= rank_right then Node (l, k1, merged, rank_right+1)
        else Node (merged, k1, l, rank_left+1) (* left becomes right due to being shorter *)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;insert, get_min, delete_min&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let insert x t = merge (singleton x) t

let get_min = function  
  | Leaf -&amp;gt; failwith &amp;quot;empty&amp;quot;
  | Node (_, k, _, _) -&amp;gt; k

let delete_min = function  
  | Leaf -&amp;gt; failwith &amp;quot;empty&amp;quot;
  | Node (l, _, r, _) -&amp;gt; merge l r
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Time complexity&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;get_min&lt;/em&gt;: &lt;code&gt;O(1)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;insert&lt;/em&gt;: &lt;code&gt;O(logn)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;delete_min&lt;/em&gt;: &lt;code&gt;O(logn)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;merge&lt;/em&gt;: &lt;code&gt;O(logn)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Leftist tree's performance is quite good. Comparing to the array based binary heap, it has a much better &lt;em&gt;merge&lt;/em&gt;. Moreover, its design and implementation are simple enough. Thus, leftist tree can an excellent choice for heap in the functional world.&lt;/p&gt;</content><id>http://typeocaml.com/2015/03/12/heap-leftist-tree/</id><title type="text">Heap - Leftist Tree</title><updated>2015-03-13T02:04:57-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2015/02/20/pearl-no-2-the-max-number-of-surpassers/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/pear-2.jpg#hero&quot; alt=&quot;pear-2&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In a list of unsorted numbers (not necessarily distinct), such as&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/problem_description_1-1.jpg&quot; alt=&quot;problem1&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The surpassers of an element are all elements whose indices are bigger and values are larger. For example, the element &lt;code&gt;1&lt;/code&gt;'s surpassers are &lt;code&gt;9&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, and &lt;code&gt;6&lt;/code&gt;, so its number of surpassers is 4. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/problem_description_2.jpg&quot; alt=&quot;problem2&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And also we can see that &lt;code&gt;9&lt;/code&gt; doesn't have any surpassers so its number of surpassers is 0. &lt;/p&gt;
  
  &lt;p&gt;So the problem of this pearl is:&lt;/p&gt;
  
  &lt;p&gt;&lt;strong&gt;Given an unsorted list of numbers, find the max number of surpassers, O(nlogn) is required.&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;In the answer for the above example is 5, for the element &lt;code&gt;-10&lt;/code&gt;. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;An easy but not optimal solution&lt;/h1&gt;

&lt;p&gt;As usual, let's put a trivial solution on the table first (&lt;em&gt;[1]&lt;/em&gt;). It is straightforward:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;For every element, we scan all elements behind it and maintain a &lt;code&gt;ns&lt;/code&gt; as its number of surpassers.  &lt;/li&gt;
&lt;li&gt;If one element is larger, then we increase the &lt;code&gt;ns&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;After we finish on all elements, the &lt;code&gt;max&lt;/code&gt; of all the &lt;code&gt;ns&lt;/code&gt;es is what we are looking for.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The diagram below demonstrates the process on &lt;code&gt;1&lt;/code&gt;. &lt;br/&gt;
&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/trivial_solution-2.jpg&quot; alt=&quot;trivial solution&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let num_surpasser p l = List.fold_left (fun c x -&amp;gt; if x &amp;gt; p then c+1 else c) 0 l

let max_num_surpasser l =  
  let rec aux ms l =
    match ms, l with
    | _, [] -&amp;gt; ms
    | None, p::tl -&amp;gt; aux (Some (p, num_surpasser p tl)) tl
    | Some (_, c), p::tl -&amp;gt; 
      let ns = num_surpasser p tl in
      if ns &amp;gt; c then aux (Some (p, ns)) tl
      else aux ms tl
  in
  aux None l

(* note think the answer as an `option` will make the code seem more complicated, but it is not a bad practice as for empty list we won't have max number of surpassers *)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution should be easy enough to obtain but its time complexity is &lt;code&gt;O(n^2)&lt;/code&gt; which is worse than the required &lt;code&gt;O(nlogn)&lt;/code&gt;. &lt;/p&gt;

&lt;h1&gt;Introducing Divide and Conquer&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/conquer-1.jpg&quot; alt=&quot;hero&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The algorithm design technique &lt;em&gt;divide and conquer&lt;/em&gt; was mentioned in &lt;a href=&quot;http://typeocaml.com/2014/12/04/recursion-reloaded/&quot;&gt;Recursion Reloaded&lt;/a&gt;. I believe it is a good time to properly introduce it now as it provides a elegant approach towards a better solution for pearl 2.&lt;/p&gt;

&lt;h2&gt;What is it, literally&lt;/h2&gt;

&lt;p&gt;Suppose we want to replace the dragon lady and become the king of the land below (&lt;em&gt;[2]&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/game_of_thrones_color-1.jpg&quot; alt=&quot;game_of_thrones&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We are very lucky that we have got a strong army and now the only question is how to overcome the realm.&lt;/p&gt;

&lt;p&gt;One &amp;quot;good&amp;quot; plan is &lt;em&gt;no plan&lt;/em&gt;. We believe in our troops so much that we can just let all of them enter the land and pwn everywhere.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/game_of_thrones_strategy_1.jpg&quot; alt=&quot;pwn&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Maybe our army is very good in terms of both &lt;em&gt;quality&lt;/em&gt; and &lt;em&gt;quantity&lt;/em&gt; and eventually this plan will lead us to win. However, is it really a good plan? Some soldiers may march to places that have already been overcome; Some soldiers may leave too soon for more wins after one winning and have to come back due to local rebel... the whole process won't be efficient and it cost too much gold on food for men and horses.&lt;/p&gt;

&lt;p&gt;Fortunately, we have a better plan.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/game_of_thrones_dragon-2.jpg&quot; alt=&quot;better&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We divide the land into smaller regions and further smaller ones inside until unnecessary. And for each small region, we put ideal amount of soldiers there for battles. After soldiers finish their assigned region, they don't need to move and just make sure the region stay with us. This is more oganised and more efficient in terms of both gold and time. After all, if we conquer all the tiny regions, who would say we were not the king?&lt;/p&gt;

&lt;h2&gt;What is it in algorithm design, with accumulation&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;divide and conquer&lt;/em&gt; in algorithm design is not a universal solution provider, but a problem attacking strategy or paradigm. Moreover, although this classic term has been lasting for quite a long time, personally I would like to add one more action - &lt;strong&gt;accumulate&lt;/strong&gt; - to make it appear more complete. Let's check the 3 actions one by one to see how we can apply the techque.&lt;/p&gt;

&lt;h3&gt;Divide&lt;/h3&gt;

&lt;p&gt;Conceptually this action is simple and we know we need to divide a big problem into smaller ones. But &lt;em&gt;how to&lt;/em&gt; is non-trivial and really context-sensitive. Generally we need to ask ourselves 2 questions first:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;What are the sizes of the smaller sub-problems?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Normally we intend to halve the problem because it can lead us to have a &lt;code&gt;O(logn)&lt;/code&gt; in our final time complexity. &lt;/p&gt;

&lt;p&gt;But it is not a must. For example &lt;a href=&quot;http://www.sorting-algorithms.com/quick-sort-3-way&quot;&gt;3-way quicksort&lt;/a&gt; divides the problem set into 3 smallers ones. 3-way partition can let quicksort have O( $ \log_3{n} $ ). However, do not forget the number of comparison also increases as we need to check equality during partition.&lt;/p&gt;

&lt;p&gt;Moreover, sometimes we may have to just split the problem into a sub-problem with size 1 and another sub-problem with the rest, like what we did for the &lt;code&gt;sum&lt;/code&gt; function. This kind of &lt;em&gt;divide&lt;/em&gt; won't give us any performance boost and it turns out to be a normal recursion design. &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Do we directly split the problem, or we somehow reshape the problem and then do the splitting?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In &lt;em&gt;mergesort&lt;/em&gt;, we simply split the problem into 2; while in &lt;em&gt;quicksort&lt;/em&gt;, we use &lt;em&gt;partition&lt;/em&gt; to rearrange the list and then obtain the 2 sub-problems. &lt;/p&gt;

&lt;p&gt;The point of this question is to bear in mind that we do not have shortcuts. We can have a very simple splitting, but later on we need to face probably more complicated &lt;em&gt;accumulate&lt;/em&gt;. Like &lt;em&gt;mergesort&lt;/em&gt; relies on &lt;em&gt;merge&lt;/em&gt;. Or, we can do our important work during &lt;em&gt;divide&lt;/em&gt; phase and have a straight &lt;em&gt;accumulate&lt;/em&gt; (&lt;em&gt;quicksort&lt;/em&gt; just needs to concatenate the solutions of the two sub-problems with the &lt;em&gt;pivot&lt;/em&gt; in the middle).&lt;/p&gt;

&lt;h3&gt;Conquer&lt;/h3&gt;

&lt;p&gt;This action implies two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Recursion. We divided the problem, then we need to conquer. How to conquer? We need to apply &lt;em&gt;divide and conquer and accumulate&lt;/em&gt; again until we are not able to divide any more.  &lt;/li&gt;
&lt;li&gt;Edge cases. This means if we cannot divide further, then it is time to really give a solution. For example, let's say our target is a list. If we reach an empty list or an one-element list, then what shall we do? Normally, if this happens, we do not need to &lt;em&gt;accumulate&lt;/em&gt; and just return the answer based on the edge cases.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I believe the &lt;em&gt;conquer&lt;/em&gt; part in the original &lt;em&gt;divide and conquer&lt;/em&gt; term also implies the &lt;em&gt;accumulate&lt;/em&gt;. I seperate &lt;em&gt;accumulate&lt;/em&gt; as explained next.&lt;/p&gt;

&lt;h3&gt;Accumulate&lt;/h3&gt;

&lt;p&gt;After we conquer every little area of the land, we should now somehow combine all our accomplishments and really build a kingdom out of them. This is the step of &lt;em&gt;accumulate&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A key way to figure out &lt;em&gt;how to accumulate&lt;/em&gt; is to &lt;strong&gt;start from small&lt;/strong&gt;. In &lt;em&gt;mergesort&lt;/em&gt;, if each of the 2 sub-problems just has one element, then the according answer is a list having that element and we have finished the &lt;em&gt;conquer&lt;/em&gt; step. Now we have two lists each of which has one element, how can we accumulate them to have a single sorted list? Simple, smaller element goes first into our resulting list. What if we have two sorted list each of which has two elements? The same, smaller element goes first again.&lt;/p&gt;

&lt;p&gt;If we decide to divide the problem in a fairly simple way, then &lt;em&gt;accumulate&lt;/em&gt; is normally non-trivial and also dominates the time complexity. Figuring out a cost-efficient approach of &lt;em&gt;accumulate&lt;/em&gt; is very important.&lt;/p&gt;

&lt;h3&gt;Summary&lt;/h3&gt;

&lt;p&gt;Again, &lt;em&gt;divide and conquer and accumulate&lt;/em&gt; is just a framework for solving an algorithm problem. All the concrete solutions are problem context based and can spread into all 3 steps. &lt;/p&gt;

&lt;p&gt;In addition, a fundamental hint to using this techqniue is that if we are given a problem, and we know the future solution is not anyhow related to the problem size, then we should try &lt;em&gt;divide and conquer and accumulate&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;Solve pearl 2&lt;/h1&gt;

&lt;p&gt;Although pearl 2 asks us to get the max number of surpassers, we can &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Get the number of surpassers for every element (we anyway need to)  &lt;/li&gt;
&lt;li&gt;Then do a linear scan for the max one. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The second step is &lt;code&gt;O(n)&lt;/code&gt;. If we can achieve the first step in &lt;code&gt;O(nlogn)&lt;/code&gt;, the overall time complexity stays as &lt;code&gt;O(nlogn)&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;So our current goal is to use &lt;em&gt;divide and conquer and accumulate&lt;/em&gt; to get all numbers of surpassers.&lt;/p&gt;

&lt;h1&gt;Divide the problem of pearl 2&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/problem_description_1-1.jpg&quot; alt=&quot;problem1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We have such as list and we want to get a new list that have the same elements and each element is associated with the number of its surpassers. Now we want to divide the original list (problem set).&lt;/p&gt;

&lt;p&gt;Can we directly halve the list?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/divide_1-3.jpg&quot; alt=&quot;divide_1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;As pearl 2 stated, an element only cares about all elements that are behind it. So if we split the list in the middle, we know the numbers of surpassers for all elements in &lt;code&gt;sub-problem 2&lt;/code&gt; do not need any special operations and the answers can directly be part of the future resulting list. &lt;/p&gt;

&lt;p&gt;For the elements inside &lt;code&gt;sub-problem 1&lt;/code&gt;, the answers are not fully accomplished yet as they will be affected by the elemnts in &lt;code&gt;sub-problem 2&lt;/code&gt;. But hey, how we obtain full answers for &lt;code&gt;sub-problem 1&lt;/code&gt; with the help of the solutions of &lt;code&gt;sub-problem 2&lt;/code&gt; should be the job of &lt;em&gt;accumulate&lt;/em&gt;, right? For now, I believe halving the problem is a good choice for &lt;em&gt;divide&lt;/em&gt; as at least we already solve half of the problem directly.&lt;/p&gt;

&lt;h1&gt;Conquer&lt;/h1&gt;

&lt;p&gt;We of course will use recursion. For sub-problems, we further halve them into smaller sub-problems until we are not able to, which means we reach the edge cases.&lt;/p&gt;

&lt;p&gt;There are possibly two edge cases we need to conquer:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Empty list  &lt;/li&gt;
&lt;li&gt;A list with only one element.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/conquer-2.jpg&quot; alt=&quot;conquer&quot;/&gt;&lt;/p&gt;

&lt;p&gt;For empty list, we just need to return an empty list as there is no element for us to count the number of surpassers. For an one-element list, we also return an one-element resulting list where the only element has &lt;code&gt;0&lt;/code&gt; surpassers.&lt;/p&gt;

&lt;h1&gt;Accumulate&lt;/h1&gt;

&lt;p&gt;Now we finished dividing and conquering like below and it is time to accumulate (take &lt;code&gt;sub-problem 1&lt;/code&gt; only for illustration).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/accumulate_1.jpg&quot; alt=&quot;accumulate 1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;It is easy to combine solutions of &lt;code&gt;sp 111&lt;/code&gt; and &lt;code&gt;sp 112&lt;/code&gt;: just compare &lt;code&gt;8&lt;/code&gt; from &lt;code&gt;sp 111&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; from &lt;code&gt;sp112&lt;/code&gt;, update &lt;code&gt;8&lt;/code&gt;'s number of surpassers if necessary and we can leave &lt;code&gt;sp 112&lt;/code&gt; alone as we talked about during &lt;em&gt;divide&lt;/em&gt;. The same way can be applied on &lt;code&gt;sp 121&lt;/code&gt; and &lt;code&gt;sp 122&lt;/code&gt;. Then we get:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/accumulate_2.jpg&quot; alt=&quot;accumulate 2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Now both &lt;code&gt;sp 11&lt;/code&gt; and &lt;code&gt;sp 12&lt;/code&gt; have more than one element. In order to get the solution for &lt;code&gt;sp 1&lt;/code&gt;, &lt;code&gt;sp 12&lt;/code&gt; can stay put. How about &lt;code&gt;sp 11&lt;/code&gt;? An obvious approach is just let every element in &lt;code&gt;sp 11&lt;/code&gt; to compare every element in &lt;code&gt;sp 12&lt;/code&gt;, and update their numbers of surpassers accordingly. This can be a candidate for &lt;em&gt;accumulate&lt;/em&gt; action, however, it is &lt;code&gt;O(n^2)&lt;/code&gt;. We need to accumulate better.&lt;/p&gt;

&lt;p&gt;We said in the very beginning of this post during our trivial solution that the original order of the list matters. However, is it still sensitive after we get the solution (for a sub-problem)? &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/accumulate_3-1.jpg&quot; alt=&quot;accumulate 3&quot;/&gt;&lt;/p&gt;

&lt;p&gt;As we can see once the answer of &lt;code&gt;sp 11&lt;/code&gt; is obtained, the order between &lt;code&gt;8&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; doesn't matter as they don't rely on each for their number of surpassers any more.&lt;/p&gt;

&lt;p&gt;If we can obtain the solution in a sorted manner, it will help us a lot. For example, assume the resulting lists for &lt;code&gt;sp 11&lt;/code&gt; and &lt;code&gt;sp 12&lt;/code&gt; are sorted like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/accumulate_4.jpg&quot; alt=&quot;accumulate 4&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Then we can avoid comparing every pair of elements by using &lt;em&gt;merge&lt;/em&gt; like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/accumulate_5-1.jpg&quot; alt=&quot;accumulate 5&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We can see that &lt;code&gt;8&lt;/code&gt; in the left hand side list doesn't have to compare to &lt;code&gt;-10&lt;/code&gt; any more. However, this example has not shown the full picture yet. &lt;strong&gt;If keep tracking the length of resulting list on the right hand side, we can save more comparisons&lt;/strong&gt;. Let's assume both &lt;code&gt;sp 1&lt;/code&gt; and &lt;code&gt;sp 2&lt;/code&gt; have been solved as sorted list with lengths attached.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/accumulate_6.jpg&quot; alt=&quot;accumulate 6&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We begin our &lt;em&gt;merge&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/accumulate_7-2.jpg&quot; alt=&quot;accumulate 7&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Have you noticed the fascinating part? Because &lt;code&gt;-10 &amp;lt; -2&lt;/code&gt;, without further going down along the resulting list on the right hand side, we can directly update the number of surpassers of &lt;code&gt;-10&lt;/code&gt; and get it out. Why? Because &lt;code&gt;-2&lt;/code&gt; is the smallest element on the right, and if it is bigger than &lt;code&gt;-10&lt;/code&gt;, then the rest of the elements on the right must all be bigger than &lt;code&gt;-10&lt;/code&gt;, right? Through only one comparison (instead of 4), we get the number of surpassers. &lt;/p&gt;

&lt;p&gt;Thus, &lt;strong&gt;as long as the solutions of all sub-problems are sorted list with the length associated, we can accumulate like this&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Compare the heads &lt;code&gt;hd1&lt;/code&gt; and &lt;code&gt;hd2&lt;/code&gt;, from two sorted resulting lists &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;, respectively  &lt;/li&gt;
&lt;li&gt;If &lt;code&gt;hd1&lt;/code&gt; &amp;gt;= &lt;code&gt;hd2&lt;/code&gt;, then &lt;code&gt;hd2&lt;/code&gt; gets out; go to 1 with updated length for &lt;code&gt;l2&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;if &lt;code&gt;hd1&lt;/code&gt; &amp;lt; &lt;code&gt;hd2&lt;/code&gt;, then &lt;code&gt;hd1&lt;/code&gt; gets out, and its &lt;code&gt;ns&lt;/code&gt; gets updated by adding the length of &lt;code&gt;l2&lt;/code&gt; to the existing value; go to 1 with updated length for &lt;code&gt;l1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The full process of accumulating &lt;code&gt;sp 1&lt;/code&gt; and &lt;code&gt;sp 2&lt;/code&gt; is illustrated as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/accumulate_8-1.jpg&quot; alt=&quot;accumulate 8&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Two things might need to be clarified:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Although we assumed the resulting lists of sub-problems to be sorted, they will naturally become sorted anyway because we are doing the &lt;em&gt;smaller goes first&lt;/em&gt; merging.  &lt;/li&gt;
&lt;li&gt;We need to attach the lengths to each resulting list on the right and keep updating them because scanning the length of a list takes &lt;code&gt;O(n)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Obviously this way of accumulation can give us &lt;code&gt;O(n)&lt;/code&gt;. Because at most we can divide &lt;code&gt;O(logn)&lt;/code&gt; times, our &lt;em&gt;divide and conquer and accumulate&lt;/em&gt; solution will be &lt;code&gt;O(nlogn)&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Code&lt;/h1&gt;

&lt;p&gt;At first, we &lt;em&gt;divide&lt;/em&gt;. Note that this version of &lt;em&gt;divide&lt;/em&gt; is actually a kind of &lt;code&gt;splitting from middle&lt;/code&gt;, as the original order of the elements before we get any solution is important.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* we have a parameter n to indicate the length of l.
   it will be passed by the caller and 
   in this way, we do not need to scan l for its length every time.

   it will return left, right and the length of the right.
*)
let divide l n =  
  let m = n / 2 in
  let rec aux left i = function
    | [] -&amp;gt; List.rev left, [], 0
    | right when i &amp;gt;= m -&amp;gt; List.rev left, right, n-i
    | hd::tl -&amp;gt; aux (hd::left) (i+1) tl
  in
  aux [] 0 l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;em&gt;accumulate&lt;/em&gt;. We put it before writing &lt;em&gt;conquer&lt;/em&gt; because &lt;em&gt;conquer&lt;/em&gt; would call it thus it must be defined before &lt;em&gt;conquer&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let accumulate l1 l2 len2 =  
  let rec aux acc len2 = function
    | l, [] | [], l -&amp;gt; List.rev_append acc l
    | (hd1,ns1)::tl1 as left, ((hd2,ns2)::tl2 as right) -&amp;gt;
      if hd1 &amp;gt;= hd2 then aux ((hd2,ns2)::acc) (len2-1) (left, tl2)
      else aux ((hd1,ns1+len2)::acc) len2 (tl1, right)
  in
  aux [] len2 (l1, l2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;conquer&lt;/em&gt; is the controller.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* note the list parameter is a list of tuple, i.e., (x, ns) *)
let rec conquer n = function  
  | [] | _::[] as l -&amp;gt; l
  | l -&amp;gt;
    let left, right, right_len = divide l n in
    let solution_sp1 = conquer (n-right_len) left in
    let solution_sp2 = conquer right_len right in
    accumulate solution_sp1 solution_sp2 right_len
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So if we are given a list of numbers, we can now get all numbers of surpassers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let numbers_of_surpassers l =  
  List.map (fun x -&amp;gt; x, 0) l |&amp;gt; conquer (List.length l)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Are we done? No! we should find the max number of surpassers out of them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* we should always consider the situation where no possible answer could be given by using **option**, although it is a bit troublesome *)
let max_num_surpassers = function  
  | [] -&amp;gt; None
  | l -&amp;gt;
    let nss = numbers_of_surpassers l in
    Some (List.fold_left (fun max_ns (_, ns) -&amp;gt; max max_ns ns) 0 nss)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;[1]&lt;/strong&gt; Unless I can see an optimal solution instantly, I always intend to think of the most straightforward one even though it sometimes sounds stupid. I believe this is not a bad habit. Afterall, many good solutions come out from brute-force ones. As long as we anyway have a solution, we can work further based on it and see whether we can make it better. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[2]&lt;/strong&gt; Yes, I believe the dragon lady will &lt;a href=&quot;http://www.imdb.com/title/tt0944947/&quot;&gt;end the game and win the throne&lt;/a&gt;. It is the circle and fate. &lt;/p&gt;</content><id>http://typeocaml.com/2015/02/20/pearl-no-2-the-max-number-of-surpassers/</id><title type="text">Pearl No.2 - The Max Number of Surpassers</title><updated>2015-02-21T01:24:38-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2015/02/02/functional-pearl-no-1-the-min-free-nature/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/pearls2-1.jpg#hero&quot; alt=&quot;pears&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cs.ox.ac.uk/richard.bird/&quot;&gt;Prof. Richard Simpson Bird&lt;/a&gt; is a Supernumerary Fellow of Computation at &lt;a href=&quot;http://www.lincoln.ox.ac.uk/&quot;&gt;Lincoln College, Oxford&lt;/a&gt;, England, and former director of &lt;a href=&quot;http://www.cs.ox.ac.uk/&quot;&gt;the Oxford University Computing Laboratory&lt;/a&gt;. His research interests include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The algebra of programming&lt;/li&gt;
&lt;li&gt;The calculation of algorithms from their specification&lt;/li&gt;
&lt;li&gt;Functional programming&lt;/li&gt;
&lt;li&gt;Algorithm design&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In 2010, he wrote the book &lt;a href=&quot;http://www.cambridge.org/gb/academic/subjects/computer-science/programming-languages-and-applied-logic/pearls-functional-algorithm-design&quot;&gt;Pearls of Functional Algorithm Design&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/pearls_book.jpeg&quot; alt=&quot;book&quot;/&gt;&lt;/p&gt;

&lt;p&gt;This book presents &lt;strong&gt;30 algorithm problems and their functional solutions&lt;/strong&gt;. The reason that they are called as &lt;em&gt;pearls&lt;/em&gt; is what I quote below:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Just as natural pearls grow from grains of sand that have irritated oysters, these programming pearls have grown from real problems that have irritated programmers. The programs are fun, and they teach important programming techniques and fundamental design principles. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;These pearls are all classic and togehter with the well presented functional approaches, they become very helpful for ones who really wish to sharpen their functional programming on algorithms. I have so far solved / fully understood 17 pearls and hmm...the rest are indeed difficult, at least for me. Nevertheless, I would like to share my journey of studying this book with you via a series of posts, each of which is a pearl in the book. All the posts will differ from the book in the following ways:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Only OCaml is used&lt;/strong&gt; for the implementations (for the obvious reason: I am a fan of OCaml)  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;More general (functional) analysis techniques&lt;/strong&gt; are adopted. The book heavily focuses on algebraic approach, namely, &lt;em&gt;design by calculation&lt;/em&gt;, which honestly is too much for me. I mean I can understand the methodology, but cannot master it. So during my study, I did not replicate the algebraic thinking; instead, I tried to sniff around the functional sprit behind the curtain and consider the algebraic part as the source of hints.  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tail-recursive implementation&lt;/strong&gt; will be provided if possible. The haskell implementations in the book do not consider much about tail-recursive because a) haskell is lazy; b) haskell's compiler is doing clever things to help recursion not blow. OCaml is different. It is not lazy and does not rely on the compiler to do optimisations on the potential &lt;em&gt;stackoverflow&lt;/em&gt;. So as OCaml developers, we need to care about tail-recursive explicitly.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ok. Let's get started.&lt;/p&gt;

&lt;h1&gt;The Min Missing Natural Number&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a unordered list of distinct natural numbers, find out the minimum natural number that is not in the list.&lt;/p&gt;
  
  &lt;p&gt;For example, if the list is [8; 2; 3; 0; 12; 4; 1; 6], then 5 is the minimum natural number that is missing.&lt;/p&gt;
  
  &lt;p&gt;O(n) solution is desired.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/problem_description-1.jpg&quot; alt=&quot;eg&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;Analysis of the problem description&lt;/h1&gt;

&lt;p&gt;The description of an algorithm problem specifies the input, the output and the constraint. Yet, it is more than just telling us what to achieve. Most of the time, the literatures can provide us hints for possible solutions. Let's break down the description first:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;unordered list  &lt;/li&gt;
&lt;li&gt;distinct  &lt;/li&gt;
&lt;li&gt;natural numbers  &lt;/li&gt;
&lt;li&gt;minimum and missing&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;unordered list&lt;/h3&gt;

&lt;p&gt;The input list is not sorted. If this is specified explicitly, it implies that ordering is important here. In other words, if the list was sorted, then the problem would not be a problem any more or at least much easier to solve.&lt;/p&gt;

&lt;h3&gt;distinct&lt;/h3&gt;

&lt;p&gt;There are no duplicates inside.&lt;/p&gt;

&lt;h3&gt;natural numbers&lt;/h3&gt;

&lt;p&gt;All numbers are non-negative integers, i.e., 0, 1, 2, ... This puts a lower boundary on the possible numbers in the input list.&lt;/p&gt;

&lt;h3&gt;minimum and missing&lt;/h3&gt;

&lt;p&gt;There might be unlimited numbers not in the input list, but we just need to find the smallest one. When our goal is to locate something with certain characteristic, it would normally be a &lt;em&gt;selection problem&lt;/em&gt;. Moreover, for problems related &lt;em&gt;min&lt;/em&gt; or &lt;em&gt;max&lt;/em&gt;, they normally can be solved by somehow bringing sorting; however, sorting will heavily involve moving all numbers around. As our target is only one number, sorting can be an overkill.&lt;/p&gt;

&lt;h1&gt;An easy but not optimal solution&lt;/h1&gt;

&lt;p&gt;From the analysis above, it is obvious that sorting can solve our problem quite easily. We can simply &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Sort the input list  &lt;/li&gt;
&lt;li&gt;If the first number is not &lt;code&gt;0&lt;/code&gt;, then the result is &lt;code&gt;0&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;Scan every consecutive pair (x, y)  &lt;/li&gt;
&lt;li&gt;If &lt;code&gt;y - x &amp;gt; 1&lt;/code&gt; then the result is &lt;code&gt;x + 1&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;If point 4 never happens, then the result is &lt;code&gt;the last number plus 1&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/easy_solution.jpg&quot; alt=&quot;easy_solution&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let min_missing_trivial l =  
  let sl = List.sort compare l in
  let rec find = function
    | [] -&amp;gt; None
    | x::[] -&amp;gt; Some (x+1)
    | x::y::_ when y - x &amp;gt; 1 -&amp;gt; Some (x+1)
    | _::tl -&amp;gt; find tl
  in
  (* adding -1 can cover point 2 and make find work for all *)
  find ((-1)::sl) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Have we solved the problem? Let's have a look. The solution above can achieve the goal indeed. However, the time complexity of this solution is &lt;code&gt;O(nlogn)&lt;/code&gt; since the sorting bit is dominating, which is worse than the required &lt;code&gt;O(n)&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;We have to try harder.&lt;/p&gt;

&lt;h1&gt;Do we need complete order?&lt;/h1&gt;

&lt;p&gt;So, if we do a sorting, we can obtain the answer but it is too slow. Let's have a look again at what we get after sorting.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/completely_ordered.jpg&quot; alt=&quot;completely sorted&quot;/&gt;&lt;/p&gt;

&lt;p&gt;If the list is sorted, then it provides us a chance where we check the consecutiveness of the numbers and the first gap is what we want. There are two questions though:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Q1. Shall we care about the consecutiveness after &lt;code&gt;6&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The answer is &lt;em&gt;no&lt;/em&gt;. Since we are chasing for the &lt;em&gt;minimum&lt;/em&gt;, i.e., the first missing one, the order of the numbers after the gap doesn't matter any more. &lt;/p&gt;

&lt;p&gt;For example, even if &lt;code&gt;12&lt;/code&gt; is before &lt;code&gt;8&lt;/code&gt;, the result won't be affected.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/after_gap.jpg&quot; alt=&quot;after gap&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Q2. Is the order of all the numbers before the gap important?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let's randomly mess up the order of &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt; a little:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/before_gap-1.jpg&quot; alt=&quot;before gap&quot;/&gt;&lt;/p&gt;

&lt;p&gt;It seems fine as the messed order of those 4 numbers does not affect the position of &lt;code&gt;4&lt;/code&gt; and &lt;code&gt;6&lt;/code&gt;. But hang on a minute, something is not right there.&lt;/p&gt;

&lt;p&gt;We replied on the consecutiveness of &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt; to locate the first gap, and the consecutiveness can be checked via the numbers being sorted. Hence, if the order before the gap was not maintained, how could we scan for consecutiveness and find the gap in the first place? It sounds like a chicken and egg thing.&lt;/p&gt;

&lt;p&gt;So can we check for the consecutiveness of the numbers without sorting them?&lt;/p&gt;

&lt;h1&gt;Hints hidden in &amp;quot;distinct natural numbers&amp;quot;&lt;/h1&gt;

&lt;p&gt;Yes, we can, and now it is the time to ask for help from &lt;em&gt;distinct natural numbers&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;As we described before, &lt;em&gt;natural numbers&lt;/em&gt; are integers euqal to or larger than &lt;code&gt;0&lt;/code&gt;. This lower bound &lt;code&gt;0&lt;/code&gt; plus the constraint of &lt;em&gt;no duplicates&lt;/em&gt; gives us the opportunity to check for consecutiveness without requiring all numbers being sorted. Let's first see a perfect consecutive sequnce (starting from 0) of natural numbers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/perfect_consecutive_1.jpg&quot; alt=&quot;perfect1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;They are sorted of course. Is there any other characteristic? Or say, for a number inside the sequence, how many other numbers are less than it (on its left side)?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/perfect_consecutive_count.jpg&quot; alt=&quot;count&quot;/&gt;&lt;/p&gt;

&lt;p&gt;For number &lt;code&gt;4&lt;/code&gt;, there will exact &lt;code&gt;4&lt;/code&gt; natural numbers less than itself. The same thing will apply on any numbers as long as all those belong to a perfect consecutive sequence starting from &lt;code&gt;0&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;This is also a two-way mapping, i.e., if we are told that there are &lt;code&gt;4&lt;/code&gt; numbers less than &lt;code&gt;4&lt;/code&gt; and all of them are before &lt;code&gt;4&lt;/code&gt;, we can be sure that all five numbers can form a consecutive sequence. Most importantly, now whether all numbers are in order or not does not matter any more.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/perfect_consecutive_not_ordered.jpg&quot; alt=&quot;not ordered again&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;What does a perfect consecutiveness imply? &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It implies that among the sequence, no one is missing and if anyone is missing, it must be on the right side of the max of the sequence.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/missing_in_right.jpg&quot; alt=&quot;in the right&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;What if for a number, the number of smaller ones does not match its own value?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It means the sequence up to the number won't be consecutive, which implies that there must be at least one a natural number missing, right?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/02/in_the_left.jpg&quot; alt=&quot;in the left&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Now we have the weapon we want. In order to check consecutiveness, or say, to know the region where the min missing natural number is, we don't need complete sorting any more. Instead, we just to&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;pick a number &lt;code&gt;x&lt;/code&gt; from the sequence  &lt;/li&gt;
&lt;li&gt;put all other smaller numbers to its left and count how many are those in &lt;code&gt;num_less&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;put all larger ones to its right  &lt;/li&gt;
&lt;li&gt;If &lt;code&gt;num_less = x&lt;/code&gt;, then it means &lt;code&gt;x&lt;/code&gt;'s left branch is perfect and the missing one must be in its right branch. We repeat the whole process in the sequence of right hand side.  &lt;/li&gt;
&lt;li&gt;Otherwise, we repeat in the left branch. Note that due to &lt;em&gt;distinct&lt;/em&gt;, it is impossible &lt;code&gt;num_less &amp;gt; x&lt;/code&gt;. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this way, we cannot identify the min missing one in one go, but we can narrow down the range where it might be through each iteration and eventually we will find it when no range can be narrowed any more. &lt;/p&gt;

&lt;p&gt;Sounds like a good plan? let's try to implement it.&lt;/p&gt;

&lt;h1&gt;Partition and Implementation&lt;/h1&gt;

&lt;p&gt;Do you feel familiar with the process we presented above? It is actually a classic &lt;code&gt;partition&lt;/code&gt; step which is the key part of &lt;em&gt;quicksort&lt;/em&gt; &lt;a href=&quot;http://typeocaml.com/2015/01/02/immutable/&quot;&gt;we talked about&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course, in this problem, it won't be a standard &lt;code&gt;partition&lt;/code&gt; as we need to record &lt;code&gt;num_less&lt;/code&gt;. The code should be easy enough to write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let partition x l =  
  let f (num_less, left, right) y =
    if y &amp;lt; x then num_less+1, y::left, right
    else num_less, left, y::right
  in
  List.fold_left f (0, [], []) l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also our solver function should be straightword too:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let min_missing l =  
  let rec find lo = function
    | [] -&amp;gt; lo
    | x::tl -&amp;gt;
      let num_less, left, right = partition x tl in
      if num_less + lo = x then find (x+1) right
      else find lo left
  in
  find 0 l

(* Why do we introduce `lo`?
   I will leave this question to the readers *)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Time complexity of our new solution&lt;/h2&gt;

&lt;p&gt;For the very 1st iteration, we need to scan all numbers, so costs &lt;code&gt;O(n)&lt;/code&gt; for this step. But we can skip out ideally half of the numbers.&lt;/p&gt;

&lt;p&gt;So for the 2nd iteration, it costs &lt;code&gt;O(n*(1/2))&lt;/code&gt;. Again, further half will be ruled out.&lt;/p&gt;

&lt;p&gt;...&lt;/p&gt;

&lt;p&gt;So the total cost would be &lt;code&gt;O(n * (1 + 1/2 + 1/4 + 1/8 + ...)) = O(n * 2) = O(n)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We made it!&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;This is the first pearl and it is not that difficult, especially if you knew &lt;em&gt;quickselect&lt;/em&gt; algorithm before. &lt;/p&gt;

&lt;p&gt;Actually, many of the pearls involve certain fundamental algorithms and what one need to do is to peel the layers out one by one and eventually solve it via the essentials. If you are interested in pearls, please pay attentions to the tags attached with each pearl as they show what each pearl is really about.&lt;/p&gt;</content><id>http://typeocaml.com/2015/02/02/functional-pearl-no-1-the-min-free-nature/</id><title type="text">Pearl No.1 - The Min Missing Natural Number</title><updated>2015-02-02T17:34:31-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2015/01/25/memoize-rec-untying-the-recursive-knot/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/knot-1.jpg#hero&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;When I wrote the section of &lt;em&gt;When we need later substitution&lt;/em&gt; in  &lt;a href=&quot;http://typeocaml.com/2015/01/20/mutable/&quot;&gt;Mutable&lt;/a&gt;, I struggled. I found out that I didn't fully understand the recursive memoize myself, so what I had to do was just copying the knowledge from &lt;a href=&quot;https://realworldocaml.org/v1/en/html/imperative-programming-1.html#memoization-and-dynamic-programming&quot;&gt;Real World OCaml&lt;/a&gt;. Luckily, after the post was published, &lt;em&gt;glacialthinker&lt;/em&gt; &lt;a href=&quot;http://www.reddit.com/r/ocaml/comments/2t49p9/mutable_and_when_shall_we_use_imperative/cnvryku&quot;&gt;commented&lt;/a&gt; in &lt;a href=&quot;http://www.reddit.com/r/ocaml/comments/2t49p9/mutable_and_when_shall_we_use_imperative/&quot;&gt;reddit&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;(I never thought before that a recursive function can be split like this, honestly. I don't know how to induct such a way and can't explain more. I guess we just learn it as it is and continue. More descriptions of it is in the book.)&lt;/p&gt;
  &lt;/blockquote&gt;
  
  &lt;p&gt;This is &amp;quot;untying the recursive knot&amp;quot;. And I thought I might find a nice wikipedia or similiar entry... but I mostly find Harrop. :) He actually had a nice article on this many years back in his OCaml Journal. Anyway, if the author swings by, searching for that phrase may turn up more material on the technique.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It greatly enlightened me. Hence, in this post, I will share with you my futher understanding on &lt;em&gt;recursive memoize&lt;/em&gt; together with the key cure &lt;em&gt;untying the recursive knot&lt;/em&gt; that makes it possible. &lt;/p&gt;

&lt;h1&gt;Simple Memoize revamped&lt;/h1&gt;

&lt;p&gt;We talked about the simple &lt;em&gt;memoize&lt;/em&gt; before. It takes a non-recursive function and returns a new function which has exactly the same logic as the original function but with new new ability of caching the &lt;em&gt;argument, result&lt;/em&gt; pairs. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let memoize f =  
  let table = Hashtbl.Poly.create () in
  let g x = 
    match Hashtbl.find table x with
    | Some y -&amp;gt; y
    | None -&amp;gt;
      let y = f x in
      Hashtbl.add_exn table ~key:x ~data:y;
      y
  in
  g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/simple_memoize-1.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The greatness of &lt;code&gt;memoize&lt;/code&gt; is its flexibility: as long as &lt;code&gt;f&lt;/code&gt; takes a single argument, &lt;code&gt;memoize&lt;/code&gt; can make a &lt;em&gt;memo version&lt;/em&gt; out of it without touching anything inside &lt;code&gt;f&lt;/code&gt;.  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This means while we create &lt;code&gt;f&lt;/code&gt;, we don't need to worry about the ability of caching but just focus on its own correct logic. After we finish &lt;code&gt;f&lt;/code&gt;, we simply let &lt;code&gt;memoize&lt;/code&gt; do its job. &lt;em&gt;Memoization&lt;/em&gt; and &lt;em&gt;functionality&lt;/em&gt; are perfectly separated. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Unfortunately, the simple &lt;code&gt;memoize&lt;/code&gt; cannot handle recursive functions.&lt;/strong&gt; If we try to do &lt;code&gt;memoize f_rec&lt;/code&gt;, we will get this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/simple_memoize_rec.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;f_rec&lt;/code&gt; is a recursive function so it will call itself inside its body. &lt;code&gt;memoize f_rec&lt;/code&gt; will produce &lt;code&gt;f_rec_memo&lt;/code&gt; which is a little similar as the previous &lt;code&gt;f_memo&lt;/code&gt;, yet with the difference that it is not a simple single call of &lt;code&gt;f_rec arg&lt;/code&gt; like we did &lt;code&gt;f arg&lt;/code&gt;. Instead, &lt;code&gt;f_rec arg&lt;/code&gt; may call &lt;code&gt;f_rec&lt;/code&gt; again and again with new arguments. &lt;/p&gt;

&lt;p&gt;Let's look at it more closely with an example. Say, &lt;code&gt;arg&lt;/code&gt; in the recursive process will be always decreased by &lt;code&gt;1&lt;/code&gt; until &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Let's first od &lt;code&gt;f_rec_memo 4&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;f_rec_memo&lt;/code&gt; will check the &lt;code&gt;4&lt;/code&gt; against &lt;code&gt;Hashtbl&lt;/code&gt; and it is not in.  &lt;/li&gt;
&lt;li&gt;So &lt;code&gt;f_rec 4&lt;/code&gt; will be called for the first time.  &lt;/li&gt;
&lt;li&gt;Then &lt;code&gt;f_rec 3&lt;/code&gt;, &lt;code&gt;f_rec 2&lt;/code&gt;, &lt;code&gt;f_rec 1&lt;/code&gt; and &lt;code&gt;f_rec 0&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;After the 5 calls, result is obtained. Then &lt;em&gt;4, result&lt;/em&gt; pair is stored in &lt;code&gt;Hashtbl&lt;/code&gt; and returned.  &lt;/li&gt;
&lt;li&gt;Now let's do &lt;code&gt;f_rec_memo 3&lt;/code&gt;, what will happen? Obviously, &lt;code&gt;3&lt;/code&gt; won't be found in &lt;code&gt;Hashtbl&lt;/code&gt; as only &lt;code&gt;4&lt;/code&gt; is stored in step 5.  &lt;/li&gt;
&lt;li&gt;But should &lt;em&gt;3, result&lt;/em&gt; pair be found? Yes, it should of course because we have dealt with &lt;code&gt;3&lt;/code&gt; in step 4, right?  &lt;/li&gt;
&lt;li&gt;Why &lt;code&gt;3&lt;/code&gt; has been done but is not stored?  &lt;/li&gt;
&lt;li&gt;ahh, it is because we did &lt;code&gt;f_rec 3&lt;/code&gt; but not &lt;code&gt;f_rec_memo 3&lt;/code&gt; while only the latter one has the caching ability. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus, we can use &lt;code&gt;memoize f_rec&lt;/code&gt; to produce a memoized version out of &lt;code&gt;f_rec&lt;/code&gt; anyway, but it changes only the surface not the &lt;code&gt;f_rec&lt;/code&gt; inside, hence not that useful. How can we make it better then?&lt;/p&gt;

&lt;h1&gt;Recursive Memoize revamped&lt;/h1&gt;

&lt;p&gt;What we really want for memoizing a recursive function is to blend the &lt;em&gt;memo&lt;/em&gt; ability deep inside, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/memoize_rec_wish-1.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Essentially we have to replace &lt;code&gt;f_rec&lt;/code&gt; inside with &lt;code&gt;f_rec_memo&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/transform-1.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;And only in this way, &lt;code&gt;f_rec&lt;/code&gt; can be fully memoized. However, we have one problem: **it seems that we have to change the internal of &lt;code&gt;f_rec&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we can modify &lt;code&gt;f_rec&lt;/code&gt; directly, we can solve it easily . For instance of &lt;em&gt;fibonacci&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec fib_rec n =  
  if n &amp;lt;= 1 then 1
  else fib_rec (n-1) + fib_rec (n-2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can make the memoized version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let fib_rec_memo_trivial n =  
  let table = Hashtbl.Poly.create () in
  let rec fib_rec_memo x = 
    match Hashtbl.find table x with
    | Some y -&amp;gt; y
    | None -&amp;gt;
      let y = fib_rec_memo (x-1) + fib_rec_memo (x-2) in
      Hashtbl.add_exn table ~key:x ~data:y;
      y
  in
  fib_rec_memo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above solution, we replaced the original &lt;code&gt;fib_rec&lt;/code&gt; inside with &lt;code&gt;fib_rec_memo&lt;/code&gt;, however, we also changed the declaration to &lt;code&gt;fib_rec_memo&lt;/code&gt; completely. In fact, now &lt;code&gt;fib_rec&lt;/code&gt; is totally ditched and &lt;code&gt;fib_rec_memo&lt;/code&gt; is a new function that blends the logic of &lt;em&gt;memoize&lt;/em&gt; with the logic of &lt;code&gt;fib_rec&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;Well, yes, &lt;code&gt;fib_rec_memo_trivial&lt;/code&gt; can achieve our goal, but only for &lt;code&gt;fib_rec&lt;/code&gt; specificly. If we need to make a memoized version for another recursive function, then we need to change the body of that function again. This is not what we want. &lt;strong&gt;We wish for a &lt;code&gt;memoize_rec&lt;/code&gt; that can turn &lt;code&gt;f_rec&lt;/code&gt; directly into a memoized version, just like what the simple &lt;code&gt;memoize&lt;/code&gt; can do for &lt;code&gt;f&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So we don't have a shortcut. Here is what we need to achieve:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;we have to replace the &lt;code&gt;f_rec&lt;/code&gt; inside the body of &lt;code&gt;f_rec&lt;/code&gt; with &lt;code&gt;f_rec_memo&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;We have keep the declaration of &lt;code&gt;f_rec&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;We must assume we can't know the specific logic inside &lt;code&gt;f_rec&lt;/code&gt;. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It sounds a bit hard. It is like giving you a compiled function without source code and asking you to modify its content. And more imporantly, your solution must be generalised. &lt;/p&gt;

&lt;p&gt;Fortunately, we have a great solution to create our &lt;code&gt;memoize_rec&lt;/code&gt; without any &lt;em&gt;hacking&lt;/em&gt; or &lt;em&gt;reverse-engineering&lt;/em&gt; and &lt;strong&gt;untying the recursive knot is the key&lt;/strong&gt;. &lt;/p&gt;

&lt;h1&gt;Untying the Recursive Knot&lt;/h1&gt;

&lt;p&gt;To me, this term sounds quite fancy. In fact, I never heard of it before &lt;em&gt;2015-01-21&lt;/em&gt;. After I digged a little bit about it, I found it actually quite simple but very useful (this recursive memoize case is an ideal demonstration). Let's have a look at what it is.&lt;/p&gt;

&lt;p&gt;Every recursive function somehow follows a similar pattern where it calls itself inside its body:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/single_f_rec.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Once a recursive function application starts, it is out of our hands and we know it will continue and continue by calling itself until the &lt;em&gt;STOP&lt;/em&gt; condition is satisfied. &lt;strong&gt;What if the users of our recursive function need some more control even after it gets started?&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;For example, say we provide our users &lt;code&gt;fib_rec&lt;/code&gt; without source code, what if the users want to print out the detailed trace of each iteration? They are not able unless they ask us for the source code and make a new version with printing. It is not that convenient.&lt;/p&gt;

&lt;p&gt;So if we don't want to give out our source code, somehow we need to reform our &lt;code&gt;fib_rec&lt;/code&gt; a little bit and give the space to our users to insert whatever they want for each iteration. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec fib_rec n =  
  if n &amp;lt;= 1 then 1
  else fib_rec (n-1) + fib_rec (n-2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Have a look at the above &lt;code&gt;fib_rec&lt;/code&gt; carefully again, we can see that the logic of &lt;code&gt;fib_rec&lt;/code&gt; is already determined during the binding, it is the &lt;code&gt;fib_rec&lt;/code&gt;s inside that control the iteration. What if we rename the &lt;code&gt;fib_rec&lt;/code&gt;s within the body to be &lt;code&gt;f&lt;/code&gt; and add it as an argument?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let fib_norec f n =  
  if n &amp;lt;= 1 then 1
  else f (n-1) + f (n-2)

(* we actually should now change the name of fib_norec 
   to something like fib_alike_norec as it is not necessarily 
   doing fibonacci anymore, depending on f *)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now &lt;code&gt;fib_norec&lt;/code&gt; won't automatically repeat unless &lt;code&gt;f&lt;/code&gt; tells it to. Moreover, &lt;code&gt;fib_norec&lt;/code&gt; becomes a pattern which returns &lt;code&gt;1&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;lt;= 1&lt;/code&gt; otherwise &lt;code&gt;add&lt;/code&gt; &lt;code&gt;f (n-1)&lt;/code&gt; and &lt;code&gt;f (n-2)&lt;/code&gt;. As long as you think this pattern is useful for you, you can inject your own logic into it by providing your own &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Going back to the printing requirement, a user can now build its own version of &lt;code&gt;fib_rec_with_trace&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec fib_rec_with_trace n =  
  Printf.printf &amp;quot;now fibbing %d\n&amp;quot; n; 
  fib_norec fib_rec_with_trace n
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Untying the recusive knot is a functional design pattern. It turns the recursive part inside the body into a new parameter &lt;code&gt;f&lt;/code&gt;. In this  way, it breaks the iteration and turns a recursive function into a pattern where new or additional logic can be injected into via &lt;code&gt;f&lt;/code&gt;. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/untie_f_rec.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;It is very easy to untie the knots for recusive functions. You just give an addition parameter &lt;code&gt;f&lt;/code&gt; and replace &lt;code&gt;f_rec&lt;/code&gt; everywhere inside with it. For example, for &lt;code&gt;quicksort&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let quicksort_norec f = function  
  | [] | _::[] as l -&amp;gt; l
  | pivot::rest -&amp;gt;
    let left, right = partition_fold pivot rest in
    f left @ (pivot::f right)

let rec quicksort l = quicksort_norec quicksort l  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are more examples in &lt;a href=&quot;http://martinsprogrammingblog.blogspot.co.uk/2012/07/untying-recursive-knot.html&quot;&gt;Martin's blog&lt;/a&gt;, though they are not in OCaml. A formalized description of this topic is in the article &lt;em&gt;Tricks with recursion: knots, modules and polymorphism&lt;/em&gt; from &lt;a href=&quot;http://www.ffconsultancy.com/products/ocaml_journal/?ob26&quot;&gt;The OCaml Journal&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Now let's come back to &lt;em&gt;recursive memoize&lt;/em&gt; problem with our new weapon. &lt;/p&gt;

&lt;h1&gt;Solve Recursive Memoize&lt;/h1&gt;

&lt;p&gt;At first, we can require that every recursive function &lt;code&gt;f_rec&lt;/code&gt; must be supplied to &lt;code&gt;memoize_rec&lt;/code&gt; in the untied form &lt;code&gt;f_norec&lt;/code&gt;. This is not a harsh requirement since it is easy to transform &lt;code&gt;f_rec&lt;/code&gt; to &lt;code&gt;f_norec&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once we get &lt;code&gt;f_norec&lt;/code&gt;, we of course cannot apply &lt;code&gt;memoize&lt;/code&gt; (non-rec version) on it directly because &lt;code&gt;f_norec&lt;/code&gt; now takes two parameters: &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;Although we can create &lt;code&gt;f_rec&lt;/code&gt; in the way of &lt;code&gt;let rec f_rec arg = f_norec f_rec arg&lt;/code&gt;, we won't do it that straightforward here as it makes no sense to have an exactly the same recursive function. Instead, we can for now do something like &lt;code&gt;let f_rec_tmp arg = f_norec f arg&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;We still do not know what &lt;code&gt;f&lt;/code&gt; will be, but &lt;code&gt;f_rec_tmp&lt;/code&gt; is non-recursive and we can apply &lt;code&gt;memoize&lt;/code&gt; on it: &lt;code&gt;let f_rec_tmp_memo = memoize f_tmp&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;f_rec_tmp_memo&lt;/code&gt; now have the logic of &lt;code&gt;f_norec&lt;/code&gt; and the ability of memoization. If &lt;code&gt;f&lt;/code&gt; can be &lt;code&gt;f_rec_tmp_memo&lt;/code&gt;, then our problem is solved. This is because &lt;code&gt;f&lt;/code&gt; is inside &lt;code&gt;f_norec&lt;/code&gt; controlling the iteration and we wished it to be memoized.&lt;/p&gt;

&lt;p&gt;The magic that can help us here is &lt;strong&gt;making &lt;code&gt;f&lt;/code&gt; mutable&lt;/strong&gt;. Because &lt;code&gt;f&lt;/code&gt; needs to be known in prior and &lt;code&gt;f_rec_tmp_memo&lt;/code&gt; is created after, we can temporarily define &lt;code&gt;f&lt;/code&gt; as a trivial function and later on after we create &lt;code&gt;f_rec_tmp_memo&lt;/code&gt;, we then change &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;f_rec_tmp_memo&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;Let's use a group of bindings to demonstrate:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* trivial initial function and it should not be ever applied in this state *)
let f = ref (fun _ -&amp;gt; assert false)

let f_rec_tmp arg = f_norec !f arg

(* memoize is the simple non-rec version *)
let f_rec_tmp_memo = memoize f_rec_tmp

(* the later substitution made possible by being mutable *)
f := f_rec_tmp_memo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final code for &lt;code&gt;memoize_rec&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let memo_rec f_norec =  
  let f = ref (fun _ -&amp;gt; assert false) in
  let f_rec_memo = memoize (fun x -&amp;gt; f_norec !f x) in
  f := f_rec_memo;
  f_rec_memo
&lt;/code&gt;&lt;/pre&gt;</content><id>http://typeocaml.com/2015/01/25/memoize-rec-untying-the-recursive-knot/</id><title type="text">Recursive Memoize &amp; Untying the Recursive Knot</title><updated>2015-01-25T13:22:15-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2015/01/20/mutable/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/mutable_2.jpg#hero&quot; alt=&quot;mutable&quot;/&gt;&lt;/p&gt;

&lt;p&gt;While OCaml is a functional programming language and emphasises pure functional style, it allows &lt;em&gt;mutable&lt;/em&gt; (variables and values) and hence imperative programming style. The reason is said in &lt;a href=&quot;https://realworldocaml.org/v1/en/html/imperative-programming-1.html&quot;&gt;Real World OCaml&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Imperative code is of fundamental importance to any practical programming language, because real-world tasks require that you interact with the outside world, which is by its nature imperative. Imperative programming can also be important for performance. While pure code is quite efficient in OCaml, there are many algorithms that can only be implemented efficiently using imperative techniques.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How to write imperative code in OCaml has been well introduced in both &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml-4.02/coreexamples.html#sec12&quot;&gt;OCaml's documentation and user's manual&lt;/a&gt; and &lt;a href=&quot;https://realworldocaml.org/v1/en/html/imperative-programming-1.html&quot;&gt;Real World OCaml&lt;/a&gt;. The imperative logic flow is very similar as in other imperative languages. For example, we can write an OCaml &lt;em&gt;binary search&lt;/em&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let binary_search a x =  
  let len = Array.length a in
  let p = ref 0 and q = ref (len-1) in
  let loc = ref None in
  while !p &amp;lt;= !q &amp;amp;&amp;amp; !loc = None &amp;amp;&amp;amp; !p &amp;gt;= 0  &amp;amp;&amp;amp; !q &amp;lt; len do
    let mi = (!p + !q) / 2 in
    if x = a.(mi) then loc := Some mi
    else if x &amp;gt; a.(mi) then p := mi + 1
    else q := mi - 1
  done;
  !loc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Mutable&lt;/em&gt; or &lt;em&gt;imperative&lt;/em&gt; could be a snake. People, who are &lt;em&gt;forced&lt;/em&gt; to use OCaml (for work or course assignments) &lt;em&gt;while they are not yet convinced by the potential functional power&lt;/em&gt;, may be happy when they know stuff can be written like in Java. They may also intend to (secretly) write imperative code in OCaml as much as possible to just get things done. &lt;/p&gt;

&lt;p&gt;It sounds bad and it indeed is. What is the point to code in a heavily imperative way with a functional programming language?&lt;/p&gt;

&lt;p&gt;However, I won't be worried even if one does that, because I know it is just the initial avoidance and it won't last long. Why? Because writing imperative code is a bit troublesome anyway. Let's revisit the &lt;code&gt;binary_search&lt;/code&gt; we wrote before.&lt;/p&gt;

&lt;p&gt;You can see that nothing is straightforward there. &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;When we define a mutable variable, we have to use &lt;code&gt;ref&lt;/code&gt;;  &lt;/li&gt;
&lt;li&gt;When we get the value out, we have to use &lt;code&gt;!&lt;/code&gt; everywhere;  &lt;/li&gt;
&lt;li&gt;When we assign a value, we can't forget &lt;code&gt;:&lt;/code&gt; before &lt;code&gt;=&lt;/code&gt;;  &lt;/li&gt;
&lt;li&gt;We even need to add &lt;code&gt;.&lt;/code&gt; before &lt;code&gt;()&lt;/code&gt; when we access arrays. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Even after we finish the function, it appears quite verbose and a little bit uncomfortable to read, right? This is why I am sure in longer term, one may give up imperative style, just truly learn the functional style and eventually understand OCaml's beautiful side. &lt;/p&gt;

&lt;p&gt;So if we will not / should not write everything imperatively, when to leverage the benefits from &lt;em&gt;mutable&lt;/em&gt;?&lt;/p&gt;

&lt;h1&gt;When performance requires it&lt;/h1&gt;

&lt;p&gt;In order to manipulate a sequence of elements, we noramlly will use &lt;code&gt;array&lt;/code&gt; in imperative languages; however, in pure functional language, we prefer &lt;code&gt;list&lt;/code&gt; as it is immutable. &lt;/p&gt;

&lt;p&gt;The best thing &lt;code&gt;array&lt;/code&gt; offers us is the &lt;em&gt;O(1)&lt;/em&gt; speed in accessing an element via its index. But we lose this advantage if using &lt;code&gt;list&lt;/code&gt;, i.e.,  we have to do a linear scan, which is &lt;code&gt;O(n)&lt;/code&gt;, to get the &lt;code&gt;ith&lt;/code&gt; value. Sometimes it would be too slow. To demonstrate this, let's have a look at the problem of &lt;em&gt;shuffle&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a sequence, randomize the order of all the elements inside. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A typical algorithm for &lt;em&gt;shuffle&lt;/em&gt; can be:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; initially is &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; is the length of the sequence.  &lt;/li&gt;
&lt;li&gt;Randomly generate an integer &lt;code&gt;r&lt;/code&gt; within &lt;code&gt;[i, len)&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Swap the element at &lt;code&gt;i&lt;/code&gt; and the one at &lt;code&gt;r&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Increase &lt;code&gt;i&lt;/code&gt; for next targeting element.  &lt;/li&gt;
&lt;li&gt;Repeat from step 2. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If we use &lt;code&gt;list&lt;/code&gt; in OCaml, then we will have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rm_nth n l =  
  let rec aux acc i = function
    | [] -&amp;gt; List.rev acc
    | _::tl when i = n -&amp;gt; List.rev_append acc tl
    | x::tl -&amp;gt; aux (x::acc) (i+1) tl
  in 
  aux [] 0 l

(* a slight modification when using list.
   we do not swap, instead, we remove the element from the randomised index 
   and put it to the new list.
*)
let shuffle l =  
  Random.self_init();
  let len = List.length l in
  let rec aux i acc l =
    if i &amp;lt; len then
      let r = Random.int (len - i) in
      aux (i+1) (List.nth l r ::acc) (rm_nth r l)
    else acc
  in
  aux 0 [] l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have to scan the list twice in each iteration: once to get the element at the randomised index &lt;code&gt;r&lt;/code&gt; and once to remove it. Totally we have &lt;code&gt;n&lt;/code&gt; iterations, thus, the time complexity is &lt;em&gt;O(n^2)&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;If we use &lt;code&gt;array&lt;/code&gt;, then it is much faster with time complexity of &lt;em&gt;O(n)&lt;/em&gt; as locating an element and swapping two elements in array just cost &lt;em&gt;O(1)&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let swap a i j =  
  let tmp = a.(i) in
  a.(i) &amp;lt;- a.(j);
  a.(j) &amp;lt;- tmp

let shuffle_array a =  
  Random.self_init();
  let len = Array.length a in
  for i = 0 to len-1 do
    let r = i + Random.int (len - i) in
    swap a i r
  done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to &lt;code&gt;array&lt;/code&gt;, some other imperative data structures can also improve performance. For example, the &lt;code&gt;Hashtbl&lt;/code&gt; is the traditional &lt;code&gt;hash table&lt;/code&gt; with &lt;code&gt;O(1)&lt;/code&gt; time complexity. However, the functional &lt;code&gt;Map&lt;/code&gt; module uses &lt;em&gt;AVL&lt;/em&gt; tree and thus provides &lt;code&gt;O(logN)&lt;/code&gt;. If one really cares about such a difference, &lt;code&gt;Hashtbl&lt;/code&gt; can be used with higher priority.&lt;/p&gt;

&lt;p&gt;Note that we &lt;em&gt;should not use potential performance boost as an excuse&lt;/em&gt; to use imperative code wildly in OCaml. In many cases, functional data structures and algorithms have similar performance, such as the &lt;em&gt;2-list&lt;/em&gt; based &lt;a href=&quot;http://www.cs.cornell.edu/Courses/cs3110/2014sp/recitations/7/functional-stacks-queues-dictionaries-fractions.html&quot;&gt;functional queue&lt;/a&gt; can offer us amortised &lt;code&gt;O(1)&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;When we need to remember something&lt;/h1&gt;

&lt;p&gt;Constantly creating new values makes functional programming safer and logically clearer, as &lt;a href=&quot;http://typeocaml.com/2015/01/02/immutable/&quot;&gt;discussed previously&lt;/a&gt;. However, occasionally we don't want everything to be newly created; instead, we need a mutable &lt;em&gt;object&lt;/em&gt; that stays put in the memory but can be updated. In this way, we can remember values in a single place.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Write a function that does &lt;code&gt;x + y * z&lt;/code&gt;. It outputs the correct result and in addition, prints how many times it has been called so far.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;x + y * z&lt;/code&gt; part is trivial, but the later recording the times of calls is tricky. Let's try to implement such a function in pure functional style first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* pure functional solution *)
let f x y z last_called_count =  
  print_int (last_called_count+1);
  x + y * z, last_called_count + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above can roughly achieve the goal. However, it is not great. &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It needs an additional argument which is meant to be the most recent count of calls. The way could work but is very vulnerable because it accepts whatever integer and there is no way to constrain it to be the real last count.  &lt;/li&gt;
&lt;li&gt;It has to return the new call count along with the real result&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When a user uses this function, he / she will feel awkward. &lt;code&gt;last_called_count&lt;/code&gt; needs to be taken care of very carefully in the code flow to avoid miscounting. The result returned is a tuple so pattern matching is necessary to obtain the real value of &lt;code&gt;x + y * z&lt;/code&gt;. Also again, one need to somehow remember the new call count so he / she can supply to the next call.&lt;/p&gt;

&lt;p&gt;This is where imperative programming comes to help:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* with help of imperative programming.
   note that the function g can be anonymous.*)
let f =  
  let countable_helper () =
    let called_count = ref 0 in
    let g x y z = 
      called_count := !called_count + 1;
      print_int !called_count;
      x + y * z
    in
    g
  in 
  countable_helper()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;countable_helper&lt;/code&gt; is a helper function. If it is called, it first creates a mutable &lt;code&gt;called_count&lt;/code&gt; and then pass it to &lt;code&gt;g&lt;/code&gt;. Because &lt;code&gt;called_count&lt;/code&gt; is mutable, so &lt;code&gt;g&lt;/code&gt; can freely increase its value by &lt;code&gt;1&lt;/code&gt;. Eventually &lt;code&gt;x + y * z&lt;/code&gt; is done after printing &lt;code&gt;called_count&lt;/code&gt;. &lt;code&gt;g&lt;/code&gt; is returned to f as it is the result of &lt;code&gt;countable_helper()&lt;/code&gt;, i.e., &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;g&lt;/code&gt;. &lt;/p&gt;

&lt;h1&gt;When we need later substitution&lt;/h1&gt;

&lt;p&gt;I found this interesting case from &lt;a href=&quot;https://realworldocaml.org/v1/en/html/imperative-programming-1.html#memoization-and-dynamic-programming&quot;&gt;The chapter for imperative programming in Real World OCaml&lt;/a&gt; and it is about &lt;em&gt;memoize&lt;/em&gt;. In this section, we borrow contents directly from the book but will emphasise &lt;em&gt;the substitution&lt;/em&gt; part.  &lt;/p&gt;

&lt;p&gt;Python developers should be quite familiar with the &lt;code&gt;memoize&lt;/code&gt; decorator . Essentially, it makes functions remember the &lt;em&gt;argument, result&lt;/em&gt; pairs so that if the same arguments are supplied again then the stored result is returned immediately without repeated computation.&lt;/p&gt;

&lt;p&gt;We can write &lt;code&gt;memoize&lt;/code&gt; in OCaml too:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* directly copied from Real World OCaml, does not use anonymous function *)
let memoize f =  
  let table = Hashtbl.Poly.create () in
  let g x = 
    match Hashtbl.find table x with
    | Some y -&amp;gt; y
    | None -&amp;gt;
      let y = f x in
      Hashtbl.add_exn table ~key:x ~data:y;
      y
  in
  g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It uses &lt;code&gt;Hashtbl&lt;/code&gt; as the imperative storage box and the mechanism is similar as our previous example of &lt;em&gt;call count&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The fascinating bit comes from the fact that this &lt;code&gt;memoize&lt;/code&gt; cannot handle recursive functions. If you don't believe it, let's try with the &lt;em&gt;fibonacci&lt;/em&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec fib n =  
  if n &amp;lt;= 1 then 1 else fib(n-1) + fib(n-2)

let fib_mem = memoize fib  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmmm...it will compile and seems working. Yes, &lt;code&gt;fib_mem&lt;/code&gt; will return correct results, but we shall have a closer look to see whether it really remembers the &lt;em&gt;argument, result&lt;/em&gt; pairs. So what is &lt;code&gt;fib_mem&lt;/code&gt; exactly? By replacing &lt;code&gt;f&lt;/code&gt; with &lt;code&gt;fib&lt;/code&gt; inside &lt;code&gt;memoize&lt;/code&gt;, we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* not proper ocaml code, just for demonstration purpose *)

fib_mem is actually  
  match Hashtbl.find table x with
  | Some y -&amp;gt; y
  | None -&amp;gt;
    let y = fib x in (* here is fib *)
    Hashtbl.add_exn table ~key:x ~data:y;
    y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So inside &lt;code&gt;fib_mem&lt;/code&gt;, if a new argument comes, it will call &lt;code&gt;fib&lt;/code&gt; and &lt;code&gt;fib&lt;/code&gt; is actually not memoized at all. What does this mean? It means &lt;code&gt;fib_mem&lt;/code&gt; may eventually remember the new argument and its result, but will never remember all the arguments and their results along the recusive way.&lt;/p&gt;

&lt;p&gt;For example, let's do &lt;code&gt;fib_mem 5&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;5&lt;/code&gt; is not in the Hashtbl, so &lt;code&gt;fib 5&lt;/code&gt; is called.  &lt;/li&gt;
&lt;li&gt;According to the definition of &lt;code&gt;fib&lt;/code&gt;, &lt;code&gt;fib 5 = fib 4 + fib 3&lt;/code&gt;, so now &lt;code&gt;fib 4&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;fib 4 = fib 3 + fib 2&lt;/code&gt;, no problem, but look, &lt;code&gt;fib 3&lt;/code&gt; will be done after &lt;code&gt;fib 4&lt;/code&gt; finishes.  &lt;/li&gt;
&lt;li&gt;Assuming &lt;code&gt;fib 4&lt;/code&gt; is done, then we go back to the right hand side of the &lt;code&gt;+&lt;/code&gt; in point 2, which means we need to do &lt;code&gt;fib 3&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Will we really do &lt;code&gt;fib 3&lt;/code&gt; now? Yes, unfortunately. Even though it has been done during &lt;code&gt;fib 4&lt;/code&gt;, because &lt;code&gt;fib&lt;/code&gt; is not memoized.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To solve this problem, we need &lt;em&gt;the substitution&lt;/em&gt; technique with the help of imperative programming.&lt;/p&gt;

&lt;h2&gt;An attractive but WRONG solution&lt;/h2&gt;

&lt;p&gt;When I read the book for the first time, before continuing for the solution of memoized fib, I tried something on my own.&lt;/p&gt;

&lt;p&gt;So the problem is the &lt;code&gt;f&lt;/code&gt; inside &lt;code&gt;memoize&lt;/code&gt; is not memoized, right? How about we make that that &lt;code&gt;f&lt;/code&gt; mutable, then after we define &lt;code&gt;g&lt;/code&gt;, we give &lt;code&gt;g&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt;? Since &lt;code&gt;g&lt;/code&gt; is memoized and &lt;code&gt;g&lt;/code&gt; is calling &lt;code&gt;g&lt;/code&gt; inside, then the whole thing would be memoized, right?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let mem_rec_bad f =  
  let table = Hashtbl.Poly.create () in
  let sub_f = ref f in
  let g x = 
    match Hashtbl.find table x with
    | Some y -&amp;gt; y
    | None -&amp;gt;
      let y = !sub_f x in
      Hashtbl.add_exn table ~key:x ~data:y;
      y
  in
  sub_f := g;
  g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can pass compiler but will stackoverflow if you do &lt;code&gt;let fib_mem = mem_rec_bad fib;; fib_mem 5&lt;/code&gt;. After we define &lt;code&gt;g&lt;/code&gt; and replae the original value of &lt;code&gt;sub_f&lt;/code&gt; with &lt;code&gt;g&lt;/code&gt;, it seems fine, but What is &lt;code&gt;g&lt;/code&gt; now?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* g is now actually like: *)
let g x =  
  match Hashtbl.find table x with
  | Some y -&amp;gt; y
  | None -&amp;gt;
    let y = g x in
    Hashtbl.add_exn table ~key:x ~data:y;
    y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;g&lt;/code&gt; will check the Hashtbl forever! And we totally lose the functionality of the original &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; becomes meaningless at all. &lt;/p&gt;

&lt;p&gt;So we can't directly replace the &lt;code&gt;f&lt;/code&gt; inside. Is there any way to reserve the functionality of &lt;code&gt;f&lt;/code&gt; but somehow substitute some part with the memoization? &lt;/p&gt;

&lt;h2&gt;The elegant solution&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Updated on 2015-01-25:&lt;/strong&gt; Please go to &lt;a href=&quot;http://typeocaml.com/2015/01/25/memoize-rec-untying-the-recursive-knot/&quot;&gt;Recursive Memoize &amp;amp; Untying the Recursive Knot&lt;/a&gt; for better explanation of recursive memoize. This following content here is not that good.&lt;/p&gt;

&lt;p&gt;The answer is Yes, and we have to build a non-recusive function out of the recusive &lt;code&gt;fib&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* directly copied from the book *)
let fib_norec f n =  
  if n &amp;lt;= 1 then 1
  else f(n-2) + f(n-1)

let fib_rec n = fib_norec fib_rec n  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(I never thought before that a recursive function can be split like this, honestly. I don't know how to induct such a way and can't explain more. I guess we just learn it as it is and continue. More descriptions of it is in the book.) (&lt;em&gt;[1]&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Basically, for a recursive function &lt;code&gt;f_rec&lt;/code&gt;, we can &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;change &lt;code&gt;f_rec&lt;/code&gt; to &lt;code&gt;f_norec&lt;/code&gt; with an additional parameter &lt;code&gt;f&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;replace the &lt;code&gt;f_rec&lt;/code&gt; in the original body with &lt;code&gt;f&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;then &lt;code&gt;let rec f_rec parameters = f_norec f_rec parameters&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;In this way, &lt;code&gt;f_rec&lt;/code&gt; will bring up &lt;code&gt;f_norec&lt;/code&gt; whenever being called, so actually the recusive logic is still controled by &lt;code&gt;f_norec&lt;/code&gt;. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here the important part is &lt;code&gt;f_norec&lt;/code&gt; and its parameter &lt;code&gt;f&lt;/code&gt; gives us the chance for correct substitution. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let memo_rec f_norec =  
  let fref = ref (fun _ -&amp;gt; assert false) in
  (* !fref below will have the new function defined next, which is
     the memoized one *)
  let h x = f_norec !fref x in 
  let f_mem = memoize h in
  fref := f_mem;
  f_mem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, &lt;code&gt;fref&lt;/code&gt;'s value will become the memoized one with &lt;code&gt;f_norec&lt;/code&gt;. Since &lt;code&gt;f_norec&lt;/code&gt; controls the logic and real work, we do not lose any functionality but can remember every &lt;em&gt;argument, result&lt;/em&gt; pairs along the recursive way.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post, we just list out three quite typical cases where imperative programming can be helpful. There are many others, such as &lt;a href=&quot;http://typeocaml.com/2014/11/13/magic-of-thunk-lazy/&quot;&gt;lazy&lt;/a&gt;, etc. &lt;/p&gt;

&lt;p&gt;Moreover, one more suggestion on using imperative style is that &lt;em&gt;don't expose imperative interface to public if you can&lt;/em&gt;. That means we should try to embed imperative code inside pure function as much as possible, so that the users of our functions cannot access the mutable parts. This way can let our functional code continue being pure enough while enjoying the juice of imperative programming internally.&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;[1].&lt;/strong&gt; glacialthinker has commented &lt;a href=&quot;http://www.reddit.com/r/ocaml/comments/2t49p9/mutable_and_when_shall_we_use_imperative/cnvryku&quot;&gt;here&lt;/a&gt;. This technique is called &lt;em&gt;untying the recursive knot&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Mystique_(comics)&quot;&gt;Mystique&lt;/a&gt; in the head image is another major character in &lt;a href=&quot;http://en.wikipedia.org/wiki/X-Men&quot;&gt;X-Men's world&lt;/a&gt;. &lt;em&gt;She is a shapeshifter who can mimic the appearance and voice of any person with exquisite precision.&lt;/em&gt; Similar like the &lt;em&gt;mutable&lt;/em&gt; in OCaml that always sticks to the same type once being created, human is the only &lt;em&gt;thing&lt;/em&gt; she can mutate to.&lt;/p&gt;</content><id>http://typeocaml.com/2015/01/20/mutable/</id><title type="text">Mutable</title><updated>2015-01-21T01:09:42-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2015/01/02/immutable/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/Immutable.jpg#hero&quot; alt=&quot;immutable&quot;/&gt;&lt;/p&gt;

&lt;p&gt;In &lt;strong&gt;pure functional programming&lt;/strong&gt;, everything is immutable. Strings, lists, values of customised types etc cannot be changed once being created. For example, a list such as &lt;code&gt;[1;2;3]&lt;/code&gt; does not have any operation that can alter its elements. If you want the stuff inside to be changed, you need to create a new list based on it. Suppose you want to change the first element of &lt;code&gt;[1;2;3]&lt;/code&gt; to be &lt;code&gt;4&lt;/code&gt;, then you have to &lt;code&gt;let new_list = 4::List.tl [1;2;3]&lt;/code&gt; or directly &lt;code&gt;let new_list = [4;2;3]&lt;/code&gt;, however, you don't have ways to do something like &lt;code&gt;old_list.first_element = 4&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;If you have got used to popular imperative programming languages such C, Java, Python, etc, you may feel that things being immutable sounds quite inconvenient. Yes, maybe sometimes being immutable forces us to do more things. In the example above, if we are able to do &lt;code&gt;old_list.first_element = 4&lt;/code&gt;, it seems more natural and straightforward. However, please do not overlook the power of being immutable. It provides us extra safety, and &lt;strong&gt;more importantly, it leads to a different paradigm - functional programming style&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Before we start to dive into immutables, there are two things that need to be clarified first. &lt;/p&gt;

&lt;h1&gt;Shadowing&lt;/h1&gt;

&lt;p&gt;People who start to learn OCaml may see something, like the trivial code below, is allowed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let f x =  
  let y = 1 in
  let y = 2 in
  x * y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two &lt;code&gt;y&lt;/code&gt;s and it seems that &lt;code&gt;y&lt;/code&gt; has been changed from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;2&lt;/code&gt;. A conclusion might be made that things in OCaml are actually mutable because &lt;code&gt;y&lt;/code&gt; is mutated. This conclusion is wrong. In OCaml, it is called &lt;em&gt;shadowing&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;Basically, the two &lt;code&gt;y&lt;/code&gt;s are different. After the binding of second &lt;code&gt;y&lt;/code&gt; is defined, the first &lt;code&gt;y&lt;/code&gt; is still there for the time being. Just because it happens to have the same name as second &lt;code&gt;y&lt;/code&gt;, it is in the shadow and can never be accessed later in the term of &lt;a href=&quot;http://www.cs.cornell.edu/Courses/cs3110/2014sp/lectures/3/lec03.html&quot;&gt;scope&lt;/a&gt;. Thus we should not say &lt;code&gt;y&lt;/code&gt; is mutated and in OCaml &lt;em&gt;variable&lt;/em&gt; / &lt;em&gt;binding&lt;/em&gt; is indeed immutable.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/shadow-1.jpg#small&quot; alt=&quot;shadowed&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;Mutable Variables and Values&lt;/h1&gt;

&lt;p&gt;The concept of being &lt;em&gt;immutable&lt;/em&gt; or &lt;em&gt;mutable&lt;/em&gt; was introduced because we need it to help us to predict whether something's possible change would affect other related things or not. In this section, we majorly talk about &lt;em&gt;mutable&lt;/em&gt; in imperative programming as clear understading of &lt;em&gt;what being mutable means&lt;/em&gt; can help us appreciate &lt;em&gt;immutable&lt;/em&gt; a little more.  &lt;/p&gt;

&lt;p&gt;It is easy to know &lt;em&gt;variable&lt;/em&gt; is mutable in imperative programming. For example, we can do &lt;code&gt;int i = 0;&lt;/code&gt;, then &lt;code&gt;i = 1;&lt;/code&gt; and the same &lt;code&gt;i&lt;/code&gt; is mutated. Altering a variable can affect other parts in the program, and it can be demonstrated using a &lt;em&gt;for loop&lt;/em&gt; example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/* The *for* scope repeatedly access `i` 
   and `i`'s change will affect each iteration. */

for (int i = 0; i &amp;lt; 10; i++)  
  System.out.println(i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes, even if a variable is mutated, it might not affect anything, like the example (in Java) below: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;int[] a = {1;2;3};  
int[] b = a;

a = {5;6;7};

/* What is b now? */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;a&lt;/code&gt; was initially &lt;code&gt;{1,2,3}&lt;/code&gt;. &lt;code&gt;b&lt;/code&gt; has been declared to be equal to &lt;code&gt;a&lt;/code&gt; so &lt;code&gt;b&lt;/code&gt; has the same value as &lt;code&gt;{1,2,3}&lt;/code&gt;. &lt;code&gt;a&lt;/code&gt; later on was changed to &lt;code&gt;{5,6,7}&lt;/code&gt;. Should &lt;code&gt;b&lt;/code&gt; be changed to &lt;code&gt;{5,6,7}&lt;/code&gt; as well? Of course not, &lt;code&gt;b&lt;/code&gt; still remains as &lt;code&gt;{1,2,3}&lt;/code&gt;. Thus, even if &lt;code&gt;a&lt;/code&gt; is mutated, &lt;code&gt;b&lt;/code&gt; is not affected. This is because in this case, the &lt;em&gt;value&lt;/em&gt; underneath has not been mutated. Let's modify the code a little bit:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;int[] a = {1,2,3};  
int[] b = a;

a[0] = 0;

/* What is b now? */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;a[0] = 0;&lt;/code&gt; altered the first element in the underlying array and &lt;code&gt;a&lt;/code&gt; would become &lt;code&gt;{0,2,3}&lt;/code&gt;. Since &lt;em&gt;array&lt;/em&gt; in Java is &lt;em&gt;mutable&lt;/em&gt;, &lt;code&gt;b&lt;/code&gt; now becomes &lt;code&gt;{0,2,3}&lt;/code&gt; too as &lt;code&gt;b&lt;/code&gt; was assigned the identical array as &lt;code&gt;a&lt;/code&gt; had initially. So the array value being mutable can lead to the case where if a mutable value is changed somewhere, all places that access it will be affected.  &lt;/p&gt;

&lt;p&gt;A &lt;em&gt;mutable&lt;/em&gt; value must provide a way for developers to alter itself through bindings, such as &lt;code&gt;a[0] = 0;&lt;/code&gt; is the way for arrays, i.e., via &lt;code&gt;a[index]&lt;/code&gt; developers can access the array &lt;code&gt;a&lt;/code&gt; by &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; can directly assign the new element at that index in the array. &lt;/p&gt;

&lt;p&gt;A &lt;em&gt;immutable&lt;/em&gt; value does not provide such as way. We can check immutable type &lt;em&gt;String&lt;/em&gt; in Java to confirm this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/immutable_mutable-1.jpg#small&quot; alt=&quot;immutable_mutable&quot;/&gt;&lt;/p&gt;

&lt;p&gt;To summarise, when dealing with &lt;em&gt;mutable&lt;/em&gt;, especially when we test our imperative code, we should not forget possible changes of both &lt;em&gt;variable&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that OCaml does support &lt;em&gt;mutable&lt;/em&gt; and it is a kind of hybrid of &lt;em&gt;functional&lt;/em&gt; and &lt;em&gt;imperative&lt;/em&gt;. However, we really should care about the &lt;em&gt;functional&lt;/em&gt; side of OCaml more. For the &lt;em&gt;imperative&lt;/em&gt; style of OCaml and when to use it, the next post will cover with details.&lt;/p&gt;

&lt;h1&gt;Extra Safety from Immutable&lt;/h1&gt;

&lt;p&gt;As described before, if a mutable variable / value is altered in one place, we need to be cautious about all other places that may have access to it. The code of altering an array in the previous section is an example. Another example is supplying a mutable value to a method as argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static int getMedian(int[] a) {  
    Arrays.sort(a);
    return a[a.length/2];
}

public static void main(String[] args) {  
    int[] x = {3,4,2,1,5,9,6};
    int median = getMedian(x);

    /* x is not {3,4,2,1,5,9,6} any more */
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getMedian&lt;/code&gt; will sort the supplied argument and the order of the elements in &lt;code&gt;x&lt;/code&gt; will be changed after the call. If we need &lt;code&gt;x&lt;/code&gt; to always maintain the original order, then the above code has serious flaw. It is not that bad if it is us who wrote &lt;code&gt;getMedian&lt;/code&gt;, because we can just refine the code directly. However, if &lt;code&gt;getMedian&lt;/code&gt; is in a third party library, even though we still can override this method, how can we know whether other method in the same library have this kind of flaw or not? A library would be useless if we cannot trust it completely. &lt;/p&gt;

&lt;p&gt;Allowing mutables also introduces troubles for threading. When multiple threads try to alter a mutable value at the same time, we sometimes can just put a locker there to restrain the access to the value, with the sacrifice of make it single-threading at that point. However, if we have to precisely control the order of altering, things get much more complicated. This is why we have hundreds of books and articles to teach how to do a great multithreading in imperative programming languages. &lt;/p&gt;

&lt;p&gt;If everything is immutable, then we do not need to worry about any of those any more. When we need to alter an immutable value, we create a new value that implements the change based on the old value and the old value is kept intact. All places that need access to the original value are very safe. As an example in OCaml:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* trivial way to get median in OCaml, simply for comparison to the imperative case *)
let get_median l =  
  (* we can't sort in place, have to return a new sorted list *)
  let sorted_l = List.sort compare l in
  let len = List.length l in
  List.nth (len/2) sorted_l (* here we use our new sorted list *)

let median_mul_hd =  
  let l = [3;4;2;1;5;9;6] in
  let median = get_median l in
  median * List.hd l (* the hd of l will not be 1, but still 3 - the original hd *)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With immutables, the burden of cautions on unexpected modification of values are  relieved for us. Hence, for OCaml, we do not need to spend time on studying materials such as &lt;em&gt;Item 39: Make defensive copies when needed&lt;/em&gt; in &lt;a href=&quot;http://www.amazon.co.uk/Effective-Java-Edition-Joshua-Bloch/dp/0321356683&quot;&gt;Effective Java&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/extra_safety-2.jpg#small&quot; alt=&quot;extra_safety&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Being immutable brings extra safety to our code and helps us to avoid possibly many trivial bugs like the ones described before. However, this is not free of charge. We may feel more restrictive and lose much flexibilities (&lt;em&gt;[1]&lt;/em&gt;). Moreover, because we cannot alter anything, pure functional programming forces us to adapt to a new style, which will be illustrated next. &lt;/p&gt;

&lt;h1&gt;Functional Programming Style&lt;/h1&gt;

&lt;p&gt;As mentioned in &lt;a href=&quot;http://typeocaml.com/2014/12/04/recursion-reloaded/&quot;&gt;Recursion Reloaded&lt;/a&gt;, we &lt;em&gt;cannot&lt;/em&gt; use loops such in pure functional programming, because &lt;em&gt;mutable&lt;/em&gt; is not in functional world. Actually, there was a little misinterpretation there: it is not &lt;em&gt;we cannot&lt;/em&gt; but is &lt;em&gt;we are not able to&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;A typical &lt;em&gt;while loop&lt;/em&gt; in Java looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;int i = 0;  
while ( i &amp;lt; 10 ) {  
   ...
   i++;
}

/* note that above is the same as
   for(int i = 0; i &amp;lt; n; i++) ... */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason that the while loop works in Java is because:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; is defined before &lt;code&gt;while&lt;/code&gt; scope.  &lt;/li&gt;
&lt;li&gt;We go into &lt;code&gt;while&lt;/code&gt; scope and &lt;code&gt;i&lt;/code&gt; continues to be valid inside.  &lt;/li&gt;
&lt;li&gt;Since &lt;code&gt;i&lt;/code&gt; is mutable, &lt;code&gt;i&lt;/code&gt;'s change is also valid inside &lt;code&gt;while&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;So we can check the same &lt;code&gt;i&lt;/code&gt; again and again, and also use it repeatedly inside &lt;code&gt;while&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Are we able to do the same thing in OCaml / Functional Programming? The answer is &lt;strong&gt;no&lt;/strong&gt;.If you are not convinced, then we can try to assume we were able to and &lt;strong&gt;fake&lt;/strong&gt; some OCaml syntax. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* fake OCaml code *)

let i = 0 in  
while i &amp;lt; 10 do  
  ...
  let i = i + 1 ...
end while
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; is defined before &lt;em&gt;while&lt;/em&gt;, no problem.  &lt;/li&gt;
&lt;li&gt;Initially, &lt;code&gt;while&lt;/code&gt; gets &lt;code&gt;i&lt;/code&gt; for the first time and check it against &lt;code&gt;10&lt;/code&gt;, no problem.  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; can be used for the first time inside &lt;code&gt;...&lt;/code&gt;, still no problem.  &lt;/li&gt;
&lt;li&gt;Then we need to increase &lt;code&gt;i&lt;/code&gt; and the problem starts.  &lt;/li&gt;
&lt;li&gt;Recall that &lt;code&gt;i&lt;/code&gt; is immutable in OCaml. The &lt;code&gt;first i&lt;/code&gt; after &lt;code&gt;let&lt;/code&gt; in &lt;code&gt;let i = i + 1&lt;/code&gt; is actually new and the &lt;code&gt;original i&lt;/code&gt; is shadowed.  &lt;/li&gt;
&lt;li&gt;The new &lt;code&gt;i&lt;/code&gt; is created within the &lt;code&gt;while&lt;/code&gt; scope, so after one iteration, it is invalid any more.  &lt;/li&gt;
&lt;li&gt;Thus the second time at &lt;code&gt;while i &amp;lt; 10 do&lt;/code&gt;, the original &lt;code&gt;i&lt;/code&gt; would be still 0 and the loop would stuck there forever. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The above attempt proves that we can't do looping in pure functional programming any more. This is why we replace it with recursion as described in &lt;a href=&quot;http://typeocaml.com/2014/12/04/recursion-reloaded/&quot;&gt;Recursion Reloaded&lt;/a&gt; before. &lt;/p&gt;

&lt;p&gt;Furthermore, we can see that the execution runtime in imperative programming is normally driven by mutating states (like the &lt;em&gt;while loop&lt;/em&gt; gets running by changing &lt;code&gt;i&lt;/code&gt;). In functional programming, however, the execution continues by creating new things and giving them to the next call / expression / function. Just like in recursion, a state needs to be changed, so we give the same function the new state as argument. This is indeed &lt;em&gt;the functional programming style:&lt;/em&gt; &lt;strong&gt;we create and then deliver&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;One may still think &lt;em&gt;imperative&lt;/em&gt; is easier and more straightforward than &lt;em&gt;functional&lt;/em&gt;. Our brain likes &lt;em&gt;change and forget&lt;/em&gt;, so for &lt;em&gt;imperative&lt;/em&gt;'s easiness, maybe. However, if you say &lt;em&gt;imperative&lt;/em&gt; is more straightforward, I doubt it.&lt;/p&gt;

&lt;p&gt;Let's temporarily forget the programming / coding part and just have a look at something at high level. &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Suppose there is process, in which there are two states: &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. Most importantly, &lt;code&gt;State A&lt;/code&gt; can change to &lt;code&gt;State B&lt;/code&gt;. Now plese close your eyes and draw a diagram for this simple process in your mind. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Done? &lt;/p&gt;

&lt;p&gt;I bet you imagined this diagram as below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/state_true.jpg#small&quot; alt=&quot;state_true&quot;/&gt;&lt;/p&gt;

&lt;p&gt;But NOT &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/state_false.jpg#small&quot; alt=&quot;state_false&quot;/&gt;&lt;/p&gt;

&lt;p&gt;When we were really thinking of the trivial process, there must be two separate states in our mind and an explicit arrow would be there to clearly indicate the transition. This is much more nature than imagining just one state and the two situations inside. Afterall, this is called landscape and we often need it when we design something. &lt;/p&gt;

&lt;p&gt;When we start to implement it, we might think differently. We sometimes intend to use the easy way we get used to. For example, in many cases we can just use one state variable and forget &lt;code&gt;State A&lt;/code&gt; after transiting to &lt;code&gt;State B&lt;/code&gt; during implementation, because always remembering &lt;code&gt;State A&lt;/code&gt; may be unnecessary. This difference between design and implementation are always there and we are just not aware of it or we just feel it smoother due to our imperative habit. &lt;/p&gt;

&lt;p&gt;Functional programming style does not have that difference. In the above example, if we implement it in OCaml, we will do exactly the same as the upper diagram, i.e., we create &lt;code&gt;State A&lt;/code&gt; and when the state needs to be changed to &lt;code&gt;B&lt;/code&gt;, we create a new &lt;code&gt;State B&lt;/code&gt;. This is why I say &lt;em&gt;functional&lt;/em&gt; is more straightforward because it directly reflects our intuitive design. If you are not convinced still, let's design and implement the &lt;em&gt;quicksort&lt;/em&gt; in both imperative and functional styles as an demonstration.&lt;/p&gt;

&lt;h1&gt;Quicksort&lt;/h1&gt;

&lt;p&gt;Quicksort is a classic sorting algorithm. &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If only one or no element is there, then we are done.  &lt;/li&gt;
&lt;li&gt;Everytime we select a pivot element, e.g. the first element,  from all elements that we need to sort.  &lt;/li&gt;
&lt;li&gt;We compare elements with the pivot, put the &lt;em&gt;smaller&lt;/em&gt; elements on its left hand side and &lt;em&gt;larger&lt;/em&gt; ones on its right hand side. Note that neither &lt;em&gt;smaller&lt;/em&gt;s or &lt;em&gt;larger&lt;/em&gt;s need to be in order.  &lt;/li&gt;
&lt;li&gt;The pivot then gets fixed.  &lt;/li&gt;
&lt;li&gt;Quicksort all elements on its left.  &lt;/li&gt;
&lt;li&gt;Quicksort all elements on its right. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The core idea of quicksort is that we partition all elements into 3 parts: &lt;em&gt;smaller&lt;/em&gt;, &lt;em&gt;pivot&lt;/em&gt; and &lt;em&gt;larger&lt;/em&gt; in every iteration. So &lt;em&gt;smaller&lt;/em&gt; elements won't need to be compared with &lt;em&gt;bigger&lt;/em&gt; elements ever in the future, thus time is saved. In addition, although we split the elements into 3 parts, &lt;em&gt;pivot&lt;/em&gt; will be fixed after one iteration and only &lt;em&gt;smaller&lt;/em&gt; and &lt;em&gt;larger&lt;/em&gt; will be taken account into the next iteration. Hence the number of effective parts, which cost time next, is actually 2. How many times we can get &lt;em&gt;smaller&lt;/em&gt; and &lt;em&gt;larger&lt;/em&gt; then? &lt;em&gt;O(logn)&lt;/em&gt; times, right? So at most we will have &lt;em&gt;O(logn)&lt;/em&gt; iterations. Hence The time complexity of quicksort is &lt;em&gt;O(nlogn)&lt;/em&gt;.&lt;/p&gt;

&lt;h2&gt;Design&lt;/h2&gt;

&lt;p&gt;The key part of quicksort is &lt;em&gt;partitioning&lt;/em&gt;, i.e., step 2 and 3. How can we do it? Again, let's design the process first without involving any coding details. &lt;/p&gt;

&lt;p&gt;Say we have some elements &lt;code&gt;4, 1, 6, 3, 7&lt;/code&gt;. You don't have to write any code and you just need to manually partition them once like step 2 and 3. How will you do it in your imagination or on paper? Could you please try it now?&lt;/p&gt;

&lt;p&gt;Done?&lt;/p&gt;

&lt;p&gt;I bet you imagined or wrote down the flow similar as below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/quicksort-1.jpg#small&quot; alt=&quot;quicksort&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The mechanism of &lt;em&gt;partition&lt;/em&gt; is not complicated. We get the &lt;em&gt;pivot&lt;/em&gt; out first. Then get an element out of the rest of elements one by one. For each element, we compare it with the &lt;em&gt;pivot&lt;/em&gt;. If it is smaller, then it goes to the left; otherwise, goes to the right. The whole process ends when no element remains. Simple enough? I believe even for non-developers, they would mannually do the &lt;em&gt;partition&lt;/em&gt; like shown in the diagram. &lt;/p&gt;

&lt;p&gt;Our design of &lt;em&gt;partition&lt;/em&gt; is quite finished. It is time to implement it.&lt;/p&gt;

&lt;h2&gt;Imperative implementation&lt;/h2&gt;

&lt;p&gt;Let's first try using Java. Can we follow the design in the diagram directly? I bet not. The design assumed that the pivot &lt;code&gt;4&lt;/code&gt; will have two bags (initially empty): one on its left and the other on its right. Just this single point beats Java. In Java or other imperative programming languages, normally when we sort some elements, all elements are in an array and we prefer doing things in place if we are able to. That says, for example, if we want &lt;code&gt;1&lt;/code&gt; to be on the left hand side of &lt;code&gt;4&lt;/code&gt;, we would use &lt;em&gt;swap&lt;/em&gt;. It is efficient and the correct way when adjusting the positions of elements in an array.&lt;/p&gt;

&lt;p&gt;There are a number of ways to implement &lt;em&gt;partition&lt;/em&gt; in Java and here the one presented in the book of &lt;a href=&quot;http://algs4.cs.princeton.edu/23quicksort/&quot;&gt;Algorithms, Robert Sedgewick and Kevin Wayne&lt;/a&gt; is briefly presented as a diagram below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2015/01/quicksort_imperative-1.jpg#small&quot; alt=&quot;quicksort_imperative&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We do not have &lt;em&gt;smaller bag&lt;/em&gt; or &lt;em&gt;larger bag&lt;/em&gt; any more. We do not do &lt;em&gt;throwing element into according bag&lt;/em&gt; either. We have to maintain two additional pointers &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;. &lt;code&gt;i&lt;/code&gt; is used to indicate the next element in action. If an element is smaller than the pivot, swapping it with the pivot will put it to the left. If an element is larger, then we swap it with &lt;code&gt;j&lt;/code&gt;'s element. &lt;code&gt;j&lt;/code&gt; can now decrease while &lt;code&gt;i&lt;/code&gt; stays put because &lt;code&gt;i&lt;/code&gt; now is a new element that was just swapped from &lt;code&gt;j&lt;/code&gt;. The whole process stops when &lt;code&gt;i &amp;gt; j&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;As we can see, the implementation is quite different from the high level design and much more complicated, isn't it? The design just tells us &lt;em&gt;we get a new element out, compare it with the pivot, and put it to the left or right depending on the comparison.&lt;/em&gt;. We cannot have such a simple summary for the implementation above. More than that, we need to pay extra attention on &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; as &lt;strong&gt;manipulating indices of an array is always error-prone&lt;/strong&gt;. &lt;/p&gt;

&lt;p&gt;The Java code is directly copied from &lt;a href=&quot;http://algs4.cs.princeton.edu/23quicksort/Quick.java.html&quot;&gt;the book&lt;/a&gt; to here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;private static int partition(Comparable[] a, int lo, int hi) {  
        int i = lo;
        int j = hi + 1;
        Comparable v = a[lo];
        while (true) { 
            // find item on lo to swap
            while (less(a[++i], v))
                if (i == hi) break;

            // find item on hi to swap
            while (less(v, a[--j]))
                if (j == lo) break;      // redundant since a[lo] acts as sentinel

            // check if pointers cross
            if (i &amp;gt;= j) break;

            exch(a, i, j);
        }

        // put partitioning item v at a[j]
        exch(a, lo, j);

        // now, a[lo .. j-1] &amp;lt;= a[j] &amp;lt;= a[j+1 .. hi]
        return j;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Functional Implementation&lt;/h2&gt;

&lt;p&gt;The functional implementation fits the design perfectly and We have to thank the &lt;em&gt;always creating new and deliver&lt;/em&gt; of functional programming style for that.  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The design asks for two bags around the pivot and we can directly do that: &lt;code&gt;(left, pivot, right)&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;The design says if an element is &lt;em&gt;smaller&lt;/em&gt;, then put to the left. We can again directly do that &lt;code&gt;if x &amp;lt; pivot then (x::left, pivot, right)&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;We can also directly handle &lt;em&gt;larger&lt;/em&gt;: &lt;code&gt;else (left, pivot, x::right)&lt;/code&gt;. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For iterations, we can just use &lt;em&gt;recursion&lt;/em&gt;. The complete OCaml code for &lt;em&gt;partition&lt;/em&gt; is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let partition pivot l =  
  (* we can actually remove pivot in aux completely.
     we put it here to make it more meaningful *)
  let rec aux (left, pivot, right) = function
    | [] -&amp;gt; (left, pivot, right)
    | x::rest -&amp;gt;
      if x &amp;lt; pivot then aux (x::left, pivot, right) rest
      else aux (left, pivot, x::right) rest
  in
  aux ([], pivot, []) l (* two bags are initially empty *)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you know &lt;code&gt;fold&lt;/code&gt; and remove pivot during the process, then it can be even simpler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* using the List.fold from Jane Street's core lib *)
let partition_fold pivot l =  
  List.fold ~f:(
    fun (left, right) x -&amp;gt; 
      if x &amp;lt; pivot then (x::left, right)
      else (left, x::right)) ~init:([], []) l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One we get the functional &lt;em&gt;partition&lt;/em&gt;, we can write &lt;em&gt;quicksort&lt;/em&gt; easily:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec quicksort = function  
  | [] | _::[] as l -&amp;gt; l
  | pivot::rest -&amp;gt;
    let left, right = partition_fold pivot rest in
    quicksort left @ (pivot::quicksort right)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;Now we have two implementations for &lt;em&gt;quicksort&lt;/em&gt;: imperative and functional. Which one is more straightforward and simpler? &lt;/p&gt;

&lt;p&gt;In fact, functional style is more than just being consistent with the design: &lt;strong&gt;it handles data directly, instead of via any intermedia layer in between&lt;/strong&gt;. In imperative programming, we often use array and like we said before, we have to manipulate the indices. The &lt;em&gt;indices&lt;/em&gt; stand between our minds and the data. In functional programming, it is different. We use immutable list and using indices makes not much sense any more (as it will be slow). So each time, we just care the head element and often it is more than enough. This is one of the reasons why I love OCaml. Afterall, we want to deal with data and why do we need any unnecessary gates to block our way while they pretend to help us?&lt;/p&gt;

&lt;p&gt;One may say imperative programming is faster as we do not need to constantly allocate memory for new things. Yes, normally array is faster than list. And also doing things in place is more effient. However, OCaml has a very good type system and a great &lt;a href=&quot;https://realworldocaml.org/v1/en/html/understanding-the-garbage-collector.html&quot;&gt;GC&lt;/a&gt;, so the performance is not bad at all even if we always creating and creating. &lt;/p&gt;

&lt;p&gt;If you are interested, you can do the design and imperative implementation for &lt;em&gt;mergesort&lt;/em&gt;, and you will find out that we have to create new auxiliary spaces just like we would do in functional programming. &lt;/p&gt;

&lt;h1&gt;OCaml - the Hybrid&lt;/h1&gt;

&lt;p&gt;So far in this post, we used quite a lot of comparisons between imperative and functional to prove &lt;em&gt;immutable is good&lt;/em&gt; and &lt;em&gt;functional programming style is great&lt;/em&gt;. Yes, I am a fan of OCaml and believe functional programming is a decent way to do coding. However, I am not saying imperative programming is bad (I do Java and Python for a living in daytime and become an OCamler at deep night). &lt;/p&gt;

&lt;p&gt;&lt;em&gt;Imperative&lt;/em&gt; has its glories and OCaml actually never forgets that. That's why OCaml itself is a hybrid, i.e., you can just write OCaml code in imperative style. One of the reasons OCaml reserves imperative part is that sometimes we need to remember a state in one single place. Another reason can be that we need arrays for a potential performance boost. &lt;/p&gt;

&lt;p&gt;Anyhow, OCaml is still a functional programming language and we should not forget that. Especially for beginners, please do pure functional programming in OCaml as much as possible. Do not bow to your imperative habit. For the question of &lt;em&gt;when should I bring up imperative style in OCaml&lt;/em&gt; will be answered in the next post &lt;a href=&quot;http://typeocaml.com/2015/01/20/mutable/&quot;&gt;Mutable&lt;/a&gt;. &lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;[1].&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;People enjoy flexbilities and conveniences, and that's one of the reasons why many people fancy Java and especially Python. It feels free there and we can easily &lt;a href=&quot;http://www.amazon.co.uk/Beginning-Python-Programming-Learn-Treading-ebook/dp/B00639H0AK/&quot;&gt;learn them in 7 days&lt;/a&gt; and implement our ideas with them quickly. However, be aware of the double sides of being flexible and convenient. &lt;/p&gt;

&lt;p&gt;When we really want to make a proper product using Java or Python, we may need to read books on &lt;em&gt;what not to do even though they are allowed&lt;/em&gt; (yeah, this is a point, if we should not use something in most cases, why it is allowed at all?). We have to be very careful in many corners and 30% - 50% of the time would be spent on testing. Eventually, &lt;em&gt;how to write beautiful code&lt;/em&gt; might become &lt;em&gt;how to test beautifully&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;OCaml and other functional programming languages are on the opposite side - they are very restrictive, but restrictions are for the great of good. For example, we cannot freely use the best excuse of &lt;em&gt;sorry I can't return you a valid answer&lt;/em&gt; - &lt;strong&gt;return null;&lt;/strong&gt;. Instead, we have the &lt;em&gt;None&lt;/em&gt;, which is part of &lt;em&gt;option&lt;/em&gt;, to explicitly tell you that nothing can be returned. The elegant reward of using &lt;em&gt;option&lt;/em&gt; is that when we try to access it, &lt;strong&gt;we have to deal with the &lt;em&gt;None&lt;/em&gt;&lt;/strong&gt;. Thus &lt;em&gt;NullPointerException&lt;/em&gt; does not exist in OCaml (&lt;em&gt;[2]&lt;/em&gt;). &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/null.jpg#small&quot; alt=&quot;null&quot;/&gt;&lt;/p&gt;

&lt;p&gt;For &lt;em&gt;if&lt;/em&gt; and &lt;em&gt;pattern matching&lt;/em&gt;, OCaml forces us to cover all possible cases. It sounds troublesome during coding as we sometimes know that we don't care about some cases or some cases will never happen. Yes, we may ignore those cases in our working code in Java or Python, but later do we have to consider them in testing code? Often we do, right? &lt;/p&gt;

&lt;p&gt;OCaml cuts off some flexibilities. As an outcome, to achieve a goal, we have quite limited number of ways and occasionally even just one way and that way might be very tough (we will see it in later posts on functional pearls). But trust me, after mastering OCaml at a certain level and looking at the very robust OCaml code you wrote, you would appreciate OCaml and recall this slogan: &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&amp;quot;Less is more&amp;quot; - Andrea del Sarto, Robert Browning. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;[2].&lt;/strong&gt; &amp;quot;Options are important because they are the standard way in OCaml to encode a value that might not be there; there's no such thing as a NullPointerException in OCaml. &amp;quot; - &lt;a href=&quot;https://realworldocaml.org/v1/en/html/a-guided-tour.html&quot;&gt;Chapter 1 in Real World Ocaml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ps.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Wolverine_(character)&quot;&gt;Wolverine&lt;/a&gt; in the head image of this post is a major character in &lt;a href=&quot;http://en.wikipedia.org/wiki/X-Men&quot;&gt;X-Men's world&lt;/a&gt;. Since the regeneration of his body cells is super fast, he will not be permernantly hurt or age. Just like Wolverine, &lt;em&gt;immutables&lt;/em&gt; in OCaml will not change once created. However, unlike Wolverine, they can not be immortals because many of them would be recycled by the garbage collector at some point during the runtime.&lt;/p&gt;</content><id>http://typeocaml.com/2015/01/02/immutable/</id><title type="text">Immutable</title><updated>2015-01-02T15:52:41-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2014/12/19/how-to-become-a-bst-ninja-genin/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/bst_ninja.jpg#hero&quot; alt=&quot;bst_ninja&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Binary Search Tree (&lt;em&gt;BST&lt;/em&gt;) is one of the most classic data structures. The definition for its structure is shown as below:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It consists of &lt;em&gt;Nodes&lt;/em&gt; and &lt;em&gt;Leaves&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;Node&lt;/em&gt; has a child bst on the &lt;em&gt;left&lt;/em&gt; side, a &lt;em&gt;key&lt;/em&gt; (, a &lt;em&gt;data&lt;/em&gt;), and a child bst on the &lt;em&gt;right&lt;/em&gt; side. Note here &lt;strong&gt;a node's left or right child is not a node, instead, is indeed another binary search tree&lt;/strong&gt;. &lt;/li&gt;
&lt;li&gt;A &lt;em&gt;Leaf&lt;/em&gt; has nothing but act only as a STOP sign. &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type 'a bst_t =  
  | Leaf
  | Node of 'a bst_t * 'a * 'a bst_t (* Node (left, key, right) *)
(* a node may also carry a data associated with the key. 
   It is omitted here for neater demonstration *)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important feature that makes BST unique is &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;for any node
&lt;ul&gt;&lt;li&gt;all keys from its &lt;strong&gt;left child are smaller&lt;/strong&gt; than its own key&lt;/li&gt;
&lt;li&gt;all keys from its &lt;strong&gt;right child are bigger&lt;/strong&gt; (assumming keys are distinct)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And here is an example of BST:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/example_bst.jpg&quot; alt=&quot;example_bst&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Instead of continuing to present the basics of BST, this post will now focus on how to attack BST related problems with the most powerful weapon: &lt;strong&gt;Recursion&lt;/strong&gt;. &lt;/p&gt;

&lt;h1&gt;Recursion on BST&lt;/h1&gt;

&lt;p&gt;From &lt;a href=&quot;http://typeocaml.com/2014/12/04/recursion-reloaded/&quot;&gt;Recursion Reloaded&lt;/a&gt;, we know that one way to model recursion is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Assume we already got a problem solver: &lt;code&gt;solve&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Don't think about what would happen in each iteration.  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Split&lt;/strong&gt; the problem to smallers sizes (&lt;em&gt;N = N1 + N2 + ...&lt;/em&gt;).  &lt;/li&gt;
&lt;li&gt;Solve those smaller problems like &lt;code&gt;solve N1&lt;/code&gt;, &lt;code&gt;solve N2&lt;/code&gt;, ... Here is the tricky part: still, we do not know or care what are inside &lt;code&gt;solve&lt;/code&gt; and how &lt;code&gt;f&lt;/code&gt; would do the job, we just believe that it will return the correct results.  &lt;/li&gt;
&lt;li&gt;Now we have those results for smaller problems, how to &lt;strong&gt;wire&lt;/strong&gt; them up to return the result for &lt;em&gt;N&lt;/em&gt;? This is the ultimate question we need to answer.  &lt;/li&gt;
&lt;li&gt;Of course, we do not forget the &lt;strong&gt;STOP sign&lt;/strong&gt; for some edge cases.  &lt;/li&gt;
&lt;li&gt;Together with point 5 and 6, we get our &lt;code&gt;solve&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A good thing coming from BST is that the &lt;em&gt;split&lt;/em&gt; step has been done already, i.e., a BST problem can be always divided into &lt;em&gt;left child&lt;/em&gt;, &lt;em&gt;root&lt;/em&gt;, and &lt;em&gt;right child&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Thus if we assume we already got &lt;code&gt;solve&lt;/code&gt;, we just need to solve &lt;em&gt;left&lt;/em&gt; and / or solve &lt;em&gt;right&lt;/em&gt;, then do something with &lt;em&gt;root&lt;/em&gt;, and finally wire all outcomes to obtain the final result. Again, we should of course never forget the STOP sign and in BST, usually it is the &lt;em&gt;Leaf&lt;/em&gt;, i.e., we need to ask ourselves what if the BST is a &lt;em&gt;Leaf&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;The thinking flow is illustrated as the diagram below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/left_root_right-4.jpg&quot; alt=&quot;solve&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Before we start to look at some problems, note that in the diagram above or &lt;a href=&quot;http://typeocaml.com/2014/12/04/recursion-reloaded/&quot;&gt;Recursion Reloaded&lt;/a&gt;, we seem to always solve &lt;em&gt;both left and right&lt;/em&gt;, or say, &lt;em&gt;all sub-problmes&lt;/em&gt;. It is actually not necessary. For BST, sometimes &lt;em&gt;either left or right&lt;/em&gt; is enough. Let's have a look at this case first. &lt;/p&gt;

&lt;h1&gt;Either Left or Right&lt;/h1&gt;

&lt;p&gt;Our starter for this section is the simplest yet very essential operation: &lt;strong&gt;insert&lt;/strong&gt; a key to a BST.&lt;/p&gt;

&lt;h2&gt;Insert&lt;/h2&gt;

&lt;p&gt;From the definition of BST, we know the basic rule is that if the new key is smaller than a root, then it belongs to the root's left child; otherwise, to the root's right child. Let's follow the modelling in the previous diagram to achieve this.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We assume we already got &lt;code&gt;insert key bst&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;We know the problem can be split into &lt;em&gt;left&lt;/em&gt;, &lt;em&gt;root&lt;/em&gt;, and &lt;em&gt;right&lt;/em&gt;.  &lt;/li&gt;
&lt;li&gt;Because a new key can go either left or right, so we need to &lt;em&gt;deal_with root&lt;/em&gt; first, i.e., compare the new key and the key of the root.  &lt;/li&gt;
&lt;li&gt;Directly taken from the rule of BST, if the new key is smaller, then we need to &lt;em&gt;solve left&lt;/em&gt; thus &lt;code&gt;insert key left&lt;/code&gt;; otherwise &lt;code&gt;insert key right&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;What if we get to a &lt;em&gt;Leaf&lt;/em&gt;? It means we can finally place our new key there as a new &lt;em&gt;Node&lt;/em&gt; and of course, at this moment both children of the new &lt;em&gt;Node&lt;/em&gt; are &lt;em&gt;Leaves&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/insert-2.jpg&quot; alt=&quot;insert&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Note that the BST type in OCaml we defined early on is pure functional, which means every time we need to update something, we have to create new. That's why in the diagram, even if we just insert x to left or right, we need to construct a new &lt;em&gt;Node&lt;/em&gt; because we are updating the left child or the right one. The code is shown as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec insert x = function  
  | Leaf -&amp;gt; Node (Leaf, x, Leaf) (* Leaf is a STOP *)
  | Node (left, k, right) -&amp;gt;
    if x &amp;lt; k then Node (insert x left, k, right) (* if x is smaller, go left *)
    else Node (left, k, insert x right) (* otherwise, go right *)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Member&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;member&lt;/code&gt; is to check whether a given key exists in the BST or not. It is very similar to &lt;code&gt;insert&lt;/code&gt;. There are three differences:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;When &lt;em&gt;dealing with root&lt;/em&gt;, we need to see whether the given key equals to the root's key or not. If yes, then we hit it.  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;member&lt;/code&gt; is a readonly function, so we directly solve &lt;em&gt;left&lt;/em&gt; or &lt;em&gt;right&lt;/em&gt; without constructing new &lt;em&gt;Node&lt;/em&gt;.  &lt;/li&gt;
&lt;li&gt;If arriving at a &lt;em&gt;Leaf&lt;/em&gt;, then we have nowhere to go any more and it means the given key is not in the BST.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec mem x = function  
  | Leaf -&amp;gt; false
  | Node (left, k, right) -&amp;gt;
    if x &amp;lt; k then mem x left
    else if x = k then true
    else mem x right
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Both Left and Right&lt;/h1&gt;

&lt;p&gt;Usually when we need to retrieve some properties of a BST or possibly go through all nodes to get an answer, we have to solve both children. However, the modelling technique does not change. &lt;/p&gt;

&lt;h2&gt;Height&lt;/h2&gt;

&lt;p&gt;Recall from &lt;a href=&quot;http://typeocaml.com/2014/11/26/height-depth-and-level-of-a-tree/&quot;&gt;Some properties of a tree&lt;/a&gt;, the height of a tree is the number of edges that the longest path (from the root to a leaf) has. From this definition, it seems easy to get the height. We simply try to find all possible paths from root and for each path we record its number of edges. The answer will be the max of them. It sounds straightforward, but if you really try to write the code in this way, I bet the code would be a bit messy. Honestly, I never wrote in this way and I will never do that.&lt;/p&gt;

&lt;p&gt;Another way is to think recursively. First let analyse a little bit about the longest path matter.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/height.jpg#small&quot; alt=&quot;height&quot;/&gt;&lt;/p&gt;

&lt;p&gt;As we can see from the above diagram, &lt;em&gt;Root&lt;/em&gt; has two edges: one to &lt;em&gt;Left&lt;/em&gt; and the other to &lt;em&gt;Right&lt;/em&gt;. So whatever the longest path from &lt;em&gt;Root&lt;/em&gt; might be, it must pass either &lt;em&gt;Left&lt;/em&gt; or &lt;em&gt;Right&lt;/em&gt;. If we somehow could obtain the longest path from the root of &lt;em&gt;Left&lt;/em&gt; and the longest path from the root of &lt;em&gt;Right&lt;/em&gt;, the longest path from &lt;em&gt;Root&lt;/em&gt; should be the bigger one of the two paths, right?&lt;/p&gt;

&lt;p&gt;Let's now assume we already got &lt;code&gt;height&lt;/code&gt; and it will return the height of a BST. Then we can obtain &lt;code&gt;h_left&lt;/code&gt; and &lt;code&gt;h_right&lt;/code&gt;. The answer is what is the &lt;code&gt;h&lt;/code&gt; (height of &lt;em&gt;Root&lt;/em&gt;)? Note that the height implies the longest path already (that's the definition). So from the paragraph above, What we need to do is getting &lt;code&gt;max h_left h_right&lt;/code&gt;. Since &lt;em&gt;Root&lt;/em&gt; has an edge to either child, &lt;code&gt;h = 1 + max h_left h_right&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Don't forget the &lt;em&gt;STOP&lt;/em&gt; sign: the height of a Leaf is 0.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec height = function  
  | Leaf -&amp;gt; 0
  | Node (left, _, right) -&amp;gt; 1 + max (height left) (height right)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simple, isn't it?&lt;/p&gt;

&lt;h2&gt;Keys at a certain depth&lt;/h2&gt;

&lt;p&gt;So far, it seems our hypothetic &lt;code&gt;solve&lt;/code&gt; function takes only the sub-probem as parameter. In many cases this is not enough. Sometimes we need to supply &lt;strong&gt;more arguments&lt;/strong&gt; to help &lt;code&gt;solve&lt;/code&gt;. For example, in the problem of retriving all keys at a certain depth definitely needs &lt;em&gt;current depth&lt;/em&gt; information.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/depth-1.jpg#small&quot; alt=&quot;depth&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Only with the help of &lt;code&gt;current_depth&lt;/code&gt;, the &lt;em&gt;Root&lt;/em&gt; can know whether it belongs to the final results. &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If &lt;code&gt;current_depth = target_depth&lt;/code&gt;, then &lt;em&gt;Root&lt;/em&gt; should be collected. Also we do not continue to solve &lt;em&gt;Left&lt;/em&gt; or &lt;em&gt;Right&lt;/em&gt; as we know their depths will never equal to &lt;em&gt;target_deapth&lt;/em&gt;.  &lt;/li&gt;
&lt;li&gt;Otherwise, we need to solve both &lt;em&gt;Left&lt;/em&gt; and &lt;em&gt;Right&lt;/em&gt; with argument of &lt;code&gt;1 + current_depth&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Assume our &lt;code&gt;solve&lt;/code&gt; is working. Then &lt;code&gt;solve left (1+current_depth)&lt;/code&gt; would return a list of target nodes and so does &lt;code&gt;solve right (1+current_depth)&lt;/code&gt;. We simply then concatenate two target lists.  &lt;/li&gt;
&lt;li&gt;STOP sign: &lt;em&gt;Leaf&lt;/em&gt; is not even a &lt;em&gt;Node&lt;/em&gt;, so the result will be empty list. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The code is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec from_depth d cur_d = function  
  | Leaf -&amp;gt; []
  | Node (left, k, right) -&amp;gt;
    if cur_d = d then [k]
    else from_depth d (cur_d + 1) left @ from_depth d (cur_d + 1) right

let all_keys_at depth bst = from_depth depth 0 bst  
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Genin&lt;/h1&gt;

&lt;p&gt;From &lt;a href=&quot;http://en.wikipedia.org/wiki/Ninja&quot;&gt;Ninja Wiki&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A system of rank existed. A j&amp;#333;nin (&amp;quot;upper man&amp;quot;) was the highest rank, representing the group and hiring out mercenaries. This is followed by the ch&amp;#363;nin (&amp;quot;middle man&amp;quot;), assistants to the j&amp;#333;nin. At the bottom was the genin (&amp;quot;lower man&amp;quot;), field agents drawn from the lower class and assigned to carry out actual missions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;Ps.&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;Some readers contacted me. They hope that maybe I can use more advanced knowledge or harder examples in my posts and the current ones might seem a little boring. I think I need to explain a bit here. &lt;/p&gt;

&lt;p&gt;The general idea behind &lt;em&gt;Many things about OCaml&lt;/em&gt; is not to write a cookbook for certain problems related to OCaml or be a place where quick solution is there and copy / paste sample code would do the trick. Instead, &lt;em&gt;Many things&lt;/em&gt; means some important aspects in OCaml that might be overlooked, or some particular problems that can show the greatness of OCaml, or the elegant OCaml solutions for some typical data structures and algorithms, etc. As long as something are valuable and that value shows only in OCaml or Functional Programming, I would like to add them all in here one by one. &lt;/p&gt;

&lt;p&gt;Fortunately or unfortunately, even though I have only limited experiences in OCaml, I found that the &lt;em&gt;many&lt;/em&gt; is actually quite big. And due to this &lt;em&gt;many&lt;/em&gt;, I had to make a plan to present them all in a progressive way. Topics can interleave with each other in terms of time order as we do not want to have the same food for a month. More importantly, however, all should go from simple / easy to advanced / hard. In order to present some advanced topic, we need to make sure we have a solid foundation. This is why, for example, I even produced a post for &lt;a href=&quot;http://typeocaml.com/2014/11/26/height-depth-and-level-of-a-tree/&quot;&gt;the properties of a tree&lt;/a&gt; although they are so basic. This is also why I &lt;a href=&quot;http://typeocaml.com/2014/12/04/recursion-reloaded/&quot;&gt;reloaded recursion&lt;/a&gt; since recursion is everywhere in OCaml. They are a kind of preparations. &lt;/p&gt;

&lt;p&gt;Moreover, I believe in fundamentals. Fundamentals are normally concise and contain the true essence. But sometimes they can be easily overlooked or ignored and we may need to experience a certain number of difficult problems afterwards, then start to look back and appreciate the fundamentals.&lt;/p&gt;

&lt;p&gt;The reason of using simple examples is that it makes my life easier for demonstrations. I love visualisations and one graph can be better than thousands of words. For complicated problems and solutions, it is a bit more difficult to draw a nice and clean diagram to show the true idea behind. I will try to do so later on, but even if I could achieve it in this early stage, some readers might easily get lost or confused because of the unavoidable complication of the graph. As a result, the point of grasping fundamentals might be missed. &lt;/p&gt;

&lt;p&gt;Anyway, please don't worry too much. Attractive problems in OCaml are always there. For example, in my plan, I will later start to present a number (maybe 15 ~ 17) of my beloved &lt;a href=&quot;http://www.cambridge.org/gb/academic/subjects/computer-science/programming-languages-and-applied-logic/pearls-functional-algorithm-design&quot;&gt;Functional Pearls&lt;/a&gt; in OCaml and if you are really chasing for some awesomeness, I hope they would satisfy you.&lt;/p&gt;</content><id>http://typeocaml.com/2014/12/19/how-to-become-a-bst-ninja-genin/</id><title type="text">Become a BST Ninja - Genin Level</title><updated>2014-12-19T12:28:00-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2014/12/04/recursion-reloaded/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/infinity-cubes-room.jpg#hero&quot; alt=&quot;recursion_reloaded&quot;/&gt;&lt;/p&gt;

&lt;p&gt;One essential of computer programming is &lt;em&gt;repeating some operations&lt;/em&gt;. This repetition has two forms: &lt;em&gt;for / while loop&lt;/em&gt; and &lt;em&gt;recursion&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loop&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We directly setup a boundary via &lt;em&gt;for&lt;/em&gt; or &lt;em&gt;while&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Certain conditions change inside the boundary.&lt;/li&gt;
&lt;li&gt;And operations are executed based on the changing conditions.&lt;/li&gt;
&lt;li&gt;It ends when hitting the boundary.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;if asked to write the &lt;code&gt;sum&lt;/code&gt; method in Java, it might be more intuitive to have this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/* Java */
public int sum(int[] a) {  
  int s = 0;
  for (int i = 1; i &amp;lt;= n; i++)
    s += a[i];
  return s
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Recursion&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We write a function for the operations that need to be repeated.&lt;/li&gt;
&lt;li&gt;The repetition is achieved by invoking the function inside itself. &lt;/li&gt;
&lt;li&gt;We may not specify an explicit boundary, yet we still need to set a STOP sign inside the function to tell it when to stop invoking itself.&lt;/li&gt;
&lt;li&gt;It ends when hitting the STOP sign.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The recursive &lt;code&gt;sum&lt;/code&gt; in OCaml can look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* OCaml *)
let sum = function  
  | [] -&amp;gt; 0 (*STOP sign*)
  | hd::tl -&amp;gt; hd + sum tl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;loop or recursion?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In imperative programming, developers may use &lt;em&gt;loop&lt;/em&gt; more often than recursion as it seems to be more straightforward. &lt;/p&gt;

&lt;p&gt;However, in functional programming, we almost (&lt;em&gt;[1]&lt;/em&gt;) cannot do &lt;em&gt;loop&lt;/em&gt;, and &lt;em&gt;recursion&lt;/em&gt; is our only option. The major reason is that &lt;em&gt;loop&lt;/em&gt; always needs to maintain mutable states inside the clause to change the conditions or pass intermediate results through iterations. Unfortunately, in functional programming, mutables are not allowed (&lt;em&gt;[2]&lt;/em&gt;) and also intermediates must be passed via function calls not state changing. &lt;/p&gt;

&lt;p&gt;So, if we really wish to get into the OCaml world, we have to get used to recursion. If you feel a bit hard, then this post is supposed to help you a little bit and show you the lovely side of recursion. &lt;/p&gt;

&lt;h1&gt;Do you dislike recursion?&lt;/h1&gt;

&lt;p&gt;Honestly, I hated recursion in the beginning. In order to &lt;strong&gt;write a recursive function&lt;/strong&gt; or &lt;strong&gt;validate one's correctness&lt;/strong&gt;, I thought I had to always somehow simulate the execution flow in my head and imagine divings into one level after another and every time when I did that, my brain felt a bit lost after some levels and sometimes I had to use pen &amp;amp; paper. &lt;/p&gt;

&lt;p&gt;This pain is natural. Human's brain feels much more comfortable on linear tasks than recursive ones. For example, if we are asked to finish the flow of first finish &lt;em&gt;task-1&lt;/em&gt; -&amp;gt; &lt;em&gt;task-2&lt;/em&gt; -&amp;gt; &lt;em&gt;task-3&lt;/em&gt; -&amp;gt; &lt;em&gt;task-4&lt;/em&gt; -&amp;gt; &lt;em&gt;done&lt;/em&gt;, it seems concise and easy. On the other hand, if we are asked to finish &lt;em&gt;task-1&lt;/em&gt;, inside which we need to finish &lt;em&gt;task-2&lt;/em&gt; and &lt;em&gt;task-3&lt;/em&gt;, and inside &lt;em&gt;task-2&lt;/em&gt; we need to finish &lt;em&gt;task-4&lt;/em&gt; and &lt;em&gt;task-5&lt;/em&gt;, and inside &lt;em&gt;task-3&lt;/em&gt; we need...(&lt;em&gt;[3]&lt;/em&gt;), our brain may not that happy, does it? &lt;/p&gt;

&lt;p&gt;What is the difference between these two cases? &lt;/p&gt;

&lt;p&gt;In the first case, when we do &lt;em&gt;task-1&lt;/em&gt;, we do not need to care about &lt;em&gt;task-2&lt;/em&gt;; and after we finish &lt;em&gt;task-1&lt;/em&gt;, we just move on and forget &lt;em&gt;task-2&lt;/em&gt;. Thus, we just focus and remember one thing at one time. &lt;/p&gt;

&lt;p&gt;In the second case, when do do &lt;em&gt;task-1&lt;/em&gt;, we not only need to foresee a bit on &lt;em&gt;task-2&lt;/em&gt; and &lt;em&gt;task-3&lt;/em&gt;, but also can't forget &lt;em&gt;task-1&lt;/em&gt;; and we need to still keep &lt;em&gt;task-2&lt;/em&gt; in mind after we begin &lt;em&gt;task-4&lt;/em&gt;...&lt;/p&gt;

&lt;p&gt;So the difference is very obvious: we remember / track more things in case 2 than in case 1. &lt;/p&gt;

&lt;p&gt;Let's investigate this difference further in the paradigm of the two different &lt;code&gt;sum&lt;/code&gt; functions written early.&lt;/p&gt;

&lt;h2&gt;Linear way&lt;/h2&gt;

&lt;p&gt;Summing [9;14;12;6;], what will we do? &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We will do &lt;code&gt;9 + 14&lt;/code&gt; first, we get &lt;code&gt;23&lt;/code&gt; and we put the &lt;code&gt;23&lt;/code&gt; somewhere, say, place &lt;code&gt;S&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Next number is &lt;code&gt;12&lt;/code&gt;, then we check &lt;code&gt;S&lt;/code&gt;, oh it is &lt;code&gt;23&lt;/code&gt;, so we do &lt;code&gt;23 + 12&lt;/code&gt; and get &lt;code&gt;35&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Now, we do not need the previous result &lt;code&gt;23&lt;/code&gt; any more and update &lt;code&gt;S&lt;/code&gt; with &lt;code&gt;35&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Next one is &lt;code&gt;6&lt;/code&gt;, ...&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/linear.jpg#small&quot; alt=&quot;linear&quot;/&gt;&lt;/p&gt;

&lt;p&gt;If we look closer into the diagram above, we will find out that at any single step, we need to care only &lt;code&gt;S&lt;/code&gt; and can forget anything happened before. For example, in step 1, we get 2 numbers from the list, calculate, store it to &lt;code&gt;S&lt;/code&gt; and forget the 2 numbers; then go to step 2, we need to retrieve from &lt;code&gt;S&lt;/code&gt;, get the 3rd number, then update &lt;code&gt;S&lt;/code&gt; with new result and forget anything else...&lt;/p&gt;

&lt;p&gt;Along the flow, we need to retrieve one number from the list at one time and forget it after done with it. We also need to remember / track &lt;code&gt;S&lt;/code&gt;, but it is just a single place; even if its value changes, we do not care about its old value. In total, we just have to bear &lt;strong&gt;2 things&lt;/strong&gt; in mind at all time, no matter the how big the list can be.&lt;/p&gt;

&lt;p&gt;For a contrast, let's take a look at the recursive way.&lt;/p&gt;

&lt;h2&gt;Recursive way&lt;/h2&gt;

&lt;p&gt;If we try to analyse the recursive &lt;code&gt;sum&lt;/code&gt;, we get&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/recursive.jpg#small&quot; alt=&quot;recursive&quot;/&gt;&lt;/p&gt;

&lt;p&gt;After we retrieve the first number, 9, from the list, we cannot do anything yet and have to continue to retrieve 14 without forgetting 9, and so on so forth. It is easy to see that we need to remember &lt;strong&gt;4 things&lt;/strong&gt; (marked as red square) if we use our brain to track the flow. It might be fine if there are only 4 numbers. Yet if the list has 100 random numbers, we need to remember &lt;strong&gt;100 things&lt;/strong&gt; and our brains would be fried.&lt;/p&gt;

&lt;p&gt;Basically, as long as we try to simulate the complete recursive / iteration flow, we cannot avoid remembering potentially big number of things. So what is the solution to escape this pain? The answer is simple: &lt;strong&gt;we do not simulate&lt;/strong&gt;. &lt;/p&gt;

&lt;p&gt;Actually, for many problems that need recursion, we do not need to look into the details of recursion and we do not need to iterate the function in our heads. &lt;strong&gt;The trick is the way of modeling the recursion&lt;/strong&gt;.&lt;/p&gt;

&lt;h1&gt;Recursion should be loved&lt;/h1&gt;

&lt;p&gt;Let's revise the recursive &lt;code&gt;sum&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let sum = function  
  | [] -&amp;gt; 0 (*STOP sign*)
  | hd::tl -&amp;gt; hd + sum tl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One &lt;strong&gt;bad way&lt;/strong&gt; to interpret its repeatition process is &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We get an element out  &lt;/li&gt;
&lt;li&gt;On the lefthand side of &lt;code&gt;+&lt;/code&gt;, we hold it  &lt;/li&gt;
&lt;li&gt;On the righthand side of &lt;code&gt;+&lt;/code&gt;, we do point 1 again.  &lt;/li&gt;
&lt;li&gt;After STOP, we do the plus on the previous numbers that were held, one by one&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This way is bad because it involves simulating the flow.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;good way&lt;/strong&gt; to interpret is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Someone tells me &lt;code&gt;sum&lt;/code&gt; can do the job of summing a list  &lt;/li&gt;
&lt;li&gt;We don't care what exactly &lt;code&gt;sum&lt;/code&gt; is doing  &lt;/li&gt;
&lt;li&gt;If you give me a list and ask me to sum, then I just get the head (&lt;code&gt;hd&lt;/code&gt;) out, and add it with &lt;code&gt;sum&lt;/code&gt; of the rest  &lt;/li&gt;
&lt;li&gt;Of course, what if the list is empty, then &lt;code&gt;sum&lt;/code&gt; should return 0&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Unlike the bad way, this modelling has actually removed the iteration part from recursion, and been purely based on logic level: &lt;strong&gt;sum of list = hd + sum of rest&lt;/strong&gt;. &lt;/p&gt;

&lt;p&gt;To summary this process of modelling:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I need to write a recursive function &lt;code&gt;f&lt;/code&gt; to solve a problem&lt;/li&gt;
&lt;li&gt;I won't think the exact steps or details inside &lt;code&gt;f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;I just assume &lt;code&gt;f&lt;/code&gt; is already there and correct&lt;/li&gt;
&lt;li&gt;If the problem size is &lt;em&gt;N&lt;/em&gt;, then I divide it into &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; where &lt;em&gt;X + Y = N&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;f&lt;/code&gt; is correct, then &lt;code&gt;f X&lt;/code&gt; and &lt;code&gt;f Y&lt;/code&gt; are both correct, right?&lt;/li&gt;
&lt;li&gt;So to solve &lt;code&gt;N&lt;/code&gt;, we just need to do &lt;code&gt;f X&lt;/code&gt; and &lt;code&gt;f Y&lt;/code&gt;, then think out &lt;strong&gt;some specific operations&lt;/strong&gt; to wire the results together.&lt;/li&gt;
&lt;li&gt;Of course, &lt;code&gt;f&lt;/code&gt; should recognise STOP signs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So what we really need to do for recursion are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Think how to divid &lt;code&gt;N&lt;/code&gt; to &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;Think how to deal with the results from &lt;code&gt;f X&lt;/code&gt; and &lt;code&gt;f Y&lt;/code&gt; in order to get result of &lt;code&gt;f N&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;Set the STOP sign(s)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let's rewrite &lt;code&gt;sum&lt;/code&gt; to fully demenstrate it&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We need to sum a list  &lt;/li&gt;
&lt;li&gt;I don't know how to write &lt;code&gt;sum&lt;/code&gt;, but I don't care and just assume &lt;code&gt;sum&lt;/code&gt; is there  &lt;/li&gt;
&lt;li&gt;a list &lt;code&gt;l&lt;/code&gt; can be divid to &lt;code&gt;[hd]&lt;/code&gt; + &lt;code&gt;tl&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;So &lt;code&gt;sum l = sum [hd] + sum tl&lt;/code&gt; should make sense.  &lt;/li&gt;
&lt;li&gt;Of course, STOP signs here can be two: &lt;code&gt;sum [] = 0&lt;/code&gt; and &lt;code&gt;sum [x] = x&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let sum = function  
  | [] -&amp;gt; 0 (*STOP sign*) 
  | [x] -&amp;gt; x (*STOP sign*)
  | hd::tl -&amp;gt; sum [hd] + sum tl (* Logic *)
(* note sum [hd] can directly be hd, I rewrote in this way to be consistent to the modelling *)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am not sure I express this high level logic based modelling clearly or not, but anyway we need more practices.&lt;/p&gt;

&lt;h2&gt;Merge two sorted lists&lt;/h2&gt;

&lt;p&gt;We need a &lt;code&gt;merge&lt;/code&gt; function to merge two sorted lists so the output list is a combined sorted list.&lt;/p&gt;

&lt;h3&gt;N = X + Y&lt;/h3&gt;

&lt;p&gt;Because the head of the final combined list should be always min, so we care about the first elements from two lists as each is already the min inside its owner. &lt;code&gt;l1 = hd1 + tl1&lt;/code&gt; and &lt;code&gt;l2 = hd2 + tl2&lt;/code&gt;. &lt;/p&gt;

&lt;h3&gt;f N = wire (f X)  (f Y)&lt;/h3&gt;

&lt;p&gt;We will have two cases here.&lt;/p&gt;

&lt;p&gt;If hd1 &amp;lt; hd2, then X = tl1 and Y = l2, then the wiring operation is just to add hd1 as the head of &lt;code&gt;merge X Y&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If hd1 &amp;gt;= hd2, then X = l1 and Y = tl2, then the wiring operation is just to add hd2 as the head of &lt;code&gt;merge X Y&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;STOP sign&lt;/h3&gt;

&lt;p&gt;If one of the lists is empty, then just return the other (no matter it is empty or not).&lt;/p&gt;

&lt;h3&gt;Code&lt;/h3&gt;

&lt;p&gt;Then it should be easy to write the code from the above modelling.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let merge = function  
  | [], l | l, [] -&amp;gt; l (*STOP sign, always written as first*) 
  | hd1::tl1 as l1, hd2::tl2 as l2 -&amp;gt; 
    if hd1 &amp;lt; hd2 then hd1::merge (tl1, l2)
    else hd2::merge (l1, tl2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The idea can be demonstrated by the diagram below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/12/merge.jpg&quot; alt=&quot;merge&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Mergesort&lt;/h2&gt;

&lt;p&gt;Mergesort is a way to sort a list.&lt;/p&gt;

&lt;h3&gt;N = X + Y&lt;/h3&gt;

&lt;p&gt;We can split N evenly so X = N / 2 and Y = N - N / 2.&lt;/p&gt;

&lt;h3&gt;f N = wire (f X)  (f Y)&lt;/h3&gt;

&lt;p&gt;What if we already mergesorted X and mergesorted Y? We simply &lt;code&gt;merge&lt;/code&gt; the two results, right? &lt;/p&gt;

&lt;h3&gt;STOP sign&lt;/h3&gt;

&lt;p&gt;If the list has just 0 or 1 element, we simply don't do anything but return.&lt;/p&gt;

&lt;h3&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* split_evenly is actually recursive too
   We here just ignore the details and use List.fold_left *)
let split_evenly l = List.fold_left ~f:(fun (l1, l2) x -&amp;gt; (l2, x::l1)) ~init:([], []) l

let rec mergesort l =  
  match l with
    | [] | hd::[] as l -&amp;gt; l
    | _ -&amp;gt; 
      let l1, l2 = split_evenly l in
      merge (mergesort l1) (mergesort l2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;More recursions will follow&lt;/h1&gt;

&lt;p&gt;So far, all examples used in this post are quite trivial and easy. I chose these easy ones because I wish to present the idea in the simplest way. Many other recursion problems are more complicated, such as permutations, combinations, etc. I will write more posts for those.&lt;/p&gt;

&lt;p&gt;One of the execellent use case of recursion is Binary Search Tree. In BST, we will see that the size of a problems is naturally split into 3. Depending on the goal, we deal with &lt;strong&gt;all or partial&lt;/strong&gt; of the 3 sub-problems. I will demonstrate all these in the next post.&lt;/p&gt;

&lt;p&gt;Again, remember, when dealing with recursion, don't try to follow the execution flow. Instead, focus on splitting the problem into smaller ones and try to combine the results. This is also called &lt;em&gt;divide and conquer&lt;/em&gt; and actually it is the true nature of recursion. After all, no matter the size of the problem can be, it is anyway the same function that solve the cases of &lt;code&gt;size = 0&lt;/code&gt;, &lt;code&gt;size = 1&lt;/code&gt;, and &lt;code&gt;size = n &amp;gt; 2&lt;/code&gt;, right?&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;[1]&lt;/strong&gt; OCaml allows imperative style, but it is not encouraged. We should use imperative programming in OCaml only if we have to.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[2]&lt;/strong&gt; OCaml allows mutables and sometimes they are useful in some cases like in &lt;a href=&quot;http://typeocaml.com/2014/11/13/magic-of-thunk-lazy/&quot;&gt;lazy&lt;/a&gt; or &lt;em&gt;memorise&lt;/em&gt;. However, in most cases, we are not encouraged to use mutables.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[3]&lt;/strong&gt; I already got lost even when I am trying to design this case&lt;/p&gt;</content><id>http://typeocaml.com/2014/12/04/recursion-reloaded/</id><title type="text">Recursion Reloaded</title><updated>2014-12-04T15:44:18-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2014/11/26/height-depth-and-level-of-a-tree/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/11/groot_tree2.jpg#hero&quot; alt=&quot;tree&quot;/&gt;&lt;/p&gt;

&lt;p&gt;This is a post on the three important properties of trees: &lt;em&gt;height&lt;/em&gt;, &lt;em&gt;depth&lt;/em&gt; and &lt;em&gt;level&lt;/em&gt;, together with &lt;em&gt;edge&lt;/em&gt; and &lt;em&gt;path&lt;/em&gt;. I bet that most people already know what they are and &lt;a href=&quot;http://en.wikipedia.org/wiki/Tree_(data_structure)&quot;&gt;tree (data structure) on wiki&lt;/a&gt; also explains them briefly. &lt;/p&gt;

&lt;p&gt;The reason why I still decided to produce such a trivial page is that I will later on write a series of articles focusing on &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;binary search tree&lt;/a&gt; in OCaml. The starters among them will be quite basic and related to these three properties. &lt;/p&gt;

&lt;p&gt;In order to be less boring, the properties are presented in a visual way and I try to fulfill details (some might be easily overlooked) as much as possible.&lt;/p&gt;

&lt;h1&gt;Edge&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Edge &amp;ndash; connection between one node to another. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/11/edge-1.jpg#small&quot; alt=&quot;edge&quot;/&gt;&lt;/p&gt;

&lt;p&gt;An example of edge is shown above between &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt;. Basically, an edge is a line between two nodes, &lt;strong&gt;or a node and a leaf&lt;/strong&gt;. &lt;/p&gt;

&lt;h1&gt;Path&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Path &amp;ndash; a sequence of nodes and edges connecting a node with a descendant.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/11/path-1.jpg#small&quot; alt=&quot;path&quot;/&gt;&lt;/p&gt;

&lt;p&gt;A path starts from a node and ends at another node or a leaf. Please don't look over the following points:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;When we talk about a path, it includes all nodes and all edges along the path, &lt;em&gt;not just edges&lt;/em&gt;.  &lt;/li&gt;
&lt;li&gt;The direction of a path is strictly from top to bottom and cannot be changed in middle. In the diagram, we can't really talk about a path from &lt;em&gt;B&lt;/em&gt; to &lt;em&gt;F&lt;/em&gt; although &lt;em&gt;B&lt;/em&gt; is above &lt;em&gt;F&lt;/em&gt;. Also there will be no path starting from a leaf or from a child node to a parent node. (&lt;em&gt;[1]&lt;/em&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;Height&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Height of node &amp;ndash; The height of a node is the number of edges on the longest downward path between that node and a leaf.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At first, we can see the above wiki definition has a redundant term - &lt;em&gt;downward&lt;/em&gt; - inside. As we already know from previous section, path can only be downward. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/11/height-3.jpg#small&quot; alt=&quot;height&quot;/&gt;&lt;/p&gt;

&lt;p&gt;When looking at height:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Every node has height. So &lt;em&gt;B&lt;/em&gt; can have height, so does &lt;em&gt;A&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;D&lt;/em&gt;.  &lt;/li&gt;
&lt;li&gt;Leaf cannot have height as there will be no path starting from a leaf.  &lt;/li&gt;
&lt;li&gt;It is the longest path from the node &lt;strong&gt;to a leaf&lt;/strong&gt;. So &lt;em&gt;A&lt;/em&gt;'s height is the number of edges of the path to &lt;em&gt;E&lt;/em&gt;, NOT to &lt;em&gt;G&lt;/em&gt;. And its height is 3.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;The height of the root is 1.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Height of tree &amp;ndash;The height of a tree is the number of edges on the longest downward path between the root and a leaf.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So &lt;strong&gt;the height of a tree is the height of its root&lt;/strong&gt;. &lt;/p&gt;

&lt;p&gt;Frequently, we may be asked the question: &lt;em&gt;what is the max number of nodes a tree can have if the height of the tree is h?&lt;/em&gt;. Of course the answer is $ 2^h-1 $ . When $ h = 1 $ , the number of node inside is 1, which is just the root; also when a tree has just root, the height of the root is 1. Hence, the two inductions match.&lt;/p&gt;

&lt;p&gt;How about giving a height of 0? Then it means we don't have any &lt;em&gt;node&lt;/em&gt; in the tree; but still we may have &lt;em&gt;leaf&lt;/em&gt; inside (note that in this case we may not call it &lt;em&gt;root&lt;/em&gt; of the tree as it makes not much sense). This is why in most languages, the type of a tree can be a leaf alone. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;OCaml&quot;&gt;type 'a bst =  
  | Leaf 
  | Node of 'a bst * 'a * 'a bst
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moreover, when we use $2^h-1$ to calculate the max number of nodes, leaves are not taken into account. &lt;em&gt;Leaf&lt;/em&gt; is not &lt;em&gt;Node&lt;/em&gt;. It carries no key or data,  and acts only like a STOP sign. We need to remember this when we deal with properties of trees.&lt;/p&gt;

&lt;h1&gt;Depth&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Depth &amp;ndash;The depth of a node is the number of edges from the node to the tree's root node.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/11/depth-1.jpg#small&quot; alt=&quot;depth&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We don't care about path any more when depth pops in. We just count how many edges between the targeting node and the root, ignoring directions. For example, &lt;em&gt;D&lt;/em&gt;'s depth is 2.&lt;/p&gt;

&lt;p&gt;Recall that when talking about height, we actually imply a baseline located at bottom. For depath, the baseline is at top which is root level. That's why we call it depth. &lt;/p&gt;

&lt;p&gt;Note that &lt;strong&gt;the depth of the root is 0&lt;/strong&gt;.&lt;/p&gt;

&lt;h1&gt;Level&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Level &amp;ndash; The level of a node is defined by 1 + the number of connections between the node and the root.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/11/level.jpg#small&quot; alt=&quot;level&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Simply, &lt;strong&gt;level is depth plus 1.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The important thing to remember is when talking about level, it &lt;strong&gt;starts from 1&lt;/strong&gt; and &lt;strong&gt;the level of the root is 1&lt;/strong&gt;. We need to be careful about this when solving problems related to level. &lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;[1]&lt;/strong&gt; Although point 2 stands, sometimes some problems may talk about paths in an arbitrary way, like &lt;em&gt;the path between B and F&lt;/em&gt;. We have to live with that while deep in our hearts remembering the precise definition.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ps.&lt;/strong&gt; &lt;a href=&quot;http://www.yworks.com/en/products/yfiles/yed/&quot;&gt;yEd - Graph Editor&lt;/a&gt; has been used to create all diagrams here.&lt;/p&gt;</content><id>http://typeocaml.com/2014/11/26/height-depth-and-level-of-a-tree/</id><title type="text">Height, Depth and Level of a Tree</title><updated>2014-11-26T22:43:46-00:00</updated><author><name>typeocaml</name></author></entry><entry><link href="http://typeocaml.com/2014/11/13/magic-of-thunk-async/" rel="alternate"/><contributor><uri>http://typeocaml.com/rss/</uri><name>typeocaml</name></contributor><content type="html">&lt;p&gt;&lt;img src=&quot;http://typeocaml.com/content/images/2014/11/async2.jpg#hero&quot; alt=&quot;async&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Currently in post-production.&lt;/p&gt;

&lt;p&gt;Sorry, I still haven't finished this post. &lt;/p&gt;

&lt;p&gt;As this will be the last post in the &lt;em&gt;magic of thunk&lt;/em&gt; series, I really don't want to just introduce the &lt;em&gt;Async&lt;/em&gt; library and its API, as &lt;a href=&quot;https://github.com/janestreet?query=async&quot;&gt;janestreet@github&lt;/a&gt; and &lt;a href=&quot;https://realworldocaml.org/v1/en/html/concurrent-programming-with-async.html&quot;&gt;realworldocaml&lt;/a&gt; have already done a pretty good job. &lt;/p&gt;

&lt;p&gt;What I am looking for is the design of &lt;em&gt;Async&lt;/em&gt; and the magic of &lt;em&gt;thunk&lt;/em&gt; that hides inside its implementations. Since &lt;em&gt;Async&lt;/em&gt; is sophisticated, it is a non-trivial task for me. I have to read the &lt;a href=&quot;https://github.com/janestreet/async_kernel/tree/master/lib&quot;&gt;source code&lt;/a&gt; and it will take a while. &lt;/p&gt;</content><id>http://typeocaml.com/2014/11/13/magic-of-thunk-async/</id><title type="text">The Magic of Thunk - Async</title><updated>2014-11-13T23:04:59-00:00</updated><author><name>typeocaml</name></author></entry></feed>