---
title: Data Types in OCaml
description: Learn OCaml's diverse data types in functional programming, their features,
  and efficient usage in code.
url: https://debajyatidey.hashnode.dev/data-types-in-ocaml
date: 2024-02-27T17:35:36-00:00
preview_image: https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1709055320479%2Fbc3047da-295e-47db-9005-56a2071159c6.gif%3Fw%3D1200%26auto%3Dformat%2Ccompress%26gif-q%3D60%26format%3Dwebm%26fm%3Dpng
authors:
- Debajyati's OCaml Blog
source:
---

Introduction<p>In the previous article we discussed about how OCaml is different than other languages, its expression oriented nature, its static type system &amp; some other aspects.</p><p>In this article we will mainly discuss about the data-types in this language.</p><p>But before we directly head on to the main topic, let me share some insights about the tools we will be using.</p><h3>Running &amp; Compiling</h3><div data-node-type="callout"><div data-node-type="callout-emoji">💡</div><div data-node-type="callout-text">We won't be using any IDE(There's no Integrated Development Environment(just like Intellij IDEa for java) available for OCaml. The closest thing we can get similar to an IDE is VScode with the <strong><mark>OCaml Platform</mark></strong> extension enabled or Neovim with the <strong><mark>merlin</mark></strong> plugin) or text editor for now and some of the upcoming articles. We'll be entering our codes in an enhanced Read-Eval-Print-Loop(REPL) for OCaml which is called <strong><em><mark>utop</mark></em></strong>.</div></div><p>Utop(Universal Top-Level for OCaml) is similar to IPython3 for python with some different features.</p><p>Although you can manually install utop with the default package manager apt(assuming you are using ubuntu,. If you have windows computer, use WSL2 instead). I recommend you to follow each and every step described in the webpage(link below) to install opam, OCaml, and setup an opam switch (similar to virtual environments of python3).</p><p><a href="https://cs3110.github.io/textbook/chapters/preface/install.html#install-opam" target="_blank">Click here</a> to see the steps. It may seem time consuming, but trust me it's worth it.</p><p>now once you have installed &amp; set up ocaml, opam and utop, you must know how to run an existing ocaml file.</p><p><strong>Run without compiling:</strong></p><p>If you're not using any other library rather than the standard library, you can then only run without compiling the code. To do that -</p><pre><code class="lang-bash">ocaml filename.ml <span class="hljs-comment">#place the appropriate path to the ocaml file in place of `filename.ml`</span></code></pre><p><strong>Compiling and running:</strong></p><p>The compiler we use to compile and run ocaml programs is <code>ocamlc</code>. The compiler first compiles the source file into byte code then we manually run the binary byte file.</p><pre><code class="lang-bash">ocamlc -o filename.byte filename.ml./filename.byte</code></pre><p>If you observe enough you'll see, two more files are also generated, filename.cmo and filename.cmi. These are not used in running code. These are for different purposes. We don't need them now. So clean them using -</p><pre><code class="lang-bash">rm filename.cmi filename.cmo</code></pre><h1>Heading Over to the Main Topic</h1><p><img src="https://media.tenor.com/ARGSE3uN7AwAAAAj/pikachu-oh-yeah.gif" alt="Oh Yeah GIFs | Tenor" class="image--center mx-auto"></p><blockquote><p>NOTE: We can write multiline comments in OCaml inside <code>(* *)</code> - this syntax.</p><p>e.g. - <code>(* This is a comment *)</code></p></blockquote><p>Enter utop in the terminal and get ready to write code.</p><p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1708955693935/0d19bb5e-637a-4826-a403-a9fff8573834.png" alt="" class="image--center mx-auto"></p><p>You should see a similar looking interface after running utop(img above).</p><div data-node-type="callout"><div data-node-type="callout-emoji">💡</div><div data-node-type="callout-text"><strong><mark>Remember</mark></strong><mark> :</mark> In utop, expressions end with a <code>;;</code> (double semicolon). Whenever you'll evaluate an expression in utop, it will show the resulting value and type in the next one or few lines.</div></div><h2>Primitive Expression Types</h2><p>The primitive types are unit, int, char, float, bool, and string.</p><h3>Unit: Singleton Type</h3><p>The unit type is the simplest type in OCaml. It contains one element: <code>( )</code>. Seems stupid, right? Actually not!</p><p>In an expression oriented language, every expression must return a value. Then what about those expressions which perform side effects?</p><p>( ) is used as the value of a procedure that makes any side-effect. It is similar to the void data type in C.</p><pre><code class="lang-ocaml">print_endline <span class="hljs-string">"Let's Learn OCaml"</span>;;<span class="hljs-comment">(*  This expression prints the specified string to the screen.    Printing something to screen is seen as a side-effect.    So, this expression will return a unit. *)</span></code></pre><h3>Int: Integers</h3><p>This is the type of signed Integers. All positive integers(1,2,3,4, ...), all negative integers(... ,-4,-3,-2,-1) and 0 are recognised as integers.</p><p>OCaml integers range from -</p><p>$$-2^{62}\ \ to\ \ 2^{62} - 1$$</p><p>on modern computer systems.</p><pre><code class="lang-ocaml"><span class="hljs-keyword">let</span> num = <span class="hljs-number">5</span>;; <span class="hljs-comment">(* integer expression *)</span><span class="hljs-keyword">val</span> num : <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span> <span class="hljs-comment">(* utop output *)</span></code></pre><div data-node-type="callout"><div data-node-type="callout-emoji">💡</div><div data-node-type="callout-text">Apart from decimals, the OCaml compiler can also recognise int literals specified in octal, binary or hexadecimal form.</div></div><ul><li><p>int described in binary - starts with 0b</p></li><li><p>int described in octal - starts with 0o</p></li><li><p>int described in hexadecimal - starts with 0x</p></li></ul><h3>Float: Floating-Point Numbers</h3><p>The syntax of a floating point requires a decimal point, an exponent (base 10) denoted by an E or e. A digit is required before the decimal point, but not after. Let's look at some examples -</p><pre><code class="lang-ocaml"><span class="hljs-number">31.415926E-1</span>;; <span class="hljs-comment">(* float value *)</span>- : <span class="hljs-built_in">float</span> = <span class="hljs-number">3.1415926</span> <span class="hljs-comment">(* utop output *)</span><span class="hljs-keyword">let</span> number = <span class="hljs-number">2e7</span>;; <span class="hljs-comment">(* float expression *)</span><span class="hljs-keyword">val</span> number : <span class="hljs-built_in">float</span> = <span class="hljs-number">20000000.</span> <span class="hljs-comment">(* utop output *)</span><span class="hljs-comment">(* float expression with unnecessary type annotation*)</span><span class="hljs-keyword">let</span> floating:<span class="hljs-built_in">float</span> = <span class="hljs-number">0.01</span>;;<span class="hljs-keyword">val</span> floating : <span class="hljs-built_in">float</span> = <span class="hljs-number">0.01</span> <span class="hljs-comment">(* utop output *)</span></code></pre><h3>Char: Characters</h3><p>The expression type <code>char</code> belongs to the ASCII character set. The syntax for a character constant uses the single quote symbol. e.g. - <code>'a'</code>, <code>'x'</code>, <code>'F'</code>, <code>' '</code> etc.</p><p>But there's more to know! Escape Sequences though commonly associated with strings, they're also expressed as <code>char</code>.</p><p><strong>Must Know Escape Sequences:</strong></p><div class="hn-table"><table><thead><tr><td>Sequences</td><td>Definition</td></tr></thead><tbody><tr><td><code>'\\'</code></td><td>The backslash character</td></tr><tr><td><code>'\''</code></td><td>The single-quote character</td></tr><tr><td><code>'\t'</code></td><td>The tab character</td></tr><tr><td><code>'\r'</code></td><td>The carriage-return character</td></tr><tr><td><code>'\n'</code></td><td>The newline character</td></tr><tr><td><code>'\ddd'</code></td><td>The decimal escape sequence</td></tr></tbody></table></div><p>A decimal escape sequence must have exactly three decimal characters. It specifies the ASCII character with the given decimal code.</p><p>Let's see some examples -</p><pre><code class="lang-ocaml"><span class="hljs-keyword">let</span> ch = <span class="hljs-string">'x'</span>;; <span class="hljs-comment">(* char expression *)</span><span class="hljs-keyword">val</span> ch : <span class="hljs-built_in">char</span> = <span class="hljs-string">'x'</span> <span class="hljs-comment">(* utop output *)</span><span class="hljs-string">'\123'</span>;; <span class="hljs-comment">(* decimal escape sequence value *)</span>- : <span class="hljs-built_in">char</span> = <span class="hljs-string">'{'</span> <span class="hljs-comment">(* utop output *)</span><span class="hljs-string">'\121'</span>;; <span class="hljs-comment">(* decimal escape sequence value *)</span>- : <span class="hljs-built_in">char</span> = <span class="hljs-string">'y'</span> <span class="hljs-comment">(* utop output *)</span></code></pre><h3>String: Character Strings</h3><p>In OCaml, strings are a primitive type represented by character sequences delimited by double quotes. Unlike C, OCaml strings are not arrays of characters and do not employ the null-character <code>'\000'</code> for termination. Strings in OCaml support escape sequences for specifying special characters, akin to those used for individual characters.</p><pre><code class="lang-ocaml"><span class="hljs-keyword">let</span> str = <span class="hljs-string">"Hello\n World!"</span>;; <span class="hljs-comment">(* string expression *)</span><span class="hljs-keyword">val</span> str : <span class="hljs-built_in">string</span> = <span class="hljs-string">"Hello\n World!"</span> <span class="hljs-comment">(* utop output *)</span><span class="hljs-comment">(* The Absolute Nightmare way to write an helloworld program *)</span><span class="hljs-keyword">let</span> greet = <span class="hljs-string">"\072\101\108\108\111\044 \087\111\114\108\100\033"</span>;;<span class="hljs-keyword">val</span> greet : <span class="hljs-built_in">string</span> = <span class="hljs-string">"Hello, World!"</span></code></pre><h3>Bool: Boolean Values</h3><p>The <code>bool</code> type includes <code>true</code> and <code>false</code>, and logical negation is done via the <code>not</code> function. Comparison operations (<code>=</code>, <code>==</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>) return <code>true</code> if the relation holds; <code>==</code> is used for checking physical equality, while <code>=</code> implies structural equality.</p><div class="hn-table"><table><thead><tr><td>Boolean Expression</td><td>What does it signify</td></tr></thead><tbody><tr><td>x = y</td><td>x is equal to y</td></tr><tr><td>x &lt;&gt; y</td><td>x is not equal to y</td></tr><tr><td>x == y</td><td>x is "identical" to y</td></tr><tr><td>x != y</td><td>x is not "identical" to y</td></tr><tr><td>x &gt; y</td><td>x is strictly greater than y</td></tr><tr><td>x &gt;= y</td><td>x is greater than or equal to y</td></tr><tr><td>x &lt; y</td><td>x is strictly less than y</td></tr><tr><td>x &lt;= y</td><td>x is less than or equal to y</td></tr></tbody></table></div><p>If you're someone experienced in python, java or C++, you have to practice using <code>=</code> in conditions, instead of <code>==</code>.</p><pre><code class="lang-ocaml"><span class="hljs-number">5.1</span> = <span class="hljs-number">5.1</span>;; <span class="hljs-comment">(* boolean expression checking structural equality *)</span>- : <span class="hljs-built_in">bool</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">(* utop output *)</span><span class="hljs-number">5.1</span> != <span class="hljs-number">5.1</span>;; <span class="hljs-comment">(* boolean expression checking physical inequality *)</span>- : <span class="hljs-built_in">bool</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">(* utop output *)</span></code></pre><h2>Type Conversion</h2><p>OCaml provides some functions to convert some primitive types to another.</p><h3>From _ to int :</h3><p> use - int_of_string</p><pre><code class="lang-ocaml">int_of_string <span class="hljs-string">"145"</span>;;- : <span class="hljs-built_in">int</span> = <span class="hljs-number">145</span></code></pre><p> use - int_of_char</p><pre><code class="lang-ocaml">int_of_char <span class="hljs-string">'o'</span>;;- : <span class="hljs-built_in">int</span> = <span class="hljs-number">111</span></code></pre><p> use - int_of_float</p><pre><code class="lang-ocaml">int_of_float <span class="hljs-number">1.9999999</span>;; <span class="hljs-comment">(* returns the floor value of the float *)</span>- : <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span></code></pre><p> use - Char.code</p><pre><code class="lang-ocaml"><span class="hljs-type">Char</span>.code <span class="hljs-string">'d'</span>;; <span class="hljs-comment">(* Char is a module which has a function named                   `code` to do this *)</span>- : <span class="hljs-built_in">int</span> = <span class="hljs-number">100</span></code></pre><h3>From _ to float :</h3><p> use - float_of_int</p><pre><code class="lang-ocaml">float_of_int <span class="hljs-number">52</span>;;- : <span class="hljs-built_in">float</span> = <span class="hljs-number">52.0</span></code></pre><p> use - float_of_string</p><pre><code class="lang-ocaml">float_of_string <span class="hljs-string">"5"</span>;;- : <span class="hljs-built_in">float</span> = <span class="hljs-number">5.</span>float_of_string <span class="hljs-string">"0.5"</span>;;- : <span class="hljs-built_in">float</span> = <span class="hljs-number">0.5</span></code></pre><h3>From _ to char:</h3><p> use - char_of_int</p><pre><code class="lang-ocaml">char_of_int <span class="hljs-number">55</span>;;- : <span class="hljs-built_in">char</span> = <span class="hljs-string">'7'</span>char_of_int <span class="hljs-number">97</span>;;- : <span class="hljs-built_in">char</span> = <span class="hljs-string">'a'</span>char_of_int <span class="hljs-number">67</span>;;- : <span class="hljs-built_in">char</span> = <span class="hljs-string">'C'</span></code></pre><p> use - Char.chr</p><pre><code class="lang-ocaml"><span class="hljs-type">Char</span>.chr <span class="hljs-number">45</span>;;- : <span class="hljs-built_in">char</span> = <span class="hljs-string">'-'</span><span class="hljs-type">Char</span>.chr <span class="hljs-number">105</span>;;- : <span class="hljs-built_in">char</span> = <span class="hljs-string">'i'</span></code></pre><h3>From _ to string:</h3><p> use - string_of_int</p><pre><code class="lang-ocaml">string_of_int <span class="hljs-number">746</span>;;- : <span class="hljs-built_in">string</span> = <span class="hljs-string">"746"</span></code></pre><p> use - string_of_bool</p><pre><code class="lang-ocaml">string_of_bool <span class="hljs-literal">true</span>;;- : <span class="hljs-built_in">string</span> = <span class="hljs-string">"true"</span></code></pre><p> use - string_of_float</p><pre><code class="lang-ocaml">string_of_float <span class="hljs-number">45.0</span>;;- : <span class="hljs-built_in">string</span> = <span class="hljs-string">"45."</span></code></pre><h3>From _ to bool:</h3><p> use - bool_of_string</p><pre><code class="lang-ocaml"><span class="hljs-keyword">let</span> wrong = bool_of_string <span class="hljs-string">"false"</span>;;<span class="hljs-keyword">val</span> wrong : <span class="hljs-built_in">bool</span> = <span class="hljs-literal">false</span><span class="hljs-comment">(* `bool_of_string` only works if the provided string is "false" or "true" *)</span>bool_of_string <span class="hljs-string">""</span>;;<span class="hljs-type">Exception</span>: <span class="hljs-type">Invalid_argument</span> <span class="hljs-string">"bool_of_string"</span>. <span class="hljs-comment">(* throwing an exception/error *)</span></code></pre><h2>Custom Types</h2><p>We can define custom data types using a type definition with the <code>type</code> keyword. These are also called variants.</p><p>Example -</p><pre><code class="lang-ocaml"><span class="hljs-comment">(* Defining a type representing different days of the week *)</span><span class="hljs-keyword">type</span> day =  | <span class="hljs-type">Monday</span>  | <span class="hljs-type">Tuesday</span>  | <span class="hljs-type">Wednesday</span>  | <span class="hljs-type">Thursday</span>  | <span class="hljs-type">Friday</span>  | <span class="hljs-type">Saturday</span>  | <span class="hljs-type">Sunday</span>;;<span class="hljs-comment">(* `|` is a symbol in OCaml that seperates different patterns or cases.   It is mainly used in type definitions and pattern matching code.*)</span><span class="hljs-comment">(* utop output *)</span><span class="hljs-keyword">type</span> day = <span class="hljs-type">Monday</span> | <span class="hljs-type">Tuesday</span> | <span class="hljs-type">Wednesday</span> | <span class="hljs-type">Thursday</span> | <span class="hljs-type">Friday</span> | <span class="hljs-type">Saturday</span> | <span class="hljs-type">Sunday</span></code></pre><h2>Composite Data Types</h2><h3>Lists</h3><p>Lists are homogeneous collections represented by square brackets. They are immutable and support powerful pattern matching operations, making them essential in functional programming.</p><pre><code class="lang-ocaml"><span class="hljs-comment">(* Defining a list of integers *)</span><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>; <span class="hljs-number">4</span>; <span class="hljs-number">5</span>];; <span class="hljs-keyword">val</span> numbers : <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>; <span class="hljs-number">4</span>; <span class="hljs-number">5</span>]</code></pre><h3>Arrays</h3><p>Arrays in OCaml, denoted by the <code>array</code> keyword, are fixed-size collections of elements of the same data type. They are zero-indexed and can be accessed using square brackets.</p><pre><code class="lang-ocaml"><span class="hljs-keyword">let</span> numbers = [|<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>|];; <span class="hljs-comment">(* defining an array of integers *)</span><span class="hljs-keyword">val</span> numbers : <span class="hljs-built_in">int</span> <span class="hljs-built_in">array</span> = [|<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>|] <span class="hljs-comment">(* utop output *)</span></code></pre><h3>Tuples</h3><p>Tuples are ordered collections of elements of different types. They offer a convenient way to group heterogeneous data. A parenthetical space () separates the tuple's components from one another.</p><pre><code class="lang-ocaml"><span class="hljs-comment">(* Defining a tuple *)</span><span class="hljs-keyword">let</span> credentials = (<span class="hljs-string">"Debajyati"</span>, <span class="hljs-number">6</span>);;<span class="hljs-keyword">val</span> credentials : <span class="hljs-built_in">string</span> * <span class="hljs-built_in">int</span> = (<span class="hljs-string">"Debajyati"</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">(* utop output *)</span><span class="hljs-comment">(* matching the pattern to access individual elements *)</span><span class="hljs-keyword">let</span> (name, roll) = credentials;;<span class="hljs-keyword">val</span> name : <span class="hljs-built_in">string</span> = <span class="hljs-string">"Debajyati"</span> <span class="hljs-comment">(* utop output *)</span><span class="hljs-keyword">val</span> roll : <span class="hljs-built_in">int</span> = <span class="hljs-number">6</span><span class="hljs-comment">(* printing a string with those values *)</span><span class="hljs-type">Printf</span>.printf <span class="hljs-string">"Roll no. of %s is %d\n"</span> name roll;;<span class="hljs-type">Roll</span> no. <span class="hljs-keyword">of</span> <span class="hljs-type">Debajyati</span> is <span class="hljs-number">6</span>  <span class="hljs-comment">(* utop output *)</span>- : <span class="hljs-built_in">unit</span> = <span class="hljs-literal">()</span></code></pre><h3>Records</h3><p>Records are labeled collections of fields, akin to structs in other languages. They allow for structured data representation and manipulation.</p><pre><code class="lang-ocaml"><span class="hljs-comment">(* Defining a record representing a person *)</span><span class="hljs-keyword">type</span> person = {  name : <span class="hljs-built_in">string</span>;  age : <span class="hljs-built_in">int</span>;};;<span class="hljs-keyword">type</span> person = { name : <span class="hljs-built_in">string</span>; age : <span class="hljs-built_in">int</span>; } <span class="hljs-comment">(* utop output *)</span><span class="hljs-comment">(* Creating a person record *)</span><span class="hljs-keyword">let</span> john = { name = <span class="hljs-string">"John"</span>; age = <span class="hljs-number">30</span> };;<span class="hljs-keyword">val</span> john : person = {name = <span class="hljs-string">"John"</span>; age = <span class="hljs-number">30</span>} <span class="hljs-comment">(* utop output *)</span><span class="hljs-comment">(* Accessing fields of the record *)</span><span class="hljs-keyword">let</span> <span class="hljs-literal">()</span> = <span class="hljs-type">Printf</span>.printf <span class="hljs-string">"%s is %d years old\n"</span> john.name john.age;;<span class="hljs-type">John</span> is <span class="hljs-number">30</span> years old  <span class="hljs-comment">(* utop output *)</span></code></pre><h2><strong>Algebraic Data Types (ADTs)</strong></h2><p>Algebraic data types in OCaml are a way of defining composite types by combining simpler types using constructors, through variant types and recursive types, respectively.</p><h3>Variant Types</h3><p>Variant types enable the creation of sum types, where a value can be one of several possibilities. They are particularly useful for modeling complex data structures and handling multiple cases in pattern matching. We already saw an example of Variant Types in OCaml in the Custom types section of this blog. Let's see another example -</p><pre><code class="lang-ocaml"><span class="hljs-comment">(* Defining a variant type representing shapes *)</span><span class="hljs-keyword">type</span> shape =  | <span class="hljs-type">Circle</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">float</span>  | <span class="hljs-type">Rectangle</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">float</span> * <span class="hljs-built_in">float</span>;;<span class="hljs-keyword">type</span> shape = <span class="hljs-type">Circle</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">float</span> | <span class="hljs-type">Rectangle</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">float</span> * <span class="hljs-built_in">float</span>   <span class="hljs-comment">(* utop output *)</span><span class="hljs-comment">(* Creating instances of shapes *)</span><span class="hljs-keyword">let</span> circle = <span class="hljs-type">Circle</span> <span class="hljs-number">5.0</span>;;<span class="hljs-keyword">val</span> circle : shape = <span class="hljs-type">Circle</span> <span class="hljs-number">5.</span>  <span class="hljs-comment">(* utop output *)</span><span class="hljs-keyword">let</span> rectangle = <span class="hljs-type">Rectangle</span> (<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);;<span class="hljs-keyword">val</span> rectangle : shape = <span class="hljs-type">Rectangle</span> (<span class="hljs-number">3.</span>, <span class="hljs-number">4.</span>)  <span class="hljs-comment">(* utop output *)</span></code></pre><h3>Recursive Types</h3><p>Recursive variant types allow for the definition of recursive data structures, such as linked lists and binary trees. One basic example using linked lists -</p><pre><code class="lang-ocaml"><span class="hljs-comment">(* Defining a recursive list type *)</span><span class="hljs-keyword">type</span> <span class="hljs-symbol">'a</span> mylist =  | <span class="hljs-type">Empty</span>  | <span class="hljs-type">Cons</span> <span class="hljs-keyword">of</span> <span class="hljs-symbol">'a</span> * <span class="hljs-symbol">'a</span> mylist;;<span class="hljs-keyword">type</span> <span class="hljs-symbol">'a</span> mylist = <span class="hljs-type">Empty</span> | <span class="hljs-type">Cons</span> <span class="hljs-keyword">of</span> <span class="hljs-symbol">'a</span> * <span class="hljs-symbol">'a</span> mylist <span class="hljs-comment">(* utop output *)</span><span class="hljs-comment">(* Creating a list of integers *)</span><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> int_list = <span class="hljs-type">Cons</span> (<span class="hljs-number">1</span>, <span class="hljs-type">Cons</span> (<span class="hljs-number">2</span>, <span class="hljs-type">Cons</span> (<span class="hljs-number">3</span>, <span class="hljs-type">Empty</span>)));;<span class="hljs-keyword">val</span> int_list : <span class="hljs-built_in">int</span> mylist = <span class="hljs-type">Cons</span> (<span class="hljs-number">1</span>, <span class="hljs-type">Cons</span> (<span class="hljs-number">2</span>, <span class="hljs-type">Cons</span> (<span class="hljs-number">3</span>, <span class="hljs-type">Empty</span>))) <span class="hljs-comment">(*utop output*)</span></code></pre><div data-node-type="callout"><div data-node-type="callout-emoji">💡</div><div data-node-type="callout-text"><strong><mark>NOTE:</mark></strong> In OCaml, <code>'a</code> represents a type variable, indicating that the type of elements in the tree can be any type. It's a placeholder for a concrete type that will be specified when the tree is instantiated.</div></div><div data-node-type="callout"><div data-node-type="callout-emoji">💡</div><div data-node-type="callout-text"><strong><mark>NOTE:</mark></strong> In OCaml, Empty &amp; Cons are constructors. <code>Empty</code> represents the end of a list, indicating that there are no more elements left. <code>Cons</code> represents adding an element to the front of a list, combining the new element with the rest of the list.</div></div><h2>Option Types</h2><p>The option data type, denoted by the 'option' keyword, is used to represent values that may or may not be present. It is particularly useful for handling null or undefined values.</p><p>Example:</p><pre><code class="lang-ocaml"><span class="hljs-keyword">let</span> maybe_number: <span class="hljs-built_in">int</span> option = <span class="hljs-type">Some</span> <span class="hljs-number">42</span>;;<span class="hljs-keyword">val</span> maybe_number : <span class="hljs-built_in">int</span> option = <span class="hljs-type">Some</span> <span class="hljs-number">42</span> <span class="hljs-comment">(* utop output *)</span></code></pre><h2><strong>Module Types</strong></h2><p><strong>Wait, there exists such things like a Module Type?? Wow!</strong> 🫡</p><p><img src="https://media2.giphy.com/media/26ufdipQqU2lhNA4g/giphy.gif?cid=6c09b952sjpe5pw2osq1635enppkgxvt9nab6ri9r6o56nea&amp;ep=v1_gifs_search&amp;rid=giphy.gif&amp;ct=g" alt="Explore mind blown GIFs" class="image--center mx-auto"></p><p>In OCaml, modules provide a way to encapsulate related code, data, and types. They serve as containers for organizing and structuring code, much like namespaces in other languages. Module types, then, define the interface or signature of a module, specifying the types and functions that must be implemented by any module that conforms to it.</p><h3><strong>What is the Use Case? Why Even Use Module Types?</strong></h3><p>Module types play a crucial role in enforcing abstraction and modularity in OCaml programs. By defining interfaces through module types, developers can separate the concerns of implementation details from the external interface.</p><h3><strong>Defining Module Types</strong></h3><p>To define a module type, we use the <code>module type</code> keyword followed by a name and a set of specifications. These specifications include the types and functions that the module must provide. For instance, consider a module type defining the interface for a stack data structure:</p><pre><code class="lang-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">StackType</span> = <span class="hljs-keyword">sig</span>  <span class="hljs-keyword">type</span> <span class="hljs-symbol">'a</span> t  <span class="hljs-keyword">val</span> empty : <span class="hljs-symbol">'a</span> t  <span class="hljs-keyword">val</span> push : <span class="hljs-symbol">'a</span> -&gt; <span class="hljs-symbol">'a</span> t -&gt; <span class="hljs-symbol">'a</span> t  <span class="hljs-keyword">val</span> pop : <span class="hljs-symbol">'a</span> t -&gt; <span class="hljs-symbol">'a</span> option * <span class="hljs-symbol">'a</span> t<span class="hljs-keyword">end</span>;;<span class="hljs-comment">(* utop output - same actually 🥲 *)</span><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">StackType</span> =  <span class="hljs-keyword">sig</span>    <span class="hljs-keyword">type</span> <span class="hljs-symbol">'a</span> t    <span class="hljs-keyword">val</span> empty : <span class="hljs-symbol">'a</span> t    <span class="hljs-keyword">val</span> push : <span class="hljs-symbol">'a</span> -&gt; <span class="hljs-symbol">'a</span> t -&gt; <span class="hljs-symbol">'a</span> t    <span class="hljs-keyword">val</span> pop : <span class="hljs-symbol">'a</span> t -&gt; <span class="hljs-symbol">'a</span> option * <span class="hljs-symbol">'a</span> t  <span class="hljs-keyword">end</span></code></pre><p>Here, <code>StackType</code> is a module type specifying that any module implementing it must define a type <code>'a t</code> representing a stack, as well as functions <code>empty</code>, <code>push</code>, and <code>pop</code> for stack manipulation.</p><h3><strong>Implementing a Module with the Module Type We Created Now</strong></h3><p>Once a module type is defined, we can create modules that adhere to it by providing concrete implementations for its specifications. For example, we can implement the <code>Stack</code> module type as follows:</p><pre><code class="lang-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Stack</span> : <span class="hljs-type">StackType</span> = <span class="hljs-keyword">struct</span>  <span class="hljs-keyword">type</span> <span class="hljs-symbol">'a</span> t = <span class="hljs-symbol">'a</span> <span class="hljs-built_in">list</span> <span class="hljs-comment">(* Instantiating the variant type *)</span>  <span class="hljs-keyword">let</span> empty = <span class="hljs-literal">[]</span>  <span class="hljs-keyword">let</span> push x s = x :: s  <span class="hljs-comment">(* pattern matching expression used to define an expression *)</span>    <span class="hljs-keyword">let</span> pop = <span class="hljs-keyword">function</span>     | <span class="hljs-literal">[]</span> -&gt; (<span class="hljs-type">None</span>, <span class="hljs-literal">[]</span>)    | x :: xs -&gt; (<span class="hljs-type">Some</span> x, xs)  <span class="hljs-comment">(* `::` is the Cons operator *)</span><span class="hljs-keyword">end</span>;;<span class="hljs-keyword">module</span> <span class="hljs-type">Stack</span> : <span class="hljs-type">StackType</span> <span class="hljs-comment">(* utop output *)</span></code></pre><p>So, finally we are done. Now you know all the most important and noteworthy data types in OCaml.</p><h1>Conclusion</h1><p>Mastering data types in OCaml is essential for writing maintainable &amp; efficient code. From primitive types to algebraic data types and module types, OCaml has many tools for data manipulation &amp; abstraction.</p><p>In future blog posts, we will explore advanced topics such as recursion, higher-order functions, and OCaml's module system. Stay tuned!</p><p>Until then you can connect with me on <a href="https://twitter.com/ddebajyati" target="_blank">twitter</a> :) &amp; share this article with your friends!</p><p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1708704809275/d4557d1a-ae5d-49e2-880f-1b61bdcf7e7f.jpeg?auto=compress,format&amp;format=webp" alt="" class="image--center mx-auto"></p><p>Most importantly, - Happy Coding! 🧑🏻💻 👩🏻💻</p>]]&gt;
