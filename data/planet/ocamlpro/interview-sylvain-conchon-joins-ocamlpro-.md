---
title: '[Interview] Sylvain Conchon joins OCamlPro '
description: "On April 2020, Sylvain Conchon joined the OCamlPro team as our Chief
  Scientific Officer on Formal Methods. Sylvain is a professor at University Paris-Saclay,
  he has also been teaching OCaml in universities for about 20 years. He is the co-author
  of Apprendre \xE0 programmer avec OCaml with Jean-Christ..."
url: https://ocamlpro.com/blog/2020_06_06_interview_sylvain_conchon_joins_ocamlpro
date: 2020-06-06T13:19:46-00:00
preview_image: URL_de_votre_image
authors:
- "\n    Aurore Dombry\n  "
source:
---

<p><img src="https://ocamlpro.com/blog/assets/img/picture_sylvainconchon.jpg" alt=""/></p>
<p><strong>On April 2020, <a href="https://www.lri.fr/~conchon/">Sylvain Conchon</a> joined the OCamlPro team as our Chief Scientific Officer on Formal Methods</strong>. Sylvain is a professor at University Paris-Saclay, he has also been teaching OCaml in universities for about 20 years. He is the co-author of <em><a href="https://www.eyrolles.com/Informatique/Livre/apprendre-a-programmer-avec-ocaml-9782212136784/">Apprendre &agrave; programmer avec OCaml</a></em> with Jean-Christophe Filli&acirc;tre, a book for students in French elitist Preparatory Schools. His field of expertise is the automated deduction for program verification and model checking of parameterized systems. He is also the co-creator of <a href="https://alt-ergo.ocamlpro.com">Alt-Ergo</a>, our <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT Solver</a> dedicated to program verification, used by Airbus and qualified for the [DO-178C](http://(https://en.wikipedia.org/wiki/DO-178C) avionic standard, of <a href="http://cubicle.lri.fr/">Cubicle</a> and the very useful <a href="https://opam.ocaml.org/packages/ocamlgraph/">OCamlgraph</a> library.</p>
<h4>Research and Industry</h4>
<h4>Sylvain, you&rsquo;ve been involved in the industrial world for a long time, what do you think about the interactions between industry and research labs?</h4>
<p>I&rsquo;ve always found interactions with industry professionals to be very rewarding. During my studies, I worked for several years in IT (SSII), and as a university professor, I have supervised students during their internships or apprenticeships in tech companies or at large industrial companies every year. I also take part in research projects that involve industrial partners, and I spent some time at Intel in Portland, which allowed me to discover the computer hardware industry from inside.</p>
<h4>How do you establish a fruitful collaboration between academia and industry?</h4>
<p>It&rsquo;s primarily a question of mutual understanding. You can see it clearly during collaborative research projects that involve both academics and industrial partners. Tools resulting from research, no matter what they are, have to be relevant to real industrial problems. Once that&rsquo;s taken care of, the software also needs to be usable by industry professionals without them needing to understand its inner workings (for instance they shouldn&rsquo;t have to specify all 50 necessary options for its use, interpret its results, or its absence of results!).</p>
<p>This requires a significant engineering effort geared towards the end user; and this task is not part of usual research activity. So, we first need to really understand the problems and needs of the industrial partner, and then determine whether our technologies and tools can be adapted or used to prototype a relevant solution.</p>
<h4>You&rsquo;ve just joined OCamlPro, what are your first thoughts?</h4>
<p>I am very happy to be joining such a dynamic company full of talented, motivated, friendly people, where they do both high-level engineering and top-quality research! Several of my former PhD students are also working at OCamlPro, such as Albin Coquereau, David Declerck and Mattias Roux. With Mohamed Iguernlala and Alain Mebsout at our partner Origin Labs, and with the other OCP team members, it makes our team rock-solid in formal methods tooling development.</p>
<blockquote>
<p><em>&ldquo;Tools resulting from research, no matter what they are, have to satisfy real industry needs.&rdquo;</em></p>
</blockquote>
<h4>OCaml, a Cutting-Edge Language</h4>
<h4>You are well known in the OCaml community, and some of your students became fans of OCaml (and of your teaching)&hellip; What do you say to your students who are just discovering OCaml?</h4>
<p>I tend to summarize it with one phrase: &ldquo;With OCaml, you&rsquo;re not learning the computer programming of the last 10 years, you&rsquo;re learning the programming of <em>the 10 coming years</em>&rdquo;. This has proven true numerous times, because a good number of OCaml&rsquo;s features were to be found in mainstream languages years later. That being said, all my years of teaching this language have led me to think that some modifications to its syntax would make the language easier to tackle for some beginners.</p>
<h4>How did you personally discover OCaml?</h4>
<p>During my master&rsquo;s thesis <em>(ma&icirc;trise)</em> at university: one of my teachers pointed this language to me; they believed it would help me write a compiler for another programming language. So, I discovered OCaml by myself, by reading the manual and going through examples. It wasn&rsquo;t until my MASt <em>(DEA)</em> that I discovered the theoretical foundations of this fantastic language (semantics, typing, compilation).</p>
<h4>Would you say OCaml is an industrial programming language?</h4>
<p>The question needs to be clarified: what <em>is</em> an industrial programming language? If by industrial language you mean one that is used by industry professionals, then I&rsquo;d say that OCaml needs to be used more widely to be classified as such. If the question is whether OCaml is at the same level as languages used in industry, then it <em>absolutely</em> is. But maybe the question is more about the OCaml ecosystem and how developed the available tooling is: certain improvements undoubtedly need to be made in order to reach the level of a widespread industrial programming language. But we&rsquo;re on the right track, especially thanks to companies like OCamlPro and its projects like <a href="https://opam.org">Opam</a> and <a href="https://try.ocamlpro.com">Try-OCaml</a> for example.</p>
<h4>Formal Methods as an Industrial Technique, and the Example of the Alt-Ergo Solver</h4>
<h4>Formal methods being one of OCamlPro&rsquo;s areas of expertise, in what way do you think OCaml is suited for the SMT domain?</h4>
<p>Tools like SMT solvers are mainly symbolic data manipulation software that allow you to analyze, transform, and reason about logical formulas. OCaml is made for that. There is also a more &ldquo;computational&rdquo; side to these tools, which requires precise programming of data structures as well as efficient memory management. OCaml, with its extremely <a href="https://ocamlpro.com/blog/2020_03_23_in_depth_look_at_best_fit_gc">efficient garbage collector</a> (GC), is particularly suited for this kind of development. SMT solvers are tools that also need to be very reliable because errors are difficult to find and are potentially very harmful. OCaml&rsquo;s type system contributes to the reliability of these tools.</p>
<blockquote>
<p>&ldquo;<em>SMT solvers are nowadays essential in software engineering</em>&rdquo;</p>
</blockquote>
<h4>Can you describe Alt-Ergo in a few words?</h4>
<p>Alt-Ergo is a software for proving logical formulas automatically (without human intervention), meaning proving whether a formula is true or false. Alt-Ergo belongs to a family of automated provers called SMT (Satisfiability Modulo Theories). It was designed to be integrated into program verification platforms. These platforms (like [Why3](https://(https://why3.lri.fr/), <a href="https://frama-c.com/">Frama-C</a>, <a href="https://www.adacore.com/about-spark">Spark</a>&hellip;) generate logical formulas that need to be proven in order to guarantee that a program is safe. Proving these formulas by hand would be very tedious (there are sometimes tens of thousands of formulas to prove). An SMT solver such as Alt-Ergo is there to do that job in a completely automated way. It is what allows these verification platforms to be used at an industrial level.</p>
<h4>In what way developing this software in OCaml benefits Alt-Ergo over its competitors?</h4>
<p>It makes it more reliable, since an SMT solver, like any program, can have bugs. Most of Alt-Ergo is written in a purely functional programming style, i.e. only using immutable data structures. One of the advantages of this programming style is that it allowed us to formally prove the main components of Alt-Ergo (for example, its kernel was formalized using the Coq proof assistant, which would have been impossible with a language like C++) without sacrificing efficiency thanks to a very good garbage collector and OCaml&rsquo;s very powerful persistent data structure library. We made use of OCaml&rsquo;s module system, particularly functors and recursive modules, to conceive a very modular code, making it maintainable and easily extensible. OCaml allowed us to create <a href="https://ocamlpro.com/blog/2019_07_09_alt_ergo_participation_to_the_smt_comp_2019">an SMT solver just as efficient as CVC4 or Z3 for program verification</a>, but with a total number of lines of code divided by three or four.This obviously does not guarantee that Alt-Ergo has zero bugs, but it really helps us in fixing any if they are found.</p>
<h4>What is your opinion on SMT solvers and the current state of the art of SMT?</h4>
<p>Today, SMT solvers are essential in software engineering. They can be found in various tools for proving, testing, model checking, abstract interpretation, and typing. The main reason for this success is that they are becoming increasingly efficient and the underlying theories are becoming more and more expressive. It is a very competitive area of research among the world&rsquo;s best universities and research labs, as well as large IT companies. But there is still a lot of room for improvement, particularly in the nonlinear arithmetic domain, where user demand is growing. For now, one of my research objectives is to combine Model Checking tools with program verification. These two types of tools are based on SMT and should complement each other to offer even more automation to verification tools.</p>
<h4>What applications can SMT techniques and Alt-Ergo have in industry?</h4>
<p>SMT techniques can be used wherever formal methods are useful. Including, but not limited to verifying the safety of critical software in embedded systems, finding security vulnerabilities in computer systems, or resolving planning problems. They can also be found in domains of artificial intelligence, where it is crucial to guarantee neural network stability and produce formal explanations of their results.</p>
<h4>You ended up working on Model Checking, can you tell us about how Model Checking is connected to SMT and how it is currently used?</h4>
<p>Model Checking consists of verifying that all possible states of a system respect certain properties, regardless of the input data. This is a difficult problem because some systems (like microprocessors for example) can have hundreds of millions of states. To reach that scale, model checkers implement extremely sophisticated algorithms to visit these states quickly by storing them in a compact manner. That said, this technique reaches its limits when the input values are unbounded or when the number of system components is unknown. Imagine Internet routing algorithms where you don&rsquo;t know how many machines are connected. These algorithms must be correct no matter the number of machines. This is where SMT solvers come into play. By using logical formulas, we&rsquo;re able to represent sets of states of arbitrary sizes. Visiting system states becomes calculating the formulas that represent the states satisfying the desired properties, etc. Therefore, everything in Model Checking is based on logical formulas, and SMT solvers are of course there to reason about these formulas.</p>

