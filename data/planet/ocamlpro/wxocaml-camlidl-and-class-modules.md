---
title: wxOCaml, camlidl and Class Modules
description: "A few months ago, a memory leak in the Scanf.fscanf function of OCaml\u2019s
  standard library has been reported on the OCaml mailing list. The following \u201Cminimal\u201D
  example reproduces this misbehavior: Let us see how to identify the origin of the
  leak and fix it with our OCaml memory profiler. Instal..."
url: https://ocamlpro.com/blog/2015_04_13_yes_ocp_memprof_scanf
date: 2015-04-13T13:19:46-00:00
preview_image: URL_de_votre_image
authors:
- "\n    \xC7agdas Bozman\n  "
source:
---

<p>A few months ago, a memory leak in the <code>Scanf.fscanf</code> function of OCaml&rsquo;s standard library has been reported on the OCaml mailing list. The following &ldquo;minimal&rdquo; example reproduces this misbehavior:</p>
<pre><code class="language-ocaml">for i = 0 to 100_000 do
  let ic = open_in &ldquo;some_file.txt&rdquo; in
  Scanf.fscanf ic &ldquo;%s&rdquo; (fun _s -&amp;amp;gt; ());
  close_in ic
done;;

read_line ();;
</code></pre>
<p>Let us see how to identify the origin of the leak and fix it with our OCaml memory profiler.</p>
<h2>Installing the OCaml Memory Profiler</h2>
<p>We first install our modified OCaml compiler and the memory profiling tool thanks to the following opam commands:</p>
<pre><code class="language-shell-session">$ opam remote add memprof http://memprof.typerex.org/opam
$ opam update
</code></pre>
<pre><code class="language-shell-session">$ opam switch 4.01.0+ocp1-20150202
$ opam install ocp-memprof
$ eval opam config env
</code></pre>
<p>That&rsquo;s all ! Installation is done after only five (opam) commands.</p>
<h2>Compiling and Executing the Example</h2>
<p>The second step consists in compiling the example above and profiling it. This is simply achieved with the commands:</p>
<pre><code class="language-shell-session">$ ocamlopt scanf_leak.ml -o scanf.x
</code></pre>
<pre><code class="language-shell-session">$ ocp-memprof &ndash;exec scanf.x
</code></pre>
<p>You may notice that no instrumentation of the source is needed to enable profiling.</p>
<h2>Visualizing the Results</h2>
<p>In the last command above, <code>scanf.x</code> dumps a lot of information (related to memory occupation) during its execution. Our &ldquo;OCaml Memory Profiler&rdquo; then analyzes these dumps, and generates a &ldquo;human readable&rdquo; graph that shows the evolution of memory consumption after each OCaml garbage collection. Concretely, this yields the graph below (the interactive graph generated by <code>ocp-memprof</code> is <a href="http://memprof.typerex.org/users/04db0c7fb9232a0829e862d5bb2801fb/2015-03-05_10-54-04_29a20719bf5482a878293ed0effa010f_17729/index.html">available here</a>). As you can see, memory consumption is growing abnormally and exceed 240Mb ! Note that we stopped the <code>scanf.x</code> after 90 seconds.</p>
<h2>Playing With (Some of) ocp-memprof Capabilities</h2>
<p>ocp-memprof allows to group and show data contained in the graph w.r.t. several criteria. For instance, data are grouped by &ldquo;Modules&rdquo; in the capture below. This allows us to deduce that most allocations are performed in the <code>Scanf</code> and <code>Buffer</code> modules.</p>
<p>In addition to aggregation capabilities, the <a href="http://memprof.typerex.org/users/04db0c7fb9232a0829e862d5bb2801fb/2015-03-05_10-54-04_29a20719bf5482a878293ed0effa010f_17729/index.html">interactive graph</a> generated by ocp-memprof also allows to &ldquo;zoom&rdquo; on particular data. For instance, by looking at <code>Scanf</code>, we obtain the graph below that shows the different functions that are allocating in this module. We remark that the most allocating function is <code>Scanf.Scanning.from_ic</code>. Let us have a look to this function.</p>
<p>From Profiling Graphs to Source Code
The code of the function <code>from_ic</code>, that is responsible for most of the allocation in <code>Scanf</code>, is the following:</p>
<pre><code class="language-ocaml">let memo_from_ic =
let memo = ref [] in
(fun scan_close_ic ic -&gt;
   try 
     List.assq ic !memo 
   with
   | Not_found -&gt;
     let ib = from_ic scan_close_ic (From_channel ic) ic in
     memo := (ic, ib) :: !memo;
     ib)
;;
</code></pre>
<p>It looks like that the leak is caused by the <code>memo</code> list that associates a lookahead buffer, resulting from the call to <code>from_ic</code>, with each input channel.</p>
<h2>Patching the Code</h2>
<p>Benoit Vaugon quickly sent a patch based on weak-pointers that seems to solve the problem. He modified the code as follows:</p>
<ul>
<li>he put the key in a weak set in order to test if it is gone;
</li>
<li>he created a pair that stores the key and the associated value (<code>PairMemo</code>);
</li>
<li>he put this pair in a weak set (<code>IcMemo</code>), where it will be reclaimed at the next GC because;
</li>
<li>he added a finalizer on the pair that adds again the pair in the weak set at each GC
</li>
</ul>
<pre><code class="language-ocaml">let memo_from_ic =
  let module IcMemo = Weak.Make (
    struct
      type t = Pervasives.in_channel
      let equal ic1 ic2 = ic1 = ic2
      let hash ic = Hashtbl.hash ic
    end) 
  in
  let module PairMemo = Weak.Make (
    struct
      type t = Pervasives.in_channel * in_channel
      let equal (ic1, _) (ic2, _) = ic1 = ic2
      let hash (ic, _) = Hashtbl.hash ic
    end) 
  in
  let ic_memo = IcMemo.create 16 in
  let pair_memo = PairMemo.create 16 in
  let rec finaliser ((ic, _) as pair) =
    if IcMemo.mem ic_memo ic then (
      Gc.finalise finaliser pair;
      PairMemo.add pair_memo pair) in
  (fun scan_close_ic ic -&gt;
     try snd (PairMemo.find pair_memo (ic, stdin)) with
     | Not_found -&gt;
       let ib = from_ic scan_close_ic (From_channel ic) ic in
       let pair = (ic, ib) in
       IcMemo.add ic_memo ic;
       Gc.finalise finaliser pair;
       PairMemo.add pair_memo pair;
       ib)
;;
</code></pre>
<h2>Checking the Fixed Version</h2>
<p>Curious to see the memory behavior after applying this patch ? The graph below shows the memory consumption of the patched version of <code>Scanf</code> module. Again, the interactive version is <a href="http://memprof.typerex.org/users/04db0c7fb9232a0829e862d5bb2801fb/2015-03-05_13-41-42_a5217e67db7d057bc68baeb1d45d7ce0_28767/index.html">available here</a>. After each iteration of the <code>for-loop</code>, the memory is released as expected and memory consumption does not exceed 2.1Mb during each <code>for-loop</code> iteration.</p>
<h2>Conclusion</h2>
<p>This example is online in our gallery of examples if you want to see and explore the graphs (<a href="http://memprof.typerex.org/users/04db0c7fb9232a0829e862d5bb2801fb/2015-03-05_10-54-04_29a20719bf5482a878293ed0effa010f_17729/">with the leak</a> and <a href="http://memprof.typerex.org/users/04db0c7fb9232a0829e862d5bb2801fb/2015-03-05_13-41-42_a5217e67db7d057bc68baeb1d45d7ce0_28767/">without the leak</a>).</p>
<p>Do not hesitate to use <code>ocp-memprof</code> on your applications. Of course, all feedback and suggestions on using <code>ocp-memprof</code> are welcome, just send us an email !</p>
<p>More information:</p>
<ul>
<li>Homepage: <a href="http://memprof.typerex.org/">http://memprof.typerex.org/</a>
</li>
<li>Usage: <a href="http://memprof.typerex.org/free-version.php">http://memprof.typerex.org/free-version.php</a>
</li>
<li>Support: <a href="http://memprof.typerex.org/report-a-bug.php">http://memprof.typerex.org/report-a-bug.php</a>
</li>
<li>Gallery of examples: <a href="http://memprof.typerex.org/gallery.php">http://memprof.typerex.org/gallery.php</a>
</li>
<li>Commercial: <a href="http://memprof.typerex.org/commercial-version.php">http://memprof.typerex.org/commercial-version.php</a>
</li>
</ul>

