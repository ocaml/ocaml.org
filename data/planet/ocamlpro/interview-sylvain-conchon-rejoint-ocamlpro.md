---
title: '[Interview] Sylvain Conchon rejoint OCamlPro'
description: "Sylvain Conchon vient de rejoindre OCamlPro en tant que Chief Scientific
  Officer M\xE9thodes Formelles. Professeur \xE0 l\u2019Universit\xE9 Paris-Saclay,
  il travaille dans le domaine de la d\xE9monstration automatique pour la preuve de
  programmes et le model checking pour syst\xE8mes param\xE9tr\xE9s. Il est aussi
  ..."
url: https://ocamlpro.com/blog/2020_06_05_fr_interview_sylvain_conchon_rejoint_ocamlpro
date: 2020-06-05T13:19:46-00:00
preview_image: URL_de_votre_image
featured:
authors:
- "\n    Aurore Dombry\n  "
source:
---

<p><img src="https://ocamlpro.com/blog/assets/img/picture_sylvainconchon.jpg" alt=""/></p>
<blockquote>
<p>Sylvain Conchon vient de rejoindre OCamlPro en tant que Chief Scientific Officer M&eacute;thodes Formelles. Professeur &agrave; l&rsquo;Universit&eacute; Paris-Saclay, il travaille dans le domaine de la d&eacute;monstration automatique pour la preuve de programmes et le model checking pour syst&egrave;mes param&eacute;tr&eacute;s. Il est aussi le co-cr&eacute;ateur d&rsquo;Alt-Ergo.</p>
</blockquote>
<h3>Recherche et industrie</h3>
<p><strong>Sylvain, tu fr&eacute;quentes de longue date le monde industriel,
que penses-tu des interactions entre les industriels et les laboratoires
de recherche ?</strong></p>
<p>J&rsquo;ai toujours trouv&eacute; tr&egrave;s enrichissantes les interactions avec les
industriels. Pendant mes &eacute;tudes, j&rsquo;ai travaill&eacute; plusieurs ann&eacute;es en
SSII, et je suis mes &eacute;tudiants en stage ou en apprentissage dans des
soci&eacute;t&eacute;s technologiques ou chez de grands industriels. Je participe
&eacute;galement &agrave; des projets de recherche qui impliquent des industriels,et
j&rsquo;ai pass&eacute; quelques temps chez Intel &agrave; Portland, ce qui m&rsquo;a permis de
d&eacute;couvrir l&rsquo;industrie du hardware.</p>
<p><strong>Comment parvenir &agrave; &eacute;tablir des relations fructueuses entre le monde acad&eacute;mique et les industriels ?</strong></p>
<p>C&rsquo;est beaucoup une histoire de rencontre. On le voit lors des
montages de projets de recherche collaboratifs qui r&eacute;unissent
acad&eacute;miques et industriels. Les outils issus de la recherche, quels
qu&rsquo;ils soient, doivent avant tout r&eacute;pondre &agrave; un besoin r&eacute;el des
industriels. Si c&rsquo;est le cas, il faut aussi que le logiciel soit
utilisable par des ing&eacute;nieurs du m&eacute;tier sans qu&rsquo;il leur soit n&eacute;cessaire
de comprendre son fonctionnement interne (par exemple, pour positionner
les 50 options n&eacute;cessaires &agrave; son utilisation, interpr&eacute;ter ses r&eacute;sultats
ou ses absences de r&eacute;sultats!). Cela n&eacute;cessite &agrave; l&rsquo;&eacute;vidence un travail
d&rsquo;ing&eacute;nierie important, tourn&eacute; vers l&rsquo;utilisateur final et souvent
&eacute;loign&eacute; des activit&eacute;s des chercheurs. Il faut donc comprendre les
probl&egrave;mes et les besoins des industriels, et ensuite d&eacute;terminer si les
technologies et les outils que l&rsquo;on ma&icirc;trise peuvent &ecirc;tre adapt&eacute;s ou
utilis&eacute;s pour r&eacute;aliser un prototype qui r&eacute;ponde &agrave; certains de ces
besoins.</p>
<p><strong>Tu viens de rejoindre OCamlPro, quelles sont tes premi&egrave;res impressions ?</strong></p>
<p>Je suis heureux d&rsquo;avoir rejoint une entreprise tr&egrave;s dynamique, pleine
de gens talentueux, motiv&eacute;s et sympathiques, o&ugrave; l&rsquo;on fait &agrave; la fois de
l&rsquo;ing&eacute;nierie de haut niveau et de la recherche de qualit&eacute; !</p>
<blockquote>
<p><em>&ldquo; Les outils issus de la recherche, quels qu&rsquo;ils soient, doivent avant tout r&eacute;pondre &agrave; un besoin r&eacute;el des industriels.&rdquo;</em></p>
</blockquote>
<h3>OCaml, un langage de pointe</h3>
<p><strong>Tu es connu dans la communaut&eacute; OCaml, et certains de
tes &eacute;tudiants sont devenus des fans d&rsquo;OCaml (et de ton enseignement)&hellip;
que dis-tu &agrave; tes &eacute;tudiants qui d&eacute;couvrent OCaml ?</strong></p>
<p>J&rsquo;ai tendance &agrave; r&eacute;sumer en disant ceci : <em>&laquo; avec OCaml, vous n&rsquo;apprenez pas la programmation des 10 derni&egrave;res ann&eacute;es, mais celle des 10 prochaines ann&eacute;es &raquo;</em>. Cette affirmation s&rsquo;est toujours v&eacute;rifi&eacute;e car bon nombre de traits du langage OCaml se sont retrouv&eacute;s dans les langages <em>mainstream</em>, avec plusieurs ann&eacute;es de d&eacute;calage. Cela dit, mes ann&eacute;es d&rsquo;exp&eacute;rience dans l&rsquo;enseignement de ce langage me laissent penser que quelques modifications dans sa syntaxe permettraient une approche plus ais&eacute;e pour certains d&eacute;butants.</p>
<p><strong>Et toi, comment as-tu d&eacute;couvert OCaml ?</strong></p>
<p>Pendant mes &eacute;tudes &agrave; l&rsquo;Universit&eacute; lors de mon projet de fin de
ma&icirc;trise : un de mes enseignants m&rsquo;avait orient&eacute; vers ce langage pour
m&rsquo;aider &agrave; r&eacute;aliser un compilateur pour un langage de programmation
concurrente. J&rsquo;ai donc d&eacute;couvert ce langage par moi-m&ecirc;me, en lisant le
manuel et les exemples. Ce n&rsquo;est que pendant mon DEA que j&rsquo;ai d&eacute;couvert
les fondements th&eacute;oriques de ce beau langage (s&eacute;mantique, typage,
compilation).</p>
<p><strong>OCaml, un langage industriel ou pas encore ?</strong></p>
<p>Il convient de pr&eacute;ciser la question : qu&rsquo;est-ce qu&rsquo;un langage
industriel ? Si c&rsquo;est un langage utilis&eacute; par les industriels, alors
OCaml n&rsquo;est h&eacute;las pas encore suffisamment utilis&eacute; dans l&rsquo;industrie pour
&ecirc;tre qualifi&eacute; ainsi. Si la question est de savoir s&rsquo;il a le niveau des
langages utilis&eacute;s dans l&rsquo;industrie, alors la r&eacute;ponse est oui, sans
h&eacute;siter. Mais peut-&ecirc;tre la question porte-t-elle davantage sur
l&rsquo;&eacute;cosyst&egrave;me OCaml et la maturit&eacute; de l&rsquo;outillage: il y a s&ucirc;rement des
progr&egrave;s &agrave; faire pour atteindre le niveau d&rsquo;un langage tr&egrave;s r&eacute;pandu dans
l&rsquo;industrie, mais c&rsquo;est en bonne voie, en particulier gr&acirc;ce &agrave; des
entreprises telles qu&rsquo;OCamlPro.</p>
<h3>Les m&eacute;thodes formelles comme technique industrielle, et l&rsquo;exemple du solveur Alt-Ergo</h3>
<p><strong>Les m&eacute;thodes formelles sont l&rsquo;un des domaines d&rsquo;expertise d&rsquo;OCamlPro, en quoi penses-tu qu&rsquo;OCaml est adapt&eacute; au domaine des SMT ?</strong></p>
<p>Les outils comme les solveurs SMT sont principalement des logiciels
de manipulation symbolique des donn&eacute;es qui permettent d&rsquo;analyser, de
transformer et de raisonner sur des formules logiques. OCaml est fait
pour ce genre de traitements. Il y a aussi une partie plus &laquo;
calculatoire &raquo; dans ces outils qui n&eacute;cessite une programmation fine des
structures de donn&eacute;es ainsi qu&rsquo;une gestion efficace de la m&eacute;moire. OCaml
est particuli&egrave;rement adapt&eacute; pour ce genre de d&eacute;veloppements, surtout
avec son ramasse-miettes (GC) extr&ecirc;mement performant. Enfin, les
solveurs SMT sont des outils qui doivent avoir un grand niveau de
fiabilit&eacute; car les erreurs dans ces logiciels sont difficiles &agrave; trouver
et leur pr&eacute;sence peut &ecirc;tre tr&egrave;s pr&eacute;judiciable. Le syst&egrave;me de types
d&rsquo;OCaml contribue &agrave; la fiabilit&eacute; de ces outils.</p>
<blockquote>
<p><em>&ldquo;Les solveurs SMT sont aujourd&rsquo;hui incontournables dans le domaine de l&rsquo;ing&eacute;nierie du logiciel.&rdquo;</em></p>
</blockquote>
<p><strong>Peux-tu nous parler d&rsquo;Alt-Ergo en quelques mots ?</strong></p>
<p>C&rsquo;est un logiciel utilis&eacute; pour prouver automatiquement (sans
intervention humaine) des formules logiques, c&rsquo;est-&agrave;-dire savoir si ces
formules sont vraies ou fausses. Alt-Ergo appartient &agrave; une famille de
d&eacute;monstrateurs automatiques appel&eacute;e SMT (pour Satisfiabilit&eacute; Modulo
Th&eacute;ories). Il a &eacute;t&eacute; con&ccedil;u pour &ecirc;tre int&eacute;gr&eacute; dans des plate-formes de
v&eacute;rification de programmes. Ces outils (comme Why3, Frama-C, Spark,&hellip;)
g&eacute;n&egrave;rent des formules logiques qu&rsquo;il est n&eacute;cessaire de prouver afin de
garantir qu&rsquo;un programme est s&ucirc;r. Faire la preuve de ces formules &agrave; la
main serait tr&egrave;s fastidieux (il y a parfois plusieurs dizaines de
milliers de formules &agrave; prouver). Un solveur SMT comme Alt-Ergo est l&agrave;
pour faire ce travail, de mani&egrave;re compl&egrave;tement automatique. C&rsquo;est ce qui
permet &agrave; ces plateformes de v&eacute;rification d&rsquo;&ecirc;tre utilisables au niveau
industriel.</p>
<p><strong>En quoi le d&eacute;veloppement d&rsquo;Alt-Ergo en OCaml peut-il &ecirc;tre un avantage par rapport aux concurrents ?</strong></p>
<p>Cela lui conf&egrave;re une plus grande s&ucirc;ret&eacute;, car un solveur SMT, comme
n&rsquo;importe quel programme peut aussi avoir des bugs. La plus grande
partie d&rsquo;Alt-Ergo est programm&eacute;e dans un style purement fonctionnel,
c&rsquo;est-&agrave;-dire uniquement avec l&rsquo;utilisation de structures de donn&eacute;es
immuables. L&rsquo;un des avantages de ce style de programmation est qu&rsquo;il
nous a permis de prouver formellement ses principaux composants (par
exemple, son noyau a &eacute;t&eacute; formalis&eacute; &agrave; l&rsquo;aide de l&rsquo;assistant &agrave; la preuve
Coq, ce qui serait impossible &agrave; faire dans un langage comme C++), sans
sacrifier son efficacit&eacute; gr&acirc;ce au tr&egrave;s bon ramasse-miettes et &agrave; la
biblioth&egrave;que de structures de donn&eacute;es persistantes tr&egrave;s performantes
d&rsquo;OCaml. Enfin, nous avons largement b&eacute;n&eacute;fici&eacute; du syst&egrave;me de modules
d&rsquo;OCaml, en particulier les foncteurs et les modules r&eacute;cursifs, pour
concevoir un code tr&egrave;s modulaire, maintenable et facilement extensible.
Au final, OCaml nous a permis de concevoir un solveur SMT aussi
performant que CVC4 ou Z3 pour la preuve de programmes, mais avec un
nombre de lignes de code divis&eacute; par trois ou quatre. Bien s&ucirc;r, cela ne
garantit pas que Alt-Ergo ait z&eacute;ro bugs, mais cela nous aide beaucoup &agrave;
mettre le doigt dessus quand quelqu&rsquo;un en trouve.</p>
<p><em>&ldquo;OCaml nous a permis de concevoir un solveur SMT aussi performant que CVC4 ou Z3 pour la
preuve de programmes, mais avec un nombre de lignes de code divis&eacute; par
trois ou quatre.&ldquo;</em></p>
<p><strong>Quel est ton avis sur les solveurs SMT et l&rsquo;&eacute;tat de l&rsquo;art SMT actuel ?</strong></p>
<p>Les solveurs SMT sont aujourd&rsquo;hui incontournables dans le domaine de
l&rsquo;ing&eacute;nierie du logiciel. On les trouve aussi bien dans des outils de
preuve, de test, de model checking, d&rsquo;interpr&eacute;tation abstraite ou encore
de typage. La principale raison de ce succ&egrave;s est qu&rsquo;ils sont de plus en
plus efficaces et les th&eacute;ories sous-jacentes sont tr&egrave;s expressives.
C&rsquo;est un domaine de recherche tr&egrave;s concurrentiel entre les meilleures
universit&eacute;s ou laboratoires du monde et de grandes entreprises en
informatique. Mais la marge de progression de ces outils est encore tr&egrave;s
grande, en particulier dans le domaine de l&rsquo;arithm&eacute;tique non lin&eacute;aire
o&ugrave; la demande des utilisateurs est de plus en plus forte. Pour le
moment, un de mes objectifs en recherche est de combiner les outils de
Model Checking avec ceux de preuve de programmes. Ces deux familles
d&rsquo;outils reposent sur les SMT et elles devraient se compl&eacute;ter pour
offrir des outils de v&eacute;rification encore plus automatiques.</p>
<p><strong>Quelles applications les techniques SMT et Alt-Ergo peuvent-elles avoir dans l&rsquo;industrie ?</strong></p>
<p>Les techniques SMT peuvent &ecirc;tre utilis&eacute;es partout o&ugrave; les m&eacute;thodes
formelles peuvent &ecirc;tre utiles. Par exemple (mais cette liste est loin
d&rsquo;&ecirc;tre exhaustive), pour v&eacute;rifier la s&ucirc;ret&eacute; de logiciels critiques dans
le domaine de l&rsquo;embarqu&eacute;, pour trouver des failles de s&eacute;curit&eacute; dans les
syst&egrave;mes informatiques ou pour r&eacute;soudre des probl&egrave;mes de planification.
On les trouve &eacute;galement dans le domaine de l&rsquo;intelligence artificielle
o&ugrave; il est crucial de garantir la stabilit&eacute; des r&eacute;seaux de neurones mais
aussi de produire des explications formelles sur leurs r&eacute;sultats.</p>
<p><strong>Tu as &eacute;t&eacute; amen&eacute; &agrave; travailler sur le Model Checking, peux-tu
nous parler des liens entre Model Checking et SMT et de son utilisation
actuelle ?</strong></p>
<p>Le Model Checking consiste &agrave; v&eacute;rifier que tous les &eacute;tats possibles
d&rsquo;un syst&egrave;me respectent bien certaines propri&eacute;t&eacute;s, et ce quelles que
soient les donn&eacute;es en entr&eacute;e. C&rsquo;est un probl&egrave;me difficile car certains
syst&egrave;mes (microprocesseurs par ex.) peuvent avoir des centaines de
millions d&rsquo;&eacute;tats. Pour passer &agrave; l&rsquo;&eacute;chelle, les model checkers
impl&eacute;mentent des algorithmes tr&egrave;s perfectionn&eacute;s pour visiter ces &eacute;tats
rapidement, en les stockant d&rsquo;une mani&egrave;re tr&egrave;s compacte. Cependant,
cette technique atteint ses limites quand les valeurs prises en entr&eacute;e
sont non born&eacute;es ou quand le nombre de composants du syst&egrave;me n&rsquo;est pas
connu. Pensez aux algorithmes de routage d&rsquo;Internet o&ugrave; on ne conna&icirc;t pas
le nombre de machines sur le r&eacute;seau, ces algorithmes doivent &ecirc;tre
corrects, quel que soit ce nombre de machines. C&rsquo;est l&agrave; que les solveurs
SMT entrent en jeu. En utilisant des formules logiques, on peut
repr&eacute;senter des ensembles d&rsquo;&eacute;tats de taille arbitraire. Visiter les
&eacute;tats d&rsquo;un syst&egrave;me consiste alors &agrave; calculer les formules qui
repr&eacute;sentent ces &eacute;tats. V&eacute;rifier que les &eacute;tats respectent une propri&eacute;t&eacute;
revient &agrave; prouver que les formules qui repr&eacute;sentent des &eacute;tats impliquent
la propri&eacute;t&eacute; voulue, etc. Tout dans le Model Checking repose donc sur
des formules logiques et les solveurs SMT sont &eacute;videmment l&agrave; pour
raisonner sur ces formules.</p>

