---
title: 'Programming Tools UX: When Statically Compiled Feels Dynamic'
description: The great debate Dynamic vs. Static is a classic one. And usually ends
  up with no clear winner. Dynamic programming languages offer develope...
url: http://blog.opalang.org/2012/09/programming-tools-ux-when-statically.html
date: 2012-09-18T10:08:00-00:00
preview_image: https://lh3.googleusercontent.com/blogger_img_proxy/AByxGDQOOlxTygWHjBAONEBtQUtwRl5U47ZuDTY3oWCeWPgV0T6ECKa2Wv2k9ykxoyDIXiqi0YZOVZ4spBgZCD4FQDU=w1200-h630-p-k-no-nu
featured:
authors:
- Rudy Sicard
---

<p>The great debate Dynamic vs. Static is a classic one. And usually ends up with no clear winner. Dynamic programming languages offer developers an awesome <a href="http://en.wikipedia.org/wiki/Workflow"><strong>workflow</strong></a>: <em>Edit, test, edit, test</em>... Static typing and compilation usually breaks this simple workflow, but offers more guarantees.</p><p><strong>Build &amp; Run on save</strong> functionality is not something new and exists in most IDEs. However, following the KISS philosophy, I recently worked on <code>opa-watch</code>, a simple independent tool that brings this functionality to your <a href="http://opalang.org">Opa</a> project.</p><p><code>opa-watch</code> automatically [re]compiles and [re]launches your project while you edit it. It simplifies your workflow and helps you to focus on editing and testing steps, just forgetting about the compilation step. All this is made possible by the speed of the <a href="http://opalang.org">Opa</a> compiler.</p><h3><code>opa-watch</code>: A standard use case</h3><p>In a terminal, create a new <a href="http://opalang.org">Opa</a> project (e.g. <code>opa create --name watchMe</code>). And <code>opa-watch</code> it <strong>once and for all</strong> by indicating the path of the project:</p><pre><code>opa-watch --src-dir watchMe</code></pre><p>Then you are notified <strong>Launched : watchMe</strong> and you can open your app in your browser (e.g. <code>firefox locahost:2001</code>):</p><img src="http://i.imgur.com/na3yY.png"/><br/>
<p>Now, <em>edit</em> and <em>save</em>, for instance change the button label from &quot;Save&quot; to &quot;Done&quot; (e.g. <code>emacs watchMe/src/view.opa</code>).</p><p>Wait for the &quot;Launched&quot; notification and refresh the page in you browser:</p><img src="http://i.imgur.com/E8jX8.png"/><br/>
<p>In case of an error (for instance when you have syntax or type errors in your code), you are notified as well:</p><img src="http://i.imgur.com/KWUt9.png"/><br/>
<p>This example works for any <a href="http://opalang.org">Opa</a> project that defines either an <code>.opack</code> and/or a <code>.conf</code> file.</p><h3>Compiled vs Dynamic languages</h3><h4>Compiled languages</h4><p>Compilation enforces that some verification steps are performed before you can test your project. Theses verifications can be minimal, like <a href="http://en.wikipedia.org/wiki/Syntax_error">syntactic correctness</a> or <a href="http://www.answers.com/topic/undefined-variable">undefined variable</a>. Or more high level like <a href="http://en.wikipedia.org/wiki/Type_system#Static_typing">type checking</a>. Typically they also improve the speed of the application at runtime.</p><p>Type checking is probably the most important verification to be done, as it helps to verify that all piece of abstractions and API of your projects' modules fit together. Compilation error systematically detect a problem with a <a href="http://blog.opalang.org/2012/07/programming-tools-ux-better-type-error.html"><strong>handcrafted diagnosis</strong></a> and usually <a href="http://blog.opalang.org/2012/07/programming-tools-ux-better-type-error.html"><strong>precise code positions</strong></a>. Maintaining big projects is made much easier.</p><p>Ideally only <a href="http://www.webopedia.com/TERM/R/runtime_error.html">runtime</a> and <a href="http://en.wikipedia.org/wiki/Logic_error">logic errors</a> remains in your code after compilation succeed. The dark side is that a compilation step is needed and it can take some time.</p><h4>Dynamic languages</h4><p>Applications written with dynamic languages run and can be tested immediately. Even if the source code is a work in progress, possibly incomplete and incorrect, an application can still be tested. Hence theses languages appears <a href="http://alexgaynor.net/2010/sep/29/dynamic-and-static-programming-languages-and-teaching/">more accessible</a>.</p><p>The disadvantage is that any problem in the code (syntax, incoherency, missing parts) will result in a runtime error, that will appear sooner or latter (think production), sometimes with high uncertainty.</p><p>Test errors can be difficult to reproduce and may only be <strong>symptoms</strong>, loosely related to the real problem. And the bigger the application, the harder ironing out bugs can be.</p><h4>Typical workflow</h4><p>With compiled language, you usually repeat the following steps:</p><ol style="list-style-type: decimal"><li>Edit code</li>
<li><em>Compile</em> (goto 1 on error)</li>
<li>Run server</li>
<li>Refresh browser</li>
<li>Test (goto 1 on error)</li>
</ol><h4>Achieving the highest productivity</h4><p>Step 2 in the above list, compilation, is usually perceived as a deal breaker because of <strong>3 speed bumps</strong>:</p><ul><li>invoking the compiler;</li>
<li>compilation time;</li>
<li>compilations errors.</li>
</ul><p>The last item is not really a problem.</p><p>Compilation errors are just way to get fewer test errors. Both equally breaks the workflow, but it's much better to notice errors as early as possible and in that respect dealing with errors before runtime vs. during test is a much better practice. </p><p>It really seems there is no trivial winner in the ever-going debate between dynamic and static languages, otherwise most companies would be using only one of the two. </p><p><em>IF</em> the compilation step was automatic and fast, compiled languages would be definitely much more interesting. This is exactly the goal of <code>opa-watch</code>.</p><h3><code>opa-watch</code>: In Details</h3><p><code>opa-watch</code>:</p><ol style="list-style-type: decimal"><li>detects any change in your project,</li>
<li>(re)Compiles the project automatically, and</li>
<li>(re)Runs the project server.</li>
</ol><p>It eliminates most manual commands required to test the project. User Interaction is minimized to almost zero and usually only need to refresh the application in your browser.</p><p>Compilation even feels faster since the duration of the compilation is partialy covered by other developer interactions like switching to browser window, refresh, etc. If compilation is fast enough, like we strive to do with <a href="http://opalang.org">Opa</a>, it is almost unnoticeable.</p><p>The apple of the pie: <code>opa-watch</code> is not restricted to an IDE or a particular language and can be used with any project using customized command-line options.</p><h4>Custom commands</h4><p>By default, <code>opa-watch</code> has rules for standard <a href="http://opalang.org">Opa</a> projects (which either have a .opack and/or a .conf file). You just need to invoke <code>opa-watch</code> with your <a href="http://opalang.org">Opa</a> project directory as a parameter.</p><p><code>opa-watch</code> on any project by giving the <em>Compile</em> command and the <em>Run server</em> command explicitly. In fact you can give a sequence of commands to be executed. For instance if your project has a Makefile with two build targets, <code>target1</code> and <code>target2</code> to build and a <code>test</code> target:</p><pre><code>opa-watch --src-dir myProject --command &quot;make build1&quot; --command &quot;make build2&quot; --command &quot;make test&quot;</code></pre><p>The last command is assume to be the <em>Run server</em> command. The <em>Run server</em> command should kill preexisting run, otherwise you can run several times your project in parallel. The <em>Launched</em> notification does not wait for this command termination. You can change this behavior with <code>--no-launch</code>. For instance, if you just need to auto-build (without running the server):</p><pre><code>opa-watch --src-dir myProject --command &quot;make target1&quot; --no-launch</code></pre><p>More customization options are available in the <a href="https://github.com/OpaOnWindowsNow/opa-watch/blob/master/README.md">README</a>.</p><h4>Ignoring given files (or directories)</h4><p>The directory given as <code>--src-dir</code> argument is folded to retrieve the whole directory hierarchy. Then any event appearing in any directory of the hierarchy is monitored.</p><p>There are however avoidance rule to ignore spurious file-system events. For instance, if your favorite editor creates temporary file with a particular extension <code>.bak</code> for any file you edit. Events on theses temporary files must be be ignored:</p><pre><code>opa-watch --src-dir myProject --avoid-ext &quot;.bak&quot;</code></pre><p>You can also use <code>--avoid-prefix</code> pref to ignore file starting with pref and <code>--avoid-dir</code> dir to ignore a subdirectory.Note that all files that are generated (or modified) during the build or test should be listed by an avoidance rule. Otherwise you will go in a auto-building loop.</p><h4>Remark on compilation times</h4><p>Depending on your build system, project recompilation can be slow. To enjoy <code>opa-watch</code>, your build system should only rebuilds what is really necessary to do the Test step.</p><p>Recent versions of <a href="http://opalang.org">Opa</a> supports dependency directed parallel (after v3395) recompilation (no Makefile involved) for structured project (i.e. modularized with package).</p><h3>Please contribute</h3><p><code>opa-watch</code> is very recent work, and is released under MIT license. We plan to ship it with the next <a href="http://opalang.org">Opa</a> release. Future features will probably be on the notification side (for <a href="http://www.gnu.org/software/emacs/">emacs</a> and <a href="http://www.sublimetext.com/">ST2</a>), more complete rules for <a href="http://opalang.org">Opa</a> projects and browser auto-refresh.</p><p><em>External contributions are <a href="https://github.com/OpaOnWindowsNow/opa-watch">welcome</a></em>.</p><p>Btw, this post was written in markdown and converted with pandoc. Left as an exercise to the reader: Adapt <code>opa-watch</code> to pandoc! Select the answer just above to discover it.</p><p><font color="white"> opa-watch --src-dir blog/opa-watch/ --command &quot;pandoc blog.md -o blog.html&quot; --no-launch --avoid-prefix &quot;blog.html&quot; </font></p>
