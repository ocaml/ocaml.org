<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://mirage.io/feed.xml</id><title type="text">mirage</title><updated>2023-06-07T05:45:50-00:00</updated><entry><link href="https://mirage.io/blog/MSA03" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;h2&gt;MirageOS Security Advisory 03 - infinite loop in console output on xen&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Module:       solo5
&lt;/li&gt;
&lt;li&gt;Announced:    2022-12-07
&lt;/li&gt;
&lt;li&gt;Credits:      Krzysztof Burghardt, Pierre Alain, Thomas Leonard, Hannes Mehnert
&lt;/li&gt;
&lt;li&gt;Affects:      solo5 &amp;gt;= 0.6.6 &amp;amp; &amp;lt; 0.7.5,
qubes-mirage-firewall &amp;gt;= 0.8.0 &amp;amp; &amp;lt; 0.8.4
&lt;/li&gt;
&lt;li&gt;Corrected:    2022-12-07: solo5 0.7.5,
2022-12-07: qubes-mirage-firewall 0.8.4
&lt;/li&gt;
&lt;li&gt;CVE:          CVE-2022-46770
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For general information regarding MirageOS Security Advisories,
please visit &lt;a href=&quot;https://mirage.io/security&quot;&gt;https://mirage.io/security&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;MirageOS is a library operating system using cooperative multitasking, which can
be executed as a guest of the Xen hypervisor. Output on the console is performed
via the Xen console protocol.&lt;/p&gt;
&lt;h3&gt;Problem Description&lt;/h3&gt;
&lt;p&gt;Since MirageOS moved from PV mode to PVH, and thus replacing Mini-OS with solo5,
there was an issue in the solo5 code which failed to properly account the
already written bytes on the console. This only occurs if the output to be
performed does not fit in a single output buffer (2048 bytes on Xen).&lt;/p&gt;
&lt;p&gt;The code in question set the number of bytes written to the last written count
(written = output_some(buf)), instead of increasing the written count
(written += output_some(buf)).&lt;/p&gt;
&lt;h3&gt;Impact&lt;/h3&gt;
&lt;p&gt;Console output may lead to an infinite loop, endlessly printing data onto the
console.&lt;/p&gt;
&lt;p&gt;A prominent unikernel is the Qubes MirageOS firewall, which prints some input
packets onto the console. This can lead to a remote denial of service
vulnerability, since any client could send a malformed and sufficiently big
network packet.&lt;/p&gt;
&lt;h3&gt;Workaround&lt;/h3&gt;
&lt;p&gt;No workaround is available.&lt;/p&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;The solution is to fix the console output code in solo5, as done in
https://github.com/Solo5/solo5/pull/538/commits/099be86f0a17a619fcadbb970bb9e511d28d3cd8&lt;/p&gt;
&lt;p&gt;For the qubes-mirage-firewall, update to a solo5 release (0.7.5) which has the
issue fixed. This has been done in the release 0.8.4 of qubes-mirage-firewall.&lt;/p&gt;
&lt;p&gt;The recommended way to upgrade is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;opam update
opam upgrade solo5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Correction details&lt;/h3&gt;
&lt;p&gt;The following PRs were part of the fix:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Solo5/solo5/pull/538&quot;&gt;solo5/pull/538&lt;/a&gt; - xen console: update the &amp;quot;to be written&amp;quot; count
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/qubes-mirage-firewall/pull/167&quot;&gt;qubes-mirage-firewall/pull/167&lt;/a&gt; - update opam repository commit
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Timeline&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2022-12-04: initial report by Krzysztof Burghardt https://github.com/mirage/qubes-mirage-firewall/issues/166
&lt;/li&gt;
&lt;li&gt;2022-12-04: investigation by Hannes Mehnert and Pierre Alain
&lt;/li&gt;
&lt;li&gt;2022-12-05: initial fix by Pierre Alain https://github.com/Solo5/solo5/pull/538
&lt;/li&gt;
&lt;li&gt;2022-12-05: review of fix by Thomas Leonard
&lt;/li&gt;
&lt;li&gt;2022-12-07: release of fixed packages and security advisory
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;You can find the latest version of this advisory online at
&lt;a href=&quot;https://mirage.io/blog/MSA03&quot;&gt;https://mirage.io/blog/MSA03&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This advisory is signed using OpenPGP, you can verify the signature
by downloading our public key from a keyserver (&lt;code&gt;gpg --recv-key 4A732D757C0EDA74&lt;/code&gt;),
downloading the raw markdown source of this advisory from
&lt;a href=&quot;https://raw.githubusercontent.com/mirage/mirage-www/master/tmpl/advisories/03.txt.asc&quot;&gt;GitHub&lt;/a&gt;
and executing &lt;code&gt;gpg --verify 03.txt.asc&lt;/code&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/MSA03</id><title type="text">MirageOS security advisory 03: xen with solo5 &gt;= 0.6.6 &amp; &lt; 0.7.5</title><updated>2022-12-07T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/2022-11-07.retreat" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;After 2.5 years of silent period due to Covid 19, we re-started the MirageOS retreats in early October 2022. This time 15 people gathered in Mirleft (southern Morocco) since it is directly at the sea side, less crowded and stressful than Marrakesh. We had a very nice venue with excellent food and a swimming pool. The group was diverse with the majority from Western Europe, but also attendees from the USA and Nigeria. Some participated for the first time, while others were regular participants. This is great, because it creates a good atmosphere with a shared knowledge of organization, i.e. that we have a daily circle, we do our own dishes, the network setup is run by MirageOS unikernels.&lt;/p&gt;
&lt;p&gt;The journey to Mirleft is slightly longer than to Marrakesh, a large group met a day earlier in Agadir and shared a 2.5 hours Taxi ride 130km south. Another group met in the afternoon in Agadir and did the same trip. There is as well public transport by bus every other day to Marrakesh, which some people took on the way back.&lt;/p&gt;
&lt;p&gt;The great food and local organization was done again by our hosts who are usually in Marrakesh, but who were happy to host us in Mirleft. Big thanks to &lt;a href=&quot;https://www.queenscollective.org/&quot;&gt;the Queens collective&lt;/a&gt;.&lt;/p&gt;
&lt;img src=&quot;https://mirage.io/graphics/mirleft-beach.jpg&quot; alt=&quot;The rough Atlantic ocean in a picture taken from a balcony which the sea visits at high tide.&quot; style=&quot;float:right; padding: 15px&quot;/&gt;
&lt;p&gt;We plan to have again more regular retreats in the future, they will be announced on the &lt;a href=&quot;http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel&quot;&gt;MirageOS developer mailing list&lt;/a&gt;, and likely on the &lt;a href=&quot;https://discuss.ocaml.org/tags/mirageos&quot;&gt;discussion forum&lt;/a&gt;, and on the &lt;a href=&quot;http://retreat.mirage.io&quot;&gt;retreat website&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Network setup&lt;/h3&gt;
&lt;p&gt;Once again we used a 4G modem as uplink. One gigabyte of data was 10 Dirham (roughly one Euro), which we collected when the data volume was close to being exceeded. The 4G connectivity was much better than in Marrakesh, likely due to less congestion on the countryside. An APU (tiny x86 computer from &lt;a href=&quot;https://www.pcengines.ch/apu.htm&quot;&gt;PC Engines APU&lt;/a&gt; with a serial connection) running &lt;a href=&quot;https://freebsd.org&quot;&gt;FreeBSD&lt;/a&gt; was at the heart of our network: the 4G modem was connected via USB, and some TP link access points for wireless connectivity. The routing and network address translation (NAT), which allowed all the laptops and mobile phones to connect to the Internet via the 4G modem was done by the FreeBSD host system (due to lack of a unikernel just doing this, something to prepare for the next event).&lt;/p&gt;
&lt;p&gt;For network address configuration and domain name resolution we used &lt;a href=&quot;https://github.com/roburio/dnsvizor/tree/main/dns-and-dhcp&quot;&gt;DNS Vizor, a MirageOS unikernel&lt;/a&gt; on the FreeBSD system with &lt;a href=&quot;https://github.com/solo5/solo5&quot;&gt;solo5 hvt&lt;/a&gt;. We also deployed two other MirageOS unikernels: a local &lt;a href=&quot;https://github.com/dinosaure/bob&quot;&gt;bob&lt;/a&gt; relay for sharing files, and used a local &lt;a href=&quot;https://hannes.robur.coop/Posts/OpamMirror&quot;&gt;opam mirror&lt;/a&gt; to reduce our bandwidth use.&lt;/p&gt;
&lt;p&gt;While the retreat developed, the DNS resolution was not very stable since the resolver on the 4G modem was sometimes overloaded by lots of requests via a single TCP connection. In the first days we developed &lt;a href=&quot;https://github.com/mirage/ocaml-dns/pull/322&quot;&gt;UDP support for the MirageOS dns-client&lt;/a&gt; and the local connectivity experience greatly improved.&lt;/p&gt;
&lt;h3&gt;Day to day activities&lt;/h3&gt;
&lt;p&gt;Apart from talking to old and new friends face-to-face, which we haven't done for some time, we also worked on various projects to improve the MirageOS ecosystem. Below is a collection of projects that wouldn't come to existance without the retreat. Please excuse if there's some project missing.&lt;/p&gt;
&lt;p&gt;In the day time we discussed various topics, including performance considerations and how to write protocol implementations with GADTs. Next to that people were going to the beach, while others were pairing up for some projects or reading code together. Others worked alone on finishing some code, but whenever a question of another library appeared, it was easy to approach the original author or someone who has used that library extensively and discuss some questions. In the evenings we had some impromptu talks about various topics, such as the opam repository CI, Lwt do's and dont's, BGP, monitoring, Raspberry pi PWM.&lt;/p&gt;
&lt;p&gt;One afternoon we did a long &lt;a href=&quot;https://dragondreaming.org/&quot;&gt;dragon dreaming&lt;/a&gt; session to figure out the ideas and dreams for the future of MirageOS. Apart from bare-metal and MirageOS as hypervisor, we also dreamed about running your own digital infrastructure with MirageOS (with increased decentralization and security). Another afternoon we had a cocktail party at the pool.&lt;/p&gt;
&lt;p&gt;Some participants already wrote articles about their journey and activities, take a look at their writings: &lt;a href=&quot;https://raphael-proust.gitlab.io/code/mirage-retreat-2022-10.html&quot;&gt;Rapha&amp;euml;l Proust&lt;/a&gt;, &lt;a href=&quot;https://tarides.com/blog/2022-10-28-the-mirageos-retreat-a-journey-of-food-cats-and-unikernels&quot;&gt;Jules, Sayo, Enguerrand, Sonja, Jan, Lucas&lt;/a&gt;, &lt;a href=&quot;http://blog.enssat.fr/2022/10/pierre-alain-enssat-teacher-at-11th.html&quot;&gt;Pierre&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;OCaml 5 support&lt;/h4&gt;
&lt;p&gt;OCaml 5 will soon be published, which has most of the runtime code being rewritten. The runtime also has many more dependencies. We worked on getting &lt;a href=&quot;https://github.com/mirage/ocaml-solo5/&quot;&gt;ocaml-solo5&lt;/a&gt; (the piece consisting of a math library, a C library, and the OCaml compiler for MirageOS unikernels) to use &lt;a href=&quot;https://github.com/mirage/ocaml-solo5/pull/122&quot;&gt;OCaml 5&lt;/a&gt;. This is still work in progress, but already lead to &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/11605&quot;&gt;some&lt;/a&gt; &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/11606&quot;&gt;upstream&lt;/a&gt; &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/11611&quot;&gt;PRs&lt;/a&gt; that are merged into the 5 branch as well.&lt;/p&gt;
&lt;h4&gt;A Verified File System for MirageOS&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mit-pdos/fscq&quot;&gt;FSCQ&lt;/a&gt; is a formally verified file system developed in the Coq proof assistant. So far MirageOS has a variety of read/write file systems: &lt;a href=&quot;https://github.com/yomimono/chamelon/&quot;&gt;chamelon&lt;/a&gt; (LittleFS) &lt;a href=&quot;https://github.com/mirage/ocaml-tar/&quot;&gt;tar&lt;/a&gt; (append-only), &lt;a href=&quot;https://github.com/mirage/ocaml-fat/&quot;&gt;fat&lt;/a&gt; (FAT16 with its limitations), and &lt;a href=&quot;https://github.com/reynir/oneffs&quot;&gt;one file FS&lt;/a&gt; (supporting only one file). We wanted to add FSCQ to the list, by making it usable from MirageOS (currently it compiles to Haskell code).&lt;/p&gt;
&lt;p&gt;At the retreat, we &lt;a href=&quot;https://github.com/mit-pdos/fscq/pull/17&quot;&gt;first repaired some FSCQ proofs&lt;/a&gt; to work with recent Coq releases, and then added &lt;a href=&quot;https://github.com/mit-pdos/fscq/pull/18&quot;&gt;OCaml wrapper code and revised the OCaml extraction&lt;/a&gt;. The current state is that the most obvious bugs have been fixed, the filesystem is usable from FUSE and underwent basic testing, but performance needs to be improved. FSCQ was developed with lazyness in mind targeting Haskell; for instance, it uses lots of lists in a way that does not go well with OCaml's strict evaluation. The progress is tracked in &lt;a href=&quot;https://github.com/mit-pdos/fscq/issues/16&quot;&gt;this issue&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Uint128&lt;/h4&gt;
&lt;p&gt;A &lt;a href=&quot;https://github.com/mirage/ocaml-ipaddr/issues/16&quot;&gt;long-standing issue&lt;/a&gt; in our IP address library is to use a different memory presentation for IPv6 addresses. As foundation we developed a &lt;a href=&quot;https://github.com/verbosemode/ocaml-uintb128&quot;&gt;uintb128&lt;/a&gt; package.&lt;/p&gt;
&lt;h4&gt;Qubes firewall&lt;/h4&gt;
&lt;p&gt;Originally developed in 2016, over the last months we revived the &lt;a href=&quot;https://www.qubes-os.org/&quot;&gt;QubesOS&lt;/a&gt; (an OS that executes applications each in a separate virtual machine for improved security) &lt;a href=&quot;https://github.com/mirage/qubes-mirage-firewall/&quot;&gt;MirageOS firewall&lt;/a&gt; and removed mutable state and improved performance. Read more &lt;a href=&quot;http://blog.enssat.fr/2022/10/pierre-alain-enssat-teacher-at-11th.html&quot;&gt;in Pierre's article&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Music bare-metal on Raspberry Pi 4&lt;/h4&gt;
&lt;p&gt;Based on &lt;a href=&quot;https://github.com/dinosaure/gilbraltar&quot;&gt;gilbraltar&lt;/a&gt; (which &lt;a href=&quot;https://github.com/dinosaure/gilbraltar/pull/21&quot;&gt;now works with newer gcc versions&lt;/a&gt;), a &lt;a href=&quot;https://github.com/pitag-ha/rpi/blob/jack-port-driver-on-interrupts/src/peripherals/pwm.ml&quot;&gt;jack port driver&lt;/a&gt; was developed. With &lt;a href=&quot;https://github.com/pitag-ha/rpi/blob/jack-port-driver-on-interrupts/test/bare-metal/jack_port/main.ml&quot;&gt;this program&lt;/a&gt; we now listen to music with MirageOS all day and night. Read &lt;a href=&quot;https://tarides.com/blog/2022-10-28-the-mirageos-retreat-a-journey-of-food-cats-and-unikernels#implementing-a-jack-port-driver-or-how-to-make-a-unikernel-sing-bare-metal&quot;&gt;further in Tarides blog&lt;/a&gt; We also &lt;a href=&quot;https://www.youtube.com/playlist?list=PLmaiK3-DyqMy3kNjdHIPUEo-Gkltha3mT&quot;&gt;made some music and recorded an EP&lt;/a&gt;, read &lt;a href=&quot;https://tarides.com/blog/2022-10-28-the-mirageos-retreat-a-journey-of-food-cats-and-unikernels#inventing-ocamlwave-serenading-cats-and-christening-dogs&quot;&gt;further in Tarides blog&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;HTTP client for MirageOS&lt;/h4&gt;
&lt;p&gt;The earlier mentioned opam mirror contained a HTTP client (using HTTP/AF and H2, supporting both HTTP1 and HTTP2 and also IPv4 and IPv6) to download archives - and we had similar code in other projects. That's why we decided to &lt;a href=&quot;https://github.com/roburio/http-mirage-client&quot;&gt;create the http-mirage-client opam package&lt;/a&gt; to reuse that code.&lt;/p&gt;
&lt;h4&gt;DNS resolver with filtering advertisement&lt;/h4&gt;
&lt;p&gt;This package is already picked up and used by &lt;a href=&quot;https://github.com/jmid/mirage-hole&quot;&gt;Mirage Hole&lt;/a&gt;, a DNS stub resolver that filters advertisement domains (based on a domain lists downloaded via HTTP using the above HTTP client), which was developed from scratch in Mirleft. Read &lt;a href=&quot;https://tarides.com/blog/2022-10-28-the-mirageos-retreat-a-journey-of-food-cats-and-unikernels#miragehole---a-unikernel-dns-resolver-with-holes&quot;&gt;further in Tarides blog&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Albatross meets NixOS&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/roburio/albatross&quot;&gt;Albatross&lt;/a&gt; is an orchestration system for MirageOS unikernels using solo5 (spt or hvt). Apart from console output, statistics, and resource policies, it supports remote management using TLS. Now albatross &lt;a href=&quot;https://github.com/roburio/albatross/pull/120&quot;&gt;supports NixOS&lt;/a&gt; and there is a &lt;a href=&quot;https://github.com/Julow/albatross-nixos-example&quot;&gt;tutorial&lt;/a&gt; how to set it up. Read &lt;a href=&quot;https://tarides.com/blog/2022-10-28-the-mirageos-retreat-a-journey-of-food-cats-and-unikernels#deploying-albatross-on-nixos-no-more-iptables-debugging&quot;&gt;further in Tarides blog&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Memory leaks&lt;/h4&gt;
&lt;p&gt;We chased some memory leaks on this website, using &lt;a href=&quot;https://grafana.com/&quot;&gt;Grafana&lt;/a&gt; and &lt;a href=&quot;https://github.com/roburio/mirage-monitoring&quot;&gt;mirage-monitoring&lt;/a&gt;. This lead to a &lt;a href=&quot;https://github.com/dinosaure/paf-le-chien/pull/72&quot;&gt;PR in paf&lt;/a&gt;. We are still investigating another &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/issues/499&quot;&gt;memory issue&lt;/a&gt;. Read &lt;a href=&quot;https://tarides.com/blog/2022-10-28-the-mirageos-retreat-a-journey-of-food-cats-and-unikernels#monitoring-mirageio-and-chasing-memory-leaks&quot;&gt;further details in Tarides blog&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Opam cache&lt;/h4&gt;
&lt;p&gt;Apart from the &lt;a href=&quot;https://hannes.robur.coop/Posts/OpamMirror&quot;&gt;opam mirror&lt;/a&gt;, sometimes only the caching part is very useful, especially since the git interaction is quite expensive for the network and CPU. We developed a &lt;a href=&quot;https://git.robur.io/robur/opam-mirror/src/branch/cache&quot;&gt;cache-only version&lt;/a&gt; in a branch.&lt;/p&gt;
&lt;h4&gt;Fixing the DNS resolver in the mirage tool&lt;/h4&gt;
&lt;p&gt;The default DNS resolver in MirageOS is &lt;a href=&quot;https://uncensoreddns.org/&quot;&gt;uncensoreddns&lt;/a&gt;, which discontinued plaintext DNS requests and replies, and instead supports DNS-over-TLS. We fixed our code to &lt;a href=&quot;https://github.com/mirage/ocaml-conduit/pull/415&quot;&gt;delay parsing of nameservers&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirage/mirage/pull/1362&quot;&gt;update the mirage tool&lt;/a&gt;. Now, with the release 4.3.1, name resolution with conduit's resolver works fine again.&lt;/p&gt;
&lt;h4&gt;Caqti and pgx&lt;/h4&gt;
&lt;p&gt;We conducted some work on integrating the pure OCaml PostgreSQL client &lt;a href=&quot;https://github.com/arenadotio/pgx/&quot;&gt;pgx&lt;/a&gt; with &lt;a href=&quot;https://github.com/paurkedal/ocaml-caqti/&quot;&gt;caqti&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Lwt&lt;/h4&gt;
&lt;p&gt;Quite some discussion was for how to use exceptions in lwt, leading to a proposed PR &lt;a href=&quot;https://github.com/ocsigen/lwt/pull/964&quot;&gt;not to capture out of memory and stack overflow exceptions&lt;/a&gt;, and &lt;a href=&quot;https://github.com/ocsigen/lwt/pull/963&quot;&gt;export reraise&lt;/a&gt;. Read &lt;a href=&quot;https://raphael-proust.gitlab.io/code/mirage-retreat-2022-10.html&quot;&gt;further in Rapha&amp;euml;l's blog&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Tarides Map&lt;/h4&gt;
&lt;p&gt;A map showing the geographic distribution of Tarides collaborators was developed as a unikernel, see the &lt;a href=&quot;https://github.com/SaySayo/tarides_map_static_website&quot;&gt;code&lt;/a&gt;. Read &lt;a href=&quot;https://tarides.com/blog/2022-10-28-the-mirageos-retreat-a-journey-of-food-cats-and-unikernels#tarides-map---serving-the-tarides-geographical-distribution-in-a-unikernel&quot;&gt;further in Tarides blog article&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Slack bot&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/pitag-ha/slack_bot&quot;&gt;coffee chat bot&lt;/a&gt; earlier worked as an executable on Unix, now it can be executed as a MirageOS unikernel. Read &lt;a href=&quot;https://tarides.com/blog/2022-10-28-the-mirageos-retreat-a-journey-of-food-cats-and-unikernels#coffee-chat-bot-a-friendly-unikernel-for-a-friendly-work-environment&quot;&gt;further in Tarides blog article&lt;/a&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/2022-11-07.retreat</id><title type="text">MirageOS retreat in October</title><updated>2022-11-07T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/2022-04-08.robur" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;At &lt;a href=&quot;https://robur.coop&quot;&gt;Robur&lt;/a&gt;, we have created many unikernels and services over the years using MirageOS, like &lt;a href=&quot;https://builds.robur.coop/job/openvpn-router/&quot;&gt;OpenVPN&lt;/a&gt;, &lt;a href=&quot;https://builds.robur.coop/job/caldav/&quot;&gt;CalDAV&lt;/a&gt;, a &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;&lt;em&gt;Let&amp;rsquo;s Encrypt&lt;/em&gt;&lt;/a&gt; &lt;a href=&quot;https://builds.robur.coop/job/dns-letsencrypt/&quot;&gt;solver using DNS&lt;/a&gt;, &lt;a href=&quot;https://builds.robur.coop/job/dns-resolver/&quot;&gt;DNS Resolver&lt;/a&gt;, authoritative &lt;a href=&quot;https://builds.robur.coop/job/dns-primary-git/&quot;&gt;DNS servers storing in a Git remote&lt;/a&gt;, and other &lt;a href=&quot;https://builds.robur.coop/&quot;&gt;reproducible binaries for deployment&lt;/a&gt;. We chose OCaml because of its advanced security, compiler speed, and automated memory management. Read more about how Robur benefits from OCaml and MirageOS &lt;a href=&quot;https://robur.coop/Our%20Work/Technology-Employed#OCaml&quot;&gt;on our website&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Most recently, we worked on &lt;a href=&quot;https://mirage.io/blog/deploying-mirageos-robur&quot;&gt;producing and deploying binary unikernels&lt;/a&gt;, funded by the European Union under the &lt;a href=&quot;https://pointer.ngi.eu&quot;&gt;NGI Pointer&lt;/a&gt; programme.&lt;/p&gt;
&lt;h3&gt;OpenVPN&lt;/h3&gt;
&lt;p&gt;Robur started the development of &lt;a href=&quot;https://openvpn.net/&quot;&gt;OpenVPN&lt;/a&gt;, a virtual private network protocol, in OCaml in 2019. The original C implementation served as documentation of the protocol. We developed it in OCaml using existing libraries (cryptographic operations, networking, NAT) and parsers (for the configuration file &lt;a href=&quot;https://github.com/inhabitedtype/angstromg&quot;&gt;angstrom&lt;/a&gt;, for the binary packets &lt;a href=&quot;https://github.com/mirage/ocaml-cstruct&quot;&gt;cstruct&lt;/a&gt;). We re-use the same configuration file format as the C implementation (but do not yet support all extensions), so the MirageOS unikernels can be used as drop-in replacements. OCaml improved the project by enhancing security and minimising our codebase.&lt;/p&gt;
&lt;p&gt;We created OpenVPN as a MirageOS unikernel to forward all traffic to a single IP address or local network NAT through the OpenVPN tunnel. To increase security even further, we designed a fail-safe that dropped all packets (rather than sending them unencrypted) when the OpenVPN tunnel was down.&lt;/p&gt;
&lt;p&gt;This project was funded by &lt;a href=&quot;https://prototypefund.de&quot;&gt;Prototype Fund&lt;/a&gt; in 2019. The &lt;a href=&quot;https://github.com/roburio/openvpn&quot;&gt;code is available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;CalDAV&lt;/h3&gt;
&lt;p&gt;Robur started the CalDAV project back in 2017 with a grant from the &lt;a href=&quot;https://prototypefund.de&quot;&gt;Prototype Fund&lt;/a&gt;, which came with the stipulation that it had to be created within six months! Thus the first version of CalDAV emerged from those efforts. Afterward, &lt;a href=&quot;https://tarides.com&quot;&gt;Tarides&lt;/a&gt; sponsored Robur so we could continue CalDAV&amp;rsquo;s development and draft an inital CardDAV implementation, resulting in the version now available.&lt;/p&gt;
&lt;p&gt;As you might&amp;rsquo;ve guessed from the name, CalDAV is a protocol to synchronise calendars, and it works on a robust server that&amp;rsquo;s relatively easy to configure and maintain. This enables more people to run our own digital infrastructure rather than rely on an outside source. Robur&amp;rsquo;s CalDAV provides considerable security, due to its minimal codebase, and stores its data on Git for version control. We even set up a live &lt;em&gt;test server&lt;/em&gt; at &lt;a href=&quot;https://calendar.robur.coop&quot;&gt;calendar.robur.coop&lt;/a&gt; that contains the &lt;a href=&quot;https://inf-it.com/open-source/clients/caldavzap/&quot;&gt;CalDavZAP user interface&lt;/a&gt;, accessible with any username and password.&lt;/p&gt;
&lt;p&gt;CalDAV also comes with some client control with its ability to be tracked and reverted, so you can remove entries from undesirable behavior. Plus, it can be exported and converted to/from other formats!&lt;/p&gt;
&lt;p&gt;Robur&amp;rsquo;s tests of the basic tasks for maintaining a digital calendar, like adding or modifying an event, have all successfully passed with several different CalDAV clients, but we hope to develop CalDAV further by adding notifications on updates via email and integrating an address book. If you&amp;rsquo;re interested in donating or investing in CalDAV, please contact us through &lt;a href=&quot;https://robur.coop/&quot;&gt;our website&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The code for &lt;a href=&quot;https://github.com/roburio/caldav&quot;&gt;CalDAV&lt;/a&gt; is also released to &lt;code&gt;opam-repository&lt;/code&gt;; the code for &lt;a href=&quot;https://git.robur.io/linse/carddav&quot;&gt;CardDAV&lt;/a&gt; is not yet integrated nor released.&lt;/p&gt;
&lt;h3&gt;DNS Projects&lt;/h3&gt;
&lt;p&gt;Robur engineers have created robust DNS Projects, like our &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;&amp;lsquo;Let&amp;rsquo;s Encrypt&amp;rsquo;&lt;/a&gt;-Certified &lt;a href=&quot;https://builds.robur.coop/job/dns-letsencrypt/&quot;&gt;DNS Solver&lt;/a&gt;, a &lt;a href=&quot;https://builds.robur.coop/job/dns-resolver/&quot;&gt;DNS Resolver&lt;/a&gt;, and an authoritative &lt;a href=&quot;https://builds.robur.coop/job/dns-primary-git/&quot;&gt;DNS Server&lt;/a&gt;. As a refresher, users navigate the Internet using domain names (addresses in cyberspace), and DNS stands for Domain Name System. These systems take the domain name (something easy to remember, like robur.coop), and reroute them to the IP address (not easily remembered, like 193.30.40.138). The term &lt;em&gt;IP address&lt;/em&gt; is short for Internet Protocol address, and its numbers point to a specific server, city, state/region, postal code, etc. In other words, it&amp;rsquo;s the actual machine&amp;rsquo;s address. These IP addresses take users to the website's files, and they&amp;rsquo;re what enable you to send and receive emails, too. DNS stores all these key values (with caching) in a decentralised hierarchy, making it fault-tolerant to minimise problems.&lt;/p&gt;
&lt;p&gt;Robur&amp;rsquo;s authoritative DNS server delegates responsibility for a specific domain and provides mapping information for it, ensuring that the user gets to the correct IP address. At the other end of the process, Robur&amp;rsquo;s DNS resolver finds the exact server to handle the user&amp;rsquo;s request. To keep the codebase minimal for security and simplicity, we included only the elements absolutely necessary. The 'Let's Encrypt' unikernel waits for certificate requests in the zones (encoded as TLSA records), and uses a 'Let's Encrypt' DNS challenge to have these signed to certificates, again stored in the zones. Of course, certificates expiring soon will be updated by &lt;code&gt;dns-letsencrypt-secondary&lt;/code&gt;. This unikernel does not need any persistent storage, as it leaves this to the &lt;code&gt;dns-primary-git&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ve been developing these DNS projects since 2017, and they serve a multitude of functions in the Robur ecosystem. Our domains (like nqsb.io and robur.coop) use our DNS server as an authoritative server, and we also use a caching resolver for our biannual &lt;a href=&quot;http://retreat.mirage.io&quot;&gt;MirageOS retreats&lt;/a&gt; in Marrakech. Additionally, any MirageOS unikernel can use our client to resolve domain names - using the dns-client devices, or &lt;a href=&quot;https://github.com/roburio/happy-eyeballs&quot;&gt;&lt;code&gt;happy-eyeballs&lt;/code&gt;&lt;/a&gt;, so it&amp;rsquo;s also beneficial to the OCaml community at large. Robur uses expressive OCaml types (GADT), so we can ensure a given query has a specific shape, like an address record query results in a set of IPv4 addresses.&lt;/p&gt;
&lt;p&gt;Robur's DNS implementation can process extensions like dynamic updates, notifications, zone transfers, and request authentications. It can be installed through opam, as all OCaml tools and libraries. You can find our DNS code&amp;rsquo;s &lt;a href=&quot;https://github.com/mirage/ocaml-dns&quot;&gt;library&lt;/a&gt; and unikernels (&lt;a href=&quot;https://github.com/roburio/dns-primary-git&quot;&gt;&lt;code&gt;dns-primary-git&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://github.com/roburio/dns-secondary&quot;&gt;&lt;code&gt;dns-secondary&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://github.com/roburio/dns-letsencrypt-secondary&quot;&gt;&lt;code&gt;dns-letsencrypt&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://git.robur.io/robur/dns-resolver&quot;&gt;&lt;code&gt;dns-resolver&lt;/code&gt;&lt;/a&gt;) on GitHub.&lt;/p&gt;
&lt;p&gt;Read further posts on &lt;a href=&quot;https://hannes.robur.coop/Posts/DNS&quot;&gt;DNS from 2018&lt;/a&gt;, &lt;a href=&quot;https://hannes.robur.coop/Posts/Summer2019&quot;&gt;DNS and CalDAV from 2019&lt;/a&gt;, &lt;a href=&quot;https://hannes.robur.coop/Posts/DnsServer&quot;&gt;deploying authoritative DNS servers as unikernels (2019)&lt;/a&gt;, &lt;a href=&quot;https://hannes.robur.coop/Posts/ReproducibleOPAM&quot;&gt;reproducible builds (2019)&lt;/a&gt;, &lt;a href=&quot;https://hannes.robur.coop/Posts/VMM&quot;&gt;albatross (2017)&lt;/a&gt;, &lt;a href=&quot;https://hannes.robur.coop/Posts/Deploy&quot;&gt;deployment (2021)&lt;/a&gt;,
&lt;a href=&quot;https://reynir.dk/posts/2022-03-08-builder-web.html&quot;&gt;builder-web (2022)&lt;/a&gt;, &lt;a href=&quot;https://r7p5.earth/blog/2022-3-7/Builder-web%20visualizations%20at%20Robur&quot;&gt;visualizations (2022)&lt;/a&gt;, and &lt;a href=&quot;https://hannes.robur.coop/Posts/Monitoring&quot;&gt;monitoring (2022)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are interested in supporting or learning more about Robur&amp;rsquo;s work, please get in touch with us at &lt;a href=&quot;https://robur.coop/Contact&quot;&gt;robur.coop&lt;/a&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/2022-04-08.robur</id><title type="text">MirageOS Unikernels at Robur</title><updated>2022-04-08T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/2022-04-06.vpnkit" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;a href=&quot;https://www.docker.com/blog/how-docker-desktop-networking-works-under-the-hood/&quot;&gt;Recently, I posted&lt;/a&gt; about how &lt;a href=&quot;https://github.com/moby/vpnkit&quot;&gt;vpnkit&lt;/a&gt;, built with MirageOS libraries, powers &lt;a href=&quot;https://www.docker.com/products/docker-desktop&quot;&gt;Docker Desktop&lt;/a&gt;. Docker Desktop enables users to build, share and run isolated, &lt;em&gt;containerised&lt;/em&gt; applications on either a Mac or Windows environment.
With &lt;a href=&quot;https://www.docker.com/blog/docker-raises-series-c-build-share-run/&quot;&gt;millions of users&lt;/a&gt;, it's the most popular developer tool
on the planet. Hence, &lt;strong&gt;MirageOS networking libraries transparently handle the traffic of millions of containers&lt;/strong&gt;, simplifying many developers' experience every day.&lt;/p&gt;
&lt;p&gt;Docker initially started as an easy-to-use packaging of the Linux kernel's isolation primitives, such as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux_namespaces&quot;&gt;namespaces&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Cgroups&quot;&gt;cgroups&lt;/a&gt;.
Docker made it convenient for developers to encapsulate applications inside containers, protecting the rest of the system from potential bugs, moving them more easily between machines, and sharing them with other developers. Unfortunately, one of the challenges of running Docker on macOS or Windows is that these Linux primitives are unavailable. Docker Desktop goes to great lengths to emulate them without modifying the user experience of running containers. It runs a (light) Linux VM to host the Docker daemon with additional &amp;quot;glue&amp;quot; helpers to connect the Docker client, running on the host, to that VM. While the Linux VM can run Linux
containers, there is often a problem accessing internal company resources. VPN clients are usually configured to allow only
&amp;quot;local&amp;quot; traffic from the host, to prevent the host accidentally routing traffic from the Internet to the internal network, compromising network security. Unfortunately network packets from the Linux VM need to be routed, and so are dropped by default. This
would prevent Linux containers from being able to access resources like internal company registries.&lt;/p&gt;
&lt;p&gt;Vpnkit bridges that gap and circumvents these issues by reversing the MirageOS network stack. It reads raw ethernet frames coming out of the Linux VM and translates them into macOS or Windows high-level (socket) syscalls: it keeps the connection states for every running Docker container in the Linux VMs and converts all their network traffic transparently into host traffic. This is possible because the MirageOS stack is highly modular, feature-rich and very flexible with full implementations of:
an &lt;a href=&quot;https://github.com/mirage/ethernet&quot;&gt;ethernet layer&lt;/a&gt;,
&lt;a href=&quot;https://github.com/mirage/mirage-vnetif&quot;&gt;ethernet switching&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/mirage/mirage-tcpip&quot;&gt;TCP/IP stack&lt;/a&gt;,
&lt;a href=&quot;https://github.com/mirage/ocaml-dns&quot;&gt;DNS&lt;/a&gt;,
&lt;a href=&quot;https://github.com/mirage/charrua&quot;&gt;DHCP&lt;/a&gt;,
&lt;a href=&quot;https://github.com/mirage/ocaml-cohttp&quot;&gt;HTTP&lt;/a&gt; etc. The following diagram shows how the Mirage components are connected together:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mirage.io/img/blog-VPNKit.png&quot; alt=&quot;Image showing the modular structure of vpnkit&quot;/&gt;&lt;/p&gt;
&lt;p&gt;For a more detailed explanation on how vpnkit works with Docker Desktop, read &amp;ldquo;&lt;a href=&quot;https://www.docker.com/blog/how-docker-desktop-networking-works-under-the-hood/&quot;&gt;How Docker Desktop Networking Works Under the Hood&lt;/a&gt;.&amp;rdquo;&lt;/p&gt;

      </content><id>https://mirage.io/blog/2022-04-06.vpnkit</id><title type="text">How MirageOS Powers Docker Desktop</title><updated>2022-04-06T00:00:00-00:00</updated><author><name>Dave Scott</name></author></entry><entry><link href="https://mirage.io/blog/2022-04-04.QuebesFirewall" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;My first experience with the Mirage ecosystem was using &lt;code&gt;qubes-mirage-firewall&lt;/code&gt; as a way to decrease resource usage for an internal system task. Just before the release of MirageOS 3.9, I participated in testing PVH-mode unikernels with Solo5. I found it interesting with very constructive exchanges and high-quality speakers (@mato, @talex5, @hannesm) to correct some minor bugs.&lt;/p&gt;
&lt;h3&gt;Observations and an Issue Rises&lt;/h3&gt;
&lt;p&gt;After the release of Mirage 3.9 and the ability to launch unikernels in PVH-mode with Solo5, my real adventure with Mirage started when I noticed a drop in the bandwidth performance compared to the Linux firewall in &lt;a href=&quot;https://github.com/mirage/qubes-mirage-firewall/issues/120&quot;&gt;Qubes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The explanation was quickly found: each time a network packet was received, the firewall performed a memory statistic call to decide whether it needed to trigger the garbage collector. The idea behind this was simply to perform the collection steps before running out of memory.&lt;/p&gt;
&lt;p&gt;With the previous system (Mini-OS), the amount of free memory was directly accessible; however, with Solo5, the &lt;code&gt;nolibc&lt;/code&gt; implementation used the &lt;code&gt;dlmalloc&lt;/code&gt; library to manage allocations in the heap. The interface that showed the fraction of occupied memory (&lt;code&gt;mallinfo()&lt;/code&gt;) had to loop over the whole heap to count the used and unused areas. This scan is time-linear with the heap size; therefore it took time to make the operation visible when it was performed (in &lt;code&gt;qubes-mirage-firewall&lt;/code&gt;) for each packet.&lt;/p&gt;
&lt;p&gt;The first proposed solution was to use a less accurate &lt;code&gt;dlmalloc&lt;/code&gt; call &lt;a href=&quot;https://github.com/mirage/qubes-mirage-firewall/pull/116#issuecomment-704827905&quot;&gt;footprint()&lt;/a&gt; which could overestimate the memory usage. This solution had the advantage to be low-cost and increase the bandwitdh performance. However, this overestimation is currently strictly increasing. Without going into details, &lt;code&gt;footprint()&lt;/code&gt; gives the amount of memory obtained from the system, which corresponds approximately to the top of the heap. It is possible to give back the top of the heap to Solo5 by calling &lt;code&gt;trim()&lt;/code&gt;, which is, sadly, currently not available in the OCaml environment, thus the top of the heap increases. After a while, the amount of free memory falls below a threshold, and our firewall spends its time writing log messages warning about the lack of memory, but it never can solve the problem. The first clue suggested that this was due to a memory leak.&lt;/p&gt;
&lt;h3&gt;Several Avenues to Explore&lt;/h3&gt;
&lt;p&gt;As a computer science degree teacher, I can sometimes propose internship topics to students, so I challenged one student to think about this memory leak problem. We tried:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;to understand how to trigger the memory leak problem in a consistent way. Unfortunately it was an erratic behavior which made the analysis of the situation complex.
&lt;/li&gt;
&lt;li&gt;to replace &lt;code&gt;dlmalloc&lt;/code&gt; by a simpler allocator written from scratch from binary buddy in Knut's TAOCP. The problem with this attempt was the large allocator overhead, as it takes almost 10MB of data structure to manage 32MB of memory.
&lt;/li&gt;
&lt;li&gt;to keep &lt;code&gt;dlmalloc&lt;/code&gt; and count the allocations, releases, reallocations, etc., the hard way with requests to keep the total amount of memory allocated for the unikernel in a simple C variable, like what existed in Mini-OS.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This latest solution looks promising at the beginning of this year, and we're now able to have an estimate of the occupied memory, which goes up and down with the allocations and the garbage collector calls (&lt;a href=&quot;https://github.com/mirage/qubes-mirage-firewall/issues/120#issuecomment-1006642747&quot;&gt;link&lt;/a&gt;). Bravo Julien! It still remains to test and produce the PR to finally close this Issue.&lt;/p&gt;
&lt;h3&gt;Sharing Files as a Side Project&lt;/h3&gt;
&lt;p&gt;In parallel to this first experience with MirageOS, and for which I had not practiced OCaml at all, I began developing with MirageOS by writing a tool for my personal usage!&lt;/p&gt;
&lt;p&gt;Before telling you about it, I have to add some context: it's easy to have one or more encrypted partitions mountable on the fly with &lt;code&gt;autofs&lt;/code&gt;, but I haven't managed to have an encrypted folder that can behave as such an encrypted partition.&lt;/p&gt;
&lt;p&gt;In January 2021, the Mirage ecosystem got a library that permits unikernels to communicate using the SSH protocol : Aw&amp;aacute;-ssh. The server part hadn't been updated since the first version, so I was able to start soaking up by updating this part.&lt;/p&gt;
&lt;p&gt;As a developer, I use SSHFS very regularly to mount a remote folder from a server to access and drop&amp;mdash;in short, to manipulate files. The good thing is that with my need to have an encrypted folder and the ability to respond in a unikernel to an incoming SSH connection, I was able to capitalize on this work on Aw&amp;aacute;-ssh server to add the management of an SSHFS mount.&lt;/p&gt;
&lt;p&gt;The first work was to follow the SSHFS RFC to handle the SSHFS protocol. Thanks again @hannesm for the help on adapting the aw&amp;aacute;-unix code to have an aw&amp;aacute;-mirage module!&lt;/p&gt;
&lt;p&gt;Quickly I needed a real file system for my tests. With luck, Mirage offers a file system! Certainly basic, but sufficient for my tests, the venerable FAT16!&lt;/p&gt;
&lt;p&gt;With this file system onboard, I was able to complete writing the unikernel, and now I'm able to easily share files (small files, as the FAT16 system doesn't help here) on my local network, thanks to the UNIX version of the unikernel. The great thing about MirageOS is that I'm also able to do it by running the unikernel as a virtual machine without changing the code, just by changing the target at compile time!&lt;/p&gt;
&lt;p&gt;However, I still have a lots of work to do to reach my initial goal of being able to build an encrypted folder on Linux (a side project will probably always take long to complete), I need to:
- add an encryption library for a disk block
- add a real file system with the features of a modern system like btrfs&lt;/p&gt;
&lt;p&gt;To answer the first point, and as the abstraction is a strong feature of MirageOS, it is very feasible to change the physical access to the file system in a transparent way. Concerning the second point there are already potential candidates to look at!&lt;/p&gt;
&lt;h3&gt;MirageOS 4&lt;/h3&gt;
&lt;p&gt;With the recent release of MirageOS 4, I truly appreciate the new build system that allows fast code iterations through all used dependencies. It considerably helped me fix a runtime issue on Xen and post a PR! Thanks to the whole team for their hard work, and it was a really nice hacking experience! The friendliness and helpfulness of the community is really a plus for this project, so I can't encourage people enough to try writing unikernels for their own needs. You'll get full help and advice from this vibrant community!&lt;/p&gt;

      </content><id>https://mirage.io/blog/2022-04-04.QuebesFirewall</id><title type="text">OS as a Development Environment: A Journey of Discovery</title><updated>2022-04-04T00:00:00-00:00</updated><author><name>Pierre Alain</name></author></entry><entry><link href="https://mirage.io/blog/2022-04-01-Mr-MIME" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;The security of communications poses a seemingly never-ending challenge across Cyberspace. From sorting through mountains of spam to protecting our private messages from malicious hackers, cybersecurity has never been more important than it is today. It takes considerable technical skills and dependable infrastructure to run an email service, and sadly, most companies with the ability to handle the billions of emails sent daily make money off mining your sensitive data.&lt;/p&gt;
&lt;p&gt;Five years ago, we started to explore an incredible endeavour on how to securely send and receive email. It was my final year in an internship at Cambridge, and the goal was to develop an OCaml library that could &lt;em&gt;parse&lt;/em&gt; and &lt;em&gt;craft&lt;/em&gt; emails. Thus, Mr. MIME was born. I even gave a &lt;a href=&quot;https://www.youtube.com/watch?v=kQkRsNEo25k&quot;&gt;presentation on it at ICFP 2016&lt;/a&gt; and introduced Mr. MIME in a &lt;a href=&quot;https://tarides.com/blog/2019-09-25-mr-mime-parse-and-generate-emails&quot;&gt;previous post&lt;/a&gt;. Mr. MIME was also selected by the [NGI DAPSI initiative]((https://tarides.com/blog/2022-03-08-secure-virtual-messages-in-a-bottle-with-scop) last year.&lt;/p&gt;
&lt;p&gt;I'm thrilled to shine a spotlight on Mr. MIME as part of the &lt;a href=&quot;https://mirage.io/blog/announcing-mirage-40&quot;&gt;MirageOS 4 release&lt;/a&gt;! It was essential to create several small libraries when building and testing Mr. MIME. I've included some samples of how to use Mr. MIME to parse and serialise emails in OCaml, as well as receiving and sending SMTP messages. I then explain how to use all of this via CLI tools. Since &lt;em&gt;unikernels&lt;/em&gt; were the foundation on which I built Mr. MIME, the final section explains how to deploy unikernels to handle email traffic.&lt;/p&gt;
&lt;h2&gt;A Tour of the Many Email Libraries&lt;/h2&gt;
&lt;p&gt;The following libraries were created to support Mr. MIME:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pecu&lt;/code&gt; as the &lt;code&gt;quoted-printable&lt;/code&gt; serialiser/deserialiser.
First, if we strictly consider standards, email transmission can use a 7-bit channel, so we made different encodings in order to safely transmit 8-bit contents &lt;em&gt;via&lt;/em&gt; such channels. &lt;code&gt;quoted-printable&lt;/code&gt; is one of them, where any non-ASCII characters are encoded.&lt;/p&gt;
&lt;p&gt;Another encoding is the &lt;em&gt;famous&lt;/em&gt; UTF-7 (the one from &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc2152&quot;&gt;RFC2152&lt;/a&gt;, not the one from &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc2060#section-5.1.3&quot;&gt;RFC2060.5.1.3&lt;/a&gt;), which is available in the &lt;code&gt;yuscii&lt;/code&gt; library. Please note, Yukoslavian engineers created &lt;a href=&quot;https://github.com/dinosaure/yuscii&quot;&gt;&lt;code&gt;YUSCII&lt;/code&gt;&lt;/a&gt; encoding to replace the imperial ASCII one.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rosetta&lt;/code&gt; is a little library that normalises some inputs such as &lt;code&gt;KOI8-{U,R}&lt;/code&gt; or &lt;code&gt;ISO-8859-*&lt;/code&gt; to Unicode. This ability permits &lt;code&gt;mrmime&lt;/code&gt; to produce only UTF-8 results that remove the encoding problem. Then, as according to &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6532&quot;&gt;RFC6532&lt;/a&gt; and the Postel law, Mr. MIME can produce only UTF-8 emails.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ke&lt;/code&gt; is a small library that implements a ring buffer with &lt;code&gt;bigarray&lt;/code&gt;. This library has only one purpose: to restrict a transmission's memory consumption via a ring buffer, like the famous Xen's shared-memory ring buffer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;emile&lt;/code&gt; may be the most useful library for many users. It parses and re-encodes an email address according to standards. Email addresses are hard! Many details exist, and some of them have meaning while others don't. &lt;code&gt;emile&lt;/code&gt; proposes the most standardised way to parse email addresses, and it has the smaller dependencies cone, so it could be used by any project, regardless of size.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unstrctrd&lt;/code&gt; may be the most obscure library, but it's the essential piece of Mr. MIME. From archeological research into multiple standards, which describe emails along that time, we discovered the most generic form of any values available in your header: the &lt;em&gt;unstructured&lt;/em&gt; form. At least email addresses, Date (&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc822&quot;&gt;RFC822&lt;/a&gt;), or DKIM-Signature follow this form. More generally, a form such as this can be found in the Debian package description (the &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc822#section-3.4.8&quot;&gt;RFC822 form&lt;/a&gt;). &lt;code&gt;unstrctrd&lt;/code&gt; implements a decoder for it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;prettym&lt;/code&gt; is the last developed library in this context. It's like the &lt;code&gt;Format&lt;/code&gt; module with &lt;code&gt;ke&lt;/code&gt;, and it produces a &lt;em&gt;continuation&lt;/em&gt;, which fills a fixed-length buffer. &lt;code&gt;prettym&lt;/code&gt; describes how to encode emails while complying with the 80-columns rule, so any emails generated by Mr. MIME fit into a catodic monitor! More importantly, with the 7-bit limitation, this rule comes from the MTU limitation of routers, and it's required from the standard point-of-view.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From all of these, we developed &lt;code&gt;mrmime&lt;/code&gt;, a library that can transform your email into an OCaml value and create an email from it. This work is related to necessary pieces in multiple contexts, especially the &lt;code&gt;multipart&lt;/code&gt; format. We decided to extract a relevant piece of software and make a new library more specialised for the HTTP (which shares many things from emails), then integrate it into &lt;a href=&quot;https://github.com/aantron/dream&quot;&gt;Dream&lt;/a&gt;. For example see &lt;a href=&quot;https://github.com/dinosaure/multipart_form&quot;&gt;multipart_form&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A huge amount of work has been done on &lt;code&gt;mrmime&lt;/code&gt; to ensure a kind of &lt;em&gt;isomorphism&lt;/em&gt;, such as &lt;code&gt;x = decode(encode(x))&lt;/code&gt;. For this goal, we created a &lt;em&gt;fuzzer&lt;/em&gt; that can generate emails. Next, we tried to encode it and then decode the result. Finally, we compared results and checked if they were semantically equal. This enables us to generate many emails, and Mr. MIME won't alter their values.&lt;/p&gt;
&lt;p&gt;We also produced a large corpus of emails (a million) that follows the standards. It's really interesting work because it offers the community a free corpus of emails where implementations can check their reliability through Mr. MIME. For a long time after we released Mr. MIME, users wondered how to confirm that what they decoded is what they wanted. It's easy! Just do as we did! Give a billion emails to Mr. MIME and see for yourself. It never fails to decode them all!&lt;/p&gt;
&lt;p&gt;At first, we discovered a problem with this implemenation because we couldn't verify Mr. MIME &lt;strong&gt;correctly&lt;/strong&gt; parsed the emails, but we fixed that through our work on &lt;code&gt;hamlet&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hamlet&lt;/code&gt; proposes a large corpus of emails, which proves the reliability of Mr. MIME, and &lt;code&gt;mrmime&lt;/code&gt; can parse any of these emails. They can be re-encoded, and &lt;code&gt;mrmime&lt;/code&gt; doesn't alter anything at any step. We ensure correspondance between the parser and the encoder, and we can finally say that &lt;code&gt;mrmime&lt;/code&gt; gives us the expected result after parsing an email.&lt;/p&gt;
&lt;h2&gt;Parsing and Serialising Emails with Mr. MIME&lt;/h2&gt;
&lt;p&gt;It's pretty easy to manipulate and craft an email with Mr. MIME, and from our work (especially on &lt;code&gt;hamlet&lt;/code&gt;), we are convinced it's reliabile. Here are some examples of Mr. MIME in OCaml to show you how to create an email and how to introspect &amp;amp; analyse an email:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;open Mrmime

let romain_calascibetta =
  let open Mailbox in
  Local.[ w &amp;quot;romain&amp;quot;; w &amp;quot;calascibetta&amp;quot; ] @ Domain.(domain, [ a &amp;quot;gmail&amp;quot;; a &amp;quot;com&amp;quot; ])

let tarides =
  let open Mailbox in
  Local.[ w &amp;quot;contact&amp;quot; ] @ Domain.(domain, [ a &amp;quot;tarides&amp;quot;; a &amp;quot;com&amp;quot; ])

let date = Date.of_ptime ~zone:Date.Zone.GMT (Ptime_clock.now ())

let content_type =
  Content_type.(make `Text (Subtype.v `Text &amp;quot;plain&amp;quot;) Parameters.empty)

let subject =
  let open Unstructured.Craft in
  compile [ v &amp;quot;A&amp;quot;; sp 1; v &amp;quot;simple&amp;quot;; sp 1; v &amp;quot;email&amp;quot; ]

let header =
  let open Header in
  empty
  |&amp;gt; add Field_name.date Field.(Date, date)
  |&amp;gt; add Field_name.subject Field.(Unstructured, subject)
  |&amp;gt; add Field_name.from Field.(Mailboxes, [ romain_calascibetta ])
  |&amp;gt; add (Field_name.v &amp;quot;To&amp;quot;) Field.(Addresses, Address.[ mailbox tarides ])
  |&amp;gt; add Field_name.content_encoding Field.(Encoding, `Quoted_printable)

let stream_of_stdin () = match input_line stdin with
  | line -&amp;gt; Some (line, 0, String.length line)
  | exception _ -&amp;gt; None

let v =
  let part = Mt.part ~header stream_of_stdin in
  Mt.make Header.empty Mt.simple part

let () =
  let stream = Mt.to_stream v in
  let rec go () = match stream () with
    | Some (str, off, len) -&amp;gt;
      output_substring stdout str off len ;
      go ()
    | None -&amp;gt; () in
  go ()

(* $ ocamlfind opt -linkpkg -package mrmime,ptime.clock.os in.ml -o in.exe
   $ echo &amp;quot;Hello World\\!&amp;quot; | ./in.exe &amp;gt; mail.eml
*)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, we wanted to create a simple email with an incoming body using the standard input. It shows that &lt;code&gt;mrmime&lt;/code&gt; is able to &lt;em&gt;encode&lt;/em&gt; the body correctly according to the given header. For instance, we used the &lt;code&gt;quoted-printable&lt;/code&gt; encoding (implemented by &lt;code&gt;pecu&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Then, in the example below from the standard input, we wanted to extract the incoming email's header and extract the email addresses (from the &lt;code&gt;From&lt;/code&gt;, &lt;code&gt;To&lt;/code&gt;, &lt;code&gt;Cc&lt;/code&gt;, &lt;code&gt;Bcc&lt;/code&gt; and &lt;code&gt;Sender&lt;/code&gt; fields). Then, we show them:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;open Mrmime

let ps =
  let open Field_name in
  Map.empty
  |&amp;gt; Map.add from Field.(Witness Mailboxes)
  |&amp;gt; Map.add (v &amp;quot;To&amp;quot;) Field.(Witness Addresses)
  |&amp;gt; Map.add cc Field.(Witness Addresses)
  |&amp;gt; Map.add bcc Field.(Witness Addresses)
  |&amp;gt; Map.add sender Field.(Witness Mailbox)

let parse ic =
  let decoder = Hd.decoder ps in
  let rec go (addresses : Emile.mailbox list) =
    match Hd.decode decoder with
    | `Malformed err -&amp;gt; failwith err
    | `Field field -&amp;gt;
      ( match Location.prj field with
      | Field (_, Mailboxes, vs) -&amp;gt;
        go (vs @ addresses)
      | Field (_, Mailbox, v) -&amp;gt;
        go (v :: addresses)
      | Field (_, Addresses, vs) -&amp;gt;
        let vs =
          let f = function
            | `Group { Emile.mailboxes; _ } -&amp;gt;
              mailboxes
            | `Mailbox m -&amp;gt; [ m ] in
          List.(concat (map f vs)) in
        go (vs @ addresses)
      | _ -&amp;gt; go addresses )
    | `End _ -&amp;gt; addresses
    | `Await -&amp;gt; match input_line ic with
      | &amp;quot;&amp;quot; -&amp;gt; go addresses
      | line
        when String.length line &amp;gt;= 1
          &amp;amp;&amp;amp; line.[String.length line - 1] = '\\r' -&amp;gt;
        Hd.src decoder (line ^ &amp;quot;\\n&amp;quot;) 0
          (String.length line + 1) ;
        go addresses
      | line -&amp;gt;
        Hd.src decoder (line ^ &amp;quot;\\r\\n&amp;quot;) 0
          (String.length line + 2) ;
        go addresses
      | exception _ -&amp;gt;
        Hd.src decoder &amp;quot;&amp;quot; 0 0 ;
        go addresses in
  go []

let () =
  let vs = parse stdin in
  List.iter (Format.printf &amp;quot;%a\\n%!&amp;quot; Emile.pp_mailbox) vs

(* $ ocamlfind opt -linkpkg -package mrmime out.ml -o out.exe
   $ echo &amp;quot;Hello World\\!&amp;quot; | ./in.exe | ./out.exe
   romain.calascibetta@gmail.com
   contact@tarides.com
*)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this library, we're able to process emails correctly &lt;em&gt;and&lt;/em&gt; verify some &lt;em&gt;meta&lt;/em&gt;-information, or we can include some &lt;em&gt;meta&lt;/em&gt;-data, such as the &lt;code&gt;Received:&lt;/code&gt; field for example.&lt;/p&gt;
&lt;h2&gt;Sending Emails with SMTP&lt;/h2&gt;
&lt;p&gt;Of course, when we talk about email, we must talk about SMTP (described by &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc5321&quot;&gt;RFC5321&lt;/a&gt;). This protocol is an old one (see &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc821&quot;&gt;RFC821&lt;/a&gt; - 1982), and it comes with many things such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;8BITMIME support (1993)
&lt;/li&gt;
&lt;li&gt;PLAIN authentication (1999)
&lt;/li&gt;
&lt;li&gt;STARTTLS (2002)
&lt;/li&gt;
&lt;li&gt;or TLS to submit an email (2018)
&lt;/li&gt;
&lt;li&gt;and some others (such as pipeline or enhancement of status code)
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Throughout this protocol's history, we tried to pay attention to CVEs like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The TURN command (see CVE-1999-0512)
&lt;/li&gt;
&lt;li&gt;Authentication into a non-securise channel (see CVE-2017-15042)
&lt;/li&gt;
&lt;li&gt;And many others due to buffer overflow
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A reimplementation of the SMTP protocol becomes an archeological job where we must be aware of its story via the evolution of its standards, usages, and experimentations; so we tried to find the best way to implement the protocol.&lt;/p&gt;
&lt;p&gt;We decided to implement a simple framework in order to describe the state machine of an SMTP server that can upgrade its flow to TLS, so we created &lt;a href=&quot;https://github.com/colombe&quot;&gt;&lt;code&gt;colombe&lt;/code&gt;&lt;/a&gt; as a simple library to implement the foundations of the protocol. In the spirit of &lt;a href=&quot;https://mirage.io/&quot;&gt;MirageOS&lt;/a&gt; projects, &lt;code&gt;colombe&lt;/code&gt; doesn't depend on &lt;code&gt;lwt&lt;/code&gt;, &lt;code&gt;async&lt;/code&gt;, or any specific TCP/IP stack, so we ensure the ability to handle incoming/outcoming flow during the process, especially when we want to test/&lt;em&gt;mock&lt;/em&gt; our state machine.&lt;/p&gt;
&lt;p&gt;With such a design, it becomes easy to integrate a TLS stack. We decided to provide (by default) the SMTP protocol with the &lt;code&gt;STARTTLS&lt;/code&gt; command &lt;em&gt;via&lt;/em&gt; the great &lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;&lt;code&gt;ocaml-tls&lt;/code&gt;&lt;/a&gt; project. Of course, the end user can choose something else if they want.&lt;/p&gt;
&lt;p&gt;From all the above, we recently implemented &lt;a href=&quot;https://github.com/mirage/colombe&quot;&gt;&lt;code&gt;sendmail&lt;/code&gt;&lt;/a&gt; (and it's derivation with &lt;code&gt;STARTTLS&lt;/code&gt;), which is currently used by some projects such as &lt;a href=&quot;https://github.com/oxidizing/letters&quot;&gt;letters&lt;/a&gt; and &lt;a href=&quot;https://github.com/oxidizing/sihl&quot;&gt;Sihl&lt;/a&gt; or &lt;a href=&quot;https://github.com/aantron/dream&quot;&gt;Dream&lt;/a&gt;, to send an email to some existing services (see &lt;a href=&quot;https://www.mailgun.com/&quot;&gt;Mailgun&lt;/a&gt; or &lt;a href=&quot;https://sendgrid.com/&quot;&gt;Sendgrid&lt;/a&gt;). Thanks to these &lt;em&gt;outsiders&lt;/em&gt; for using our work!&lt;/p&gt;
&lt;h2&gt;Manipulate Emails with CLI tools&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mrmime&lt;/code&gt; is the bedrock of our email stack. With &lt;code&gt;mrmime&lt;/code&gt;, it's possible to manipulate emails as the user wants, so we developed several tools to help the user manipulate emails:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ocaml-dkim&lt;/code&gt; provides a tool to verify and sign an email. This tool is interesting because we put a lot of effort into ensuring that the verification is really memory-bound. Indeed, many tools that verify the DKIM signature do two passes: one to extract the signature and the second to verify. However, it's possible to combine these two steps into one and ensure that such verification can be &amp;quot;piped&amp;quot; into a larger process (such as an SMTP reception server).
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uspf&lt;/code&gt; provides a verification tool for meta-information (such as the IP address of the sender), like the email's source, and ensure that the email didn't come from an untrusted source. Like &lt;code&gt;ocaml-dkim&lt;/code&gt;, it's a simple tool that can be &amp;quot;piped&amp;quot; into a larger process.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ocaml-maildir&lt;/code&gt; is a MirageOS project that manipulates a &lt;code&gt;maildir&lt;/code&gt; &amp;quot;store.&amp;quot; Similar to MirageOS, &lt;code&gt;ocaml-maildir&lt;/code&gt; provides a multitude of backends, depending on your context. Of course, the default backend is Unix, but we planned to use &lt;code&gt;ocaml-maildir&lt;/code&gt; with &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin&lt;/a&gt;.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ocaml-dmarc&lt;/code&gt; is finally the tool which aggregates SPF and DKIM meta-information to verify an incoming email (if it comes from an expected authority and wasn't altered).
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spamtacus&lt;/code&gt; is a tool which analyses the incoming email to determine if it's spam or not. It filters incoming emails and rejects spam.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;conan&lt;/code&gt; is an experimental tool that re-implements the command &lt;code&gt;file&lt;/code&gt; to recognise the MIME type of a given file. Its status is still experimental, but outcomes are promising! We hope to continue the development of it to improve the whole MirageOS stack.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blaze&lt;/code&gt; is the end-user tool. It aggregates many small programs in the Unix spirit. Every tool can be used with &amp;quot;pipe&amp;quot; (&lt;code&gt;|&lt;/code&gt;) and allows the user to do something more complex in its emails. It permits an introspection of our emails in order to aggregate some information, and it proposes a &amp;quot;functional&amp;quot; way to craft and send an email, as you can see below:
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ blaze.make --from din@osau.re \\
  | blaze.make wrap --mixed \\
  | blaze.make put --type image/png --encoding base64 image.png \\
  | blaze.submit --sender din@osau.re --password ****** osau.re
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Currently, our development mainly follows the same pattern:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Make a library that manipulate emails
&lt;/li&gt;
&lt;li&gt;Provide a simple tool that does the job implemented by our library
&lt;/li&gt;
&lt;li&gt;Integrate it into our &amp;quot;stack&amp;quot; with MirageOS
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;blaze&lt;/code&gt; is a part of this workflow where you can find:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;blaze.dkim&lt;/code&gt; which uses &lt;code&gt;ocaml-dkim&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blaze.spf&lt;/code&gt; which uses &lt;code&gt;uspf&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blaze.mdir&lt;/code&gt; which uses &lt;code&gt;ocaml-maildir&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;and many small libraries such as:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;blaze.recv&lt;/code&gt; to produce a graph of the route of our email
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blaze.send&lt;/code&gt;/&lt;code&gt;blaze.submit&lt;/code&gt; to send an email to a recipient/an authority
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blaze.srv&lt;/code&gt; which launches a simple SMTP server to receive on email
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blaze.descr&lt;/code&gt; which describes the structure of your email
&lt;/li&gt;
&lt;li&gt;and some others...
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It's interesting to split and prioritise goals of all email possibilities instead of making a monolithic tool which supports far too wide a range of features, although that could also be useful. We ensure a healthy separation between all functionalities and make the user responsible through a self-learning experience, because the most useful black-box does not really help.&lt;/p&gt;
&lt;h2&gt;Deploying Email Services as Unikernels&lt;/h2&gt;
&lt;p&gt;As previously mentioned, we developed all of these libraries in the spirit of MirageOS. This mainly means that they should work everywhere, given that we gave great attention to dependencies and abstractions. The goal is to provide a full SMTP stack that's able to send and receive emails.&lt;/p&gt;
&lt;p&gt;This work was funded by &lt;a href=&quot;https://dapsi.ngi.eu/&quot;&gt;the NGI DAPSI project&lt;/a&gt;, which was jointly funded by the EU's Horizon 2020 research and innovation programme (contract No. 871498) and the Commissioned Research of National Institute of Information.&lt;/p&gt;
&lt;p&gt;Such an endeavour takes a huge amount of work on the MirageOS side in order to &amp;quot;scale-up&amp;quot; our infrastructure and deploy &lt;strong&gt;many&lt;/strong&gt; unikernels automatically, so we can propose a coherent final service. We currently use:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/roburio/albatross&quot;&gt;&lt;code&gt;albatross&lt;/code&gt;&lt;/a&gt; as the daemon which deploys unikernels
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocurrent/ocurrent&quot;&gt;&lt;code&gt;ocurrent&lt;/code&gt;&lt;/a&gt; as the Continuous Integration pipeline that compiles unikernels from the source and asks &lt;code&gt;albatross&lt;/code&gt; to deploy them
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We have a self-contained infrastructure. It does not require extra resources, and you can &lt;em&gt;bootstrap&lt;/em&gt; a full SMTP service from what we did with required layouts for SPF, DKIM, and DMARC. Our SMTP stack requires a DNS stack already developed and used by &lt;code&gt;mirage.io&lt;/code&gt;. From that, we provide a &lt;em&gt;submit&lt;/em&gt; service and a receiver that redirects incoming emails to their real identities.&lt;/p&gt;
&lt;p&gt;This graph shows our infrastructure:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/W6rjghJ.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;As you can see, we have seven unikernels:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A simple submission server, from a Git database, that's able to authenticate clients or not
&lt;/li&gt;
&lt;li&gt;A DKIM signer that contains your private key that notifies the primary DNS server to record your public key and let receivers verify the integrity of your sent emails
&lt;/li&gt;
&lt;li&gt;The primary DNS server that handles your domain name
&lt;/li&gt;
&lt;li&gt;The SMTP relay that transfers incoming emails to their right destinations. For instance, for a given user (i.e.,&lt;code&gt;foo@&amp;lt;my-domain&amp;gt;&lt;/code&gt;) from the Git database, the relay knows that the real address is &lt;code&gt;foo@gmail.com&lt;/code&gt;. Thus, it will retransfer the incoming email to the correct SMTP service.
&lt;/li&gt;
&lt;li&gt;The SMTP relay needs a DNS resolver to get the IP of the destination. This is our fifth unikernel to ensure that we don't use extra resources or control anything necessary to send and receive emails.
&lt;/li&gt;
&lt;li&gt;The SMTP receiver does a sanity check on incoming emails, such as SPF and DKIM (DMARC), and prepends the incoming email with results.
&lt;/li&gt;
&lt;li&gt;Finally, we have a spam filter that prepends incoming emails with meta information, which helps us to determine if they're spam or not.
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;An eighth unikernel can help provide a &lt;em&gt;Let's Encrypt&lt;/em&gt; certificate under your domain name. This ensures a secure TLS connection from a recognised authority. At the boot of the submission server and the receiver, they ask this unikernel to obtain and use a certificate. Users can now submit emails in a secure way, and senders can transmit their emails in a secure way, too.&lt;/p&gt;
&lt;p&gt;The SMTP stack is pretty complex, but any of these unikernels can be used separately from the others. Finally, a full tutorial to deploy this stack from scratch is available &lt;a href=&quot;https://github.com/mirage/ptt-deployer&quot;&gt;here&lt;/a&gt;, and the development of unikernels is available in the &lt;a href=&quot;https://github.com/mirage/ptt&quot;&gt;&lt;code&gt;ptt&lt;/code&gt;&lt;/a&gt; (Poste, T&amp;eacute;l&amp;eacute;graphe, and T&amp;eacute;l&amp;eacute;phone) repository.&lt;/p&gt;

      </content><id>https://mirage.io/blog/2022-04-01-Mr-MIME</id><title type="text">Emails in OCaml</title><updated>2022-04-01T00:00:00-00:00</updated><author><name>Romain Calascibetta</name></author></entry><entry><link href="https://mirage.io/blog/2022-03-30.cross-compilation" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;In this blog post, we'll discover &lt;em&gt;build contexts&lt;/em&gt;, one of the central changes of MirageOS 4. It's a feature from the &lt;a href=&quot;https://dune.build&quot;&gt;Dune build system&lt;/a&gt; that enables fully-customizable cross-compilation. We'll showcase its usage by cross-compiling a unikernel to deploy it on an &lt;code&gt;arm64&lt;/code&gt; Linux machine using KVM. This way, a powerful machine does the heavy lifting while a more constrained device such as a &lt;a href=&quot;https://www.raspberrypi.org/&quot;&gt;Raspberry Pi&lt;/a&gt; or a &lt;a href=&quot;https://www.clockworkpi.com/devterm&quot;&gt;DevTerm&lt;/a&gt; deploys it.&lt;/p&gt;
&lt;p&gt;We recommend having some familiarity with the MirageOS project in order to fully understand this article. See &lt;a href=&quot;https://mirage.io/docs/&quot;&gt;mirage.io/docs&lt;/a&gt; for more information on that matter.&lt;/p&gt;
&lt;p&gt;The unikernel we'll deploy is a caching DNS resolver: https://github.com/mirage/dns-resolver. In a network configuration, the DNS resolver &lt;em&gt;translates&lt;/em&gt; domain names to IP adresses, so a personal computer knows which IP should be contacted while accessing mirage.io. &lt;em&gt;See the first 10 minutes of this &lt;a href=&quot;https://www.youtube.com/watch?v=-wMU8vmfaYo&quot;&gt;YouTube video&lt;/a&gt; for a more precise introduction to DNS.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;It's common that your ISP provides a &lt;em&gt;default&lt;/em&gt; DNS resolver that's automatically set up when connecting to your network (see DHCP), but this may come with privacy issues. The &lt;em&gt;Internet People&amp;trade;&lt;/em&gt; recommend using &lt;code&gt;1.1.1.1&lt;/code&gt; (Cloudflare) or &lt;code&gt;8.8.8.8&lt;/code&gt; (Google), but a better solution is to self-host your resolver or use one set up by someone you trust.&lt;/p&gt;
&lt;h2&gt;The MirageOS 4 Build System&lt;/h2&gt;
&lt;h3&gt;Preliminary Steps&lt;/h3&gt;
&lt;p&gt;Let's start by setting up MirageOS 4, fetching the project, and configuring it for &lt;code&gt;hvt&lt;/code&gt;. &lt;code&gt;hvt&lt;/code&gt; is a Solo5-based target that exploits KVM to perform virtualization.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ opam install &amp;quot;mirage&amp;gt;4&amp;quot; &amp;quot;dune&amp;gt;=3.2.0&amp;quot;
$ git clone https://github.com/mirage/dns-resolver
$ cd dns-resolver
dns-resolver $ mirage configure -t hvt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;What is a Configured Unikernel ?&lt;/h3&gt;
&lt;p&gt;In MirageOS 4, a &lt;em&gt;configured unikernel&lt;/em&gt; is obtained by running the &lt;code&gt;mirage configure&lt;/code&gt; command in a folder where a &lt;code&gt;config.ml&lt;/code&gt; file resides. This file describes the requirements to build the application, usually a &lt;code&gt;unikernel.ml&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;The following hierarchy is obtained. It's quite complex, but today the focus is on the Dune-related part of it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; dns-resolver/
 &amp;#9507; config.ml
 &amp;#9507; unikernel.ml
 &amp;#9475;
 &amp;#9507; Makefile
 &amp;#9507; dune             &amp;lt;- switch between config and build
 &amp;#9507; dune.config      &amp;lt;- configuration build rules
 &amp;#9507; dune.build       &amp;lt;- unikernel build rules
 &amp;#9507; dune-project     &amp;lt;- dune project definition
 &amp;#9507; dune-workspace   &amp;lt;- build contexts definition
 &amp;#9507; mirage/
 &amp;#9475;  &amp;#9507; context
 &amp;#9475;  &amp;#9507; key_gen.ml
 &amp;#9475;  &amp;#9507; main.ml
 &amp;#9475;  &amp;#9507; &amp;lt;...&amp;gt;-&amp;lt;target&amp;gt;-monorepo.opam
 &amp;#9475;  &amp;#9495; &amp;lt;...&amp;gt;-&amp;lt;target&amp;gt;-switch.opam
 &amp;#9495; dist/
   &amp;#9495; dune           &amp;lt;- rules to produce artifacts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To set up the switch state and fetch dependencies, use the &lt;code&gt;make depends&lt;/code&gt; command. Under the hood (see the Makefile), this calls &lt;code&gt;opam&lt;/code&gt; and &lt;code&gt;opam-monorepo&lt;/code&gt; to gather dependencies. When the command succeeds, a &lt;code&gt;duniverse/&lt;/code&gt; folder is created, which contains the unikernel's runtime dependencies.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ make depends
&lt;/code&gt;&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;While obtaining dependencies, let's start to investigate the Dune-related files.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;dune&lt;/code&gt; Files&lt;/h2&gt;
&lt;h3&gt;&lt;code&gt;./dune&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;dune&lt;/code&gt; files describe build rules and high-level operations so that the build system can obtain a global dependency graph and know about what's available to build. See &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#dune&quot;&gt;dune-files&lt;/a&gt; for more information.&lt;/p&gt;
&lt;p&gt;In our case, we'll use this file as a &lt;em&gt;switch&lt;/em&gt; between two states. This one's first:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(include dune.config)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;at the configuration stage (after calling &lt;code&gt;mirage configure&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Then the content is replaced by &lt;code&gt;(include dune.build)&lt;/code&gt; if the configuration is successful.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;./dune.config&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;(data_only_dirs duniverse)

(executable
 (name config)
 (flags (:standard -warn-error -A))
 (modules config)
 (libraries mirage))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, two things are happening. First, the &lt;code&gt;duniverse/&lt;/code&gt; folder is declared as data-only, because we don't want it to interfere with the configuration build, as it should only depend on the global switch state.&lt;/p&gt;
&lt;p&gt;Second, a &lt;code&gt;config&lt;/code&gt; executable is declared. It contains the second stage of the configuration process, which is executed to generate &lt;code&gt;dune.build&lt;/code&gt;, &lt;code&gt;dune-workspace&lt;/code&gt;, and various other files required to build the unikernel.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;./dune-workspace&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The workspace declaration file is a single file at a Dune project's root and describes global settings for the project. See the &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#dune-workspace&quot;&gt;documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First, it declares the Dune language used and the compilation profile, which is &lt;em&gt;release&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(lang dune 2.0)

(profile release)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For cross-compilation to work, two contexts are declared.&lt;/p&gt;
&lt;p&gt;The host context simply imports the configuration from the Opam switch:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(context (default))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use the target context in a more flexible way, and there are many fields allowing users to customize settings such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OCaml compilation and linking flags
&lt;/li&gt;
&lt;li&gt;C compilation and linking flags
&lt;/li&gt;
&lt;li&gt;Dynamic linking
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OCaml compiler toolchain&lt;/strong&gt;: any compiler toolchain described by a &lt;code&gt;findlib.conf&lt;/code&gt; file in the switch can be used by Dune in a build context. See &lt;a href=&quot;https://linux.die.net/man/5/findlib.conf&quot;&gt;https://linux.die.net/man/5/findlib.conf&lt;/a&gt; for more details on how to write such a file.
An important fact about the compiler toolchain is that Dune derives the C compilation rules from the &lt;em&gt;configuration&lt;/em&gt;, as described in &lt;code&gt;ocamlc -config&lt;/code&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;(context (default
  (name solo5)      ; name of the context
  (host default)    ; inform dune that this is cross-compilation
  (toolchain solo5) ; use the ocaml-solo5 compiler toolchain
  (merlin)          ; enable merlin for this context
  (disable_dynamically_linked_foreign_archives true)
))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;code&gt;./dune.build&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;When configuration is done, this file is included by &lt;code&gt;./dune&lt;/code&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The generated source code is imported along with the unikernel sources:
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;(copy_files ./mirage/*)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;An executable is declared within the cross-compilation build context, using the statically-known list of dependencies:
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;(executable
 (enabled_if (= %{context_name} &amp;quot;solo5&amp;quot;))
 (name main)
 (modes (native exe))
 (libraries arp.mirage dns dns-mirage dns-resolver.mirage dns-server
   ethernet logs lwt mirage-bootvar-solo5 mirage-clock-solo5
   mirage-crypto-rng-mirage mirage-logs mirage-net-solo5 mirage-random
   mirage-runtime mirage-solo5 mirage-time tcpip.icmpv4 tcpip.ipv4
   tcpip.ipv6 tcpip.stack-direct tcpip.tcp tcpip.udp)
 (link_flags :standard -w -70 -color always -cclib &amp;quot;-z solo5-abi=hvt&amp;quot;)
 (modules (:standard \\ config manifest))
 (foreign_stubs (language c) (names manifest))
)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Solo5 requires the usage of a small chunk of C code derived from a manifest file, which is also generated:
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;(rule
 (targets manifest.c)
 (deps manifest.json)
 (action
  (run solo5-elftool gen-manifest manifest.json manifest.c)))
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;The obtained image is renamed, and the default alias is overriden so that &lt;code&gt;dune build&lt;/code&gt; works as expected:
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;(rule
 (target resolver.hvt)
 (enabled_if (= %{context_name} &amp;quot;solo5&amp;quot;))
 (deps main.exe)
 (action
  (copy main.exe %{target})))

(alias
  (name default)
  (enabled_if (= %{context_name} &amp;quot;solo5&amp;quot;))
  (deps (alias_rec all)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;code&gt;./dist/dune&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Once the unikernel is built, this rule describes how it's promoted back into the source tree that resides inside the &lt;code&gt;dist/&lt;/code&gt; folder.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(rule
 (mode (promote (until-clean)))
 (target resolver.hvt)
 (enabled_if (= %{context_name} &amp;quot;solo5&amp;quot;))
 (action
  (copy ../resolver.hvt %{target})))
&lt;/code&gt;&lt;/pre&gt;
&lt;hr/&gt;
&lt;h2&gt;Cross-Compiling to &lt;code&gt;x86_64/hvt&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;If everything went correctly, the unikernel source tree should be populated with all the build rules and dependencies needed. It's just a matter of&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ make build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mirage build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dune build --root .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we obtain an &lt;code&gt;hvt&lt;/code&gt;-enabled executable in the &lt;code&gt;dist/&lt;/code&gt; folder. To execute it, the we must first:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;install the HVT tender: &lt;code&gt;solo5-hvt&lt;/code&gt; that is installed in the &lt;code&gt;solo5&lt;/code&gt; package.
&lt;/li&gt;
&lt;li&gt;prepare a TAP interface for networking: note that it requires access to the Internet to be able to query the root DNS servers.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That executable can run using &lt;code&gt;solo5-hvt --net:service=&amp;lt;TAP_INTERFACE&amp;gt; dist/resolver.hvt --ipv4=&amp;lt;UNIKERNEL_IP&amp;gt; --ipv4-gateway=&amp;lt;HOST_IP&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Cross-Compiling to ARM64/HVT&lt;/h2&gt;
&lt;p&gt;When cross-compiling to ARM64, the scheme looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/QqEGUPz.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;So, from the Mirage build system viewpoint, nothing changes. The only part that changes is the compiler used. We switch from a &lt;em&gt;host&lt;/em&gt;-architecture &lt;code&gt;ocaml-solo5&lt;/code&gt; to a &lt;em&gt;cross&lt;/em&gt;-architecture version of &lt;code&gt;ocaml-solo5&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To achieve that, we must pin a version of &lt;code&gt;ocaml-solo5&lt;/code&gt; configured for cross-compilation and pin the cross-compiled Solo5 distribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ opam pin solo5-cross-aarch64 https://github.com/Solo5/solo5.git#v0.7.1
$ opam pin ocaml-solo5-cross-aarch64 https://github.com/mirage/ocaml-solo5.git#v0.8.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that doing this will uninstall &lt;code&gt;ocaml-solo5&lt;/code&gt;. Indeed, they both define the same &lt;em&gt;toolchain name&lt;/em&gt; &lt;code&gt;solo5&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;KVM is now enabled by default in most Raspberry Pi kernel distributions, but for historical interest, this blog post shows how to enable KVM and cross-compile the Linux kernel: &lt;a href=&quot;https://mirage.io/docs/arm64&quot;&gt;https://mirage.io/docs/arm64&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Then, simply run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dune build / mirage build / make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A cross-compiled binary will appear in the &lt;code&gt;dist/&lt;/code&gt; folder:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ file dist/resolver.hvt
dist/resolver.hvt: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, interpreter /nonexistent/solo5/, for OpenBSD, with debug_info, not stripped
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On the Raspberry Pi target, simply copy the unikernel binary, install the Solo5 tender (&lt;code&gt;opam install solo5&lt;/code&gt;), and run &lt;code&gt;solo5-hvt unikernel.hvt&lt;/code&gt; to execute the unikernel.&lt;/p&gt;
&lt;h2&gt;Compiling to a New Target or Architecture&lt;/h2&gt;
&lt;h3&gt;Case 1: An Already Known Mirage Target (Unix / HVT / etc.)&lt;/h3&gt;
&lt;p&gt;In that situation, &lt;code&gt;mirage configure -t &amp;lt;target&amp;gt;&lt;/code&gt; should already output the correct source code and dependencies for the target. This is notably under the assumption that the involved C code is portable.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;dune-workspace&lt;/code&gt; can then be tweaked to reference the wanted cross-compiler distribution. &lt;a href=&quot;https://github.com/mirage/ocaml-solo5&quot;&gt;&lt;code&gt;ocaml-solo5&lt;/code&gt;&lt;/a&gt; is an example on how a cross-compiler distribution can be set up and installed inside an Opam switch.&lt;/p&gt;
&lt;h3&gt;Case 2: A New Target&lt;/h3&gt;
&lt;p&gt;In this situation, a more in-depth comprehension of Mirage is required.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Set up a cross-compiler distribution: see previous case.
&lt;/li&gt;
&lt;li&gt;Implement a base layer:
An OCaml module named &lt;code&gt;&amp;lt;Target&amp;gt;_os&lt;/code&gt; is required to implement the base features of MirageOS, namely job scheduling and timers. See &lt;a href=&quot;https://github.com/mirage/mirage-solo5&quot;&gt;&lt;code&gt;mirage-solo5&lt;/code&gt;&lt;/a&gt;.
&lt;/li&gt;
&lt;li&gt;Implement the target signature in the Mirage tool:
&lt;a href=&quot;https://github.com/mirage/mirage/blob/main/lib/mirage/target/s.ml&quot;&gt;&lt;code&gt;Mirage_target.S&lt;/code&gt;&lt;/a&gt; notably describes the packages required and the Dune rules needed to build for that target.
&lt;/li&gt;
&lt;li&gt;To obtain feature parity with the other Mirage targets and be able to use the existing devices, device drivers should be implemented:
&lt;ul&gt;
&lt;li&gt;Networking: see &lt;a href=&quot;https://github.com/mirage/mirage-net-solo5&quot;&gt;mirage-net-solo5&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;Console: see &lt;a href=&quot;https://github.com/mirage/mirage-console-solo5&quot;&gt;mirage-console-solo5&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;Block Device: see &lt;a href=&quot;https://github.com/mirage/mirage-block-solo5&quot;&gt;mirage-block-solo5&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;Clock: see &lt;a href=&quot;https://github.com/mirage/mirage-clock&quot;&gt;mirage-clock-solo5&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This blog post shows how the Mirage tool acts as super glue between the build system, the mirage libraries, the host system, and the &lt;strong&gt;application code&lt;/strong&gt;. One of the major changes with MirageOS 4 is the switch from OCamlbuild to Dune.&lt;/p&gt;
&lt;p&gt;Using Dune to build unikernels enables cross-compilation through build contexts that use various toolchains. It also enables the usage of the Merlin tool to provide IDE features when writing the application. Finally, a single-workspace containg all the unikernels' code lets developers investigate and edit code anywhere in the stack, allowing for fast iterations when debugging libraries and improving APIs.&lt;/p&gt;

      </content><id>https://mirage.io/blog/2022-03-30.cross-compilation</id><title type="text">Introduction to Build Contexts in MirageOS 4</title><updated>2022-03-30T00:00:00-00:00</updated><author><name>Lucas Pluvinage</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage-40" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;strong&gt;On behalf of the MirageOS team, I am delighted to announce the release
of MirageOS 4.0.0!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Since its first release in 2013, MirageOS has made steady progress
towards deploying self-managed internet infrastructure. The
project&amp;rsquo;s initial aim was to self-host as many services as possible
aimed at empowering internet users to deploy infrastructure securely
to own their data and take back control of their privacy. MirageOS can
securely deploy &lt;a href=&quot;https://github.com/roburio/unipi&quot;&gt;static website
hosting&lt;/a&gt; with &amp;ldquo;Let&amp;rsquo;s Encrypt&amp;rdquo;
certificate provisioning and a &lt;a href=&quot;https://github.com/mirage/ptt&quot;&gt;secure SMTP
stack&lt;/a&gt; with security
extensions. MirageOS can also deploy decentralised communication
infrastructure like &lt;a href=&quot;https://github.com/mirage/ocaml-matrix&quot;&gt;Matrix&lt;/a&gt;,
&lt;a href=&quot;https://github.com/roburio/openvpn&quot;&gt;OpenVPN servers&lt;/a&gt;, and &lt;a href=&quot;https://github.com/roburio/tlstunnel&quot;&gt;TLS
tunnels&lt;/a&gt; to ensure data privacy
or &lt;a href=&quot;https://github.com/mirage/ocaml-dns&quot;&gt;DNS(SEC) servers&lt;/a&gt; for better
authentication.&lt;/p&gt;
&lt;p&gt;The protocol ecosystem now contains &lt;a href=&quot;https://github.com/mirage/&quot;&gt;hundreds of libraries&lt;/a&gt; and services
millions of daily users. Over these years, major commercial users have
joined the projects. They rely on MirageOS libraries to keep their
products secure. For instance, the MirageOS networking code powers
&lt;a href=&quot;https://www.docker.com/blog/how-docker-desktop-networking-works-under-the-hood/&quot;&gt;Docker Desktop&amp;rsquo;s
VPNKit&lt;/a&gt;,
which serves the traffic of millions of containers daily. &lt;a href=&quot;https://www.citrix.com/fr-fr/products/citrix-hypervisor/&quot;&gt;Citrix
Hypervisor&lt;/a&gt;
uses MirageOS to interact with Xen, the hypervisor that powers most of
today&amp;rsquo;s public
cloud. &lt;a href=&quot;https://www.nitrokey.com/products/nethsm&quot;&gt;Nitrokey&lt;/a&gt; is
developing a new hardware security module based on
MirageOS. &lt;a href=&quot;https://robur.io/&quot;&gt;Robur&lt;/a&gt; develops a unikernel
orchestration system for fleets of MirageOS
unikernels. &lt;a href=&quot;https://tarides.com/&quot;&gt;Tarides&lt;/a&gt; uses MirageOS to improve
the &lt;a href=&quot;https://tezos.com/&quot;&gt;Tezos&lt;/a&gt; blockchain, and
&lt;a href=&quot;https://hyper.ag/&quot;&gt;Hyper&lt;/a&gt; uses MirageOS to build sensor analytics and
an automation platform for sustainable agriculture.&lt;/p&gt;
&lt;p&gt;In the coming weeks, our blog will feature in-depth technical content
for the new features that MirageOS brings and a tour of
the existing community and commercial users of MirageOS. Please reach out
If you&amp;rsquo;d like to tell us about your story.&lt;/p&gt;
&lt;h2&gt;Install MirageOS 4&lt;/h2&gt;
&lt;p&gt;The easiest way to install MirageOS 4 is by using the &lt;a href=&quot;https://opam.ocaml.org/&quot;&gt;opam package
manager&lt;/a&gt; version 2.1. Follow the
&lt;a href=&quot;https://mirage.io/docs/install&quot;&gt;installation guide&lt;/a&gt; for more details.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ opam update
$ opam install 'mirage&amp;gt;4'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: if you upgrade from MirageOS 3, you will need to manually clean
the previously generated files (or call &lt;code&gt;mirage clean&lt;/code&gt; before
upgrading). You would also want to read &lt;a href=&quot;https://mirage.io/docs/breaking-changes&quot;&gt;the complete list of API
changes&lt;/a&gt;. You can see
unikernel examples in
&lt;a href=&quot;https://github.com/mirage/mirage-skeleton&quot;&gt;mirage/mirage-skeleton&lt;/a&gt;,
&lt;a href=&quot;https://github.com/roburio/unikernels&quot;&gt;roburio/unikernels&lt;/a&gt; or
&lt;a href=&quot;https://github.com/tarides/unikernels&quot;&gt;tarides/unikernels&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;About MirageOS&lt;/h2&gt;
&lt;p&gt;MirageOS is a library operating system that constructs unikernels for
secure, high-performance, low-energy footprint applications across
various hypervisor and embedded platforms. It is available as an
open-source project created and maintained by the &lt;a href=&quot;https://mirage.io/community&quot;&gt;MirageOS Core
Team&lt;/a&gt;. A unikernel
can be customised based on the target architecture by picking the
relevant MirageOS libraries and compiling them into a standalone
operating system, strictly containing the functionality necessary
for the target. This minimises the unikernel&amp;rsquo;s footprint, increasing
the security of the deployed operating system.&lt;/p&gt;
&lt;p&gt;The MirageOS architecture can be divided into operating system
libraries, typed signatures, and a metaprogramming compiler. The
operating system libraries implement various functionalities, ranging
from low-level network card drivers to full reimplementations of the
TLS protocol, as well as the Git protocol to store versioned data. A
set of typed signatures ensures that the OS libraries are consistent
and work well in conjunction with each other. Most importantly,
MirageOS is also a metaprogramming compiler that can input OCaml
source code along with its dependencies, and a deployment target
description to generate an executable unikernel, i.e., a
specialised binary artefact containing only the code needed to run on
the target platform. Overall, MirageOS focuses on providing a small,
well-defined, typed interface with the system components of the target
architecture.&lt;/p&gt;
&lt;h2&gt;What&amp;rsquo;s New in MirageOS 4?&lt;/h2&gt;
&lt;p&gt;The MirageOS4 release focuses on better integration with existing
ecosystems. For instance, parts of MirageOS are now merged into the
OCaml ecosystem, making it easier to deploy OCaml applications into a
unikernel. Plus, we improved the cross-compilation support, added more
compilation targets to MirageOS (for instance, we have an experimental
bare-metal &lt;a href=&quot;https://github.com/mirage/mirage/pull/1253&quot;&gt;Raspberry-Pi 4
target&lt;/a&gt;, and made it
easier to integrate MirageOS with C and Rust libraries.&lt;/p&gt;
&lt;p&gt;This release introduces a significant change in how MirageOS compiles
projects. We developed a new tool called
&lt;a href=&quot;https://github.com/ocamllabs/opam-monorepo&quot;&gt;opam-monorepo&lt;/a&gt; that
separates package management from building the resulting source
code. It creates a lock file for the project&amp;rsquo;s dependencies, downloads
and extracts the dependency sources locally, and sets up a &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#dune-workspace-1&quot;&gt;dune
workspace&lt;/a&gt;,
enabling &lt;code&gt;dune build&lt;/code&gt; to build everything simultaneously. The MirageOS
4.0 release also contains improvements in the &lt;code&gt;mirage&lt;/code&gt; CLI tool, a new
libc-free OCaml runtime (thus bumping the minimal required version of
OCaml to 4.12.1), and a cross-compiler for OCaml. Finally, MirageOS
4.0 now supports the use of familiar IDE tools while developing
unikernels via Merlin, making day-to-day coding much faster.&lt;/p&gt;
&lt;p&gt;Review a complete list of features on the &lt;a href=&quot;https://mirage.io/docs/mirage-4&quot;&gt;MirageOS 4 release
page&lt;/a&gt;. And check out &lt;a href=&quot;https://mirage.io/docs/breaking-changes&quot;&gt;the breaking
API changes&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;About Cross-Compilation and opam overlays&lt;/h2&gt;
&lt;p&gt;This new release of MirageOS adds systematic support for
cross-compilation to all supported unikernel targets. This means that
libraries that use C stubs (like Base, for example) can now seamlessly
have those stubs cross-compiled to the desired target. Previous
releases of MirageOS required specific support to accomplish this by
adding the stubs to a central package. MirageOS 4.0 implements
cross-compilation using &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#dune-workspace-1&quot;&gt;Dune
workspaces&lt;/a&gt;,
which can take a whole collection of OCaml code (including all
transitive dependencies) and compile it with a given set of C and
OCaml compiler flags.&lt;/p&gt;
&lt;p&gt;The change in how MirageOS compiles projects that accompanies this
release required implementing a new developer experience for Opam
users, to simplify cross-compilation of large OCaml projects.&lt;/p&gt;
&lt;p&gt;A new tool called
&lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#dune-workspace-1&quot;&gt;opam-monorepo&lt;/a&gt;
separates package management from building the resulting source
code. It is an opam plugin that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;creates a lock file for the project&amp;rsquo;s dependencies
&lt;/li&gt;
&lt;li&gt;downloads and extracts the dependency sources locally
&lt;/li&gt;
&lt;li&gt;sets up a Dune workspace so that &lt;code&gt;dune build&lt;/code&gt; builds everything in one
go.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;opam-monorepo&lt;/code&gt; is already available in opam and can be used
on many projects which use Dune as a build system. However, as we
don&amp;rsquo;t expect the complete set of OCaml dependencies to use Dune, we
MirageOS maintainers are committed to maintaining patches that build
the most common dependencies with dune. These packages are hosted in two
separate Opam repositories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dune-universe/opam-overlays&quot;&gt;dune-universe/opam-overlays&lt;/a&gt;
adds patched packages (with a &lt;code&gt;+dune&lt;/code&gt; version) that compile with
Dune.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dune-universe/mirage-opam-overlays&quot;&gt;dune-universe/mirage-opam-overlays&lt;/a&gt;
add patched packages (with a &lt;code&gt;+dune+mirage&lt;/code&gt; version) that fix
cross-compilation with Dune.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When using the &lt;code&gt;mirage&lt;/code&gt; CLI tool, these repositories are enabled by default.&lt;/p&gt;
&lt;h2&gt;In Memory of Lars Kurth&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://xenproject.org/wp-content/uploads/sites/79/2020/01/LarsK_0.jpg&quot; width=&quot;180&quot; heigth=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We dedicate this release of MirageOS 4.0 to &lt;a href=&quot;https://xenproject.org/2020/01/31/saying-goodbye-to-lars-kurth-open-source-advocate-and-friend/&quot;&gt;Lars
Kurth&lt;/a&gt;.
Unfortunately, he passed away early in 2020, leaving a big hole in our
community. Lars was instrumental in bringing the Xen Project to
fruition, and we wouldn&amp;rsquo;t be here without him.&lt;/p&gt;

      </content><id>https://mirage.io/blog/announcing-mirage-40</id><title type="text">Announcing MirageOS 4.0.0</title><updated>2022-03-28T00:00:00-00:00</updated><author><name>Thomas Gazagnaire</name></author></entry><entry><link href="https://mirage.io/blog/deploying-mirageos-robur" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We are pleased to announce that the EU &lt;a href=&quot;https://pointer.ngi.eu&quot;&gt;NGI Pointer&lt;/a&gt; funding received by &lt;a href=&quot;https://robur.coop&quot;&gt;robur&lt;/a&gt; in 2021 lead to improved operations for MirageOS unikernels.&lt;/p&gt;
&lt;p&gt;Our main achievement are &lt;a href=&quot;https://builds.robur.coop&quot;&gt;reproducible binary builds&lt;/a&gt; of opam packages, including MirageOS unikernels and system packages. The infrastructure behind it, &lt;a href=&quot;https://github.com/roburio/orb&quot;&gt;orb&lt;/a&gt;, &lt;a href=&quot;https://github.com/roburio/builder&quot;&gt;builder&lt;/a&gt;, &lt;a href=&quot;https://github.com/roburio/builder-web&quot;&gt;builder-web&lt;/a&gt; is itself reproducible and delivered as packages by &lt;a href=&quot;https://builds.robur.coop&quot;&gt;builds.robur.coop&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The documentation how to get started &lt;a href=&quot;https://robur.coop/Projects/Reproducible_builds&quot;&gt;installing MirageOS unikernels and albatross from packages&lt;/a&gt; is available online, further documentation on &lt;a href=&quot;https://hannes.robur.coop/Posts/Monitoring&quot;&gt;monitoring&lt;/a&gt; is available as well.&lt;/p&gt;
&lt;p&gt;The funding proposal covered the parts (as outlined in &lt;a href=&quot;https://hannes.robur.coop/Posts/NGI&quot;&gt;an earlier post from 2020&lt;/a&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reproducible binary releases of MirageOS unikernels,
&lt;/li&gt;
&lt;li&gt;monitoring (and other devops features: profiling) and integration into existing infrastructure,
&lt;/li&gt;
&lt;li&gt;and further documentation and advertisement.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We &lt;a href=&quot;https://discuss.ocaml.org/t/ann-robur-reproducible-builds/8827&quot;&gt;announced the web interface earlier&lt;/a&gt; and also &lt;a href=&quot;https://hannes.robur.coop/Posts/Deploy&quot;&gt;posted about deployment&lt;/a&gt; possibilities.&lt;/p&gt;
&lt;p&gt;At the heart of our infrastructure is &lt;a href=&quot;https://github.com/roburio/builder-web&quot;&gt;builder-web&lt;/a&gt;, a database that receives binary builds and provides a web interface and binary package repositories (&lt;a href=&quot;https://apt.robur.coop&quot;&gt;apt.robur.coop&lt;/a&gt; and &lt;a href=&quot;https://pkg.robur.coop&quot;&gt;pkg.robur.coop&lt;/a&gt;). Reynir discusses the design and implementation of &lt;a href=&quot;https://github.com/roburio/builder-web&quot;&gt;builder-web&lt;/a&gt; in &lt;a href=&quot;https://reyn.ir/posts/2022-03-08-builder-web.html&quot;&gt;his blogpost&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There we &lt;a href=&quot;https://builds.robur.coop/job/tlstunnel/build/7f0afdeb-0a52-4de1-b96f-00f654ce9249/&quot;&gt;visualize&lt;/a&gt; the opam dependencies of an opam package:&lt;/p&gt;
&lt;iframe src=&quot;../graphics/tlstunnel-deps.html&quot; title=&quot;Opam dependencies&quot; style=&quot;width: 45em; height: 45.4em; max-width: 100%; max-height: 49vw; min-width: 38em; min-height: 40em;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;We also visualize the contributing modules and their sizes to the binary:&lt;/p&gt;
&lt;iframe src=&quot;../graphics/tlstunnel-treemap.html&quot; title=&quot;Binary dissection&quot; style=&quot;width: 46em; height: 48.4em; max-width: 100%; max-height: 52vw; min-width: 38em; min-height: 43em;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;Rand wrote a more in-depth explanation about the &lt;a href=&quot;https://builds.robur.coop/job/tlstunnel/build/7f0afdeb-0a52-4de1-b96f-00f654ce9249/&quot;&gt;visualizations&lt;/a&gt; &lt;a href=&quot;https://r7p5.earth/blog/2022-3-7/Builder-web%20visualizations%20at%20Robur&quot;&gt;on his blog&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you've comments or are interested in deploying MirageOS unikernels at your organization, &lt;a href=&quot;https://robur.coop/Contact&quot;&gt;get in touch with us&lt;/a&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/deploying-mirageos-robur</id><title type="text">Deploying MirageOS unikernels using binaries</title><updated>2022-03-08T00:00:00-00:00</updated><author><name>Rand</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage-40-beta-release" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;strong&gt;On behalf of the Mirage team, I am delighted to announce the beta release of MirageOS 4.0!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mirage.io&quot;&gt;MirageOS&lt;/a&gt; is a library operating system that constructs unikernels for secure, high-performance network applications across a variety of hypervisor and embedded platforms. For example, OCaml code can be developed on a standard OS, such as Linux or macOS, and then compiled into a fully standalone, specialised unikernel that runs under a Xen or KVM hypervisor. The MirageOS project also supplies several protocol and storage implementations written in pure OCaml, ranging from TCP/IP to TLS to a full Git-like storage stack.&lt;/p&gt;
&lt;p&gt;The beta of the MirageOS 4.00 release contains:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mirage.4.0.0~beta&lt;/code&gt;: the CLI tool;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ocaml-freestanding.0.7.0&lt;/code&gt;: a libc-free OCaml runtime;
&lt;/li&gt;
&lt;li&gt;and &lt;code&gt;solo5.0.7.0&lt;/code&gt;: a cross-compiler for OCaml.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;They are all available in &lt;code&gt;opam&lt;/code&gt; by using:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opam install 'mirage&amp;gt;=4.0'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: you need to explicitly add the &lt;code&gt;4.0&amp;gt;=0&lt;/code&gt; version here, otherwise &lt;code&gt;opam&lt;/code&gt; will select the latest &lt;code&gt;3.*&lt;/code&gt; stable release. For a good experience, check that at least version &lt;code&gt;4.0.0~beta3&lt;/code&gt; is installed.&lt;/p&gt;
&lt;h2&gt;New Features&lt;/h2&gt;
&lt;p&gt;This new release of MirageOS adds systematic support for cross-compilation to all supported unikernel targets. This means that libraries that use C stubs (like Base, for example) can now seamlessly have those stubs cross-compiled to the desired target.  Previous releases of MirageOS required specific support to accomplish this by adding the stubs to a central package.&lt;/p&gt;
&lt;p&gt;MirageOS implements cross-compilation using &lt;em&gt;Dune Workspaces&lt;/em&gt;, which can take a whole collection of OCaml code (including all transitive dependencies) and compile it with a given set of C and OCaml compiler flags. This workflow also unlocks support for familiar IDE tools (such as &lt;code&gt;ocaml-lsp-server&lt;/code&gt; and Merlin) while developing unikernels in OCaml. It makes day-to-day coding much faster because builds are decoupled from configuration and package updates. This means that live-builds, such as Dune's watch mode, now work fine even for exotic build targets!&lt;/p&gt;
&lt;p&gt;A complete list of features can be found on the &lt;a href=&quot;https://mirage.io/docs/mirage-4&quot;&gt;MirageOS 4 release page&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Cross-Compilation and Dune Overlays&lt;/h2&gt;
&lt;p&gt;This release introduces a significant change in the way MirageOS projects are compiled based on Dune Workspaces. This required implementing a new developer experience for Opam users in order to simplify cross-compilation of large OCaml projects.&lt;/p&gt;
&lt;p&gt;That new tool, called &lt;a href=&quot;https://github.com/ocamllabs/opam-monorepo&quot;&gt;opam-monorepo&lt;/a&gt; (n&amp;eacute;e duniverse), separates package management from building the resulting source code. It is an Opam plugin that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;creates a lock file for the project dependencies
&lt;/li&gt;
&lt;li&gt;downloads and extracts the dependency sources locally
&lt;/li&gt;
&lt;li&gt;sets up a Dune Workspace so that &lt;code&gt;dune build&lt;/code&gt; builds everything in one go.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://asciinema.org/a/rRf6s8cNyHUbBsDDfZkBjkf7X?speed=2&quot;&gt;&lt;img src=&quot;https://asciinema.org/a/rRf6s8cNyHUbBsDDfZkBjkf7X.svg&quot; alt=&quot;asciicast&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;opam-monorepo&lt;/code&gt; is already available in Opam and can be used on many projects which use &lt;code&gt;dune&lt;/code&gt; as a build system. However, as we don't expect the complete set of OCaml dependencies to use &lt;code&gt;dune&lt;/code&gt;, we MirageOS maintainers are committed to maintaining patches to build the most common dependencies with &lt;code&gt;dune&lt;/code&gt;. Two repositories are used for that purpose:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dune-universe/opam-overlays&quot;&gt;dune-universe/opam-overlays&lt;/a&gt; is set up by default by &lt;code&gt;opam-monorepo&lt;/code&gt; and contains most packages.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dune-universe/mirage-opam-overlays&quot;&gt;dune-universe/mirage-opam-overlays&lt;/a&gt; is enabled when using the Mirage CLI tool.
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;Your feedback on this beta release is very much appreciated. You can follow the tutorials &lt;a href=&quot;https://mirage.io/docs/mirage-4&quot;&gt;here&lt;/a&gt;. Issues are very welcome on our &lt;a href=&quot;https://github.com/mirage/mirage/issues&quot;&gt;bug-tracker&lt;/a&gt;, or come find us on Matrix in the MirageOS channel: &lt;a href=&quot;https://matrix.to/#/%23mirageos:matrix.org&quot;&gt;#mirageos:matrix.org&lt;/a&gt; or on &lt;a href=&quot;https://discuss.ocaml.org/t/mirageos-4-0-beta-release/9302&quot;&gt;Discuss&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;final release&lt;/strong&gt; will happen in about a month. This release will incorporate your early feedback. It will also ensure the existing MirageOS ecosystem is compatible with MirageOS 4 by reducing the overlay packages to the bare minimum. We also plan to write more on &lt;code&gt;opam-monorepo&lt;/code&gt; and all the new things MirageOS 4.0 will bring.&lt;/p&gt;

      </content><id>https://mirage.io/blog/announcing-mirage-40-beta-release</id><title type="text">Announcing MirageOS 4.0.0 Beta Release</title><updated>2022-02-10T00:00:00-00:00</updated><author><name>Thomas Gazagnaire</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage-310-release" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;IPv6 and dual (IPv4 and IPv6) stack support https://github.com/mirage/mirage/pull/1187 https://github.com/mirage/mirage/issues/1190&lt;/p&gt;
&lt;p&gt;Since a long time, IPv6 code was around in our TCP/IP stack (thanks to @nojb who developed it in 2014). Some months ago, @hannesm and @MagnusS got excited to use it. After we managed to fix some bugs and add some test cases, and writing more code to setup IPv6-only and dual stacks, we are eager to share this support for MirageOS in a released version. We expect there to be bugs lingering around, but duplicate address detection (neighbour solicitation and advertisements) has been implemented, and (unless &amp;quot;--accept-router-advertisement=false&amp;quot;) router advertisements are decoded and used to configure the IPv6 part of the stack. Configuring a static IPv6 address is also possible (with
&amp;quot;--ipv6=2001::42/64&amp;quot;).&lt;/p&gt;
&lt;p&gt;While at it, we unified the boot arguments between the different targets: namely, on Unix (when using the socket stack), you can now pass &amp;quot;--ipv4=127.0.0.1/24&amp;quot; to the same effect as the direct stack: only listen on 127.0.0.1 (the subnet mask is ignored for the Unix socket stack).&lt;/p&gt;
&lt;p&gt;A dual stack unikernel has &amp;quot;--ipv4-only=BOOL&amp;quot; and &amp;quot;--ipv6-only=BOOL&amp;quot; parameters, so a unikernel binary could support both Internet Protocol versions, while the operator can decide which protocol version to use. I.e. now there are both development-time (stackv4 vs stackv6 vs stackv4v6) choices, as well as the run-time choice (via boot parameter).&lt;/p&gt;
&lt;p&gt;I'm keen to remove the stackv4 &amp;amp; stackv6 in future versions, and always develop with dual stack (leaving it to configuration &amp;amp; startup time to decide whether to enable ipv4 and ipv6).&lt;/p&gt;
&lt;p&gt;Please also note that the default IPv4 network configuration no longer uses 10.0.0.1 as default gateway (since there was no way to unset the default gateway https://github.com/mirage/mirage/issues/1147).&lt;/p&gt;
&lt;p&gt;For unikernel developers, there are some API changes in the Mirage module&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New &amp;quot;v4v6&amp;quot; types for IP protocols and stacks
&lt;/li&gt;
&lt;li&gt;The ipv6_config record was adjusted in the same fashion as the ipv4_config type: it is now a record of a network (V6.Prefix.t) and gateway (V6.t option)
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some parts of the Mirage_key module were unified as well:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arp.ip_address is available (for a dual Ipaddr.t)
&lt;/li&gt;
&lt;li&gt;Arg.ipv6_address replaces Arg.ipv6 (for an Ipaddr.V6.t)
&lt;/li&gt;
&lt;li&gt;Arg.ipv6 replaces Arg.ipv6_prefix (for a Ipaddr.V6.Prefix.t)
&lt;/li&gt;
&lt;li&gt;V6.network and V6.gateway are available, mirroring the V4 submodule
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you're ready to experiment with the dual stack: below is a diff for our basic network example (from mirage-skeleton/device-usage/network) replacing IPv4 with a dual stack, and the tlstunnel unikernel commit
https://github.com/roburio/tlstunnel/commit/2cb3e5aa11fca4b48bb524f3c0dbb754a6c8739b
changed tlstunnel from IPv4 stack to dual stack.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;diff --git a/device-usage/network/config.ml b/device-usage/network/config.ml
index c425edb..eabc9d6 100644
--- a/device-usage/network/config.ml
+++ b/device-usage/network/config.ml
@@ -4,9 +4,9 @@ let port =
   let doc = Key.Arg.info ~doc:&amp;quot;The TCP port on which to listen for
incoming connections.&amp;quot; [&amp;quot;port&amp;quot;] in
   Key.(create &amp;quot;port&amp;quot; Arg.(opt int 8080 doc))

-let main = foreign ~keys:[Key.abstract port] &amp;quot;Unikernel.Main&amp;quot; (stackv4
@-&amp;gt; job)
+let main = foreign ~keys:[Key.abstract port] &amp;quot;Unikernel.Main&amp;quot;
(stackv4v6 @-&amp;gt; job)

-let stack = generic_stackv4 default_network
+let stack = generic_stackv4v6 default_network

 let () =
   register &amp;quot;network&amp;quot; [
diff --git a/device-usage/network/unikernel.ml
b/device-usage/network/unikernel.ml
index 5d29111..1bf1228 100644
--- a/device-usage/network/unikernel.ml
+++ b/device-usage/network/unikernel.ml
@@ -1,19 +1,19 @@
 open Lwt.Infix

-module Main (S: Mirage_stack.V4) = struct
+module Main (S: Mirage_stack.V4V6) = struct

   let start s =
     let port = Key_gen.port () in
-    S.listen_tcpv4 s ~port (fun flow -&amp;gt;
-        let dst, dst_port = S.TCPV4.dst flow in
+    S.listen_tcp s ~port (fun flow -&amp;gt;
+        let dst, dst_port = S.TCP.dst flow in
         Logs.info (fun f -&amp;gt; f &amp;quot;new tcp connection from IP %s on port %d&amp;quot;
-                  (Ipaddr.V4.to_string dst) dst_port);
-        S.TCPV4.read flow &amp;gt;&amp;gt;= function
+                  (Ipaddr.to_string dst) dst_port);
+        S.TCP.read flow &amp;gt;&amp;gt;= function
         | Ok `Eof -&amp;gt; Logs.info (fun f -&amp;gt; f &amp;quot;Closing connection!&amp;quot;);
Lwt.return_unit
-        | Error e -&amp;gt; Logs.warn (fun f -&amp;gt; f &amp;quot;Error reading data from
established connection: %a&amp;quot; S.TCPV4.pp_error e); Lwt.return_unit
+        | Error e -&amp;gt; Logs.warn (fun f -&amp;gt; f &amp;quot;Error reading data from
established connection: %a&amp;quot; S.TCP.pp_error e); Lwt.return_unit
         | Ok (`Data b) -&amp;gt;
           Logs.debug (fun f -&amp;gt; f &amp;quot;read: %d bytes:\\n%s&amp;quot; (Cstruct.len b)
(Cstruct.to_string b));
-          S.TCPV4.close flow
+          S.TCP.close flow
       );

     S.listen s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Other bug fixes include https://github.com/mirage/mirage/issues/1188 (in https://github.com/mirage/mirage/pull/1201) and adapt to charrua 1.3.0 and arp 2.3.0 changes (https://github.com/mirage/mirage/pull/1199).&lt;/p&gt;

      </content><id>https://mirage.io/blog/announcing-mirage-310-release</id><title type="text">Announcing MirageOS 3.10</title><updated>2020-12-08T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage-39-release" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We are pleased to announce the release of MirageOS 3.9.0.&lt;/p&gt;
&lt;p&gt;Our last release announcement was for &lt;a href=&quot;https://mirage.io/blog/announcing-mirage-36-release&quot;&gt;MirageOS 3.6.0&lt;/a&gt;, so we will also cover changes since 3.7.x and 3.8.x in this announcement.&lt;/p&gt;
&lt;p&gt;New features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Xen backend has been &lt;a href=&quot;https://github.com/mirage/mirage/issues/1159&quot;&gt;re-written from scratch&lt;/a&gt; to be based on Solo5, and now supports PVHv2 on Xen 4.10 or higher, and QubesOS 4.0.
&lt;/li&gt;
&lt;li&gt;As part of this re-write, the existing Mini-OS based implementation has been retired, and all non-UNIX backends now use a unified OCaml runtime based on &lt;code&gt;ocaml-freestanding&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;OCaml runtime settings settable via the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable are now exposed as unikernel boot parameters. For details, refer to &lt;a href=&quot;https://github.com/mirage/mirage/pull/1180&quot;&gt;#1180&lt;/a&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Security posture improvements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;With the move to a unified Solo5 and ocaml-freestanding base MirageOS unikernels on Xen gain several notable improvements to their overall security posture such as SSP for all C code, W^X, and malloc heap canaries. For details, refer to the mirage-xen 6.0.0 release &lt;a href=&quot;https://github.com/mirage/mirage-xen/releases/tag/v6.0.0&quot;&gt;announcement&lt;/a&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;API breaking changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Several Xen-specific APIs have been removed or replaced, unikernels using these may need to be updated. For details, refer to the mirage-xen 6.0.0 release &lt;a href=&quot;https://github.com/mirage/mirage-xen/releases/tag/v6.0.0&quot;&gt;announcement&lt;/a&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Other notable changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Mirage_runtime&lt;/code&gt; provides event loop enter and exit hook registration (&lt;a href=&quot;https://github.com/mirage/mirage/pull/1010&quot;&gt;#1010&lt;/a&gt;).
&lt;/li&gt;
&lt;li&gt;All MirageOS backends now behave similarly on a successful exit of the unikernel: they call &lt;code&gt;exit&lt;/code&gt; with the return value 0, thus &lt;code&gt;at_exit&lt;/code&gt; handlers are now executed (&lt;a href=&quot;https://github.com/mirage/mirage/pull/1011&quot;&gt;#1011&lt;/a&gt;).
&lt;/li&gt;
&lt;li&gt;The unix backend used a toplevel exception handler, which has been removed. All backends now behave equally with respect to exceptions.
&lt;/li&gt;
&lt;li&gt;Please note that the &lt;code&gt;Mirage_net.listen&lt;/code&gt; function still installs an exception handler, which will be removed in a future release. The out of memory exception is no longer caught by &lt;code&gt;Mirage_net.listen&lt;/code&gt; (&lt;a href=&quot;https://github.com/mirage/mirage/issues/1036&quot;&gt;#1036&lt;/a&gt;).
&lt;/li&gt;
&lt;li&gt;To reduce the number of OPAM packages, the &lt;code&gt;mirage-*-lwt&lt;/code&gt; packages are now deprecated. &lt;code&gt;Mirage_net&lt;/code&gt; (and others) now use &lt;code&gt;Lwt.t&lt;/code&gt; directly, and their &lt;code&gt;buffer&lt;/code&gt; type is &lt;code&gt;Cstruct.t&lt;/code&gt; (&lt;a href=&quot;https://github.com/mirage/mirage/issues/1004&quot;&gt;#1004&lt;/a&gt;).
&lt;/li&gt;
&lt;li&gt;OPAM files generated by &lt;code&gt;mirage configure&lt;/code&gt; now include opam build and installation instructions, and also an URL to the Git &lt;code&gt;origin&lt;/code&gt; (&lt;a href=&quot;https://github.com/mirage/mirage/pull/1022&quot;&gt;#1022&lt;/a&gt;).
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Known issues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mirage configure&lt;/code&gt; fails if the unikernel is under version control and no &lt;code&gt;origin&lt;/code&gt; remote is present (&lt;a href=&quot;https://github.com/mirage/mirage/issues/1188&quot;&gt;#1188&lt;/a&gt;).
&lt;/li&gt;
&lt;li&gt;The Xen backend has issues with event delivery if built with an Alpine Linux GCC toolchain. As a work-around, please use a Fedora or Debian based toolchain.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Acknowledgements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Thanks to Roger Pau Monn&amp;eacute;, Andrew Cooper and other core Xen developers for help with understanding the specifics of how Xen PVHv2 works, and how to write an implementation from scratch.
&lt;/li&gt;
&lt;li&gt;Thanks to Marek Marczykowski-G&amp;oacute;recki for help with the QubesOS specifics, and for forward-porting some missing parts of PVHv2 to QubesOS version of Xen.
&lt;/li&gt;
&lt;li&gt;Thanks to @palainp on Github for help with testing on QubesOS.
&lt;/li&gt;
&lt;/ul&gt;

      </content><id>https://mirage.io/blog/announcing-mirage-39-release</id><title type="text">Announcing MirageOS 3.9.0</title><updated>2020-10-27T00:00:00-00:00</updated><author><name>Martin Lucina</name></author></entry><entry><link href="https://mirage.io/blog/tls-1-3-mirageos" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We are pleased to announce that &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS 1.3&lt;/a&gt; support for MirageOS is available. With
mirage 3.7.7 and tls 0.12 the &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;Transport Layer Security (TLS) Protocol Version 1.3&lt;/a&gt;
is available in all MirageOS unikernels, including on our main website. If you're reading this, you've likely established a TLS 1.3 connection already :)&lt;/p&gt;
&lt;p&gt;Getting there was some effort: we now embed the Coq-verified &lt;a href=&quot;https://github.com/mirage/fiat/&quot;&gt;fiat&lt;/a&gt;
library (from &lt;a href=&quot;https://github.com/mit-plv/fiat-crypto/&quot;&gt;fiat-crypto&lt;/a&gt;) for the P-256 elliptic curve, and the F*-verified &lt;a href=&quot;https://github.com/mirage/hacl&quot;&gt;hacl&lt;/a&gt;
library (from &lt;a href=&quot;https://project-everest.github.io/&quot;&gt;Project Everest&lt;/a&gt;) for the X25519 elliptic curve to establish 1.3 handshakes with ECDHE.&lt;/p&gt;
&lt;p&gt;Part of our TLS 1.3 stack is support for pre-shared keys, and 0 RTT. If you're keen to try these features, please do so and report any issues you encounter &lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;to our issue tracker&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We are still lacking support for RSA-PSS certificates and EC certificates, post-handshake authentication, and the chacha20-poly1305 ciphersuite. There is also a &lt;a href=&quot;https://github.com/mirage/hacl/issues/32&quot;&gt;minor symbol clash&lt;/a&gt; with the upstream F* C bindings which we are aware of. We will continue to work on these, and patches are welcome.&lt;/p&gt;

      </content><id>https://mirage.io/blog/tls-1-3-mirageos</id><title type="text">TLS 1.3 support for MirageOS</title><updated>2020-05-20T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/ccc-2019-leipzig" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;em&gt;By Damien Leloup, special correspondent, Le Monde. Originally &lt;a href=&quot;https://www.lemonde.fr/pixels/article/2019/12/30/a-leipzig-hackers-et-militants-pour-le-climat-font-front-commun_6024362_4408996.html&quot;&gt;published&lt;/a&gt; by Le Monde on December 30, 2019. English translation by the MirageOS Core Team.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Chaos Communication Congress, the world's largest self-managed event dedicated to IT security, hosted its 36th edition this weekend in Germany.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In front of Leipzig station, around fifty students and high school students are gathered.  It's Sunday, but the local branch of the Fridays for Future movement, which organizes demonstrations on Fridays at the call of activist Greta Thunberg, made an exception to its usual calendar to take advantage of the presence, a few kilometers from there, of the Chaos Communication Congress (CCC).&lt;/p&gt;
&lt;p&gt;Organized each year for thirty-six years, this gigantic gathering of hackers and activists - 18,000 participants, dozens of conference talks around the clock - invades the Leipzig convention center for four days, in an atmosphere that is both anarcho-libertarian and very family oriented.  For the first time, the slogan of the 2019 edition is devoted to the environment: &amp;ldquo;Resource exhaustion&amp;rdquo;, a reference both to a computer &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_exhaustion_attack&quot;&gt;attack technique&lt;/a&gt; and to the preservation of the planet.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;quot;It makes sense: it's a major issue, and the environmental movement is a highlight of the year, isn't it?&amp;quot;&lt;/em&gt;, notes, hair dyed pink and megaphone in hand, Rune, one of the organizers of the event. &lt;em&gt;&amp;ldquo;In any case, we are very happy that the CCC opened its doors to us and supports us.&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The conference program gave pride of place to ecological themes and organizations such as Fridays for Future or Extinction Rebellion. These themes were all features in the main talks.  The audience for the event, marked on the far left, is quite sensitive to environmental issues.  &lt;a href=&quot;https://www.fridaysforfuture.org/&quot;&gt;Fridays for Future's&lt;/a&gt; review of the year was sold out;  the track where some scientists explained how they build their climate models was full and was not able to host all the attendees.&lt;/p&gt;
&lt;h2&gt;Safety of power plants and the right to repair&lt;/h2&gt;
&lt;p&gt;But if the CCC has given a lot of space to environmental issues, it has done it in its own way.  In this mecca of cyber-security, we could for example discover long lists of vulnerabilities affecting the on-board systems used to manage the turbines of power plants. &lt;em&gt;Do not&lt;/em&gt; panic: &lt;em&gt;&amp;quot;These flaws do not block a power plant, or cut the power of a city,&amp;quot;&lt;/em&gt; relativized Radu Motspan, the author of the study.  Some of them have been corrected;  for others, it is up to plant managers to carry out verifications.  The researcher and his associates produced a small turnkey guide to help them: &lt;em&gt;&amp;ldquo;No need to hire expensive consultants, you can do everything yourself.&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This &amp;ldquo;do it yourself&amp;rdquo; spirit, omnipresent in hacker culture in general and at the CCC in particular, easily lends itself to an environmental translation.  The collective &lt;a href=&quot;https://runder-tisch-reparatur.de/&quot;&gt;Runder Tisch Reparatur&lt;/a&gt;, which campaigns for the adoption at European level of a &amp;quot;right to repair&amp;quot;, was thus invited for the first time to the conference.  The philosophy of the movement, which aims above all to reduce the amount of waste produced by obsolescence whether or not it is programmed, is very similar to that of the free software movement, say Eduard and Erik, who run the stand of the association. &lt;em&gt;&amp;quot;An object that you cannot repair does not really belong to you,&amp;quot;&lt;/em&gt; they believe, just as the promoters of free software believe that software that you cannot modify yourself deprives you of certain freedoms.&lt;/p&gt;
&lt;p&gt;But the main issue, at the heart of many talks during the four days of the CCC, is that of the energy impact of the Internet.  No one in the aisles of the Leipzig congress center plans to reduce their use of the Internet;  but everyone concedes that the network consumes a lot of electricity unnecessarily, or uses too much fossil energy.  &lt;em&gt;&amp;quot;There are simple things to do to improve the carbon footprint of a site or service,&amp;quot;&lt;/em&gt; said Chris Adams, environmental activist and member of the Green Web Foundation.  &lt;em&gt;&amp;ldquo;If your service uses Amazon Web Service [AWS, a very popular cloud service], you can choose the data center you want to use, for example.  The one assigned to you by default may be in a country that produces little renewable electricity and uses a lot of coal for its power plants&amp;hellip; &amp;rdquo;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Existing non-digital systems (like boilers) already have ways to function more efficiently, such as off-peak hours at night, when electricity is both cheaper and more eco-friendly. There are equivalent options for more modern, digital systems, for instance: Chris Adams advocates the use of the &lt;a href=&quot;http://ceur-ws.org/Vol-2382/ICT4S2019_paper_28.pdf&quot;&gt;Low Carbon Kubernetes Scheduler&lt;/a&gt;, an orchestration tool which allows to optimise the power consumption of a server in order to reduce its environmental impact.&lt;/p&gt;
&lt;h2&gt;Safety and minimum consumption, get the best of both worlds&lt;/h2&gt;
&lt;p&gt;Despite everything, the &amp;ldquo;greenest&amp;rdquo; electricity remains that which we do not consume in the first place.  There too, promising solutions exist: &lt;a href=&quot;https://hannes.nqsb.io/&quot;&gt;Hannes Mehnert&lt;/a&gt;, a German computer scientist, presented at the opening of the CCC the MirageOS project, an operating system for ultra-minimalist servers, coded in a language renowned for its lightness, and which runs each process in a dedicated virtual machine.  A radical approach - and reserved for connoisseurs - which allows the software to embed only the bare minimum of lines of code in each compiled version. &lt;em&gt;&amp;quot;Reducing complexity mathematically reduces the number of calculation operations required,&amp;quot;&lt;/em&gt; explains Mehnert.  Result: &lt;em&gt;&amp;quot;A carbon footprint that drops drastically, with ten times less computing power used by the processor, and up to twenty-five times less memory used&amp;quot;&lt;/em&gt;, according to his measurements.&lt;/p&gt;
&lt;p&gt;Above all, and this is a strong argument at a conference dedicated to computer security, minimalism is also a real advantage in terms of potential vulnerabilities: the more compact the code is, the less it risks containing flaws or errors.  And such systems are also better protected and safer than more conventional systems, as they are not vulnerable to memory-safety issues.&lt;/p&gt;
&lt;p&gt;But the collaboration between environmentalists and privacy advocates seemed much broader than just focusing on technical issues. That mix was everywhere: for instance the corridor walls had graffiti concerned with the the excessive consumption of CO2 on the planet close to others highlighting the fact that every human being generates, on average, 1.7 MB of data per second. The posters of the anarchist or anti-fascist movements were also mixed with the flyers of the collective Hackers against &lt;a href=&quot;https://hacc.uber.space/Main_Page&quot;&gt;Climate Change&lt;/a&gt;, which attracted the curious with a joke typical of the place: &lt;em&gt;&amp;quot;cli / mate crisis is real&amp;quot;&lt;/em&gt;, in reference to Club-Mate, an ubiquitous drink at the event.&lt;/p&gt;
&lt;p&gt;This community of views between hackers and climate activists comes as little surprise in Germany, where both movements are very present, and even less in Leipzig, the flagship city of the former GDR where pre-Internet mass surveillance tools from the Stasi were also directed against environmental activists in the 1980s. Some environmental movements feel naturally close to the anarchist spirit of the German hackers of the Chaos Computer Club, which organizes the CCC: a talk by &lt;a href=&quot;https://rebellion.earth/&quot;&gt;Extinction Rebellion&lt;/a&gt; detailed the security measures they took to ensure their privacy, and how they didn't depend on third-party tools from Facebook, Google or Amazon - responsible, in their eyes, both for mass surveillance and &lt;em&gt;green washing&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;However, in this atmosphere of global collaboration some questions remained unanswered.  In some specific cases, better IT security can also consume more resources.  A talk dedicated to encrypted messaging thus presented many tools which make it possible to reinforce the confidentiality of exchanges, but also require using more computing power, to encrypt or decrypt messages, or even request the sending of large quantities of data to scramble the origin or volume of a message.  This first CCC under the sign of environmental protection did not really address this contradiction - pending, perhaps, a next edition?&lt;/p&gt;

      </content><id>https://mirage.io/blog/ccc-2019-leipzig</id><title type="text">Hackers and climate activists join forces in Leipzig</title><updated>2020-01-08T00:00:00-00:00</updated><author><name>Damien Leloup</name></author></entry><entry><link href="https://mirage.io/blog/introducing-irmin-v2" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We are pleased to announce &lt;a href=&quot;https://github.com/mirage/irmin/releases&quot;&gt;Irmin
2.0.0&lt;/a&gt;, a major release of the
Git-like distributed branching and storage substrate that underpins MirageOS.
We began the release process for all the components that make up Irmin &lt;a href=&quot;https://tarides.com/blog/2019-05-13-on-the-road-to-irmin-v2&quot;&gt;back in
May 2019&lt;/a&gt;, and
there have been close to 1000 commits since Irmin 1.4.0 release back in June
2018. To celebrate this milestone, we have a new logo and opened a dedicated
website: &lt;a href=&quot;https://irmin.org&quot;&gt;irmin.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can read more details about the new features in the &lt;a href=&quot;https://tarides.com/blog/2019-11-21-irmin-v2&quot;&gt;Irmin v2 blog
post&lt;/a&gt;.  Enjoy the new release,
and stay tuned for the upcoming Wodan integration in 2020 that will be a stable
filesystem for the hypervisor targets for MirageOS that do not have a
conventional OS kernel underneath them!&lt;/p&gt;

      </content><id>https://mirage.io/blog/introducing-irmin-v2</id><title type="text">Announcing Irmin 2.0.0</title><updated>2019-11-26T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage-36-release" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We are pleased to announce the release of MirageOS 3.6.0. This release updates MirageOS to support &lt;a href=&quot;https://github.com/Solo5/solo5&quot;&gt;Solo5&lt;/a&gt; 0.6.0 and later.&lt;/p&gt;
&lt;p&gt;New features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Support for the Solo5 &lt;code&gt;spt&lt;/code&gt; (sandboxed process tender) target via &lt;code&gt;mirage configure -t spt&lt;/code&gt;. The &lt;code&gt;spt&lt;/code&gt; target runs MirageOS unikernels in a minimal strict seccomp sandbox on Linux &lt;code&gt;x86_64&lt;/code&gt;, &lt;code&gt;aarch64&lt;/code&gt; and &lt;code&gt;ppc64le&lt;/code&gt; hosts.
&lt;/li&gt;
&lt;li&gt;Support for the Solo5 &lt;em&gt;application manifest&lt;/em&gt;, enabling support for multiple network and block storage devices on the &lt;code&gt;hvt&lt;/code&gt;, &lt;code&gt;spt&lt;/code&gt; and &lt;code&gt;muen&lt;/code&gt; targets. The &lt;code&gt;genode&lt;/code&gt; and &lt;code&gt;virtio&lt;/code&gt; targets are still limited to using a single network or block storage device.
&lt;/li&gt;
&lt;li&gt;Several notable security enhancements to Solo5 targets, such as enabling stack smashing protection throughout the toolchain by default and improved page protections on some targets.  For details, please refer to the Solo5 0.6.0 &lt;a href=&quot;https://github.com/Solo5/solo5/releases/tag/v0.6.0&quot;&gt;release notes&lt;/a&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additional user-visible changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Solo5 0.6.0 has removed the compile-time specialization of the &lt;code&gt;solo5-hvt&lt;/code&gt; tender. As a result, a &lt;code&gt;solo5-hvt&lt;/code&gt; binary is no longer built at &lt;code&gt;mirage build&lt;/code&gt; time. Use the &lt;code&gt;solo5-hvt&lt;/code&gt; binary installed in your &lt;code&gt;$PATH&lt;/code&gt; by OPAM to run the unikernel.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mirage build&lt;/code&gt; now produces silent &lt;code&gt;ocamlbuild&lt;/code&gt; output by default. To get the old behaviour, run with &lt;code&gt;--verbose&lt;/code&gt; or set the log level to &lt;code&gt;info&lt;/code&gt; or &lt;code&gt;debug&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;New functions &lt;code&gt;Mirage_key.is_solo5&lt;/code&gt; and &lt;code&gt;Mirage_key.is_xen&lt;/code&gt;, analogous to &lt;code&gt;Mirage_key.is_unix&lt;/code&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks to Hannes Mehnert for help with the release engineering for MirageOS 3.6.0.&lt;/p&gt;

      </content><id>https://mirage.io/blog/announcing-mirage-36-release</id><title type="text">Announcing MirageOS 3.6.0</title><updated>2019-10-18T00:00:00-00:00</updated><author><name>Martin Lucina</name></author></entry><entry><link href="https://mirage.io/blog/MSA02" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;h2&gt;MirageOS Security Advisory 02 - grant unshare vulnerability in mirage-xen&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Module:       mirage-xen
&lt;/li&gt;
&lt;li&gt;Announced:    2019-04-25
&lt;/li&gt;
&lt;li&gt;Credits:      Thomas Leonard, Mindy Preston
&lt;/li&gt;
&lt;li&gt;Affects:      mirage-xen &amp;lt; 3.3.0,
mirage-block-xen &amp;lt; 1.6.1,
mirage-net-xen &amp;lt; 1.10.2,
mirage-console &amp;lt; 2.4.2,
ocaml-vchan &amp;lt; 4.0.2,
ocaml-gnt (no longer supported)
&lt;/li&gt;
&lt;li&gt;Corrected:    2019-04-22: mirage-xen 3.4.0,
2019-04-05: mirage-block-xen 1.6.1,
2019-04-02: mirage-net-xen 1.10.2,
2019-03-27: mirage-console 2.4.2,
2019-03-27: ocaml-vchan 4.0.2
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For general information regarding MirageOS Security Advisories,
please visit &lt;a href=&quot;https://mirage.io/security&quot;&gt;https://mirage.io/security&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;MirageOS is a library operating system using cooperative multitasking, which can
be executed as a guest of the Xen hypervisor. Virtual machines running on a Xen
host can communicate by sharing pages of memory. For example, when a Mirage VM
wants to use a virtual network device provided by a Linux dom0:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The Mirage VM reserves some of its memory for this purpose and writes an entry
to its &lt;em&gt;grant table&lt;/em&gt; to say that dom0 should have access to it.
&lt;/li&gt;
&lt;li&gt;The Mirage VM tells dom0 (via XenStore) about the grant.
&lt;/li&gt;
&lt;li&gt;dom0 asks Xen to map the memory into its address space.
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The Mirage VM and dom0 can now communicate using this shared memory.
When dom0 has finished with the memory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dom0 tells Xen to unmap the memory from its address space.
&lt;/li&gt;
&lt;li&gt;dom0 tells the Mirage VM that it no longer needs the memory.
&lt;/li&gt;
&lt;li&gt;The Mirage VM removes the entry from its grant table.
&lt;/li&gt;
&lt;li&gt;The Mirage VM may reuse the memory for other purposes.
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Problem Description&lt;/h3&gt;
&lt;p&gt;Mirage removes the entry by calling the &lt;a href=&quot;https://github.com/mirage/mini-os/blob/94cb25eb73e58e5c825c1ad5f6cf3d2647603a50/gnttab.c#L98&quot;&gt;gnttab_end_access&lt;/a&gt; function in Mini-OS.
This function checks whether the remote domain still has the memory mapped. If so,
it returns 0 to indicate that the entry cannot be removed yet. To make this function
available to OCaml code, the &lt;a href=&quot;https://github.com/mirage/mirage-xen/blob/v3.2.0/bindings/gnttab_stubs.c#L227&quot;&gt;stub_gntshr_end_access&lt;/a&gt; C stub in mirage-xen wrapped this
with the OCaml calling conventions. Unfortunately, it ignored the return code and reported
success in all cases.&lt;/p&gt;
&lt;h3&gt;Impact&lt;/h3&gt;
&lt;p&gt;A malicious VM can tell a MirageOS unikernel that it has finished using some
shared memory while it is still mapped. The Mirage unikernel will think that
the unshare operation has succeeded and may reuse the memory, or allow it to be
garbage collected. The malicious VM will still have access to the memory.&lt;/p&gt;
&lt;p&gt;In many cases (such as in the example above) the remote domain will be dom0,
which is already fully trusted. However, if a unikernel shares memory with an
untrusted domain then there is a problem.&lt;/p&gt;
&lt;h3&gt;Workaround&lt;/h3&gt;
&lt;p&gt;No workaround is available.&lt;/p&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;Returning the result from the C stub required changes to the OCaml grant API to
deal with the result. This turned out to be difficult because, for historical
reasons, the OCaml part of the API was in the ocaml-gnt package while the C stubs
were in mirage-xen, and because the C stubs are also shared with the Unix backend.&lt;/p&gt;
&lt;p&gt;We instead created a &lt;a href=&quot;https://github.com/mirage/mirage-xen/pull/9&quot;&gt;new grant API&lt;/a&gt; in mirage-xen, migrated all existing
Mirage drivers to use it, and then dropped support for the old API.
mirage-xen 3.3.0 added support for the new API and 3.4.0 removed support for the
old one.&lt;/p&gt;
&lt;p&gt;The recommended way to upgrade is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;opam update
opam upgrade mirage-xen
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Correction details&lt;/h3&gt;
&lt;p&gt;The following PRs were part of the fix:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-xen/pull/9&quot;&gt;mirage-xen/pull/9&lt;/a&gt; - Add grant-handling code to OS.Xen
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-net-xen/pull/85&quot;&gt;mirage-net-xen/pull/85&lt;/a&gt; - Use new OS.Xen API for grants
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-vchan/pull/125&quot;&gt;ocaml-vchan/pull/125&lt;/a&gt; - Update to new OS.Xen grant API
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-block-xen/pull/79&quot;&gt;mirage-block-xen/pull/79&lt;/a&gt; - Port to new grant interface provided by mirage-xen
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-console/pull/75&quot;&gt;mirage-console/pull/75&lt;/a&gt; - Use new grant interface in mirage-xen
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-xen/pull/12&quot;&gt;mirage-xen/pull/12&lt;/a&gt; - Drop support for old ocaml-gnt package
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;You can find the latest version of this advisory online at
&lt;a href=&quot;https://mirage.io/blog/MSA02&quot;&gt;https://mirage.io/blog/MSA02&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This advisory is signed using OpenPGP, you can verify the signature
by downloading our public key from a keyserver (&lt;code&gt;gpg --recv-key 4A732D757C0EDA74&lt;/code&gt;),
downloading the raw markdown source of this advisory from
&lt;a href=&quot;https://raw.githubusercontent.com/mirage/mirage-www/master/tmpl/advisories/02.txt.asc&quot;&gt;GitHub&lt;/a&gt;
and executing &lt;code&gt;gpg --verify 02.txt.asc&lt;/code&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/MSA02</id><title type="text">MirageOS security advisory 02: mirage-xen &lt; 3.3.0</title><updated>2019-04-26T00:00:00-00:00</updated><author><name>Thomas Leonard</name></author></entry><entry><link href="https://mirage.io/blog/2019-spring-retreat-roundup" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Early March 2019, 31 MirageOS hackers gathered again in Marrakesh for our bi-annual hack retreat. We'd like to thank our amazing hosts, and everyone who participated on-site or remotely, and especially those who wrote up their experiences.
&lt;img src=&quot;https://mirage.io/graphics/spring2019.jpg&quot; style=&quot;glot:right; padding: 15px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;On this retreat, we ate our own dogfood, and used our MirageOS &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/tree/master/applications/dhcp&quot;&gt;DHCP&lt;/a&gt;, &lt;a href=&quot;https://github.com/roburio/unikernels/tree/master/resolver&quot;&gt;recursive DNS resolver&lt;/a&gt;, and &lt;a href=&quot;https://github.com/roburio/caldav&quot;&gt;CalDAV&lt;/a&gt; unikernels as isolated virtual machines running on a &lt;a href=&quot;https://pcengines.ch/apu2c4.htm&quot;&gt;PC Engines APU&lt;/a&gt; with &lt;a href=&quot;https://freebsd.org&quot;&gt;FreeBSD&lt;/a&gt; as host system. The CalDAV server persisted its data in a git repository on the host system, using the raw git protocol for communication, the smart HTTP protocol could have been used as well. Lynxis wrote a &lt;a href=&quot;https://lunarius.fe80.eu/blog/mirageos-2019.html&quot;&gt;detailed blog post about our uplink situation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Lots of interesting discussions took place, code was developed, knowledge was exchanged, and issues were solved while we enjoyed the sun and the Moroccan food. The following list is not exhaustive, but gives an overview what was pushed forward.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/rlepigre/ocaml-imagelib&quot;&gt;Imagelib&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Imagelib is a library that can parse several image formats, and &lt;a href=&quot;https://github.com/cfcs/eye-of-mirage&quot;&gt;eye-of-mirage&lt;/a&gt; uses it to display those images in a &lt;a href=&quot;https://github.com/cfcs/mirage-framebuffer/&quot;&gt;framebuffer&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;During the retreat, imagelib was extended with &lt;a href=&quot;https://github.com/rlepigre/ocaml-imagelib/pull/22&quot;&gt;support for the BMP format&lt;/a&gt;, it's &lt;a href=&quot;https://github.com/rlepigre/ocaml-imagelib/pull/23&quot;&gt;build system was revised to split off Unix-dependent functionality&lt;/a&gt;, and preliminary support for the GIF format was implemented.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/kit-ty-kate/ocaml-activitypub&quot;&gt;ActivityPub&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ActivityPub is an open, decentralized social networking protocol, as used by &lt;a href=&quot;https://mastodon.social&quot;&gt;mastodon&lt;/a&gt;. It provides a client/server API for creating, updating, and deleting content, and a federated server-to-server API for notifications and content delivery. During the retreat, an initial prototype of a protocol implementation was drafted.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/ocaml/opam&quot;&gt;opam&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Opam, the OCaml package manager, was extended in several directions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rjbou/opam/tree/depext&quot;&gt;External (OS package system) dependency integration&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/opam/pull/3777&quot;&gt;Interleaving download with build/install actions&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/opam/pull/3778&quot;&gt;Generalisation of the job scheduler&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/opam/pull/3776&quot;&gt;JSON serialisation, including crowbar round-trip tests&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;Plugin evaluating (binary) &lt;a href=&quot;https://reproducible-builds.org/&quot;&gt;reproducibility&lt;/a&gt; of opam packages
&lt;/li&gt;
&lt;li&gt;some smaller cleanup PRs (&lt;a href=&quot;https://github.com/ocaml/opam/pull/3781&quot;&gt;return values&lt;/a&gt;, &lt;a href=&quot;https://github.com/ocaml/opam/pull/3783&quot;&gt;locking code&lt;/a&gt;)
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/Armael/marracheck/&quot;&gt;marracheck&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Work was started on a new utility to install as many opam packages as possible on a machine (there just wasn't enough choice with &lt;a href=&quot;https://github.com/OCamlPro/opam-builder&quot;&gt;opam-builder&lt;/a&gt;, &lt;a href=&quot;https://github.com/damiendoligez/opamcheck&quot;&gt;opamcheck&lt;/a&gt; and &lt;a href=&quot;https://github.com/kit-ty-kate/opam-check-all&quot;&gt;opam-check-all&lt;/a&gt;). It uses opam-lib and Z3 to accomplish this.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/hannesm/conex&quot;&gt;Conex&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Conex is used for signing community repositories, esp. the opam-repository. Any opam package author can cryptographically sign their package releases, and users can verify that the downloaded tarball and build instructions are identical to what the author intended.&lt;/p&gt;
&lt;p&gt;Conex has been developed since 2015, but is not yet widely deployed. We extended &lt;a href=&quot;https://github.com/ocaml/opam-publish&quot;&gt;opam-publish&lt;/a&gt; to invoke the &lt;code&gt;conex_targets&lt;/code&gt; utility and sign before opening a pull request on the opam-repository.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/clecat/colombe&quot;&gt;SMTP&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The simple mail transfer protocol is an Internet standard for sending and receiving eMail. Our OCaml implementation has been improved, and it is possible to send eMails from OCaml code now.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/anmonteiro/ocaml-h2&quot;&gt;HTTP2&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The hypertext transfer protocol is an Internet standard widely used for browsing the world wide web. HTTP 1.1 is a line-based protocol which was specified 20 years ago. HTTP2 is an attempt to fix various shortcomings, and uses a binary protocol with multiplexing, priorities, etc. An OCaml implementation of HTTP2 has been actively worked on in Marrakesh.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Irmin is a distributed database that follows the same design principles as git. Soon, Irmin 2.0 will be released, which includes GraphQL, HTTP, chunk support, and can use the git protocol for interoperability. Irmin provides a key-value interface for MirageOS.&lt;/p&gt;
&lt;h2&gt;OCaml compiler&lt;/h2&gt;
&lt;p&gt;Some hints on type errors for &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/2301&quot;&gt;int literals&lt;/a&gt; and &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/2307&quot;&gt;int operators&lt;/a&gt; were developed and merged to the OCaml compiler.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 1.5 +. 2;;
         ^
Error: This expression has type int but an expression was expected of type
         float
       Hint: Did you mean `2.'?

# 1.5 + 2.;;
  ^^^ ^
Error: This expression has type float but an expression was expected of type
         int
Line 1, characters 4-5:
  Hint: Did you mean to use `+.'?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also, the &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/608&quot;&gt;whole program dead code elimination&lt;/a&gt; PR was rebased onto trunk.&lt;/p&gt;
&lt;h2&gt;BGP / lazy trie&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/mor1/mrt-format&quot;&gt;mrt-format&lt;/a&gt; library which can parse multi-threaded routing toolkit traces, has been adapted to the modern OCaml ecosystem. The &lt;a href=&quot;https://github.com/jimyuan1995/Mirage-BGP&quot;&gt;border gateway protocol (BGP)&lt;/a&gt; library was slightly updated, one of its dependencies, &lt;a href=&quot;https://github.com/mirage/ocaml-lazy-trie&quot;&gt;lazy-trie&lt;/a&gt; was adapted to the modern ecosystem as well.&lt;/p&gt;
&lt;h2&gt;Xen PVH&lt;/h2&gt;
&lt;p&gt;Xen provides several modes for virtualization.  MirageOS's first non-Unix target was the para-virtualized (PV) mode for Xen, which does not require hardware support from the hypervisor's host operating system but has a weak security profile (static mapping of addresses, large attack surface).  However, PV mode provides an attractive target for unikernels because it provides a simple software-based abstraction for dealing with drivers and a simple memory model; this is in contrast to hardware-virtualization mode, which provides greater security but requires more work from the guest OS.&lt;/p&gt;
&lt;p&gt;A more modern virtualization mode combining the virtues of both approaches is PVH (formerly referred to as HVMLite), which is not yet supported by MirageOS.  Marek Marczykowski-G&amp;oacute;recki from the &lt;a href=&quot;https://qubes-os.org&quot;&gt;QubesOS&lt;/a&gt; project visited to help us bring PVH support to the &lt;a href=&quot;https://xenproject.org/developers/teams/unikraft/&quot;&gt;unikraft project&lt;/a&gt;, a common platform for building unikernels which we hope to use for MirageOS's Xen support in the future.&lt;/p&gt;
&lt;p&gt;During the retreat, lots of bugs porting MirageOS to PVH were solved. It boots and crashes now!&lt;/p&gt;
&lt;h2&gt;Learn OCaml as a unikernel&lt;/h2&gt;
&lt;p&gt;The platform learn OCaml embeds an editor, top-level, and exercises into a HTTP server, and allows students to learn OCaml, and submit solutions via the web interface, where an automated grader runs unit tests etc. to evaluate the submitted solutions. Teachers can assign mandatory exercises, and have an overview how the students are doing. Learn OCaml used to be executable only on a Unix host, but is now beeing ported into a MirageOS unikernel, executable as a standalone virtual machine.&lt;/p&gt;
&lt;h2&gt;Network device driver (ixy)&lt;/h2&gt;
&lt;p&gt;The ixy network driver supports Intel 82599 network interface cards, and &lt;a href=&quot;https://github.com/ixy-languages/ixy.ml&quot;&gt;is implemented in OCaml&lt;/a&gt;. Its performance has been improved, including several failing attempts which degraded its performance. Also, &lt;a href=&quot;https://github.com/mirage/mirage/pull/977&quot;&gt;it has been integrated into the mirage tool&lt;/a&gt; and is usable as a &lt;a href=&quot;https://github.com/mirage/mirage-net&quot;&gt;mirage-net&lt;/a&gt; implementation.&lt;/p&gt;
&lt;h2&gt;DNS client API&lt;/h2&gt;
&lt;p&gt;Our proposed API is &lt;a href=&quot;https://github.com/roburio/udns/blob/09c5e3c74c92505ec97f2a16818cc8a030e2868f/client/udns_client_flow.mli#L53-L80&quot;&gt;described here&lt;/a&gt;. Unix, Lwt, and MirageOS implementations are already available.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/mirage/mirage-http&quot;&gt;mirage-http&lt;/a&gt; unified HTTP API&lt;/h2&gt;
&lt;p&gt;Since we now have two HTTP servers, &lt;a href=&quot;https://github.com/mirage/ocaml-cohttp&quot;&gt;cohttp&lt;/a&gt; and &lt;a href=&quot;https://github.com/inhabitedtype/httpaf&quot;&gt;httpaf&lt;/a&gt;, in OCaml and MirageOS available, the new interface &lt;a href=&quot;https://github.com/mirage/mirage-http&quot;&gt;mirage-http&lt;/a&gt; provides a unified interface, and also supports connection upgrades to websockets.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-cstruct&quot;&gt;cstruct&lt;/a&gt; capabilities&lt;/h2&gt;
&lt;p&gt;We use cstruct, a wrapper around OCaml's &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.html&quot;&gt;Bigarray&lt;/a&gt;, quite a lot in MirageOS. Until now, cstruct is a readable and writable byte array. We used phantom types to &lt;a href=&quot;https://github.com/mirage/ocaml-cstruct/pull/237&quot;&gt;add capabilities&lt;/a&gt; to the interface to distinct read-only and write-only buffers.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/hannesm/patch&quot;&gt;patch&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;An OCaml implementation to apply unified diffs. This code has been extracted from conex (since we found some issues in it), and still needs to be fixed.&lt;/p&gt;
&lt;h2&gt;Statistical memory profiler&lt;/h2&gt;
&lt;p&gt;Since 2016, Jacques-Henri Jourdan has been working on a &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/847&quot;&gt;statistical memory profiler for OCaml&lt;/a&gt; (read the &lt;a href=&quot;https://jhjourdan.mketjh.fr/pdf/jourdan2016statistically.pdf&quot;&gt;OCaml 2016 paper&lt;/a&gt;). An &lt;a href=&quot;https://github.com/jhjourdan/statmemprof-emacs/&quot;&gt;Emacs user interface&lt;/a&gt; is available since some years. We integrated statmemprof into MirageOS unikernels &lt;a href=&quot;https://github.com/hannesm/statmemprof-mirage&quot;&gt;using the statmemprof-mirage library&lt;/a&gt;, marshal the data via TCP, and provide a proxy that communicates with Emacs over a Unix domain socket, and the unikernel.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://github.com/p2pcollab&quot;&gt;P2Pcollab&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;P2Pcollab is a collection of composable libraries implementing protocols for P2P collaboration.
So far various P2P gossip protocols has been implemented.
At this retreat the focus was on a gossip-based publish-subscribe dissemination protocol.
Future plans include building P2P unikernels and adding P2P pub/sub sync functionality to Irmin.&lt;/p&gt;

      </content><id>https://mirage.io/blog/2019-spring-retreat-roundup</id><title type="text">MirageOS Spring 2019 hack retreat roundup</title><updated>2019-04-03T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/MSA01" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;h2&gt;MirageOS Security Advisory 01 - memory disclosure in mirage-net-xen&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Module:       netchannel
&lt;/li&gt;
&lt;li&gt;Announced:    2019-03-21
&lt;/li&gt;
&lt;li&gt;Credits:      Thomas Leonard, Hannes Mehnert, Mindy Preston
&lt;/li&gt;
&lt;li&gt;Affects:      netchannel = 1.10.0
&lt;/li&gt;
&lt;li&gt;Corrected:    2019-03-20 1.10.1 release
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For general information regarding MirageOS Security Advisories,
please visit &lt;a href=&quot;https://mirage.io/security&quot;&gt;https://mirage.io/security&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;MirageOS is a library operating system using cooperative multitasking, which can
be executed as a guest of the Xen hypervisor.  Virtual devices, such as a
network device, share memory between MirageOS and the hypervisor.  To maintain
adequate performance, the virtual device managing network communication between
MirageOS and the Xen hypervisor maintains a shared pool of pages and reuses
them for write requests.&lt;/p&gt;
&lt;h3&gt;Problem Description&lt;/h3&gt;
&lt;p&gt;In version 1.10.0 of netchannel, the API for handling network requests
changed to provide higher-level network code with an interface for writing into
memory directly.  As part of this change, code paths which exposed memory taken
from the shared page pool did not ensure that previous data had been cleared
from the buffer.  This error resulted in memory which the user did not
overwrite staying resident in the buffer, and potentially being sent as part of
unrelated network communication.&lt;/p&gt;
&lt;p&gt;The mirage-tcpip library, which provides interfaces for higher-level operations
like IPv4 and TCP header writes, assumes that buffers into which it writes have
been zeroed, and therefore may not explicitly write some fields which are always
zero.  As a result, some packets written with netchannel v1.10.0 which were
passed to mirage-tcpip with nonzero data will have incorrect checksums
calculated and will be discarded by the receiver.&lt;/p&gt;
&lt;h3&gt;Impact&lt;/h3&gt;
&lt;p&gt;This issue discloses memory intended for another recipient and corrupts packets.
Only version 1.10.0 of netchannel is affected.  Version 1.10.1 fixes this issue.&lt;/p&gt;
&lt;p&gt;Version 1.10.0 was available for less than one month and many upstream users
had not yet updated their own API calls to use it.  In particular, no version of
qubes-mirage-firewall or its dependency mirage-nat compatible with version
1.10.0 was released.&lt;/p&gt;
&lt;h3&gt;Workaround&lt;/h3&gt;
&lt;p&gt;No workaround is available.&lt;/p&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;Transmitting corrupt data and disclosing memory is fixed in version 1.10.1.&lt;/p&gt;
&lt;p&gt;The recommended way to upgrade is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;opam update
opam upgrade netchannel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or, explicitly:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;opam upgrade
opam reinstall netchannel=1.10.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Affected releases (version 1.10.0 of netchannel and mirage-net-xen) have been marked uninstallable in the opam repository.&lt;/p&gt;
&lt;h3&gt;Correction details&lt;/h3&gt;
&lt;p&gt;The following list contains the correction revision numbers for each
affected branch.&lt;/p&gt;
&lt;p&gt;Memory disclosure on transmit:&lt;/p&gt;
&lt;p&gt;master: &lt;a href=&quot;https://github.com/mirage/mirage-net-xen/commit/6c7a13a5dae0f58dcc0653206a73fa3d8174b6d2&quot;&gt;6c7a13a5dae0f58dcc0653206a73fa3d8174b6d2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.10.0: &lt;a href=&quot;https://github.com/mirage/mirage-net-xen/commit/bd0382eabe17d0824c8ba854ec935d8a2e5f7489&quot;&gt;bd0382eabe17d0824c8ba854ec935d8a2e5f7489&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirage/mirage-net-xen&quot;&gt;netchannel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can find the latest version of this advisory online at
&lt;a href=&quot;https://mirage.io/blog/MSA01&quot;&gt;https://mirage.io/blog/MSA01&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This advisory is signed using OpenPGP, you can verify the signature
by downloading our public key from a keyserver (&lt;code&gt;gpg --recv-key 4A732D757C0EDA74&lt;/code&gt;),
downloading the raw markdown source of this advisory from &lt;a href=&quot;https://raw.githubusercontent.com/mirage/mirage-www/master/tmpl/advisories/01.txt.asc&quot;&gt;GitHub&lt;/a&gt;
and executing &lt;code&gt;gpg --verify 01.txt.asc&lt;/code&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/MSA01</id><title type="text">MirageOS security advisory 01: netchannel 1.10.0</title><updated>2019-03-21T00:00:00-00:00</updated><author><name>Mindy Preston</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage-35-release" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We are happy to announce our MirageOS 3.5.0 release. We didn't announce post 3.0.0 releases too well -- that's why this post tries to summarize the changes in the MirageOS ecosystem over the past two years. MirageOS consists of over 100 opam packages, lots of which are reused in other OCaml projects and deployments without MirageOS. These opam packages are maintained and developed further by lots of developers.&lt;/p&gt;
&lt;p&gt;On the OCaml tooling side, since MirageOS 3.0.0 we did several major changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;moved most packages to &lt;a href=&quot;https://dune.build/&quot;&gt;dune&lt;/a&gt; (formerly jbuilder) and began using &lt;a href=&quot;https://github.com/samoht/dune-release&quot;&gt;dune-release&lt;/a&gt; for smooth developer experience and simple releases,
&lt;/li&gt;
&lt;li&gt;require &lt;a href=&quot;https://opam.ocaml.org&quot;&gt;opam&lt;/a&gt; to be version 2.0.2 or later, allowing &lt;code&gt;pin-depends&lt;/code&gt; in &lt;code&gt;config.ml&lt;/code&gt;. &lt;code&gt;pin-depends&lt;/code&gt; allows you to depend on a development branch of any opam package for your unikernel,
&lt;/li&gt;
&lt;li&gt;adjusted documentation to adhere to &lt;a href=&quot;https://github.com/ocaml/odoc/&quot;&gt;odoc&lt;/a&gt; requirements,
&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;mirage&lt;/code&gt; command-line utility now emits lower and upper bounds of opam packages, allowing uncompromising deprecation of packages,
&lt;/li&gt;
&lt;li&gt;support for OCaml 4.06.0 (and above), where &lt;code&gt;safe-string&lt;/code&gt; is enabled by default. Strings are immutable now!!,
&lt;/li&gt;
&lt;li&gt;remove usage of &lt;code&gt;result&lt;/code&gt; package, which has incorporated into &lt;code&gt;Pervasives&lt;/code&gt; since OCaml 4.03.0.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The 3.5.0 release contains several API improvements of different MirageOS interfaces - if you're developing your own MirageOS unikernels, you may want to read this post to adjust to the new APIs.&lt;/p&gt;
&lt;h2&gt;MirageOS interface API changes:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-clock&quot;&gt;mirage-clock&lt;/a&gt; has the &lt;code&gt;type t&lt;/code&gt; constrained to &lt;code&gt;unit&lt;/code&gt; as of 2.0.0;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-protocols&quot;&gt;mirage-protocols&lt;/a&gt; renames the &lt;code&gt;ETHIF&lt;/code&gt; module type to the clearer &lt;code&gt;ETHERNET&lt;/code&gt;. As of 2.0.0 it also contains keep-alive support, complies with recent TCP/IP layering rework (see below), and IPv4 now supports reassembly and fragmentation;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-net&quot;&gt;mirage-net&lt;/a&gt; reflects revised layering API as of 2.0.0 (see below);
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-kv&quot;&gt;mirage-kv&lt;/a&gt; has a revised API and introduction of a read-write key-value store (see below).
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Major changes&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/mirage/mirage-kv&quot;&gt;Key-value store&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We improved the key-value store API, and added a read-write store. There is also &lt;a href=&quot;https://github.com/mirage/irmin/pull/559&quot;&gt;ongoing work&lt;/a&gt; which implements the read-write interface using irmin, a branchable persistent storage that can communicate via the git protocol. Motivations for these changes were the development of &lt;a href=&quot;https://github.com/roburio/caldav&quot;&gt;CalDAV&lt;/a&gt;, but also the development of &lt;a href=&quot;https://github.com/mirage/wodan&quot;&gt;wodan&lt;/a&gt;, a flash-friendly, safe and flexible filesystem. The goal is to EOL the &lt;a href=&quot;https://github.com/mirage/mirage-fs&quot;&gt;mirage-fs&lt;/a&gt; interface in favour of the key-value store.&lt;/p&gt;
&lt;p&gt;Major API improvements (in &lt;a href=&quot;https://github.com/mirage/mirage-kv/pull/14&quot;&gt;this PR&lt;/a&gt;, since 2.0.0):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;key&lt;/code&gt; is now a path (list of segments) instead of a &lt;code&gt;string&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;value&lt;/code&gt; type is now a &lt;code&gt;string&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;The new function &lt;code&gt;list : t -&amp;gt; key -&amp;gt; (string * [&lt;/code&gt;Value|&lt;code&gt;Dictionary], error) result io&lt;/code&gt; was added
&lt;/li&gt;
&lt;li&gt;The function &lt;code&gt;get : t -&amp;gt; key -&amp;gt; (value, error) result io&lt;/code&gt; is now provided (used to be named &lt;code&gt;read&lt;/code&gt; and requiring an &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; parameter)
&lt;/li&gt;
&lt;li&gt;The functions &lt;code&gt;last_modified : t -&amp;gt; key -&amp;gt; (int * int64, error) result io&lt;/code&gt; and &lt;code&gt;digest : t -&amp;gt; key -&amp;gt; (string, error) result io&lt;/code&gt; have been introduced
&lt;/li&gt;
&lt;li&gt;The function &lt;code&gt;size&lt;/code&gt; was removed.
&lt;/li&gt;
&lt;li&gt;The signature &lt;code&gt;RW&lt;/code&gt; for read-write key-value stores extends &lt;code&gt;RO&lt;/code&gt; with three functions &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;batch&lt;/code&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is now a &lt;a href=&quot;https://github.com/mirage/mirage-kv-mem&quot;&gt;non-persistent in-memory implementation&lt;/a&gt; of a read-write key-value store available. Other implementations (such as &lt;a href=&quot;https://github.com/mirage/ocaml-crunch&quot;&gt;crunch&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/mirage-kv-unix&quot;&gt;mirage-kv-unix&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/mirage-fs&quot;&gt;mirage-fs&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/ocaml-tar&quot;&gt;tar&lt;/a&gt; have been adapted, as well as clients of mirage-kv (dns, cohttp, tls)).&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/mirage/mirage-tcpip&quot;&gt;TCP/IP&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The IPv4 implementation now has support for &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/pull/375&quot;&gt;fragment reassembly&lt;/a&gt;. Each incoming IPv4 fragment is checked for the &amp;quot;more fragments&amp;quot; and &amp;quot;offset&amp;quot; fields. If these are non-zero, the fragment is processed by the &lt;a href=&quot;https://mirage.github.io/mirage-tcpip/tcpip/Fragments/index.html&quot;&gt;fragment cache&lt;/a&gt;, which uses a &lt;a href=&quot;https://github.com/pqwy/lru&quot;&gt;least recently used&lt;/a&gt; data structure of maximum size 256kB content shared by all incoming fragments. If there is any overlap in fragments, the entire packet is dropped (&lt;a href=&quot;https://eprint.iacr.org/2015/1020.pdf&quot;&gt;avoiding security issues&lt;/a&gt;). Fragments may arrive out of order. The code is &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/blob/v3.7.1/test/test_ipv4.ml#L49-L203&quot;&gt;heavily unit-tested&lt;/a&gt;. Each IPv4 packet may at most be in 16 fragments (to minimise CPU DoS with lots of small fragments), the timeout between the first and last fragment is 10 seconds.&lt;/p&gt;
&lt;p&gt;The layering and allocation discipline has been revised. &lt;a href=&quot;https://github.com/mirage/ethernet&quot;&gt;&lt;code&gt;ethernet&lt;/code&gt;&lt;/a&gt; (now encapsulating and decapsulating Ethernet) and &lt;a href=&quot;https://github.com/mirage/arp&quot;&gt;&lt;code&gt;arp&lt;/code&gt;&lt;/a&gt; (the address resolution protocol) are separate opam packages, and no longer part of &lt;code&gt;tcpip&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At the lowest layer, &lt;a href=&quot;https://github.com/mirage/mirage-net&quot;&gt;mirage-net&lt;/a&gt; is the network device. This interface is implemented by our different backends (&lt;a href=&quot;https://github.com/mirage/mirage-net-xen&quot;&gt;xen&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/mirage-net-solo5&quot;&gt;solo5&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/mirage-net-unix&quot;&gt;unix&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/mirage-net-macosx&quot;&gt;macos&lt;/a&gt;, and &lt;a href=&quot;https://github.com/mirage/mirage-vnetif&quot;&gt;vnetif&lt;/a&gt;). Some backends require buffers to be page-aligned when they are passed to the host system. This was previously not really ensured: while the abstract type &lt;code&gt;page_aligned_buffer&lt;/code&gt; was required, &lt;code&gt;write&lt;/code&gt; (and &lt;code&gt;writev&lt;/code&gt;) took the abstract &lt;code&gt;buffer&lt;/code&gt; type (always constrained to &lt;code&gt;Cstruct.t&lt;/code&gt; by mirage-net-lwt). The &lt;code&gt;mtu&lt;/code&gt; (maximum transmission unit) used to be an optional &lt;code&gt;connect&lt;/code&gt; argument to the Ethernet layer, but now it is a function which needs to be provided by mirage-net.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Mirage_net.write&lt;/code&gt; function now has a signature that is explicit about ownership and lifetime: &lt;code&gt;val write : t -&amp;gt; size:int -&amp;gt; (buffer -&amp;gt; int) -&amp;gt; (unit, error) result io&lt;/code&gt;.
It requires a requested &lt;code&gt;size&lt;/code&gt; argument to be passed, and a fill function which is called with an allocated buffer, that satisfies the backend demands. The &lt;code&gt;fill&lt;/code&gt; function is supposed to write to the buffer, and return the length of the frame to be send out. It can neither error (who should handle such an error anyways?), nor is it in the IO monad. The &lt;code&gt;fill&lt;/code&gt; function should not save any references to the buffer, since this is the network device's memory, and may be reused. The &lt;code&gt;writev&lt;/code&gt; function has been removed.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/mirage/mirage-protocols&quot;&gt;Ethernet layer&lt;/a&gt; does encapsulation and decapsulation now. Its &lt;code&gt;write&lt;/code&gt; function has the following signature:
&lt;code&gt;val write: t -&amp;gt; ?src:macaddr -&amp;gt; macaddr -&amp;gt; Ethernet.proto -&amp;gt; ?size:int -&amp;gt; (buffer -&amp;gt; int) -&amp;gt; (unit, error) result io&lt;/code&gt;.
It fills in the Ethernet header with the given source address (defaults to the device's own MAC address) and destination address, and Ethernet protocol. The &lt;code&gt;size&lt;/code&gt; argument is optional, and defaults to the MTU. The &lt;code&gt;buffer&lt;/code&gt; that is passed to the &lt;code&gt;fill&lt;/code&gt; function is usable from offset 0 on. The Ethernet header is not visible at higher layers.&lt;/p&gt;
&lt;p&gt;The IP layer also embeds a revised &lt;code&gt;write&lt;/code&gt; signature:
&lt;code&gt;val write: t -&amp;gt; ?fragment:bool -&amp;gt; ?ttl:int -&amp;gt; ?src:ipaddr -&amp;gt; ipaddr -&amp;gt; Ip.proto -&amp;gt; ?size:int -&amp;gt; (buffer -&amp;gt; int) -&amp;gt; buffer list -&amp;gt; (unit, error) result io&lt;/code&gt;.
This is similar to the Ethernet signature - it writes the IPv4 header and sends a packet. It also supports fragmentation (including setting the do-not-fragment bit for path MTU discovery) -- whenever the payload is too big for a single frame, it is sent as multiple fragmented IPv4 packets. Additionally, setting the time-to-live is now supported, meaning we now can implement traceroute!
The API used to include two functions, &lt;code&gt;allocate_frame&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt;, where only buffers allocated by the former should be used in the latter. This has been combined into a single function that takes a fill function and a list of payloads. This change is for maximum flexibility: a higher layer can either construct its header and payload, and pass it to &lt;code&gt;write&lt;/code&gt; as payload argument (the &lt;code&gt;buffer list&lt;/code&gt;), which is then copied into the buffer(s) allocated by the network device, or the upper layer can provide the callback &lt;code&gt;fill&lt;/code&gt; function to assemble its data into the buffer allocated by the network device, to avoid copying. Of course, both can be used - the outgoing packet contains the IPv4 header, and possibly the buffer until the offset returned by &lt;code&gt;fill&lt;/code&gt;, and afterwards the payload.&lt;/p&gt;
&lt;p&gt;The TCP implementation has &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/pull/338&quot;&gt;preliminary keepalive support&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/solo5/solo5&quot;&gt;Solo5&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MirageOS 3.0.0 used the 0.2.0 release of solo5
&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;ukvm&lt;/code&gt; target was renamed to &lt;code&gt;hvt&lt;/code&gt;, where &lt;code&gt;solo5-hvt&lt;/code&gt; is the monitoring process
&lt;/li&gt;
&lt;li&gt;Support for &lt;a href=&quot;http://bhyve.org/&quot;&gt;FreeBSD bhyve&lt;/a&gt; and &lt;a href=&quot;https://man.openbsd.org/vmm.4&quot;&gt;OpenBSD VMM&lt;/a&gt; hypervisor (within the hvt target)
&lt;/li&gt;
&lt;li&gt;Support for ARM64 and KVM
&lt;/li&gt;
&lt;li&gt;New target &lt;a href=&quot;https://muen.sk&quot;&gt;muen.sk&lt;/a&gt;, a separation kernel developed in SPARK/Ada
&lt;/li&gt;
&lt;li&gt;New target &lt;a href=&quot;https://genode.org&quot;&gt;GenodeOS&lt;/a&gt;, an operating system framework using a microkernel
&lt;/li&gt;
&lt;li&gt;Debugger support: attach gdb in the host system for improved debugging experience
&lt;/li&gt;
&lt;li&gt;Core dump support
&lt;/li&gt;
&lt;li&gt;Drop privileges on OpenBSD and FreeBSD
&lt;/li&gt;
&lt;li&gt;Block device write fixes (in &lt;a href=&quot;https://github.com/mirage/mirage-block-solo5&quot;&gt;mirage-block-solo5&lt;/a&gt;)
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/mirage/mirage-random&quot;&gt;random&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/mirage/mirage-random-stdlib&quot;&gt;default random device&lt;/a&gt; from the OCaml standard library is now properly seeded using &lt;a href=&quot;https://github.com/mirage/mirage-entropy&quot;&gt;mirage-entropy&lt;/a&gt;. In the future, we plan to make the &lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto&quot;&gt;fortuna RNG&lt;/a&gt; the default random number generator.&lt;/p&gt;
&lt;h3&gt;Argument passing to unikernels&lt;/h3&gt;
&lt;p&gt;The semantics of arguments passed to a MirageOS unikernel used to vary between different backends, now they're the same everywhere: all arguments are concatenated using the whitespace character as separator, and split on the whitespace character again by &lt;a href=&quot;https://github.com/mirage/parse-argv&quot;&gt;parse-argv&lt;/a&gt;. To pass a whitespace character in an argument, the whitespace now needs to be escaped: &lt;code&gt;--hello=foo\\ bar&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Noteworthy package updates&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-cstruct&quot;&gt;cstruct 3.6.0&lt;/a&gt; API changes and repackaging, see &lt;a href=&quot;https://discuss.ocaml.org/t/ann-cstruct-3-0-0-with-packaging-changes&quot;&gt;this announcement&lt;/a&gt; and &lt;a href=&quot;https://discuss.ocaml.org/t/psa-cstruct-3-4-0-removes-old-ocamlfind-subpackage-aliases&quot;&gt;this announcement&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-ipaddr&quot;&gt;ipaddr 3.0.0&lt;/a&gt; major API changes, the s-expression serialisation is a separate subpackage, macaddr is now a standalone opam package
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/base64&quot;&gt;base64 3.0.0&lt;/a&gt; performance and API changes, see &lt;a href=&quot;https://discuss.ocaml.org/t/ann-major-release-of-base64-article&quot;&gt;this announcement&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-git&quot;&gt;git 2.0.0&lt;/a&gt;, read &lt;a href=&quot;https://discuss.ocaml.org/t/ann-ocaml-git-2-0&quot;&gt;this announcement&lt;/a&gt;, as well as &lt;a href=&quot;https://discuss.ocaml.org/t/ocaml-git-git-design-and-implementation&quot;&gt;its design and implementation&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/io-page&quot;&gt;io-page 2.0.0&lt;/a&gt;, see &lt;a href=&quot;https://discuss.ocaml.org/t/ann-io-page-2-0-0-with-packaging-changes&quot;&gt;this announcement&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-cohttp&quot;&gt;cohttp 2.0.0&lt;/a&gt;, see &lt;a href=&quot;https://discuss.ocaml.org/t/ann-major-releases-of-cohttp-conduit-dns-tcpip&quot;&gt;this announcement&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-dns&quot;&gt;dns 1.0.0&lt;/a&gt;, see &lt;a href=&quot;https://discuss.ocaml.org/t/ann-major-releases-of-cohttp-conduit-dns-tcpip&quot;&gt;this announcement&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-conduit&quot;&gt;conduit 1.0.0&lt;/a&gt;, see &lt;a href=&quot;https://discuss.ocaml.org/t/ann-major-releases-of-cohttp-conduit-dns-tcpip&quot;&gt;this announcement&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;More features and bugfixes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;More HTTP server choices are supported via a new &lt;a href=&quot;https://github.com/mirage/mirage/pull/955&quot;&gt;httpaf device&lt;/a&gt; that permits the &lt;a href=&quot;https://github.com/inhabitedtype/httpaf&quot;&gt;high performance httpaf&lt;/a&gt; stack to run as a unikernel now.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage/pull/903&quot;&gt;libvirt.xml is generated for virtio target&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage/issues/861&quot;&gt;Unix target now include -tags thread&lt;/a&gt; (for mirage-framebuffer SDL support)
&lt;/li&gt;
&lt;li&gt;Various modules (IPv6, DHCP) are explicit about their dependency to the random device
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage/pull/807&quot;&gt;QubesDB can be requested in config.ml when the target is Xen&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You may also want to read the &lt;a href=&quot;https://discuss.ocaml.org/t/ann-mirage-3-2-0&quot;&gt;MirageOS 3.2.0 announcement&lt;/a&gt; and the &lt;a href=&quot;https://discuss.ocaml.org/t/mirage-3-3-0-released&quot;&gt;MirageOS 3.3.0 announcement&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Next steps&lt;/h2&gt;
&lt;p&gt;We are working on &lt;a href=&quot;https://github.com/mirage/mirage/issues/969&quot;&gt;further&lt;/a&gt; &lt;a href=&quot;https://github.com/mirage/functoria/pull/167&quot;&gt;changes&lt;/a&gt; which revise the &lt;code&gt;mirage&lt;/code&gt; internal build system to &lt;a href=&quot;https://dune.build&quot;&gt;dune&lt;/a&gt;. At the moment it uses &lt;code&gt;ocamlbuild&lt;/code&gt;, &lt;code&gt;ocamlfind&lt;/code&gt;, &lt;code&gt;pkg-config&lt;/code&gt;, and &lt;code&gt;make&lt;/code&gt;. The goal of this change is to make MirageOS more developer-friendly. On the horizon we have MirageOS unikernel monorepos, incremental builds, pain-free cross-compilation, documentation generation, ...&lt;/p&gt;
&lt;p&gt;Several other MirageOS ecosystem improvements are on the schedule for 2019, including an &lt;a href=&quot;https://zshipko.github.io/irmin-tutorial/&quot;&gt;irmin 2.0 release&lt;/a&gt;, a &lt;a href=&quot;https://github.com/Solo5/solo5/pull/310&quot;&gt;seccomp target for Solo5&lt;/a&gt;, and &lt;a href=&quot;https://github.com/Solo5/solo5/issues/326&quot;&gt;easier deployment and multiple interface in Solo5&lt;/a&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/announcing-mirage-35-release</id><title type="text">Announcing MirageOS 3.5.0</title><updated>2019-03-05T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/2018-visiting-the-camels" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Original posted on &lt;a href=&quot;https://linse.me/2018/04/20/Visiting-the-camels.html&quot;&gt;linse's blog&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/7/7f/Maroc_Marrakech_Jemaa-el-Fna_Luc_Viatour.JPG&quot; alt=&quot;Jemaa El Fnaa&quot;/&gt;
Image by Luc Viatour / https://Lucnix.be&lt;/p&gt;
&lt;p&gt;In March 2018, I attended my first &lt;a href=&quot;http://retreat.mirage.io/&quot;&gt;MirageOS hack retreat&lt;/a&gt; in Morrocco.
&lt;a href=&quot;https://mirage.io/&quot;&gt;MirageOS&lt;/a&gt; is a library operating system which allows everyone to build very small, specialized operating system kernels that are intended to run directly on the virtualization layer.
The application code itself is the guest operating system kernel, and can be deployed at scale without the need for an extra containerization step in between.
It is written in &lt;a href=&quot;https://ocaml.org/learn/description.html&quot;&gt;OCaml&lt;/a&gt; and each kernel is built only with exactly the code that is necessary for the particular application.
A pretty different approach from traditional operating systems. Linux feels &lt;a href=&quot;https://www.linuxcounter.net/statistics/kernel&quot;&gt;huge&lt;/a&gt; all of a sudden.&lt;/p&gt;
&lt;p&gt;I flew in from New York via Casablanca to Marrakesh, and then took a cab to the city center, to the main square, &lt;a href=&quot;https://en.wikipedia.org/wiki/Jemaa_el-Fnaa&quot;&gt;Jemaa El Fnaa&lt;/a&gt;.
At Cafe de France, Hannes was picking me up and we walked back through the labyrinth of the Medina to the hostel Riad &amp;quot;Priscilla&amp;quot; where we lived with about 20 MirageOS folks, two &lt;a href=&quot;https://www.instagram.com/p/BgPaVbuD3Y3/?taken-by=l1ns3&quot;&gt;turtles&lt;/a&gt; and a dog.
We ate some food, and there were talks about Mirage's quickcheck-style fuzzing library &lt;a href=&quot;https://github.com/stedolan/crowbar&quot;&gt;Crowbar&lt;/a&gt;, and an API realized on top of a message queue written in OCaml.&lt;/p&gt;
&lt;p&gt;Coming from compiler construction in Haskell and building &amp;quot;stateless&amp;quot; services for information retrieval in Scala, I have a good grasp of functional programming. The funny problem is I don't know much about OCaml yet.&lt;/p&gt;
&lt;p&gt;At Etsy, I was part of the Core Platform team where we first &lt;a href=&quot;https://www.youtube.com/watch?v=75j1RRxxARI&quot;&gt;used hhvm&lt;/a&gt; (Facebook's hip-hop virtual machine) on the API cluster, and then advocated to use their gradually typed &lt;a href=&quot;http://hacklang.org/&quot;&gt;&amp;quot;hack&amp;quot; language&lt;/a&gt; to introduce typing to the gigantic PHP codebase at Etsy. Dan Miller and I added types to the codebase with Facebook's &lt;a href=&quot;https://docs.hhvm.com/hack/tools/hackificator&quot;&gt;&lt;code&gt;hackificator&lt;/code&gt;&lt;/a&gt;, but then
PHP 7 added the possibility of type annotations and great speedups, and PHP's own static analyzer &lt;a href=&quot;https://github.com/phan/phan&quot;&gt;&lt;code&gt;phan&lt;/code&gt;&lt;/a&gt; was developed by Rasmus Lerdorf and Andrew Morrison to work with PHP's types.
We abandoned the hackification approach.
Why is this interesting? These were my first encounters with OCaml! The &lt;a href=&quot;https://docs.hhvm.com/hack/typechecker/introduction&quot;&gt;hack typechecker&lt;/a&gt; is written in OCaml, and Dan and I have read it to understand the gradual typing approach.
Also, we played with &lt;a href=&quot;https://github.com/facebook/pfff/wiki/Main&quot;&gt;&lt;code&gt;pfff&lt;/code&gt;&lt;/a&gt;, a tool written in OCaml that allows structural edits on PHP programs, based on the abstact syntax tree.
I made a list to translate between Haskell and OCaml syntax, and later Maggie Zhou and I used &lt;code&gt;pfff&lt;/code&gt; to &lt;a href=&quot;https://codeascraft.com/author/sschirmer/&quot;&gt;unify&lt;/a&gt; the syntax of several hundred endpoints in Etsy's internal API.&lt;/p&gt;
&lt;p&gt;At the MirageOS retreat, I started my week reading &lt;a href=&quot;https://dev.realworldocaml.org/&quot;&gt;&amp;quot;Real World OCaml&amp;quot;&lt;/a&gt;, but got stuck because the examples did not work with the buildsystem used in the book. Stephen helped me to find a workaround, I made a PR to the book but it was closed since it is a temporary problem. Also, I started reading about OCaml's &lt;a href=&quot;https://mirage.io/docs/tutorial-lwt&quot;&gt;&amp;quot;lwt&amp;quot; library&lt;/a&gt; for concurrent programming. The abbreviation stands for lightweight threads and the library provides a monadic way to do multithreading, really similar to &lt;a href=&quot;https://twitter.github.io/util/docs/com/twitter/util/Future.html&quot;&gt;twitter futures&lt;/a&gt; in Scala. Asynchronous calls can be made in a thread, which then returns at some point when the call was successful or failed. We can  do operations &amp;quot;inside&amp;quot; lwt with bind (&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;) in the same way we can flatMap over Futures in scala. The library also provides ways to run multiple threads in sequence or in parallel, and to block and wait.
In the evening, there was a talk about a &lt;a href=&quot;https://github.com/cfcs/mirage-ocra-demo&quot;&gt;high-end smart card&lt;/a&gt; that based on a private start value can provide a succession of keys. The hardware is interesting, being the size of a credit card it has a small keypad and a screen. Some banks use these cards already (for their TAN system?), and we all got a sample card to play with.&lt;/p&gt;
&lt;p&gt;One day I went swimming with Lix and Reynir, which was quite the adventure since the swimming pool was closed and we were not sure what to do. We still made it to the part that was still open, swam a lot and then got a cake for Hannes birthday which lead to a cake overflow since there were multiple cakes and an awesome party with candles, food and live music already. :D Thanks everyone for organizing!! Happy birthday Hannes!&lt;/p&gt;
&lt;p&gt;I started reading another book, &lt;a href=&quot;http://ocaml-book.com/&quot;&gt;&amp;quot;OCaml from the very beginning&amp;quot;&lt;/a&gt;, and working through it with Kugg. This book was more focused on algorithms and the language itself than on tooling and libraries, and the exercises were really fun to solve. Fire up OCaml's REPL &lt;a href=&quot;https://github.com/diml/utop&quot;&gt;&lt;code&gt;utop&lt;/code&gt;&lt;/a&gt; and go! :D&lt;/p&gt;
&lt;p&gt;At the same time I started reading the code for &lt;a href=&quot;https://github.com/solo5/solo5&quot;&gt;solo5&lt;/a&gt; to get an understanding of the underlying hypervisor abstraction layer and the backends we compile to. This code is really a pleasure to read.
It is called solo5 because of MirageOS's system calls, initially a set of 5 calls to the hypervisor, called hypercalls which sounds really futuristic. :D&lt;/p&gt;
&lt;p&gt;So that's the other fun problem: I don't know too much about kernel programming yet. I did the &lt;a href=&quot;http://eudyptula-challenge.org/&quot;&gt;Eudyptula (Linux kernel) challenge&lt;/a&gt;, an email-based challenge that sends you programming quests to learn about kernel programming.
Over the course of the challenge, I've made my own Linux kernel module that says &amp;quot;Hello world!&amp;quot; but I have not built anything serious yet.&lt;/p&gt;
&lt;p&gt;The next things I learned were &lt;a href=&quot;https://mirage.io/docs/hello-world&quot;&gt;configuring and compiling&lt;/a&gt; a MirageOS unikernel. Hannes showed me how this works.
The config system is powerful and can be tailored to the unikernel we are about to build, via a config file.
After configuring the build, we can build the kernel for a target backend of our choice. I started out with compiling to Unix, which means all network calls go through unix pipes and the unikernel runs as a simple unix binary in my host system, which is really useful for testing.&lt;/p&gt;
&lt;p&gt;The next way to run MirageOS that I tried was running it in ukvm. For this setup you have to change the networking approach so that you can talk from the host system to you unikernel inside ukvm. In Linux you can use the Tun/Tap loopback interface for networking to wire up this connection.&lt;/p&gt;
&lt;p&gt;We had a session with &lt;a href=&quot;https://hackingwithcare.in/about-2/&quot;&gt;Jeremie&lt;/a&gt; about our vision for MirageOS which was super fun, and very interesting because people have all kinds of different backgrounds but the goals are still very aligned.&lt;/p&gt;
&lt;p&gt;Another thing I learned was how to look at network traffic with &lt;a href=&quot;https://www.wireshark.org/&quot;&gt;wireshark&lt;/a&gt;. &lt;a href=&quot;https://s4y.us/&quot;&gt;Sidney&lt;/a&gt; and I had previously recorded a TLS handshake with tcpdump and looked at the binary data in the pcap file with &amp;quot;hexfiend&amp;quot; next to Wikipedia to decode what we saw.
Derpeter gave me a nice introduction about how to do this with wireshark, which knows about most protocols already and will do the decoding of the fields for us. We talked about all layers of the usual stack, other kinds of internet protocols, the iptables flow, and bgp / &lt;a href=&quot;https://www.peeringdb.com/net/12276&quot;&gt;peeringDB&lt;/a&gt;. Quite interesting and I feel I have a pretty good foundational understanding about how the internet actually works now.&lt;/p&gt;
&lt;p&gt;During the last days I wanted to write a unikernel that does something new, and I thought about monitoring, as there is no monitoring for MirageOS yet. I set up a &lt;a href=&quot;https://grafana.com/&quot;&gt;grafana&lt;/a&gt; on my computer and sent some simple data packets to grafana from a unikernel, producing little peaks in a test graph. Reynir and I played with this a bit and restructured the program.&lt;/p&gt;
&lt;p&gt;After this, the week was over, I walked back to Jemaa el Fnaa with Jeremie, I feel I learned a ton and yet am still at the very beginning, excited what to build next. On the way back I got stuck in a weird hotel in Casablanca due to the flight being cancelled, where I bumped into a Moroccan wedding and met some awesome travelling women from Brazil and the US who also got stuck. All in all a fun adventure!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://scontent-frt3-2.cdninstagram.com/vp/b7383ad87744d99eae8940b38789fc94/5B58DFFC/t51.2885-15/e35/28764104_231320117439563_2956918922680467456_n.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

      </content><id>https://mirage.io/blog/2018-visiting-the-camels</id><title type="text">Visiting the camels - MirageOS spring hack retreat 2018</title><updated>2018-04-20T00:00:00-00:00</updated><author><name>Stefanie Schirmer</name></author></entry><entry><link href="https://mirage.io/blog/2018-esp32-booting" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Now that the winter holiday break is over, we are starting to see the results of winter hacking among our community.&lt;/p&gt;
&lt;p&gt;The first great hack for 2018 is from &lt;a href=&quot;http://toao.com&quot;&gt;Sadiq Jaffer&lt;/a&gt;, who got OCaml booting on a tiny and relatively new CPU architecture -- the &lt;a href=&quot;http://esp32.net&quot;&gt;Espressif ESP32&lt;/a&gt;.  After proudly demonstrating a battery powered version to the folks at &lt;a href=&quot;https://ocamllabs.io&quot;&gt;OCaml Labs&lt;/a&gt;, he then proceeded to clean it up enough tha it can be built with a &lt;a href=&quot;https://github.com/sadiqj/ocaml-esp32-docker&quot;&gt;Dockerfile&lt;/a&gt;, so that others can start to do a native code port and get bindings to the networking interface working.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://toao.com/blog/getting-ocaml-running-on-the-esp32#getting-ocaml-running-on-the-esp32&quot;&gt;Read all about it on Sadiq's blog&lt;/a&gt;, and thanks for sharing this with us, Sadiq!&lt;/p&gt;
&lt;p&gt;We also noticed that another OCaml generic virtual machine for even smaller microcontrollers has &lt;a href=&quot;https://github.com/stevenvar/omicrob&quot;&gt;shown up on GitHub&lt;/a&gt;.  This, combined with some functional metaprogramming, may mean that 2018 is the year of OCaml in all the tiny embedded things...&lt;/p&gt;

      </content><id>https://mirage.io/blog/2018-esp32-booting</id><title type="text">MirageOS running on the ESP32 embedded chip</title><updated>2018-01-26T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/2017-winter-hackathon-roundup" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;This winter, 33 people from around the world gathered in Marrakesh for a Mirage hack retreat. This is fast becoming a &lt;a href=&quot;https://mirage.io/blog/2016-spring-hackathon&quot;&gt;MirageOS&lt;/a&gt; &lt;a href=&quot;https://mirage.io/blog/2017-march-hackathon-roundup&quot;&gt;tradition&lt;/a&gt;, and we're a little sad that it's over already! We've collected some trip reports from those who attended the 2017 winter hack retreat, and we'd like to thank our amazing hosts, organisers and everyone who took the time to write up their experiences.
&lt;img src=&quot;https://mirage.io/graphics/winter2017.jpg&quot; style=&quot;float:right; padding: 15px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We, the MirageOS community, strongly believe in using our own software: this website has been a unikernel since day one^W^W it was possible to run MirageOS unikernels.  In Marrakesh we used our own DHCP and DNS server without trouble.  There are many more services under heavy development (including git, ssh, ...), which we're looking forward to using soon ourselves.&lt;/p&gt;
&lt;p&gt;Several atteendees joined for the second or third time in Marrakesh, and brought their own projects, spanning over &lt;a href=&quot;https://github.com/andreas/ocaml-graphql-server&quot;&gt;graphql&lt;/a&gt;, &lt;a href=&quot;https://reproducible-builds.org/&quot;&gt;reproducible builds&lt;/a&gt; (with application to &lt;a href=&quot;https://github.com/talex5/qubes-mirage-firewall&quot;&gt;qubes-mirage-firewall&lt;/a&gt;, see &lt;a href=&quot;http://layer-acht.org/thinking/blog/20171204-qubes-mirage-firewall/&quot;&gt;holger's report&lt;/a&gt; and &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/1515&quot;&gt;Gabriel's OCaml fixes for build path variation&lt;/a&gt;).  A stream of improving error messages in the OCaml compiler (based on &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/102&quot;&gt;Arthur Chargu&amp;eacute;raud PR&lt;/a&gt;) was prepared and merged (&lt;a href=&quot;https://github.com/ocaml/ocaml/pull/1496&quot;&gt;PR 1496&lt;/a&gt;, &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/1501&quot;&gt;PR 1501&lt;/a&gt;, &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/1505&quot;&gt;PR 1505&lt;/a&gt;, &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/1510&quot;&gt;PR 1510&lt;/a&gt;, and &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/1534&quot;&gt;PR 1534&lt;/a&gt;).  Our OCaml &lt;a href=&quot;https://github.com/mirage/ocaml-git/&quot;&gt;git implementation&lt;/a&gt; was rewritten to support git push properly, and this PR was &lt;a href=&quot;https://github.com/mirage/ocaml-git/pull/227&quot;&gt;merged&lt;/a&gt;.  Other projects of interest are &lt;a href=&quot;https://github.com/haesbaert/awa-ssh&quot;&gt;awa-ssh&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/charrua-core/pull/76&quot;&gt;anonymity profiles in DHCP&lt;/a&gt;, and fixes to the deployment troubles of &lt;a href=&quot;https://github.com/mirage/mirage-www&quot;&gt;our website&lt;/a&gt;.  There is now a &lt;a href=&quot;https://github.com/cfcs/eye-of-mirage&quot;&gt;mirage PNG viewer integrated into Qubes&lt;/a&gt; and a &lt;a href=&quot;https://github.com/cfcs/passmenage&quot;&gt;password manager&lt;/a&gt;.  Some &lt;a href=&quot;https://github.com/juga0/mirage_mar2017&quot;&gt;getting started notes&lt;/a&gt; were written down as well as the new &lt;a href=&quot;https://mirage.io/docs/learning&quot;&gt;learning about MirageOS&lt;/a&gt; website.&lt;/p&gt;
&lt;p&gt;A huge fraction of the &lt;a href=&quot;https://github.com/solo5/solo5&quot;&gt;Solo5 contributors&lt;/a&gt; gathered in Marrakesh as well and discussed the future, including terminology, the project scope, and outlined a roadmap for merging branches in various states.  Adrian from the &lt;a href=&quot;https://muen.sk&quot;&gt;Muen&lt;/a&gt; project joined the discussion, and in the aftermath they are now running their website using MirageOS on top of the Muen separation kernel.&lt;/p&gt;
&lt;p&gt;A complete list of fixes and discussions is not available, please bear with us if we forgot anything above.  A sneak preview: there will be &lt;a href=&quot;http://retreat.mirage.io&quot;&gt;another retreat in March 2018&lt;/a&gt; in Marrakesh.  Following are texts written by individual participants about their experience.&lt;/p&gt;
&lt;h2&gt;Mindy Preston&lt;/h2&gt;
&lt;p&gt;I came to Marrakesh for the hack retreat with one goal in mind: documentation.  I was very pleased to discover that &lt;a href=&quot;https://github.com/mk270&quot;&gt;Martin Keegan&lt;/a&gt; had come with the same goal in mind and fresher eyes, and so I had some time to relax, enjoy Priscilla and the sun, photograph some cats, and chat about projects both past and future.  In particular, I was really pleased that there's continued interest in building on some of the projects I've worked on at previous hack retreats.&lt;/p&gt;
&lt;p&gt;On the way to the first hack retreat, I did some work applying &lt;a href=&quot;https://github.com/stedolan&quot;&gt;Stephen Dolan's&lt;/a&gt; then-experimental &lt;a href=&quot;http://lcamtuf.coredump.cx&quot;&gt;American Fuzzy Lop&lt;/a&gt; instrumentation to testing the &lt;a href=&quot;https://github.com/mirage/mirage-tcpip&quot;&gt;mirage-tcpip&lt;/a&gt; library via &lt;a href=&quot;https://github.com/yomimono/mirage-net-pcap&quot;&gt;mirage-net-pcap&lt;/a&gt;. (A post on this was &lt;a href=&quot;http://canopy.mirage.io/Projects/Fuzzing&quot;&gt;one of the first Canopy entries!&lt;/a&gt;  At this hack retreat, I did a short presentation on the current state of this work:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AFL instrumentation was released in OCaml 4.05; switches with it enabled by default are available in opam (&lt;code&gt;opam sw 4.05.0+afl&lt;/code&gt;)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/stedolan/crowbar&quot;&gt;crowbar&lt;/a&gt; for writing generative tests powered by AFL, with an &lt;a href=&quot;https://github.com/stedolan/crowbar/tree/staging&quot;&gt;experimental staging branch&lt;/a&gt; that shows OCaml code for regenerating failing test cases
&lt;/li&gt;
&lt;li&gt;a &lt;a href=&quot;https://github.com/yomimono/ppx_deriving_crowbar&quot;&gt;companion ppx_deriving&lt;/a&gt; plugin for automatic generator discovery based on type definitions
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yomimono/ocaml-bun&quot;&gt;bun&lt;/a&gt;, for integrating afl tests into CI runs
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I was lucky to have a lot of discussions about fuzzing in OCaml, some of which inspired further work and suggestions on &lt;a href=&quot;https://github.com/stedolan/crowbar/issues/7&quot;&gt;some current problems in Crowbar&lt;/a&gt;.  (Special thanks to &lt;a href=&quot;https://github.com/gasche&quot;&gt;gasche&lt;/a&gt; and &lt;a href=&quot;https://github.com/armael&quot;&gt;armael&lt;/a&gt; for their help there!)  I'm also grateful to &lt;a href=&quot;https://github.com/aantron&quot;&gt;aantron&lt;/a&gt; for some discussions on ppx_bisect motivated by an attempt to estimate coverage for this testing workflow.  I was prodded into trying to get Crowbar ready to release by these conversations, and wrote a lot of docstrings and an actual README for the project.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/juga0&quot;&gt;juga0&lt;/a&gt; added some extensions to the &lt;a href=&quot;https://github.com/mirage/charrua-core&quot;&gt;charrua-core DHCP library&lt;/a&gt; started by &lt;a href=&quot;https://github.com/haesbaert&quot;&gt;Christiano Haesbaert&lt;/a&gt; a few hack retreats ago.  juga0 wanted to add some features to support &lt;a href=&quot;https://tools.ietf.org/html/rfc7844.html&quot;&gt;more anonymity for DHCP clients&lt;/a&gt;, so we did some associated work on the &lt;a href=&quot;https://github.com/haesbaert/rawlink&quot;&gt;rawlink&lt;/a&gt; library, and added an experimental Linux DHCP client for charrua-core itself.  I got to write a lot of docstrings for this library!&lt;/p&gt;
&lt;p&gt;I was also very excited to see the work that &lt;a href=&quot;https://github.com/cfcs&quot;&gt;cfcs&lt;/a&gt; has been doing on building more interesting MirageOS unikernels for use in QubesOS.  I had seen static screenshots of &lt;a href=&quot;https://github.com/cfcs/mirage-framebuffer&quot;&gt;mirage-framebuffer&lt;/a&gt; in action which didn't do it justice at all; seeing it in person (including self-hosted slides!) was really cool, and inspired me to think about how to fix &lt;a href=&quot;https://discuss.ocaml.org/t/mirageos-parametric-compilation-depending-on-target/1005/12&quot;&gt;some ugliness in writing unikernels using the framebuffer&lt;/a&gt;. The &lt;a href=&quot;https://github.com/cfcs/passmenage&quot;&gt;experimental password manager&lt;/a&gt; is something I hope to be using by the next hack retreat.  Maybe 2017 really is &lt;a href=&quot;https://mirage.io/blog/qubes-target&quot;&gt;the year of unikernels on the desktop&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;tg, hannes, halfdan, samoht, and several others (sorry if I missed you!) worked hard to get some unikernel infrastructure up and running at Priscilla, including homegrown DHCP and DNS services, self-hosted pastebin and etherpad, an FTP server for blazing-fast local filesharing, and (maybe most importantly!) a local &lt;code&gt;opam&lt;/code&gt; mirror.  I hope that in future hack retreats, we can set up a local &lt;code&gt;git&lt;/code&gt; server using the &lt;a href=&quot;https://github.com/mirage/ocaml-git&quot;&gt;OCaml git implementation&lt;/a&gt;, which got some major improvements during the hack retreat thanks to dinosaure (from the other side of the world!) and samoht.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;a href=&quot;https://github.com/talex5/qubes-mirage-firewall&quot;&gt;qubes-mirage-firewall&lt;/a&gt; got a lot of attention this hack retreat.  (The firewall itself incorporates some past hack retreat work by me and talex5.)  h01ger worked on the &lt;a href=&quot;http://layer-acht.org/thinking/blog/20171204-qubes-mirage-firewall/&quot;&gt;reproducibility of the build&lt;/a&gt;, and cfcs did some work on passing ruleset changes to the firewall -- currently, users of qubes-mirage-firewall need to rebuild the unikernel with ruleset changes.&lt;/p&gt;
&lt;p&gt;We also uncovered some strangeness and bugs in the &lt;a href=&quot;https://github.com/mirage/mirage/pull/874&quot;&gt;handling of Xen block-storage devices&lt;/a&gt;, which I was happy to fix in advance of the more intense use of block storage I expect with &lt;a href=&quot;https://github.com/g2p/wodan&quot;&gt;wodan&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;irmin&lt;/a&gt; in the near future.&lt;/p&gt;
&lt;h2&gt;Oh yes, and somewhere in there, I did find time to see some cats, eat tajine, wander around the medina, and enjoy all of the wonder that &lt;a href=&quot;http://queenofthemedina.com&quot;&gt;Priscilla, the Queen of the Medina&lt;/a&gt; and her lovely hosts have to offer.  Thanks to everyone who did the hard work of organizing, feeding, and laundering this group of itinerant hackers!&lt;/h2&gt;
&lt;h2&gt;Ximin Luo&lt;/h2&gt;
&lt;p&gt;This was my third MirageOS hack retreat, I continued right where I left off last time.&lt;/p&gt;
&lt;p&gt;I've had a pet project for a while to develop a end-to-end secure protocol for group messaging. One of its themes is to completely separate the transport and application layers, by sticking an end-to-end secure session layer in between them, with the aim of unifying all the &lt;em&gt;secure messaging&lt;/em&gt; protocols that exist today. Like many pet projects, I haven't had much time to work on it recently, and took the chance to this week.&lt;/p&gt;
&lt;p&gt;I worked on implementing a consistency checker for the protocol. This allows chat members to verify everyone is seeing and has seen the same messages, and to distinguish between other members being silent (not sending anything) vs the transport layer dropping packets (either accidentally or maliciously). This is built on top of my as-yet-unreleased pure library for setting timeouts, monitors (scheduled tasks) and expectations (promises that can timeout), which I worked on in the previous hackathons.&lt;/p&gt;
&lt;p&gt;I also wrote small libraries for doing 3-valued and 4-valued logic, useful for implementing complex control flows where one has to represent different control states like &lt;code&gt;success&lt;/code&gt;, &lt;code&gt;unknown/pending&lt;/code&gt;, &lt;code&gt;temporary failure&lt;/code&gt;, &lt;code&gt;permanent failure&lt;/code&gt;, and be able to compose these states in a logically coherent way.&lt;/p&gt;
&lt;p&gt;For my day-to-day work I work on the &lt;a href=&quot;https://reproducible-builds.org/&quot;&gt;Reproducible Builds&lt;/a&gt;, and as part of this we write patches and/or give advice to compilers on how to generate output deterministically. I showed Gabriel Scherer our testing framework with our results for various ocaml libraries, and we saw that the main remaining issue is that the build process embeds absolute paths into the output. I explained our &lt;code&gt;BUILD_PATH_PREFIX_MAP&lt;/code&gt; mechanism for stripping this information without negatively impacting the build result, and he implemented this for the ocaml compiler. It works for findlib! Then, I need to run some wider tests to see the overall effect on all ocaml packages. Some of the non-reproducibility is due to GCC and/or GAS, and more analysis is needed to distinguish these cases.&lt;/p&gt;
&lt;p&gt;I had very enjoyable chats with Anton Bachin about continuation-passing style, call-cc, coroutines, and lwt; and with Gabriel Scherer about formal methods, proof systems, and type systems.&lt;/p&gt;
&lt;p&gt;For fun times I carried on the previous event's tradition of playing Cambio, teaching it to at least half of other people here who all seemed to enjoy it very much! I also organised a few mini walks to places a bit further out of the way, like Gueliz and the Henna Art Cafe.&lt;/p&gt;
&lt;p&gt;On the almost-last day, I decided to submerge myself in the souks at 9am or so and explored it well enough to hopefully never get lost in there ever again! The existing data on OpenStreetMap for the souks is actually er, &lt;em&gt;topologically accurate&lt;/em&gt; shall we say, except missing some side streets. :)&lt;/p&gt;
&lt;h2&gt;All-in-all this was another enjoyable event and it was good to be back in a place with nice weather and tasty food!&lt;/h2&gt;
&lt;h2&gt;Martin Keegan&lt;/h2&gt;
&lt;p&gt;My focus at the retreat was on working out how to improve the documentation.
This decomposed into&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;encouraging people to fix the build for the docs system
&lt;/li&gt;
&lt;li&gt;talking to people to find out what the current state of Mirage is
&lt;/li&gt;
&lt;li&gt;actually writing some material and getting it merged
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What I learnt was&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;which backends are in practice actually usable today
&lt;/li&gt;
&lt;li&gt;the current best example unikernels
&lt;/li&gt;
&lt;li&gt;who can actually get stuff done
&lt;/li&gt;
&lt;li&gt;how the central configuration machinery of &lt;code&gt;mirage configure&lt;/code&gt; works today
&lt;/li&gt;
&lt;li&gt;what protocols and libraries are currently at the coal-face
&lt;/li&gt;
&lt;li&gt;that some important documentation exists in the form of blog posts
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I am particularly grateful to Mindy Preston and Thomas Gazagnaire for
their assistance on documentation. I am continuing the work now that I
am back in Cambridge.&lt;/p&gt;
&lt;p&gt;The tone and pace of the retreat was just right, for which Hannes is
due many thanks.&lt;/p&gt;
&lt;p&gt;On the final day, I gave a brief presentation about the use of OCaml
for making part of a vote counting system, focusing on the practicalities
and cost of explaining to laymen the guarantees provided by &lt;code&gt;.mli&lt;/code&gt;
interface files, with an implicit comparison to the higher cost in more
conventional programming languages.&lt;/p&gt;
&lt;h2&gt;The slides for the talk as delivered &lt;a href=&quot;http://mk.ucant.org/media/talks/2017-12-05_OCaml-Marrakesh-STV/&quot;&gt;are here&lt;/a&gt;, but it deserves its own
blog post.&lt;/h2&gt;
&lt;h2&gt;Michele Orr&amp;ugrave;&lt;/h2&gt;
&lt;p&gt;This year's Marrakech experience has been been a bit less productive than
past years'. I indulged a bit more chatting to people, and pair programming with
them.&lt;/p&gt;
&lt;p&gt;I spent some of my individual time time getting my hands dirty with the Jsonm
library, hoping that I would have been able to improve the state of my
ocaml-letsencrypt library; I also learned how to integrate ocaml API in C,
improving and updating the ocaml-scrypt library, used by another fellow mirage
user in order to develop its own password manager.
Ultimately, I'm not sure either direction I took was good: a streaming Json library is
perhaps not the best choice for an application that shares few jsons (samoht
should have been selling more his &lt;a href=&quot;https://github.com/mirage/ezjsonm&quot;&gt;easyjson&lt;/a&gt; library!), and the ocaml-scrypt
library has been superseeded by the pure implementation &lt;a href=&quot;https://github.com/abeaumont/ocaml-scrypt-kdf&quot;&gt;ocaml-scrypt-kdf&lt;/a&gt;, which
supposedly will make the integration in mirage easier.&lt;/p&gt;
&lt;h2&gt;The overall warm atmosphere and the overall positive attitude of the
group make me still think of this experience as a positive learning experience,
and how they say: failure the best teacher is.&lt;/h2&gt;
&lt;h2&gt;Reynir Bj&amp;ouml;rnsson&lt;/h2&gt;
&lt;p&gt;For the second time this year (and ever) I went to Marrakech to participate in the MirageOS hack retreat / unconference.
I wrote about my &lt;a href=&quot;http://reynir.dk/posts/2017-03-20-11-27-Marrakech%202017.html&quot;&gt;previous trip&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;The walk from the airport&lt;/h3&gt;
&lt;p&gt;Unlike the previous trip I didn't manage to meet any fellow hackers at the RAK airport.
Considering the annoying haggling taking a taxi usually involves and that the bus didn't show up last time I decided to walk the 5.3 km from the airport to Priscilla (the venue).
The walk to &lt;a href=&quot;https://en.wikipedia.org/wiki/Jemaa_el-Fnaa&quot;&gt;Jemaa el-Fnaa&lt;/a&gt; (AKA 'Big Square') was pretty straight forward.
Immediately after leaving the airport area I discovered every taxi driver would stop and tell me I needed a ride.
I therefore decided to walk on the opposite side of the road.
This made things more difficult because I then had more difficulties reading the road signs.
Anyway, I found my way to the square without any issues, although crossing the streets on foot requires cold blood and nerves of steel.&lt;/p&gt;
&lt;p&gt;Once at the square I noticed a big caf&amp;eacute; with lots of lights that I recognized immediately.
I went past it thinking it was Caf&amp;eacute; de France.
It was not.
I spent about 30-40 minutes practicing my backtracking skills untill I finally gave up.
I went back to the square in order to call Hannes and arrange a pickup.
The two meeting points at the square was some juice stand whose number I couldn't remember and Caf&amp;eacute; de France, so I went looking for the latter.
I quickly realized my mistake, and once I found the correct caf&amp;eacute; the way to Priscilla was easy to remember.&lt;/p&gt;
&lt;p&gt;All in all I don't recommend walking unless you &lt;em&gt;definitely&lt;/em&gt; know the way and is not carrying 12-15 kg of luggage.&lt;/p&gt;
&lt;h3&gt;People&lt;/h3&gt;
&lt;p&gt;Once there I met new and old friends.
Some of the old friends I had seen at &lt;a href=&quot;https://bornhack.dk&quot;&gt;Bornhack&lt;/a&gt; while others I hadn't seen since March.
In either case it was really nice to meet them again!
As for the new people it's amazing how close you can get with strangers in just a week.
I had some surprisingly personal conversations with people I had only met a few days prior.
Lovely people!&lt;/p&gt;
&lt;h3&gt;My goals&lt;/h3&gt;
&lt;p&gt;Two months prior to the hack retreat I had started work on implementing the ssh-agent protocol.
I started the project because I couldn't keep up with Christiano's &lt;a href=&quot;https://github.com/haesbaert/awa-ssh&quot;&gt;awa-ssh&lt;/a&gt; efforts in my limited spare time, and wanted to work on something related that might help that project.
My goals were to work on my &lt;a href=&quot;https://github.com/reynir/ocaml-ssh-agent&quot;&gt;ocaml-ssh-agent&lt;/a&gt; implementation as well as on awa-ssh.&lt;/p&gt;
&lt;p&gt;Before going to Marrakech I had had a stressful week at work.
I had some things to wrap up before going to a place without a good internet connection.
I therefore tried to avoid doing anything on the computer the first two days.
On the plane to Marrakech I had taken up knitting again - something I hadn't done in at least two years.
The morning of the first day I started knitting.
Eventually I had to stop knitting because I had drunk too much coffee for me to have steady enough hands to continue, so I started the laptop despite my efforts not to.
I then looked at awa-ssh, and after talking with Christiano I made the first (and sadly only) contribution to awa-ssh of that trip:
The upstream &lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto&quot;&gt;nocrypto&lt;/a&gt; library had been changed in a way that required changes to awa-ssh.
I rewrote the digest code to reflect the upstream changes, and refactored the code on suggestion by Christiano.&lt;/p&gt;
&lt;p&gt;In ocaml-ssh-agent I was already using &lt;a href=&quot;https://github.com/inhabitedtype/angstrom&quot;&gt;angstrom&lt;/a&gt; for parsing ssh-agent messages.
I rewrote the serialization from my own brittle cstruct manipulations to using &lt;a href=&quot;https://github.com/inhabitedtype/faraday&quot;&gt;faraday&lt;/a&gt;.
This worked great, except I never quite understood how to use the &lt;code&gt;Faraday_lwt_unix&lt;/code&gt; module.
Instead I'm serializing to a string and then writing that string to the &lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;GADT !!!FUN!!!&lt;/h3&gt;
&lt;p&gt;The ssh-agent is a request-response protocol.
Only a certain subset of the responses are valid for each request.
I wanted to encode that relationship into the types so that the user of the library wouldn't have to deal with invalid responses.
In order to do that I got help by &lt;a href=&quot;https://github.com/aantron&quot;&gt;@aantron&lt;/a&gt; to implement this with GADTs.
The basic idea is a phantom type is added to the request and response types.
The phantom type, called request_type, is a polymorphic variant that reflects the kind of requests that are possible.
Each response is parameterized with a subset of this polymorphic variant.
For example, every request can fail, so &lt;code&gt;Ssh_agent_failure&lt;/code&gt; is parameterized with the whole set,
while &lt;code&gt;Ssh_agent_identities_answer&lt;/code&gt; is parameterized with &lt;code&gt; `Ssh_agent_request_identities&lt;/code&gt;,
and &lt;code&gt;Ssh_agent_success&lt;/code&gt; is parameterized with &lt;code&gt; `Ssh_agent_successable&lt;/code&gt; - a collapse of all the request types that can either return success or failure.&lt;/p&gt;
&lt;p&gt;This worked great except it broke the typing of my parser -
The compiler can't guess what the type parameter should be for the resulting &lt;code&gt;ssh_agent_response&lt;/code&gt;.
To work around that &lt;a href=&quot;https://github.com/gasche&quot;&gt;@gasche&lt;/a&gt; helped me solve that problem by introducing an existential type:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;    type any_ssh_agent_response = Any_response : 'a ssh_agent_response -&amp;gt; any_ssh_agent_response
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this I could now write a function &lt;code&gt;unpack_any_response&lt;/code&gt; which 'discards' every response that doesn't make sense for a particular request.
Its type is the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;    val unpack_any_response : 'a ssh_agent_request -&amp;gt; any_ssh_agent_response -&amp;gt;
                              ('a ssh_agent_response, string) result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now I want to write a &lt;code&gt;listen&lt;/code&gt; function that takes a handler of type &lt;code&gt;'a ssh_agent_request -&amp;gt; 'a ssh_agent_response&lt;/code&gt;, in other words a handler that can only create valid response types.
This unfortunately doesn't type check.
The parser returns an existential
&lt;code&gt;type any_ssh_agent_request = Any_request : 'req_type ssh_agent_request -&amp;gt; any_ssh_agent_request&lt;/code&gt;.
This is causing me a problem: the &lt;code&gt;'req_type&lt;/code&gt; existential would escape.
I do not know how to solve this problem, or if it's possible to solve it at all.
I discussed this issue with &lt;a href=&quot;http://github.com/infinity0&quot;&gt;@infinity0&lt;/a&gt; after the retreat, and we're not very optimistic.
Perhaps someone in &lt;code&gt;#ocaml&lt;/code&gt; on Freenode might know a trick.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;    let listen ((ic, oc) : in_channel * out_channel)
        (handler : 'a Ssh_agent.ssh_agent_request -&amp;gt; 'a Ssh_agent.ssh_agent_response) =
      match Angstrom_unix.parse Ssh_agent.Parse.ssh_agentc_message ic with
      | { len = 0; _ }, Ok (Ssh_agent.Any_request request) -&amp;gt;
        Ok (Ssh_agent.Any_response (handler response))
      | { len; _ }, Ok _ -&amp;gt;
        Error &amp;quot;Additional data in reply&amp;quot;
      | _, Error e -&amp;gt;
        Error e
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Ideas for uses of ocaml-ssh-agent&lt;/h3&gt;
&lt;p&gt;Besides the obvious use in a ssh-agent client in a ssh client, the library could be used to write an ssh-agent unikernel.
This unikernel could then be used in &lt;a href=&quot;https://www.qubes-os.org/&quot;&gt;Qubes OS&lt;/a&gt; in the same way as &lt;a href=&quot;https://github.com/henn/qubes-app-split-ssh&quot;&gt;Qubes Split SSH&lt;/a&gt; where the ssh-agent is running in a separate VM not connected to the internet.
Furthermore, &lt;a href=&quot;https://github.com/cfcs&quot;&gt;@cfcs&lt;/a&gt; suggested an extension could be implemented such that only identities relevant for a specific host or host key are offered by the ssh-agent.
When one connects to e.g. github.com using ssh keys all the available public keys are sent to the server.
This allows the server to do finger printing of the client since the set of keys is likely unique for that machine, and may leak information about keys irrelevant for the service (Github).
This requires a custom ssh client which may become a thing with awa-ssh soon-ish.&lt;/p&gt;
&lt;h3&gt;Saying goodbye&lt;/h3&gt;
&lt;p&gt;Leaving such lovely people is always difficult.
The trip to the airport was emotional.
It was a chance to spend some last few moments with some of the people from the retreat knowing it was also the last chance this time around.
I will see a lot of the participants at 34c3 in 3 weeks already, while others I might not see again in the near future.
I do hope to stay in contact with most of them online!&lt;/p&gt;
&lt;h2&gt;Thank you for yet another great retreat!&lt;/h2&gt;
&lt;p&gt;Many thanks to everyone involved!  The hostel is already booked for &lt;a href=&quot;http://retreat.mirage.io&quot;&gt;another retreat in March 2018&lt;/a&gt;...&lt;/p&gt;

      </content><id>https://mirage.io/blog/2017-winter-hackathon-roundup</id><title type="text">MirageOS Winter 2017 hack retreat roundup</title><updated>2017-12-23T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/2017-march-hackathon-roundup" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;This March, 34 people from around the world gathered in Marrakech for a spring Mirage hack retreat. This is fast becoming a &lt;a href=&quot;https://mirage.io/blog/2016-spring-hackathon&quot;&gt;MirageOS tradition&lt;/a&gt;, and we're a little sad that it's over already! We've collected some trip reports from those who attended the 2017 Hack Retreat, and we'd like to thank our amazing hosts, organisers and everyone who took the time to write up their experiences. Props go especially to Hannes Mehnert who initiated the event and took care of many of the logistics, and to Gemma Gordon for designing and printing &lt;a href=&quot;http://reynard.io/2017/03/10/OCamlCollection.html&quot;&gt;limited edition t-shirts&lt;/a&gt; especially for the occasion!
&lt;img src=&quot;https://mirage.io/graphics/medina-2017.jpg&quot; style=&quot;float:right; padding: 15px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In addition to the reports below, you can find other information online:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the daily &lt;a href=&quot;http://ocamllabs.io/events/2017/03/06/MirageHackUpdates.html&quot;&gt;tweets about the event&lt;/a&gt;, including sophisticated &amp;quot;paper slides&amp;quot;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ollehost.dk/blog/2017/03/17/travel-report-mirageos-hack-retreat-in-marrakesh-2017/&quot;&gt;Olle Jonsson&lt;/a&gt; and &lt;a href=&quot;https://reynir.dk/posts/2017-03-20-11-27-Marrakech%202017.html&quot;&gt;Reynir Bj&amp;ouml;rnsson&lt;/a&gt; wrote up their experiences on their personal sites.
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Hannes Mehnert&lt;/h2&gt;
&lt;p&gt;At the retreat, 34 people from all around the world (mainly Western
Europe) interested in MirageOS gathered for a week in Marrakech.&lt;/p&gt;
&lt;p&gt;Numerous social contacts, political discussions, technical challenges
were discussed in smaller and bigger groups. Lots of pull requests were
opened and merged - we kept the DSL line busy with git pushes and pulls
:) - sometimes overly busy.&lt;/p&gt;
&lt;p&gt;In contrast to &lt;a href=&quot;https://mirage.io/blog/2016-spring-hackathon&quot;&gt;last year&lt;/a&gt;, we organised several events:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Body self-awareness workshop (by the resident dancers)
&lt;/li&gt;
&lt;li&gt;Hiking to waterfalls on Sunday
&lt;/li&gt;
&lt;li&gt;Hamam visit on Monday
&lt;/li&gt;
&lt;li&gt;Herbalist visit on Tuesday
&lt;/li&gt;
&lt;li&gt;Talk by the resident dancers on Tuesday
&lt;/li&gt;
&lt;li&gt;A &lt;a href=&quot;https://www.dropbox.com/s/w5wnlbxujf7pk5w/Marrakech.pdf?dl=0&quot;&gt;public talk&lt;/a&gt; led by Amir on Saturday (highly appreciated, it
was announced rather late, only ~10 external people showed up)
&lt;img src=&quot;https://mirage.io/graphics/spiros-camel.jpg&quot; style=&quot;float:right; padding: 15px&quot;/&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Several voluntary presentations on topics of interest to several people:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;Reverse engineering MirageOS with radare2 (and IDA pro)&amp;quot; by Alfredo
(Alfredo and Chris tried afterwards the link-time optimization branch of
OCaml, which does not seem to have any effect at all (there may be
something missing from the 4.04.0+trunk+forced_lto switch))
&lt;/li&gt;
&lt;li&gt;&amp;quot;Introduction to base&amp;quot; by Spiros
&lt;/li&gt;
&lt;li&gt;&amp;quot;Solo5&amp;quot; (or rather: what is below the OCaml runtime, xen vs solo5) by
Mato https://pbs.twimg.com/media/C6VQffoWMAAtbot.jpg
&lt;/li&gt;
&lt;li&gt;&amp;quot;Angstrom intro&amp;quot; by Spiros
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After the week in Marrakech, I was sad to leave the place and all the nice people. Fortunately we can interact via the Internet (on IRC,
GitHub, Mail, ...) on projects which we started or continued to work on at the retreat.&lt;/p&gt;
&lt;p&gt;It was a very nice week, I met lots of new faces. These were real people with interesting stories, and I could finally match email addresses to faces. I was delighted to share knowledge about software I know to other people, and learned about other pieces of software.&lt;/p&gt;
&lt;p&gt;My personal goal is to grow a nice and diverse community around MirageOS, and so far I have the feeling that this is coming along smoothly.&lt;/p&gt;
&lt;h2&gt;Thanks again to everybody for participating (on-site and remote) and special thanks to &lt;a href=&quot;http://ocamllabs.io&quot;&gt;OCaml Labs&lt;/a&gt; for support, and Gemma Gordon for the limited edition &lt;a href=&quot;http://reynard.io/2017/03/10/OCamlCollection.html&quot;&gt;t-shirts&lt;/a&gt; (design and logistics)!&lt;/h2&gt;
&lt;h2&gt;Ximin Luo&lt;/h2&gt;
&lt;p&gt;Good people, good food, good weather, what more could you ask for? This year's MirageOS hackathon was a blast, like last year.&lt;/p&gt;
&lt;p&gt;I started off the week by giving a monad tutorial to a few people - introducing the terminology around it, the motivation behind it, giving a few concrete examples and exercises, and relating it to some basic category theory.&lt;/p&gt;
&lt;p&gt;Since last year, I've been working on-and-off on a group messaging protocol. One of its aims is to completely separate the transport and application layers, by sticking an end-to-end secure session layer in between them. This could help to unify &lt;a href=&quot;https://xkcd.com/1810/&quot;&gt;all the messaging protocols that exist today&lt;/a&gt; or it could &lt;a href=&quot;https://xkcd.com/927/&quot;&gt;make the problem worse&lt;/a&gt;, time will tell how this works out in the end. :)&lt;/p&gt;
&lt;p&gt;Another of my interests is to write more code that is obviously-more-secure, using strong type systems that provide compile-time guarantees about what your code can or can't do. As part of bringing these two concepts together, I've been working on writing a pure library for doing scheduled (timed) computations - i.e., to express &amp;quot;do this in X time in the future&amp;quot; then actually do it. This is very important in real world security systems, where you can't wait for too long for certain events to happen, otherwise you'll be susceptible to attacks.&lt;/p&gt;
&lt;p&gt;To give the game away, the utility is just a state monad transformer where the state is a schedule data structure that records the tasks to be performed in the future, together with a pure monadic runner that executes these tasks but is triggered by impure code that knows the &amp;quot;real&amp;quot; time. However, implementing the specifics so that user code is composable and still looks (relatively) nice, has taken quite some effort to figure out. There are various other nice properties I added, such as being able to serialise the schedule to disk, so the behaviour is preserved across program shutdowns.&lt;/p&gt;
&lt;p&gt;Using this pure lower-level control-flow utility, we can build slightly higher-level utilities, such as a &amp;quot;monitor&amp;quot; (something that runs a task repeatedly, e.g. useful for resending algorithms) or an &amp;quot;expectation&amp;quot; (a promise/future that can time out, and also runs a monitor to repeatedly &amp;quot;try&amp;quot; to succeed, while it is not yet succeeded or failed, which is useful for &lt;em&gt;deferring&lt;/em&gt; high-level security properties but not forgetting about them, a very common pattern). I spent much of the week building these things and testing them, and using this practical experience to refine the APIs for the low-level scheduled computations.&lt;/p&gt;
&lt;p&gt;I also did some more short-term work to spread type-safe languages to more audiences, packaging OCaml 4.04 for Debian, and also reporting and working around some test failures for rustc 1.15.1 on Debian, earning me the label of &amp;quot;traitor&amp;quot; for a while. :p&lt;/p&gt;
&lt;p&gt;I wrote more documentation for my in-progress contribution to the ocaml-lens library, to bring traverse-once &amp;quot;van Laarhoven&amp;quot; lens to OCaml, similar to the ones in Haskell. I had some very interesting discussions with Jens and Rudi on Rust, Haskell, OCaml and various other &amp;quot;cutting-edge&amp;quot; FP research topics. Rudi also gave some useful feedback on my ocaml-lens code as well as some other pure functional utilities that I've been developing for the messaging protocol mentioned above, thanks Rudi!&lt;/p&gt;
&lt;p&gt;Viktor and Luk taught us how to play &lt;a href=&quot;https://web.archive.org/web/20161026135837/http://joshaguirre.com/cambio-card-game-rules-and-cheatsheet/&quot;&gt;Cambio&lt;/a&gt; and we in turn taught that to probably 10 more people around the hostel, including some non-mirage guests of the hostel! It was very enjoyable playing this into the early hours of the morning.&lt;/p&gt;
&lt;h2&gt;On one of the evenings Jurre and I got drunk and did some very diverse and uncensored karaoke and eventually embarassed^H^H^H^H^H^H^H persuaded a lot of the others to join us in the fun and celebrations. We'll be back next year with more, don't worry!&lt;/h2&gt;
&lt;h2&gt;Michele Orr&amp;ugrave;&lt;/h2&gt;
&lt;p&gt;Last summer I started, while being an intern in Paris, a &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;let's encrypt&lt;/a&gt; (or rather
&lt;a href=&quot;https://www.ietf.org/id/draft-ietf-acme-acme-06.txt&quot;&gt;ACME&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's encrypt is a certificate authority which issues signed certificates via an automated service (using the ACME protocol). Even though it is still in the process of being standardized, the first eCA already launched in April 2016, as a low-cost alternative to commercial CAs (where you usually need to provide identity information (passport) for verification).&lt;/p&gt;
&lt;p&gt;If you want to run a secure service on your domain, such as HTTPS, STARTTLS in SMTP, IMAPS, ..., you have to generate a private key and a certificate signing request (CSR).  You then upload this CSR via HTTP to the let's encrypt server and solve a some &amp;quot;challenge&amp;quot; proposed by the server in order to certify you &lt;em&gt;own&lt;/em&gt; the requested domain.&lt;/p&gt;
&lt;p&gt;At the time of the hack retreat, the following challenges were supported:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TLS (using the SNI extension),
&lt;/li&gt;
&lt;li&gt;DNS (setting a TXT record), or
&lt;/li&gt;
&lt;li&gt;HTTP (replying to a particular request at some &amp;quot;.well_known&amp;quot; url),
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In order to reach a working implementation, I had to implement myself a JSON web signature, and a JSON web key &lt;a href=&quot;https://github.com/mmaker/ocaml-letsencrypt/&quot;&gt;library in OCaml&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;My goal for the hack retreat was to polish this library, get it up to date with the new internet standards, and present this library to the Mirage community, as I do believe it could be the cornerstone for bootstrapping a unikernel on the internet having encryption by default. I was impressed by the overwhelming interest of the participants and their interest in helping out polishing this library. I spent a lot of time reviewing pull requests and coding with people I had just met. For instance, &lt;a href=&quot;https://github.com/reynir&quot;&gt;Reynir&lt;/a&gt; ported it to the &lt;a href=&quot;http://erratique.ch/software/topkg&quot;&gt;topkg&lt;/a&gt; packager, cleaned up the dependencies and made it possible to have a certificate for multiple domains. &lt;a href=&quot;https://github.com/vbaluch&quot;&gt;Viktor&lt;/a&gt; and &lt;a href=&quot;https://github.com/realfake&quot;&gt;Luk&lt;/a&gt; helped out implementing the DNS challenge. &lt;a href=&quot;https://github.com/azet&quot;&gt;Aaron&lt;/a&gt; helped out adding the new internet draft.&lt;/p&gt;
&lt;p&gt;While busy reviewing and merging the pull requests, and extending &lt;a href=&quot;https://github.com/Engil/Canopy&quot;&gt;Canopy&lt;/a&gt; to automatically renew its certificates (&lt;a href=&quot;https://github.com/Engil/Canopy/tree/feature/letsencrypt&quot;&gt;WIP on this feature branch&lt;/a&gt;). My library is still not released, but I will likely do an initial release before the end of the month, after some more tests.&lt;/p&gt;
&lt;h2&gt;This was the second time I attended the hack retreat, and it's been quite different: last year I was mostly helping out people, uncovering bugs and reporting documentation. This time it was other people helping me out and uncovering bugs on my code. The atmosphere and cooperation between the participants was amazing: everybody seemed to have different skills and be pleased to explain their own area of expertise, even at the cost of interrupting their own work. (I'd have to say sorry to Mindy and Thomas for interrupting too often, but they were sooo precious!) I particularly enjoyed the self-organized sessions: some of them, like Ximin's one on monads, even occurred spontaneously!&lt;/h2&gt;
&lt;h2&gt;Mindy Preston&lt;/h2&gt;
&lt;p&gt;Update 2017: Morocco, Marrakesh, the medina, and Priscilla are still sublime. Thank you very much to Hannes Mehnert for organizing and to the wonderful Queens at Priscilla for creating an excellent space and inviting us to inhabit it.&lt;/p&gt;
&lt;p&gt;I tried to spend some time talking with people about getting started with the project and with OCaml. There's still a thirst for good-first-bug which isn't met by &amp;quot;please implement this protocol&amp;quot;. People are also eager for intermediate-level contributions; people are less resistant to &amp;quot;please clean up this mess&amp;quot; than I would have expected. I think that figuring out how to make cross-cutting changes in Mirage is still not very accessible, and would be a welcome documentation effort; relatedly, surfacing the set of work we have to do in more self-contained packages would go a long way to filling that void and is probably easier.&lt;/p&gt;
&lt;p&gt;People were excited about, and did, documentation work!! And test implementation!! I was so excited to merge all of the PRs improving READMEs, blog entries, docstrings, and all of the other important bits of non-code that we haven't done a good job of keeping up with. It was &lt;em&gt;amazing&lt;/em&gt; to see test contributions to our existing repositories, too -- we have our first unit test touching ipv6 in tcpip since the ipv6 modules were added in 2014. :D Related to the previous bullet point, it would be great to point at a few repositories which particularly need testing and documentation attention -- I found doing that kind of work for mirage-tcpip very helpful when I was first getting started, and there's certainly more of it to do there and in other places as well.&lt;/p&gt;
&lt;p&gt;I spent a lot less time on install problems this year than last year, and a lot more time doing things like reviewing code, seeing cats, merging PRs, exploring the medina, cutting releases, climbing mountains, and pairing with people on building and testing stuff. \\o/&lt;/p&gt;
&lt;p&gt;Presentations from folks were a great addition! We got introductions to Angstrom and Base from Spiros, a tour through reversing unikernels with radare2 from Alfredo, and a solo5 walkthrough from Martin. Amir gave a great description of MirageOS, OCaml, and use cases like Nymote and Databox for some of our fellow guests and friends of the hostel.  My perception is that we had more folks from the non-Mirage OCaml community this year, and I think that was a great change; talking about jbuilder, Base, Logs, and Conduit from new perspectives was illuminating. I don't have much experience of writing OCaml outside of Mirage and it's surprisingly easy (for me, anyway) to get siloed into the tools we already use and the ways we already use them. Like last year, we had several attendees who don't write much OCaml or don't do much systems programming, and I'm really glad that was preserved -- that mix of perspectives is how we get new and interesting stuff, and also all of the people were nice :)&lt;/p&gt;
&lt;p&gt;There were several projects I saw more closely for the first time and was really interested in: g2p's storage, timada's performance harness; haesbaert's awa-ssh; maker's ocaml-acme; and there were tons of other things I didn't see closely but overheard interesting bits and pieces of!&lt;/p&gt;
&lt;h2&gt;Rereading the aggregated trip report from the 2016 spring hack retreat, it's really striking to me how much of Mirage 3's work started there; from this year's event, I think Mirage 4 is going to be amazing. :)&lt;/h2&gt;
&lt;h2&gt;Viktor Baluch &amp;amp; Luk Burchard:&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Let&amp;rsquo;s make operating systems great again&amp;rdquo; &amp;ndash; with this in mind we started our trip to Marrakech. But first things first: we are two first year computer science students from Berlin with not a whole lot of knowledge of hypervisors, operating systems or functional programming. This at first seems like a problem&amp;hellip; and it turned out it was :).
The plan was set, let&amp;rsquo;s learn this amazing language called OCaml and start hacking on some code, right? But, as you could imagine, it turned out to be different yet even better experience. When we arrived, we received a warm welcome in Marrakech from very motivated people who were happy to teach us new things from their areas of expertise. We wanted to share some of our valuable knowledge as well, so we taught some people how to play Cambio, our favourite card game, and it spread like wildfire (almost everyone was playing it in the second evening). We&amp;rsquo;re glad that we managed to set back productivity in such a fun way. ;P&lt;/p&gt;
&lt;p&gt;Back to what we came to Morocco for: as any programming language, OCaml seems to provide its special blend of build system challenges. &lt;a href=&quot;https://github.com/rgrinberg/&quot;&gt;Rudi&lt;/a&gt; was kind enough to help us navigate the labyrinth of distribution packages, opam, and ocamlfind with great patience and it took us only two days to get it almost right.&lt;/p&gt;
&lt;p&gt;Finally having a working installation, we got started by helping &lt;a href=&quot;https://github.com/mmaker/&quot;&gt;Michele&lt;/a&gt; with his &lt;a href=&quot;https://github.com/mmaker/ocaml-acme/&quot;&gt;ocaml-acme&lt;/a&gt; package, a client for Let's Encrypt (and other services implementing the protocol). An easy to use and integrate client seemed like one feature that could provide a boost to unikernel adoption and it looked like a good match for us as OCaml beginners since there are many implementations in other programming languages that we could refer to. After three days we finally made our first Open Source OCaml contributions to this MirageOS-related project by implementing the dns-01 challenge.&lt;/p&gt;
&lt;p&gt;Hacking away on OCaml code of course wasn&amp;rsquo;t the only thing we did in Marrakech: we climbed the Atlas mountains to see the seven magic waterfalls (little disclaimer: there are only four). It was not a really productive day but great for building up the spirit which makes the community so unique and special. Seeing camels might also helped a little bit. ;)&lt;/p&gt;
&lt;p&gt;One of the most enjoyable things that the retreat provided was the chance for participants to share knowledge through presentations which lead to very interesting conversations like after &lt;a href=&quot;https://github.com/amirmc/&quot;&gt;Amir&amp;rsquo;s&lt;/a&gt; presentation when some artists asked about sense of life and computer systems (by the way, one question is already solved and it is &amp;rsquo;42&amp;rsquo;). We were also very impressed by the power and expressiveness of functional languages which &lt;a href=&quot;https://github.com/seliopou/&quot;&gt;Sprios&lt;/a&gt; demonstrated in his parser combinator &lt;a href=&quot;https://github.com/inhabitedtype/angstrom/&quot;&gt;Angstrom&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thank you to everyone involved for giving us the experience of an early &amp;lsquo;enlightenment&amp;rsquo; about functional programming as first year students and the engaging discussions with so many amazing people! We sure learned a lot and will continue working with OCaml and MirageOS whenever possible.&lt;/p&gt;
&lt;h2&gt;Hope to see all of you again next time!&lt;/h2&gt;
&lt;h2&gt;Aaron Zauner&lt;/h2&gt;
&lt;p&gt;I flew from Egypt to Marrakech not sure what to expect, although I'm not new to functional programming, I'm a total OCaml novice and haven't worked on unikernels - but have always been interested in the topic. Hannes invited me to hang out and discuss, and that's exactly what I did. I really enjoyed spending my time with and meeting all of you. Some of you I have known &amp;quot;from the interwebs&amp;quot; for a while, but never met in person, so this was a great opportunity for me to finally get to see some of you in real life. I spent most of my time discussing security topics (everything from cryptography, bootstrapping problems to telco/ mobile security), operating system design and some programming language theory. I got to know the OCaml environment, a bit more about MirageOS and I read quite a few cryptography and operating system security papers.&lt;/p&gt;
&lt;h2&gt;All of the people I spoke with were very knowledgeble - and I got to see what people exactly work on in MirageOS - which certainly sparked further interest in the project. I've been to Morocco a couple of times but the food we got at Queens of the Medina was by far the best food I've eaten in Morocco so far. I think the mix of nerds and artists living at the Riad was really inspiring for all of us, I was certainly interested in what they were working on, and they seemed to be interested in what all of these freaky hackers were about too. Living together for more than a week gives the opportunity to get to know people not only on a technical level but -- on a personal level, in my opinion we had a great group of people. Giving back to the local community by giving talks on what we're doing at the Hackathon was a great idea, and I enjoyed all of the talks that I've attended. I've been to a few hackathons (and even organized one or two), but this one has certainly been the most enjoyable one for me. People, food, location and the discussions (also Karaoke and learning to play Cambio!) I've had will make me remember the time I spent with you guys for a long time. I hope I'm able to join again at some point (and actually contribute to code not only discussions) in the future. Unfortunately I cannot give any feedback on possible improvements, as I think we had a very well selected group of people and perfect conditions for a Hackathon, could not think of how to organize it better - Thank you Hannes!&lt;/h2&gt;
&lt;h2&gt;Thomas Leonard&lt;/h2&gt;
&lt;p&gt;This was my second time at the hackathon, and it was great to see everyone and work on Mirage stuff again! I brought along a NUC which provided an additional wireless access point, running a Mirage/Xen DHCP server using haesbaert's &lt;a href=&quot;https://github.com/mirage/charrua-core&quot;&gt;charrua&lt;/a&gt; library - one of the fruits of last year's efforts.&lt;/p&gt;
&lt;p&gt;My goal this year was to update &lt;a href=&quot;http://roscidus.com/blog/blog/2016/01/01/a-unikernel-firewall-for-qubesos/&quot;&gt;qubes-mirage-firewall&lt;/a&gt; to support Mirage 3 and the latest version of &lt;a href=&quot;https://github.com/yomimono/mirage-nat&quot;&gt;mirage-nat&lt;/a&gt;, and to add support for NAT of ICMP messages (so that &lt;code&gt;ping&lt;/code&gt; works and connection errors are reported). In the process, I converted mirage-nat to use the new parsers in the Mirage 3 version of the tcpip library, which cleaned up the code a lot. It turned out that the firewall stressed these parsers in new ways and we were able to &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/pull/301&quot;&gt;make them more robust&lt;/a&gt; as a result. Having Mirage 3 release manager and mirage-nat author yomimono on hand to help out was very useful!&lt;/p&gt;
&lt;p&gt;It was great to see so many QubesOS users there this year. Helping them get the firewall installed motivated me to write some proper installation instructions for &lt;a href=&quot;https://github.com/talex5/qubes-test-mirage&quot;&gt;qubes-test-mirage&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After the hackathon, I also updated mirage-nat to limit the size of the NAT table (using pqwy's &lt;a href=&quot;https://github.com/pqwy/lru&quot;&gt;lru&lt;/a&gt;) and made a new release of the firewall with all the improvements.&lt;/p&gt;
&lt;p&gt;ComposMin was looking for a project and I hopefully suggested some tedious upgrading and build system porting work. He accepted!! So, &lt;a href=&quot;https://github.com/talex5/qubes-mirage-skeleton&quot;&gt;qubes-mirage-skeleton&lt;/a&gt; now works with Mirage 3 and &lt;a href=&quot;https://github.com/mirage/mirage-profile&quot;&gt;mirage-profile&lt;/a&gt; has been ported to topkg - something I had previously attempted and failed at.&lt;/p&gt;
&lt;p&gt;Rudi gave me an introduction to the new &lt;a href=&quot;https://github.com/janestreet/jbuilder&quot;&gt;jbuilder&lt;/a&gt; build tool and I look forward to converting some of my projects to use it in the near future.&lt;/p&gt;
&lt;p&gt;Particularly useful for me personally was the chance discovery that Ximin Luo is a Debian Developer. He signed my GPG key, allowing me to complete a Debian key rollover that I began in May 2009, and thus recover the ability to update my package again.&lt;/p&gt;
&lt;p&gt;I also wanted to work on &lt;a href=&quot;https://github.com/talex5/irmin-indexeddb&quot;&gt;irmin-indexeddb&lt;/a&gt; (which allows web applications to store Irmin data in the browser), but ran out of time - maybe next year...&lt;/p&gt;
&lt;h2&gt;Many thanks to hannesm for organising this!&lt;/h2&gt;
&lt;h2&gt;Amir Chaudhry&lt;/h2&gt;
&lt;p&gt;This was my first time at the Marrakech hack retreat. I was only there for about half the time (mostly the weekend) and my goal was simply to meet people and understand what their experiences have been. Having missed the inaugural event last year, I wasn't sure what to expect in terms of format/event. What I found was a very relaxed approach with lots of underlying activity. The daily stand ups just before lunch were well managed and it was interesting to hear what people were thinking of working on, even when that included taking a break. The food was even more amazing than I'd been led to believe by tweets :)&lt;/p&gt;
&lt;p&gt;Somehow, a few hours after I arrived, Hannes managed to sweet-talk me in to giving a presentation the next day about MirageOS to the artists and dance troupe that normally make use of the venue. Since we'd taken over the place for a week &amp;mdash; displacing their normal activities &amp;mdash; our host thought it would be helpful if someone explained &amp;quot;what the nerds are doing here&amp;quot;. This was an unexpected challenge as getting across the background for MirageOS involves a lot of assumed knowledge about operating system basics, software development, software &lt;em&gt;itself&lt;/em&gt;, the differences between end-users and developers, roughly how the internet works, and so on. There's a surprising number of things that we all just 'know', which the average software user has no clue about. I hadn't given a talk to that kind of audience before so I spent half a day scrambling for analogies before settling on one that seemed like it might work &amp;mdash; involving houses, broken windows, and the staff of Downton Abbey. The talk led to a bunch of interesting discussions with the artists which everyone got involved with. I think the next time I do this, I might also add an analogy around pizza (I have many ideas on this theme already). If you're interested in the slides themselves (mostly pics), there's a PDF at https://www.dropbox.com/s/w5wnlbxujf7pk5w/Marrakech.pdf?dl=0&lt;/p&gt;
&lt;p&gt;I also had time to chat with Mindy about an upcoming talk on MirageOS 3.0, and Martin about future work on Solo5. The talks and demos I saw were really useful too and sharing that knowledge with others in this kind of environment was a great idea. Everyone loved the t-shirts and were especially pleased to see me as it turned out I was bringing many of the medium-sized ones. One of the best things about this trip was putting names and faces to GitHub handles, though my brain regularly got the mapping wrong. :)&lt;/p&gt;
&lt;h2&gt;Overall, this was an excellent event and now that it's happened twice, I think we can call it a tradition. I'm looking forward to the next one!&lt;/h2&gt;
&lt;h2&gt;Jurre van Bergen&lt;/h2&gt;
&lt;p&gt;I spent most of my time reading up on functional programming and setting up an developer environment and helped with some small things here and there. I didn't feel confident to do a lot of code yet, but it was a very nice environment to ask questions in, especially as a newcomer to MirageOS and OCaml!&lt;/p&gt;
&lt;p&gt;I plan to do more OCaml in my spare time and play more with MirageOS in the future. Maybe someday, we can actually merge in some MirageOS things into &lt;a href=&quot;https://tails.boum.org/&quot;&gt;Tails&lt;/a&gt;. I hope to actually do some OCaml code with people next year!
Next to that, there was also some time to relax, climbing the Atlas mountains was a welcome change of scenery after reading through up on functional programming for a couple of days. Will definitely do that again some day!&lt;/p&gt;
&lt;h2&gt;Next to that, shout out to Viktor and Luke for teaching us how to play Cambio, we had a lot of fun with it the entire retreat in the evenings!
I was excited to learn that so many people were actually into karaoke, I hope those who don't will join us next year ;-)&lt;/h2&gt;
&lt;h2&gt;Reynir Bj&amp;ouml;rnsson&lt;/h2&gt;
&lt;p&gt;A work in progress from Reynir is his work on documentation in the toplevel:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As mentioned on the midday talkie talkie I've made a OCaml toplevel directive for querying documentation (if available). It's available here &lt;a href=&quot;https://github.com/reynir/ocp-index-top&quot;&gt;https://github.com/reynir/ocp-index-top&lt;/a&gt;.
To test it out you can install it with opam pin:
opam pin add ocp-index-top https://github.com/reynir/ocp-index-top.git&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It doesn't depend on opam-lib. opam-lib is yuuuuge and the API is unstable. Instead I shell out to opam directly similar to how ocp-browser works. This means installing the package is less likely to make a mess in your dependencies.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is one issue I don't know how to fix (see issue #1). When requiring &lt;code&gt;ocp-index-top&lt;/code&gt; the &lt;code&gt;compiler-libs&lt;/code&gt; and &lt;code&gt;ocp-index.lib&lt;/code&gt; libraries are pulled into scope which is not cool and totally unnecessary.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;Many thanks to everyone involved!  The hackathon is already booked for next year in the same place...&lt;/p&gt;

      </content><id>https://mirage.io/blog/2017-march-hackathon-roundup</id><title type="text">MirageOS March 2017 hack retreat roundup</title><updated>2017-04-15T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/irmin-1.0" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;I am really happy to announce the release of Irmin 1.0, which fully
supports MirageOS 3.0 and which brings a simpler and yet more
expressive API. Irmin is a library for designing Git-like distributed
databases, with built-in branching, snapshoting, reverting and
auditing capabilities. With Irmin, applications can create tailored
mergeable datastructures to scale seamlessly. Applications built on
top of Irmin include &lt;a href=&quot;https://tezos.com/&quot;&gt;Tezos&lt;/a&gt;, a distributed ledger,
&lt;a href=&quot;https://github.com/docker/datakit&quot;&gt;Datakit&lt;/a&gt;, a distributed and reactive key-value store, and
&lt;a href=&quot;https://github.com/talex5/cuekeeper&quot;&gt;cuekeeper&lt;/a&gt;, a web-based GTD system. Read &lt;a href=&quot;https://mirage.io/blog/introducing-irmin&quot;&gt;&amp;quot;Introducing
Irmin: Git-like distributed, branchable storage&amp;quot;&lt;/a&gt; for a
description of the concepts and high-level architecture of the system.&lt;/p&gt;
&lt;p&gt;To install Irmin 1.0:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opam install irmin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The running example in this post will be an imaginary model for
collecting distributed metrics (for instance to count network
packets). In this model, every node has a unique ID, and uses Irmin to
store metrics names and counters. Every node is also a distributed
collector and can sync with the metrics of other nodes at various
points in time. Users of the application can read metrics for the
network from any node. We want the metrics to be eventually
consistent.&lt;/p&gt;
&lt;p&gt;This post will describe:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;how to define the metrics as a mergeable data-structures;
&lt;/li&gt;
&lt;li&gt;how to create a new Irmin store with the metrics, the basic
operations that are available and how to define atomic operations; and
&lt;/li&gt;
&lt;li&gt;how to create and merge branches.
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Mergeable Contents&lt;/h3&gt;
&lt;p&gt;Irmin now exposes &lt;code&gt;Irmin.Type&lt;/code&gt; to create new mergeable contents more
easily. For instance, the following type defines the property of
simple metrics, where &lt;code&gt;name&lt;/code&gt; is a human-readable name and &lt;code&gt;gauge&lt;/code&gt; is a
metric counting the number of occurences for some kind of event:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;type metric = {
  name : string;
  gauge: int64;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First of all, we need to reflect the structure of the type, to
automatically derive serialization (to and from JSON, binary encoding,
etc) functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let metric_t =
  let open Irmin.Type in
  record &amp;quot;metric&amp;quot; (fun name gauge -&amp;gt; { name; gauge })
  |+ field &amp;quot;name&amp;quot;  string (fun t -&amp;gt; t.name)
  |+ field &amp;quot;gauge&amp;quot; int64    (fun t -&amp;gt; t.gauge)
  |&amp;gt; sealr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;record&lt;/code&gt; is used to describe a new (empty) record with a name and a
constructor; &lt;code&gt;field&lt;/code&gt; describes record fields with a name a type and an
accessor function while &lt;code&gt;|+&lt;/code&gt; is used to stack fields into the
record. Finally &lt;code&gt;|&amp;gt; sealr&lt;/code&gt; seals the record, e.g. once applied no more
fields can be added to it.&lt;/p&gt;
&lt;p&gt;All of the types in Irmin have such a description, so they can be
easily and efficiently serialized (to disk and/or over the
network). For instance, to print a value of type &lt;code&gt;metric&lt;/code&gt; as a JSON object,
one can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let print m = Fmt.pr &amp;quot;%a\\n%!&amp;quot; (Irmin.Type.pp_json metric_t) m
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once this is defined, we now need to write the merge function. The
consistency model that we want to define is the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt; : can change if there is no conflicts between branches.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gauge&lt;/code&gt;: the number of events seen on a branch. Can be updated
either by incrementing the number (because events occured) or by
syncing with other nodes partial knowledge. This is very similar to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type&quot;&gt;conflict-free replicated datatypes&lt;/a&gt; and related
&lt;a href=&quot;https://en.wikipedia.org/wiki/Vector_clock&quot;&gt;vector-clock&lt;/a&gt; based algorithms. However, in Irmin we keep the
actual state as simple as possible: for counters, it is a single
integer -- but the user needs to provide an external 3-way merge
function to be used during merges.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similarly to the type definitions, the 3-way merge functions can
defined using &amp;quot;merge&amp;quot; combinators. Merge combinators for records are
not yet available (but they are planned on the roadmap), so we need to
use &lt;code&gt;Irmin.Merge.like&lt;/code&gt; to map the record definition to a pair:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let merge =
  let open Irmin.Merge in
  like metric_t (pair string counter)
    (fun x -&amp;gt; x.name, x.gauge)
    (fun (name, gauge) -&amp;gt; {name; gauge })
  |&amp;gt; option
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final step to define a mergeable data-structure is to wrap
everything into a module satisfying the &lt;a href=&quot;http://mirage.github.io/irmin/Irmin.Contents.S.html&quot;&gt;Irmin.Contents.S&lt;/a&gt;
signature:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;module Metric: Irmin.Contents.S with type t = metric = struct
  type t = metric
  let t = metric_t
  let merge = merge
  let pp = Irmin.Type.pp_json metric_t
  let of_string s =
    Irmin.Type.decode_json metric_t (Jsonm.decoder (`String s))
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Creating an Irmin Store&lt;/h3&gt;
&lt;p&gt;To create a key/value store to store metrics, using the on-disk Git
format:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;module Store = Irmin_unix.Git.FS.KV(Metric)
let config = Irmin_git.config &amp;quot;/tmp/irmin&amp;quot;
let info fmt = Irmin_unix.info ~author:&amp;quot;Thomas&amp;quot; fmt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Store&lt;/code&gt; &lt;a href=&quot;http://mirage.github.io/irmin/Irmin.S.html&quot;&gt;exposes&lt;/a&gt; various functions to create and manipulate
Irmin stores. &lt;code&gt;config&lt;/code&gt; is used to configure Irmin repositories based
on &lt;code&gt;Store&lt;/code&gt;. In that example we decided to keep the store state in
&lt;code&gt;&amp;quot;/tmp/irmin&amp;quot;&lt;/code&gt; (which can be inspected using the usual Git
tools). &lt;code&gt;info&lt;/code&gt; is the function used to create new commit information:
&lt;code&gt;Irmin_unix.info&lt;/code&gt; use the usual POSIX clock for timestamps, and can
also be tweaked to specify the author name.&lt;/p&gt;
&lt;p&gt;The most common functions to create an Irmin store are
&lt;code&gt;Store.Repo.create&lt;/code&gt; to create an Irmin repository and &lt;code&gt;Store.master&lt;/code&gt;
to get a handler on the &lt;code&gt;master&lt;/code&gt; branch in that repository. For
instance, using the OCaml toplevel:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;# open Lwt.Infix;;

# let repo = Store.Repo.v config;;
val repo : Store.Repo.t Lwt.t = &amp;lt;abstr&amp;gt;
# let master = repo &amp;gt;&amp;gt;= fun repo -&amp;gt; Store.master repo;;
val master : Store.t Lwt.t = &amp;lt;abstr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Store&lt;/code&gt; also exposes the usual key/value base operations using
&lt;a href=&quot;http://mirage.github.io/irmin/Irmin.S.html#VALfind&quot;&gt;find&lt;/a&gt; and
&lt;a href=&quot;http://mirage.github.io/irmin/Irmin.S.html#VALset&quot;&gt;set&lt;/a&gt;. All the
operations are reflected as Git state.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  Lwt_main.run begin
      Store.Repo.v config &amp;gt;&amp;gt;= Store.master &amp;gt;&amp;gt;= fun master -&amp;gt;
      Store.set master
        ~info:(info &amp;quot;Creating a new metric&amp;quot;)
        [&amp;quot;vm&amp;quot;; &amp;quot;writes&amp;quot;] { name = &amp;quot;write Kb/s&amp;quot;; gauge = 0L }
      &amp;gt;&amp;gt;= fun () -&amp;gt;
      Store.get master [&amp;quot;vm&amp;quot;; &amp;quot;writes&amp;quot;] &amp;gt;|= fun m -&amp;gt;
      assert (m.gauge = 0L);
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that &lt;code&gt;Store.set&lt;/code&gt; is atomic: the implementation ensures that no
data is ever lost, and if someone else is writing on the same path at
the same, the operation is retried until it succeeds (see &lt;a href=&quot;https://en.wikipedia.org/wiki/Optimistic_concurrency_control&quot;&gt;optimistic
transaction control&lt;/a&gt;). More complex atomic operations are also
possible: the API also exposes function to read and write subtrees
(simply called trees) instead of single values. Trees are very
efficient: they are immutable so all the reads are cached in memory
and done only when really needed; and write on disk are only done the
final transaction is commited. Trees are also stored very efficiently
in memory and on-disk as they are deduplicated. For users of previous
releases of Irmin: trees replaces the concept of views, but have a
very implementation and usage.&lt;/p&gt;
&lt;p&gt;An example of a tree transaction is a custom-defined move function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let move t src dst =
  Store.with_tree t
    ~info:(info &amp;quot;Moving %a to %a&amp;quot; Store.Key.pp src Store.Key.pp dst)
    [] (fun tree -&amp;gt;
          let tree = match tree with
            | None -&amp;gt; Store.Tree.empty
            | Some tree -&amp;gt; tree
          in
          Store.Tree.get_tree tree src &amp;gt;&amp;gt;= fun v -&amp;gt;
          Store.Tree.remove tree src &amp;gt;&amp;gt;= fun _ -&amp;gt;
          Store.Tree.add_tree tree dst v &amp;gt;&amp;gt;= Lwt.return_some
    )
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Creating and Merging Branches&lt;/h3&gt;
&lt;p&gt;They are two kinds of stores in Irmin: permanent and temporary
ones. In Git-speak, these are &amp;quot;branches&amp;quot; and &amp;quot;detached
heads&amp;quot;. Permanent stores are created from branch names using
&lt;code&gt;Store.of_branch&lt;/code&gt; (&lt;code&gt;Store.master&lt;/code&gt; being an alias to &lt;code&gt;Store.of_branch Store.Branch.master&lt;/code&gt;) while temporary stores are created from commit
using &lt;code&gt;Store.of_commit&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The following example show how to clone the master branch, how to make
concurrent update to both branches, and how to merge them back.&lt;/p&gt;
&lt;p&gt;First, let's define an helper function to increment the &lt;code&gt;/vm/writes&lt;/code&gt;
gauge in a store &lt;code&gt;t&lt;/code&gt;, using a transaction:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let incr t =
  let path = [&amp;quot;vm&amp;quot;; &amp;quot;writes&amp;quot;] in
  Store.with_tree ~info:(info &amp;quot;New write event&amp;quot;) t path (fun tree -&amp;gt;
      let tree = match tree with
        | None -&amp;gt; Store.Tree.empty
        | Some tree -&amp;gt; tree
      in
      (Store.Tree.find tree [] &amp;gt;|= function
        | None   -&amp;gt; { name = &amp;quot;writes in kb/s&amp;quot;; gauge = 0L }
        | Some x -&amp;gt; { x with gauge = Int64.succ x.gauge })
      &amp;gt;&amp;gt;= fun m -&amp;gt;
      Store.Tree.add tree [] m
      &amp;gt;&amp;gt;= Lwt.return_some
    )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, the following program create an empty gauge on &lt;code&gt;master&lt;/code&gt;,
increment the metrics, then create a &lt;code&gt;tmp&lt;/code&gt; branch by cloning
&lt;code&gt;master&lt;/code&gt;. It then performs two increments in parallel in both
branches, and finally merge &lt;code&gt;tmp&lt;/code&gt; back into &lt;code&gt;master&lt;/code&gt;. The result is a
gauge which have been incremented three times in total: the &amp;quot;counter&amp;quot;
merge function ensures that the result counter is consistent: see
&lt;a href=&quot;http://kcsrk.info/ocaml/irmin/crdt/2017/02/15/an-easy-interface-to-irmin-library/&quot;&gt;KC's blog post&lt;/a&gt; for more details about the semantic of recursive
merges.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let () =
  Lwt_main.run begin
    Store.Repo.v config &amp;gt;&amp;gt;= Store.master &amp;gt;&amp;gt;= fun master -&amp;gt; (* guage 0 *)
    incr master &amp;gt;&amp;gt;= fun () -&amp;gt; (* gauge = 1 *)
    Store.clone ~src:master ~dst:&amp;quot;tmp&amp;quot; &amp;gt;&amp;gt;= fun tmp -&amp;gt;
    incr master &amp;gt;&amp;gt;= fun () -&amp;gt; (* gauge = 2 on master *)
    incr tmp    &amp;gt;&amp;gt;= fun () -&amp;gt; (* gauge = 2 on tmp *)
    Store.merge ~info:(info &amp;quot;Merge tmp into master&amp;quot;) tmp ~into:master
    &amp;gt;&amp;gt;= function
    | Error (`Conflict e) -&amp;gt; failwith e
    | Ok () -&amp;gt;
      Store.get master [&amp;quot;vm&amp;quot;; &amp;quot;writes&amp;quot;] &amp;gt;|= fun m -&amp;gt;
      Fmt.pr &amp;quot;Gauge is %Ld\\n%!&amp;quot; m.gauge
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Irmin 1.0 is out. Defining new mergeable contents is now simpler. The
Irmin API to create stores as also been simplified, as well as
operations to read and write atomically. Finally, flexible first-class
support for immutable trees has also been added.&lt;/p&gt;
&lt;p&gt;Send us feedback on the &lt;a href=&quot;https://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel&quot;&gt;MirageOS mailing-list&lt;/a&gt; or on the &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin
issue tracker on GitHub&lt;/a&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/irmin-1.0</id><title type="text">Easy distributed analytics with Irmin 1.0</title><updated>2017-03-06T00:00:00-00:00</updated><author><name>Thomas Gazagnaire</name></author></entry><entry><link href="https://mirage.io/blog/qubes-target" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;When I got a new laptop in early 2016, I decided to try out this &lt;a href=&quot;https://qubesos.org&quot;&gt;QubesOS&lt;/a&gt; all the cool kids were talking about.  QubesOS also runs a hypervisor, but it nicely supports running multiple virtual machines for typical user tasks, like looking at cat photos with a web browser, viewing a PDF, listening to music, or patching MirageOS.  QubesOS also uses Xen, which means we should be able to even &lt;em&gt;run&lt;/em&gt; our MirageOS unikernels on it... right?&lt;/p&gt;
&lt;p&gt;The answer is &lt;a href=&quot;http://roscidus.com/blog/blog/2016/01/01/a-unikernel-firewall-for-qubesos/&quot;&gt;yes, after a fashion&lt;/a&gt;.  Thomas Leonard did the hard work of writing &lt;a href=&quot;https://github.com/mirage/mirage-qubes&quot;&gt;mirage-qubes&lt;/a&gt;, a library that interfaces nicely with the QubesOS management layer and allows MirageOS unikernels to boot, configure themselves, and run as managed by the Qubes management system.  That solution is nice for generating, once, a unikernel that you're going to run all the time under QubesOS, but building a unikernel that will boot and run on QubesOS requires QubesOS-specific code in the unikernel itself.  It's very unfriendly for testing generic unikernels, and as the release manager for Mirage 3, I wanted to do that pretty much all the time.&lt;/p&gt;
&lt;p&gt;The command-line &lt;code&gt;mirage&lt;/code&gt; utility was made to automatically build programs against libraries that are specific to a target only when the user has asked to build for that target, which is the exact problem we have!  So let's try to get to &lt;code&gt;mirage configure -t qubes&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;teach a robot to do human tricks&lt;/h2&gt;
&lt;p&gt;In order for Qubes to successfully boot our unikernel, it needs to do at least two (but usually three) things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;start a qrexec listener, and respond to requests from dom0
&lt;/li&gt;
&lt;li&gt;start a qubes-gui listener, and respond to requests from dom0
&lt;/li&gt;
&lt;li&gt;if we're going to do networking (usually we are), get the network configuration from qubesdb
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There's code for doing all of these available in the &lt;a href=&quot;https://github.com/mirage/mirage-qubes&quot;&gt;mirage-qubes&lt;/a&gt; library, and a nice example available at &lt;a href=&quot;https://github.com/talex5/qubes-mirage-skeleton&quot;&gt;qubes-mirage-skeleton&lt;/a&gt;.  The example at qubes-mirage-skeleton shows us what we have to plumb into a MirageOS unikernel in order to boot in Qubes.  All of the important stuff is in &lt;code&gt;unikernel.ml&lt;/code&gt;.  We need to pull the code that connects to RExec and GUI:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;(* Start qrexec agent, GUI agent and QubesDB agent in parallel *)
   let qrexec = RExec.connect ~domid:0 () in
   let gui = GUI.connect ~domid:0 () in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;qrexec&lt;/code&gt; and &lt;code&gt;gui&lt;/code&gt; are Lwt threads that will resolve in the records we need to pass to the respective &lt;code&gt;listen&lt;/code&gt; functions from the &lt;code&gt;RExec&lt;/code&gt; and &lt;code&gt;GUI&lt;/code&gt; modules.  We'll state the rest of the program in terms of what to do once they're connected with a couple of monadic binds:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;    (* Wait for clients to connect *)
    qrexec &amp;gt;&amp;gt;= fun qrexec -&amp;gt;
    let agent_listener = RExec.listen qrexec Command.handler in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;agent_listener&lt;/code&gt; is called much later in the program.  It's not something we'll use generally in an adaptation of this code for a generic unikernel running on QubesOS -- instead, we'll invoke &lt;code&gt;RExec.listen&lt;/code&gt; with a function that disregards input.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;    gui &amp;gt;&amp;gt;= fun gui -&amp;gt;
    Lwt.async (fun () -&amp;gt; GUI.listen gui);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use &lt;code&gt;gui&lt;/code&gt; right away, though.  &lt;code&gt;Lwt.async&lt;/code&gt; lets us start an Lwt thread that the rest of our program logic isn't impacted by, but needs to be hooked into the event loop.  The function we define in this call asks &lt;code&gt;GUI.listen&lt;/code&gt; to handle incoming events for the &lt;code&gt;gui&lt;/code&gt; record we got from &lt;code&gt;GUI.connect&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;qubes-mirage-skeleton&lt;/code&gt; does an additional bit of setup:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;    Lwt.async (fun () -&amp;gt;
      OS.Lifecycle.await_shutdown_request () &amp;gt;&amp;gt;= fun (`Poweroff | `Reboot) -&amp;gt;
      RExec.disconnect qrexec
    );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This hooks another function into the event loop: a listener which hears shutdown requests from &lt;a href=&quot;https://github.com/mirage/mirage-platform/blob/2d044a499824c98ee2f067b71110883e9226d8cf/xen/lib/lifecycle.ml#L21&quot;&gt;OS.Lifecycle&lt;/a&gt; and disconnects &lt;code&gt;RExec&lt;/code&gt; when they're heard.  The &lt;code&gt;disconnect&lt;/code&gt; has the side effect of terminating the &lt;code&gt;agent_listener&lt;/code&gt; if it's running, as documented in &lt;a href=&quot;https://github.com/talex5/mirage-qubes/master/lib/qubes.mli#L130%22&quot;&gt;mirage-qubes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;qubes-mirage-skeleton&lt;/code&gt; then configures its networking (we'll talk about this later) and runs a test to make sure it can reach the outside world.  Once that's finished, it calls the &lt;code&gt;agent_listener&lt;/code&gt; defined above, which listens for commands via &lt;code&gt;RExec.listen&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;making mirageos unikernels&lt;/h2&gt;
&lt;p&gt;Building MirageOS unikernels is a three-phase process:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mirage configure: generate main.ml unifying your code with the devices it needs
&lt;/li&gt;
&lt;li&gt;make depend: make sure you have the libraries required to build the final artifact
&lt;/li&gt;
&lt;li&gt;make: build your application against the specified configuration
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In order to get an artifact that automatically includes the code above, we need to plumb the tasks above into &lt;code&gt;main.ml&lt;/code&gt;, and the libraries they depend on into &lt;code&gt;make depend&lt;/code&gt;, via &lt;code&gt;mirage configure&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;let's quickly revisit what impl passing usually looks like&lt;/h2&gt;
&lt;p&gt;Applications built to run as MirageOS unikernels are written as OCaml functors.  They're parameterized over OCaml modules providing implementations of some functionality, which is stated as a module type.  For example, here's a MirageOS networked &amp;quot;hello world&amp;quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;module Main (N: Mirage_net_lwt.S) = struct

  let start (n : N.t)  =
    N.write n @@ Cstruct.of_string &amp;quot;omg hi network&amp;quot; &amp;gt;&amp;gt;= function
    | Error e -&amp;gt; Log.warn (fun f -&amp;gt; f &amp;quot;failed to send message&amp;quot;); Lwt.return_unit
    | Ok () -&amp;gt; Log.info (fun f -&amp;gt; f &amp;quot;said hello!&amp;quot;); Lwt.return_unit

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our program is in a module that's parameterized over the module &lt;code&gt;N&lt;/code&gt;, which can be any module that matches the module type &lt;code&gt;Mirage_net_lwt.S&lt;/code&gt;.  The entry point for execution is the &lt;code&gt;start&lt;/code&gt; function, which takes one argument of type &lt;code&gt;N.t&lt;/code&gt;.  This is the usual pattern for Mirage unikernels, powered by Functoria's &lt;a href=&quot;https://mirage.io/blog/introducing-functoria&quot;&gt;invocation of otherworldly functors&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But there are other modules which aren't explicitly passed.  Since MirageOS version 2.9.0, for example, a &lt;code&gt;Logs&lt;/code&gt; module has been available to MirageOS unikernels.  It isn't explicitly passed as a module argument to &lt;code&gt;Main&lt;/code&gt;, because it's assumed that all unikernels will want to use it, and so it's always made available.  The &lt;code&gt;OS&lt;/code&gt; module is also always available, although the implementation will be specific to the target for which the unikernel was configured, and there is no module type to which the module is forced to conform.&lt;/p&gt;
&lt;h2&gt;providing additional modules&lt;/h2&gt;
&lt;p&gt;Let's look first at fulfilling the &lt;code&gt;qrexec&lt;/code&gt; and &lt;code&gt;gui&lt;/code&gt; requirements, which we'll have to do for any unikernel that's configured with &lt;code&gt;mirage configure -t qubes&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When we want a module passed to the generated unikernel, we start by making a &lt;code&gt;job&lt;/code&gt;.  Let's add one for &lt;code&gt;qrexec&lt;/code&gt; to &lt;code&gt;lib/mirage.ml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let qrexec = job
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and we'll want to define some code for what &lt;code&gt;mirage&lt;/code&gt; should do if it's determined from the command-line arguments to &lt;code&gt;mirage configure&lt;/code&gt; that a &lt;code&gt;qrexec&lt;/code&gt; is required:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let qrexec_qubes = impl @@ object
  inherit base_configurable
  method ty = qrexec
  val name = Name.ocamlify @@ &amp;quot;qrexec_&amp;quot;
  method name = name
  method module_name = &amp;quot;Qubes.RExec&amp;quot;
  method packages = Key.pure [ package &amp;quot;mirage-qubes&amp;quot; ]
  method configure i =
    match get_target i with
    | `Qubes -&amp;gt; R.ok ()
    | _ -&amp;gt; R.error_msg &amp;quot;Qubes remote-exec invoked for non-Qubes target.&amp;quot;
  method connect _ modname _args =
    Fmt.strf
      &amp;quot;@[&amp;lt;v 2&amp;gt;\\
       %s.connect ~domid:0 () &amp;gt;&amp;gt;= fun qrexec -&amp;gt;@ \\
       Lwt.async (fun () -&amp;gt;@ \\
       OS.Lifecycle.await_shutdown_request () &amp;gt;&amp;gt;= fun _ -&amp;gt;@ \\
       %s.disconnect qrexec);@ \\
       Lwt.return (`Ok qrexec)@]&amp;quot;
      modname modname
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This defines a &lt;code&gt;configurable&lt;/code&gt; object, which inherits from the &lt;code&gt;base_configurable&lt;/code&gt; class defined in Mirage.  The interesting bits for this &lt;code&gt;configurable&lt;/code&gt; are the methods &lt;code&gt;packages&lt;/code&gt;, &lt;code&gt;configure&lt;/code&gt;, and &lt;code&gt;connect&lt;/code&gt;. &lt;code&gt;packages&lt;/code&gt; is where the dependency on &lt;code&gt;mirage-qubes&lt;/code&gt; is declared.  &lt;code&gt;configure&lt;/code&gt; will terminate if &lt;code&gt;qrexec_qubes&lt;/code&gt; has been pulled into the dependency graph but the user invoked another target (for example, &lt;code&gt;mirage configure -t unix&lt;/code&gt;).  &lt;code&gt;connect&lt;/code&gt; gives the instructions for generating the code for &lt;code&gt;qrexec&lt;/code&gt; in &lt;code&gt;main.ml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You may notice that &lt;code&gt;connect&lt;/code&gt;'s &lt;code&gt;strf&lt;/code&gt; call doesn't refer to &lt;code&gt;Qrexec&lt;/code&gt; directly, but rather takes a &lt;code&gt;modname&lt;/code&gt; parameter.  Most of the modules referred to will be the result of some functor application, and the previous code generation will automatically name them; the only way to access this name is via the &lt;code&gt;modname&lt;/code&gt; parameter.&lt;/p&gt;
&lt;p&gt;We do something similar for &lt;code&gt;gui&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let gui = job

let gui_qubes = impl @@ object
  inherit base_configurable
  method ty = gui
  val name = Name.ocamlify @@ &amp;quot;gui&amp;quot;
  method name = name
  method module_name = &amp;quot;Qubes.GUI&amp;quot;
  method packages = Key.pure [ package &amp;quot;mirage-qubes&amp;quot; ]
  method configure i =
    match get_target i with
    | `Qubes -&amp;gt; R.ok ()
    | _ -&amp;gt; R.error_msg &amp;quot;Qubes GUI invoked for non-Qubes target.&amp;quot;
  method connect _ modname _args =
    Fmt.strf
      &amp;quot;@[&amp;lt;v 2&amp;gt;\\
       %s.connect ~domid:0 () &amp;gt;&amp;gt;= fun gui -&amp;gt;@ \\
       Lwt.async (fun () -&amp;gt; %s.listen gui);@ \\
       Lwt.return (`Ok gui)@]&amp;quot;
      modname modname
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For details on what both &lt;code&gt;gui_qubes&lt;/code&gt; and &lt;code&gt;qrexec_qubes&lt;/code&gt; are actually doing in their &lt;code&gt;connect&lt;/code&gt; blocks and why, &lt;a href=&quot;http://roscidus.com/blog/blog/2016/01/01/a-unikernel-firewall-for-qubesos/&quot;&gt;talex5's post on building the QubesOS unikernel firewall&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;QRExec for nothing, GUI for free&lt;/h3&gt;
&lt;p&gt;We'll need the &lt;code&gt;connect&lt;/code&gt; function for both of these configurables to be run before the &lt;code&gt;start&lt;/code&gt; function of our unikernel.  But we also don't want a corresponding &lt;code&gt;QRExec.t&lt;/code&gt; or &lt;code&gt;GUI.t&lt;/code&gt; to be passed to our unikernel, nor do we want to parameterize it over the module type corresponding to either module, since either of these would be nonsensical for a non-Qubes target.&lt;/p&gt;
&lt;p&gt;Instead, we need to have &lt;code&gt;main.ml&lt;/code&gt; take care of this transparently, and we don't want any of the results passed to us.  In order to accomplish this, we'll need to change the final invocation of Functoria's &lt;code&gt;register&lt;/code&gt; function from &lt;code&gt;Mirage.register&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let qrexec_init = match_impl Key.(value target) [
  `Qubes, qrexec_qubes;
] ~default:Functoria_app.noop

let gui_init = match_impl Key.(value target) [
  `Qubes, gui_qubes;
] ~default:Functoria_app.noop

let register
    ?(argv=default_argv) ?tracing ?(reporter=default_reporter ())
    ?keys ?packages
    name jobs =
  let argv = Some (Functoria_app.keys argv) in
  let reporter = if reporter == no_reporter then None else Some reporter in
  let qubes_init = Some [qrexec_init; gui_init] in
  let init = qubes_init ++ argv ++ reporter ++ tracing in
  register ?keys ?packages ?init name jobs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;qrexec_init&lt;/code&gt; and &lt;code&gt;gui_init&lt;/code&gt; will only take action if the target is &lt;code&gt;qubes&lt;/code&gt;; otherwise, the dummy implementation &lt;code&gt;Functoria_app.noop&lt;/code&gt; will be used.  The &lt;code&gt;qrexec_init&lt;/code&gt; and &lt;code&gt;gui_init&lt;/code&gt; values are added to the &lt;code&gt;init&lt;/code&gt; list passed to &lt;code&gt;register&lt;/code&gt; regardless of whether they are the Qubes &lt;code&gt;impl&lt;/code&gt;s or &lt;code&gt;Functoria_app.noop&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With those additions, &lt;code&gt;mirage configure -t qubes&lt;/code&gt; will result in a bootable unikernel!  ...but we're not done yet.&lt;/p&gt;
&lt;h2&gt;how do I networks&lt;/h2&gt;
&lt;p&gt;MirageOS previously had two methods of IP configuration: automatically at boot via &lt;a href=&quot;https://github.com/mirage/charrua-core&quot;&gt;DHCP&lt;/a&gt;, and statically at code, configure, or boot.  Neither of these are appropriate IPv4 interfaces on Qubes VMs: QubesOS doesn't run a DHCP daemon.  Instead, it expects VMs to consult the Qubes database for their IP information after booting.  Since the IP information isn't known before boot, we can't even supply it at boot time.&lt;/p&gt;
&lt;p&gt;Instead, we'll add a new &lt;code&gt;impl&lt;/code&gt; for fetching information from QubesDB, and plumb the IP configuration into the &lt;code&gt;generic_stackv4&lt;/code&gt; function.  &lt;code&gt;generic_stackv4&lt;/code&gt; already makes an educated guess about the best IPv4 configuration retrieval method based in part on the target, so this is a natural fit.&lt;/p&gt;
&lt;p&gt;Since we want to use QubesDB as an input to the function that configures the IPv4 stack, we'll have to do a bit more work to make it fit nicely into the functor application architecture -- namely, we have to make a &lt;code&gt;Type&lt;/code&gt; for it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;type qubesdb = QUBES_DB
let qubesdb = Type QUBES_DB

let qubesdb_conf = object
  inherit base_configurable
  method ty = qubesdb
  method name = &amp;quot;qubesdb&amp;quot;
  method module_name = &amp;quot;Qubes.DB&amp;quot;
  method packages = Key.pure [ package &amp;quot;mirage-qubes&amp;quot; ]
  method configure i =
    match get_target i with
    | `Qubes -&amp;gt; R.ok ()
    | _ -&amp;gt; R.error_msg &amp;quot;Qubes DB invoked for non-Qubes target.&amp;quot;
  method connect _ modname _args = Fmt.strf &amp;quot;%s.connect ~domid:0 ()&amp;quot; modname
end

let default_qubesdb = impl qubesdb_conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Other than the &lt;code&gt;type qubesdb = QUBES_DB&lt;/code&gt; and &lt;code&gt;let qubesdb = Type QUBES_DB&lt;/code&gt;, this isn't very different from the previous &lt;code&gt;gui&lt;/code&gt; and &lt;code&gt;qrexec&lt;/code&gt; examples.  Next, we'll need something that can take a &lt;code&gt;qubesdb&lt;/code&gt;, look up the configuration, and set up an &lt;code&gt;ipv4&lt;/code&gt; from the lower layers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let ipv4_qubes_conf = impl @@ object
    inherit base_configurable
    method ty = qubesdb @-&amp;gt; ethernet @-&amp;gt; arpv4 @-&amp;gt; ipv4
    method name = Name.create &amp;quot;qubes_ipv4&amp;quot; ~prefix:&amp;quot;qubes_ipv4&amp;quot;
    method module_name = &amp;quot;Qubesdb_ipv4.Make&amp;quot;
    method packages = Key.pure [ package ~sublibs:[&amp;quot;ipv4&amp;quot;] &amp;quot;mirage-qubes&amp;quot; ]
    method connect _ modname = function
      | [ db ; etif; arp ] -&amp;gt; Fmt.strf &amp;quot;%s.connect %s %s %s&amp;quot; modname db etif arp
      | _ -&amp;gt; failwith (connect_err &amp;quot;qubes ipv4&amp;quot; 3)
  end

let ipv4_qubes db ethernet arp = ipv4_qubes_conf $ db $ ethernet $ arp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notably, the &lt;code&gt;connect&lt;/code&gt; function here is a bit more complicated -- we care about the arguments presented to the function (namely the initialized database, an ethernet module, and an arp module), and we'll pass them to the initialization function, which comes from &lt;code&gt;mirage-qubes.ipv4&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To tell &lt;code&gt;mirage configure&lt;/code&gt; that when &lt;code&gt;-t qubes&lt;/code&gt; is specified, we should use &lt;code&gt;ipv4_qubes_conf&lt;/code&gt;, we'll add a bit to &lt;code&gt;generic_stackv4&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let generic_stackv4
    ?group ?config
    ?(dhcp_key = Key.value @@ Key.dhcp ?group ())
    ?(net_key = Key.value @@ Key.net ?group ())
    (tap : network impl) : stackv4 impl =
  let eq a b = Key.(pure ((=) a) $ b) in
  let choose qubes socket dhcp =
    if qubes then `Qubes
    else if socket then `Socket
    else if dhcp then `Dhcp
    else `Static
  in
  let p = Functoria_key.((pure choose)
          $ eq `Qubes Key.(value target)
          $ eq `Socket net_key
          $ eq true dhcp_key) in
  match_impl p [
    `Dhcp, dhcp_ipv4_stack ?group tap;
    `Socket, socket_stackv4 ?group [Ipaddr.V4.any];
    `Qubes, qubes_ipv4_stack ?group tap;
  ] ~default:(static_ipv4_stack ?config ?group tap)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, &lt;code&gt;mirage configure -t qubes&lt;/code&gt; with any unikernel that usees &lt;code&gt;generic_stackv4&lt;/code&gt; will automatically work!&lt;/p&gt;
&lt;h1&gt;So What?&lt;/h1&gt;
&lt;p&gt;This means I can configure this website for the Qubes target in my development VM:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;4.04.0&amp;#128043;  (qubes-target) mirageos:~/mirage-www/src$ mirage configure -t qubes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and get some nice invocations of the QRExec and GUI start code, along with the IPv4 configuration from QubesDB:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;4.04.0&amp;#128043;  (qubes-target) mirageos:~/mirage-www/src$ cat main.ml
(* Generated by mirage configure -t qubes (Tue, 28 Feb 2017 18:15:49 GMT). *)

open Lwt.Infix
let return = Lwt.return
let run =
OS.Main.run

let _ = Printexc.record_backtrace true

module Ethif1 = Ethif.Make(Netif)

module Arpv41 = Arpv4.Make(Ethif1)(Mclock)(OS.Time)

module Qubesdb_ipv41 = Qubesdb_ipv4.Make(Qubes.DB)(Ethif1)(Arpv41)

module Icmpv41 = Icmpv4.Make(Qubesdb_ipv41)

module Udp1 = Udp.Make(Qubesdb_ipv41)(Stdlibrandom)

module Tcp1 = Tcp.Flow.Make(Qubesdb_ipv41)(OS.Time)(Mclock)(Stdlibrandom)

module Tcpip_stack_direct1 = Tcpip_stack_direct.Make(OS.Time)(Stdlibrandom)
  (Netif)(Ethif1)(Arpv41)(Qubesdb_ipv41)(Icmpv41)(Udp1)(Tcp1)

module Conduit_mirage1 = Conduit_mirage.With_tcp(Tcpip_stack_direct1)

module Dispatch1 = Dispatch.Make(Cohttp_mirage.Server_with_conduit)(Static1)
  (Static2)(Pclock)

module Mirage_logs1 = Mirage_logs.Make(Pclock)

let net11 = lazy (
  Netif.connect (Key_gen.interface ())
  )

let time1 = lazy (
  return ()
  )

let mclock1 = lazy (
  Mclock.connect ()
  )

let ethif1 = lazy (
  let __net11 = Lazy.force net11 in
  __net11 &amp;gt;&amp;gt;= fun _net11 -&amp;gt;
  Ethif1.connect _net11
  )

let qubesdb1 = lazy (
  Qubes.DB.connect ~domid:0 ()
  )

let arpv41 = lazy (
  let __ethif1 = Lazy.force ethif1 in
  let __mclock1 = Lazy.force mclock1 in
  let __time1 = Lazy.force time1 in
  __ethif1 &amp;gt;&amp;gt;= fun _ethif1 -&amp;gt;
  __mclock1 &amp;gt;&amp;gt;= fun _mclock1 -&amp;gt;
  __time1 &amp;gt;&amp;gt;= fun _time1 -&amp;gt;
  Arpv41.connect _ethif1 _mclock1
  )

let qubes_ipv411 = lazy (
  let __qubesdb1 = Lazy.force qubesdb1 in
  let __ethif1 = Lazy.force ethif1 in
  let __arpv41 = Lazy.force arpv41 in
  __qubesdb1 &amp;gt;&amp;gt;= fun _qubesdb1 -&amp;gt;
  __ethif1 &amp;gt;&amp;gt;= fun _ethif1 -&amp;gt;
  __arpv41 &amp;gt;&amp;gt;= fun _arpv41 -&amp;gt;
  Qubesdb_ipv41.connect _qubesdb1 _ethif1 _arpv41
  )

let random1 = lazy (
  Lwt.return (Stdlibrandom.initialize ())
  )

let icmpv41 = lazy (
  let __qubes_ipv411 = Lazy.force qubes_ipv411 in
  __qubes_ipv411 &amp;gt;&amp;gt;= fun _qubes_ipv411 -&amp;gt;
  Icmpv41.connect _qubes_ipv411
  )

let udp1 = lazy (
  let __qubes_ipv411 = Lazy.force qubes_ipv411 in
  let __random1 = Lazy.force random1 in
  __qubes_ipv411 &amp;gt;&amp;gt;= fun _qubes_ipv411 -&amp;gt;
  __random1 &amp;gt;&amp;gt;= fun _random1 -&amp;gt;
  Udp1.connect _qubes_ipv411
  )

let tcp1 = lazy (
  let __qubes_ipv411 = Lazy.force qubes_ipv411 in
  let __time1 = Lazy.force time1 in
  let __mclock1 = Lazy.force mclock1 in
  let __random1 = Lazy.force random1 in
  __qubes_ipv411 &amp;gt;&amp;gt;= fun _qubes_ipv411 -&amp;gt;
  __time1 &amp;gt;&amp;gt;= fun _time1 -&amp;gt;
  __mclock1 &amp;gt;&amp;gt;= fun _mclock1 -&amp;gt;
  __random1 &amp;gt;&amp;gt;= fun _random1 -&amp;gt;
  Tcp1.connect _qubes_ipv411 _mclock1
  )

let stackv4_1 = lazy (
  let __time1 = Lazy.force time1 in
  let __random1 = Lazy.force random1 in
  let __net11 = Lazy.force net11 in
  let __ethif1 = Lazy.force ethif1 in
  let __arpv41 = Lazy.force arpv41 in
  let __qubes_ipv411 = Lazy.force qubes_ipv411 in
  let __icmpv41 = Lazy.force icmpv41 in
  let __udp1 = Lazy.force udp1 in
  let __tcp1 = Lazy.force tcp1 in
  __time1 &amp;gt;&amp;gt;= fun _time1 -&amp;gt;
  __random1 &amp;gt;&amp;gt;= fun _random1 -&amp;gt;
  __net11 &amp;gt;&amp;gt;= fun _net11 -&amp;gt;
  __ethif1 &amp;gt;&amp;gt;= fun _ethif1 -&amp;gt;
  __arpv41 &amp;gt;&amp;gt;= fun _arpv41 -&amp;gt;
  __qubes_ipv411 &amp;gt;&amp;gt;= fun _qubes_ipv411 -&amp;gt;
  __icmpv41 &amp;gt;&amp;gt;= fun _icmpv41 -&amp;gt;
  __udp1 &amp;gt;&amp;gt;= fun _udp1 -&amp;gt;
  __tcp1 &amp;gt;&amp;gt;= fun _tcp1 -&amp;gt;
  let config = {Mirage_stack_lwt. name = &amp;quot;stackv4_&amp;quot;; interface = _net11;} in
Tcpip_stack_direct1.connect config
_ethif1 _arpv41 _qubes_ipv411 _icmpv41 _udp1 _tcp1
  )

let nocrypto1 = lazy (
  Nocrypto_entropy_mirage.initialize ()
  )

let tcp_conduit_connector1 = lazy (
  let __stackv4_1 = Lazy.force stackv4_1 in
  __stackv4_1 &amp;gt;&amp;gt;= fun _stackv4_1 -&amp;gt;
  Lwt.return (Conduit_mirage1.connect _stackv4_1)

  )

let conduit11 = lazy (
  let __nocrypto1 = Lazy.force nocrypto1 in
  let __tcp_conduit_connector1 = Lazy.force tcp_conduit_connector1 in
  __nocrypto1 &amp;gt;&amp;gt;= fun _nocrypto1 -&amp;gt;
  __tcp_conduit_connector1 &amp;gt;&amp;gt;= fun _tcp_conduit_connector1 -&amp;gt;
  Lwt.return Conduit_mirage.empty &amp;gt;&amp;gt;= _tcp_conduit_connector1 &amp;gt;&amp;gt;=
fun t -&amp;gt; Lwt.return t
  )

let argv_qubes1 = lazy (
  let filter (key, _) = List.mem key (List.map snd Key_gen.runtime_keys) in
Bootvar.argv ~filter ()
  )

let http1 = lazy (
  let __conduit11 = Lazy.force conduit11 in
  __conduit11 &amp;gt;&amp;gt;= fun _conduit11 -&amp;gt;
  Cohttp_mirage.Server_with_conduit.connect _conduit11
  )

let static11 = lazy (
  Static1.connect ()
  )

let static21 = lazy (
  Static2.connect ()
  )

let pclock1 = lazy (
  Pclock.connect ()
  )

let key1 = lazy (
  let __argv_qubes1 = Lazy.force argv_qubes1 in
  __argv_qubes1 &amp;gt;&amp;gt;= fun _argv_qubes1 -&amp;gt;
  return (Functoria_runtime.with_argv (List.map fst Key_gen.runtime_keys) &amp;quot;www&amp;quot; _argv_qubes1)
  )

let gui1 = lazy (
  Qubes.GUI.connect ~domid:0 () &amp;gt;&amp;gt;= fun gui -&amp;gt;
  Lwt.async (fun () -&amp;gt; Qubes.GUI.listen gui);
  Lwt.return (`Ok gui)
  )

let qrexec_1 = lazy (
  Qubes.RExec.connect ~domid:0 () &amp;gt;&amp;gt;= fun qrexec -&amp;gt;
  Lwt.async (fun () -&amp;gt;
  OS.Lifecycle.await_shutdown_request () &amp;gt;&amp;gt;= fun _ -&amp;gt;
  Qubes.RExec.disconnect qrexec);
  Lwt.return (`Ok qrexec)
  )

let f11 = lazy (
  let __http1 = Lazy.force http1 in
  let __static11 = Lazy.force static11 in
  let __static21 = Lazy.force static21 in
  let __pclock1 = Lazy.force pclock1 in
  __http1 &amp;gt;&amp;gt;= fun _http1 -&amp;gt;
  __static11 &amp;gt;&amp;gt;= fun _static11 -&amp;gt;
  __static21 &amp;gt;&amp;gt;= fun _static21 -&amp;gt;
  __pclock1 &amp;gt;&amp;gt;= fun _pclock1 -&amp;gt;
  Dispatch1.start _http1 _static11 _static21 _pclock1
  )

let mirage_logs1 = lazy (
  let __pclock1 = Lazy.force pclock1 in
  __pclock1 &amp;gt;&amp;gt;= fun _pclock1 -&amp;gt;
  let ring_size = None in
  let reporter = Mirage_logs1.create ?ring_size _pclock1 in
  Mirage_runtime.set_level ~default:Logs.Info (Key_gen.logs ());
  Mirage_logs1.set_reporter reporter;
  Lwt.return reporter
  )

let mirage1 = lazy (
  let __qrexec_1 = Lazy.force qrexec_1 in
  let __gui1 = Lazy.force gui1 in
  let __key1 = Lazy.force key1 in
  let __mirage_logs1 = Lazy.force mirage_logs1 in
  let __f11 = Lazy.force f11 in
  __qrexec_1 &amp;gt;&amp;gt;= fun _qrexec_1 -&amp;gt;
  __gui1 &amp;gt;&amp;gt;= fun _gui1 -&amp;gt;
  __key1 &amp;gt;&amp;gt;= fun _key1 -&amp;gt;
  __mirage_logs1 &amp;gt;&amp;gt;= fun _mirage_logs1 -&amp;gt;
  __f11 &amp;gt;&amp;gt;= fun _f11 -&amp;gt;
  Lwt.return_unit
  )

let () =
  let t =
  Lazy.force qrexec_1 &amp;gt;&amp;gt;= fun _ -&amp;gt;
    Lazy.force gui1 &amp;gt;&amp;gt;= fun _ -&amp;gt;
    Lazy.force key1 &amp;gt;&amp;gt;= fun _ -&amp;gt;
    Lazy.force mirage_logs1 &amp;gt;&amp;gt;= fun _ -&amp;gt;
    Lazy.force mirage1
  in run t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and we can build this unikernel, then &lt;a href=&quot;https://github.com/talex5/qubes-test-mirage&quot;&gt;send it to dom0 to be booted&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;4.04.0&amp;#128043;  (qubes-target) mirageos:~/mirage-www/src$ make depend
4.04.0&amp;#128043;  (qubes-target) mirageos:~/mirage-www/src$ make
4.04.0&amp;#128043;  (qubes-target) mirageos:~/mirage-www/src$ ~/test-mirage www.xen mirage-test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and if we check the guest VM logs for the test VM (which on my machine is named &lt;code&gt;mirage-test&lt;/code&gt;, as above), we'll see that it's up and running:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;.[32;1mMirageOS booting....[0m
Initialising timer interface
Initialising console ... done.
Note: cannot write Xen 'control' directory
Attempt to open(/dev/urandom)!
Unsupported function getpid called in Mini-OS kernel
Unsupported function getppid called in Mini-OS kernel
2017-02-28 18:29:54 -00:00: INF [net-xen:frontend] connect 0
2017-02-28 18:29:54 -00:00: INF [qubes.db] connecting to server...
gnttab_stubs.c: initialised mini-os gntmap
2017-02-28 18:29:54 -00:00: INF [qubes.db] connected
2017-02-28 18:29:54 -00:00: INF [net-xen:frontend] create: id=0 domid=2
2017-02-28 18:29:54 -00:00: INF [net-xen:frontend]  sg:true gso_tcpv4:true rx_copy:true rx_flip:false smart_poll:false
2017-02-28 18:29:54 -00:00: INF [net-xen:frontend] MAC: 00:16:3e:5e:6c:0e
2017-02-28 18:29:54 -00:00: INF [ethif] Connected Ethernet interface 00:16:3e:5e:6c:0e
2017-02-28 18:29:54 -00:00: INF [arpv4] Connected arpv4 device on 00:16:3e:5e:6c:0e
2017-02-28 18:29:54 -00:00: INF [udp] UDP interface connected on 10.137.3.16
2017-02-28 18:29:54 -00:00: INF [tcpip-stack-direct] stack assembled: mac=00:16:3e:5e:6c:0e,ip=10.137.3.16
2017-02-28 18:29:56 -00:00: INF [dispatch] Listening on http://localhost/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And if we do a bit of firewall tweaking in &lt;code&gt;sys-firewall&lt;/code&gt; to grant access from other VMs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[user@sys-firewall ~]$ sudo iptables -I FORWARD -d 10.137.3.16 -i vif+ -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we can verify that things are as we expect from any VM that has the appropriate software -- for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;4.04.0&amp;#128043;  (qubes-target) mirageos:~/mirage-www/src$ wget -q -O - ht.137.3.16|head -1
&amp;lt;!DOCTYPE html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;What's Next?&lt;/h1&gt;
&lt;p&gt;The implementation work above leaves a lot to be desired, noted in the &lt;a href=&quot;https://github.com/mirage/mirage/pull/553#issuecomment-231529011&quot;&gt;comments to the original pull request&lt;/a&gt;.  We welcome further contributions in this area, particularly from QubesOS users and developers!  If you have questions or comments, please get in touch on the &lt;a href=&quot;https://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel&quot;&gt;mirageos-devel mailing list&lt;/a&gt; or on our IRC channel at #mirage on irc.freenode.net !&lt;/p&gt;

      </content><id>https://mirage.io/blog/qubes-target</id><title type="text">Adding the Qubes target to Mirage</title><updated>2017-03-01T00:00:00-00:00</updated><author><name>Mindy Preston</name></author></entry><entry><link href="https://mirage.io/blog/mirage-3-smaller" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;In this article, some technical background and empirical evidence is given how
we reduced the lines of code in Mirage3, which has about 25% fewer lines of
code than Mirage2, while providing &lt;a href=&quot;https://mirage.io/blog/announcing-mirage-30-release&quot;&gt;more features&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Mirage does a fair amount of code generation since its initial release to extend
target-agnostic unikernels to target-specific virtual machine images (or Unix
binaries).
Until Mirage 2.7, string concatenation &lt;a href=&quot;https://github.com/mirage/mirage/blob/v2.6.1/lib/mirage.ml&quot;&gt;was used
heavily&lt;/a&gt;.  Since the
Mirage 2.7.0 release (February 2016), it is based on
&lt;a href=&quot;https://mirage.io/blog/introducing-functoria&quot;&gt;functoria&lt;/a&gt;, &amp;quot;a DSL to describe a
set of modules and functors, their types and how to apply them in order to
produce a complete application&amp;quot;.
The code generated by Mirage3 is less complex than the Mirage2 one and contains up to 45% fewer
lines of code.&lt;/p&gt;
&lt;h2&gt;Generating code considered harmful&lt;/h2&gt;
&lt;p&gt;Code generated by a program with intricate control flow and automatically
generated identifier names is difficult to understand by a human - in case the
generated code is incorrect and needs to be debugged (or the compiler chokes on
it with an error message pointing in the middle of intricate generated code).
It is also a burden on the developer, since generated code should not be part of
the version control system, thus the build system needs to include another step.
If the code generator is buggy, or not easily extendible for new features,
developers may want to manually modify the generated code - which then turns
into a release nightmare, since you need to maintain a set of patches on top of
generated code, while the code generator may is developed alongside.  Generating
code is best avoided - maybe there is a feature in the programming language to
solve the boilerplate without code generators.&lt;/p&gt;
&lt;p&gt;Having said this, there's nothing wrong with LISP macros or MetaOCaml.&lt;/p&gt;
&lt;p&gt;Mirage uses code generation to complete backend-agnostic unikernels with the
required boilerplate to compile for a specific backend - by selecting the
network device driver, the console, the network stack, and other devices -
taking user-supplied configuration arguments into account.  In Mirage, the OCaml
TCP/IP stack requires any network device which implements the
&lt;a href=&quot;http://docs.mirage.io/mirage-net/Mirage_net/module-type-S/index.html&quot;&gt;&lt;code&gt;Mirage_net.S&lt;/code&gt;&lt;/a&gt;
module type.&lt;/p&gt;
&lt;p&gt;At the end of the day, some mechanism needs to be in place which links the
&lt;a href=&quot;https://github.com/mirage/mirage-net-solo5&quot;&gt;mirage-net-solo5&lt;/a&gt; library if
compiling for Solo5 (or
&lt;a href=&quot;https://github.com/mirage/mirage-net-xen&quot;&gt;mirage-net-xen&lt;/a&gt; if compiling for xen,
or &lt;a href=&quot;https://github.com/mirage-net-unix&quot;&gt;mirage-net-unix&lt;/a&gt; for Unix, or
&lt;a href=&quot;https://github.com/mirage/mirage-net-macosx&quot;&gt;mirage-net-macosx&lt;/a&gt; for MacOSX).
This can be left to each unikernel developer, which would require having the
same boilerplate code all over, which needs to be updated if a new backend
becomes available (Mirage2 knew about Xen, Unix, and MacOSX, Mirage3 extends
this with Solo5 and Qubes).  Instead, the mirage tool generates this boilerplate
by knowing about all supported devices, and which library a unikernel has to
link for a device depending on the target and command line arguments.
That's not exactly the ideal solution.  But it works good enough for us right
now (&lt;a href=&quot;https://github.com/mirage/mirage/pull/750&quot;&gt;more or less&lt;/a&gt;).  A single place - the mirage tool - needs to be extended whenever a new backend becomes
available.&lt;/p&gt;
&lt;h2&gt;Device initialisation - &lt;code&gt;connect&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Devices may depend on each other, e.g. a TCP stack requires a monotonic clock and a
random number generator, which influences the initialisation order.  Mirage
generates the device initialisation startup code based on the configuration and
data dependencies (which hopefully form an acyclic graph).  Mirage2 allowed to
handle initialisation errors (the type of &lt;code&gt;connect&lt;/code&gt; used to be &lt;code&gt;unit -&amp;gt; [ `Ok of t | `Error of error ] io&lt;/code&gt;), but calls to &lt;code&gt;connect&lt;/code&gt; were automatically
generated, and the error handler always spit out an error message and exited.
Becaus the &lt;code&gt;error&lt;/code&gt; was generic, Mirage2 didn't know how to properly print it,
and instead failed with some incomprehensible error message.  Pretty printing
errors is solved in Mirage3 by our &lt;a href=&quot;https://github.com/mirage/mirage/pull/743&quot;&gt;re-work of errors&lt;/a&gt;, which now use the &lt;code&gt;result&lt;/code&gt;
type, are extendible, and can be pretty printed.  Calls to &lt;code&gt;connect&lt;/code&gt; are
automatically generated, and handling errors gracefully is out of scope for a
unikernel -- where should it get the other 2 network devices promised at
configuration time from, if they're not present on the (virtual) PCI bus?&lt;/p&gt;
&lt;p&gt;The solution we &lt;a href=&quot;https://lists.xenproject.org/archives/html/mirageos-devel/2016-09/msg00050.html&quot;&gt;discussed&lt;/a&gt;
and &lt;a href=&quot;https://github.com/mirage/mirage/pull/602&quot;&gt;implemented&lt;/a&gt; (also in &lt;a href=&quot;https://github.com/mirage/functoria/pull/71&quot;&gt;functoria&lt;/a&gt;) was to always fail hard (i.e. crash) in &lt;code&gt;connect : unit -&amp;gt; t&lt;/code&gt;.  This lead to a series of patches for all implementors of &lt;code&gt;connect&lt;/code&gt;,
where lots of patches removed control flow complexity (and less complex test
cases, see e.g.
&lt;a href=&quot;https://github.com/mirage/mirage-net-unix/pull/27/files&quot;&gt;mirage-net-unix&lt;/a&gt;, or
&lt;a href=&quot;https://github.com/mirage/mirage-tcpip/pull/251/files&quot;&gt;tcpip&lt;/a&gt;).  Lots of common
boilerplate (like &lt;code&gt;or_error&lt;/code&gt;, which throws an exception if &lt;code&gt;connect&lt;/code&gt; errored)
could be removed.&lt;/p&gt;
&lt;p&gt;Comparing the generated &lt;code&gt;main.ml&lt;/code&gt; between Mirage 2.9.1 and 3.0.0 for various
unikernels on both unix and xen code reductions up to 45% (&lt;a href=&quot;http://www.cl.cam.ac.uk/~hm519/mirage-2.9.1-3.0.0-diffs/&quot;&gt;diffs are
here&lt;/a&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;console (device-usage) xen: +35 -41 (now 81) unix: +32 -39 (now 80)
&lt;/li&gt;
&lt;li&gt;block (device-usage) xen: +36 -45 (now 87) unix: +34 -44 (now 86)
&lt;/li&gt;
&lt;li&gt;kv_ro (device-usage) xen: +34 -59 (now 75) unix: +39 -51 (now 86)
&lt;/li&gt;
&lt;li&gt;network (device-usage) xen: +82 -134 (now 178) unix: +79 -133 (now 177)
&lt;/li&gt;
&lt;li&gt;conduit_server (device-usage) xen: +86 -152 (now 200) unix: +84 -213 (now 199)
&lt;/li&gt;
&lt;li&gt;dhcp (applications) xen: +44 -51 (now 93) unix: +41 -49 (now 92)
&lt;/li&gt;
&lt;li&gt;dns (applications) xen: +86 -143 (now 190) unix: +83 -141 (now 189)
&lt;/li&gt;
&lt;li&gt;static_website_tls (applications) xen: +97 -176 (now 230) unix: +108 -168 (now 237)
&lt;/li&gt;
&lt;li&gt;nqsb.io xen: +122 -171 (now 223) unix: +65 -85 (now 133)
&lt;/li&gt;
&lt;li&gt;btc-pinata xen: +119 -155 (now 217) unix: +64 -73 (now 127)
&lt;/li&gt;
&lt;li&gt;canopy xen: +106 -180 (now 245) unix: +61 -106 (now 159)
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Workflow, phase separation, versioned opam dependencies&lt;/h2&gt;
&lt;p&gt;The workflow to build a unikernel used to be &lt;code&gt;mirage configure&lt;/code&gt; followed by
&lt;code&gt;make&lt;/code&gt;.  During the configure phase, a &lt;code&gt;Makefile&lt;/code&gt; was generated with the right
build and link commands (depending on configuration target and other
parameters).  Mirage2 installed opam packages and system packages as a side
effect during configuration.  This lead to several headaches: you needed to have the
target-specific libraries installed while you were configuring (you couldn't
even test the configuration for xen if you didn't have xen headers and support
libraries installed).  Reconfiguration spawned yet another &lt;code&gt;opam&lt;/code&gt; process (which
even if it does not install anything since everything required is already
installed, takes some time since the solver has to evaluate the universe) -
unless the &lt;code&gt;--no-opam&lt;/code&gt; option was passed to &lt;code&gt;mirage configure&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A second issue with the Mirage2 approach was that dependent packages were listed
in the unikernel &lt;code&gt;config.ml&lt;/code&gt;, and passed as string to opam.  When version
constraints were included, this lead either shell (calling out &lt;code&gt;opam&lt;/code&gt;) or make
(embedding the packages in the Makefile) or both to choke.  Being able to
express version constraints for dependencies in &lt;code&gt;config.ml&lt;/code&gt; was one of the most
wanted features for Mirage3.  It is crucial for further development (to continue
allowing API breakage and removing legacy): a unikernel author, and the mirage
tool, can now embed versioned dependencies onto device interfaces.  Instead of a
garbled error message from mirage trying to compile a unikernel where the
libraries don't fit the generated code, opam will inform which updates are
necessary.&lt;/p&gt;
&lt;p&gt;In a &lt;a href=&quot;https://github.com/mirage/mirage/pull/691&quot;&gt;first rampage&lt;/a&gt; (&lt;a href=&quot;https://github.com/mirage/functoria/pull/82&quot;&gt;functoria&lt;/a&gt;) instead of
manual executions of &lt;code&gt;opam&lt;/code&gt; processes, an opam package file was generated by
mirage at configuration time for the given target.  This allowed to express
version constraints in each &lt;code&gt;config.ml&lt;/code&gt; file (via the &lt;code&gt;package&lt;/code&gt; function).  This
change also separated the configuration phase, the dependency installation
phase, and the build phase - which included delayed invocations of &lt;code&gt;pkg-config&lt;/code&gt;
to pass parameters to &lt;code&gt;ld&lt;/code&gt;.  A mess, especially if your goal is to generate
Makefiles which run both on GNU make and BSD make.&lt;/p&gt;
&lt;p&gt;A &lt;a href=&quot;https://github.com/mirage/mirage/pull/703&quot;&gt;second approach&lt;/a&gt; (&lt;a href=&quot;https://github.com/mirage/functoria/pull/84&quot;&gt;functoria&lt;/a&gt;) digged a bit
deeper down the rabbit hole, and removed complex selection and adjustment of
strings to output the Makefile, by implementing this logic in OCaml (and calling
out to &lt;code&gt;ocamlbuild&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;).  Removing an uneeded layer of code generation is
easier to read and understand, less code, and includes stronger guarantees.
More potential errors are caught during compile time, instead of generating
(possible ill-formed) Makefiles.  &lt;a href=&quot;http://erratique.ch/software/bos&quot;&gt;Bos&lt;/a&gt; is a
concise library interacting with basic operating system services, and solves
once and for all common issues in that area, such as properly escaping of
arguments.&lt;/p&gt;
&lt;p&gt;Mirage3 contains, instead of a single &lt;code&gt;configure_makefile&lt;/code&gt; function which
generated the entire makefile, the build and link logic is separated into
functions, and only a simplistic makefile is generated which invokes &lt;code&gt;mirage build&lt;/code&gt; to build the unikernel, and expects all dependent libraries to be
installed (e.g. using &lt;code&gt;make depend&lt;/code&gt;, which invokes &lt;code&gt;opam&lt;/code&gt;) -- no need for
delaying &lt;code&gt;pkg-config&lt;/code&gt; calls anymore.&lt;/p&gt;
&lt;p&gt;This solution has certainly less complex string concatenation, and mirage has
now a clearer phase distinction - configure, depend, compile &amp;amp; link.  (This
workflow (still) &lt;a href=&quot;https://github.com/mirage/mirage/issues/694&quot;&gt;lacks a provisioning
step&lt;/a&gt; (e.g. private key material,
if provided as static binary blob, needs to be present during compilation atm),
but can easily be added later.)  There are drawbacks: the mirage utility is now
needed during compilation and linking, and needs to preserve command line
arguments between configuration and build phase.  Maybe the build step should be
in the opam file, then we would need to ensure unique opam package names and we
would need to communicate to the user where the binary got built and installed.&lt;/p&gt;
&lt;h2&gt;Other functionality removed or replaced&lt;/h2&gt;
&lt;p&gt;The first commit to mirage is from 2004, back then opam was an infant.  Mirage2
ensured that a &lt;a href=&quot;https://github.com/mirage/mirage/blob/v2.9.1/lib/mirage.ml#L1462-L1487&quot;&gt;not-too-ancient version of
OCaml&lt;/a&gt;
is installed (&lt;a href=&quot;https://github.com/mirage/functoria/blob/1.1.1/lib/functoria_misc.ml#L298-L309&quot;&gt;functoria contained a similar piece of
code&lt;/a&gt;).
Mirage3 relies on opam to require a certain OCaml version (at the moment 4.03).&lt;/p&gt;
&lt;p&gt;Mirage and functoria were developed while support libraries were not yet
available - worth mentioning &lt;a href=&quot;http://erratique.ch/software/bos&quot;&gt;bos&lt;/a&gt; (mentioned
above), &lt;a href=&quot;http://erratique.ch/software/fpath&quot;&gt;fpath&lt;/a&gt;,
&lt;a href=&quot;http://erratique.ch/software/logs&quot;&gt;logs&lt;/a&gt;, and
&lt;a href=&quot;http://erratique.ch/software/astring&quot;&gt;astring&lt;/a&gt;.  Parts of those libraries were
embedded in functoria, and are now replaced by the libraries. (See
&lt;a href=&quot;https://github.com/mirage/mirage/pull/703&quot;&gt;mirage#703&lt;/a&gt; and
&lt;a href=&quot;https://github.com/mirage/functoria/pull/84&quot;&gt;functoria#84&lt;/a&gt; in case you want to
know the details.)&lt;/p&gt;
&lt;p&gt;Functoria support for OCaml &lt;code&gt;&amp;lt;4.02&lt;/code&gt; has been
&lt;a href=&quot;https://github.com/mirage/functoria/pull/75&quot;&gt;dropped&lt;/a&gt;, also
&lt;a href=&quot;https://github.com/mirage/functoria/pull/77&quot;&gt;astring&lt;/a&gt; is now in use.
Mirage support for OCaml &lt;code&gt;&amp;lt;4.01&lt;/code&gt; has been
&lt;a href=&quot;https://github.com/mirage/mirage/blob/v2.9.1/lib/mirage.ml#L1318-L1355&quot;&gt;dropped&lt;/a&gt;
from Mirage.&lt;/p&gt;
&lt;p&gt;Some C bits and pieces, namely &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;bignum&lt;/code&gt;, and &lt;code&gt;libgcc.a&lt;/code&gt;, are no longer linked and part
of every unikernel.  This is documented in
&lt;a href=&quot;https://github.com/mirage/mirage/pull/544&quot;&gt;mirage#544&lt;/a&gt; and
&lt;a href=&quot;https://github.com/mirage/mirage/issues/663&quot;&gt;mirage#663&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The overall statistics of Mirage3 look promising: more libraries, more
contributors, less code, uniform error treatment, unified logging support.  Individual unikernels
contain slightly less boilerplate code (as shown
&lt;a href=&quot;http://www.cl.cam.ac.uk/~hm519/mirage-2.9.1-3.0.0-diffs/&quot;&gt;by these unified diffs&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The binary sizes of the above mentioned examples (mirage-skeleton, nqsb, Canopy,
pinata) between Mirage2 and Mirage3 results on both Unix and Xen only in small
differences (in the range of kilobytes).  We are working on a &lt;a href=&quot;https://github.com/mirage/mirage/issues/685&quot;&gt;performance harness&lt;/a&gt;
to evaluate the performance of
&lt;a href=&quot;https://blogs.janestreet.com/flambda/&quot;&gt;flambda&lt;/a&gt; intermediate language in OCaml
and &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/608&quot;&gt;dead code elimination&lt;/a&gt;.  These should
decrease the binary size and improve the performance.&lt;/p&gt;

      </content><id>https://mirage.io/blog/mirage-3-smaller</id><title type="text">Size matters: how Mirage got smaller and less magical</title><updated>2017-02-27T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage-30-release" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We're excited to announce MirageOS 3.0! MirageOS is a modern, modular library operating system that allows the creation of small, secure, legacy-free services. MirageOS applications can be compiled to run as self-contained virtual machines (a few MB in size) on Xen or KVM hosts, FreeBSD's bhyve, or even as regular Unix processes (allowing access to regular debugging tools).  The system libraries themselves can be reused in traditional applications, just like any other software library.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirage/mirage/releases/tag/v3.0.0&quot;&gt;Full release notes are available on GitHub&lt;/a&gt;.  If you're interested in getting started with MirageOS 3 right away, you might be interested in the &lt;a href=&quot;https://mirage.io/docs/hello-world&quot;&gt;revamped guide to getting started&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/mirage-skeleton&quot;&gt;a small collection of example unikernels&lt;/a&gt;, or the &lt;a href=&quot;https://mirage.io/docs/mirage2-to-mirage3&quot;&gt;porting guide for updating Mirage 2.x unikernels to Mirage 3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here's a summary of the things in MirageOS 3 that we're most excited about:&lt;/p&gt;
&lt;h3&gt;Solo5&lt;/h3&gt;
&lt;p&gt;MirageOS 3.0 is the first release that integrates the solo5 targets, &lt;code&gt;virtio&lt;/code&gt; and &lt;code&gt;ukvm&lt;/code&gt;, fully with the &lt;code&gt;mirage&lt;/code&gt; front-end tool.  Now you can &lt;code&gt;mirage configure -t ukvm&lt;/code&gt;, build a unikernel, and run directly with the generated &lt;code&gt;ukvm-bin&lt;/code&gt;!  We've updated the &amp;quot;hello world&amp;quot; tutorial to reflect our excitement about &lt;code&gt;ukvm&lt;/code&gt; -- the &lt;code&gt;ukvm&lt;/code&gt; target is considerably easier to interface with and configure than &lt;code&gt;xen&lt;/code&gt; was, and for a lot of users this will be a clearer path toward operational deployment of unikernels.&lt;/p&gt;
&lt;p&gt;For a lot more information on the Solo5 targets, see &lt;a href=&quot;https://mirage.io/blog/introducing-solo5&quot;&gt;the earlier blog post announcing solo5&lt;/a&gt;, &lt;a href=&quot;https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/williams&quot;&gt;Unikernel Monitors: Extending Minimalism Outside of the Box&lt;/a&gt;, and &lt;a href=&quot;https://github.com/solo5/solo5/tree/master/README.md&quot;&gt;the very readable solo5 repository README&lt;/a&gt;.  You can also read how to &lt;a href=&quot;https://hannes.nqsb.io/Posts/Solo5&quot;&gt;run solo5 unikernels on FreeBSD via bhyve&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Playing More Nicely with OPAM&lt;/h3&gt;
&lt;p&gt;MirageOS 3 has a much richer interface for dealing with the package manager and external library dependencies.  A user can now specify a version or range of versions for a package dependency, and the &lt;code&gt;mirage&lt;/code&gt; front-end tool will construct a custom &lt;code&gt;opam&lt;/code&gt; file including both those package dependencies and the ones automatically generated from &lt;code&gt;mirage configure&lt;/code&gt;.  &lt;code&gt;mirage&lt;/code&gt; will also consider version constraints for its own packages -- from now on, &lt;code&gt;opam&lt;/code&gt; should notice that releases of &lt;code&gt;mirage&lt;/code&gt; are incompatible with your unikernel.&lt;/p&gt;
&lt;p&gt;For more information on dealing with packages and dependencies, the documentation for &lt;a href=&quot;http://docs.mirage.io/functoria/Functoria/index.html#pkg&quot;&gt;the Functoria.package function&lt;/a&gt; will likely be of use.  &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/blob/mirage-dev/device-usage/prng/config.ml&quot;&gt;The PRNG device-usage example in mirage-skeleton&lt;/a&gt; demonstrates some useful invocations of &lt;code&gt;package&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Amazing Docs&lt;/h3&gt;
&lt;p&gt;Thanks to a lot of hard work, a fully interlinked set of module documentation is now automatically generated by &lt;code&gt;odig&lt;/code&gt; and available for your reading pleasure at &lt;a href=&quot;http://docs.mirage.io&quot;&gt;the MirageOS central documentation repository&lt;/a&gt;.  While documentation was previously available for most modules, it was scattershot and often required having several disconnected pages open simultaneously.  We hope you'll find the new organization more convenient.  The documentation generation system is still in beta, so please report &lt;a href=&quot;https://github.com/ocaml-doc/odoc/issues&quot;&gt;issues upstream&lt;/a&gt; if you run across rendering issues or have other feedback.&lt;/p&gt;
&lt;h3&gt;Result-y Errors&lt;/h3&gt;
&lt;p&gt;The module types provided by MirageOS 3 replace the previous error paradigm (a combination of exceptions and directly returning polymorphic variants) with one that uses &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/147&quot;&gt;the Result module included in OCaml 4.03 and up&lt;/a&gt;.  A notable exception is when problems occur during the unikernel's initialization (i.e., in &lt;code&gt;connect&lt;/code&gt; functions), where unikernels will now fail hard as soon as they can.  The goal of these changes is to surface errors when the application cares about them, and to not present any uninitialized or unstable state to an application at start time.&lt;/p&gt;
&lt;p&gt;The MirageOS 3 module types define a core set of likely errors for each module type (see &lt;a href=&quot;http://docs.mirage.io/mirage-flow/Mirage_flow/module-type-S/index.html&quot;&gt;the mirage-flow module type&lt;/a&gt; for an example), which can be extended by any given implementation.  Module types now specify that each implementation must include a pretty-printer that can handle all emitted error types.  Functions that return a &lt;code&gt;success&lt;/code&gt; type when they run as expected return a &lt;code&gt;(success, error) Result.t&lt;/code&gt;, which the caller can print with &lt;code&gt;pp_error&lt;/code&gt; if the value is an &lt;code&gt;Error&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For more background on the result type, see the &lt;a href=&quot;http://erratique.ch/software/rresult&quot;&gt;Rresult library&lt;/a&gt; which defines further useful operations on &lt;code&gt;Result.t&lt;/code&gt; and is used widely in MirageOS libraries.  &lt;a href=&quot;https://mirage.io/docs/mirage-3.0-errors&quot;&gt;A more in-depth explanation of errors&lt;/a&gt; in Mirage 3 is also available.&lt;/p&gt;
&lt;h3&gt;Logs Where You Want Them&lt;/h3&gt;
&lt;p&gt;MirageOS version 2.9.0 included automatic support for logging via the &lt;code&gt;Logs&lt;/code&gt; and &lt;code&gt;Mirage_logs&lt;/code&gt; library, but by default logs were always printed to the console and changing the log reporter was cumbersome.  In MirageOS 3, you can send logs to a consumer of syslog messages with &lt;code&gt;syslog_udp&lt;/code&gt;, &lt;code&gt;syslog_tcp&lt;/code&gt;, or with the full authentication and encryption provided by &lt;code&gt;ocaml-tls&lt;/code&gt; using &lt;code&gt;syslog_tls&lt;/code&gt;.  For more information, see &lt;a href=&quot;https://hannes.nqsb.io/Posts/Syslog&quot;&gt;the excellent writeup at hannes.nqsb.io&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Disaggregated Module Type Definitions&lt;/h3&gt;
&lt;p&gt;Breaking all of the MirageOS 3.0 APIs showed us that keeping them all in the same place made updates really difficult.  There's now an additional set of packages which contain the definitions for each set of module types (e.g. &lt;a href=&quot;https://github.com/mirage/mirage-fs&quot;&gt;mirage-fs&lt;/a&gt; for the &lt;code&gt;FS&lt;/code&gt; module type, &lt;a href=&quot;https://github.com/mirage/mirage-block&quot;&gt;mirage-block&lt;/a&gt; for the &lt;code&gt;BLOCK&lt;/code&gt; module type, etc).  A few module types had some additional useful code that was nicely functorized over the module type in question, so we've bundled that code in the module type packages as well.  Documentation for all of the module type packages is available at &lt;a href=&quot;http://docs.mirage.io&quot;&gt;the Mirage documentation hub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We hope that this change combined with the &lt;code&gt;opam&lt;/code&gt; workflow changes above will result in &lt;em&gt;much&lt;/em&gt; less painful API changes in the future, as it will be possible for unikernel authors to target specific versions more readily.&lt;/p&gt;
&lt;h3&gt;Clockier Clocks, Timelier Time&lt;/h3&gt;
&lt;p&gt;In older MirageOS versions, we noticed that we were often having to deduce a span of time from having taken two wall-clock samples of the current time.  In MirageOS 3, you have your choice of two types of clock - &lt;code&gt;MCLOCK&lt;/code&gt;, which provides a monotonically increasing clock reflecting the time elapsed since the clock started, and &lt;code&gt;PCLOCK&lt;/code&gt;, which provides a traditional POSIX wall-clock time.  Most previous users of &lt;code&gt;CLOCK&lt;/code&gt; were able to migrate to the more-honest, less-complicated &lt;code&gt;MCLOCK&lt;/code&gt;.  For an example of both clocks, see &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/blob/mirage-dev/device-usage/clock/unikernel.ml&quot;&gt;the speaking clock&lt;/a&gt;.  You may also be interested in &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/pull/232/files&quot;&gt;an example of converting existing code from &lt;code&gt;CLOCK&lt;/code&gt; to &lt;code&gt;MCLOCK&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MCLOCK&lt;/code&gt; provides a nice interface for dealing with time at a nanosecond granularity.  The &lt;code&gt;TIME&lt;/code&gt; module type has been updated to expect an &lt;code&gt;int64&lt;/code&gt; number of nanoseconds, rather than a float, as an argument to its function &lt;code&gt;sleep&lt;/code&gt;.  For those of us who don't think in nanoseconds, the &lt;a href=&quot;https://github.com/hannesm/duration&quot;&gt;Duration&lt;/a&gt; library provides convenient functions for translating from and to more familiar units like seconds.&lt;/p&gt;
&lt;h3&gt;Build System Shift&lt;/h3&gt;
&lt;p&gt;Mirage 3.0 has many, many more packages than before, and so we turned to &lt;a href=&quot;http://ocamllabs.io&quot;&gt;OCaml Labs&lt;/a&gt; to help us to &lt;a href=&quot;http://ocamllabs.io/projects/2017/02/23/topkg.html&quot;&gt;scale up our package management&lt;/a&gt;. In many but not all MirageOS packages, we've replaced &lt;code&gt;oasis&lt;/code&gt; with &lt;code&gt;topkg&lt;/code&gt;, the &amp;quot;transitory OCaml software packager&amp;quot;. &lt;code&gt;topkg&lt;/code&gt; is a lighter layer over the underlying &lt;code&gt;ocamlbuild&lt;/code&gt;.  Using &lt;code&gt;topkg&lt;/code&gt; has allowed us to remove several thousand lines of autogenerated code across the MirageOS package universe, and let our release manager automate a significant amount of the MirageOS 3 release process.  We hope to continue benefitting from the ease of using &lt;code&gt;topkg&lt;/code&gt; and &lt;code&gt;topkg-care&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Not all packages are using &lt;code&gt;topkg&lt;/code&gt; yet -- if you see one that isn't, feel free to submit a pull request!&lt;/p&gt;
&lt;h3&gt;Less Code, Better Behavior&lt;/h3&gt;
&lt;p&gt;There's more in MirageOS 3 than we can fit in one blog post without our eyes glazing over.  The release notes for &lt;code&gt;mirage&lt;/code&gt; version 3.0.0 are a nice summary, but you might also be interested in the full accounting of changes for every package released as a part of the MirageOS 3 effort; links for each library are available at the end of this post.&lt;/p&gt;
&lt;p&gt;Across the package universe, a net several thousand lines of code were &lt;em&gt;removed&lt;/em&gt; as part of MirageOS 3.  Many were autogenerated build-time support files removed in the transition from &lt;code&gt;oasis&lt;/code&gt; to &lt;code&gt;topkg&lt;/code&gt;.  Others were small support modules like &lt;code&gt;Result&lt;/code&gt;, which had previously been replicated in many places and were replaced by a reference to a common implementation.  Some large implementations (like the DHCP client code in &lt;code&gt;mirage-tcpip&lt;/code&gt;) were replaced by smaller, better implementations in common libraries (like &lt;code&gt;charrua-core&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;For example, &lt;a href=&quot;https://github.com/mirage/ocaml-fat/compare/0.11.0...0.12.0&quot;&gt;ocaml-fat&lt;/a&gt; had 1,280 additions and 10,265 deletions for a net of -8,985 lines of code; version 0.12.0 jettisoned a custom in-memory block device in favor of using the in-memory block device provided by &lt;code&gt;Mirage_block_lwt.Mem&lt;/code&gt;, removed several thousand lines of autogenerated OASIS code, removed several custom error-case polymorphic variants, and lost a custom &lt;code&gt;result&lt;/code&gt; module.  The &lt;a href=&quot;https://github.com/mirage/mirage/compare/v2.9.1...v3.0.0&quot;&gt;mirage repository itself&lt;/a&gt; netted -8,490 lines of code while adding all of the features above!&lt;/p&gt;
&lt;p&gt;A number of improvements were made to &lt;code&gt;mirage&lt;/code&gt; to limit the number of unnecessary build artifacts and reduce the amount of unnecessary code linked into unikernels.  Modules you're unlikely to use like &lt;code&gt;Str&lt;/code&gt; are no longer included in the OCaml runtime.  MirageOS 3 is also the first to drop support for OCaml 4.02.3, meaning that all supported compilers support the &lt;code&gt;flambda&lt;/code&gt; compiler extension and a number of related optimization opportunities.&lt;/p&gt;
&lt;p&gt;Very many people were involved in making the MirageOS package universe smaller and better than it was before.  We'd like to thank, in a particular alphabetical order, the following people who contributed code, suggestions, bug reports, comments, mailing lists questions and answers, and other miscellaneous help:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Aaron Cornelius
&lt;/li&gt;
&lt;li&gt;Amir Chaudhry
&lt;/li&gt;
&lt;li&gt;Andrew Stuart
&lt;/li&gt;
&lt;li&gt;Anil Madhavapeddy
&lt;/li&gt;
&lt;li&gt;Ashish Agarwal
&lt;/li&gt;
&lt;li&gt;Balraj Singh
&lt;/li&gt;
&lt;li&gt;Cedric Cellier
&lt;/li&gt;
&lt;li&gt;Christiano Haesbaert
&lt;/li&gt;
&lt;li&gt;Daniel B&amp;uuml;nzli
&lt;/li&gt;
&lt;li&gt;Dan Williams
&lt;/li&gt;
&lt;li&gt;Dave Scott
&lt;/li&gt;
&lt;li&gt;David Kaloper
&lt;/li&gt;
&lt;li&gt;David Sheets
&lt;/li&gt;
&lt;li&gt;Enguerrand Decorne
&lt;/li&gt;
&lt;li&gt;Eugene Bagdasaryan
&lt;/li&gt;
&lt;li&gt;Federico Gimenez
&lt;/li&gt;
&lt;li&gt;Gabriel de Perthuis
&lt;/li&gt;
&lt;li&gt;Gabriel Jaldon
&lt;/li&gt;
&lt;li&gt;Gabriel Radanne
&lt;/li&gt;
&lt;li&gt;Gemma Gordon
&lt;/li&gt;
&lt;li&gt;Hannes Mehnert
&lt;/li&gt;
&lt;li&gt;Ian Campbell
&lt;/li&gt;
&lt;li&gt;Jochen Bartl
&lt;/li&gt;
&lt;li&gt;John P. McDermott
&lt;/li&gt;
&lt;li&gt;Jon Ludlam
&lt;/li&gt;
&lt;li&gt;Kia
&lt;/li&gt;
&lt;li&gt;Leo White
&lt;/li&gt;
&lt;li&gt;Leonid Rozenberg
&lt;/li&gt;
&lt;li&gt;Liang Wang
&lt;/li&gt;
&lt;li&gt;Madhuri Yechuri
&lt;/li&gt;
&lt;li&gt;Magnus Skjegstad
&lt;/li&gt;
&lt;li&gt;Martin Lucina
&lt;/li&gt;
&lt;li&gt;Matt Gray
&lt;/li&gt;
&lt;li&gt;Mindy Preston
&lt;/li&gt;
&lt;li&gt;Nick Betteridge
&lt;/li&gt;
&lt;li&gt;Nicolas Ojeda Bar
&lt;/li&gt;
&lt;li&gt;Nik Sultana
&lt;/li&gt;
&lt;li&gt;Pablo Polvorin
&lt;/li&gt;
&lt;li&gt;Petter A. Urkedal
&lt;/li&gt;
&lt;li&gt;Qi LI
&lt;/li&gt;
&lt;li&gt;Ramana Venkata
&lt;/li&gt;
&lt;li&gt;Ricardo Koller
&lt;/li&gt;
&lt;li&gt;Richard Mortier
&lt;/li&gt;
&lt;li&gt;Rudi Grinberg
&lt;/li&gt;
&lt;li&gt;Sean Grove
&lt;/li&gt;
&lt;li&gt;Takayuki Imada
&lt;/li&gt;
&lt;li&gt;Thomas Gazagnaire
&lt;/li&gt;
&lt;li&gt;Thomas Leonard
&lt;/li&gt;
&lt;li&gt;Vincent Bernardoff
&lt;/li&gt;
&lt;li&gt;Vittorio Cozzolino
&lt;/li&gt;
&lt;li&gt;GitHub user waldyrious
&lt;/li&gt;
&lt;li&gt;Wassim Haddad
&lt;/li&gt;
&lt;li&gt;Jeremy Yallop
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please let us know if you notice someone (including yourself) is missing so we can add them and apologize!  We're happy to remove or change your listed name if you'd prefer as well.  Names were taken from metadata on commit messages and e-mail headers.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For a summary of changes in each repository that released code for MirageOS 3, please see the following list:
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-clock/compare/v1.1...1.2.0&quot;&gt;changes in mirage-clock between v1.1 and 1.2.0&lt;/a&gt;:  51 files changed, 788 insertions(+), 381 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/ocaml-vchan/compare/v2.2.0...v2.3.0&quot;&gt;changes in ocaml-vchan between v2.2.0 and v2.3.0&lt;/a&gt;:  14 files changed, 4384 insertions(+), 3553 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/haesbaert/charrua-core/compare/v0.3...v0.4&quot;&gt;changes in charrua-core between v0.3 and v0.4&lt;/a&gt;:  14 files changed, 760 insertions(+), 231 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hannesm/arp/compare/0.1.1...0.2.0&quot;&gt;changes in arp between 0.1.1 and 0.2.0&lt;/a&gt;:  23 files changed, 302 insertions(+), 430 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hannesm/logs-syslog/compare/0.0.2...0.1.0&quot;&gt;changes in logs-syslog between 0.0.2 and 0.1.0&lt;/a&gt;:  25 files changed, 277 insertions(+), 361 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/MagnusS/mirage-vnetif/compare/0.2.0...v0.3&quot;&gt;changes in mirage-vnetif between 0.2.0 and v0.3&lt;/a&gt;:  35 files changed, 669 insertions(+), 8551 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/functoria/compare/1.1.0...2.0.1&quot;&gt;changes in functoria between 1.1.0 and 2.0.1&lt;/a&gt;:  46 files changed, 1107 insertions(+), 9666 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-block/compare/v0.2...1.0.0&quot;&gt;changes in mirage-block between v0.2 and 1.0.0&lt;/a&gt;:  42 files changed, 1194 insertions(+), 925 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-block-ramdisk/compare/v0.2...v0.3&quot;&gt;changes in mirage-block-ramdisk between v0.2 and v0.3&lt;/a&gt;:  18 files changed, 440 insertions(+), 305 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-block-solo5/compare/v0.1.1...v0.2.1&quot;&gt;changes in mirage-block-solo5 between v0.1.1 and v0.2.1&lt;/a&gt;:  23 files changed, 187 insertions(+), 7854 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-block-unix/compare/v2.5.0...v2.6.0&quot;&gt;changes in mirage-block-unix between v2.5.0 and v2.6.0&lt;/a&gt;:  9 files changed, 76 insertions(+), 40 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-block-xen/compare/v1.4.0...v1.5.0&quot;&gt;changes in mirage-block-xen between v1.4.0 and v1.5.0&lt;/a&gt;:  11 files changed, 4261 insertions(+), 3440 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-bootvar-solo5/compare/v0.1.1...v0.2.0&quot;&gt;changes in mirage-bootvar-solo5 between v0.1.1 and v0.2.0&lt;/a&gt;:  24 files changed, 78 insertions(+), 7842 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-bootvar-xen/compare/v0.3.2...0.4.0&quot;&gt;changes in mirage-bootvar-xen between v0.3.2 and 0.4.0&lt;/a&gt;:  24 files changed, 98 insertions(+), 8068 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-channel/compare/v1.1.1...v3.0.0&quot;&gt;changes in mirage-channel between v1.1.1 and v3.0.0&lt;/a&gt;:  22 files changed, 511 insertions(+), 485 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-console/compare/v2.1.3...2.2.0&quot;&gt;changes in mirage-console between v2.1.3 and 2.2.0&lt;/a&gt;:  63 files changed, 1364 insertions(+), 9188 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-console-solo5/compare/v0.1.1...v0.2.0&quot;&gt;changes in mirage-console-solo5 between v0.1.1 and v0.2.0&lt;/a&gt;:  26 files changed, 164 insertions(+), 7814 deletions(-)
&lt;/li&gt;
&lt;li&gt;mirage-device is new in MirageOS 3:  13 files changed, 169 insertions(+)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-entropy/compare/0.3.0...0.4.0&quot;&gt;changes in mirage-entropy between 0.3.0 and 0.4.0&lt;/a&gt;:  34 files changed, 533 insertions(+), 8181 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-flow/compare/v1.1.0...1.2.0&quot;&gt;changes in mirage-flow between v1.1.0 and 1.2.0&lt;/a&gt;:  48 files changed, 1254 insertions(+), 8865 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-fs/compare/v0.6.0...1.0.0&quot;&gt;changes in mirage-fs between v0.6.0 and 1.0.0&lt;/a&gt;:  27 files changed, 476 insertions(+), 244 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-fs-unix/compare/v1.2.1...1.3.0&quot;&gt;changes in mirage-fs-unix between v1.2.1 and 1.3.0&lt;/a&gt;:  41 files changed, 1075 insertions(+), 9477 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage/compare/v2.9.1...v3.0.0&quot;&gt;changes in mirage between v2.9.1 and v3.0.0&lt;/a&gt;:  77 files changed, 2332 insertions(+), 11037 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-http/compare/2.5.3...3.0.0&quot;&gt;changes in mirage-http between 2.5.3 and 3.0.0&lt;/a&gt;:  14 files changed, 75 insertions(+), 49 deletions(-)
&lt;/li&gt;
&lt;li&gt;mirage-kv is new in MirageOS 3:  18 files changed, 282 insertions(+)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-logs/compare/v0.2...0.3.0&quot;&gt;changes in mirage-logs between v0.2 and 0.3.0&lt;/a&gt;:  30 files changed, 563 insertions(+), 8250 deletions(-)
&lt;/li&gt;
&lt;li&gt;mirage-net is new in MirageOS 3:  18 files changed, 345 insertions(+)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-net-macosx/compare/1.2.0...1.3.0&quot;&gt;changes in mirage-net-macosx between 1.2.0 and 1.3.0&lt;/a&gt;:  15 files changed, 184 insertions(+), 181 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-net-solo5/compare/v0.1.1...v0.2.0&quot;&gt;changes in mirage-net-solo5 between v0.1.1 and v0.2.0&lt;/a&gt;:  27 files changed, 266 insertions(+), 7969 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-net-unix/compare/v2.2.3...2.3.0&quot;&gt;changes in mirage-net-unix between v2.2.3 and 2.3.0&lt;/a&gt;:  26 files changed, 365 insertions(+), 8133 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-net-xen/compare/v1.4.2...v1.7.0&quot;&gt;changes in mirage-net-xen between v1.4.2 and v1.7.0&lt;/a&gt;:  47 files changed, 6279 insertions(+), 4059 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-platform/compare/v2.6.0...v3.0.0&quot;&gt;changes in mirage-platform between v2.6.0 and v3.0.0&lt;/a&gt;:  36 files changed, 7897 insertions(+), 7449 deletions(-)
&lt;/li&gt;
&lt;li&gt;mirage-protocols is new in MirageOS 3:  18 files changed, 780 insertions(+)
&lt;/li&gt;
&lt;li&gt;mirage-random is new in MirageOS 3:  16 files changed, 172 insertions(+)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-solo5/compare/v0.1.1...v0.2.0&quot;&gt;changes in mirage-solo5 between v0.1.1 and v0.2.0&lt;/a&gt;:  69 files changed, 1411 insertions(+), 9130 deletions(-)
&lt;/li&gt;
&lt;li&gt;mirage-stack is new in MirageOS 3:  16 files changed, 254 insertions(+)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-tcpip/compare/v2.8.1...v3.0.0&quot;&gt;changes in mirage-tcpip between v2.8.1 and v3.0.0&lt;/a&gt;:  228 files changed, 15376 insertions(+), 13301 deletions(-)
&lt;/li&gt;
&lt;li&gt;mirage-time is new in MirageOS 3:  15 files changed, 198 insertions(+)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-conduit/compare/v0.15.0...v0.14.5&quot;&gt;changes in ocaml-conduit between v0.15.0 and v0.14.5&lt;/a&gt;:  14 files changed, 59 insertions(+), 76 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-crunch/compare/v1.4.1...2.0.0&quot;&gt;changes in ocaml-crunch between v1.4.1 and 2.0.0&lt;/a&gt;:  34 files changed, 576 insertions(+), 8196 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-dns/compare/v0.18.1...v0.19.0&quot;&gt;changes in ocaml-dns between v0.18.1 and v0.19.0&lt;/a&gt;:  24 files changed, 5526 insertions(+), 3824 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-fat/compare/0.11.0...0.12.0&quot;&gt;changes in ocaml-fat between 0.11.0 and 0.12.0&lt;/a&gt;:  80 files changed, 3239 insertions(+), 12224 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-freestanding/compare/v0.2.0...v0.2.1&quot;&gt;changes in ocaml-freestanding between v0.2.0 and v0.2.1&lt;/a&gt;:  3 files changed, 7 insertions(+), 1 deletion(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-qcow/compare/v0.8.0...v0.8.1&quot;&gt;changes in ocaml-qcow between v0.8.0 and v0.8.1&lt;/a&gt;:  2 files changed, 5 insertions(+), 2 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto/compare/v0.5.3...v0.5.4&quot;&gt;changes in ocaml-nocrypto between v0.5.3 and v0.5.4&lt;/a&gt;:  44 files changed, 513 insertions(+), 576 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/compare/0.7.1...0.8.0&quot;&gt;changes in ocaml-tls between 0.7.1 and 0.8.0&lt;/a&gt;:  43 files changed, 415 insertions(+), 695 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pqwy/mirage-os-shim/compare/v0.0.1...v3.0.0&quot;&gt;changes in mirage-os-shim between v0.0.1 and v3.0.0&lt;/a&gt;:  11 files changed, 62 insertions(+), 143 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pqwy/ocb-stubblr/compare/v0.1.0...v0.1.1&quot;&gt;changes in ocb-stubblr between v0.1.0 and v0.1.1&lt;/a&gt;:  3 files changed, 21 insertions(+), 11 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/solo5/solo5/compare/v0.1.1...v0.2.0&quot;&gt;changes in solo5 between v0.1.1 and v0.2.0&lt;/a&gt;:  102 files changed, 5554 insertions(+), 9421 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/talex5/mirage-qubes/compare/v0.3...0.4&quot;&gt;changes in mirage-qubes between v0.3 and 0.4&lt;/a&gt;:  28 files changed, 318 insertions(+), 1074 deletions(-)
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yomimono/charrua-client/compare/0.0.1...0.1.0&quot;&gt;changes in charrua-client between 0.0.1 and 0.1.0&lt;/a&gt;:  24 files changed, 492 insertions(+), 442 deletions(-)
&lt;/li&gt;
&lt;/ul&gt;

      </content><id>https://mirage.io/blog/announcing-mirage-30-release</id><title type="text">Announcing MirageOS 3.0.0</title><updated>2017-02-23T00:00:00-00:00</updated><author><name>Mindy Preston</name></author></entry><entry><link href="https://mirage.io/blog/irmin-0.12" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Development of the &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin&lt;/a&gt; Git-like data store continues (see &lt;a href=&quot;https://mirage.io/blog/introducing-irmin&quot;&gt;here&lt;/a&gt; for an introduction). We are releasing &lt;a href=&quot;https://github.com/mirage/irmin/releases/tag/0.12.0&quot;&gt;Irmin 0.12.0&lt;/a&gt; which brings support for native file-system watchers to greatly improve the performance of watches on the datastore.&lt;/p&gt;
&lt;p&gt;Previously, an Irmin application that wanted to use watches would setup file-system scanning/polling by doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  let () = Irmin_unix.install_dir_polling_listener 1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which would scan the &lt;code&gt;.git/refs&lt;/code&gt; directory every second. This worked in practice but was unpredictably latent (if unlucky you might wait for a full second for the watch callbacks to trigger), and disk/CPU intensive as we were scanning the full storage directory every second to detect file changes.  In the cases where the store had 1000s of tags, this could easily saturate the CPU. And in case you were wondering, there are increasing number of applications (such as &lt;a href=&quot;https://github.com/docker/datakit&quot;&gt;DataKit&lt;/a&gt;) that do create thousands of tags regularly, and &lt;a href=&quot;https://github.com/engil/Canopy&quot;&gt;Canopy&lt;/a&gt; that need low latency for interactive development.&lt;/p&gt;
&lt;p&gt;In the new 0.12.0 release, you need to use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;   let () = Irmin_unix.set_listen_dir_hook ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the Irmin storage will do &amp;quot;the right thing&amp;quot;. If you are on Linux, and have the &lt;a href=&quot;https://opam.ocaml.org/packages/inotify/&quot;&gt;inotify OPAM package&lt;/a&gt; installed, it will use libinotify to get notified by the kernel on every change and re-scan the whole directory. On OSX, if you have the &lt;a href=&quot;https://opam.ocaml.org/packages/osx-fsevents/&quot;&gt;osx-fsevents OPAM package&lt;/a&gt; installed, it will do the same thing using the OSX &lt;a href=&quot;https://en.wikipedia.org/wiki/FSEvents&quot;&gt;FSEvents.framework&lt;/a&gt;. The portable compatibility layer between inotify and fsevents comes via the new &lt;a href=&quot;https://github.com/samoht/irmin-watcher/releases/tag/0.2.0&quot;&gt;irmin-watcher&lt;/a&gt; package that has been released recently as well.  This may also come in useful for other tools that require portable OCaml access to filesystem hierarchies.&lt;/p&gt;
&lt;p&gt;If you are using Irmin, please do let us know how you are getting on via the
&lt;a href=&quot;https://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel&quot;&gt;mailing list&lt;/a&gt;
and report any bugs on the &lt;a href=&quot;https://github.com/mirage/irmin/issues&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/irmin-0.12</id><title type="text">Irmin 0.12 with portable filesystem watching released</title><updated>2016-11-17T00:00:00-00:00</updated><author><name>Thomas Gazagnaire</name></author></entry><entry><link href="https://mirage.io/blog/2016-summer-hackathon-roundup" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;a href=&quot;https://www.flickr.com/photos/138528518@N02/sets/72157671241464475&quot;&gt;&lt;img src=&quot;https://mirage.io/graphics/cambridge2016-hackathon.jpg&quot; align=&quot;right&quot; width=&quot;250px&quot;/&gt;&lt;/a&gt;
Our first Cambridge-based MirageOS hack retreat took place yesterday - and what a fantastic day it was! The torrential rain may have halted our punting plans, but it didn't stop progress in the Old Library! Darwin College was a fantastic venue, complete with private islands linked by picturesque wooden bridges and an unwavering wifi connection.&lt;/p&gt;
&lt;p&gt;People naturally formed groups to work on similar projects, and we had a handful of brand new users keen to get started with OCaml and Mirage.  The major tasks that emerged were:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;new hypervisor target&lt;/strong&gt;: the integration of the Solo5 KVM-based hypervisor backend, bringing the number of officially supported targets up to 3 (Xen, Unix and KVM)
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;build system template&lt;/strong&gt;: establishing a new &lt;a href=&quot;https://erratique.ch/software/topkg&quot;&gt;topkg&lt;/a&gt;  template for MirageOS libraries, to prepare us for building a unified API documentation bundle that works across all the entire project.
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU portability&lt;/strong&gt;: improving ARM support via a better base OS image.
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;libraries breadth&lt;/strong&gt;: hacking on all the things to fill in the blanks, such as btree support for bare-metal &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin&lt;/a&gt;, or a peer-to-peer layer for the &lt;a href=&quot;https://github.com/docker/datakit&quot;&gt;DataKit&lt;/a&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll write about all of this in more detail, but for now here are the hack retreat notes hot off the press...&lt;/p&gt;
&lt;h3&gt;Solo5/MirageOS integration (KVM-based backend)&lt;/h3&gt;
&lt;p&gt;Progress on the Solo5 project has been steaming ahead &lt;a href=&quot;https://mirage.io/blog/introducing-solo5&quot;&gt;since January&lt;/a&gt;, and this was the perfect opportunity to get everyone together to plan its integration with MirageOS. &lt;a href=&quot;http://researcher.ibm.com/researcher/view.php?person=us-djwillia&quot;&gt;Dan Williams&lt;/a&gt; from IBM Research flew over to join us for the week, and &lt;a href=&quot;https://github.com/mato&quot;&gt;Martin Lucina&lt;/a&gt; headed to Cambridge to prepare for the upstreaming of the recent Solo5 work. This included deciding on naming and ownership of the repositories, detailing the relationships between repositories and getting ready to publish the mirage-solo5 packages to OPAM. &lt;a href=&quot;http://somerandomidiot.com&quot;&gt;Mindy Preston&lt;/a&gt;, our MirageOS 3.0 release manager, and &lt;a href=&quot;http://anil.recoil.org&quot;&gt;Anil Madhavapeddy&lt;/a&gt; and &lt;a href=&quot;http://gazagnaire.org&quot;&gt;Thomas Gazagnaire&lt;/a&gt; (OPAM minions) were on hand to help plan this smoothly.&lt;/p&gt;
&lt;p&gt;See their updates from the day on &lt;a href=&quot;http://canopy.mirage.io/Posts/Solo5&quot;&gt;Canopy&lt;/a&gt; and related blog posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/introducing-solo5&quot;&gt;Introducing Solo 5&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;Unikernel Monitors HotCloud 2016 &lt;a href=&quot;https://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_williams.pdf&quot;&gt;paper&lt;/a&gt; and &lt;a href=&quot;https://www.usenix.org/sites/default/files/conference/protected-files/hotcloud16_slides_williams.pdf&quot;&gt;slides&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Solo5/solo5/issues/36&quot;&gt;upstreaming GitHub issue&lt;/a&gt; and &lt;a href=&quot;https://github.com/Solo5/solo5/issues/61&quot;&gt;FreeBSD support tracking issue&lt;/a&gt; from Hannes Mehnert.
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Onboarding new MirageOS/OCaml users&lt;/h3&gt;
&lt;p&gt;Our tutorials and onboarding guides &lt;em&gt;really&lt;/em&gt; needed a facelift and an update, so &lt;a href=&quot;https://ocaml.io/w/User:GemmaG&quot;&gt;Gemma Gordon&lt;/a&gt; spent the morning with some of our new users to observe their installation process and tried to pinpoint blockers and areas of misunderstanding. Providing the simple, concise instructions needed in a guide together with alternatives for every possible system and version requirement is a tricky combination to get right, but we made some &lt;a href=&quot;https://github.com/mirage/mirage-www/pull/468&quot;&gt;changes&lt;/a&gt; to the &lt;a href=&quot;https://mirage.io/docs/install&quot;&gt;installation guide&lt;/a&gt; that we hope will help. The next task is to do the same for our other popular tutorials, reconfigure the layout for easy reading and centralise the information as much as possible between the OPAM, MirageOS and OCaml guides. Thank you to Marwan Aljubeh for his insight into this process.&lt;/p&gt;
&lt;p&gt;Other industrial users are also steaming ahead with their own MirageOS deployments. &lt;a href=&quot;http://amirchaudhry.com&quot;&gt;Amir Chaudhry&lt;/a&gt; spent the hackathon blogging about &lt;a href=&quot;http://unikernel.org/blog/2016/unikernel-nfv-platform&quot;&gt;NFV Platforms with MirageOS unikernels&lt;/a&gt;, which details how Ericsson Silicon Valley has been using MirageOS to build lightweight routing kernels.&lt;/p&gt;
&lt;h3&gt;Packaging&lt;/h3&gt;
&lt;p&gt;Thomas Gazagnaire was frenetically converting &lt;code&gt;functoria&lt;/code&gt;, &lt;code&gt;mirage&lt;/code&gt;, &lt;code&gt;mirage-types&lt;/code&gt; and &lt;code&gt;mirage-console&lt;/code&gt; to use &lt;a href=&quot;https://github.com/dbuenzli/topkg&quot;&gt;topkg&lt;/a&gt;, and the feedback prompted fixes and a new release from Daniel Buenzli.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/functoria/pull/64&quot;&gt;Functoria #64&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage/pull/558&quot;&gt;Mirage #558&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-console/pull/41&quot;&gt;Mirage-console #41&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ARM and Cubieboards&lt;/h3&gt;
&lt;p&gt;Ian Campbell implemented a (slightly hacky) way to get Alpine Linux onto some Cubieboard2 boxes and &lt;a href=&quot;https://gist.github.com/ijc25/612b8b7975e9461c3584b1402df2cb34&quot;&gt;provided notes&lt;/a&gt; on his process, including how to tailor the base for KVM and Xen respectively.&lt;/p&gt;
&lt;p&gt;Meanwhile, Qi Li worked on testing and adapting &lt;a href=&quot;https://github.com/yomimono/simple-nat&quot;&gt;simple-nat&lt;/a&gt; and &lt;a href=&quot;https://github.com/yomimono/mirage-nat&quot;&gt;mirage-nat&lt;/a&gt; to provide connectivity control for unikernels on ARM Cubieboards to act as network gateways.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yomimono/simple-nat/tree/ethernet-level-no-irmin&quot;&gt;Simple-NAT ethernet branch&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yomimono/mirage-nat/tree/depopt_irmin&quot;&gt;Mirage NAT with optional Irmin branch&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cl.cam.ac.uk/~hm519/&quot;&gt;Hannes Mehnert&lt;/a&gt; recently published a purely functional &lt;a href=&quot;https://github.com/hannesm/arp&quot;&gt;ARP package&lt;/a&gt; and continued refining it (with code coverage via &lt;a href=&quot;https://github.com/aantron/bisect_ppx&quot;&gt;bisect-ppx&lt;/a&gt;) during the hackathon.&lt;/p&gt;
&lt;h3&gt;MirageOS 3.0 API changes&lt;/h3&gt;
&lt;p&gt;Our MirageOS release manager, Mindy Preston, was on hand to talk with everyone about their PRs in preparation for the 3.0 release along with some patches for deprecating out of date code.  There has been a lot of discussion on the &lt;a href=&quot;https://lists.xenproject.org/archives/html/mirageos-devel/2016-07/msg00000.html&quot;&gt;development list&lt;/a&gt;.  One focus was to address time handling properly in the interfaces: Matthew Gray came up from London to finish up his extensive revision of the &lt;a href=&quot;https://github.com/mirage/mirage/issues/442&quot;&gt;CLOCK&lt;/a&gt; interface, and Hannes developed a new &lt;a href=&quot;https://github.com/hannesm/duration&quot;&gt;duration&lt;/a&gt; library to handle time unit conversions safely and get rid of the need for floating point handling.  We are aiming to minimise the dependency on floating point handling in external interfaces to simplify compilation to very embedded hardware that only has soft floats (particularly for something as ubiquitous as time handling).&lt;/p&gt;
&lt;h3&gt;Error logging&lt;/h3&gt;
&lt;p&gt;Thomas Leonard continued with the work he started in Marrakech by &lt;a href=&quot;https://github.com/mirage/functoria/pull/55&quot;&gt;updating the error reporting patches&lt;/a&gt; (also &lt;a href=&quot;https://github.com/mirage/mirage-dev/pull/107&quot;&gt;here&lt;/a&gt;) to work with the latest version of MirageOS (which has a different logging system based on Daniel Buenzlis &lt;a href=&quot;http://erratique.ch/software/logs&quot;&gt;Logs&lt;/a&gt;). See the &lt;a href=&quot;http://canopy.mirage.io/Posts/Errors&quot;&gt;original post&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;Ctypes 0.7.0 release&lt;/h3&gt;
&lt;p&gt;Jeremy released the foreign function interface library &lt;a href=&quot;https://github.com/ocamllabs/ocaml-ctypes/releases/tag/0.7.0&quot;&gt;Ctypes 0.7.0&lt;/a&gt; which, along with bug fixes, adds the following features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Support for bytecode-only architectures (&lt;a href=&quot;https://github.com/ocamllabs/ocaml-ctypes/issues/410&quot;&gt;#410&lt;/a&gt;)
&lt;/li&gt;
&lt;li&gt;A new &lt;code&gt;sint&lt;/code&gt; type corresponding to a full-range C integer and updated errno support for its use (&lt;a href=&quot;https://github.com/ocamllabs/ocaml-ctypes/issues/411&quot;&gt;#411&lt;/a&gt;)
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the full changelog &lt;a href=&quot;https://github.com/ocamllabs/ocaml-ctypes/blob/master/CHANGES.md&quot;&gt;online&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;P2P key-value store over DataKit&lt;/h3&gt;
&lt;p&gt;KC Sivaramakrishnan and Philip Dexter took on the challenge of grabbing the Docker &lt;a href=&quot;https://github.com/docker/datakit&quot;&gt;DataKit&lt;/a&gt; release and started building a distributed key-value store that features flexible JSON synching and merging.  Their raw notes are in a &lt;a href=&quot;https://gist.github.com/kayceesrk/d3edb2da0aa9a3d40e9e3f838b67bd1a&quot;&gt;Gist&lt;/a&gt; -- get in touch with them if you want to help hack on the sync system backed by Git.&lt;/p&gt;
&lt;h3&gt;Developer experience improvements&lt;/h3&gt;
&lt;p&gt;The OCaml Labs undergraduate interns are spending their summers working on user improvements and CI logs with MirageOS, and used the time at the hackathon to focus on these issues.&lt;/p&gt;
&lt;p&gt;Ciaran Lawlor is working on an editor implementation, specifically getting the &lt;a href=&quot;https://github.com/andrewray/iocaml&quot;&gt;IOcaml kernel&lt;/a&gt; working with the &lt;a href=&quot;https://github.com/nteract/hydrogen&quot;&gt;Hydrogen&lt;/a&gt; plugin for the Atom editor. This will allow developers to run OCaml code directly in Atom, and eventually interactively build unikernels!&lt;/p&gt;
&lt;p&gt;Joel Jakubovic used &lt;a href=&quot;https://github.com/inhabitedtype/angstrom&quot;&gt;Angstrom&lt;/a&gt; (a fast parser combinator library developed by Spiros Eliopoulos) to ANSI escape codes, usually displayed as colours and styles into HTML for use in viewing CI logs.&lt;/p&gt;
&lt;h3&gt;Windows Support&lt;/h3&gt;
&lt;p&gt;Most of the Mirage libraries already work on Windows thanks to lots of work in the wider OCaml community, but other features don't have full support yet.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dave.recoil.org&quot;&gt;Dave Scott&lt;/a&gt; from Docker worked on &lt;a href=&quot;https://github.com/djs55/ocaml-wpcap&quot;&gt;ocaml-wpcap&lt;/a&gt;: a &lt;a href=&quot;https://github.com/ocamllabs/ocaml-ctypes&quot;&gt;ctypes&lt;/a&gt; binding to the Windows &lt;a href=&quot;http://www.winpcap.org&quot;&gt;winpcap.dll&lt;/a&gt; which lets OCaml programs send and receive ethernet frames on Windows. The ocaml-wpcap library will hopefully let us run the Mirage TCP/IP stack and all the networking applications too.&lt;/p&gt;
&lt;p&gt;David Allsopp continued his OPAM-Windows support by fine-tuning the 80 native Windows OCaml versions - these will hopefully form part of OPAM 2.0. As it turns out, he's not the only person still interested in being able to run OCaml 3.07...if you are, get in touch!&lt;/p&gt;
&lt;h3&gt;General Libraries and utilities&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/OlivierNicole&quot;&gt;Olivier Nicole&lt;/a&gt; is working on an implementation of macros in OCaml and started working on the
HTML and XML templates using this system. The objective is to have the same
behaviour as the &lt;code&gt;Pa_tyxml&lt;/code&gt; syntax extension, but in a type-safe and more
maintainable way without requiring PPX extensions. This project could be
contributed to the development of &lt;a href=&quot;http://ocsigen.org&quot;&gt;Ocsigen&lt;/a&gt; once implemented.&lt;/p&gt;
&lt;p&gt;Nick Betteridge teamed up with Dave Scott to look at using
&lt;a href=&quot;https://github.com/djs55/ocaml-btree&quot;&gt;ocaml-btree&lt;/a&gt; as a backend for Irmin/xen
and spent the day looking at different approaches.&lt;/p&gt;
&lt;p&gt;Anil Madhavapeddy built a Docker wrapper for the CI system and spun up a big cluster
to run OPAM bulk builds.  Several small utilities like &lt;a href=&quot;https://github.com/avsm/jsontee&quot;&gt;jsontee&lt;/a&gt; and
an immutable &lt;a href=&quot;https://github.com/avsm/opam-log-server&quot;&gt;log collection server&lt;/a&gt; and
&lt;a href=&quot;https://github.com/avsm/opam-bulk-builder&quot;&gt;bulk build scripts&lt;/a&gt; will be released in the
next few weeks once the builds are running stably, and be re-usable by other OPAM-based
projects to use for their own tests.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Chris00&quot;&gt;Christophe Troestler&lt;/a&gt; is spending a month at
&lt;a href=&quot;https://ocaml.io&quot;&gt;OCaml Labs&lt;/a&gt; in Cambridge this summer, and spent the hack day
working on implementing a library to allow seamless application switching from
HTTP to FastCGI. Christophe has initiated work on a client and server for this
protocol using &lt;a href=&quot;https://github.com/mirage/ocaml-cohttp&quot;&gt;CoHTTP&lt;/a&gt; so that it is
unikernel-friendly.&lt;/p&gt;

      </content><id>https://mirage.io/blog/2016-summer-hackathon-roundup</id><title type="text">MirageOS Summer 2016 hack retreat roundup</title><updated>2016-07-18T00:00:00-00:00</updated><author><name>Gemma Gordon</name></author></entry><entry><link href="https://mirage.io/blog/2016-summer-hackathon" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;As summer starts to shine over an obstinately rainy England, we are organising
the second MirageOS hack retreat in Cambridge!  It will be held on &lt;strong&gt;Weds 13th
July&lt;/strong&gt; at the lovely &lt;a href=&quot;https://www.darwin.cam.ac.uk&quot;&gt;Darwin College&lt;/a&gt; from
9am-11pm, with snacks, teas, coffees and a servery lunch provided (thanks to
sponsorship from &lt;a href=&quot;http://docker.com&quot;&gt;Docker&lt;/a&gt; and &lt;a href=&quot;https://ocaml.io&quot;&gt;OCaml Labs&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Anyone is welcome at all skill levels&lt;/strong&gt;, but we'd appreciate you filling out the
&lt;a href=&quot;http://doodle.com/poll/ngbbviwyb9e65uiw&quot;&gt;Doodle&lt;/a&gt; so that we can plan
refreshments.  We will be working on a variety of projects from improving ARM
support, to continuous integration tests, the new Solo5 backend and improving
the suite of protocol libraries.  If you have something in particular that
interests you, please drop a note to the &lt;a href=&quot;https://mirage.io/community&quot;&gt;mailing list&lt;/a&gt; or check
out the full list of &lt;a href=&quot;https://github.com/mirage/mirage-www/wiki/Pioneer-Projects&quot;&gt;Pioneer Projects&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Some other events of note recently:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;After several years of scribing awesome notes about our development, Amir has handed over the reigns to &lt;a href=&quot;https://github.com/engil&quot;&gt;Enguerrand&lt;/a&gt;.
Enguerrand joined OCaml Labs as an intern, and has built an IRC-to-Git logging bot which records our meetings over IRC and commits them
directly to a &lt;a href=&quot;https://github.com/hannesm/canopy-data&quot;&gt;repository&lt;/a&gt; which is &lt;a href=&quot;http://canopy.mirage.io/irclogs&quot;&gt;available online&lt;/a&gt;.  Thanks Amir
and Enguerrand for all their hard work on recording the growing amount of development in MirageOS.  &lt;a href=&quot;https://ocaml.io/w/User:GemmaG&quot;&gt;Gemma Gordon&lt;/a&gt;
has also joined the project and been coordinating the &lt;a href=&quot;https://github.com/mirage/mirage-www/wiki/Call-Agenda&quot;&gt;meetings&lt;/a&gt;.  The next one is in a
few hours, so please join us on &lt;code&gt;#mirage&lt;/code&gt; on Freenode IRC at 4pm British time if you would like to participate or are just curious!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Our participation in the &lt;a href=&quot;https://wiki.gnome.org/Outreachy/2016/MayAugust&quot;&gt;Outreachy&lt;/a&gt; program for 2016 has begun, and the irrepressible
&lt;a href=&quot;http://www.gina.codes&quot;&gt;Gina Marie Maini&lt;/a&gt; (aka &lt;a href=&quot;http://twitter.com/wiredsis&quot;&gt;wiredsister&lt;/a&gt;) has been hacking on syslogd, mentored by &lt;a href=&quot;http://somerandomidiot.com&quot;&gt;Mindy Preston&lt;/a&gt;.
She has already started blogging (&lt;a href=&quot;http://www.gina.codes/ocaml/2016/06/06/syslog-a-tale-of-specifications.html&quot;&gt;about syslog&lt;/a&gt; and &lt;a href=&quot;http://www.gina.codes/ocaml/2016/02/14/dear-ocaml-i-love-you.html&quot;&gt;OCaml love&lt;/a&gt;), as well as &lt;a href=&quot;http://hanselminutes.com/531/living-functional-programming-with-ocaml-and-gina-marie-maini&quot;&gt;podcasting with the stars&lt;/a&gt;.  Welcome to the crew, Gina!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The new &lt;a href=&quot;https://docs.docker.com/engine/installation/mac/&quot;&gt;Docker for Mac&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/engine/installation/windows/&quot;&gt;Docker for Windows&lt;/a&gt; products have entered open beta! They use a number of libraries from MirageOS (including most of the network stack) and provide a fast way of getting started with containers and unikernel builds on Mac and Windows.  You can find talks about it at the recent &lt;a href=&quot;https://ocaml.io/w/Blog:News/FP_Meetup:_OCaml,_Facebook_and_Docker_at_Jane_Street&quot;&gt;JS London meetup&lt;/a&gt; and my &lt;a href=&quot;http://www.slideshare.net/AnilMadhavapeddy/advanced-docker-developer-workflows-on-macos-x-and-windows&quot;&gt;slides&lt;/a&gt;  I also spoke at OSCON 2016 about it, but those videos aren't online yet.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There have also been a number of talks in the past couple of months about MirageOS and its libraries:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://researcher.watson.ibm.com/researcher/view.php?person=us-djwillia&quot;&gt;Dan Williams&lt;/a&gt; from IBM Research delivered a paper at &lt;a href=&quot;https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/williams&quot;&gt;USENIX HotCloud 2016&lt;/a&gt; about &lt;a href=&quot;https://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_williams.pdf&quot;&gt;Unikernel Monitors&lt;/a&gt;. This explains the basis of his work on &lt;a href=&quot;https://mirage.io/blog/introducing-solo5&quot;&gt;Solo5&lt;/a&gt;, which we are currently integrating into MirageOS as a KVM-based boot backend to complement the Xen port.  You can also find his &lt;a href=&quot;https://www.usenix.org/sites/default/files/conference/protected-files/hotcloud16_slides_williams.pdf&quot;&gt;talk slides&lt;/a&gt; online.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/amirmc&quot;&gt;Amir Chaudhry&lt;/a&gt; has given several talks and demos recently: check out his slides and detailed
writeups about &lt;a href=&quot;http://amirchaudhry.com/gluecon2016&quot;&gt;GlueCon 2016&lt;/a&gt; and &lt;a href=&quot;http://amirchaudhry.com/craftconf2016&quot;&gt;CraftConf 2016&lt;/a&gt; in particular,
as they come with instructions on how to reproduce his Mirage/ARM on-stage demonstrations of unikernels.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/sgrove&quot;&gt;Sean Grove&lt;/a&gt; is speaking at &lt;a href=&quot;http://polyconf.com&quot;&gt;Polyconf 2016&lt;/a&gt; next week in Poland.  If you are in the region, he would love to meet up with you as well -- his talk abstract is below
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;With libraries like Mirage, &lt;code&gt;js_of_ocaml&lt;/code&gt;, &amp;amp; ARM compiler output OCaml apps can operate at such a low level
we don't even need operating systems on the backend anymore (removing 15 &lt;em&gt;million&lt;/em&gt; lines of memory-unsafe code)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;while at the same time, writing UI's is easier &amp;amp; more reliable than ever before, with lightweight type-checked
code sharing between server, browser clients, &amp;amp; native mobile apps. We'll look at what's enabled by new tech
like Unikernels, efficient JS/ARM output, &amp;amp; easy host interop.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

      </content><id>https://mirage.io/blog/2016-summer-hackathon</id><title type="text">MirageOS Summer 2016 hack retreat announcement, and talk roundup</title><updated>2016-06-29T00:00:00-00:00</updated><author><name>Gemma Gordon</name></author></entry><entry><link href="https://mirage.io/blog/2016-spring-hackathon" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We're looking forward to the next MirageOS hack retreat already!  We've collected some reports from those who were present at our &lt;a href=&quot;http://retreat.mirage.io&quot;&gt;2016 Spring hack retreat&lt;/a&gt; to share our excitement!  Thanks to the folks who put in the time and effort to organize the event and our wonderful hosts, and a huge thanks to everyone who documented their hack retreat experience!&lt;/p&gt;
&lt;p&gt;More information is also available at &lt;a href=&quot;http://canopy.mirage.io&quot;&gt;the Canopy site developed and used for information sharing during the hack retreat&lt;/a&gt;!&lt;/p&gt;
&lt;h2&gt;Trip Report&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;by David Kaloper&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mirage.io/graphics/2016-hackathon/roof_flash.jpg&quot; alt=&quot;roof-flash&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Last month, the MirageOS community saw its first community-organized, international
[hackathon][hweb]. It took place between 11th and 16th March 2016. The venue?
[Rihad Priscilla][priscilla], Marrakech, Morocco.&lt;/p&gt;
&lt;p&gt;The place turned out to be ideal for a community building exercise. A city
bursting with life, scents and colors, a relaxed and friendly hostel with plenty
of space, warm and sunny weather -- all the elements of a good get-together
were there. This is where some 25 hackers from all over the world convened, with
various backgrounds and specialties, all sharing an interest in MirageOS.&lt;/p&gt;
&lt;p&gt;Not wanting to limit ourselves to breaking only those conventions, we added another layer: the
hackathon was set up as a classical anti-conference, with a bare minimum of
structure, no pre-defined program, and a strong focus on one-on-one work,
teaching, and collaboration.&lt;/p&gt;
&lt;p&gt;As this was the first hackathon, this time the focus was on building up the nascent
community that already exists around MirageOS. Faces were put to online handles, stories were
exchanged, and connections were forged. Meeting in person helped bring a new
level of cohesion to the online community around the project, as witnessed by
the flurry of online conversations between people that were present, and have continued after
the event ended.&lt;/p&gt;
&lt;p&gt;One particularly useful (however inglorious) activity proved to be introducing
people to the tool chain. Even though the MirageOS website has a
[documentation][mirage-docs] section with various documents on the architecture
of the project, technical blog posts and a series of examples to get newcomers
started, a number of people found it difficult to juggle all the concepts and
tools involved. Where is the line dividing &lt;code&gt;ocamlfind&lt;/code&gt; from &lt;code&gt;opam&lt;/code&gt; and what
exactly constitutes an OCaml library? What is the correct way to declare
dependencies not covered by the declarative configuration language? When should
one use &lt;code&gt;add_to_opam_packages&lt;/code&gt;, and when &lt;code&gt;add_to_ocamlfind_libraries&lt;/code&gt;? Will the
&lt;code&gt;mirage&lt;/code&gt; tool take care of installing missing packages so declared?&lt;/p&gt;
&lt;p&gt;Although these questions either have answers scattered throughout the docs, or
are almost obvious to an experienced MirageOS developer, such getting-started
issues proved to be an early obstacle for a number of hackathon participants.
While our project documentation certainly could -- and will! -- be improved with
the perspective of a new developer in mind, this was an opportunity to help
participants get a more comprehensive overview of the core tooling in an
efficient, one-to-one setting. As a result, we saw a number of developers go
from trying to get the examples to compile to making their own unikernels within
a day, something pretty awesome to witness!&lt;/p&gt;
&lt;p&gt;Another fun thread was dogfooding the network stack. Network itself was provided
by our venue Priscilla, but we brought our own routers and access points. DHCP on site was
served by [Charrua][charrua], which stood up to the task admirably. We were able
to access arbitrary domains on the Internet, almost all of the time!&lt;/p&gt;
&lt;p&gt;A group of hackers had a strong web background, and decided to focus their
efforts there. Perhaps the most interesting project to come out of this is
[Canopy][canopy]. Canopy is best described as the first dynamic offering in the
space of static web site generators! It combines [Irmin][irmin] with
[TyXML][tyxml], [COW][cow], and [Mirage HTTP][mirage-http], to create a simple,
one-stop solution for putting content on the web. A Canopy unikernel boots,
pulls a series of markdown files from a git repository, renders them, and serves
them via HTTP. Expect more to come in this space, as Canopy has already proved
to be a handy tool to simply put something on the web.&lt;/p&gt;
&lt;p&gt;At the same time, the atmosphere was conducive for discussing how OCaml
in general, and MirageOS in particular, fits in the web development ecosystem.
As a language originally honed in different contexts, it's the opinion of a number
of practicing web developers that the current OCaml ecosystem is not as
conducive to supporting their day-to-day work as it could be. These brainstorming
sessions led to a [writeup][adoption-manifesto] which tries to summarize the
current state and plot the course forward.&lt;/p&gt;
&lt;p&gt;Another group of hackers was more focused on security and privacy
technology. MirageOS boasts its own cryptographic core and a TLS stack,
providing a solid base for development of cryptographic protocols. We saw
coordinated work on improving the [cryptographic layer][nocrypto-pr];
implementations of a few key-derivation functions ([Scrypt][scrypt] and
[PBKDF][pbkdf]); and even a beginning of an [IKEv2][ikev2] implementation.&lt;/p&gt;
&lt;p&gt;A further common topic was networking, which is not entirely surprising for a
network-centric unikernel platform. Amidst the enthusiasm, hackers in attendance
started several projects related to general networking. These include a
[SWIM][swim] membership protocol implementation, the beginnings of
[telnet][telnet] for Mirage, [SOCKS4][socks] packet handling,
[DNS wildcard][dns-wcard] matching, Charrua updates, and more.&lt;/p&gt;
&lt;p&gt;In between these threads of activity, people used the time to get general
MirageOS work done. This resulted in lots of progress including: making
[AFL][afl], already supported by OCaml, run against MirageOS unikernels; a
comprehensive update of error reporting across the stack; a concentrated push to
move away from Camlp4 and adopt PPX; and producing a prototype unikernel
displaying rich terminal output via telnet.&lt;/p&gt;
&lt;p&gt;Partially motivated by the need to improve the experience of building and
running unikernels, a number of hackers worked on improvements to [error
reporting][syslog] and [logging][log-pr]. Improving the experience when things
go wrong will be an important part of helping folks make unikernels with
MirageOS.&lt;/p&gt;
&lt;p&gt;For more, and less structured, details of what went on, check out the
[blog][event-blog] some of us kept, or the [meeting notes][meeting-notes] from
the few short morning meetings we had.&lt;/p&gt;
&lt;p&gt;It seems that when surrounded by like-minded, skilled people, in a pleasant
atmosphere, and with absolutely nothing to do, people's curiosity will reliably
kick in. In between lieing in the sun (sunscreen was a hot commodity!), sinking
into the [midday heat][midday-heat], and talking to other hackers, not a single
person failed to learn, practice, or produce something new.&lt;/p&gt;
&lt;p&gt;In this way, the first MirageOS hackathon was a resounding success. Friendships
were forged, skills shared, and courses plotted. And although the same venue has
already been booked for the next year's event, there is ongoing chit-chat about
cutting the downtime in half with a summer edition!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mirage.io/graphics/2016-hackathon/heat.jpg&quot; alt=&quot;heat&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;[hweb]: http://retreat.mirage.io/
[priscilla]: http://queenofthemedina.com/en/index.html
[mirage-docs]: https://mirage.io/docs
[charrua]: https://github.com/haesbaert/charrua-core
[canopy]: https://github.com/Engil/Canopy
[irmin]: https://github.com/mirage/irmin
[tyxml]: http://ocsigen.org/tyxml
[cow]: https://github.com/mirage/ocaml-cow
[mirage-http]: https://github.com/mirage/mirage-http
[adoption-manifesto]: https://github.com/fxfactorial/an-ocaml-adoption-manifesto
[nocrypto-pr]: https://github.com/mirleft/ocaml-nocrypto/pull/93
[scrypt]: https://github.com/abeaumont/ocaml-scrypt-kdf
[pbkdf]: https://github.com/abeaumont/ocaml-pbkdf
[ikev2]: https://github.com/isakmp/ike
[swim]: https://github.com/andreas/mirage-swim
[telnet]: https://github.com/hannesm/telnet
[socks]: https://github.com/cfcs/ocaml-socks
[dns-wcard]: https://github.com/cfcs/ocaml-wildcard
[afl]: http://lcamtuf.coredump.cx/afl/
[event-blog]: http://canopy.mirage.io/
[meeting-notes]: https://github.com/ocamllabs/activity/wiki/MirageOS-Hackathon
[midday-heat]: https://twitter.com/rudenoise/status/709453313553596416
[syslog]: https://github.com/verbosemode/syslogd-mirage
[log-pr]: https://github.com/mirage/mirage-dev/pull/107&lt;/h2&gt;
&lt;h2&gt;MirageOS hackathon in Marrakech&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Text and images by Enguerrand Decorne&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Setting up and settling in&lt;/h3&gt;
&lt;p&gt;The first &lt;a href=&quot;https://mirage.io/&quot;&gt;MirageOS hackathon&lt;/a&gt; was held from March 11th-16th 2016, at &lt;a href=&quot;http://queenofthemedina.com/en/index.html&quot;&gt;Priscilla, Queen of the Medina&lt;/a&gt;, Marrakech. It successfully gathered around 30 Mirage enthusiasts, some already familiar with the MirageOS ecosystem, and others new to the community. People travelled from Europe and further afield for a week of sun, tajine and hacking.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mirage.io/graphics/2016-hackathon/main_room.jpg&quot; alt=&quot;Main room&quot; title=&quot;The main room&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Getting to the guesthouse &lt;a href=&quot;https://www.youtube.com/watch?v=zgzwmyxlKBE&quot;&gt;was an adventure&lt;/a&gt;, and once there we prepared by quickly setting up a nice internet hotspot then organised groups to head to the souk to meet new arrivals.
Soon enough the guest house was filled with people, and various new projects and ideas began to emerge. Having a few books and experienced OCaml developers around helped the OCaml newcomers get stuck in, and it didn't take long to get their first unikernel or OCaml library up and running. Daily meetings were arranged at noon on the rooftop in order to allow the exchange of project ideas and questions, and we used the &lt;a href=&quot;http://canopy.mirage.io/Index&quot;&gt;hackathon notepad&lt;/a&gt; to loosely pair projects and people together. Our &lt;a href=&quot;https://mirage.io/blog/introducing-charrua-dhcp&quot;&gt;DHCP server&lt;/a&gt; enabled extensive dogfooding and successfully fulfilled our project-testing needs.&lt;/p&gt;
&lt;p&gt;Participants found a wide range of activities to keep themselves occupied during the event: contributing to the &lt;a href=&quot;https://github.com/mirage/mirage-www/wiki/Pioneer-Projects&quot;&gt;MirageOS Pioneer Projects&lt;/a&gt;, starting new projects and libraries, improving the MirageOS ecosystem and core components, discussing new ideas... or simply enjoying the sun, delicious tajine, or walking around Marrakech itself. Some expeditions were also (non)organised during the week, allowing sightseeing of the nicest local spots, or negotiating with local stallholders to get the best prices on souvenirs and fresh fruits to enjoy during hard hacking sessions.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mirage.io/graphics/2016-hackathon/food.jpg&quot; alt=&quot;Food&quot; title=&quot;Some more food&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;My week inside the camel's nest&lt;/h3&gt;
&lt;p&gt;A few days before heading up to Marrakech (in a very non-organised fashion, having been offered a hackathon place only two days before!) the idea of writing some kind of notebook using Mirage had been floating around - we wanted to be able to allow people inside the hackathon to exchange ideas, and those not physically present to be kept updated about progress. I decided to write a simple blog unikernel, &lt;a href=&quot;https://github.com/Engil/Canopy/&quot;&gt;Canopy&lt;/a&gt; which relies on &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin's&lt;/a&gt; capabilities to synchronise remote git repositiories. By describing new pages in a format similar to Jekyll (and using Markdown) on a git repository, new content pushed there would be pulled to the website and displayed there nicely. This allowed every participant to report on their current projects, and see the content displayed on the notepad after a simple &lt;code&gt;git push&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The project was well received and new ideas started to emerge in order to turn it into a CMS enabling users to easily describe new website with a simple git repository. A huge thank you to &lt;a href=&quot;https://github.com/mmaker&quot;&gt;Michele&lt;/a&gt; for his awesome contributions, as well as everyone involved with answering questions about the Mirage ecosystem along the way. This project also allowed me to dive a little further inside various libraries, report a few issues, discuss features and discover new concepts... A week well spent that I would be glad to repeat at the next MirageOS hackathon :)&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://mirage.io/graphics/2016-hackathon/rooftop.jpg&quot; alt=&quot;Rooftop&quot; title=&quot;Rooftop view&quot;/&gt;&lt;/p&gt;
&lt;p&gt;This hackathon was a huge success and allowed the MirageOS community to combine sun and high productivity in a crazy yet very relaxing week. We hope (and plan) to see more events like this, so anyone interested in OCaml, Mirage - expert or not - is more than welcome to join us next time!&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;https://mirage.io/graphics/2016-hackathon/cats.jpg&quot; alt=&quot;Cats&quot; title=&quot;And obviously&amp;hellip; Marrakech's cats!&quot;/&gt;&lt;/h2&gt;
&lt;h2&gt;MirageOS + OCaml Newcomers&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;by Alfredo and Sonia&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Our experience in Marrakesh was great. We really enjoyed the place,
the weather, the food, the people and the atmosphere! I think the
setting was a great win, there was lot of open space where you could
find a quiet spot for yourself to concentrate while programming,
as well as a place with lots of people coding, or a place where you
could be talking about anything while enjoying the sun, or just hang
out and get lost for a while in the nice Marrakesh's old city.&lt;/p&gt;
&lt;p&gt;We had already learnt some OCaml, but we both are quite new to both
OCaml and MirageOS, so we decided to work on a project with low entry
barrier so we could get in the loop more easily. Nevertheless we had to
invest some time getting more familiar with the specifics of the OCaml
environment (libraries, packaging, testing frameworks, etc.). Hannes
kindly helped us getting started, showing us a library (&lt;code&gt;ocaml-hkdf&lt;/code&gt;) we
could use to understand this all better, and from here we could start
writing some code. Having most of the authors (Thomas, David,
Hannes...) of the libraries we used (&lt;code&gt;nocrypto&lt;/code&gt;, &lt;code&gt;cstruct&lt;/code&gt;, &lt;code&gt;alcotest&lt;/code&gt;,
&lt;code&gt;opam&lt;/code&gt;...) there with us was also a win. Finally we managed to release a
pair of libraries with key derivation functions (&lt;code&gt;ocaml-pbkdf&lt;/code&gt; and
&lt;code&gt;ocaml-scrypt-kdf&lt;/code&gt;), so we are quite happy with the outcome.&lt;/p&gt;
&lt;h2&gt;The only downside of the hackathon we can think of, if any, is that we
didn't get too deep into the MirageOS specifics (something we are
surely willing to fix!), but we wanted to stay focused to keep
productive and had enough new things to learn.&lt;/h2&gt;
&lt;h2&gt;Hackathon Projects&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;by Ximin Luo&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Here's a list of things I did during the hackathon:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read into ocaml-tls and ocaml-otr implementations, as well as David's &amp;quot;nqsb&amp;quot; TLS paper
&lt;/li&gt;
&lt;li&gt;Talked with David about developing a general pattern for implementing protocols, that allows one to compose components more easily and consistently. He pointed me to many resources that I could learn from and build on top of.
&lt;/li&gt;
&lt;li&gt;Read documents on &amp;quot;Extensible Effects&amp;quot;, &amp;quot;Freer Monads&amp;quot; and &amp;quot;Iteratee pattern&amp;quot; by Oleg Kiselyov.
&lt;/li&gt;
&lt;li&gt;Read documents and source code of the Haskell Pipes library by Gabriel Gonzalez.
&lt;/li&gt;
&lt;li&gt;Sent some PRs to Hannes' jackline IM client, for better usability under some graphical environments.
&lt;/li&gt;
&lt;li&gt;Showed some people my ocaml-hello &amp;quot;minimal build scripts&amp;quot; example, and my ocaml emacs scripts.
&lt;/li&gt;
&lt;li&gt;Tested the &amp;quot;solo5&amp;quot; system that runs mirageos on kvm as an alternative to xen.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm continuing with the following work in my spare time:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read documents and source code of the opam monadlib library with a view to extending this and unifying it with other libraries such as lwt.
&lt;/li&gt;
&lt;li&gt;Using the approach of the Haskel Pipes library to develop a general protocol handler framework. I'm experimenting initially in Haskell but I'd also like to do it in OCaml when the ideas are more solid.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In terms of the event it was great - everything worked out very well, I don't have any suggestions for improvements :)&lt;/p&gt;

      </content><id>https://mirage.io/blog/2016-spring-hackathon</id><title type="text">MirageOS Spring 2016 hack retreat!</title><updated>2016-05-04T00:00:00-00:00</updated><author><name>Gemma Gordon</name></author></entry><entry><link href="https://mirage.io/blog/MSA00" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;h2&gt;MirageOS Security Advisory 00 - memory disclosure in mirage-net-xen&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Module:       mirage-net-xen
&lt;/li&gt;
&lt;li&gt;Announced:    2016-05-03
&lt;/li&gt;
&lt;li&gt;Credits:      Enguerrand Decorne, Thomas Leonard, Hannes Mehnert, Mindy Preston
&lt;/li&gt;
&lt;li&gt;Affects:      mirage-net-xen &amp;lt;1.4.2
&lt;/li&gt;
&lt;li&gt;Corrected:    2016-01-08 1.5.0 release, 2016-05-03 1.4.2 release
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For general information regarding MirageOS Security Advisories,
please visit &lt;a href=&quot;https://mirage.io/security&quot;&gt;https://mirage.io/security&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Hannes published a &lt;a href=&quot;https://hannes.nqsb.io/Posts/BadRecordMac&quot;&gt;blog article&lt;/a&gt; about
the analysis of this issue.&lt;/p&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;MirageOS is a library operating system using cooperative multitasking, which can
be executed as a guest of the Xen hypervisor.  Virtual devices, such as a
network device, share memory between MirageOS and the hypervisor.  MirageOS
allocates and grants the hypervisor access to a ringbuffer containing pages to
be sent on the network device, and another ringbuffer with pages to be filled
with received data.  A write on the MirageOS side consists of filling the page
with the packet data, submitting a write request to the hypervisor, and awaiting
a response from the hypervisor.  To correlate the request with the response, a
16bit identifier is used.&lt;/p&gt;
&lt;h3&gt;Problem Description&lt;/h3&gt;
&lt;p&gt;Generating this 16bit identifier was not done in a unique manner.  When multiple
pages share an identifier, and are requested to be transmitted via the wire, the
first successful response will mark all pages with this identifier free, even
those still waiting to be transmitted.  Once marked free, the MirageOS
application fills the page for another chunk of data.  This leads to corrupted
packets being sent, and can lead to disclosure of memory intended for another
recipient.&lt;/p&gt;
&lt;h3&gt;Impact&lt;/h3&gt;
&lt;p&gt;This issue discloses memory intended for another recipient.  All versions before
mirage-net-xen 1.4.2 are affected.  The receiving side uses a similar mechanism,
which may lead to corrupted incoming data (eventually even mutated while being
processed).&lt;/p&gt;
&lt;p&gt;Version 1.5.0, released on 8th January, already assigns unique identifiers for
transmission.  Received pages are copied into freshly allocated buffers before
passed to the next layer.  When 1.5.0 was released, the impact was not clear to
us.  Version 1.6.1 now additionally ensures that received pages have a unique
identifier.&lt;/p&gt;
&lt;h3&gt;Workaround&lt;/h3&gt;
&lt;p&gt;No workaround is available.&lt;/p&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;The unique identifier is now generated in a unique manner using a monotonic
counter.&lt;/p&gt;
&lt;p&gt;Transmitting corrupt data and disclosing memory is fixed in versions 1.4.2 and
above.&lt;/p&gt;
&lt;p&gt;The recommended way to upgrade is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;opam update
opam upgrade mirage-net-xen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or, explicitly:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;opam upgrade
opam reinstall mirage-net-xen=1.4.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Affected releases have been marked uninstallable in the opam repository.&lt;/p&gt;
&lt;h3&gt;Correction details&lt;/h3&gt;
&lt;p&gt;The following list contains the correction revision numbers for each
affected branch.&lt;/p&gt;
&lt;p&gt;Memory disclosure on transmit:&lt;/p&gt;
&lt;p&gt;master: &lt;a href=&quot;https://github.com/mirage/mirage-net-xen/commit/47de2edfad9c56110d98d0312c1a7e0b9dcc8fbf&quot;&gt;47de2edfad9c56110d98d0312c1a7e0b9dcc8fbf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.4: &lt;a href=&quot;https://github.com/mirage/mirage-net-xen/commit/ec9b1046b75cba5ae3473b2d3b223c3d1284489d&quot;&gt;ec9b1046b75cba5ae3473b2d3b223c3d1284489d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Corrupt data while receiving:&lt;/p&gt;
&lt;p&gt;master: &lt;a href=&quot;https://github.com/mirage/mirage-net-xen/commit/0b1e53c0875062a50e2d5823b7da0d8e0a64dc37&quot;&gt;0b1e53c0875062a50e2d5823b7da0d8e0a64dc37&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.4: &lt;a href=&quot;https://github.com/mirage/mirage-net-xen/commit/6daad38af2f0b5c58d6c1fb24252c3eed737ede4&quot;&gt;6daad38af2f0b5c58d6c1fb24252c3eed737ede4&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirage/mirage-net-xen&quot;&gt;mirage-net-xen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can find the latest version of this advisory online at
&lt;a href=&quot;https://mirage.io/blog/MSA00&quot;&gt;https://mirage.io/blog/MSA00&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This advisory is signed using OpenPGP, you can verify the signature
by downloading our public key from a keyserver (&lt;code&gt;gpg --recv-key 4A732D757C0EDA74&lt;/code&gt;),
downloading the raw markdown source of this advisory from &lt;a href=&quot;https://raw.githubusercontent.com/mirage/mirage-www/master/tmpl/advisories/00.txt.asc&quot;&gt;GitHub&lt;/a&gt;
and executing &lt;code&gt;gpg --verify 00.md.asc&lt;/code&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/MSA00</id><title type="text">MirageOS security advisory 00: mirage-net-xen</title><updated>2016-05-03T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/introducing-functoria" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;For the last few months, I've been working with &lt;a href=&quot;http://www.gazagnaire.org&quot;&gt;Thomas&lt;/a&gt; on improving the &lt;code&gt;mirage&lt;/code&gt; tool and
I'm happy to present &lt;a href=&quot;https://github.com/mirage/functoria&quot;&gt;Functoria&lt;/a&gt;, a library to create arbitrary MirageOS-like DSLs. Functoria is independent from &lt;code&gt;mirage&lt;/code&gt; and will replace the core engine, which was somewhat bolted on to the tool until now.&lt;/p&gt;
&lt;p&gt;This introduces a few breaking changes so please consult
&lt;a href=&quot;https://mirage.io/docs/breaking-changes&quot;&gt;the breaking changes page&lt;/a&gt; to see what is different and how to fix things if needed.
The good news is that it will be much more simple to use, much more flexible,
and will even produce pretty pictures!&lt;/p&gt;
&lt;h2&gt;Configuration&lt;/h2&gt;
&lt;p&gt;For people unfamiliar with MirageOS, the &lt;code&gt;mirage&lt;/code&gt; tool handles configuration of mirage unikernels by reading an OCaml file describing the various pieces and dependencies of the project.
Based on this configuration it will use &lt;a href=&quot;http://opam.ocaml.org/&quot;&gt;opam&lt;/a&gt; to install the dependencies, handle various configuration tasks and emit a build script.&lt;/p&gt;
&lt;p&gt;A very simple configuration file looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;open Mirage
let main = foreign &amp;quot;Unikernel.Main&amp;quot; (console @-&amp;gt; job)
let () = register &amp;quot;console&amp;quot; [main $ default_console]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It declares a new functor, &lt;code&gt;Unikernel.Main&lt;/code&gt;, which take a console as an argument and instantiates it on the &lt;code&gt;default_console&lt;/code&gt;. For more details about unikernel configuration, please read the &lt;a href=&quot;https://mirage.io/wiki/hello-world&quot;&gt;hello-world&lt;/a&gt; tutorial.&lt;/p&gt;
&lt;h2&gt;Keys&lt;/h2&gt;
&lt;p&gt;A &lt;a href=&quot;https://github.com/mirage/mirage/issues/229&quot;&gt;much&lt;/a&gt; &lt;a href=&quot;https://github.com/mirage/mirage/issues/228&quot;&gt;demanded&lt;/a&gt; &lt;a href=&quot;https://github.com/mirage/mirage/issues/231&quot;&gt;feature&lt;/a&gt; has been the ability to define so-called bootvars.
Bootvars are variables whose value is set either at configure time or at
startup time.&lt;/p&gt;
&lt;p&gt;A good example of a bootvar would be the IP address of the HTTP stack. For example, you may wish to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set a good default directly in the &lt;code&gt;config.ml&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;Provide a value at configure time, if you are already aware of deployment conditions.
&lt;/li&gt;
&lt;li&gt;Provide a value at startup time, for last minute changes.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of this is now possible using &lt;strong&gt;keys&lt;/strong&gt;. A key is composed of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;name&lt;/em&gt; &amp;mdash; The name of the value in the program.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;description&lt;/em&gt; &amp;mdash; How it should be displayed/serialized.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;stage&lt;/em&gt; &amp;mdash; Is the key available only at runtime, at configure time, or both?
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;documentation&lt;/em&gt; &amp;mdash; This is not optional, so you have to write it.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Imagine we are building a multilingual unikernel and we want to pass the
default language as a parameter. The language parameter is an optional string, so we use the &lt;a href=&quot;http://mirage.github.io/functoria/Functoria_key.Arg.html#VALopt&quot;&gt;&lt;code&gt;opt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://mirage.github.io/functoria/Functoria_key.Arg.html#VALstring&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; combinators. We want to be able to define it both
at configure and run time, so we use the stage &lt;code&gt; `Both&lt;/code&gt;. This gives us the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let lang_key =
  let doc = Key.Arg.info
      ~doc:&amp;quot;The default language for the unikernel.&amp;quot; [ &amp;quot;l&amp;quot; ; &amp;quot;lang&amp;quot; ]
  in
  Key.(create &amp;quot;language&amp;quot; Arg.(opt ~stage:`Both string &amp;quot;en&amp;quot; doc))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we defined both a long option &lt;code&gt;--lang&lt;/code&gt;, and a short one &lt;code&gt;-l&lt;/code&gt;, (the format is similar to the one used by &lt;a href=&quot;http://erratique.ch/software/cmdliner&quot;&gt;Cmdliner&lt;/a&gt;).
In the unikernel, the value is retrieved with &lt;code&gt;Key_gen.language ()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The option is also documented in the &lt;code&gt;--help&lt;/code&gt; option for both &lt;code&gt;mirage configure&lt;/code&gt; (at configure time) and &lt;code&gt;./my_unikernel&lt;/code&gt; (at startup time).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       -l VAL, --lang=VAL (absent=en)
           The default language for the unikernel.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A simple example of a unikernel with a key is available in &lt;a href=&quot;https://github.com/mirage/mirage-skeleton&quot;&gt;mirage-skeleton&lt;/a&gt; in the &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/tree/master/hello&quot;&gt;&lt;code&gt;hello&lt;/code&gt; directory&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Switching implementation&lt;/h3&gt;
&lt;p&gt;We can do much more with keys, for example we can use them to switch devices at configure time.
To illustrate, let us take the example of dynamic storage, where we want to choose between a block device and a crunch device with a command line option.
In order to do that, we must first define a boolean key:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let fat_key =
  let doc = Key.Arg.info
      ~doc:&amp;quot;Use a fat device if true, crunch otherwise.&amp;quot; [ &amp;quot;fat&amp;quot; ]
  in
  Key.(create &amp;quot;fat&amp;quot; Arg.(opt ~stage:`Configure bool false doc))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use the &lt;a href=&quot;http://mirage.github.io/functoria/Functoria.html#VALif_impl&quot;&gt;&lt;code&gt;if_impl&lt;/code&gt;&lt;/a&gt; combinator to choose between two devices depending on the value of the key.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let dynamic_storage =
  if_impl (Key.value fat_key)
    (kv_ro_of_fs my_fat_device)
    (my_crunch_device)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now use this device as a normal storage device of type &lt;code&gt;kv_ro impl&lt;/code&gt;! The key is also documented in &lt;code&gt;mirage configure --help&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       --fat=VAL (absent=false)
           Use a fat device if true, crunch otherwise.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is also possible to compute on keys before giving them to &lt;code&gt;if_impl&lt;/code&gt;, combining multiple keys in order to compute a value, and so on. For more details, see the &lt;a href=&quot;http://mirage.github.io/functoria/&quot;&gt;API&lt;/a&gt; and the various examples available in &lt;a href=&quot;https://github.com/mirage/mirage&quot;&gt;mirage&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirage/mirage-skeleton&quot;&gt;mirage-skeleton&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Switching keys opens various possibilities, for example a &lt;code&gt;generic_stack&lt;/code&gt; combinator is now implemented in &lt;code&gt;mirage&lt;/code&gt; that will switch between socket stack, direct stack with DHCP, and direct stack with static IP, depending on command line arguments.&lt;/p&gt;
&lt;h2&gt;Drawing unikernels&lt;/h2&gt;
&lt;p&gt;All these keys and dynamic implementations make for complicated unikernels. In order to clarify what is going on and help to configure our unikernels, we have a new command: &lt;code&gt;describe&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let us consider the &lt;code&gt;console&lt;/code&gt; example in &lt;a href=&quot;https://github.com/mirage/mirage-skeleton&quot;&gt;mirage-skeleton&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;open Mirage

let main = foreign &amp;quot;Unikernel.Main&amp;quot; (console @-&amp;gt; job)
let () = register &amp;quot;console&amp;quot; [main $ default_console]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is fairly straightforward: we define a &lt;code&gt;Unikernel.Main&lt;/code&gt; functor using a console and we
instantiate it with the default console. If we execute &lt;code&gt;mirage describe --dot&lt;/code&gt; in this directory, we will get the following output.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mirage.io/graphics/dot/console.svg&quot;&gt;&lt;img src=&quot;https://mirage.io/graphics/dot/console.svg&quot; alt=&quot;A console unikernel&quot; title=&quot;My little unikernel&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As you can see, there are already quite a few things going on!
Rectangles are the various devices and you'll notice that
the &lt;code&gt;default_console&lt;/code&gt; is actually two consoles: the one on Unix and the one on Xen. We use the &lt;code&gt;if_impl&lt;/code&gt; construction &amp;mdash; represented as a circular node &amp;mdash; to choose between the two during configuration.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;key&lt;/code&gt; device handles the runtime key handling. It relies on an &lt;code&gt;argv&lt;/code&gt; device, which is similar to &lt;code&gt;console&lt;/code&gt;. Those devices are present in all unikernels.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;mirage&lt;/code&gt; device is the device that brings all the jobs together (and on the hypervisor binds them).&lt;/p&gt;
&lt;h2&gt;Data dependencies&lt;/h2&gt;
&lt;p&gt;You may have noticed dashed lines in the previous diagram, in particular from &lt;code&gt;mirage&lt;/code&gt; to &lt;code&gt;Unikernel.Main&lt;/code&gt;. Those lines are data dependencies. For example, the &lt;code&gt;bootvar&lt;/code&gt; device has a dependency on the &lt;code&gt;argv&lt;/code&gt; device. It means that &lt;code&gt;argv&lt;/code&gt; is configured and run first, returns some data &amp;mdash; an array of string &amp;mdash; then &lt;code&gt;bootvar&lt;/code&gt; is configured and run.&lt;/p&gt;
&lt;p&gt;If your unikernel has a data dependency &amp;mdash; say, initializing the entropy &amp;mdash; you can use the &lt;code&gt;~deps&lt;/code&gt; argument on &lt;code&gt;Mirage.foreign&lt;/code&gt;. The &lt;code&gt;start&lt;/code&gt; function of the unikernel will receive one extra argument for each dependency.&lt;/p&gt;
&lt;p&gt;As an example, let us look at the &lt;a href=&quot;http://mirage.github.io/functoria/Functoria_app.html#VALapp_info&quot;&gt;&lt;code&gt;app_info&lt;/code&gt;&lt;/a&gt; device. This device makes the configuration information available at runtime. We can declare a dependency on it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let main =
  foreign &amp;quot;Unikernel.Main&amp;quot; ~deps:[abstract app_info] (console @-&amp;gt; job)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://mirage.io/graphics/dot/info.svg&quot;&gt;&lt;img src=&quot;https://mirage.io/graphics/dot/info.svg&quot; alt=&quot;A unikernel with info&quot; title=&quot;My informed unikernel&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The only difference with the previous unikernel is the data dependency &amp;mdash; represented by a dashed arrow &amp;mdash; going from &lt;code&gt;Unikernel.Main&lt;/code&gt; to &lt;code&gt;Info_gen&lt;/code&gt;. This means that &lt;code&gt;Unikernel.Main.start&lt;/code&gt; will take an extra argument of type &lt;code&gt;Mirage_info.t&lt;/code&gt; which we can, for example, print:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: console
libraries: [functoria.runtime; lwt.syntax; mirage-console.unix;
            mirage-types.lwt; mirage.runtime; sexplib]
packages: [functoria.0.1; lwt.2.5.0; mirage-console.2.1.3; mirage-unix.2.3.1;
           sexplib.113.00.00]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The complete example is available in &lt;a href=&quot;https://github.com/mirage/mirage-skeleton&quot;&gt;mirage-skeleton&lt;/a&gt; in the &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/tree/master/app_info&quot;&gt;&lt;code&gt;app_info&lt;/code&gt; directory&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Sharing&lt;/h2&gt;
&lt;p&gt;Since we have a way to draw unikernels, we can now observe the sharing between various pieces. For example, the direct stack with static IP yields this diagram:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mirage.io/graphics/dot/stack.svg&quot;&gt;&lt;img src=&quot;https://mirage.io/graphics/dot/stack.svg&quot; alt=&quot;A stack unikernel&quot; title=&quot;My stack unikernel&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can see that all the sub-parts of the stack have been properly shared. To be merged, two devices must have the same name, keys, dependencies and functor arguments.
To force non-sharing of two devices, it is enough to give them different names.&lt;/p&gt;
&lt;p&gt;This sharing also works up to switching keys. The generic stack gives us this diagram:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mirage.io/graphics/dot/dynamic.svg&quot;&gt;&lt;img src=&quot;https://mirage.io/graphics/dot/dynamic.svg&quot; alt=&quot;A dynamic stack unikernel&quot; title=&quot;My generic unikernel&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you look closely, you'll notice that there are actually &lt;em&gt;three&lt;/em&gt; stacks in the last example: the &lt;em&gt;socket&lt;/em&gt; stack, the &lt;em&gt;direct stack with DHCP&lt;/em&gt;, and the &lt;em&gt;direct stack with IP&lt;/em&gt;. All controlled by switching keys.&lt;/p&gt;
&lt;h2&gt;All your functors are belong to us&lt;/h2&gt;
&lt;p&gt;There is more to be said about the new capabilities offered by functoria, in particular on how to define new devices. You can discover them by looking at the &lt;a href=&quot;https://github.com/mirage/mirage&quot;&gt;mirage&lt;/a&gt; implementation.&lt;/p&gt;
&lt;p&gt;However, to wrap up this blog post, I offer you a visualization of the MirageOS website itself (brace yourself). &lt;a href=&quot;https://mirage.io/graphics/dot/www.svg&quot;&gt;Enjoy!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thanks to &lt;a href=&quot;http://mort.io&quot;&gt;Mort&lt;/a&gt;, &lt;a href=&quot;http://somerandomidiot.com&quot;&gt;Mindy&lt;/a&gt;, &lt;a href=&quot;http://amirchaudhry.com&quot;&gt;Amir&lt;/a&gt; and &lt;a href=&quot;https://github.com/yallop&quot;&gt;Jeremy&lt;/a&gt;
for their comments on earlier drafts.&lt;/em&gt;&lt;/p&gt;

      </content><id>https://mirage.io/blog/introducing-functoria</id><title type="text">Introducing Functoria</title><updated>2016-02-29T00:00:00-00:00</updated><author><name>Gabriel Radanne</name></author></entry><entry><link href="https://mirage.io/blog/introducing-solo5" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;I'm excited to announce the release of
&lt;a href=&quot;https://github.com/solo5/solo5&quot;&gt;Solo5&lt;/a&gt;!
Solo5 is essentially a kernel library that bootstraps the hardware and
forms a base (similar to Mini-OS) from which unikernels can be built.
It runs on fully virtualized x86 hardware (e.g., KVM/QEMU), using
&lt;code&gt;virtio&lt;/code&gt; device interfaces.&lt;/p&gt;
&lt;p&gt;Importantly, Solo5 is integrated (to some extent) with the MirageOS
toolstack, so the Solo5 version of the Mirage toolstack can build
Mirage unikernels that run directly on KVM/QEMU instead of Xen.  As
such, Solo5 can be considered an alternative to Mini-OS in the Mirage
stack.  &lt;a href=&quot;https://github.com/solo5/solo5&quot;&gt;Try it out
today!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the rest of this post, I'll give a bit of motivation about why I
think the lowest layer of the unikernel is interesting and important,
as well as a rough overview of the steps I took to create Solo5.&lt;/p&gt;
&lt;h3&gt;Why focus so far down the software stack?&lt;/h3&gt;
&lt;p&gt;When people think about Mirage unikernels, one of the first things
that comes to mind is the use of a high-level language (OCaml).
Indeed, the Mirage community has invested lots of time and effort
producing implementations of traditional system components (e.g., an
entire &lt;a href=&quot;https://github.com/mirage/mirage-tcpip&quot;&gt;TCP stack&lt;/a&gt;) in OCaml.  The pervasive use of OCaml contributes to
security arguments for Mirage unikernels (strong type systems are
good) and is an interesting design choice well worth exploring.&lt;/p&gt;
&lt;p&gt;But underneath all of that OCaml goodness is a little kernel layer
written in C.  This layer has a direct impact on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;What environments the unikernel can run on.&lt;/strong&gt; Mini-OS, for
example, assumes a paravirtualized (Xen) machine, whereas Solo5
targets full x86 hardware virtualization with &lt;code&gt;virtio&lt;/code&gt; devices.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Boot time.&lt;/strong&gt; &amp;quot;Hardware&amp;quot; initialization (or lack of it in a
paravirtualized case) is a major factor in achieving the 20 ms
unikernel boot times that are changing the way people think about
elasticity in the cloud.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Memory layout and protection.&lt;/strong&gt; Hardware &amp;quot;features&amp;quot; like
page-level write protection must be exposed by the lowest layer for
techniques like memory tracing to be performed.  Also,
software-level strategies like address space layout randomization
require cooperation of this lowest layer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Low-level device interfacing.&lt;/strong&gt; As individual devices (e.g., NICs)
gain virtualization capabilities, the lowest software layer is an
obvious place to interface directly with hardware.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Threads/events.&lt;/strong&gt; The low-level code must ensure that device I/O
is asynchronous and/or fits with the higher-level synchronization
primitives.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The most popular existing code providing this low-level kernel layer
is called Mini-OS.  Mini-OS was (I believe) originally written as
a vehicle to demonstrate the paravirtualized interface offered by Xen
for people to have a reference to port their kernels to and as a base
for new kernel builders to build specialized Xen domains.  Mini-OS is
a popular base for &lt;a href=&quot;https://mirage.io&quot;&gt;MirageOS&lt;/a&gt;,
&lt;a href=&quot;http://cnp.neclab.eu/projects/clickos/&quot;&gt;ClickOS&lt;/a&gt;,
and &lt;a href=&quot;http://unikernel.org/projects/&quot;&gt;other unikernels&lt;/a&gt;.  Other
software that implements a unikernel base include
&lt;a href=&quot;http://rumpkernel.org/&quot;&gt;Rumprun&lt;/a&gt; and &lt;a href=&quot;http://osv.io/&quot;&gt;OSv&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I built Solo5 from scratch (rather than adapting Mini-OS, for example)
primarily as an educational (and fun!) exercise to explore and really
understand the role of the low-level kernel layer in a unikernel.  To
provide applications, Solo5 supports the Mirage stack.  It is my hope
that Solo5 can be a useful base for others; even if only at this point
to run some Mirage applications on KVM/QEMU!&lt;/p&gt;
&lt;h3&gt;Solo5: Building a Unikernel Base from Scratch&lt;/h3&gt;
&lt;p&gt;At a high level, there are roughly 3 parts to building a unikernel
base that runs on KVM/QEMU and supports Mirage:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Typical kernel hardware initialization.&lt;/strong&gt; The kernel must know how
to load things into memory at the desired locations and prepare
the processor to operate in the correct mode (e.g., 64-bit).  Unlike
typical kernels, most setup is one-time and simplified.  The kernel
must set up a memory map, stack, interrupt vectors, and provide
primitives for basic memory allocation.  At its simplest, a
unikernel base kernel does not need to worry about user address
spaces, threads, or many other things typical kernels need.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Interact with &lt;code&gt;virtio&lt;/code&gt; devices.&lt;/strong&gt; &lt;code&gt;virtio&lt;/code&gt; is a paravirtualized
device standard supported by some hypervisors, including KVM/QEMU
and Virtualbox.  As far as devices go, &lt;code&gt;virtio&lt;/code&gt; devices are simple:
I was able to write (very simple/unoptimized) &lt;code&gt;virtio&lt;/code&gt; drivers for
Solo5 drivers from scratch in C.  At some point it may be
interesting to write them in OCaml like the Xen device drivers in
Mirage, but for someone who doesn't know OCaml (like me) a simple C
implementation seemed like a good first step.  I should note that
even though the drivers themselves are written in C, Solo5 does
include some OCaml code to call out to the drivers so it can connect with
Mirage.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Appropriately link Mirage binaries/build system.&lt;/strong&gt; A piece of
software called &lt;a href=&quot;https://github.com/mirage/mirage-platform&quot;&gt;mirage-platform&lt;/a&gt;
performs the binding between Mini-OS
and the rest of the Mirage stack.  Building a new unikernel base
means that this &amp;quot;cut point&amp;quot; will have lots of undefined dependencies
which can either be implemented in the new unikernel base, stubbed
out, or reused.  Other &amp;quot;cut points&amp;quot; involve device drivers: the
console, network and block devices.  Finally, the &lt;code&gt;mirage&lt;/code&gt; tool
needs to output appropriate Makefiles for the new target and an
overall Makefile needs to put everything together.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each one of these steps carries complexity and gotchas and I have
certainly made many mistakes when performing all of them.  The
hardware initialization process is needlessly complex, and the overall
Makefile reflects my ignorance of OCaml and its building and packaging
systems.  It's a work in progress!&lt;/p&gt;
&lt;h3&gt;Next Steps and Getting Involved&lt;/h3&gt;
&lt;p&gt;In addition to the aforementioned clean up, I'm currently exploring
the boot time in this environment.  So far I've found that generating
a bootable iso with GRUB as a bootloader and relying on QEMU to
emulate BIOS calls to load the kernel is, by the nature of emulation,
inefficient and something that should be avoided.&lt;/p&gt;
&lt;p&gt;If you find the lowest layer of the unikernel interesting, please
don't hesitate to contact me or get involved.  I've packaged the build
and test environment for Solo5 into a Docker container to reduce the
dependency burden in playing around with it.  Check out &lt;a href=&quot;https://github.com/solo5/solo5&quot;&gt;the
repo&lt;/a&gt; for the full
instructions!&lt;/p&gt;
&lt;p&gt;I'll be talking about Solo5 at the upcoming &lt;a href=&quot;http://wiki.xenproject.org/wiki/2016_Unikernels_and_More:_Cloud_Innovators_Forum_Schedule&quot;&gt;2016 Unikernels and More:
Cloud Innovators
Forum&lt;/a&gt;
event to be held on January 22, 2016 at &lt;a href=&quot;https://www.socallinuxexpo.org/scale/14x&quot;&gt;SCALE
14X&lt;/a&gt; in Pasadena, CA USA.  I
look forward to meeting some of you there!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Discuss this post on &lt;a href=&quot;https://devel.unikernel.org/t/run-mirage-unikernels-on-kvm-qemu-with-solo5/59&quot;&gt;devel.unikernel.org&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thanks to &lt;a href=&quot;https://twitter.com/amirmc&quot;&gt;Amir&lt;/a&gt;,
&lt;a href=&quot;http://mort.io&quot;&gt;Mort&lt;/a&gt;,
and &lt;a href=&quot;https://github.com/yallop&quot;&gt;Jeremy&lt;/a&gt;,
for taking the time to read and comment on earlier drafts.&lt;/em&gt;&lt;/p&gt;

      </content><id>https://mirage.io/blog/introducing-solo5</id><title type="text">Run Mirage Unikernels on KVM/QEMU with Solo5</title><updated>2016-01-07T00:00:00-00:00</updated><author><name>Dan Williams</name></author></entry><entry><link href="https://mirage.io/blog/hackathon-marrakech2016" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;The first MirageOS hack retreat will take place in Marrakech, Morocco, from 11th till 16th March 2016.  It is open for everybody.  The main goal is to get together people motivated to contribute to MirageOS.&lt;/p&gt;
&lt;p&gt;Find more details on &lt;a href=&quot;http://retreat.mirage.io&quot;&gt;the hack retreat website&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edit: discuss this post on &lt;a href=&quot;https://devel.unikernel.org/t/1st-mirageos-hackathon/24/1&quot;&gt;devel.unikernel.org&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

      </content><id>https://mirage.io/blog/hackathon-marrakech2016</id><title type="text">MirageOS hack retreat</title><updated>2016-01-01T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/introducing-charrua-dhcp" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Almost every network needs to support
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol&quot;&gt;DHCP&lt;/a&gt;
(Dynamic
Host Configuration Protocol), that is, a way for clients to request network
parameters from the environment. Common parameters are an IP address, a network
mask, a default gateway and so on.&lt;/p&gt;
&lt;p&gt;DHCP can be seen as a critical security component, since it deals usually with
unauthenticated/unknown peers, therefore it is of special interest to run a
server as a self-contained MirageOS unikernel.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.github.com/haesbaert/charrua-core&quot;&gt;Charrua&lt;/a&gt; is a DHCP implementation
written in OCaml and it started off as an excuse to learn more about the language.
While in development it got picked up on the MirageOS mailing lists and became one
of the &lt;a href=&quot;https://github.com/mirage/mirage-www/wiki/Pioneer-Projects&quot;&gt;Pioneer
Projects&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The name &lt;code&gt;Charrua&lt;/code&gt; is a reference to the, now extinct, semi-nomadic people of
southern South America &amp;mdash; nowadays it is also used to refer to Uruguayan
nationals. The logic is that DHCP handles dynamic (hence nomadic) clients.&lt;/p&gt;
&lt;p&gt;The library is platform agnostic and works outside of MirageOS as well. It
provides two main modules:
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html&quot;&gt;Dhcp_wire&lt;/a&gt; and
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_server.html&quot;&gt;Dhcp_server&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Dhcp_wire&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html&quot;&gt;Dhcp_wire&lt;/a&gt; provides
basic functions for dealing with the protocol, essentially
marshalling/unmarshalling and helpers for dealing with the various DHCP options.&lt;/p&gt;
&lt;p&gt;The central record type of
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html&quot;&gt;Dhcp_wire&lt;/a&gt; is a
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#TYPEpkt&quot;&gt;pkt&lt;/a&gt;, which
represents a full DHCP packet, including layer 2 and layer 3 data as well as the
many possible DHCP options. The most important functions are:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;val pkt_of_buf : Cstruct.t -&amp;gt; int -&amp;gt; [&amp;gt; `Error of string | `Ok of pkt ]
val buf_of_pkt : pkt -&amp;gt; Cstruct.t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#VALpkt_of_buf&quot;&gt;pkt_of_buf&lt;/a&gt; takes
a &lt;a href=&quot;https://github.com/mirage/ocaml-cstruct&quot;&gt;Cstruct.t&lt;/a&gt; buffer and a length and it
then attempts to build a DHCP packet. Unknown DHCP options are ignored, invalid
options or malformed data are not accepted and you get an &lt;code&gt; `Error of string&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#VALbuf_of_pkt&quot;&gt;buf_of_pkt&lt;/a&gt; is
the mirror function, but it never fails.  It could for instance fail in case of
two duplicate DHCP options, but that would imply too much policy in a
marshalling function.&lt;/p&gt;
&lt;p&gt;The DHCP options from RFC2132 are implemented in
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#TYPEdhcp_option&quot;&gt;dhcp_option&lt;/a&gt;.
There are more, but the most common ones look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;type dhcp_option =
  | Subnet_mask of Ipaddr.V4.t
  | Time_offset of int32
  | Routers of Ipaddr.V4.t list
  | Time_servers of Ipaddr.V4.t list
  | Name_servers of Ipaddr.V4.t list
  | Dns_servers of Ipaddr.V4.t list
  | Log_servers of Ipaddr.V4.t list
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Dhcp_server&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_server.html&quot;&gt;Dhcp_server&lt;/a&gt;
Provides a library for building a DHCP server and is divided into two sub-modules:
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_server.Config.html&quot;&gt;Config&lt;/a&gt;,
which handles the building of a suitable DHCP server configuration record and
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_server.Config.html&quot;&gt;Input&lt;/a&gt;,
which handles the input of DHCP packets.&lt;/p&gt;
&lt;p&gt;The logic is modelled in a pure functional style and
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_server.html&quot;&gt;Dhcp_server&lt;/a&gt; does
not perform any IO of its own. It works by taking an input
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#TYPEpkt&quot;&gt;packet&lt;/a&gt;,
a
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_server.Config.html#TYPEt&quot;&gt;configuration&lt;/a&gt;
and returns a possible reply to be sent by the caller, or an error/warning:&lt;/p&gt;
&lt;h4&gt;Input&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;type result = 
| Silence                 (* Input packet didn't belong to us, normal nop event. *)
| Reply of Dhcp_wire.pkt  (* A reply packet to be sent on the same subnet. *)
| Warning of string       (* An odd event, could be logged. *)
| Error of string         (* Input packet is invalid, or some other error ocurred. *)

val input_pkt : Dhcp_server.Config.t -&amp;gt; Dhcp_server.Config.subnet -&amp;gt;
   Dhcp_wire.pkt -&amp;gt; float -&amp;gt; result
(** input_pkt config subnet pkt time Inputs packet pkt, the resulting action
    should be performed by the caller, normally a Reply packet is returned and
    must be sent on the same subnet. time is a float representing time as in
    Unix.time or MirageOS's Clock.time. **)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A typical main server loop would work by:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reading a packet from the network.
&lt;/li&gt;
&lt;li&gt;Unmarshalling with &lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#VALpkt_of_buf&quot;&gt;Dhcp_wire.pkt_of_buf&lt;/a&gt;.
&lt;/li&gt;
&lt;li&gt;Inputting the result with &lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_server.Input.html#VALinput_pkt&quot;&gt;Dhcp_server.Input.input_pkt&lt;/a&gt;.
&lt;/li&gt;
&lt;li&gt;Sending the reply, or logging the event from the &lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_server.Input.html#VALinput_pkt&quot;&gt;Dhcp_server.Input.input_pkt&lt;/a&gt; call.
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A mainloop example can be found in
&lt;a href=&quot;https://github.com/mirage/mirage-skeleton/blob/master/dhcp/unikernel.ml#L28&quot;&gt;mirage-skeleton&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  let input_dhcp c net config subnet buf =
    let open Dhcp_server.Input in
    match (Dhcp_wire.pkt_of_buf buf (Cstruct.len buf)) with
    | `Error e -&amp;gt; Lwt.return (log c (red &amp;quot;Can't parse packet: %s&amp;quot; e))
    | `Ok pkt -&amp;gt;
      match (input_pkt config subnet pkt (Clock.time ())) with
      | Silence -&amp;gt; Lwt.return_unit
      | Warning w -&amp;gt; Lwt.return (log c (yellow &amp;quot;%s&amp;quot; w))
      | Error e -&amp;gt; Lwt.return (log c (red &amp;quot;%s&amp;quot; e))
      | Reply reply -&amp;gt;
        log c (blue &amp;quot;Received packet %s&amp;quot; (Dhcp_wire.pkt_to_string pkt));
        N.write net (Dhcp_wire.buf_of_pkt reply)
        &amp;gt;&amp;gt;= fun () -&amp;gt;
        log c (blue &amp;quot;Sent reply packet %s&amp;quot; (Dhcp_wire.pkt_to_string reply));
        Lwt.return_unit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As stated,
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_server.Input.html#VALinput_pkt&quot;&gt;Dhcp_server.Input.input_pkt&lt;/a&gt;
does not perform any IO of its own, it only deals with the logic of analyzing a
DHCP packet and building a possible answer, which should then be sent by the
caller. This allows a design where all the side effects are controlled in one
small chunk, which makes it easier to understand the state transitions since they
are made explicit.&lt;/p&gt;
&lt;p&gt;At the time of this writing,
&lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_server.Input.html#VALinput_pkt&quot;&gt;Dhcp_server.Input.input_pkt&lt;/a&gt;
is not side effect free, as it manipulates a database of leases, this will be
changed in the next version to be pure as well.&lt;/p&gt;
&lt;p&gt;Storing leases in permanent storage is also unsupported at this time and
should be available soon, with Irmin and other backends. The main idea is to
always return a new lease database for each input, or maybe just the updates to
be applied, and in this scenario, the caller would be able to store the database in
permanent storage as he sees fit.&lt;/p&gt;
&lt;h4&gt;Configuration&lt;/h4&gt;
&lt;p&gt;This project started independently of MirageOS and at that time, the best
configuration I could think of was the well known &lt;code&gt;ISC&lt;/code&gt; &lt;code&gt;dhcpd.conf&lt;/code&gt;. Therefore,
the configuration uses the same format but it does not support the myriad of
options of the original one.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  type t = {
    addresses : (Ipaddr.V4.t * Macaddr.t) list;
    subnets : subnet list;
    options : Dhcp_wire.dhcp_option list;
    hostname : string;
    default_lease_time : int32;
    max_lease_time : int32;
  }

  val parse : string -&amp;gt; (Ipaddr.V4.Prefix.addr * Macaddr.t) list -&amp;gt; t
  (** [parse cf l] Creates a server configuration by parsing [cf] as an ISC
      dhcpd.conf file, currently only the options at [sample/dhcpd.conf] are
      supported. [l] is a list of network addresses, each pair is the output
      address to be used for building replies and each must match a [network
      section] of [cf]. A normal usage would be a list of all interfaces
      configured in the system *)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although it is a great format, it doesn't exactly play nice with MirageOS and
OCaml, since the unikernel needs to parse a string at runtime to build the
configuration, this requires a file IO backend and other complications. The
next version should provide OCaml helpers for building the configuration, which
would drop the requirements of a file IO backend and facilitate writing tests.&lt;/p&gt;
&lt;h3&gt;Building a simple server&lt;/h3&gt;
&lt;p&gt;The easiest way is to follow the &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/blob/master/dhcp/README.md&quot;&gt;mirage-skeleton DHCP
README&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Future&lt;/h3&gt;
&lt;p&gt;The next steps would be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Provide helpers for building the configuration.
&lt;/li&gt;
&lt;li&gt;Expose the lease database in an immutable structure, possibly a &lt;code&gt;Map&lt;/code&gt;, adding
also support/examples for &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin&lt;/a&gt;.
&lt;/li&gt;
&lt;li&gt;Use &lt;a href=&quot;https://github.com/mirage/functoria&quot;&gt;Functoria&lt;/a&gt; to pass down the
configuration in &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/blob/master/dhcp/README.md&quot;&gt;mirage-skeleton&lt;/a&gt;. Currently
it is awkward since the user has to edit &lt;code&gt;unikernel.ml&lt;/code&gt; and &lt;code&gt;config.ml&lt;/code&gt;, with
&lt;a href=&quot;https://github.com/mirage/functoria&quot;&gt;Functoria&lt;/a&gt; we would be able to have it
much nicer and only touch &lt;code&gt;config.ml&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;Convert MirageOS DHCP client code to use &lt;a href=&quot;http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html&quot;&gt;Dhcp_wire&lt;/a&gt;, or perhaps add a
client logic functionality to &lt;a href=&quot;http://www.github.com/haesbaert/charrua-core&quot;&gt;Charrua&lt;/a&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Finishing words&lt;/h3&gt;
&lt;p&gt;This is my first real project in OCaml and I'm more or less a newcomer to
functional programming as well, my background is mostly kernel hacking as an
ex-OpenBSD developer.
I'd love to hear how people are actually using it and any problems they're
finding, so please do let me know via the
&lt;a href=&quot;https://github.com/haesbaert/charrua-core/issues&quot;&gt;issue tracker&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Prior to this project I had no contact with any of the MirageOS folks, but I'm
amazed about how easy the interaction and communication with the community has been,
everyone has been incredibly friendly and supportive. I'd say MirageOS is a gold
project for anyone wanting to work with smart people and hack OCaml.&lt;/p&gt;
&lt;p&gt;My many thanks to &lt;a href=&quot;http://anil.recoil.org&quot;&gt;Anil&lt;/a&gt;, &lt;a href=&quot;http://mort.io&quot;&gt;Richard&lt;/a&gt;, &lt;a href=&quot;https://github.com/hannesm&quot;&gt;Hannes&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/amirmc&quot;&gt;Amir&lt;/a&gt;, Scott, Gabriel and others.
Thanks also to &lt;a href=&quot;http://roscidus.com/blog/&quot;&gt;Thomas&lt;/a&gt; and &lt;a href=&quot;https://github.com/Chris00/&quot;&gt;Christophe&lt;/a&gt; for comments on this post.
I also
would like to thank my &lt;a href=&quot;https://www.genua.de&quot;&gt;employer&lt;/a&gt; for letting me work on this
project in our hackathons.&lt;/p&gt;

      </content><id>https://mirage.io/blog/introducing-charrua-dhcp</id><title type="text">Introducing Charrua  a DHCP implementation</title><updated>2015-12-29T00:00:00-00:00</updated><author><name>Christiano Haesbaert</name></author></entry><entry><link href="https://mirage.io/blog/unikernel-org" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Unikernels are specialised single address space machine images that are
constructed by using library operating systems. With MirageOS, we've taken a
clean-slate approach to unikernels with a focus on safety. This involved
writing protocol libraries from the ground up and it also afforded the ability
to use clean, modern APIs.&lt;/p&gt;
&lt;p&gt;Other unikernel implementations have made trade-offs different to those made
by MirageOS. Some excel at handling legacy applications by making the most of
existing OS codebases rather than building clean-slate implementations. Some
target a wide array of possible environments, or environments complementary to
those supported by MirageOS currently.
All of these implementations ultimately help developers construct unikernels
that match their specific needs and constraints.&lt;/p&gt;
&lt;p&gt;As word about unikernels in general is spreading, more people are trying to
learn about this new approach to programming the cloud and embedded devices.
Since information is spread across multiple sites, it can be tricky to know
where to get an overview and how to get started quickly. So to help people get
on board, there's a new community website at &lt;strong&gt;&lt;a href=&quot;http://unikernel.org&quot;&gt;unikernel.org&lt;/a&gt;&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;http://unikernel.org&quot;&gt;unikernel.org&lt;/a&gt; community site aims to collate information about the
various projects and provide a focal point for early adopters to understand
more about the technology and become involved in the projects themselves.&lt;/p&gt;
&lt;p&gt;Over time, it will also become a gathering place for common infrastructure to
form and be shared across projects.  Early examples of this include the
scripts for booting on Amazon EC2, which began with MirageOS contributors but
were used and improved by &lt;a href=&quot;http://rumpkernel.org&quot;&gt;Rump Kernel&lt;/a&gt; contributors.  You can follow the
email threads where the script was &lt;a href=&quot;https://www.freelists.org/post/rumpkernel-users/EC2-launch-script-feedback-valued&quot;&gt;first proposed&lt;/a&gt; and ultimately
provided &lt;a href=&quot;https://www.freelists.org/post/rumpkernel-users/Amazon-EC2-support-now-in-Rumprun&quot;&gt;EC2 support for Rumprun&lt;/a&gt;. Continuing to work together
to make such advances will ease the process of bringing in new users and
contributors across all the projects.&lt;/p&gt;
&lt;p&gt;Please do visit the site and contribute stories about how you're using and
improving unikernels!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edit: discuss this post on &lt;a href=&quot;https://devel.unikernel.org/t/why-we-need-unikernel-org/18/1&quot;&gt;devel.unikernel.org&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thanks to &lt;a href=&quot;http://anil.recoil.org&quot;&gt;Anil&lt;/a&gt;, &lt;a href=&quot;https://github.com/yallop&quot;&gt;Jeremy&lt;/a&gt; and &lt;a href=&quot;http://somerandomidiot.com&quot;&gt;Mindy&lt;/a&gt; for
comments on an earlier draft.&lt;/em&gt;&lt;/p&gt;

      </content><id>https://mirage.io/blog/unikernel-org</id><title type="text">Unikernel.org</title><updated>2015-12-17T00:00:00-00:00</updated><author><name>Amir Chaudhry</name></author></entry><entry><link href="https://mirage.io/blog/videos-around-world-2015" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Word about Unikernels and MirageOS is spreading and as the community grows,
more people have been giving talks at user groups and conferences. Below are a
selection of those that have been recorded, which alone is about 5 hours of
content.  The topics are wide ranging and include discussions about where
unikernels fit in the ecosystem, all the way down to networking topics.&lt;/p&gt;
&lt;p&gt;I hope you enjoy these and if you'd like to give a talk somewhere or share
one of your videos, please do &lt;a href=&quot;mailto:mirageos-devel@lists.xenproject.org&quot;&gt;get in touch&lt;/a&gt;!&lt;/p&gt;
&lt;h4&gt;Videos of recent talks&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://anil.recoil.org&quot;&gt;Anil Madhavapeddy&lt;/a&gt; at Esper Technologies - May 2015&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;'Unikernels: Functional Infrastructure with MirageOS'&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/bC7rTUEZfmI&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://twitter.com/RCPavlicek&quot;&gt;Russell Pavlicek&lt;/a&gt; at SouthEast LinuxFest - June 2015&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;'Next Generation Cloud'&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/8UgiPODw3CY&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Russ has also been at many other Linuxfests this year!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://amirchaudhry.com&quot;&gt;Amir Chaudhry&lt;/a&gt; at PolyConf - July 2015&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;'Unikernels!'&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/nZLy19eRWLk&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;There's more information about this talk in the blog post at:
&lt;a href=&quot;http://amirchaudhry.com/unikernels-polyconf-2015&quot;&gt;http://amirchaudhry.com/unikernels-polyconf-2015&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/hannesm&quot;&gt;Hannes Mehnert&lt;/a&gt; at Source_Code Berlin - Aug 2015&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;'Leaving legacy behind &amp;mdash; A clean-slate approach to operating systems'&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/PTtI8hpR7hQ&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://twitter.com/sjfloat&quot;&gt;Steve Jones&lt;/a&gt; at DevopsDays Pittsburgh - Aug 2015&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;'The Incredible Shrinking Operating System!'&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/Ud3NGqRRGc4&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://somerandomidiot.com&quot;&gt;Mindy Preston&lt;/a&gt; at Strangeloop - Sep 2015&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;'Non-Imperative Network Programming'&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/GNc1t6Q5Dls&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;Mindy also wrote a post that has some information and links:
&lt;a href=&quot;http://somerandomidiot.com/blog/2015/10/07/ocaml-workshop-and-strange-loop-talks&quot;&gt;http://somerandomidiot.com/blog/2015/10/07/ocaml-workshop-and-strange-loop-talks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://twitter.com/mattbajor&quot;&gt;Matt Bajor&lt;/a&gt; at Strangeloop - Sep 2015&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;'Look ma, no OS! Unikernels and their applications'&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/W9F4pn9Lngc&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://twitter.com/garethr&quot;&gt;Gareth Rushgrove&lt;/a&gt; at Operability - Sep 2015&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;'Taking the Operating System out of Operations'&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/nxofKgwgjHs&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://twitter.com/gar1t&quot;&gt;Garett Smith&lt;/a&gt; at CityCode - Oct 2015&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;'Rainbows and Unikernels'&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/cUvNths_5RA&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

      </content><id>https://mirage.io/blog/videos-around-world-2015</id><title type="text">Videos from around the world!</title><updated>2015-10-23T00:00:00-00:00</updated><author><name>Amir Chaudhry</name></author></entry><entry><link href="https://mirage.io/blog/getting-started-screencasts" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We put together some quick screencasts to make it easier for people to get
started with MirageOS. They're all in a playlist below, which is around 10
minutes in total.&lt;/p&gt;
&lt;p&gt;There are currently 4 videos which walk through some of the typical steps.
The first three cover installation, building a 'hello world', and building a
Xen unikernel on an Ubuntu machine. The fourth video gives an overview of the
development workflows that are possible with OPAM and Git.&lt;/p&gt;
&lt;p&gt;These should give everyone a clear idea of what it's like to work with the
tools before leaping in and installing things!&lt;/p&gt;
&lt;p&gt;If anyone would like to help us make more of these screencasts, please do get
in touch on the &lt;a href=&quot;http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel&quot;&gt;mailing list&lt;/a&gt; &amp;mdash; I've also listed it as one of our many
&lt;a href=&quot;https://github.com/mirage/mirage-www/wiki/Pioneer-Projects#screencasts&quot;&gt;Pioneer Projects&lt;/a&gt;!&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/videoseries?list=PLgjWYrrJw8_wlrkveCXULbg6oIYDvNuDU&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

      </content><id>https://mirage.io/blog/getting-started-screencasts</id><title type="text">Getting Started Screencasts</title><updated>2015-10-15T00:00:00-00:00</updated><author><name>Amir Chaudhry</name></author></entry><entry><link href="https://mirage.io/blog/mirage-entropy" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;This post gives a bit of background on the &lt;em&gt;Random Number Generator&lt;/em&gt; (RNG) in
the recent MirageOS v2.5 release.&lt;/p&gt;
&lt;p&gt;First we give background about why RNGs are really critical for security. Then
we try to clarify the often-confused concepts of &amp;quot;randomness&amp;quot; and &amp;quot;entropy&amp;quot;, as
used in this context. Finally, we explore the challenges of harvesting
good-quality entropy in a unikernel environment.&lt;/p&gt;
&lt;h3&gt;Playing dice&lt;/h3&gt;
&lt;p&gt;Security software must play dice.&lt;/p&gt;
&lt;p&gt;It must do so to create secrets, for example. Secrets can then serve as the
keys that protect communication, like the Diffie-Hellman key exchanged between
two TLS endpoints. Proof of the knowledge of a particular secret can be
used to verify the identity of someone on the Internet, as in the case of
verifying the possession of the secret RSA key associated with an X.509
certificate. As an attacker guessing a secret can have disastrous consequences,
it must be chosen in a manner that is realistically unpredictable by anyone
else &amp;mdash; we need it to be &lt;em&gt;random&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;There are other reasons to use randomness. A number of algorithms require a
unique value every time they are invoked and badly malfunction when this
assumption is violated, with random choice being one way to provide a value
likely to be unique. For example, repeating the &lt;code&gt;k&lt;/code&gt;-&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_Signature_Algorithm#Sensitivity&quot;&gt;parameter&lt;/a&gt;
in DSA digital signatures compromises the secret key, while reusing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Galois/Counter_Mode&quot;&gt;GCM&lt;/a&gt; nonce negates both confidentiality and authenticity. Other
algorithms are probabilistic, in that they generate random values before
operating on an input, and then store the chosen values in the output, such as
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding&quot;&gt;OAEP&lt;/a&gt; padding mode for RSA. This is done in order to confuse the
relationship between the input and the output and defeat a clever attacker who
tries to manipulate the input to gain knowledge about secrets by looking at the
output. Still other algorithms pick random numbers to internally change their
operation and hide the physical amount of time they need to execute, to avoid
revealing information about the secrets they operate on. This is known as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Blinding_(cryptography)&quot;&gt;blinding&lt;/a&gt;, and is one way to counter timing side-channel
attacks.&lt;/p&gt;
&lt;p&gt;Randomness is therefore quite pervasive in a security context. In fact, many
cryptographic algorithms are designed under the assumption of a readily
available source of randomness, termed a &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_oracle&quot;&gt;random oracle&lt;/a&gt;&lt;/em&gt;.
The security analysis of those algorithms is conditional on the oracle; we know
that they have certain security characteristics, like the difficulty of guessing
the correct message or impersonating somebody, only given an ideal random oracle.&lt;/p&gt;
&lt;p&gt;And so security software has a problem here. Computers are inherently
deterministic, made to behave reproducibly given a known program and starting
state. How to go about solving this?&lt;/p&gt;
&lt;h3&gt;Random failures&lt;/h3&gt;
&lt;p&gt;Before taking a look at how we try to solve this problem, let's instead consider
what happens if we &lt;strong&gt;fail&lt;/strong&gt; to do so. There is even a &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_number_generator_attack&quot;&gt;Wikipedia
page&lt;/a&gt; about this, which is a nice starting point. Some
of the highlights:&lt;/p&gt;
&lt;p&gt;The first public release of Netscape's original SSL, version 2.0, was
&lt;a href=&quot;http://prng.net/faq/netscape-ssl/&quot;&gt;broken&lt;/a&gt; several months after its release. The weakness
was in initializing the RNG with the current time, the process ID and the parent
process ID of the browser. The time stamp can be guessed to a certain precision,
leaving only its sub-second part and the two PIDs unknown. This relatively small
unknown space of initial values can be brute-forced.&lt;/p&gt;
&lt;p&gt;About a decade later, Debian patched their version of OpenSSL and reduced RNG
initialization to the current PID. As a result, only 32767 random sequences were
possible. This flaw went undetected for two years and became known as the
&lt;a href=&quot;http://research.swtch.com/openssl&quot;&gt;Debian fiasco&lt;/a&gt;. Personal reports indicate that some of the 32767
distinct secret keys that could be generated with OpenSSL on a Debian system
during that time are still in circulation.&lt;/p&gt;
&lt;p&gt;Computing the largest common divisor of a pair of numbers is much faster than
discovering all the prime divisors of a particular number. RSA public keys
contain a number, and secret keys contain its factors. An RSA key is usually
generated by randomly picking the factors. If a pool of keys was generated with
a heavily biased random number generator, such that factors are likely to
repeat, it is possible to search for common factors in all pairs and crack the
affected keys, a technique which produces
&lt;a href=&quot;https://eprint.iacr.org/2013/599&quot;&gt;spectacular&lt;/a&gt; &lt;a href=&quot;https://factorable.net/weakkeys12.extended.pdf&quot;&gt;results&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Recently, a bitcoin application for Android was
&lt;a href=&quot;https://www.reddit.com/r/Bitcoin/comments/37oxow/the_security_issue_of_blockchaininfos_android/&quot;&gt;discovered&lt;/a&gt; to be downloading its random initial value from a
&lt;a href=&quot;http://www.random.org&quot;&gt;website&lt;/a&gt;. It wasn't even necessary to intercept this
unencrypted traffic, because the website started serving a redirect page and the
Android application was left initializing its RNG with the text of the redirection
message. It therefore started
generating the same private ECDSA key and the associated bitcoin address for
every affected user, an issue which reportedly &lt;a href=&quot;http://www.theregister.co.uk/2015/06/01/blockchain_app_shows_how_not_to_code/&quot;&gt;cost&lt;/a&gt; some users
their bitcoins.&lt;/p&gt;
&lt;p&gt;Playstation 3 game signatures can be forged. Sony &lt;a href=&quot;https://www.schneier.com/blog/archives/2011/01/sony_ps3_securi.html&quot;&gt;reused&lt;/a&gt; a
single &lt;code&gt;k&lt;/code&gt;-parameter, which is supposed to be &amp;quot;unique, unpredictable and
secret&amp;quot;, for every ECDSA signature they made. This lead to complete compromise
of the signing keys. Admittedly, this is not really an RNG
problem in itself, but it shows where such a malfunction can lead.&lt;/p&gt;
&lt;p&gt;These are only some of the most spectacular failures related to random numbers.
For example, it is widely known in security circles that RNGs of embedded
devices tend to be predictable, leading to widespread use of weak keys on routers
and similar equipment, amongst other things. So when implementing a unikernel
operating system, you don't want to end up on that Wikipedia page either.&lt;/p&gt;
&lt;h3&gt;Random sequences and stuff&lt;/h3&gt;
&lt;p&gt;But what are random numbers, really? Intuitively, we tend to think about them as
somehow &amp;quot;dancing around&amp;quot;, or being &amp;quot;jiggly&amp;quot; in a sense. If we have a software
component that keeps producing random outputs, these outputs form a sequence,
and we hope this to be a &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_sequence&quot;&gt;random sequence&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But such a thing is &lt;a href=&quot;https://xkcd.com/221&quot;&gt;notoriously&lt;/a&gt; &lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;difficult&lt;/a&gt; to define.
The above linked page opens with the following quote:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A random sequence is a vague notion... in which each term is unpredictable to
the uninitiated and whose digits pass a certain number of tests traditional with
statisticians.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The intuitive jigglyness is captured by &lt;a href=&quot;https://en.wikipedia.org/wiki/Statistical_randomness&quot;&gt;statistical
randomness&lt;/a&gt;. We require each output, taken
independently, to come from the same distribution (and in fact we want it to be
the uniform distribution). That is, when we take a long sequence of outputs, we
want them to cover the entire range, we want them to cover it evenly, and we
want the evenness to increase as the number of outputs increases &amp;mdash; which
constitutes a purely frequentist definition of randomness. In addition, we want
the absence of clear patterns between outputs. We don't want the sequence to
look like &lt;code&gt;7, 8, 9, 10, ...&lt;/code&gt;, even with a bit of noise, and we
don't want correlation between outputs. The problem here is that no-one really
knows what &amp;quot;having patterns&amp;quot; means; it is entirely possible that we only
searched for patterns too simple, and that in fact there is a pattern that fully
explains the sequence lurking just around the complexity corner.&lt;/p&gt;
&lt;p&gt;Nonetheless, there is a well established battery of tests to check statistical
randomness of RNG outputs, called the &lt;a href=&quot;http://www.stat.fsu.edu/pub/diehard/&quot;&gt;Diehard Tests&lt;/a&gt;, and serves
as the de-facto standard for testing random number generators. Here's the
beginning of a certain sequence that &lt;a href=&quot;http://interstat.statjournals.net/YEAR/2005/articles/0510005.pdf&quot;&gt;passes&lt;/a&gt; the test
with flying colors:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4, 6, 2, 6, 4, 3, 3, 8, 3, ...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;We still would not recommend using digits of &lt;code&gt;&amp;pi;&lt;/code&gt; as a secret key.
Neither would we recommend
releasing software for everyone to study, which uses that sequence to generate
the secrets. But what went wrong?&lt;/p&gt;
&lt;p&gt;The other &lt;a href=&quot;https://en.wikipedia.org/wiki/Algorithmically_random_sequence&quot;&gt;concept of randomness&lt;/a&gt;. Roughly, a
random sequence should not be predictable to anyone with any knowledge other
than the sequence itself. In other words, it cannot be compressed no matter how
much we try, and in the extreme, this means that it cannot be generated by a
program. While the latter restriction is obviously a little too strong for our
purpose, it highlights a deep distinction in what people mean by being
&amp;quot;random&amp;quot;.
Jumping around is one thing. Being &lt;em&gt;actually unpredictable&lt;/em&gt; is a
wholly different matter.&lt;/p&gt;
&lt;p&gt;There are many other &lt;a href=&quot;http://mathworld.wolfram.com/Rule30.html&quot;&gt;simple&lt;/a&gt; mathematical processes which
generate sequences with high statistical randomness. Many of those are used to
produce &amp;quot;random&amp;quot; sequences for various purposes. But these are still completely
deterministic processes that exhibit random behaviour only in the statistical
sense. Instead of being &lt;em&gt;random&lt;/em&gt;, they are &lt;em&gt;pseudo-random&lt;/em&gt;, and we call such
generators &lt;em&gt;Pseudo-Random Number Generators&lt;/em&gt; (PRNGs).&lt;/p&gt;
&lt;p&gt;We can look for something approaching a &amp;quot;true&amp;quot; random sequence in nature.
The current agreement is that the nature of quantum processes is random in this
sense, and random sequences based on this idea are readily available for
&lt;a href=&quot;http://qrbg.irb.hr/&quot;&gt;download&lt;/a&gt;. Or we can use the microphone and keep recording; the
lowest-order bits of the signal are pretty unpredictable. But we cannot write a
program to generate an actually random sequence.&lt;/p&gt;
&lt;p&gt;Still, we need to compromise. The real problem of common PRNGs is that knowing
the rule and observing some of the outputs is enough to predict the rest of the
sequence. The entire future behavior of &lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne twister&lt;/a&gt;,
one of the most commonly used generators in various programming packages, can be
predicted after observing only 624 outputs in a row. A step up from such a
process is a &lt;em&gt;Cryptographically Secure Pseudo-Random Number Generator&lt;/em&gt; (CSPRNG).
Their key property is that it is computationally prohibitively expensive to
distinguish their outputs from a &amp;quot;true&amp;quot; random sequence. This also means that it
is computationally prohibitively expensive to reconstruct their internal state,
just by looking at their outputs. In a sense, someone trying to predict the
outputs can not take shortcuts, and is instead forced to perform the laborious
task of starting the generator with all the possible states and checking if the
output matches the observed sequence. This is how we can quantify a CSPRNG
unpredictability: it takes trying about half of all the possibilities to guess
the state.&lt;/p&gt;
&lt;p&gt;MirageOS' security stack contains a CSPRNG, a design called &lt;a href=&quot;https://www.schneier.com/fortuna.html&quot;&gt;Fortuna&lt;/a&gt;.
What it really does, is encrypt the simple sequence &lt;code&gt;0, 1, 2, 3, ...&lt;/code&gt; with AES
(AES-CTR) using a secret key. This makes it as resistant to prediction as AES is
to &lt;a href=&quot;https://en.wikipedia.org/wiki/Known-plaintext_attack&quot;&gt;known-plaintext attacks&lt;/a&gt;. After each output, it
generates a bit more, hashes that, and uses the result as the next key. This is
not to improve the statistical randomness, as it is already guaranteed by AES.
Rather, it's a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Forward_secrecy&quot;&gt;forward secrecy&lt;/a&gt;: an attacker who
learns the secret key at some point would need to perform the &lt;a href=&quot;https://en.wikipedia.org/wiki/Preimage_attack&quot;&gt;preimage
attack&lt;/a&gt; on the hash function to figure out the earlier key
and reconstruct the earlier outputs.&lt;/p&gt;
&lt;h3&gt;Entropy&lt;/h3&gt;
&lt;p&gt;Although resistant to prediction based solely on the outputs, just like any
other software RNG, Fortuna is still just a deterministic PRNG. Its entire
output is as unpredictable as its initial value, which we call the &lt;em&gt;seed&lt;/em&gt;. From
the information perspective, a PRNG can only transform what was unpredictable
about its initial seed into an equally unpredictable sequence. In other words,
we typically use PRNGs to stretch the unpredictability inherent in the initial
seed into an infinite stream. The best PRNGs do not give out more hints about
their starting position, but they can never out-race the amount of
unpredictability that they started with.&lt;/p&gt;
&lt;p&gt;We often call this quality of unpredictability &lt;em&gt;entropy&lt;/em&gt;. In a sense, by
employing an algorithmic generator, we have just shifted the burden of being
unpredictable to the beginning. But now we're cornered and have to search for entropy in
the only place where a computer can find it: in the physical world.&lt;/p&gt;
&lt;p&gt;A typical (kernel-level) RNG-system reaches out into the world around it through
hardware interaction: as hardware events happen, various drivers tend to emit
small packets of data, such as the time, or hardware-specific state. These
events are a product of the user interactions with the keyboard and mouse, of
network packets arriving at an interface, of the hard drive asserting interrupts
to signal the end of a DMA transfer, and the like. They are combined together
and used to seed the internal (CS-)PRNG.&lt;/p&gt;
&lt;p&gt;In fact, describing them as a &lt;em&gt;seed&lt;/em&gt; from which the entire sequence is unfolded
is a deliberate oversimplification: what really happens is that the PRNG is
continuously fed with random events, which change its state as they arrive, and
the requests for random bytes are served from the PRNG. The PRNG is used to
&amp;quot;mix&amp;quot; the unpredictability inherent in its input, that is, to smooth out various
timestamps and similar values into a statistically well-behaved sequence.&lt;/p&gt;
&lt;h3&gt;Do Virtual Machines Dream of Electric Sheep?&lt;/h3&gt;
&lt;p&gt;Our problem here is that a virtual machine (VM) in a typical configuration
barely sees any physical hardware. Users do not interact with VMs in server
scenarios using a directly-connected keyboard and mouse. VMs make use of a
virtualized network interface and virtualized disks. Even the CPU features can
be intercepted and virtualized. Virtual environments are entropy-starved.&lt;/p&gt;
&lt;p&gt;This is a known problem and &lt;a href=&quot;http://www.cs.berkeley.edu/~cthompson/papers/vmm-entropy-report-2011.pdf&quot;&gt;various&lt;/a&gt;
&lt;a href=&quot;http://www.ieee-security.org/TC/SP2014/papers/Not-So-RandomNumbersinVirtualizedLinuxandtheWhirlwindRNG.pdf&quot;&gt;analyses&lt;/a&gt; of the weakness of random outputs in virtual
environments have been published. The problem is especially severe right after
boot. The gradual trickle of unpredictability from hardware events slowly moves
the pseudo-random stream into an increasingly unpredictable state,
but at the very start, it still
tends to be fairly predictable. Typically, operating systems store some of their
PRNG output on shutdown and use it to quickly reseed their PRNG on the next
boot, in order to reuse whatever entropy was contained in its state.
Unfortunately, it is common to boot several machines from the same system image,
or from a pristine image lacking a seed, making random outputs in a virtual
machine vulnerable to prediction close to the startup phase.&lt;/p&gt;
&lt;p&gt;To help solve these problems, we employ several sources of entropy in MirageOS
unikernels. The case of a Unix executable is simple, as we reuse the system's
own RNG, as exposed via &lt;code&gt;/dev/urandom&lt;/code&gt;, as the source of our entropy. This is
because the kernel is in a much better position to enter an unpredictable state
than any single process running under its supervision. The case of Xen
unikernels is harder. Here, we group the entropy sources into those that
originate within the unikernel itself, and those that originate externally.&lt;/p&gt;
&lt;p&gt;In the external case, we again rely on the kernel interacting with the hardware,
but this time it's the dom0 kernel. We have a background service,
&lt;a href=&quot;https://github.com/mirage/xentropyd&quot;&gt;Xentropyd&lt;/a&gt;, which runs in dom0, reads the RNG and serves its output
to other domains through the Xen Console. The problem is that in many scenarios,
like hosting on popular cloud providers, we cannot expect this degree of cooperation from
dom0. A bigger problem is that although most of the code is present, we haven't
fully fleshed out this design and it remains disabled in MirageOS 2.5.0&lt;/p&gt;
&lt;p&gt;So we need to be able to achieve unpredictability relying purely on what is
available inside a unikernel. A unikernel has no direct exposure to the
hardware, but it is of course interacting with the outside world. To tap into
this ambient entropy, we have to continuously sample all inter-event timings
in its event loop. This process is analogous to what happens in a full-blown OS
kernel, except our events lack the extra hardware context, and our timers are
potentially less granular (for example, on ARM). This makes our
interaction-based events somewhat more predictable, or in other words, they have
a little less entropy.&lt;/p&gt;
&lt;p&gt;Recent Intel chips come with an on-die random generator, which ultimately
derives from thermal readings, and is available through &lt;code&gt;RDRAND&lt;/code&gt; and (more
directly) &lt;code&gt;RDSEED&lt;/code&gt; instructions. The community has expressed concern that
relying exclusively on this generator might not be a wise choice: it could
silently malfunction, and its design is hidden in the hardware, which raises
concerns about potential intentional biases in the output &amp;mdash; a scheme not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dual_EC_DRBG&quot;&gt;unheard of&lt;/a&gt;. However, since entropy is additive, its output can never
reduce whatever unpredictability the system already has. Therefore, if
available, we continuously sample this on-die RNG, and inject its outputs into
our PRNG.&lt;/p&gt;
&lt;p&gt;The combination of event timings and a built-in RNG does have good unpredictability
in the long run, especially if our unikernel is running on a multi-tenant host
and competing for CPU with other instances. But the entropy in each individual
event is still relatively low: we can assume that a determined attacker can
guess each individual time stamp up to a certain precision that we don't know,
but which is potentially quite high. This creates the following problem: imagine
that an attacker knows the current PRNG state, and can measure the time of the
next event, but not with sufficient precision to know the last two bits of the
timestamp. To this attacker, our event contains two bits of entropy.
If we immediately update the PRNG, the attacker only has to observe
some of the output and check four candidate states against it, to fully recover
knowledge about the state and negate our entropy addition. On the other hand, if
we decide to wait and try to accumulate many more events before updating the
PRNG, we keep generating a fully predictable sequence in the meantime.&lt;/p&gt;
&lt;p&gt;And here is where Fortuna really shines. It keeps accumulating events in a
number of
internal pools in a round-robin fashion. These pools are constantly being
activated, but with an exponentially decreasing frequency. The pools activated
too frequently are wasted, but one of them is activated with just the right
frequency to contain enough entropy to make it prohibitively expensive for an
attacker to enumerate all the possibilities. This design was
&lt;a href=&quot;https://eprint.iacr.org/2014/167&quot;&gt;shown&lt;/a&gt; to be within a constant factor from optimal entropy
use, and in particular, scales robustly with the actual amount of entropy
inherent in the input events.&lt;/p&gt;
&lt;p&gt;This leaves us with the problem of boot-time entropy. Not only can the saved
random seed be reused by cloning the disk image, but in many cases, a MirageOS
unikernel is running without such storage at all!&lt;/p&gt;
&lt;p&gt;Following the design of &lt;a href=&quot;http://www.ieee-security.org/TC/SP2014/papers/Not-So-RandomNumbersinVirtualizedLinuxandtheWhirlwindRNG.pdf&quot;&gt;Whirlwind RNG&lt;/a&gt;, we employ an entropy
&lt;a href=&quot;https://github.com/mirage/mirage-entropy/blob/863b48d4e33b43ca31c49c2e8caef4e367fab7b2/lib/entropy_xen.ml#L79&quot;&gt;bootstrapping loop&lt;/a&gt;. It's an iterated computation, which
measures the time it took to perform the previous iteration, and then performs
the amount of work that depends on the time, many times over. In this way, it
creates a feedback loop with a fragile dependency on any non-determinism in the
physical execution on the CPU, such as any contention or races in the CPU state.
Even on ARM, which currently uses a less fine-grained timer and whose design is
not as parallel as Intel's, this yields an initial value which varies wildly
between boots. We use this value to kickstart the PRNG, giving it quick
divergence, and ensuring that the state is unpredictable from the very start.&lt;/p&gt;
&lt;h3&gt;Parting words&lt;/h3&gt;
&lt;p&gt;While some of our techniques (in particular bootstrapping on ARM) need a little
more exposure before we place our full confidence in them &amp;mdash; and users should
probably avoid generating long-term private keys in unikernels running on bare
Xen just yet &amp;mdash; the combination of boostrapping, continuous reseeding, and
robust accumulation gives us a hopefully comprehensive solution to generating
randomness in a unikernel environment.&lt;/p&gt;
&lt;p&gt;We intend to re-evaluate the effectiveness of this design after getting some
experience with how it works in the wild. To this end, we particularly
appreciate the community feedback and
you can reach us through our &lt;a href=&quot;http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel&quot;&gt;mailing list&lt;/a&gt;, or hop onto
&lt;code&gt;freenode&lt;/code&gt; and join &lt;code&gt;#mirage&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thanks to &lt;a href=&quot;http://erratique.ch&quot;&gt;Daniel&lt;/a&gt;, &lt;a href=&quot;http://mort.io&quot;&gt;Mort&lt;/a&gt; and &lt;a href=&quot;http://amirchaudhry.com&quot;&gt;Amir&lt;/a&gt; for their comments on earlier
drafts.&lt;/em&gt;&lt;/p&gt;

      </content><id>https://mirage.io/blog/mirage-entropy</id><title type="text">Organized chaos: managing randomness</title><updated>2015-07-22T00:00:00-00:00</updated><author><name>David Kaloper</name></author></entry><entry><link href="https://mirage.io/blog/mirage-seal" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Building a static website is one of the better-supported user stories for MirageOS, but it currently results in an HTTP-only site, with no capability for TLS.  Although there's been a great TLS stack &lt;a href=&quot;https://mirage.io/blog/introducing-ocaml-tls&quot;&gt;available for a while now&lt;/a&gt;, it was a bit fiddly to assemble the pieces of TLS, Cohttp, and the MirageOS frontend tool in order to construct an HTTPS unikernel.  With MirageOS 2.5, that's changed!  Let's celebrate by building an HTTPS-serving unikernel of our very own.&lt;/p&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;h2&gt;Get a Certificate&lt;/h2&gt;
&lt;p&gt;To serve HTTPS, we'll need a certificate to present to clients (i.e., browsers) for authentication and establishing asymmetric encryption. For just testing things out, or when it's okay to cause a big scary warning message to appear for anyone browsing a site, we can just use a self-signed certificate.  Alternatively, the domain name registrar or hosting provider for a site will be happy to sell (or in some cases, give!) a certificate -- both options are explained in more detail below.&lt;/p&gt;
&lt;p&gt;Whichever option you choose, you'll need to install &lt;code&gt;certify&lt;/code&gt; to get started (assuming you'd like to avoid using &lt;code&gt;openssl&lt;/code&gt;).  To do so, pin the package in opam:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opam pin add certify https://github.com/yomimono/ocaml-certify.git
opam install certify
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Self-Signed&lt;/h3&gt;
&lt;p&gt;It's not strictly necessary to get someone else to sign a certificate. We can create and sign our own certificates with the &lt;code&gt;selfsign&lt;/code&gt; command-line tool.  The following invocation will create a secret key in &lt;code&gt;secrets/server.key&lt;/code&gt; and a public certificate for the domain &lt;code&gt;totallyradhttpsunikernel.xyz&lt;/code&gt; in &lt;code&gt;secrets/server.pem&lt;/code&gt;.  The certificate will be valid for 365 days, so if you choose this option, it's a good idea set a calendar reminder to renew it if the service will be up for longer than that.  The key generated will be a 2048-bit RSA key, although it's possible to create certificates valid for different lengths -- check &lt;code&gt;selfsign --help&lt;/code&gt; for more information.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;selfsign -c secrets/server.pem -k secrets/server.key -d 365 totallyradhttpsunikernel.example
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now use this key and certificate with &lt;code&gt;mirage-seal&lt;/code&gt;!  See &amp;quot;Packaging Up an HTTPS Site with Mirage-Seal&amp;quot; below.&lt;/p&gt;
&lt;h3&gt;Signed by Someone Else&lt;/h3&gt;
&lt;p&gt;Although there are many entities that can sign a certificate with different processes, most have the following in common:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;you generate a request to have a certificate made for a domain
&lt;/li&gt;
&lt;li&gt;the signing entity requests that you prove your ownership over that domain
&lt;/li&gt;
&lt;li&gt;once verified, the signing entity generates a certificate for you
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Generating a Certificate-Signing Request&lt;/h4&gt;
&lt;p&gt;No matter whom we ask to sign a certificate, we'll need to generate a certificate signing request so the signer knows what to create.  The &lt;code&gt;csr&lt;/code&gt; command-line tool can do this.  The line below will generate a CSR (saved as server.csr) signed with a 2048-bit RSA key (which will be saved as server.key), for the organization &amp;quot;Rad Unikernel Construction, Ltd.&amp;quot; and the common name &amp;quot;totallyradhttpsunikernel.example&amp;quot;.  For more information on &lt;code&gt;csr&lt;/code&gt;, try &lt;code&gt;csr --help&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;csr -c server.csr -k server.key totallyradhttpsunikernel.example &amp;quot;Rad Unikernel Construction, Ltd.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;csr&lt;/code&gt; will generate a &lt;code&gt;server.csr&lt;/code&gt; that contains the certificate signing request for submission elsewhere.&lt;/p&gt;
&lt;h5&gt;Example: Gandi.net&lt;/h5&gt;
&lt;p&gt;My domain is registered through the popular registrar Gandi.net, who happen to give a free TLS certificate for one year with domain registration, so I elected to have them sign a certificate for me (Gandi did not pay a promotional consideration for this mention).  Most of this process is managed through their web GUI and a fairly large chunk is automatically handled behind the scenes.  Here's how you can do it too:&lt;/p&gt;
&lt;p&gt;Log in to the web interface available through the registrar's website.  You can start the certificate signing process from the &amp;quot;services&amp;quot; tab, which exposes an &amp;quot;SSL&amp;quot; subtab.  Click that (Gandi doesn't need to know that we intend only to support TLS, not SSL).  Hit the &amp;quot;Get an SSL Certificate&amp;quot; button.  Standard SSL is fine.  Even if you're entitled to a free certificate, it will appear that you need to pay here; however at checkout, the total amount due will be 0 in your preferred currency.  Ask for a single address and, if you want to pay nothing, a valid period of 1 year.&lt;/p&gt;
&lt;p&gt;Copy the content of the certificate-signing request you generated earlier and paste it into the web form.  Gandi will also ask you to identify your TLS stack; unfortunately &lt;code&gt;ocaml-tls&lt;/code&gt; isn't in the drop-down menu, so choose OTHER (and perhaps send them a nice note asking them to add the hottest TLS stack on the block to their list).  Click &amp;quot;submit&amp;quot; and click through the order form.&lt;/p&gt;
&lt;p&gt;If you're buying a certificate for a domain you have registered through Gandi (via the registered account), the rest of the process is pretty automatic.  You should shortly receive an e-mail with a subject like &amp;quot;Procedure for the validation of your Standard SSL certificate&amp;quot;, which explains the process in more detail, but really all you need to do is wait a while (about 30 minutes, for me).  After the certificate has been generated, Gandi will notify you by e-mail, and you can download your certificate from the SSL management screen.  Click the magnifying glass next to the name of the domain for which you generated the cert to do so.&lt;/p&gt;
&lt;p&gt;Once you've downloaded your certificate, you may also wish to append the &lt;a href=&quot;https://en.wikipedia.org/wiki/Intermediate_certificate_authorities&quot;&gt;intermediate certificates&lt;/a&gt;.  Here's a help page on &lt;a href=&quot;https://wiki.gandi.net/en/ssl/intermediate&quot;&gt;gathering intermediate certificates&lt;/a&gt;.  Equipped with the intermediate certificates, append them to the signed certificate downloaded for your site to provide a full certificate chain:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat signed_cert.pem intermediate_certs.pem &amp;gt; server.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Example: StartSSL.com&lt;/h5&gt;
&lt;p&gt;Another free TLS certificate provider is &lt;a href=&quot;https://www.startssl.com&quot;&gt;StartSSL&lt;/a&gt;.  During online registration, StartSSL will generate a TLS client certificate for you.  This is used for authentication of yourself towards their service.&lt;/p&gt;
&lt;p&gt;You need to validate that you own the domain you want to request a certificate for.  This is done via the &amp;quot;Validations Wizard&amp;quot;, which lets you choose to validate a domain via &amp;quot;Domain Name Validation&amp;quot;.  There you enter your domain name, and receive an eMail with a token which you have to enter into the web interface.&lt;/p&gt;
&lt;p&gt;Once done, run &lt;code&gt;csr&lt;/code&gt; to create a key and a certificate signing request.  Go to the &amp;quot;Certificates Wizard&amp;quot;, select &amp;quot;Web Server SSL/TLS Certificate&amp;quot;, skip the generation of the private key (you already generated one with &lt;code&gt;csr&lt;/code&gt;), copy and paste your certificate signing request (only the public key of that CSR is used, everything else is ignored), select a domain name, and immediately receive your certificate.&lt;/p&gt;
&lt;p&gt;Make sure to also download their intermediate CA certificate, and append them:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat intermediate.pem cert.pem &amp;gt; server.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Packaging Up an HTTPS Site with Mirage-Seal&lt;/h2&gt;
&lt;p&gt;Equipped with a private key and a certificate, let's make an HTTPS unikernel!  First, use &lt;code&gt;opam&lt;/code&gt; to install &lt;code&gt;mirage-seal&lt;/code&gt;.  If &lt;code&gt;opam&lt;/code&gt; or other MirageOS tooling aren't set up yet, check out the &lt;a href=&quot;https://mirage.io/docs/install&quot;&gt;instructions for getting started&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opam install mirage-seal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mirage-seal&lt;/code&gt; has a few required arguments.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--data&lt;/code&gt;: one directory containing all the content that should be served by the unikernel.  Candidates for such a directory are the top-level output directory of a static site generator (such as &lt;code&gt;public&lt;/code&gt; for octopress), the &lt;code&gt;DocumentRoot&lt;/code&gt; of an Apache configuration, or the &lt;code&gt;root&lt;/code&gt; of an nginx configuration.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--keys&lt;/code&gt;: one directory containing the certificate (&lt;code&gt;server.pem&lt;/code&gt;) and key (&lt;code&gt;server.key&lt;/code&gt;) for the site.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are also a number of configurable parameters for IP settings.  By default, &lt;code&gt;mirage-seal&lt;/code&gt; will use DHCP to configure the network at boot.  To set static IP information, use the &lt;code&gt;--ip&lt;/code&gt;, &lt;code&gt;--nm&lt;/code&gt;, and &lt;code&gt;--gw&lt;/code&gt; arguments.&lt;/p&gt;
&lt;p&gt;You'll find more thorough documentation by looking at &lt;code&gt;mirage-seal --help&lt;/code&gt; or &lt;a href=&quot;https://github.com/mirage/mirage-seal/blob/master/README.md&quot;&gt;mirage-seal's README file&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To build a Xen unikernel, select the Xen mode with &lt;code&gt;-t xen&lt;/code&gt;.  In full, for a unikernel that will configure its network via DHCP:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mirage-seal --data=/home/me/coolwebsite/public --keys=/home/me/coolwebsite/secrets -t xen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mirage-seal&lt;/code&gt; will then generate a unikernel &lt;code&gt;mir-seal.xen&lt;/code&gt; and a Xen configuration file &lt;code&gt;seal.xl&lt;/code&gt; in the current working directory.  To boot it and open the console (on a machine running Xen), invoke &lt;code&gt;xl create&lt;/code&gt; on the configuration file with the &lt;code&gt;-c&lt;/code&gt; option:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo xl create seal.xl -c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Via the console, we can see the sealed unikernel boot and obtain an IP through DHCP.  Congratulations -- you made a static site unikernel browsable over HTTPS!&lt;/p&gt;

      </content><id>https://mirage.io/blog/mirage-seal</id><title type="text">Easy HTTPS Unikernels with mirage-seal</title><updated>2015-07-07T00:00:00-00:00</updated><author><name>Mindy Preston</name></author></entry><entry><link href="https://mirage.io/blog/bitcoin-pinata-results" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;TL;DR: Nobody took our BTC.  Random people from the Internet even donated
into our BTC wallet.
We showed the feasibility of a
transparent self-service bounty.  In the style of Dijkstra: security
bounties can be a very effective way to show the presence of
vulnerabilities, but they are hopelessly inadequate for showing their
absence.&lt;/p&gt;
&lt;h4&gt;What are you talking about?&lt;/h4&gt;
&lt;p&gt;Earlier this year, we &lt;a href=&quot;https://mirage.io/blog/announcing-bitcoin-pinata&quot;&gt;released a Bitcoin Pi&amp;ntilde;ata&lt;/a&gt;.
The &lt;a href=&quot;http://ownme.ipredator.se&quot;&gt;Pi&amp;ntilde;ata&lt;/a&gt; was a security bounty
containing 10 BTC and it's been online since 10th February 2015.
Upon successful
mutual authentication, where the Pi&amp;ntilde;ata has only a single trust anchor, it sends the
private key to the Bitcoin address.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirleft/btc-pinata&quot;&gt;It is open source&lt;/a&gt;,
and exposes both the client and server side of
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;ocaml-tls&lt;/a&gt;, running as an 8.2MB
&lt;a href=&quot;https://mirage.io&quot;&gt;MirageOS&lt;/a&gt; unikernel.  You can see the &lt;a href=&quot;https://github.com/mirleft/btc-pinata/blob/master/opam-full.txt&quot;&gt;code manifest&lt;/a&gt; to find out which libraries are involved.  We put this online and invited people to attack it.&lt;/p&gt;
&lt;p&gt;Any approach was permitted in attacking the Pi&amp;ntilde;ata:
the host system, the MirageOS &lt;a href=&quot;https://github.com/mirage/mirage-tcpip&quot;&gt;TCP/IP
stack&lt;/a&gt;, our TLS,
X.509 and ASN.1 implementations, as well as the Pi&amp;ntilde;ata code.
A successful attacker could do whatever they want with the BTC, no
questions asked (though we would &lt;a href=&quot;https://blockchain.info/address/183XuXTTgnfYfKcHbJ4sZeF46a49Fnihdh&quot;&gt;notice the transaction&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The exposed server could even be short-circuited to the exposed
client: you could proxy a TLS connection in which the (encrypted!)
secret was transmitted via your machine.&lt;/p&gt;
&lt;p&gt;This post summarises what we've seen so far and what we've learned about attempts people have made to take the BTC.&lt;/p&gt;
&lt;h4&gt;Accesses&lt;/h4&gt;
&lt;p&gt;There were 50,000 unique IP addresses who accessed the website.
1000 unique IP addresses initiated more than 20,000 TLS
connections to the Pi&amp;ntilde;ata, trying to break it.  Cumulative numbers of
the HTTP and TLS accesses are shown in the diagram:&lt;/p&gt;
&lt;img src=&quot;https://mirage.io/graphics/pinata_access.png&quot; alt=&quot;Cumulative Pi&amp;ntilde;ata accesses&quot;/&gt;
&lt;p&gt;There were more than 9000 failing and 12000 successful TLS sessions,
comprised of short-circuits described earlier, and our own tests.&lt;/p&gt;
&lt;p&gt;No X.509 certificate was presented in 1200 of the failed TLS
connections.  Another 1000 failed due to invalid input as the first
bytes.  This includes attempts using telnet &amp;mdash; I'm looking at you,
xx.xxx.74.126 &lt;code&gt;please give key&lt;/code&gt; (on 10th February at 16:00) and
xx.xxx.166.143 &lt;code&gt;hi give me teh btcs&lt;/code&gt; (on 11th February at 05:57)!&lt;/p&gt;
&lt;h4&gt;We are not talking to everybody&lt;/h4&gt;
&lt;p&gt;Our implementation first parses the record version of a client hello,
and if it fails, an unknown record version is reported.  This happened
in 10% of all TLS connections (including the 1000 with invalid input in the
last section).&lt;/p&gt;
&lt;p&gt;Another big class, 6%, were attempted Heartbeat packets (popular due
to &lt;a href=&quot;https://en.wikipedia.org/wiki/Heartbleed&quot;&gt;Heartbleed&lt;/a&gt;), which we
do not implement.&lt;/p&gt;
&lt;p&gt;Recently, issues in the state machines of TLS implementations were
published in &lt;a href=&quot;http://smacktls.com&quot;&gt;smacktls&lt;/a&gt; (and &lt;a href=&quot;http://ccsinjection.lepidum.co.jp/&quot;&gt;CCS
injection&lt;/a&gt;).  3% of the Pi&amp;ntilde;ata connections
received an unexpected handshake record at some point, which the Pi&amp;ntilde;ata handled
correctly by shutting down the connection.&lt;/p&gt;
&lt;p&gt;In 2009, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security#Renegotiation_attack&quot;&gt;renegotiation
attack&lt;/a&gt;
on the TLS protocol was published, which allowed a person in the
middle to inject prefix bytes, because a renegotiated handshake was
not authenticated with data from the previous handshake.  OCaml-TLS
closes a connection if the &lt;a href=&quot;https://tools.ietf.org/html/rfc5746&quot;&gt;renegotiation
extension&lt;/a&gt; is not present, which
happened in 2% of the connections.
Another 2% did not propose a ciphersuite supported by OCaml-TLS; yet
another 2% tried to talk SSL version 3 with us, which we do not
implement (for &lt;a href=&quot;https://tools.ietf.org/html/rfc7568&quot;&gt;good reasons&lt;/a&gt;, such as
&lt;a href=&quot;https://www.us-cert.gov/ncas/alerts/TA14-290A&quot;&gt;POODLE&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In various other (old versions of) TLS implementations, these
connections would have been successful and insecure!&lt;/p&gt;
&lt;h4&gt;Attempts worth noting&lt;/h4&gt;
&lt;p&gt;Interesting failures were: 31 connections which sent too many or too
few bytes, leading to parse errors.&lt;/p&gt;
&lt;p&gt;TLS requires each communication partner who authenticates themselves to
present a certificate.  To prove ownership of the private key of the
certificate, a hash of the concatenated handshake records needs to be
signed and transmitted over the wire.  22 of our TLS traces had
invalid signatures.  Not verifying such signatures was the problem of Apple's famous &lt;a href=&quot;https://www.imperialviolet.org/2014/02/22/applebug.html&quot;&gt;goto
fail&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another 100 failure traces tested our X.509 validation:
The majority of these failures (58) sent us certificates which were not signed by our trust
anchor, such as &lt;code&gt;CN=hacker/emailAddress=hacker@hacker&lt;/code&gt; and &lt;code&gt;CN=Google Internal SNAX Authority&lt;/code&gt; and various Apple and Google IDs -- we're still trying to figure out what SNAX is, Systems Network Architecture maybe?&lt;/p&gt;
&lt;p&gt;Several certificates contained invalid X.509 extensions: we require
that a server certificate does not contain the &lt;code&gt;BasicConstraints = true&lt;/code&gt; extension, which marks this certificate as certificate
authority, allowing to sign other certificates.  While not explicitly
forbidden, best practices (e.g. from
&lt;a href=&quot;https://wiki.mozilla.org/SecurityEngineering/mozpkix-testing#Behavior_Changes&quot;&gt;Mozilla&lt;/a&gt;)
reject them.  Any sensible systems administrator would not accept a CA
as a server certificate.&lt;/p&gt;
&lt;p&gt;Several other certificates were self-signed or contained an invalid
signature: one certificate was our client certificate, but with a
different RSA public key, thus the signature on the certificate was
invalid; another one had a different RSA public key, and the signature
was zeroed out.&lt;/p&gt;
&lt;p&gt;Some certificates were not of X.509 version 3, or were expired.
Several certificate chains were not pairwise signed, a &lt;a href=&quot;https://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html&quot;&gt;common attack
vector&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Two traces contained certificate structures which our ASN.1 parser
rejected.&lt;/p&gt;
&lt;p&gt;Another two connections (both initiated by ourselves) threw an
exception which lead to &lt;a href=&quot;https://github.com/mirleft/btc-pinata/blob/master/logger.ml#L116&quot;&gt;shutdown of the connection&lt;/a&gt;: there
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/commit/80117871679d57dde8c8e3b73392024ef4b42c38&quot;&gt;was&lt;/a&gt;
an out-of-bounds access while parsing handshake records.  This did not
lead to arbitrary code execution.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;The BTC Pi&amp;ntilde;ata was the first transparent self-service bounty, and it
was a success: people showed interest in the topic; some even donated
BTC; we enjoyed setting it up and running it; we fixed a non-critical
out of bounds access in our implementation; a large fraction of our
stack has been covered by the recorded traces.&lt;/p&gt;
&lt;p&gt;There are several points to improve a future Pi&amp;ntilde;ata: attestation that the code
running is the open sourced code, attestation that the service owns
the private key (maybe by doing transactions or signatures with input
from any user).&lt;/p&gt;
&lt;p&gt;There are several applications using OCaml-TLS, using MirageOS as well
as Unix:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-seal&quot;&gt;mirage-seal&lt;/a&gt; compiles to
a unikernel container which serves a given directory over https;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hannesm/tlstunnel&quot;&gt;tlstunnel&lt;/a&gt; is a
(&lt;a href=&quot;https://github.com/bumptech/stud&quot;&gt;stud&lt;/a&gt; like) TLS proxy, forwarding
to a backend server;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hannesm/jackline&quot;&gt;jackline&lt;/a&gt; is a
(alpha version) terminal-based XMPP client;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-conduit&quot;&gt;conduit&lt;/a&gt; is an abstraction
over network connections -- to make it use OCaml-TLS, set
&lt;code&gt;CONDUIT_TLS=native&lt;/code&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Again, a big thank you to &lt;a href=&quot;https://ipredator.se&quot;&gt;IPredator&lt;/a&gt; for
hosting our BTC Pi&amp;ntilde;ata and lending us the BTC!&lt;/p&gt;

      </content><id>https://mirage.io/blog/bitcoin-pinata-results</id><title type="text">Reviewing the Bitcoin Pinata</title><updated>2015-06-29T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/why-ocaml-tls" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;TLS implementations have a history of security flaws, which are often the
result of implementation errors.  These security flaws stem from the
underlying challenges of interpreting ambiguous specifications, the
complexities of large APIs and code bases, and the use of unsafe programming
practices.&lt;/p&gt;
&lt;p&gt;Re-engineering security-critical software allows the opportunity to use modern
approaches to prevent these recurring issues. Creating &lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;the TLS stack in OCaml&lt;/a&gt;
offers a range of benefits, including:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Robust memory safety&lt;/strong&gt;: Lack of memory safety was the largest single source
of vulnerabilities in various TLS stacks throughout 2014, including
&lt;a href=&quot;http://heartbleed.com&quot;&gt;Heartbleed (CVE-2014-0160)&lt;/a&gt;. OCaml-TLS avoids this
class of issues entirely due to OCaml's automatic memory management, safety
guarantees and the use of a pure-functional programming style.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Improved certificate validation&lt;/strong&gt;: Implementation errors in other stacks
allowed validation to be skipped under certain conditions, leaving users
exposed (e.g.
&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0092&quot;&gt;CVE-2014-0092&lt;/a&gt;).
In our TLS stack, we return errors explicitly as values and handle all
possible variants. The OCaml toolchain and compile-time checks ensure that
this has taken place.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mitigation of state machine errors&lt;/strong&gt;: Errors such as
&lt;a href=&quot;https://gotofail.com&quot;&gt;Apple's GoTo Fail (CVE-2014-1266)&lt;/a&gt; involved code being
skipped and a default 'success' value being returned, even though signatures
were never verified. Our approach encodes the state machine explicitly, while
state transitions default to failure. The code structure also makes clear the
need to consider preconditions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Elimination of downgrade attacks&lt;/strong&gt;: Legacy requirements forced other TLS
stacks to incorporate weaker 'EXPORT' encryption ciphers. Despite the
environment changing, this code still exists and leads to attacks such as
&lt;a href=&quot;https://freakattack.com&quot;&gt;FREAK (CVE-2015-0204)&lt;/a&gt; and
&lt;a href=&quot;https://weakdh.org&quot;&gt;Logjam (CVE-2015-4000)&lt;/a&gt;. Our TLS server does not support
weaker EXPORT cipher suites so was never vulnerable to such attacks.
In addition our stack never supported SSLv3, which was known to be the cause of many vulnerabilities and is only now in the process of being deprecated (&lt;a href=&quot;https://tools.ietf.org/html/rfc7568&quot;&gt;RFC: 7568&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Greatly reduced TCB&lt;/strong&gt;: The size of the trusted computing base (TCB) of a
system, measured in lines of code, is a widely accepted approximation of the
size of its attack surface.  Our secure Bitcoin Pi&amp;ntilde;ata, a unikernel built
using our TLS stack, is less than 4% the size of an equivalent, traditional
stack (102 kloc as opposed to 2560 kloc).&lt;/p&gt;
&lt;p&gt;These are just some of the benefits of re-engineering critical software using
modern techniques.&lt;/p&gt;

      </content><id>https://mirage.io/blog/why-ocaml-tls</id><title type="text">Why OCaml-TLS?</title><updated>2015-06-26T00:00:00-00:00</updated><author><name>Amir Chaudhry</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage-25-release" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Today we're announcing the new release of MirageOS v2.5, which includes
first-class support for SSL/TLS in the MirageOS configuration language. We
introduced the pure OCaml implementation of
&lt;a href=&quot;https://mirage.io/blog/introducing-ocaml-tls&quot;&gt;transport layer security (TLS)&lt;/a&gt; last summer and have been working since
then to improve the integration and create a robust framework.  The recent
releases allow developers to easily build and deploy secure unikernel services
and we've also incorporated numerous bug-fixes and major stability
improvements (especially in the network stack).  The full list of changes is
available on the &lt;a href=&quot;https://mirage.io/releases&quot;&gt;releases&lt;/a&gt; page and the &lt;a href=&quot;https://mirage.io/wiki/breaking-changes&quot;&gt;breaking API changes&lt;/a&gt;
now have their own page.&lt;/p&gt;
&lt;p&gt;Over the coming week, we'll share more about the TLS stack by diving into the
results of the &lt;a href=&quot;https://mirage.io/blog/announcing-bitcoin-pinata&quot;&gt;Bitcoin Pi&amp;ntilde;ata&lt;/a&gt;, describing a new workflow for
building secure static sites, and discussing insights on entropy in
virtualised environments.&lt;/p&gt;
&lt;p&gt;In the rest of this post, we'll cover why OCaml-TLS matters (and link to some
tools), mention our new domain name, and mention our security advisory
process.&lt;/p&gt;
&lt;h3&gt;Why OCaml-TLS matters&lt;/h3&gt;
&lt;p&gt;The last year has seen a slew of security flaws, which are even reaching the
mainstream news.  This history of flaws are often the result of implementation
errors and stem from the underlying challenges of interpreting ambiguous
specifications, the complexities of large APIs and code bases, and the use of
unsafe programming practices.  Re-engineering security-critical software
allows the opportunity to use modern approaches to prevent these recurring
issues. In a &lt;a href=&quot;https://mirage.io/blog/why-ocaml-tls&quot;&gt;separate post&lt;/a&gt;, we cover some of the benefits of
re-engineering TLS in OCaml.&lt;/p&gt;
&lt;h4&gt;TLS Unix Tools&lt;/h4&gt;
&lt;p&gt;To make it even easier to start benefiting from OCaml-TLS, we've also made a
collection of &lt;a href=&quot;https://mirage.io/wiki/tls-unix&quot;&gt;TLS unix tools&lt;/a&gt;.  These are designed to make it
really easy to use a good portion of the stack without having to use Xen. For
example, Unix &lt;code&gt;tlstunnel&lt;/code&gt; is being used on &lt;a href=&quot;https://realworldocaml.org&quot;&gt;https://realworldocaml.org&lt;/a&gt;. If
you have &lt;code&gt;stunnel&lt;/code&gt; or &lt;code&gt;stud&lt;/code&gt; in use somewhere, then replacing it with the
&lt;code&gt;tlstunnel&lt;/code&gt; binary is an easy way to try things out.  Please do give this a go
and send us feedback!&lt;/p&gt;
&lt;h3&gt;openmirage.org -&amp;gt; mirage.io&lt;/h3&gt;
&lt;p&gt;We've also switched our domain over to &lt;strong&gt;&lt;a href=&quot;https://mirage.io&quot;&gt;https://mirage.io&lt;/a&gt;&lt;/strong&gt;, which is a
unikernel running the full stack. We've been discussing this transition for a
while on our &lt;a href=&quot;https://mirage.io/wiki/#Weekly-calls-and-release-notes&quot;&gt;fortnightly calls&lt;/a&gt; and have actually been running this
unikernel in parallel for a while. Setting things up this way has allowed us
to stress test things in the wild and we've made big improvements to the
networking stack as a result.&lt;/p&gt;
&lt;p&gt;We now have end-to-end deployments for our secure-site unikernels, which is
largely automated -- going from &lt;code&gt;git push&lt;/code&gt; all the way to live site. You can
get an idea of the workflows we have set up by looking over the following
links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://amirchaudhry.com/heroku-for-unikernels-pt1&quot;&gt;Automated unikernel deployment&lt;/a&gt; -- Description of the end-to-end flow for one of our sites.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-www-deployment&quot;&gt;mirage-www-deployment repo&lt;/a&gt; -- The repo from which we pull the site you're currently reading! You might find the scripts useful.
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Security disclosure process&lt;/h3&gt;
&lt;p&gt;Since we're incorporating more security features, it's important to consider
the process of disclosing issues to us.  Many bugs can be reported as usual on
our &lt;a href=&quot;https://github.com/mirage/mirage/issues&quot;&gt;issue tracker&lt;/a&gt; but if you think you've discovered a
&lt;strong&gt;security vulnerability&lt;/strong&gt;, the best way to inform us is described on a new
page at &lt;strong&gt;&lt;a href=&quot;https://mirage.io/security&quot;&gt;https://mirage.io/security&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Get started!&lt;/h3&gt;
&lt;p&gt;As usual, MirageOS v2.5 and the its ever-growing collection of
libraries is packaged with the &lt;a href=&quot;https://opam.ocaml.org&quot;&gt;OPAM&lt;/a&gt; package
manager, so look over the &lt;a href=&quot;https://mirage.io/wiki/install&quot;&gt;installation instructions&lt;/a&gt;
and run &lt;code&gt;opam install mirage&lt;/code&gt; to get the command-line
tool. To update from a previously installed version of MirageOS,
simply use the normal workflow to upgrade your packages by using &lt;code&gt;opam update -u&lt;/code&gt; (you should do this regularly to benefit from ongoing fixes).
If you're looking for inspiration, you can check out the examples on
&lt;a href=&quot;https://github.com/mirage/mirage-skeleton&quot;&gt;mirage-skeleton&lt;/a&gt; or ask on the &lt;a href=&quot;https://mirage.io/community&quot;&gt;mailing list&lt;/a&gt;. Please do be aware
that existing &lt;code&gt;config.ml&lt;/code&gt; files using
the &lt;code&gt;conduit&lt;/code&gt; and &lt;code&gt;http&lt;/code&gt; constructors might need to be updated -- we've made a
page of &lt;a href=&quot;https://mirage.io/wiki/breaking-changes&quot;&gt;backward incompatible changes&lt;/a&gt; to explain what you need to
do.&lt;/p&gt;
&lt;p&gt;We would love to hear your feedback on this release, either on our
&lt;a href=&quot;https://github.com/mirage/mirage/issues&quot;&gt;issue tracker&lt;/a&gt; or &lt;a href=&quot;https://mirage.io/community&quot;&gt;our mailing lists&lt;/a&gt;!&lt;/p&gt;

      </content><id>https://mirage.io/blog/announcing-mirage-25-release</id><title type="text">MirageOS v2.5 with full TLS support</title><updated>2015-06-26T00:00:00-00:00</updated><author><name>Amir Chaudhry</name></author></entry><entry><link href="https://mirage.io/blog/announcing-bitcoin-pinata" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;a href=&quot;http://ownme.ipredator.se/&quot;&gt;&lt;img src=&quot;http://amirchaudhry.com/images/btc-pinata/btc-pinata.png&quot; style=&quot;float:right; padding: 10px&quot; width=&quot;300px&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Last summer we announced the beta release of a clean-slate implementation of
TLS in pure OCaml, alongside a &lt;a href=&quot;https://mirage.io/blog/introducing-ocaml-tls&quot;&gt;series of blog posts&lt;/a&gt; that described
the libraries and the thinking behind them.  It took two hackers six months
&amp;mdash; starting on &lt;a href=&quot;https://goo.gl/maps/GpcQs&quot;&gt;the beach&lt;/a&gt; &amp;mdash;  to get the stack to that point and
their &lt;a href=&quot;https://tls.nqsb.io&quot;&gt;demo server&lt;/a&gt; is still going strong. Since then, the team has
continued working and recently &lt;a href=&quot;http://media.ccc.de/browse/congress/2014/31c3_-_6443_-_en_-_saal_2_-_201412271245_-_trustworthy_secure_modular_operating_system_engineering_-_hannes_-_david_kaloper.html#video&quot;&gt;presented&lt;/a&gt; at the 31st Chaos
Communication Congress.&lt;/p&gt;
&lt;p&gt;The authors are putting their stack to the test again and this time they've
built a &lt;strong&gt;&lt;a href=&quot;http://ownme.ipredator.se&quot;&gt;Bitcoin Pi&amp;ntilde;ata&lt;/a&gt;&lt;/strong&gt;! Essentially, they've hidden a
private key to a bitcoin address within a Unikernel running on Xen. If you're
able to smash your way in, then you get to keep the spoils.&lt;/p&gt;
&lt;p&gt;There's more context around this in my &lt;a href=&quot;http://amirchaudhry.com/bitcoin-pinata&quot;&gt;Pi&amp;ntilde;ata post&lt;/a&gt; and you can see
the details on the &lt;a href=&quot;http://ownme.ipredator.se&quot;&gt;site itself&lt;/a&gt;. Remember that the codebase is
&lt;a href=&quot;https://github.com/mirleft/&quot;&gt;all open&lt;/a&gt; (as well as &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues?q=label:%22security%20concern%22%20&quot;&gt;issues&lt;/a&gt;) so there's nothing to
reverse engineer. Have fun!&lt;/p&gt;

      </content><id>https://mirage.io/blog/announcing-bitcoin-pinata</id><title type="text">Smash the Bitcoin Pinata for fun and profit!</title><updated>2015-02-10T00:00:00-00:00</updated><author><name>Amir Chaudhry</name></author></entry><entry><link href="https://mirage.io/blog/2014-in-review" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;small&gt;
  This work funded in part by the EU FP7 User-Centric Networking project, Grant
  No. 611001.
&lt;/small&gt;
&lt;p&gt;An action-packed year has flown by for MirageOS, and it's time for a little recap of what's been happening and the plans for the new year.
We announced &lt;a href=&quot;https://mirage.io/blog/announcing-mirage10&quot;&gt;MirageOS 1.0&lt;/a&gt; just over a year ago, and 2014 also saw a major &lt;a href=&quot;https://mirage.io/blog/announcing-mirage-20-release&quot;&gt;2.0 summer release&lt;/a&gt; and the growth of a developer community that have been building support for IPv6, Transport Layer Security, on-demand spawning, profiling and much more.  There have been 205 individual library &lt;a href=&quot;https://mirage.io/releases&quot;&gt;releases&lt;/a&gt;, 25 &lt;a href=&quot;http://decks.openmirage.org&quot;&gt;presentations&lt;/a&gt;, and lots of &lt;a href=&quot;https://mirage.io/links&quot;&gt;online chatter&lt;/a&gt; through the year, so here follows a summary of our major activities recently.&lt;/p&gt;
&lt;h3&gt;Clean-Slate Transport Layer Security&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://media.ccc.de/browse/congress/2014/31c3_-_6443_-_en_-_saal_2_-_201412271245_-_trustworthy_secure_modular_operating_system_engineering_-_hannes_-_david_kaloper.html#video&quot;&gt;&lt;img src=&quot;https://mirage.io/graphics/tls-31c3.png&quot; style=&quot;float:right; padding: 5px&quot; width=&quot;300px&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;David Kaloper and Hannes Mehnert started 2014 with getting interested in writing a &lt;a href=&quot;https://ocaml.org/meetings/ocaml/2014/ocaml2014_4.pdf&quot;&gt;safer and cleaner TLS stack&lt;/a&gt; in OCaml, and ended the year with a complete demonstration and talk last week in &lt;a href=&quot;http://media.ccc.de/browse/congress/2014/31c3_-_6443_-_en_-_saal_2_-_201412271245_-_trustworthy_secure_modular_operating_system_engineering_-_hannes_-_david_kaloper.html#video&quot;&gt;31C3&lt;/a&gt;, the premier hacker conference!  Their blog posts over the summer remain an excellent introduction to the new stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-ocaml-tls&quot;&gt;OCaml-TLS: Introducing transport layer security (TLS) in pure OCaml&lt;/a&gt;&amp;quot;&lt;/em&gt; presents the motivation and architecture behind our clean-slate implementation of the protocol.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-nocrypto&quot;&gt;OCaml-TLS: building the nocrypto library core&lt;/a&gt;&amp;quot;&lt;/em&gt; talks about the cryptographic primitives that form the heart of TLS confidentiality guarantees, and how they expose safe interfaces to the rest of the stack.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-x509&quot;&gt;OCaml-TLS: adventures in X.509 certificate parsing and validation&lt;/a&gt;&amp;quot;&lt;/em&gt; explains how authentication and chain-of-trust verification is implemented in our stack.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-asn1&quot;&gt;OCaml-TLS: ASN.1 and notation embedding&lt;/a&gt;&amp;quot;&lt;/em&gt; introduces the libraries needed for handling ASN.1 grammars, the wire representation of messages in TLS.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation&quot;&gt;OCaml-TLS: the protocol implementation and mitigations to known attacks&lt;/a&gt;&amp;quot;&lt;/em&gt; concludes with the implementation of the core TLS protocol logic itself.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By summer, the stack was complete enough to connect to the majority of TLS 1.0+ sites on the Internet, and work progressed to integration with the remainder of the MirageOS libraries.  By November, the &lt;a href=&quot;https://github.com/mirage/ocaml-conduit&quot;&gt;Conduit&lt;/a&gt; network library had Unix support for both the &lt;a href=&quot;https://github.com/savonet/ocaml-ssl&quot;&gt;OpenSSL/Lwt&lt;/a&gt; bindings and the pure OCaml stack, with the ability to dynamically select them.  You can now deploy and test the pure OCaml TLS stack on a webserver simply by:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opam install lwt tls cohttp
export CONDUIT_TLS=native
cohttp-server-lwt -c &amp;lt;certfile&amp;gt; -p &amp;lt;port&amp;gt; &amp;lt;directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will spin up an HTTPS server that serves the contents of &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; to you over TLS.
At the same time, we were also working on integrating the TLS stack into the Xen unikernel backend, so we could run completely standalone.  This required some surgery:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto&quot;&gt;nocrypto&lt;/a&gt; crypto core is written in C, so we had to improve support for linking in external C libraries.  Since the Xen unikernel is a single address-space custom kernel, we also need to be careful to compile it with the correct compilation flags or else risk &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/issues/80&quot;&gt;subtle bugs&lt;/a&gt;. Thomas Leonard completely rearranged the MirageOS compilation pipeline to support &lt;a href=&quot;https://github.com/mirage/mirage/pull/332&quot;&gt;separation compilation of C stubs&lt;/a&gt;, and we had the opportunity to remove lots of duplicated code within &lt;a href=&quot;https://github.com/mirage/mirage-platform&quot;&gt;mirage-platform&lt;/a&gt; as a result of this work.
&lt;/li&gt;
&lt;li&gt;Meanwhile, the problem of gathering entropy in a virtual machine reared its head.  We created a &lt;a href=&quot;https://github.com/mirage/mirage-entropy&quot;&gt;mirage-entropy&lt;/a&gt; device driver, and an &lt;a href=&quot;http://lists.xenproject.org/archives/html/mirageos-devel/2014-11/msg00146.html&quot;&gt;active discussion&lt;/a&gt; ensued about how best to gather reliable randomness from Xen.  &lt;a href=&quot;http://dave.recoil.org&quot;&gt;Dave Scott&lt;/a&gt; built the best solution -- the &lt;a href=&quot;https://github.com/mirage/xentropyd&quot;&gt;xenentropyd&lt;/a&gt; that proxies entropy from dom0 to a unikernel VM.
&lt;/li&gt;
&lt;li&gt;David Kaloper also ported the &lt;code&gt;nocrypto&lt;/code&gt; library to use the &lt;a href=&quot;https://github.com/ocamllabs/ocaml-ctypes&quot;&gt;OCaml-Ctypes&lt;/a&gt; library, which increases the safety of the C bindings significantly.  This is described in more detail in the &amp;quot;&lt;a href=&quot;https://mirage.io/blog/modular-foreign-function-bindings&quot;&gt;Modular foreign function bindings&lt;/a&gt;&amp;quot; blog post from the summer.  This forms the basis for allowing Xen unikernels to communicate with C code, and integration with the MirageOS toolchain will continue to improve next year.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can see &lt;a href=&quot;http://media.ccc.de/browse/congress/2014/31c3_-_6443_-_en_-_saal_2_-_201412271245_-_trustworthy_secure_modular_operating_system_engineering_-_hannes_-_david_kaloper.html#video&quot;&gt;Hannes and David present OCaml-TLS&lt;/a&gt; at CCC online.  It's been a real pleasure watching their work develop in the last 12 months with such precision and attention to detail!&lt;/p&gt;
&lt;h3&gt;HTTP and JavaScript&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://rgrinberg.com/&quot;&gt;Rudi Grinberg&lt;/a&gt; got sufficiently irked with the poor state of documentation for the &lt;a href=&quot;https://github.com/mirage/ocaml-cohttp&quot;&gt;CoHTTP&lt;/a&gt; library that he began gently contributing fixes towards the end of 2013, and rapidly became one of the maintainers.  He also began improving the ecosystem around the web stack by building a HTTP routing layer, described in his blog posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;a href=&quot;http://rgrinberg.com/blog/2014/12/13/primitive-type-safe-routing/&quot;&gt;Type Safe Routing - Baby Steps&lt;/a&gt;&lt;/em&gt;: type-safe routing of URLs to avoid dangling links
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href=&quot;http://rgrinberg.com/blog/2014/04/04/introducing-opium/&quot;&gt;Introducing Opium&lt;/a&gt;&lt;/em&gt;: middleware for REST services
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href=&quot;http://rgrinberg.com/blog/2014/04/11/middleware-intro/&quot;&gt;Middleware in Opium&lt;/a&gt;&lt;/em&gt;: a walkthrough the Opium HTTP middleware model
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href=&quot;http://rgrinberg.com/blog/2014/05/23/humane-re-intro/&quot;&gt;Introducing Humane-Re&lt;/a&gt;&lt;/em&gt;: more friendly regular expression interfaces
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Meanwhile, &lt;a href=&quot;http://www.ujamjar.com/&quot;&gt;Andy Ray&lt;/a&gt; started developing &lt;a href=&quot;http://www.ujamjar.com/hardcaml/&quot;&gt;HardCaml&lt;/a&gt; (a register transfer level hardware design system) in OCaml, and built the &lt;a href=&quot;https://andrewray.github.io/iocamljs/&quot;&gt;iocamljs&lt;/a&gt; interactive browser notebook.  This uses &lt;a href=&quot;http://ocsigen.org/js_of_ocaml&quot;&gt;js_of_ocaml&lt;/a&gt; to port the &lt;em&gt;entire&lt;/em&gt; OCaml compilation toolstack to JavaScript, including &lt;code&gt;ocamlfind&lt;/code&gt;, Lwt threading and dynamic loading support.  The results are browsable &lt;a href=&quot;https://andrewray.github.io/iocamljs/&quot;&gt;online&lt;/a&gt;, and it is now easy to generate a JavaScript-driven interactive page for many MirageOS libraries.&lt;/p&gt;
&lt;p&gt;An interesting side effect of Andy's patches were the addition of a &lt;a href=&quot;https://github.com/mirage/ocaml-cohttp/pull/172&quot;&gt;JavaScript port&lt;/a&gt; to the CoHTTP library.  For those not familiar with the innards, CoHTTP uses the &lt;a href=&quot;https://realworldocaml.org/v1/en/html/functors.html&quot;&gt;OCaml module system&lt;/a&gt; to build a very portable HTTP implementation that can make mapped to different I/O models (Lwt or Async cooperative threading or POSIX blocking I/O), and to different operating systems (e.g. Unix or MirageOS).  The JavaScript support mapped the high-level modules in CoHTTP to the XMLHTTPRequest native to JavaScript, allowing the same OCaml HTTP client code to run efficiently on Unix, Windows and now an IOCamlJS browser instance.&lt;/p&gt;
&lt;p&gt;MirageOS uses a number of libraries developed by the &lt;a href=&quot;http://ocsigen.org&quot;&gt;Ocsigen&lt;/a&gt; team at &lt;a href=&quot;http://irill.org&quot;&gt;IRILL&lt;/a&gt; in Paris, and so I was thrilled to &lt;a href=&quot;https://www.irill.org/videos/oups-december-2014/MirageOS&quot;&gt;deliver a talk&lt;/a&gt; there in December.  Romain Calascibetta started integrating Ocsigen and MirageOS over the summer, and the inevitable plotting over beer in Paris lead &lt;a href=&quot;https://github.com/Drup&quot;&gt;Gabriel Radanne&lt;/a&gt; to kick off an effort to integrate the complete Ocsigen web stack into MirageOS. Head to &lt;a href=&quot;https://github.com/ocsigen/ocsigenserver/issues/54&quot;&gt;ocsigen/ocsigenserver#54&lt;/a&gt; if you're interested in seeing this happen in 2015!
I also expect the JavaScript and MirageOS integration to continue to improve in 2015, thanks to large industrial users such as &lt;a href=&quot;https://github.com/facebook&quot;&gt;Facebook&lt;/a&gt; adopting &lt;code&gt;js_of_ocaml&lt;/code&gt; in their open-source tools such as &lt;a href=&quot;https://github.com/facebook/hack&quot;&gt;Hack&lt;/a&gt; and &lt;a href=&quot;https://github.com/facebook/flow&quot;&gt;Flow&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;IPv6&lt;/h3&gt;
&lt;p&gt;We've wanted IPv6 support in MirageOS since its inception, and several people contributed to making this possible.  At the start of the year, &lt;a href=&quot;https://github.com/hhugo&quot;&gt;Hugo Heuzard&lt;/a&gt; and &lt;a href=&quot;https://github.com/dsheets&quot;&gt;David Sheets&lt;/a&gt; got &lt;a href=&quot;https://github.com/mirage/ocaml-ipaddr/pull/9&quot;&gt;IPv6 parsing support&lt;/a&gt; into the &lt;code&gt;ipaddr&lt;/code&gt; library (with me watching bemusedly at how insanely complex parsing is versus IPv4).&lt;/p&gt;
&lt;p&gt;Meanwhile, &lt;a href=&quot;https://www.dpmms.cam.ac.uk/~no263/&quot;&gt;Nicolas Ojeda Bar&lt;/a&gt; had been building OCaml networking libraries independently for some time, such as a &lt;a href=&quot;https://github.com/nojb/ocaml-imap&quot;&gt;IMAP client&lt;/a&gt;, &lt;a href=&quot;https://github.com/nojb/ocaml-maildir&quot;&gt;Maildir&lt;/a&gt; handler, and a &lt;a href=&quot;https://github.com/nojb/ocaml-bt&quot;&gt;Bittorrent&lt;/a&gt; client.  He became interested in the networking layer of MirageOS, and performed a &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/pull/70&quot;&gt;comprehensive cleanup&lt;/a&gt;  that resulted in a more modular stack that now supports both IPv4 and IPv6!&lt;/p&gt;
&lt;p&gt;The addition of IPv6 support also forced us to consider how to simplify the configuration frontend to MirageOS unikernels that was &lt;a href=&quot;https://mirage.io/blog/mirage-1.1-released&quot;&gt;originally written&lt;/a&gt; by Thomas Gazagnaire and &lt;a href=&quot;https://mirage.io/blog/intro-tcpip&quot;&gt;described here&lt;/a&gt; by Mindy Preston.
Nicolas has &lt;a href=&quot;http://lists.xenproject.org/archives/html/mirageos-devel/2014-12/msg00001.html&quot;&gt;proposed&lt;/a&gt; a declarative extension to the configuration that allows applications to extend the &lt;code&gt;mirage&lt;/code&gt; command-line more easily, thus unifying the &amp;quot;built-in&amp;quot; MirageOS compilation modes (such as choosing between Xen or Unix) and protocol-specific choices (such as configuring IPv4 and IPv6).&lt;/p&gt;
&lt;p&gt;The new approach opens up the possibility of writing more user-friendly configuration frontends that can render them as a text- or web-based selectors, which is really important as more real-world uses of MirageOS are being created.  It should be possible in 2015 to solve common problems such as web or DNS serving without having to write a single line of OCaml code.&lt;/p&gt;
&lt;h3&gt;Profiling&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://roscidus.com/blog/blog/2014/10/27/visualising-an-asynchronous-monad&quot;&gt;&lt;img src=&quot;http://roscidus.com/blog/images/mirage-profiling/block-reads-3-32.png&quot; style=&quot;float:right; padding: 5px&quot; width=&quot;300px&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;One of the benefits touted by our CACM article on &lt;a href=&quot;http://queue.acm.org/detail.cfm?id=2566628&quot;&gt;unikernels&lt;/a&gt; at the start of the year was the improved tooling from the static linking of an entire application stack with an operating system layer.
&lt;a href=&quot;http://roscidus.com&quot;&gt;Thomas Leonard&lt;/a&gt; joined the project this year after publishing a widely read &lt;a href=&quot;http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/&quot;&gt;blog series&lt;/a&gt; on his experiences from switching from Python to OCaml.
Aside from leading (and upstreaming to Xen) the port of &lt;a href=&quot;https://mirage.io/blog/introducing-xen-minios-arm&quot;&gt;MirageOS to ARM&lt;/a&gt;, he also explored how to add profiling throughout the unikernel stack.&lt;/p&gt;
&lt;p&gt;The support is now comprehensive and integrated into the MirageOS trees: the &lt;a href=&quot;http://ocsigen.org/lwt&quot;&gt;Lwt&lt;/a&gt; cooperative threading engine has hooks for thread switching, most of the core libraries register named events, traces are dumped into shared memory buffers in the &lt;a href=&quot;http://wiki.eclipse.org/Linux_Tools_Project/TMF/CTF_guide&quot;&gt;CTF&lt;/a&gt; file format used by the Linux trace toolkit, and there are JavaScript and GTK+ &lt;a href=&quot;https://github.com/talex5/mirage-trace-viewer&quot;&gt;GUI frontends&lt;/a&gt; that can parse them.&lt;/p&gt;
&lt;p&gt;You can find the latest instructions on &lt;a href=&quot;https://mirage.io/docs/profiling&quot;&gt;Tracing and Profiling&lt;/a&gt; on this website, and here are Thomas' original blog posts on the subject:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://roscidus.com/blog/blog/2014/08/15/optimising-the-unikernel/&quot;&gt;Optimising the Unikernel&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://roscidus.com/blog/blog/2014/10/27/visualising-an-asynchronous-monad/&quot;&gt;Visualising an Asynchronous Monad&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Irmin&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://gazagnaire.org&quot;&gt;Thomas Gazagnaire&lt;/a&gt; spent most of the year furiously hacking away at the storage layer in Irmin, which is a clean-slate storage stack that uses a Git-like branching model as the basis for distributed unikernel storage.  &lt;a href=&quot;https://github.com/mirage/irmin/releases/tag/0.9.0&quot;&gt;Irmin 0.9.0&lt;/a&gt; was released in December with efficiency improvements and a sufficiently portable set of dependencies to make JavaScript compilation practical.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-irmin&quot;&gt;Introducing Irmin: Git-like distributed, branchable storage&lt;/a&gt;&amp;quot;&lt;/em&gt;  describes the concepts and high-level architecture of the system.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-irmin-in-xenstore&quot;&gt;Using Irmin to add fault-tolerance to the Xenstore database&lt;/a&gt;&amp;quot;&lt;/em&gt; shows how Irmin is used in a real-world application: the security-critical Xen toolstack that manages hosts full of virtual machines (&lt;a href=&quot;https://www.youtube.com/watch?v=DSzvFwIVm5s&quot;&gt;video&lt;/a&gt;).
&lt;/li&gt;
&lt;li&gt;There have been several other early adopters of Irmin for their own projects (independent of MirageOS).  One of the most exciting is by &lt;a href=&quot;https://github.com/gregatcam&quot;&gt;Gregory Tsipenyuk&lt;/a&gt;, who has been developing a version-controlled &lt;a href=&quot;https://github.com/gregtatcam/imaplet-lwt&quot;&gt;Irmin-based IMAP server&lt;/a&gt; that offers a very different model for e-mail management.  Expect to see more of this in the new year!
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We also had the pleasure of Benjamin Farinier and Matthieu Journault join us as summer interns.  Both of them did a great job improving the internals of Irmin, and Benjamin's work on &lt;em&gt;&lt;a href=&quot;http://gazagnaire.org/pub/FGM15.pdf&quot;&gt;Mergeable Persistent Datastructures&lt;/a&gt;&lt;/em&gt; will be presented at JFLA 2015.&lt;/p&gt;
&lt;h3&gt;Jitsu&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://decks.openmirage.org/irill14-seminar#/&quot;&gt;&lt;img src=&quot;https://mirage.io/graphics/decks-on-arm.png&quot; style=&quot;float:right; padding: 5px&quot; width=&quot;250px&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.skjegstad.com/&quot;&gt;Magnus Skjegstad&lt;/a&gt; returned to Cambridge and got interested in the rapid dynamic provisioning of unikernels.  He built &lt;a href=&quot;https://github.com/MagnusS/jitsu&quot;&gt;Jitsu&lt;/a&gt;, a DNS server that spawns unikernels in response to DNS requests and boots them in real-time with no perceptible lag to the end user.  The longer term goal behind this is to enable a community cloud of ARM-based &lt;a href=&quot;http://cubieboard.org/&quot;&gt;Cubieboard2&lt;/a&gt; boards that serve user content without requiring centralised data centers, but with the ease-of-use of existing systems.&lt;/p&gt;
&lt;p&gt;Building Jitsu and hitting our goal of extremely low latency management of unikernels required a huge amount of effort from across the MirageOS team.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://dave.recoil.org&quot;&gt;Dave Scott&lt;/a&gt; and &lt;a href=&quot;http://jon.recoil.org&quot;&gt;Jon Ludlam&lt;/a&gt; (two of the Xen maintainers at Citrix) improved the Xen &lt;code&gt;xl&lt;/code&gt; toolstack to deserialise the VM startup chain to shave 100s of milliseconds off every operation.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://roscidus.com/blog/&quot;&gt;Thomas Leonard&lt;/a&gt; drove the removal of our forked &lt;a href=&quot;http://wiki.xen.org/wiki/Mini-OS&quot;&gt;Xen MiniOS&lt;/a&gt; with a library version that is being fed upstream (including ARM support).  This made the delta between Xen and MirageOS much smaller and therefore made reducing end-to-end latency tractable.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dsheets&quot;&gt;David Sheets&lt;/a&gt; built a test harness to boot unikernel services and measure their latency under very different conditions, including contrasting boot timer versus &lt;a href=&quot;http://docker.com&quot;&gt;Docker&lt;/a&gt; containers.  In many instances, we ended up booting faster than containers due to not touching disk at all with a standalone unikernel.  &lt;a href=&quot;http://www.cl.cam.ac.uk/~iml1/&quot;&gt;Ian Leslie&lt;/a&gt; built us some custom power measurement hardware that came in handy to figure out how to drive down the energy cost of unikernels running on ARM boards.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gazagnaire.org&quot;&gt;Thomas Gazagnaire&lt;/a&gt;, Balraj Singh, Magnus Skjegstad built the &lt;code&gt;synjitsu&lt;/code&gt; proxy server that intercepts and proxies TCP connections to mask the couple of 100 milliseconds during unikernel boot time, ensuring that no TCP connections ever require retransmission from the client.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dave.recoil.org&quot;&gt;Dave Scott&lt;/a&gt; and I built out the &lt;a href=&quot;https://github.com/mirage/&quot;&gt;vchan&lt;/a&gt; shared memory transport that supports low-latency communiction between unikernels and/or Unix processes.  This is rapidly heading into a Plan9-like model, with the additional twist of using Git instead of a flat filesystem hierarchy as its coordination basis.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://amirchaudhry.com/&quot;&gt;Amir Chaudhry&lt;/a&gt; and &lt;a href=&quot;http://mort.io&quot;&gt;Richard Mortier&lt;/a&gt; documented the Git-based (and eventually Irmin-based) workflow behind managing the unikernels themselves, so that they can easily be deployed to distance ARM devices simply by running &lt;code&gt;git pull&lt;/code&gt;.  You can read more about this in his &lt;a href=&quot;http://amirchaudhry.com/from-jekyll-to-unikernel-in-fifty-lines&quot;&gt;From Jekyll to Unikernels&lt;/a&gt; post.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of this work was hastily crammed into a &lt;a href=&quot;https://www.usenix.org/conference/nsdi15/call-for-papers&quot;&gt;USENIX NSDI 2015&lt;/a&gt; paper that got submitted at 4am on a bright autumn morning.  &lt;a href=&quot;https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-madhavapeddy.pdf&quot;&gt;Here is the published paper&lt;/a&gt;, and we're planning a blog post describing how you can deploy this infrastructure for yourself.&lt;/p&gt;
&lt;h3&gt;Community&lt;/h3&gt;
&lt;p&gt;All of the above work was only possible due to the vastly improved tooling and infrastructure around the project.  Our community manager Amir Chaudhry led the &lt;a href=&quot;https://mirage.io/docs/&quot;&gt;minuted&lt;/a&gt; calls every two weeks that tied the efforts together, and we established some &lt;a href=&quot;https://github.com/mirage/mirage-www/wiki/Pioneer-Projects&quot;&gt;pioneer projects&lt;/a&gt; for newcomers to tackle.&lt;/p&gt;
&lt;img src=&quot;https://mirage.io/graphics/opam-packages-20141231.png&quot; style=&quot;float:right; padding: 5px&quot; width=&quot;250px&quot;/&gt;
&lt;p&gt;The &lt;a href=&quot;https://opam.ocaml.org&quot;&gt;OPAM&lt;/a&gt; package manager continued to be the frontend for all MirageOS tools, with releases of libraries happening &lt;a href=&quot;https://mirage.io/releases&quot;&gt;regularly&lt;/a&gt;.  Because of the modular nature of MirageOS code, most of the libraries can also be used as normal Unix-based libraries, meaning that we aren't just limited to MirageOS users but can benefit from the entire OCaml community.  The graph to the right shows the growth of the total package database since the project started to give you a sense of how much activity there is.&lt;/p&gt;
&lt;p&gt;The major &lt;a href=&quot;http://opam.ocaml.org/blog/opam-1-2-0-release/&quot;&gt;OPAM 1.2&lt;/a&gt; also added a number of new features that made MirageOS code easier to develop, including a &lt;a href=&quot;http://opam.ocaml.org/blog/opam-1-2-pin/&quot;&gt;Git-based library pinning workflow&lt;/a&gt; that works superbly with GitHub, and &lt;a href=&quot;http://opam.ocaml.org/blog/opam-1-2-travisci/&quot;&gt;easier Travis integration&lt;/a&gt; for continuous integration.  &lt;a href=&quot;https://github.com/niksu&quot;&gt;Nik Sultana&lt;/a&gt; also improved the &lt;a href=&quot;https://github.com/mirage/is-mirage-broken/tree/master/logs&quot;&gt;is-mirage-broken&lt;/a&gt; to give us a cron-driven prod if a library update caused an end-to-end failure in building the MirageOS website or other self-hosted infrastructure.&lt;/p&gt;
&lt;p&gt;Our favourite &lt;a href=&quot;http://www.somerandomidiot.com&quot;&gt;random idiot&lt;/a&gt;, Mindy Preston, wrote up a superb blog series about her experiences in the spring of 2014 with moving her homepage to be hosted on MirageOS.  This was followed up by &lt;a href=&quot;http://roscidus.com/blog/blog/2014/07/28/my-first-unikernel/&quot;&gt;Thomas Leonard&lt;/a&gt;, &lt;a href=&quot;http://philtomson.github.io/blog/2014/09/10/some-notes-on-building-and-running-mirage-unikernels-on-cubieboard2/&quot;&gt;Phil Tomson&lt;/a&gt;, &lt;a href=&quot;https://github.com/iw/mirage-jekyll&quot;&gt;Ian Wilkinson&lt;/a&gt;, &lt;a href=&quot;http://ocaml.is-awesome.net/2014/11/building-a-blog-with-mirage-os&quot;&gt;Toby Moore&lt;/a&gt;, and many others that we've tried to record in our &lt;a href=&quot;https://mirage.io/links/&quot;&gt;link log&lt;/a&gt;.  We really appreciate the hundreds of bug reports filed by users and folk trying out MirageOS; by taking the trouble to do this, you've  helped us refine and polish the frontend.  One challenge for 2015 that we could use help on is to pull together many of these distributed blogged instructions and merge them back into the main documentation (get in touch if interested!).&lt;/p&gt;
&lt;p&gt;OCaml has come a long way in the last year in terms of tooling, and another task my research group &lt;a href=&quot;http://ocaml.io&quot;&gt;OCaml Labs&lt;/a&gt; works on at Cambridge is the development of the &lt;a href=&quot;https://ocaml.org/meetings/ocaml/2014/ocaml2014_7.pdf&quot;&gt;OCaml Platform&lt;/a&gt;.  I'll be blogging separately about our OCaml-specific activities in a few days, but all of this work has a direct impact on MirageOS itself since it lets us establish a local feedback loop between MirageOS and OCaml developers to rapidly iterate on large-scale development.  The regular &lt;a href=&quot;http://ocamllabs.github.io/compiler-hacking/&quot;&gt;OCaml compiler hacking sessions&lt;/a&gt; organised by Jeremy Yallop and Leo White have been a great success this year, with a wide variety of people from academic (Cambridge, London universities and Microsoft Research) and industrial (Jane Street, Citrix and Facebook among others) and locally interested folk.
One very important project that has had a lot of work put into it in 2014 (but isn't quite ready for a public release yet) is &lt;a href=&quot;https://github.com/samoht/assemblage&quot;&gt;Assemblage&lt;/a&gt;, which will remove much of the boilerplate currently needed to build and release an OCaml library to OPAM.&lt;/p&gt;
&lt;p&gt;We also had a great time working with open-source summer programs. Thanks to the Xen Foundation and GNOME for their support here, and we hope to do this again next summer!  The roundup posts were:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;a href=&quot;http://www.somerandomidiot.com/blog/2014/08/22/opw-fin/&quot;&gt;OPW FIN&lt;/a&gt;&lt;/em&gt; by Mindy Preston: on of her &lt;a href=&quot;http://gnome.org/opw/&quot;&gt;FOSS Outreach Program&lt;/a&gt; work.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href=&quot;http://1000hippos.wordpress.com/&quot;&gt;Amazon Adventures&lt;/a&gt;&lt;/em&gt; by Jyotsna Prakash: on her &lt;a href=&quot;https://developers.google.com/open-source/soc/?csw=1&quot;&gt;Google Summer of Code&lt;/a&gt; 2014 efforts on EC2 bindings.
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Upcoming features&lt;/h3&gt;
&lt;p&gt;So what's coming up for our unikernels in 2015?  Our focus heading into the new year is very much on improving the ease-of-use and deployability of MirageOS and fleshing out the feature set for the early adopters such as the &lt;a href=&quot;https://github.com/xapi-project&quot;&gt;XAPI&lt;/a&gt; project, &lt;a href=&quot;http://events.linuxfoundation.org/sites/events/files/slides/XenStore_MAC_XenSummit_2014.pdf&quot;&gt;Galois&lt;/a&gt;, and the &lt;a href=&quot;http://nymote.org&quot;&gt;Nymote&lt;/a&gt; personal data project.  Here are some of the highlights:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Dust Clouds&lt;/strong&gt;: The work on Jitsu is leading to the construction of what we term &amp;quot;&lt;a href=&quot;http://anil.recoil.org/papers/2010-iswp-dustclouds.pdf&quot;&gt;dust clouds&lt;/a&gt;&amp;quot;: on-demand scaling of unikernel services within milliseconds of requests coming in, terminated right beside the user on local ARM devices.  The model supports existing clouds as well, and so we are improving support for cloud APIs such via Jyotsna Prakash's &lt;a href=&quot;https://github.com/moonlightdrive/ocaml-ec2&quot;&gt;EC2&lt;/a&gt; bindings, &lt;a href=&quot;https://github.com/djs55/xe-unikernel-upload&quot;&gt;XenAPI&lt;/a&gt;, and (volunteers needed) OpenStack support.  If you're interested in tracking this work, head over to the &lt;a href=&quot;http://nymote.org&quot;&gt;Nymote&lt;/a&gt; site for updates.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Portability&lt;/strong&gt;: Beyond Xen, there are several efforts afoot to port MirageOS to bare metal targets.  One promising effort is to use &lt;a href=&quot;http://rumpkernel.org&quot;&gt;Rump Kernels&lt;/a&gt; as the boot infrastructure and MirageOS as the application stack.  We hope to have a Raspberry Pi and other ARM targets fairly soon.  Meanwhile at the end of the spectrum is mobile computing, which was part of the original &lt;a href=&quot;http://anil.recoil.org/papers/2010-bcs-visions.pdf&quot;&gt;multiscale&lt;/a&gt; vision for starting the project.  The JavaScript, iOS and Android ports are all progressing (mainly thanks to community contributions around OCaml support for this space, such as Jeff Psellos' hard work on &lt;a href=&quot;http://psellos.com/ocaml/&quot;&gt;OCaml-IOS&lt;/a&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Protocol Development&lt;/strong&gt;: There are a huge number of protocols being developed independently, and more are always welcome.  &lt;a href=&quot;https://github.com/infidel&quot;&gt;Luke Dunstan&lt;/a&gt; is hacking on &lt;a href=&quot;https://github.com/mirage/ocaml-dns/pull/35#discussion_r22388447&quot;&gt;multicast DNS&lt;/a&gt; support, we have an IMAP &lt;a href=&quot;https://github.com/nojb/ocaml-imap&quot;&gt;client&lt;/a&gt; and &lt;a href=&quot;https://github.com/gregtatcam/imaplet-lwt/&quot;&gt;server&lt;/a&gt;, &lt;a href=&quot;https://github.com/dominicjprice&quot;&gt;Dominic Price&lt;/a&gt; has built a series of social network APIs for &lt;a href=&quot;https://github.com/dominicjprice/sociaml-facebook-api&quot;&gt;Facebook&lt;/a&gt; or &lt;a href=&quot;https://github.com/dominicjprice/sociaml-tumblr-api&quot;&gt;Tumblr&lt;/a&gt;, and &lt;a href=&quot;http://nottingham.ac.uk/horizon/people/masoud.koleini&quot;&gt;Masoud Koleini&lt;/a&gt; has been extending Haris Rotsos' work to achieve a line-rate and type-safe &lt;a href=&quot;https://github.com/mirage/ocaml-openflow&quot;&gt;OpenFlow&lt;/a&gt; switch and controller based on the &lt;a href=&quot;https://github.com/frenetic-lang&quot;&gt;Frenetic&lt;/a&gt; project.  Hannes is also developing &lt;a href=&quot;https://github.com/hannesm/jackline&quot;&gt;Jackline&lt;/a&gt;, which uses his MirageOS to assemble a trustworthy communication client.  &lt;a href=&quot;http://erratique.ch/software&quot;&gt;Daniel Buenzli&lt;/a&gt; also continues to release a growing set of high-quality, modular libraries that we depend on throughout MirageOS.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Storage&lt;/strong&gt;: All storage services from the unikernels will be Git-based (e.g. logging, command-and-control, key-value retrieval).  Expect to see Xen toolstack extensions that make this support seamless, so a single Linux VM will be able to control a large army of unikernels via persistent data structures.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Want to get involved?&lt;/h3&gt;
&lt;p&gt;This is a really fun time to get involved with unikernels and the MirageOS project. The year of 2014 has seen &lt;a href=&quot;https://mirage.io/links/&quot;&gt;lots of discussion&lt;/a&gt; about the potential of unikernels and we'll see some of the first big deployments involving them in 2015.  For the ones among you who wish to learn more, then check out the &lt;a href=&quot;https://github.com/mirage/mirage-www/wiki/Pioneer-Projects&quot;&gt;pioneer projects&lt;/a&gt;, watch out for &lt;a href=&quot;https://mirage.io/docs&quot;&gt;Amir's meeting notes&lt;/a&gt; and join the voice calls if you want a more interactive discussion, and engage on the &lt;a href=&quot;https://mirage.io/community/&quot;&gt;mailing lists&lt;/a&gt; with any questions you might have.&lt;/p&gt;
&lt;p&gt;For me personally, it's been a real privilege to spend the year working with and learning from the friendly, intelligent and diverse community that is springing up around the project.  The progression from experiment to reality has been a lot of work, but the unikernel dream is finally coming together rath[er nicely thanks to everyone's hard work and enthusiasm.  I'd also like to thank all of our &lt;a href=&quot;https://mirage.io/community/&quot;&gt;funding bodies&lt;/a&gt; and the &lt;a href=&quot;http://linuxfoundation.org&quot;&gt;Linux Foundation&lt;/a&gt; and the &lt;a href=&quot;http://xenproject.org&quot;&gt;Xen Project&lt;/a&gt; (especially Lars Kurth and Russell Pavlicek) for their support throughout the year that made all this work possible.  Happy new year, everyone!&lt;/p&gt;

      </content><id>https://mirage.io/blog/2014-in-review</id><title type="text">MirageOS 2014 review: IPv6, TLS, Irmin, Jitsu and community growth</title><updated>2014-12-31T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/introducing-xen-minios-arm" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Mirage has just gained the ability to compile unikernels for the Xen/arm32
platform, allowing Mirage guests to run under the Xen hypervisor on ARM
devices such as the &lt;a href=&quot;http://cubietruck.com/collections/frontpage/products/cubieboard2-allwinner-a20-arm-cortex-a7-dual-core-development-board&quot;&gt;Cubieboard 2&lt;/a&gt; and &lt;a href=&quot;http://cubietruck.com/collections/frontpage/products/cubietruck-cubieboard3-cortex-a7-dual-core-2gb-ram-8gb-flash-with-wifi-bt&quot;&gt;CubieTruck&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;The ARMv7 architecture introduced the (optional) Virtualization Extensions,
providing hardware support for running virtual machines on ARM devices, and
Xen's &lt;a href=&quot;http://www.xenproject.org/developers/teams/arm-hypervisor.html&quot;&gt;ARM Hypervisor&lt;/a&gt; uses this to support hardware accelerated
ARM guests.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.xen.org/wiki/Mini-OS&quot;&gt;Mini-OS&lt;/a&gt; is a tiny OS kernel designed specifically for running under Xen.
It provides code to initialise the CPU, display messages on the console,
allocate memory (malloc), and not much else. It is used as the low-level
core of Mirage's Xen implementation.&lt;/p&gt;
&lt;p&gt;Mirage v1 was built on an old version of Mini-OS which didn't support ARM.
For Mirage v2, we have added ARM support to the current Mini-OS (completing
Karim Allah Ahmed's &lt;a href=&quot;http://lists.xen.org/archives/html/xen-devel/2014-01/msg00249.html&quot;&gt;initial ARM port&lt;/a&gt;) and made Mirage depend
on it as an external library.
This means that Mirage will automatically gain support for other
architectures that get added later.
We are currently working with the Xen developers to get
&lt;a href=&quot;https://github.com/talex5/xen&quot;&gt;our Mini-OS fork&lt;/a&gt; upstreamed.&lt;/p&gt;
&lt;p&gt;In a similar way, we have replaced Mirage v1's bundled maths library with a
dependency on the external
&lt;a href=&quot;https://github.com/JuliaLang/openlibm&quot;&gt;OpenLibm&lt;/a&gt;, which we also extended
with ARM support (this was just a case of fixing the build system; the code
is from FreeBSD's libm, which already supported ARM).&lt;/p&gt;
&lt;p&gt;Mirage v1 also bundled &lt;a href=&quot;http://www.fefe.de/dietlibc/&quot;&gt;dietlibc&lt;/a&gt; to provide its standard C library.
A nice side-effect of this work came when we were trying to separate out the
dietlibc headers from the old Mini-OS headers in Mirage.
These had rather grown together over time and the work was proving
difficult, until we discovered that we no longer needed a libc at all, as
almost everything that used it had been replaced with pure OCaml versions!
The only exception was the &lt;code&gt;printf&lt;/code&gt; code for formatting floating point
numbers, which OCaml uses in its &lt;code&gt;printf&lt;/code&gt; implementation.
We replaced that by taking the small &lt;code&gt;fmt_fp&lt;/code&gt; function from
&lt;a href=&quot;http://www.musl-libc.org/&quot;&gt;musl libc&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here's the final diffstat of the changes to &lt;a href=&quot;https://github.com/mirage/mirage-platform&quot;&gt;mirage-platform&lt;/a&gt;
adding ARM support:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;778 files changed, 1949 insertions(+), 59689 deletions(-)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Trying it out&lt;/h3&gt;
&lt;p&gt;You'll need an ARM device with the Virtualization Extensions.
I've been testing using the Cubieboard 2 (and CubieTruck):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mirage.io/graphics/cubieboard2.jpg&quot; alt=&quot;Cubieboard2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The first step is to install Xen.
&lt;a href=&quot;https://mirage.io/docs/xen-on-cubieboard2&quot;&gt;Running Xen on the Cubieboard2&lt;/a&gt;
documents the manual installation process, but you can now also use
&lt;a href=&quot;https://github.com/mirage/xen-arm-builder&quot;&gt;mirage/xen-arm-builder&lt;/a&gt; to build
an SDcard image automatically.
Copy the image to the SDcard, connect the network cable and power, and the
board will boot Xen.&lt;/p&gt;
&lt;p&gt;Once booted you can ssh to Dom0, the privileged Linux domain used to manage
the system, &lt;a href=&quot;https://mirage.io/docs/install&quot;&gt;install Mirage&lt;/a&gt;, and build your unikernel just
as on x86.
Currently, you need to select the Git versions of some components.
The following commands will install the necessary versions if you're using
the xen-arm-builder image:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ opam init
$ opam install mirage-xen-minios
$ opam remote add mirage-dev https://github.com/mirage/mirage-dev
$ opam install mirage
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Technical details&lt;/h3&gt;
&lt;p&gt;One of the pleasures of unikernels is that you can comprehend the whole
system with relatively little effort, and
those wishing to understand, debug or contribute to the ARM support may find
the following technical sections interesting.
However, you don't need to know the details of the ARM port to use it,
as Mirage abstracts away the details of the underlying platform.&lt;/p&gt;
&lt;h4&gt;The boot process&lt;/h4&gt;
&lt;p&gt;An ARM Mirage unikernel uses the &lt;a href=&quot;http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html&quot;&gt;Linux zImage format&lt;/a&gt;, though it is
not actually compressed. Xen will allocate some RAM for the image and load
the kernel at the offset 0x8000 (32 KB).&lt;/p&gt;
&lt;p&gt;Execution begins in &lt;a href=&quot;https://github.com/talex5/xen/blob/cde4b7e14b0aeedcdc006b0622905b7af2665c77/extras/mini-os/arch/arm/arm32.S#L8&quot;&gt;arm32.S&lt;/a&gt;, with the &lt;code&gt;r2&lt;/code&gt; register pointing to a
&lt;a href=&quot;http://www.devicetree.org&quot;&gt;Flattened Device Tree (FDT)&lt;/a&gt; describing details of the virtual system.
This assembler code performs a few basic boot tasks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Configuring the MMU, which maps virtual addresses to physical addresses (see next section).
&lt;/li&gt;
&lt;li&gt;Turning on caching and branch prediction.
&lt;/li&gt;
&lt;li&gt;Setting up the exception vector table (this says how to handle interrupts and deal with various faults, such as reading from an invalid address).
&lt;/li&gt;
&lt;li&gt;Setting up the stack pointer and calling the C function &lt;code&gt;arch_init&lt;/code&gt;.
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/talex5/xen/blob/cde4b7e14b0aeedcdc006b0622905b7af2665c77/extras/mini-os/arch/arm/setup.c#L74&quot;&gt;arch_init&lt;/a&gt; makes some calls to the hypervisor to set up support for the console and interrupt controller, and then calls &lt;code&gt;start_kernel&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirage/mirage-platform/blob/b0a027d4486230ce6e1e8fd0e7354b17e9c388f5/xen/runtime/xencaml/main.c#L57&quot;&gt;start_kernel&lt;/a&gt; (in libxencaml) sets up a few more features (events, malloc, time-keeping and &lt;a href=&quot;http://wiki.xen.org/wiki/Grant_Table&quot;&gt;grant tables&lt;/a&gt;), then calls &lt;code&gt;caml_startup&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirage/mirage-platform/blob/b0a027d4486230ce6e1e8fd0e7354b17e9c388f5/xen/runtime/ocaml/startup.c#L202&quot;&gt;caml_startup&lt;/a&gt; (in libocaml) initialises the garbage collector and calls &lt;code&gt;caml_program&lt;/code&gt;, which is your application's &lt;code&gt;main.ml&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;The address space&lt;/h4&gt;
&lt;p&gt;With the Virtualization Extensions, there are two stages to converting a
virtual memory address (used by application code) to a physical address in
RAM.
The first stage is under the control of the guest VM, mapping the virtual
address to what the guest believes is the physical address (this address is
referred to as the &lt;em&gt;Intermediate Physical Address&lt;/em&gt; or &lt;em&gt;IPA&lt;/em&gt;).
The second stage, under the control of Xen, maps the IPA to the real
physical address.
The tables holding these mappings are called &lt;em&gt;translation tables&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Mirage's memory needs are simple: most of the RAM should be used for the
garbage-collected OCaml heap, with a few pages used for interacting with Xen
(these don't go on the OCaml heap because they must be page aligned and must
not move around).&lt;/p&gt;
&lt;p&gt;Xen does not commit to using a fixed address as the IPA of the RAM, but the
C code needs to run from a known location. To solve this problem the
assembler code in &lt;code&gt;arm32.S&lt;/code&gt; detects where it is running from and sets up a
virtual-to-physical mapping that will make it appear at the expected
location, by adding a fixed offset to each virtual address.
For example, on Xen/unstable, we configure the beginning of the virtual
address space to look like this (on Xen 4.4, the physical addresses would
start at 80000000 instead):&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Virtual address&lt;/th&gt;&lt;th&gt;Physical address (IPA)&lt;/th&gt;&lt;th&gt;Purpose&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;400000&lt;/td&gt;&lt;td&gt;40000000&lt;/td&gt;&lt;td&gt;Stack (16 KB)&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;404000&lt;/td&gt;&lt;td&gt;40004000&lt;/td&gt;&lt;td&gt;Translation tables (16 KB)&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;408000&lt;/td&gt;&lt;td&gt;40008000&lt;/td&gt;&lt;td&gt;Kernel image&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;The physical address is always at a fixed offset from the virtual address and
the addresses wrap around, so virtual address c0400000 maps back to physical
address 0 (in this example).&lt;/p&gt;
&lt;p&gt;The stack, which grows downwards, is placed at the start of RAM so that a
stack overflow will trigger a fault rather than overwriting other data.&lt;/p&gt;
&lt;p&gt;The 16 KB translation table is an array of 4-byte entries each mapping 1 MB
of the virtual address space, so the 16 KB table is able to map the entire
32-bit address space (4 GB). Each entry can either give the physical section
address directly (which is what we do) or point to a second-level table
mapping individual 4 KB pages. By using only the top-level table we reduce
possible delays due to &lt;a href=&quot;http://en.wikipedia.org/wiki/Translation_lookaside_buffer&quot;&gt;TLB misses&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After the kernel code comes the data (constants and global variables), then
the &lt;a href=&quot;http://en.wikipedia.org/wiki/.bss&quot;&gt;bss&lt;/a&gt; section (data that is initially
zero, and therefore doesn't need to be stored in the kernel image),
and finally the rest of the RAM, which is handed over to the malloc system.&lt;/p&gt;
&lt;h3&gt;Contact&lt;/h3&gt;
&lt;p&gt;The current version seems to be working well on Xen 4.4 (stable) and the 4.5
development version, but has only been lightly tested.
If you have any problems or questions, or get it working on other devices,
please &lt;a href=&quot;https://mirage.io/community/&quot;&gt;let us know&lt;/a&gt;!&lt;/p&gt;

      </content><id>https://mirage.io/blog/introducing-xen-minios-arm</id><title type="text">Building an ARMy of Xen unikernels</title><updated>2014-07-22T00:00:00-00:00</updated><author><name>Thomas Leonard</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage-20-release" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;small&gt;
  This work funded in part by the EU FP7 User-Centric Networking project, Grant
  No. 611001.
&lt;/small&gt;
&lt;p&gt;The &lt;a href=&quot;https://mirage.io/blog/announcing-mirage10&quot;&gt;first release&lt;/a&gt; of MirageOS back in December 2013 introduced the prototype
of the &lt;a href=&quot;http://queue.acm.org/detail.cfm?id=2566628&quot;&gt;unikernel concept&lt;/a&gt;, which realised the promise of a safe,
flexible mechanism to build highly optimized software stacks purpose-built for deployment in the public cloud (more &lt;a href=&quot;https://mirage.io/docs/overview-of-mirage&quot;&gt;background&lt;/a&gt; on this).
Since then, we've been hard at work using and extending MirageOS for real projects and the community has been
&lt;a href=&quot;https://mirage.io/blog/welcome-to-our-summer-hackers&quot;&gt;steadily growing&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We're thrilled to announce the release of MirageOS v2.0 today!  Over the past
few weeks the &lt;a href=&quot;https://mirage.io/community&quot;&gt;team&lt;/a&gt; has been &lt;a href=&quot;https://github.com/mirage/mirage/issues/257&quot;&gt;hard at work&lt;/a&gt; blogging about all
the new features in this latest release, coordinated by the tireless &lt;a href=&quot;http://amirchaudhry.com&quot;&gt;Amir Chaudhry&lt;/a&gt;:&lt;/p&gt;
&lt;img src=&quot;https://mirage.io/graphics/cubieboard2.jpg&quot; style=&quot;float:right; padding: 5px&quot; width=&quot;250px&quot;/&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ARM device support&lt;/strong&gt;: While the first version of MirageOS was specialised towards conventional x86 clouds, the code generation and boot libraries have now been made portable enough to operate on low-power embedded ARM devices such as the &lt;a href=&quot;http://cubieboard.org/&quot;&gt;Cubieboard 2&lt;/a&gt;.  This is a key part of our efforts to build a safe, unified &lt;a href=&quot;http://anil.recoil.org/papers/2010-bcs-visions.pdf&quot;&gt;mutiscale programming model&lt;/a&gt; for both cloud and mobile workloads as part of the &lt;a href=&quot;http://nymote.org&quot;&gt;Nymote&lt;/a&gt; project.  We also upstreamed the changes required to the Xen Project so that other unikernel efforts such as &lt;a href=&quot;https://github.com/GaloisInc/HaLVM&quot;&gt;HalVM&lt;/a&gt; or &lt;a href=&quot;https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-martins.pdf&quot;&gt;ClickOS&lt;/a&gt; can benefit.
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-xen-minios-arm&quot;&gt;Introducing an ARMy of unikernels&lt;/a&gt;&amp;quot;&lt;/em&gt; by &lt;a href=&quot;http://roscidus.com/blog/&quot;&gt;Thomas Leonard&lt;/a&gt; talks about the changes required and &lt;a href=&quot;https://mirage.io/docs/xen-on-cubieboard2&quot;&gt;instructions&lt;/a&gt; for trying this out for yourself on your own cheap Cubieboard.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Irmin distributed, branchable storage&lt;/strong&gt;: Unikernels usually execute in a distributed, disconnection-prone environment (particularly with the new mobile ARM support).  We therefore built the &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin&lt;/a&gt; library to explicitly make synchronization easier via a Git-like persistence model that can be used to build and easily trace the operation of distributed applications across all of these diverse environments.
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-irmin&quot;&gt;Introducing Irmin: Git-like distributed, branchable storage&lt;/a&gt;&amp;quot;&lt;/em&gt; by &lt;a href=&quot;http://gazagnaire.org&quot;&gt;Thomas Gazagnaire&lt;/a&gt; describes the concepts and high-level architecture of the system.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-irmin-in-xenstore&quot;&gt;Using Irmin to add fault-tolerance to the Xenstore database&lt;/a&gt;&amp;quot;&lt;/em&gt; by &lt;a href=&quot;http://dave.recoil.org&quot;&gt;Dave Scott&lt;/a&gt; shows how Irmin is used in a real-world application: the security-critical Xen toolstack that manages hosts full of virtual machines (&lt;a href=&quot;https://www.youtube.com/watch?v=DSzvFwIVm5s&quot;&gt;video&lt;/a&gt;).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OCaml TLS&lt;/strong&gt;: The philosophy of MirageOS is to construct the entire operating system in a safe programming style, from the device drivers up.  This continues in this release with a comprehensive OCaml implementation of &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;Transport Level Security&lt;/a&gt;, the most widely deployed end-to-end encryption protocol on the Internet (and one that is very prone to &lt;a href=&quot;https://en.wikipedia.org/wiki/Heartbleed&quot;&gt;bad security holes&lt;/a&gt;).  The blog series is written by &lt;a href=&quot;https://github.com/hannesm&quot;&gt;Hannes Mehnert&lt;/a&gt; and &lt;a href=&quot;https://github.com/pqwy&quot;&gt;David Kaloper&lt;/a&gt;.
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-ocaml-tls&quot;&gt;OCaml-TLS: Introducing transport layer security (TLS) in pure OCaml&lt;/a&gt;&amp;quot;&lt;/em&gt; presents the motivation and architecture behind our clean-slate implementation of the protocol.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-nocrypto&quot;&gt;OCaml-TLS: building the nocrypto library core&lt;/a&gt;&amp;quot;&lt;/em&gt; talks about the cryptographic primitives that form the heart of TLS confidentiality guarantees, and how they expose safe interfaces to the rest of the stack.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-x509&quot;&gt;OCaml-TLS: adventures in X.509 certificate parsing and validation&lt;/a&gt;&amp;quot;&lt;/em&gt; explains how authentication and chain-of-trust verification is implemented in our stack.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/introducing-asn1&quot;&gt;OCaml-TLS: ASN.1 and notation embedding&lt;/a&gt;&amp;quot;&lt;/em&gt; introduces the libraries needed for handling ASN.1 grammars, the wire representation of messages in TLS.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation&quot;&gt;OCaml-TLS: the protocol implementation and mitigations to known attacks&lt;/a&gt;&amp;quot;&lt;/em&gt; concludes with the implementation of the core TLS protocol logic itself.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Modularity and communication&lt;/strong&gt;: MirageOS is built on the concept of a &lt;a href=&quot;http://anil.recoil.org/papers/2013-asplos-mirage.pdf&quot;&gt;library operating system&lt;/a&gt;, and this release provides many new libraries to flexibly extend applications with new functionality.
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/intro-tcpip&quot;&gt;Fitting the modular MirageOS TCP/IP stack together&lt;/a&gt;&amp;quot;&lt;/em&gt; by &lt;a href=&quot;http://somerandomidiot.com&quot;&gt;Mindy Preston&lt;/a&gt; explains the rather unique modular architecture of our TCP/IP stack that lets you swap between the conventional Unix sockets API, or a complete implementation of TCP/IP in pure OCaml.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/update-on-vchan&quot;&gt;Vchan: low-latency inter-VM communication channels&lt;/a&gt;&amp;quot;&lt;/em&gt; by &lt;a href=&quot;http://jon.recoil.org&quot;&gt;Jon Ludlam&lt;/a&gt; shows how unikernels can communicate efficiently with each other to form distributed clusters on a multicore Xen host, by establishing shared memory rings with each other.
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;quot;&lt;a href=&quot;https://mirage.io/blog/modular-foreign-function-bindings&quot;&gt;Modular foreign function bindings&lt;/a&gt;&amp;quot;&lt;/em&gt; by &lt;a href=&quot;https://github.com/yallop&quot;&gt;Jeremy Yallop&lt;/a&gt; continues the march towards abstraction by expaining how to interface safely with code written in C, without having to write any unsafe C bindings!  This forms the basis for allowing Xen unikernels to communicate with existing libraries that they may want to keep at arm's length for security reasons.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All the libraries required for these new features are &lt;a href=&quot;https://mirage.io/releases&quot;&gt;regularly
released&lt;/a&gt; into the &lt;a href=&quot;http://opam.ocaml.org&quot;&gt;OPAM&lt;/a&gt; package manager, so
just follow the &lt;a href=&quot;https://mirage.io/wiki/install&quot;&gt;installation instructions&lt;/a&gt; to give them a spin.
A release this size probably introduces minor hiccups that may cause build
failures, so we very much encourage &lt;a href=&quot;https://github.com/mirage/mirage/issues&quot;&gt;bug
reports&lt;/a&gt; on our issue tracker or
&lt;a href=&quot;https://mirage.io/community&quot;&gt;questions&lt;/a&gt; to our mailing lists.  Don't be shy: no question is too
basic, and we'd love to hear of any weird and wacky uses you put this new
release to!  And finally, the lifeblood of MirageOS is about sharing and
&lt;a href=&quot;http://opam.ocaml.org/doc/Packaging.html&quot;&gt;publishing libraries&lt;/a&gt; that add new functionality to the framework, so do get
involved and open-source your own efforts.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Breaking news&lt;/em&gt;: &lt;a href=&quot;http://mort.io&quot;&gt;Richard Mortier&lt;/a&gt; and I will be speaking at &lt;a href=&quot;http://www.oscon.com&quot;&gt;OSCON&lt;/a&gt; this week on Thursday morning about the new features &lt;a href=&quot;http://www.oscon.com/oscon2014/public/schedule/detail/35024&quot;&gt;in F150 in the Cloud Track&lt;/a&gt;. Come along if you are in rainy Portland at the moment!&lt;/p&gt;

      </content><id>https://mirage.io/blog/announcing-mirage-20-release</id><title type="text">MirageOS v2.0: a recap of the new features</title><updated>2014-07-22T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/introducing-irmin-in-xenstore" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;em&gt;This is the second in a series of posts that introduces the &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin&lt;/a&gt; distributed storage engine.
You might like to begin with the &lt;a href=&quot;https://mirage.io/blog/introducing-irmin&quot;&gt;introductory post&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.xen.org/wiki/XenStore&quot;&gt;Xenstore&lt;/a&gt; is a critical service found on all hosts
running &lt;a href=&quot;http://www.xen.org/&quot;&gt;Xen&lt;/a&gt;. Xenstore is necessary to&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;configure all VM I/O devices such as disk controllers and network interface cards;
&lt;/li&gt;
&lt;li&gt;share performance statistics and OS version information; and
&lt;/li&gt;
&lt;li&gt;signal VMs during shutdown, suspend, resume, migrate etc.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Xenstore must be &lt;strong&gt;reliable&lt;/strong&gt;: if it fails then the host is unmanageable and must be rebooted.&lt;/p&gt;
&lt;p&gt;Xenstore must be &lt;strong&gt;secure&lt;/strong&gt;: if it is compromised by a VM then that VM can access data belonging
to other VMs.&lt;/p&gt;
&lt;p&gt;The current version of Xenstore is &lt;a href=&quot;http://xenbits.xen.org/gitweb/?p=xen.git%3Ba=tree%3Bf=tools/ocaml/xenstored%3Bh=0d762f2a61de098c0100814e0c140575b51688a3%3Bhb=stable-4.4&quot;&gt;already written in OCaml&lt;/a&gt;
and documented in the paper
&lt;a href=&quot;http://gazagnaire.org/pub/GH09.pdf&quot;&gt;OXenstored: an efficient hierarchical and transactional database using functional programming with reference cell comparisons&lt;/a&gt; presented at ICFP 2009.
The existing code works very reliably, but there is always room for improvement
for debuggability of such a complex system component. This is where Irmin, the
storage layer of Mirage 2.0, can help.&lt;/p&gt;
&lt;p&gt;But first, a quick Xenstore primer:&lt;/p&gt;
&lt;h3&gt;Xen and Xenstore in 30 seconds&lt;/h3&gt;
&lt;p&gt;The Xen hypervisor focuses on isolating VMs from each-other; the hypervisor provides a virtual CPU scheduler
and a memory allocator but does not perform I/O on behalf of guest VMs.
On a Xen host, privileged server VMs perform I/O on behalf of client VMs.
The configuration for calculating which server VM services requests for which client VMs is stored in Xenstore, as
key/value pairs.&lt;/p&gt;
&lt;p&gt;The following diagram shows a Xen host with a single client and server VM, with
a single virtual device in operation.  Disk blocks and network packets flow via
shared memory between Xen-aware drivers in the VMs, shown in the lower-half.
The control-plane, shown in the upper-half, contains the metadata about the
datapath: how the device should appear in the client VM; where the I/O should
go in the server VM; where the shared memory control structures are etc.&lt;/p&gt;
&lt;img src=&quot;https://mirage.io/graphics/xenstore-diagram.png&quot; alt=&quot;Device configuration is stored in Xenstore as key=value pairs.&quot;/&gt;
&lt;p&gt;The Xenstore device attach protocol insists that all device keys are added
through atomic transactions, i.e. partial updates are never visible to clients and transactions
cannot interfere with each other.
A Xenstore server must abort transactions whose operations were not successfully
isolated from other transactions. After an abort, the client is expected to retry.
Each key=value write is communicated to the server as a single request/response, so transactions
comprising multiple writes are open for multiple round-trip times.
This protocol is baked into guest VM kernels (including Linux, FreeBSD, Mirage, ...)
and won't change anytime soon.&lt;/p&gt;
&lt;p&gt;Xenstore is used heavily when lots of VMs are starting in parallel. Each VM typically
has several devices, each of these devices is added in a parallel transaction and therefore
many transactions are open at once. If the server aborts too many of these transactions,
causing the clients to retry, the system will make little progress and may appear to live-lock.
The challenge for a Xenstore implementation is to minimise the number of aborted
transactions and retries, without compromising on the isolation guarantee.&lt;/p&gt;
&lt;h3&gt;Irmin Xenstore design goals&lt;/h3&gt;
&lt;p&gt;The design goals of the Irmin-based Mirage Xenstore server are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;safely restart after a crash;
&lt;/li&gt;
&lt;li&gt;make system debugging easy; and
&lt;/li&gt;
&lt;li&gt;go really fast!
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;How does Irmin help achieve these goals?&lt;/p&gt;
&lt;h3&gt;Restarting after crashes&lt;/h3&gt;
&lt;p&gt;The Xenstore service is a reliable component and very rarely crashes. However,
if a crash does occur, the impact is severe on currently running virtual
machines. There is no protocol for a running VM to close its connection to a
Xenstore and open a new one, so if Xenstore crashes then running VMs are simply
left orphaned. VMs in this state are impossible to manage properly: there is no
way to shut them down cleanly, to suspend/resume or migrate, or to configure
any disk or network interfaces. If Xenstore crashes, the host must be rebooted
shortly after.&lt;/p&gt;
&lt;p&gt;Irmin helps make Xenstore recoverable after a crash, by providing a library
that applications can use to persist and synchronise distributed data
structures on disk and in memory. By using Irmin to persist all our state
somewhere sensible and taking care to manage our I/O carefully, then the server
process becomes stateless and can be restarted at will.&lt;/p&gt;
&lt;p&gt;To make Xenstore use Irmin,
the first task is to enumerate all the different kinds of state in the running process.
This includes the obvious key-value pairs used for VM configuration
as well as data currently hidden away in the OCaml heap:
the addresses in memory of established communication rings,
per-domain quotas, pending watch events and watch registrations etc etc.
Once the state has been enumerated it must be mapped onto key-value pairs which can
be stored in Irmin. Rather than using ad-hoc mappings everywhere, the Mirage Irmin
server has
&lt;a href=&quot;https://github.com/mirage/ocaml-xenstore-server/blob/blog/introducing-irmin-in-xenstore/server/pMap.mli&quot;&gt;persistent Maps&lt;/a&gt;,
&lt;a href=&quot;https://github.com/mirage/ocaml-xenstore-server/blob/blog/introducing-irmin-in-xenstore/server/pSet.ml&quot;&gt;persistent Sets&lt;/a&gt;,
&lt;a href=&quot;https://github.com/mirage/ocaml-xenstore-server/blob/blog/introducing-irmin-in-xenstore/server/pQueue.ml&quot;&gt;persistent Queues&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/mirage/ocaml-xenstore-server/blob/blog/introducing-irmin-in-xenstore/server/pRef.ml&quot;&gt;persistent reference cells&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Irmin applications are naturally written as functors, with the details of the persistence kept
abstract.
The following &lt;a href=&quot;https://github.com/mirage/irmin/blob/0.8.3/lib/core/irminView.mli&quot;&gt;Irmin-inspired&lt;/a&gt; signature represents what Xenstore needs
from Irmin:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;module type VIEW = sig
  type t

  val create: unit -&amp;gt; t Lwt.t
  (** Create a fresh VIEW from the current state of the store.
      A VIEW tracks state queries and updates and acts like a branch
      which has an explicit [merge]. *)

  val read: t -&amp;gt; Protocol.Path.t -&amp;gt; 
    [ `Ok of Node.contents | `Enoent of Protocol.Path.t ] Lwt.t
  (** Read a single key *)

  val list: t -&amp;gt; Protocol.Path.t -&amp;gt; 
    [ `Ok of string list | `Enoent of Protocol.Path.t ] Lwt.t
  (** List all the children of a key *)

  val write: t -&amp;gt; Protocol.Path.t -&amp;gt; Node.contents -&amp;gt; 
    [ `Ok of unit ] Lwt.t
  (** Update a single key *)

  val mem: t -&amp;gt; Protocol.Path.t -&amp;gt; bool Lwt.t
  (** Check whether a key exists *)

  val rm: t -&amp;gt; Protocol.Path.t -&amp;gt; [ `Ok of unit ] Lwt.t
  (** Remove a key *)

  val merge: t -&amp;gt; string -&amp;gt; bool Lwt.t
  (** Merge this VIEW into the current state of the store *)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main 'business logic' of Xenstore can then be functorised over this signature relatively easily.
All we need is to instantiate the functor using Irmin to persist the data somewhere sensible.
Eventually we will need two instantiations: one which runs as a userspace application and which
writes to the filesystem; and a second which will run as a
native Xen kernel (known as a &lt;a href=&quot;https://mirage.io/blog/xenstore-stub-domain&quot;&gt;xenstore stub domain&lt;/a&gt;)
and which will write to a fixed memory region (like a ramdisk).
The choice of which to use is left to the system administrator. Currently most (if not all)
distribution packagers choose to run Xenstore in userspace. Administrators who wish to
further secure their hosts are encouraged to run the kernelspace version to isolate Xenstore
from other processes (where a VM offers more isolation than a container, which offers more
isolation than a chroot). Note this choice is invisible to the guest VMs.&lt;/p&gt;
&lt;p&gt;So far in the Irmin Xenstore integration only the userspace instantiation has been implemented.
One of the most significant user-visible features is that all of the operations done through
Irmin can be inspected using the standard &lt;code&gt;git&lt;/code&gt; command line tool.
The runes to configure Irmin to write
&lt;a href=&quot;http://git-scm.com&quot;&gt;git&lt;/a&gt; format data to the filesystem are as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;    let open Irmin_unix in
    let module Git = IrminGit.FS(struct
      let root = Some filename
      let bare = true
    end) in
    let module DB = Git.Make(IrminKey.SHA1)(IrminContents.String)(IrminTag.String) in
    DB.create () &amp;gt;&amp;gt;= fun db -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where keys and values will be mapped into OCaml &lt;code&gt;strings&lt;/code&gt;, and our
&lt;code&gt;VIEW.t&lt;/code&gt; is simply an Irmin &lt;code&gt;DB.View.t&lt;/code&gt;. All that remains is to implement
&lt;code&gt;read&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt; by&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mapping Xenstore &lt;code&gt;Protocol.Path.t&lt;/code&gt; values onto Irmin keys; and
&lt;/li&gt;
&lt;li&gt;mapping Xenstore &lt;code&gt;Node.contents&lt;/code&gt; records onto Irmin values.
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As it happens Xenstore and Irmin have similar notions of &amp;quot;paths&amp;quot; so the first mapping is
easy. We currently use &lt;a href=&quot;https://github.com/janestreet/sexplib&quot;&gt;sexplib&lt;/a&gt; to map Node.contents
values onto strings for Irmin.&lt;/p&gt;
&lt;p&gt;The resulting &lt;a href=&quot;https://github.com/mirage/ocaml-xenstore-server/blob/blog/introducing-irmin-in-xenstore/userspace/main.ml#L101&quot;&gt;Irmin glue module&lt;/a&gt; looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;    let module V = struct
      type t = DB.View.t
      let create = DB.View.create
      let write t path contents =
        DB.View.update t (value_of_filename path) (Sexp.to_string (Node.sexp_of_contents contents))
      (* omit read,list,write,rm for brevity *)
      let merge t origin =
        let origin = IrminOrigin.create &amp;quot;%s&amp;quot; origin in
        DB.View.merge_path ~origin db [] t &amp;gt;&amp;gt;= function
        | `Ok () -&amp;gt; return true
        | `Conflict msg -&amp;gt;
          info &amp;quot;Conflict while merging database view: %s&amp;quot; msg;
          return false
    end in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;write&lt;/code&gt; function simply calls through to Irmin's &lt;code&gt;update&lt;/code&gt; function, while the &lt;code&gt;merge&lt;/code&gt; function
calls Irmin's &lt;code&gt;merge_path&lt;/code&gt;. If Irmin cannot merge the transaction then our &lt;code&gt;merge&lt;/code&gt; function will
return &lt;code&gt;false&lt;/code&gt; and this will be signalled to the client, which is expected to retry the high-level
operation (e.g. hotplugging or unplugging a device).&lt;/p&gt;
&lt;p&gt;Now all that remains is to carefully adjust the I/O code so that effects (reading and writing packets
along the persistent connections) are interleaved properly with persisted state changes and
voil&amp;agrave;, we now have a xenstore which can recover after a restart.&lt;/p&gt;
&lt;h3&gt;Easy system debugging with Git&lt;/h3&gt;
&lt;p&gt;When something goes wrong on a Xen system it's standard procedure to&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;take a snapshot of the current state of Xenstore; and
&lt;/li&gt;
&lt;li&gt;examine the log files for signs of trouble.
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Unfortunately by the
time this is done, interesting Xenstore state has usually been deleted. Unfortunately the first task
of the human operator is to evaluate by-hand the logged actions in reverse to figure out what the state
actually was when the problem happened. Obviously this is tedious, error-prone and not always
possible since the log statements are ad-hoc and don't always include the data you need to know.&lt;/p&gt;
&lt;p&gt;In the new Irmin-powered Xenstore the history is preserved in a git-format repository, and can
be explored using your favourite git viewing tool. Each store
update has a compact one-line summary, a more verbose multi-line explanation and (of course)
the full state change is available on demand.&lt;/p&gt;
&lt;p&gt;For example you can view the history in a highly-summarised form with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ git log --pretty=oneline --abbrev-commit --graph
* 2578013 Closing connection -1 to domain 0
* d4728ba Domain 0: rm /bench/local/domain/0/backend/vbd/10 = ()
* 4b55c99 Domain 0: directory /bench/local/domain/0/backend = [ vbd ]
* a71a903 Domain 0: rm /bench/local/domain/10 = ()
* f267b31 Domain 0: rm /bench/vss/uuid-10 = ()
* 94df8ce Domain 0: rm /bench/vm/uuid-10 = ()
* 0abe6b0 Domain 0: directory /bench/vm/uuid-10/domains = [  ]
* 06ddd3b Domain 0: rm /bench/vm/uuid-10/domains/10 = ()
* 1be2633 Domain 0: read /bench/local/domain/10/vss = /bench/vss/uuid-10
* 237a8e4 Domain 0: read /bench/local/domain/10/vm = /bench/vm/uuid-10
* 49d70f6 Domain 0: directory /bench/local/domain/10/device = [  ]
*   ebf4935 Merge view to /
|\\
| * e9afd9f Domain 0: read /bench/local/domain/10 =
* | c4e0fa6 Domain 0: merging transaction 375
|/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The summarised form shows both individual operations as well as isolated transactions which
are represented as git branches.
You can then 'zoom in' and show the exact state change with commands like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git show bd44e03
commit bd44e0388696380cafd048eac49474f68d41bd3a
Author: 448 &amp;lt;irminsule@openmirage.org&amp;gt;
Date:   Thu Jan 1 00:09:26 1970 +0000

    Domain 0: merging transaction 363

diff --git a/*0/bench.dir/local.dir/domain.dir/7.dir/control.dir/shutdown.value b/*0/bench.dir/local.dir/domain.dir/7.dir/control.dir/shutdown.value
new file mode 100644
index 0000000..aa38106
--- /dev/null
+++ b/*0/bench.dir/local.dir/domain.dir/7.dir/control.dir/shutdown.value
@@ -0,0 +1 @@
+((creator 0)(perms((owner 7)(other NONE)(acl())))(value halt))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Last but not least, you can &lt;code&gt;git checkout&lt;/code&gt; to the exact time the problem occurred and examine
the state of the store.&lt;/p&gt;
&lt;h3&gt;Going really fast&lt;/h3&gt;
&lt;p&gt;Xenstore is part of the control-plane of a Xen system and is most heavily stressed when lots
of VMs are being started in parallel. Each VM has multiple devices and each device is added in a
separate transaction. These transactions remain open for multiple client-server round-trips, as
each individual operation is sent to Xenstore as a separate RPC.
To provide isolation, each Xenstore transaction is represented by an Irmin &lt;code&gt;VIEW.t&lt;/code&gt; which
is persisted on disk as a git branch.
When starting lots of VMs in
parallel, lots of branches are created and must be merged back together. If a branch cannot
be merged then an abort signal is sent to the client and it must retry.&lt;/p&gt;
&lt;p&gt;Earlier versions of Xenstore had naive transaction merging algorithms
which aborted many of these transactions, causing the clients to re-issue them.This led to a live-lock
where clients were constantly reissuing the same transactions again and again.&lt;/p&gt;
&lt;p&gt;Happily Irmin's default merging strategy is much better: by default Irmin
records the results of every operation and replays the operations on merge
(similar to &lt;code&gt;git rebase&lt;/code&gt;). Irmin will only generate a &lt;code&gt;Conflict&lt;/code&gt; and signal an
abort if the client would now see different results to those it has already
received (imagine reading a key twice within an isolated transaction and seeing
two different values). In the case of parallel VM starts, the keys are disjoint
by construction so all transactions are merged trivially; clients never receive
abort signals; and therefore the system makes steady, predictable progress
starting the VMs.&lt;/p&gt;
&lt;h3&gt;Trying it out&lt;/h3&gt;
&lt;p&gt;The Irmin Xenstore is under &lt;a href=&quot;https://github.com/mirage/ocaml-xenstore-server&quot;&gt;active development&lt;/a&gt;
but you can try it by:&lt;/p&gt;
&lt;p&gt;Install basic development tools along with the xen headers and xenstore tools (NB you don't
actually have to run Xen):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  sudo apt-get install libxen-dev xenstore-utils opam build-essential m4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Initialise opam (if you haven't already). Make sure you have OCaml 4.01:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  opam init
  opam update
  opam switch 4.01.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install the OCaml build dependencies:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  opam install lwt irmin git sexplib cstruct uri sexplib cmdliner xen-evtchn shared-memory-ring io-page ounit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Clone the code and build it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  git clone https://github.com/mirage/ocaml-xenstore-server
  cd ocaml-xenstore-server
  make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run a server (as a regular user):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ./main.native --database /tmp/db --enable-unix --path /tmp/xenstored
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In a separate terminal, perform some operations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  export XENSTORED_PATH=/tmp/xenstored
  xenstore-write -s /one/two/three 4 /five/six/seven 8
  xenstore-ls -s /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next check out the git repo generated by Irmin:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  cd /tmp/db
  git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Comments and/or contributions are welcome: join the &lt;a href=&quot;http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel&quot;&gt;Mirage email list&lt;/a&gt; and say hi!&lt;/p&gt;

      </content><id>https://mirage.io/blog/introducing-irmin-in-xenstore</id><title type="text">Using Irmin to add fault-tolerance to the Xenstore database</title><updated>2014-07-21T00:00:00-00:00</updated><author><name>Dave Scott</name></author></entry><entry><link href="https://mirage.io/blog/introducing-irmin" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;blockquote&gt;
&lt;p&gt;This is the first post in a series which will describe &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin&lt;/a&gt;,
the new Git-like storage layer for Mirage OS 2.0. This post gives a
high-level description on Irmin and its overall architecture, and
later posts will detail how to use Irmin in real systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin&lt;/a&gt; is a library to persist and synchronize distributed
data structures both on-disk and in-memory. It enables a style of
programming very similar to the &lt;a href=&quot;http://git-scm.com/&quot;&gt;Git&lt;/a&gt; workflow, where
distributed nodes fork, fetch, merge and push data between
each other. The general idea is that you want every active node to
get a local (partial) copy of a global database and always be very
explicit about how and when data is shared and migrated.&lt;/p&gt;
&lt;p&gt;Irmin is &lt;em&gt;not&lt;/em&gt;, strictly speaking, a full database engine. It
is, as are all other components of Mirage OS, a collection of
libraries designed to solve different flavours of the challenges raised
by the &lt;a href=&quot;http://en.wikipedia.org/wiki/CAP_theorem&quot;&gt;CAP theorem&lt;/a&gt;. Each application can select the right
combination of libraries to solve its particular distributed problem. More
precisely, Irmin consists of a core of well-defined low-level
data structures that specify how data should be persisted
and be shared across nodes. It defines algorithms for efficient
synchronization of those distributed low-level constructs. It also
builds a collection of higher-level data structures, like persistent
&lt;a href=&quot;https://github.com/mirage/merge-queues&quot;&gt;mergeable queues&lt;/a&gt;, that can be used by developers without
having to know precisely how Irmin works underneath.&lt;/p&gt;
&lt;p&gt;Since it's a part of Mirage OS, Irmin does not make strong assumptions about the
OS environment that it runs in. This makes the system very portable, and the
details below hold for in-memory databases as well as for slower persistent
serialization such as SSDs, hard drives, web browser local storage, or even
the Git file format.&lt;/p&gt;
&lt;h3&gt;Persistent Data Structures&lt;/h3&gt;
&lt;p&gt;Persistent data structures are well known and used pervasively in many
different areas. The programming language community has
investigated the concepts &lt;a href=&quot;https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf&quot;&gt;widely&lt;/a&gt; (and this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Object_copy&quot;&gt;not
limited&lt;/a&gt; to functional programming), and in the meantime,
the systems community experimented with various persistent
strategies such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;copy-on-write&lt;/a&gt; filesystems. In most of these
systems, the main concern is how to optimize the space complexity by
maximizing the sharing of immutable sub-structures.&lt;/p&gt;
&lt;p&gt;The Irmin design ideas share roots with previous works on persistent data
structures, as it provides an efficient way to &lt;em&gt;fork&lt;/em&gt; data structures,
but it also explores new strategies and mechanisms to be able to
efficiently &lt;em&gt;merge&lt;/em&gt; back these forked structures. This offers
programming constructs very similar to the Git workflow.&lt;/p&gt;
&lt;p&gt;Irmin focuses on two main aspects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Semantics&lt;/strong&gt;: what properties the resulting merged objects should
verify.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Complexity&lt;/strong&gt;: how to design efficient merge and synchronization
primitives, taking advantage of the immutable nature of the underlying
objects.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Although it is pervasively used, &lt;em&gt;data persistence&lt;/em&gt; has a very broad and
fuzzy meaning. In this blog post, I will refer to data persistence as
a way for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a single process to lazily populate a process memory on startup.
You need this when you want the process to be able to resume while
holding part of its previous state if it crashes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;concurrent processes to share references between objects living in
a global pool of data. Sharing references, as opposed to sharing
values, reduces memory copies and allow different processes to
concurrently update a shared store.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In both cases, you need a global pool of data (the Irmin &lt;em&gt;block store&lt;/em&gt;)
and a way to name values in that pool (the Irmin &lt;em&gt;tag store&lt;/em&gt;).&lt;/p&gt;
&lt;h3&gt;The Block Store: a Virtual Heap&lt;/h3&gt;
&lt;p&gt;Even high-level data structures need to be allocated in memory, and it
is the purpose of the runtime to map such high-level constructs into
low-level memory graph blocks. One of the strengths of &lt;a href=&quot;http://ocaml.org&quot;&gt;OCaml&lt;/a&gt;
is the very simple and deterministic mapping from high-level data
structures to low-level block representations (the &lt;em&gt;heap&lt;/em&gt;): see for
instance, the excellent series of blog posts on &lt;a href=&quot;http://rwmj.wordpress.com/2009/08/04/ocaml-internals/&quot;&gt;OCaml
internals&lt;/a&gt; by Richard W. Jones, or
&lt;a href=&quot;https://realworldocaml.org/v1/en/html/memory-representation-of-values.html&quot;&gt;Chapter 20: Memory Representation of Values&lt;/a&gt; in
&lt;a href=&quot;https://realworldocaml.org&quot;&gt;Real World OCaml&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;An Irmin &lt;em&gt;block store&lt;/em&gt; can be seen as a virtual OCaml heap that uses a more
abstract way of connecting heap blocks. Instead of using the concrete physical
memory addresses of blocks, Irmin uses the hash of the block contents as an
address. As for any &lt;a href=&quot;http://en.wikipedia.org/wiki/Content-addressable_storage&quot;&gt;content-addressable storage&lt;/a&gt;, this gives Irmin
block stores a lot of nice properties and greatly simplifies the way distributed
stores can be synchronized.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Persistent&lt;/em&gt; data structures are immutable, and once a block is created in
the block store, its contents will never change again.
Updating an immutable data structure means returning a completely new
structure, while trying to share common sub-parts to avoid the cost of
making new allocations as much as possible. For instance, modifying a
value in a persistent tree means creating a chain of new blocks, from
the root of the tree to the modified leaf.
For convenience, Irmin only considers acyclic block graphs --
it is difficult in a non-lazy pure language to generate complex cyclic
values with reasonable space usage.&lt;/p&gt;
&lt;p&gt;Conceptually, an Irmin block store has the following signature:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;type t
(** The type for Irmin block store. *)

type key
(** The type for Irmin pointers *)

type value = ...
(** The type for Irmin blocks *)

val read: t -&amp;gt; key -&amp;gt; value option
(** [read t k] is the block stored at the location [k] of the
store. It is [None] if no block is available at that location. *)

val add: t -&amp;gt; key -&amp;gt; value -&amp;gt; t
(** [add t k v] is the *new* store storing the block [v] at the
location [k]. *)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Persistent data structures are very efficient to store in memory and on
disk as you do not need &lt;a href=&quot;http://en.wikipedia.org/wiki/Write_barrier&quot;&gt;write barriers&lt;/a&gt;, and updates
can be written &lt;a href=&quot;http://en.wikipedia.org/wiki/Write_amplification#Sequential_writes&quot;&gt;sequentially&lt;/a&gt; instead of requiring random
access into the data structure.&lt;/p&gt;
&lt;h3&gt;The Tag Store: Controlled Mutability and Concurrency&lt;/h3&gt;
&lt;p&gt;So far, we have only discussed purely functional data structures,
where updating a structure means returning a pointer to a new
structure in the heap that shares most of its contents with the previous
one. This style of programming is appealing when implementing
&lt;a href=&quot;https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation&quot;&gt;complex protocols&lt;/a&gt; as it leads to better compositional properties.&lt;/p&gt;
&lt;img src=&quot;https://mirage.io/graphics/irmin-stores.png&quot; alt=&quot;Irmin Stores&quot; style=&quot;float:right; border: 5px&quot; width=&quot;250px&quot;/&gt;
&lt;p&gt;However, this makes sharing information between processes much more
difficult, as you need a way to &amp;quot;inject&amp;quot; the state of one structure into another process's memory. In order to do so, Irmin borrows the concept of
&lt;em&gt;branches&lt;/em&gt; from Git by relating every operation to a branch name, and
modifying the tip of the branch if it has side-effects.
The Irmin &lt;em&gt;tag store&lt;/em&gt; is the only mutable part of the whole system and
is responsible for mapping some global (branch) names to blocks in the
block store. These tag names can then be used to pass block references between
different processes.&lt;/p&gt;
&lt;p&gt;A block store and a tag store can be combined to build
a higher-level store (the Irmin store) with fine concurrency control
and atomicity guarantees. As mutation happens only in the tag store,
we can ensure that as long a given tag is not updated, no change made
in the block store will be visible by anyone. This also gives a nice
story for concurrency: as in Git, creating a concurrent view of the
store is the straightforward operation of creating a new tag that
denotes a new branch. All concurrent operations can then happen on
different branches:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;type t
(** The type for Irmin store. *)

type tag
(** Mutable tags *)

type key = ...
(** The type for user-defined keys (for instance a list of strings) *)

type value = ...
(** The type for user-defined values *)

val read: t -&amp;gt; ?branch:tag -&amp;gt; key -&amp;gt; value option
(** [read t ?branch k] reads the contents of the key [k] in the branch
[branch] of the store [t]. If no branch is specified, then use the
[&amp;quot;HEAD&amp;quot;] one. *)

val update: t -&amp;gt; ?branch:tag -&amp;gt; key -&amp;gt; value -&amp;gt; unit
(** [update t ?branch k v] *updates* the branch [branch] of the store
[t] the association of the key [key] to the value [value]. *)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Interactions between concurrent processes are completely explicit and
need to happen via synchronization points and merge events (more on
this below). It is also possible to emulate the behaviour of
transactions by recording the sequence of operations (&lt;code&gt;read&lt;/code&gt; and
&lt;code&gt;update&lt;/code&gt;) on a given branch -- that sequence is used before a merge
to check that all the operations are valid (i.e. that all reads in the
transaction still return the same result on the current tip of the
store) and it can be discarded after the merge takes place.&lt;/p&gt;
&lt;h3&gt;Merging Data Structures&lt;/h3&gt;
&lt;p&gt;To merge two data structures in a consistent way, one has to compute
the sequence of operations which leads, from an initial common state, to two
diverging states (the ones that you want to merge). Once these two
sequences of operations have been found, they must be combined (if
possible) in a sensible way and then applied again back on the initial
state, in order to get the new merged state. This mechanism sounds
nice, but in practice it has two major drawbacks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It does not specify how we find the initial state from two diverging
states -- this is generally not possible (think of diverging
counters); and
&lt;/li&gt;
&lt;li&gt;It means we need to compute the sequence of &lt;code&gt;update&lt;/code&gt; operations
that leads from one state to an other.  This is easier than finding
the common initial state between two branches, but is still generally
not very efficient.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In Irmin, we solve these problems using two mechanisms.&lt;/p&gt;
&lt;p&gt;First of all, an interesting observation is that that we can model the
sequence of store tips as a purely functional data-structure. We model
the partial order of tips as a directed acyclic graph where nodes are
the tips, and there is an edge between two tips if either &lt;em&gt;(i)&lt;/em&gt; one is
the result of applying a sequence of &lt;code&gt;update&lt;/code&gt;s to the other, or &lt;em&gt;(ii)&lt;/em&gt;
one is the result of a merge operation between the other and some
other tips. Practically speaking, that means that every tip should
contains the list of its predecessors as well as the actual data it
associated to. As it is purely functional, we can (and we do) store
that graph in an Irmin block store.&lt;/p&gt;
&lt;img src=&quot;https://mirage.io/graphics/irmin-merge.png&quot; alt=&quot;Finding a common ancestor&quot; style=&quot;float:right; border:5px&quot; width=&quot;150px&quot;/&gt;
&lt;p&gt;Having a persistent and immutable history is good for various obvious
reasons, such as access to a forensics if an error occurs or
snapshot and rollback features for free. But another less obvious
useful property is that we can now find the greatest common
ancestors of two data structures without an expensive global search.&lt;/p&gt;
&lt;p&gt;The second mechanism is that we require the data structures used in
Irmin to be equipped with a well-defined 3-way merge operation, which
takes two diverging states, the corresponding initial state (computed
using the previous mechanism) and that return either a new state or a
conflict (similar to the &lt;code&gt;EAGAIN&lt;/code&gt; exception that you get when you try
to commit a conflicting transaction in more traditional transactional
databases). Having access to the common ancestors makes a great
difference when designing new merge functions, as usually no
modification is required to the data-structure itself. In contrast,
the conventional approach is more invasive as it requires the data
structure to carry more information about the operation history
(for instance &lt;a href=&quot;http://hal.upmc.fr/docs/00/55/55/88/PDF/techreport.pdf&quot;&gt;conflict-free replicated
datatypes&lt;/a&gt;, which relies on unbounded vector clocks).&lt;/p&gt;
&lt;p&gt;We have thus been designing interesting data structure equipped with a 3-way
merge, such as counters, &lt;a href=&quot;https://github.com/mirage/merge-queues&quot;&gt;queues&lt;/a&gt; and ropes.&lt;/p&gt;
&lt;p&gt;This is what the implementation of distributed and mergeable counters
looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;type t = int
(** distributed counters are just normal integers! *)

let merge ~old t1 t2 = old + (t1-old) + (t2-old)
(** Merging counters means:
   - computing the increments of the two states [t1] and [t2]
     relatively to the initial state [old]; and
   - and add these two increments to [old]. *)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Next steps, how to git at your data&lt;/h3&gt;
&lt;p&gt;From a design perspective, having access to the history makes it easier to
design complex data structures with good compositional properties to use in
unikernels. Moreover, as we made few assumptions on how the substrate of the
low-level constructs need to be implemented, the Irmin engine can be be ported
to many exotic backends such as JavaScript or anywhere else that Mirage OS
runs: this is just a matter of implementing a rather trivial
&lt;a href=&quot;https://github.com/mirage/irmin/blob/4b06467ddee1e20c35bad64812769587fb9fa8a4/lib/core/irminStore.mli#L61&quot;&gt;signature&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;From a developer perspective, this means that the full history of operations is
available to inspect, and that the history model is very similar to the Git
workflow that is increasingly familiar. So similar, in fact, that we've
developed a bidirectional mapping between Irmin data structures and the Git
format to permit the &lt;code&gt;git&lt;/code&gt; command-line to interact with.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://mirage.io/blog/introducing-irmin-in-xenstore&quot;&gt;next post in our series&lt;/a&gt; explains what &lt;a href=&quot;http://dave.recoil.org/&quot;&gt;Dave Scott&lt;/a&gt; has been doing
with the new version of the &lt;a href=&quot;http://wiki.xen.org/wiki/XenStoreReference&quot;&gt;Xenstore&lt;/a&gt; database that powers every Xen host,
where the entire database is stored in a prefix-tree Irmin data-structure and exposed
as a Git repository which is live-updated!  Here's a sneak preview...&lt;/p&gt;
&lt;div class=&quot;flex-video&quot;&gt;
  &lt;iframe width=&quot;480&quot; height=&quot;360&quot; src=&quot;//www.youtube-nocookie.com/embed/DSzvFwIVm5s&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;1&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

      </content><id>https://mirage.io/blog/introducing-irmin</id><title type="text">Introducing Irmin: Git-like distributed, branchable storage</title><updated>2014-07-18T00:00:00-00:00</updated><author><name>Thomas Gazagnaire</name></author></entry><entry><link href="https://mirage.io/blog/intro-tcpip" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;A critical part of any unikernel is its network stack -- it's difficult to
think of a project that needs a cloud platform or runs on a set-top box with no
network communications.&lt;/p&gt;
&lt;p&gt;Mirage provides a number of &lt;a href=&quot;https://github.com/mirage/mirage/tree/master/types&quot;&gt;module
types&lt;/a&gt; that abstract
interfaces at different layers of the network stack, allowing unikernels to
customise their own stack based on their deployment needs. Depending on the
abstractions your unikernel uses, you can fulfill these abstract interfaces
with implementations ranging from the venerable and much-imitated Unix sockets
API to a clean-slate Mirage &lt;a href=&quot;https://github.com/mirage/mirage-tcpip&quot;&gt;TCP/IP
stack&lt;/a&gt; written from the ground up in
pure OCaml!&lt;/p&gt;
&lt;p&gt;A Mirage unikernel will not use &lt;em&gt;all&lt;/em&gt; these interfaces, but will pick those that
are appropriate for the particular application at hand. If your unikernel just
needs a standard TCP/IP stack, the &lt;code&gt;STACKV4&lt;/code&gt; abstraction will be sufficient.
However, if you want more control over the implementation of the different
layers in the stack or you don't need TCP support, you might construct your
stack by hand using just the &lt;a href=&quot;https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/types/V1.mli#L263&quot;&gt;NETWORK&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/types/V1.mli#L316&quot;&gt;ETHIF&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/types/V1.mli#L368&quot;&gt;IPV4&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/types/V1.mli#L457&quot;&gt;UDPV4&lt;/a&gt; interfaces.&lt;/p&gt;
&lt;h2&gt;How a Stack Looks to a Mirage Application&lt;/h2&gt;
&lt;p&gt;Mirage provides a high-level interface to a TCP/IP network stack through the module type
&lt;a href=&quot;https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/types/V1.mli#L581&quot;&gt;STACKV4&lt;/a&gt;.
(Currently this can be included with &lt;code&gt;open V1_LWT&lt;/code&gt;, but soon &lt;code&gt;open V2_LWT&lt;/code&gt; will also bring this module type into scope as well when Mirage 2.0 is released.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;(** Single network stack *)                                                     
module type STACKV4 = STACKV4                                                   
  with type 'a io = 'a Lwt.t                                                    
   and type ('a,'b,'c) config = ('a,'b,'c) stackv4_config                       
   and type ipv4addr = Ipaddr.V4.t                                              
   and type buffer = Cstruct.t 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;STACKV4&lt;/code&gt; has useful high-level functions, a subset of which are reproduced below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;    val listen_udpv4 : t -&amp;gt; port:int -&amp;gt; UDPV4.callback -&amp;gt; unit
    val listen_tcpv4 : t -&amp;gt; port:int -&amp;gt; TCPV4.callback -&amp;gt; unit
    val listen : t -&amp;gt; unit io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;as well as submodules that include functions for data transmission:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;    module UDPV4 :
      sig
        type callback =
            src:ipv4addr -&amp;gt; dst:ipv4addr -&amp;gt; src_port:int -&amp;gt; buffer -&amp;gt; unit io
        val input :
          listeners:(dst_port:int -&amp;gt; callback option) -&amp;gt; t -&amp;gt; ipv4input
        val write :
          ?source_port:int -&amp;gt;
          dest_ip:ipv4addr -&amp;gt; dest_port:int -&amp;gt; t -&amp;gt; buffer -&amp;gt; unit io
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;    module TCPV4 :
      sig
        type flow
        type callback = flow -&amp;gt; unit io
        val read : flow -&amp;gt; [ `Eof | `Error of error | `Ok of buffer ] io
        val write : flow -&amp;gt; buffer -&amp;gt; unit io
        val close : flow -&amp;gt; unit io
        val create_connection :
          t -&amp;gt; ipv4addr * int -&amp;gt; [ `Error of error | `Ok of flow ] io
        val input : t -&amp;gt; listeners:(int -&amp;gt; callback option) -&amp;gt; ipv4input
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These should look rather familiar if you've used the Unix sockets
API before, with one notable difference: the stack accepts functional
callbacks to react to events such as a new connection request.  This
permits callers of the library to define the precise datastructures that
are used to store intermediate state (such as active connections).
This becomes important when building very scalable systems that have
to deal with &lt;a href=&quot;https://en.wikipedia.org/wiki/C10k_problem&quot;&gt;lots of concurrent connections&lt;/a&gt;
efficiently.&lt;/p&gt;
&lt;h2&gt;Configuring a Stack&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;STACKV4&lt;/code&gt; signature shown so far is just a module signature, and you
need to find a concrete module that satisfies that signature.  The known
implementations of a module can be found in the &lt;code&gt;mirage&lt;/code&gt; CLI frontend,
which provids the &lt;a href=&quot;https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/lib/mirage.mli#L266&quot;&gt;configuration API&lt;/a&gt; for unikernels.&lt;br/&gt;
There are currently two implementations for &lt;code&gt;STACKV4&lt;/code&gt;: &lt;code&gt;direct&lt;/code&gt; and &lt;code&gt;socket&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;module STACKV4_direct: CONFIGURABLE with                                        
  type t = console impl * network impl * [`DHCP | `IPV4 of ipv4_config]         
                                                                                
module STACKV4_socket: CONFIGURABLE with                                        
  type t = console impl * Ipaddr.V4.t list  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;socket&lt;/code&gt; implementations rely on an underlying OS kernel to provide the
transport, network, and data link layers, and therefore can't be used for a Xen
guest VM deployment.  Currently, the only way to use &lt;code&gt;socket&lt;/code&gt; is by configuring
your Mirage project for Unix with &lt;code&gt;mirage configure --unix&lt;/code&gt;.  This is the mode
you will most often use when developing high-level application logic that doesn't
need to delve into the innards of the network stack (e.g. a REST website).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;direct&lt;/code&gt; implementations use the &lt;a href=&quot;https://github.com/mirage/mirage-tcpip&quot;&gt;mirage-tcpip&lt;/a&gt; implementations of the
transport, network, and data link layers.  When you use this stack, all the network
traffic from the Ethernet level up will be handled in pure OCaml.  This means that the
&lt;code&gt;direct&lt;/code&gt; stack will work with either a Xen
guest VM (provided there's a valid network configuration for the unikernel's
running environment of course), or a Unix program if there's a valid &lt;a href=&quot;https://en.wikipedia.org/wiki/TUN/TAP&quot;&gt;tuntap&lt;/a&gt; interface.
&lt;code&gt;direct&lt;/code&gt; this works with both &lt;code&gt;mirage configure --xen&lt;/code&gt; and &lt;code&gt;mirage configure --unix&lt;/code&gt;
as long as there is a corresponding available device when the unikernel is run.&lt;/p&gt;
&lt;p&gt;There are a few Mirage functions that provide IPv4 (and UDP/TCP) stack
implementations (of type &lt;code&gt;stackv4 impl&lt;/code&gt;), usable from your application code.
The &lt;code&gt;stackv4 impl&lt;/code&gt; is generated in &lt;code&gt;config.ml&lt;/code&gt; by some logic set when the
program is &lt;code&gt;mirage configure&lt;/code&gt;'d - often by matching an environment variable.
This means it's easy to flip between different stack implementations when
developing an application just be recompiling the application.  The &lt;code&gt;config.ml&lt;/code&gt;
below allows the developer to build socket code with &lt;code&gt;NET=socket make&lt;/code&gt; and
direct code with &lt;code&gt;NET=direct make&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;let main = foreign &amp;quot;Services.Main&amp;quot; (console @-&amp;gt; stackv4 @-&amp;gt; job)

let net =
  try match Sys.getenv &amp;quot;NET&amp;quot; with
    | &amp;quot;direct&amp;quot; -&amp;gt; `Direct
    | &amp;quot;socket&amp;quot; -&amp;gt; `Socket
    | _        -&amp;gt; `Direct
  with Not_found -&amp;gt; `Direct

let dhcp =
  try match Sys.getenv &amp;quot;ADDR&amp;quot; with
    | &amp;quot;dhcp&amp;quot;   -&amp;gt; `Dhcp
    | &amp;quot;static&amp;quot; -&amp;gt; `Static
    | _ -&amp;gt; `Dhcp
  with Not_found -&amp;gt; `Dhcp

let stack console =
  match net, dhcp with
  | `Direct, `Dhcp   -&amp;gt; direct_stackv4_with_dhcp console tap0
  | `Direct, `Static -&amp;gt; direct_stackv4_with_default_ipv4 console tap0
  | `Socket, _       -&amp;gt; socket_stackv4 console [Ipaddr.V4.any]

let () =
  register &amp;quot;services&amp;quot; [
    main $ default_console $ stack default_console
  ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Moreover, it's possible to configure multiple stacks individually for use in
the same program, and to &lt;code&gt;register&lt;/code&gt; multiple modules from the same &lt;code&gt;config.ml&lt;/code&gt;.
This means functions can be written such that they're aware of the network
stack they ought to be using, and no other - a far cry from developing network
code over most socket interfaces, where it can be quite difficult to separate
concerns nicely.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;let client = foreign &amp;quot;Unikernel.Client&amp;quot; (console @-&amp;gt; stackv4 @-&amp;gt; job)
let server = foreign &amp;quot;Unikernel.Server&amp;quot; (console @-&amp;gt; stackv4 @-&amp;gt; job) 

let client_netif = (netif &amp;quot;0&amp;quot;)
let server_netif = (netif &amp;quot;1&amp;quot;) 

let client_stack = direct_stackv4_with_dhcp default_console client_netif
let server_stack = direct_stackv4_with_dhcp default_console server_netif

let () = 
  register &amp;quot;unikernel&amp;quot; [
    main $ default_console $ client_stack;
    server $ default_console $ server_stack 
  ]

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Acting on Stacks&lt;/h2&gt;
&lt;p&gt;Most network applications will either want to listen for incoming connections
and respond to that traffic with information, or to connect to some remote
host, execute a query, and receive information.  &lt;code&gt;STACKV4&lt;/code&gt; offers simple ways
to define functions implementing either of these patterns.&lt;/p&gt;
&lt;h3&gt;Establishing and Communicating Across Connections&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;STACKV4&lt;/code&gt; offers &lt;code&gt;listen_tcpv4&lt;/code&gt; and &lt;code&gt;listen_udpv4&lt;/code&gt; functions for establishing
listeners on specific ports.  Both take a &lt;code&gt;stack impl&lt;/code&gt;, a named &lt;code&gt;port&lt;/code&gt;, and a
&lt;code&gt;callback&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;For UDP listeners, which are datagram-based rather than connection-based,
&lt;code&gt;callback&lt;/code&gt; is a function of the source IP, destination IP, source port, and the
&lt;code&gt;Cstruct.t&lt;/code&gt; that contains the payload data.  Applications that wish to respond
to incoming UDP packets with their own UDP responses (e.g., DNS servers) can
use this information to construct reply packets and send them with
&lt;code&gt;UDPV4.write&lt;/code&gt; from within the callback function.&lt;/p&gt;
&lt;p&gt;For TCP listeners, &lt;code&gt;callback&lt;/code&gt; is a function of &lt;code&gt;TCPV4.flow -&amp;gt; unit Lwt.t&lt;/code&gt;.  &lt;code&gt;STACKV4.TCPV4&lt;/code&gt; offers &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;close&lt;/code&gt; on &lt;code&gt;flow&lt;/code&gt;s for application writers to build higher-level protocols on top of.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TCPV4&lt;/code&gt; also offers &lt;code&gt;create_connection&lt;/code&gt;, which allows client application code to establish TCP connections with remote servers.  In success cases, &lt;code&gt;create_connection&lt;/code&gt; returns a &lt;code&gt;TCPV4.flow&lt;/code&gt;, which can be acted on just as the data in a &lt;code&gt;callback&lt;/code&gt; above.  There's also a polymorphic variant for error conditions, such as an unreachable remote server.&lt;/p&gt;
&lt;h3&gt;A Simple Example&lt;/h3&gt;
&lt;p&gt;Some very simple examples of user-level TCP code are included in &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/tree/master/examples&quot;&gt;mirage-tcpip/examples&lt;/a&gt;.  &lt;code&gt;config.ml&lt;/code&gt; is identical to the first configuration example above, and will build a &lt;code&gt;direct&lt;/code&gt; stack by default.&lt;/p&gt;
&lt;p&gt;Imagine a very simple application - one which simply repeats any data back to the sender, until the sender gets bored and wanders off (&lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;RFC 862&lt;/a&gt;, for the curious).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;open Lwt
open V1_LWT

module Main (C: V1_LWT.CONSOLE) (S: V1_LWT.STACKV4) = struct
  let report_and_close c flow message =
    C.log c message;
    S.TCPV4.close flow

  let rec echo c flow =
    S.TCPV4.read flow &amp;gt;&amp;gt;= fun result -&amp;gt; (
      match result with  
        | `Eof -&amp;gt; report_and_close c flow &amp;quot;Echo connection closure initiated.&amp;quot;
        | `Error e -&amp;gt; 
          let message = 
          match e with 
            | `Timeout -&amp;gt; &amp;quot;Echo connection timed out; closing.\\n&amp;quot;
            | `Refused -&amp;gt; &amp;quot;Echo connection refused; closing.\\n&amp;quot;
            | `Unknown s -&amp;gt; (Printf.sprintf &amp;quot;Echo connection error: %s\\n&amp;quot; s)
             in
          report_and_close c flow message
        | `Ok buf -&amp;gt;
            S.TCPV4.write flow buf &amp;gt;&amp;gt;= fun () -&amp;gt; echo c flow
        ) 

  let start c s = 
    S.listen_tcpv4 s ~port:7 (echo c);
    S.listen s

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All the application programmer needs to do is define functionality in relation to &lt;code&gt;flow&lt;/code&gt; for sending and receiving data, establish this function as a callback with &lt;code&gt;listen_tcpv4&lt;/code&gt;, and start a listening thread with &lt;code&gt;listen&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;More Complex Uses&lt;/h2&gt;
&lt;p&gt;An OCaml HTTP server, &lt;a href=&quot;http://www.github.com/mirage/ocaml-cohttp&quot;&gt;Cohttp&lt;/a&gt;, is currently powering this very blog.  A simple static webserver using Cohttp &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/tree/master/static_website&quot;&gt;is included in &lt;code&gt;mirage-skeleton&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tls.nqsb.io/&quot;&gt;The OCaml-TLS demonstration server&lt;/a&gt; announced here &lt;a href=&quot;http://mirage.io/blog/introducing-ocaml-tls&quot;&gt;just a few days ago&lt;/a&gt; is also running atop Cohttp - &lt;a href=&quot;https://github.com/mirleft/tls-demo-server&quot;&gt;source is available on Github&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;The future&lt;/h2&gt;
&lt;p&gt;Mirage's TCP/IP stack is under active development!  &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/search?q=TODO&amp;amp;ref=cmdform&quot;&gt;Some low-level details&lt;/a&gt; are still stubbed out, and we're working on implementing some of the trickier corners of TCP, as well as &lt;a href=&quot;http://somerandomidiot.com/blog/2014/05/22/throwing-some-fuzzy-dice/&quot;&gt;doing automated testing&lt;/a&gt; on the stack.  We welcome testing tools, bug reports, bug fixes, and new protocol implementations!&lt;/p&gt;

      </content><id>https://mirage.io/blog/intro-tcpip</id><title type="text">Fitting the modular MirageOS TCP/IP stack together</title><updated>2014-07-17T00:00:00-00:00</updated><author><name>Mindy Preston</name></author></entry><entry><link href="https://mirage.io/blog/update-on-vchan" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;em&gt;Today's post is an update to &lt;a href=&quot;https://github.com/vbmithr&quot;&gt;Vincent Bernardoff's&lt;/a&gt;
&lt;a href=&quot;https://mirage.io/blog/introducing-vchan&quot;&gt;introducing vchan&lt;/a&gt; blog
post, updated to use the modern build scheme for Mirage.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Unless you are familiar with Xen's source code, there is little chance
that you've ever heard of the &lt;em&gt;vchan&lt;/em&gt; library or
protocol. Documentation about it is very scarce: a description can be
found on vchan's
&lt;a href=&quot;http://xenbits.xen.org/gitweb/?p=xen.git%3Ba=blob%3Bf=xen/include/public/io/libxenvchan.h%3Bhb=HEAD&quot;&gt;public header file&lt;/a&gt;,
that I quote here for convenience:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Originally borrowed from the
&lt;a href=&quot;http://www.qubes-os.org&quot;&gt;Qubes OS Project&lt;/a&gt;, this code (i.e. libvchan)
has been substantially rewritten [...]
This is a library for inter-domain communication.  A standard Xen ring
buffer is used, with a datagram-based interface built on top.  The
grant reference and event channels are shared in XenStore under a
user-specified path.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This protocol uses shared memory for inter-domain communication,
i.e. between two VMs residing in the same Xen host, and uses Xen's
mechanisms -- more specifically,
&lt;a href=&quot;http://www.informit.com/articles/article.aspx?p=1160234&amp;amp;seqNum=3&quot;&gt;ring buffers&lt;/a&gt;
and
&lt;a href=&quot;http://xenbits.xen.org/gitweb/?p=xen.git%3Ba=blob%3Bf=tools/libxc/xenctrl.h%3Bh=f2cebafc9ddd4815ffc73fcf9e0d292b1d4c91ff%3Bhb=HEAD#l934&quot;&gt;event channels&lt;/a&gt;
-- in order to achieve its aims. The term &lt;em&gt;datagram-based interface&lt;/em&gt; simply
means that the
&lt;a href=&quot;http://xenbits.xen.org/gitweb/?p=xen.git%3Ba=blob%3Bf=tools/libvchan/libxenvchan.h%3Bh=6365d36a06f8c8f56454724cefc4c2f1d39beba2%3Bhb=HEAD&quot;&gt;interface&lt;/a&gt;
resembles UDP, although there is support for stream based communication (like
TCP) as well.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;vchan&lt;/code&gt; protocol is an important feature in MirageOS 2.0 since it
forms the foundational communication mechanism for &lt;strong&gt;building distributed
clusters of unikernels&lt;/strong&gt; that cooperate to solve problems that are beyond
the power of a single node.  Instead of forcing communication between
nodes via a conventional wire protocol like TCP, it permits highly efficient
low-overhead communication to nodes that are colocated on the same Xen
host machine.&lt;/p&gt;
&lt;p&gt;Before diving into vchan, I thought I'd also take the opportunity to describe the
&lt;a href=&quot;http://releases.ubuntu.com/14.04/&quot;&gt;Ubuntu-Trusty&lt;/a&gt; environment for developing
and running &lt;a href=&quot;http://www.xenproject.org/&quot;&gt;Xen&lt;/a&gt; unikernels.&lt;/p&gt;
&lt;h3&gt;Installing Xen on Ubuntu&lt;/h3&gt;
&lt;p&gt;Ubuntu 14.04 has good support for running Xen 4.4, the most recent release (at time of writing).
For running VMs it's a good idea to install Ubuntu on an LVM volume rather than directly on a
partition, which allows the use of LVs as the virtual disks for your VMs. On my system I have
a 40 Gig partition for '/', an 8 Gig swap partition and the rest is free for my VMs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ sudo lvs
   LV     VG      Attr      LSize  Pool Origin Data%  Move Log Copy%  Convert
   root   st28-vg -wi-ao--- 37.25g
   swap_1 st28-vg -wi-ao---  7.99g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this particular walkthough I won't be using disks, but later posts will.
Install Xen via the meta-package. This brings in all you will need to run VMs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ sudo apt-get install xen-system-amd64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It used to be necessary to reorder the grub entries to make sure Xen was started
by default, but this is no longer necessary. Once the machine has rebooted, you
should be able to verify you're running virtualized by invoking 'xl':&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ sudo xl list
Name                                        ID   Mem VCPUs      State   Time(s)
Domain-0                                     0  7958     6     r-----       9.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;My machine has 8 Gigs of memory, and this list shows that it's all being used by
my dom0, so I'll need to either balloon down dom0 or reboot with a lower maximum
memory. Ballooning is the most straightfoward:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ sudo xenstore-write /local/domain/0/memory/target 4096000
$ sudo xl list
Name                                        ID   Mem VCPUs      State   Time(s)
Domain-0                                     0  4000     6     r-----      12.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is handy for quick testing, but is &lt;a href=&quot;http://wiki.xenproject.org/wiki/Xen_Project_Best_Practices&quot;&gt;discouraged&lt;/a&gt; by the Xen folks. So alternatively, change the xen command line by
editing &lt;code&gt;/etc/default/grub&lt;/code&gt; and add the line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;GRUB_CMDLINE_XEN_DEFAULT=&amp;quot;dom0_mem=4096M,max:4096M&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once again, update-grub and reboot.&lt;/p&gt;
&lt;h3&gt;Mirage&lt;/h3&gt;
&lt;p&gt;Now lets get Mirage up and running. Install ocaml, opam and set up the opam environment:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ sudo apt-get install ocaml opam ocaml-native-compilers camlp4-extra
...
$ opam init
...
$ eval `opam config env`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Don't forget the &lt;code&gt;ocaml-native-compilers&lt;/code&gt;, as without this we can't
compile the unikernels. Now we are almost ready to install Mirage; we
need two more dependencies, and then we're good to go.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ sudo apt-get install m4 libxen-dev
$ opam install mirage mirage-xen mirage-unix vchan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where &lt;code&gt;m4&lt;/code&gt; is for ocamlfind, and &lt;code&gt;libxen-dev&lt;/code&gt; is required to compile the
unix variants of the &lt;code&gt;xen-evtchn&lt;/code&gt; and &lt;code&gt;xen-gnt&lt;/code&gt; libraries. Without these
installing vchan will complain that there is no &lt;code&gt;xen-evtchn.lwt&lt;/code&gt;
library installed.&lt;/p&gt;
&lt;p&gt;This second line installs the various Mirage and vchan libraries, but
doesn't build the demo unikernel and Unix CLI.  To get them, clone
the ocaml-vchan repository:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ git clone https://github.com/mirage/ocaml-vchan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The demo unikernel is a very straightforward capitalizing echo server.
The &lt;a href=&quot;https://github.com/mirage/ocaml-vchan/blob/master/test/echo.ml#L13&quot;&gt;main function&lt;/a&gt; simply consists of&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let (&amp;gt;&amp;gt;=) = Lwt.bind

let (&amp;gt;&amp;gt;|=) m f = m &amp;gt;&amp;gt;= function
| `Ok x -&amp;gt; f x
| `Eof -&amp;gt; Lwt.fail (Failure &amp;quot;End of file&amp;quot;)
| `Error (`Not_connected state) -&amp;gt;
    Lwt.fail (Failure (Printf.sprintf &amp;quot;Not in a connected state: %s&amp;quot;
      (Sexplib.Sexp.to_string (Node.V.sexp_of_state state))))

let rec echo vch =
  Node.V.read vch &amp;gt;&amp;gt;|= fun input_line -&amp;gt;
  let line = String.uppercase (Cstruct.to_string input_line) in
  let buf = Cstruct.create (String.length line) in
  Cstruct.blit_from_string line 0 buf 0 (String.length line);
  Node.V.write vch buf &amp;gt;&amp;gt;|= fun () -&amp;gt;
  echo vch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where we've defined an error-handling monadic bind (&lt;code&gt;&amp;gt;&amp;gt;|=&lt;/code&gt;) which
is then used to sequence the read and write operations.&lt;/p&gt;
&lt;p&gt;Building the CLI is done simply via &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ make
...
$ ls -l node_cli.native
lrwxrwxrwx 1 jludlam jludlam 52 Jul 14 14:56 node_cli.native -&amp;gt; /home/jludlam/ocaml-vchan/_build/cli/node_cli.native
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Building the unikernel is done via the &lt;code&gt;mirage&lt;/code&gt; tool:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ cd test
$ mirage configure --xen
...
$ make depend
...
$ make
...
$ ls -l mir-echo.xen echo.xl
-rw-rw-r-- 1 jludlam jludlam     596 Jul 14 14:58 echo.xl
-rwxrwxr-x 1 jludlam jludlam 3803982 Jul 14 14:59 mir-echo.xen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This make both the unikernel binary (the mir-echo.xen file) and a convenient
xl script to run it. To run, we use the xl tool, passing '-c' to connect
directly to the console so we can see what's going on:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ sudo xl create -c echo.xl
Parsing config from echo.xl
kernel.c: Mirage OS!
kernel.c:   start_info: 0x11cd000(VA)
kernel.c:     nr_pages: 0x10000
kernel.c:   shared_inf: 0xdf2f6000(MA)
kernel.c:      pt_base: 0x11d0000(VA)
kernel.c: nr_pt_frames: 0xd
kernel.c:     mfn_list: 0x114d000(VA)
kernel.c:    mod_start: 0x0(VA)
kernel.c:      mod_len: 0
kernel.c:        flags: 0x0
kernel.c:     cmd_line:
x86_setup.c:   stack:      0x144f40-0x944f40
mm.c: MM: Init
x86_mm.c:       _text: 0x0(VA)
x86_mm.c:      _etext: 0xb8eec(VA)
x86_mm.c:    _erodata: 0xde000(VA)
x86_mm.c:      _edata: 0x1336f0(VA)
x86_mm.c: stack start: 0x144f40(VA)
x86_mm.c:        _end: 0x114d000(VA)
x86_mm.c:   start_pfn: 11e0
x86_mm.c:     max_pfn: 10000
x86_mm.c: Mapping memory range 0x1400000 - 0x10000000
x86_mm.c: setting 0x0-0xde000 readonly
x86_mm.c: skipped 0x1000
mm.c: MM: Initialise page allocator for 0x1256000 -&amp;gt; 0x10000000
mm.c: MM: done
x86_mm.c: Pages to allocate for p2m map: 2
x86_mm.c: Used 2 pages for map
x86_mm.c: Demand map pfns at 10001000-2010001000.
Initialising timer interface
Initializing Server domid=0 xs_path=data/vchan
gnttab_stubs.c: gnttab_table mapped at 0x10001000
Server: right_order = 13, left_order = 13
allocate_buffer_locations: gntref = 9
allocate_buffer_locations: gntref = 10
allocate_buffer_locations: gntref = 11
allocate_buffer_locations: gntref = 12
Writing config into the XenStore
Shared page is:

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0d 00 0d 00 02 01 01 00 09 00 00 00 0a 00 00 00
0b 00 00 00 0c 00 00 00
Initialization done!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vchan is domain-to-domain communication, and relies on Xen's grant
tables to share the memory. The entries in the grant tables have
domain-level access control, so we need to know the domain ID of the
client and server in order to set up the communications. The test
unikernel server is hard-coded to talk to domain 0, so we only need to
know the domain ID of our echo server. In another terminal,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ sudo xl list
Name                                        ID   Mem VCPUs      State   Time(s)
Domain-0                                     0  4095     6     r-----    1602.9
echo                                         2   256     1     -b----       0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, the domain ID is 2, so we invoke the CLI as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ sudo ./node_cli.native 2
Client initializing: Received gntref = 8, evtchn = 4
Mapped the ring shared page:

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0d 00 0d 00 02 01 01 00 09 00 00 00 0a 00 00 00
0b 00 00 00 0c 00 00 00
Correctly bound evtchn number 71
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We're now connected via vchan to the Mirage domain. The test server
is simply a capitalisation service:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;hello from dom0
HELLO FROM DOM0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ctrl-C to get out of the CLI, and destroy the domain with an &lt;code&gt;xl destroy&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ sudo xl destroy test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vchan&lt;/code&gt; is a very low-level communication mechanism, and so our next post on
this topic will address how to use it in combination with a name resolver
to intelligently map connection requests to use &lt;code&gt;vchan&lt;/code&gt; if available, and
otherwise fall back to normal TCP or TCP+TLS.&lt;/p&gt;

      </content><id>https://mirage.io/blog/update-on-vchan</id><title type="text">Vchan: Low-latency inter-VM communication channels</title><updated>2014-07-16T00:00:00-00:00</updated><author><name>Jon Ludlam</name></author></entry><entry><link href="https://mirage.io/blog/modular-foreign-function-bindings" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;One of the most frequent questions about MirageOS from developers is
&amp;quot;do I really need to write all my code in OCaml&amp;quot;?  There are, of
course, very good reasons to build the core system in pure OCaml: the
module system permits reusing algorithmic abstractions at scale, and
OCaml's static type checking makes it possible to enforce lightweight
invariants across interfaces.  However, it's ultimately necessary to
support interfacing to existing code, and this blog post will describe
what we're doing to make this possible this without sacrificing the
security benefits afforded by unikernels.&lt;/p&gt;
&lt;p&gt;A MirageOS application works by abstracting the &lt;em&gt;logic&lt;/em&gt; of the
application from the details of &lt;em&gt;platform&lt;/em&gt; that it is compiled for.
The &lt;code&gt;mirage&lt;/code&gt; CLI tool parses a configuration file that represents the
desired hardware target, which can be a Unix binary or a specialized
Xen guest OS.  Our foreign function interface design elaborates on
these design principles by separating the &lt;em&gt;description&lt;/em&gt; of the C
foreign functions from how we &lt;em&gt;link&lt;/em&gt; to that code.  For instance, a
Unix unikernel could use the normal &lt;code&gt;ld.so&lt;/code&gt; to connect to a shared
library, while in Xen we would need to interface to that C library
through some other mechanism (for instance, a separate VM could be
spawned to run the untrusted OpenSSL code).  If you're curious about
how this works, this blog post is for you!&lt;/p&gt;
&lt;h3&gt;Introducing ctypes&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ocamllabs/ocaml-ctypes&quot;&gt;ocaml-ctypes&lt;/a&gt; (&amp;quot;ctypes&amp;quot; for short) is a library for
gluing together OCaml code and C code without writing any C.  This
post introduces the ctypes library with a couple of simple examples,
and outlines how OCaml's module system makes it possible to write
high-level bindings to C that are independent of any particular
linking mechanism.&lt;/p&gt;
&lt;h3&gt;Hello, C&lt;/h3&gt;
&lt;p&gt;Binding a C function using ctypes involves two steps.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, construct an OCaml value that represents the type of the function
&lt;/li&gt;
&lt;li&gt;Second, use the type representation and the function name to resolve and bind the function
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, here's a binding to C's &lt;code&gt;puts&lt;/code&gt; function, which prints a string to
standard output and returns the number of characters written:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let puts = foreign &amp;quot;puts&amp;quot; (string @-&amp;gt; returning int)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the call to &lt;code&gt;foreign&lt;/code&gt; the bound function is available to OCaml
immediately.  Here's a call to &lt;code&gt;puts&lt;/code&gt; from the interactive top level:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;# puts &amp;quot;Hello, world&amp;quot;;;
Hello, world
- : int = 13
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&amp;lt;Hello-C/&amp;gt;&lt;/h3&gt;
&lt;p&gt;Now that we've had a taste of ctypes, let's look at a more realistic
example: a program that defines bindings to the &lt;a href=&quot;http://www.libexpat.org/&quot;&gt;expat&lt;/a&gt; XML
parsing library, then uses them to display the structure of an XML
document.&lt;/p&gt;
&lt;p&gt;We'll start by describing the types used by expat.  Since ctypes
represents C types as OCaml values, each of the types we need becomes
a value binding in our OCaml program.  The parser object involves an
incomplete (abstract) struct definition and a typedef for a pointer to
a struct:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;struct xml_ParserStruct;
typedef xml_ParserStruct *xml_Parser;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In ctypes these become calls to the &lt;code&gt;structure&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let parser_struct : [`XML_ParserStruct] structure typ = structure &amp;quot;xml_ParserStruct&amp;quot;
let xml_Parser = ptr parser_struct
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we'll use the type representations to bind some functions.  The
&lt;a href=&quot;http://www.xml.com/pub/a/1999/09/expat/reference.html#parsercreate&quot;&gt;&lt;code&gt;XML_ParserCreate&lt;/code&gt;&lt;/a&gt;
and
&lt;a href=&quot;http://www.xml.com/pub/a/1999/09/expat/reference.html#parserfree&quot;&gt;&lt;code&gt;XML_ParserFree&lt;/code&gt;&lt;/a&gt;
functions construct and destroy parser objects.  As with &lt;code&gt;puts&lt;/code&gt;, each
function binding involves a simple call to &lt;code&gt;foreign&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let parser_create = foreign &amp;quot;XML_ParserCreate&amp;quot;
  (ptr void @-&amp;gt; returning xml_Parser)
let parser_free = foreign &amp;quot;XML_ParserFree&amp;quot;
  (xml_Parser @-&amp;gt; returning void)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Expat operates primarily through callbacks: when start and end elements are
encountered the parser invokes user-registered functions, passing the tag names
and attributes (along with a piece of user data):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;typedef void (*start_handler)(void *, char *, char **);
typedef void (*end_handler)(void *, char *);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In ctypes function pointer types are built using the &lt;code&gt;funptr&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let start_handler =
  funptr (ptr void @-&amp;gt; string @-&amp;gt; ptr string @-&amp;gt; returning void)
let end_handler =
  funptr (ptr void @-&amp;gt; string @-&amp;gt; returning void)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use the &lt;code&gt;start_handler&lt;/code&gt; and &lt;code&gt;end_handler&lt;/code&gt; type representations to bind
&lt;a href=&quot;http://www.xml.com/pub/a/1999/09/expat/reference.html#elementhandler&quot;&gt;&lt;code&gt;XML_SetElementHandler&lt;/code&gt;&lt;/a&gt;, the callback-registration function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let set_element_handler = foreign &amp;quot;XML_SetElementHandler&amp;quot;
  (xml_Parser @-&amp;gt; start_handler @-&amp;gt; end_handler @-&amp;gt; returning void)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The type that OCaml infers for &lt;code&gt;set_element_handler&lt;/code&gt; reveals that the function
accepts regular OCaml functions as arguments, since the argument types are
normal OCaml function types:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;val set_element_handler :
  [ `XML_ParserStruct ] structure ptr -&amp;gt;
  (unit ptr -&amp;gt; string -&amp;gt; string ptr -&amp;gt; unit) -&amp;gt;
  (unit ptr -&amp;gt; string -&amp;gt; unit) -&amp;gt; unit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There's one remaining function to bind, then we're ready to use the
library.  The
&lt;a href=&quot;http://www.xml.com/pub/a/1999/09/expat/reference.html#parse&quot;&gt;&lt;code&gt;XML_Parse&lt;/code&gt;&lt;/a&gt;
function performs the actual parsing, invoking the callbacks when tags
are encountered:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let parse = foreign &amp;quot;XML_Parse&amp;quot;
  (xml_Parser @-&amp;gt; string @-&amp;gt; int @-&amp;gt; int @-&amp;gt; returning int)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As before, all the functions that we've bound are available for use
immediately.  We'll start by using them to define a more idiomatic OCaml entry
point to the library.  The &lt;code&gt;parse_string&lt;/code&gt; function accepts the start and end
callbacks as labelled arguments, along with a string to parse:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let parse_string ~start_handler ~end_handler s =
  let p = parser_create null in
  let () = set_element_handler p start_handler end_handler in
  let _ = parse p s (String.length s) 1 in
  parser_free p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using &lt;code&gt;parse_string&lt;/code&gt; we can write a program that prints out the names of each
element in an XML document, indented according to nesting depth:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let depth = ref 0

let start_handler _ name _ =
  Printf.printf &amp;quot;%*s%s\\n&amp;quot; (!depth * 3) &amp;quot;&amp;quot; name;
  incr depth

let end_handler _ _ =
  decr depth

let () =
  parse_string ~start_handler ~end_handler (In_channel.input_all stdin)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The full source of the program is &lt;a href=&quot;https://github.com/yallop/ocaml-ctypes-expat-example&quot;&gt;available on github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here's the program in action:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ ocamlfind opt -thread -package core,ctypes.foreign expat_example.ml \\
   -linkpkg -cclib -lexpat -o expat_example
$ wget -q https://mirage.io/blog/atom.xml -O /dev/stdout \\
  | ./expat_example
feed
   id
   title
   subtitle
   rights
   updated
   link
   link
   contributor
      email
      uri
      name
[...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since this is just a high-level overview we've passed over a number of
details.  The interested reader can find a more comprehensive introduction to
using ctypes in &lt;a href=&quot;https://realworldocaml.org/v1/en/html/foreign-function-interface.html&quot;&gt;Chapter 19: Foreign Function Interface&lt;/a&gt; of &lt;a href=&quot;https://realworldocaml.org&quot;&gt;Real World OCaml&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Dynamic vs static&lt;/h3&gt;
&lt;p&gt;Up to this point we've been using a single function, &lt;code&gt;foreign&lt;/code&gt;, to
make C functions available to OCaml.  Although &lt;code&gt;foreign&lt;/code&gt; is simple to
use, there's quite a lot going on behind the scenes.  The two
arguments to &lt;code&gt;foreign&lt;/code&gt; are used to dynamically construct an OCaml
function value that wraps the C function: the name is used to resolve
the code for the C function, and the type representation is used to
construct a call frame appropriate to the C types invovled and to the
underlying platform.&lt;/p&gt;
&lt;p&gt;The dynamic nature of &lt;code&gt;foreign&lt;/code&gt; that makes it convenient for
interactive use, also makes it unsuitable for some environments.
There are three main drawbacks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Binding functions dynamically involves a certain loss of &lt;em&gt;safety&lt;/em&gt;:
since C libraries typically don't maintain information about the
types of the functions they contain, there's no way to check whether
the type representation passed to &lt;code&gt;foreign&lt;/code&gt; matches the actual type of
the C function.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamically constructing calls introduces a certain &lt;em&gt;interpretative
overhead&lt;/em&gt;.  In mitigation, this overhead is much less than might be supposed,
since much of the work can be done when the function is bound rather than
when the call is made, and &lt;code&gt;foreign&lt;/code&gt; has been used to bind C functions in
&lt;a href=&quot;http://erratique.ch/software/tgls&quot;&gt;performance-sensitive applications&lt;/a&gt; without problems.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The implementation of &lt;code&gt;foreign&lt;/code&gt; uses a low-level library, &lt;a href=&quot;https://sourceware.org/libffi/&quot;&gt;libffi&lt;/a&gt;,
to deal with calling conventions across platforms.  While libffi is mature
and widely supported, it's not appropriate for use in every environment.
For example, introducing such a (relatively) large and complex library into
Mirage would compromise many of the benefits of writing the rest of the
system in OCaml.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Happily, there's a solution at hand.  As the introduction hints, &lt;code&gt;foreign&lt;/code&gt; is
one of a number of binding strategies, and OCaml's module system makes it easy
to defer the choice of which strategy to use when writing the actual code.
Placing the &lt;code&gt;expat&lt;/code&gt; bindings in a functor (parameterised module) makes it
possible to abstract over the linking strategy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;module Bindings(F : FOREIGN) =
struct
  let parser_create = F.foreign &amp;quot;XML_ParserCreate&amp;quot;
    (ptr void @-&amp;gt; returning xml_Parser)
  let parser_free = F.foreign &amp;quot;XML_ParserFree&amp;quot;
    (xml_Parser @-&amp;gt; returning void)
  let set_element_handler = F.foreign &amp;quot;XML_SetElementHandler&amp;quot;
    (xml_Parser @-&amp;gt; start_handler @-&amp;gt; end_handler @-&amp;gt; returning void)
  let parse = F.foreign &amp;quot;XML_Parse&amp;quot;
    (xml_Parser @-&amp;gt; string @-&amp;gt; int @-&amp;gt; int @-&amp;gt; returning int)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Bindings&lt;/code&gt; module accepts a single parameter of type &lt;code&gt;FOREIGN&lt;/code&gt;, which
encodes the binding strategy to use.  Instantiating &lt;code&gt;Bindings&lt;/code&gt; with a module
containing the &lt;code&gt;foreign&lt;/code&gt; function used above recovers the
dynamically-constructed bindings that we've been using so far.  However, there
are now other possibilities available.  In particular, we can instantiate
&lt;code&gt;Bindings&lt;/code&gt; with code generators that output code to expose the bound functions
to OCaml.  The actual instantiation is hidden behind a couple of convenient
functions, &lt;code&gt;write_c&lt;/code&gt; and &lt;code&gt;write_ml&lt;/code&gt;, which accept &lt;code&gt;Bindings&lt;/code&gt; as a parameter
and write to a &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html#TYPEformatter&quot;&gt;formatter&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;Cstubs.write_c formatter ~prefix:&amp;quot;expat&amp;quot; ~bindings:(module Bindings)
Cstubs.write_ml formatter ~prefix:&amp;quot;expat&amp;quot; ~bindings:(module Bindings)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generating code in this way eliminates the concerns associated with
constructing calls dynamically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The C compiler checks the types of the generated calls against the C
headers (the API), so the safety concerns associated with linking
directly against the C library binaries (the ABI) don't apply.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There's no interpretative overhead, since the generated code is
(statically) compiled.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The dependency on libffi disappears altogether.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How easy is it in practice to switch between dynamic and static
binding strategies?  It turns out that it's quite straightforward,
even for code that was originally written without parameterisation.
Bindings written using early releases of ctypes used the dynamic
strategy exclusively, since dynamic binding was then the only option
available.  The commit logs for projects that switched over to static
generation and linking (e.g. &lt;a href=&quot;https://github.com/whitequark/ocaml-lz4/commit/acc257ea1&quot;&gt;ocaml-lz4&lt;/a&gt; and
&lt;a href=&quot;https://github.com/janestreet/async_ssl/commit/ab5ea6f55e&quot;&gt;async-ssl&lt;/a&gt;) when it became available show that
moving to the new approach involved only straightforward and localised
changes.&lt;/p&gt;
&lt;h3&gt;Local vs remote&lt;/h3&gt;
&lt;p&gt;Generating code is safer than constructing calls dynamically, since it
allows the C compiler to check the types of function calls against
declarations.  However, there are some safety problems that even C's
type checking doesn't detect.  For instance, the following call is
type correct (given suitable definitions of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;), but is
likely to misbehave at run time:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;memcpy(p, q, SIZE_MAX)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In contrast, code written purely in OCaml detects and prevents
attempts to write beyond the bounds of allocated objects:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;# StringLabels.blit ~src ~dst ~src_pos:0 ~dst_pos:0 ~len:max_int;;
Exception: Invalid_argument &amp;quot;String.blit&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It seems a shame to weaken OCaml's safety guarantees by linking in C
code that can potentially write to any region of memory, but what is
the alternative?&lt;/p&gt;
&lt;p&gt;One possibility is to use &lt;a href=&quot;http://en.wikipedia.org/wiki/Privilege_separation&quot;&gt;privilege separation&lt;/a&gt; to separate
trusted OCaml code from untrusted C functions.  The modular design of
ctypes means that privilege separation can be treated as one more
linking strategy: we can run C code in an entirely separate process
(or for Mirage/Xen, in a separate virtual machine), and instantiate
&lt;code&gt;Bindings&lt;/code&gt; with a strategy that forwards calls to the process using
standard inter-process communication.  The remote calling strategy is
not supported in the &lt;a href=&quot;https://github.com/ocamllabs/ocaml-ctypes/releases/tag/0.3.2&quot;&gt;current release&lt;/a&gt; of ctypes, but
it's scheduled for a future version.  As with the switch from dynamic
to static bindings, we anticipate that updating existing bindings to
use cross-process calls will be straightforward.&lt;/p&gt;
&lt;p&gt;This introductory post should give you a sense of the power of the unikernel
approach in Mirage.  By turning the FFI into just another library (for the C
interface description) and protocol (for the linkage model), we can use code
generation to map application logic onto the privilege model most suitable for
the target hardware platform.  This starts with Unix processes, continues onto Xen
paravirtualization, and could even extend into &lt;a href=&quot;http://www.cl.cam.ac.uk/research/security/ctsrd/cheri/&quot;&gt;CHERI&lt;/a&gt; fine-grained
compartmentalization.&lt;/p&gt;
&lt;h3&gt;Further examples&lt;/h3&gt;
&lt;p&gt;Although ctypes is a fairly new library, it's already in use in a
number of projects across a variety of domains: &lt;a href=&quot;http://erratique.ch/software/tgls&quot;&gt;graphics&lt;/a&gt;,
&lt;a href=&quot;http://erratique.ch/software/tsdl&quot;&gt;multimedia&lt;/a&gt;, &lt;a href=&quot;https://github.com/whitequark/ocaml-lz4&quot;&gt;compression&lt;/a&gt;, &lt;a href=&quot;https://github.com/dsheets/ocaml-sodium&quot;&gt;cryptography&lt;/a&gt;,
&lt;a href=&quot;https://github.com/nojb/ocaml-gsasl&quot;&gt;security&lt;/a&gt;, &lt;a href=&quot;https://github.com/hcarty/ocaml-gdal&quot;&gt;geospatial data&lt;/a&gt;, &lt;a href=&quot;http://github.com/rgrinberg/onanomsg&quot;&gt;communication&lt;/a&gt;,
and many others.  Further resources (documentation, forums, etc.) are
available via the &lt;a href=&quot;https://github.com/ocamllabs/ocaml-ctypes&quot;&gt;home page&lt;/a&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/modular-foreign-function-bindings</id><title type="text">Modular foreign function bindings</title><updated>2014-07-15T00:00:00-00:00</updated><author><name>Jeremy Yallop</name></author></entry><entry><link href="https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;em&gt;This is the fifth in a series of posts that introduce new libraries for a pure OCaml implementation of TLS.
You might like to begin with the &lt;a href=&quot;http://mirage.io/blog/introducing-ocaml-tls&quot;&gt;introduction&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;ocaml-tls&lt;/a&gt; is the new, clean-slate implementation of TLS in OCaml
that we've been working on for the past six months. In this post we
try to document some of its internal design, the reasons for the
decisions we made, and the current security status of that work. Try
our &lt;a href=&quot;https://tls.nqsb.io&quot;&gt;live interactive demonstration server&lt;/a&gt; which visualises TLS
sessions.&lt;/p&gt;
&lt;h3&gt;The OCaml-TLS architecture&lt;/h3&gt;
&lt;p&gt;The OCaml ecosystem has several distinct ways of interacting with the outside world
(and the network in particular): straightforward &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html&quot;&gt;unix&lt;/a&gt; interfaces
and the asynchronous programming libraries &lt;a href=&quot;http://ocsigen.org/lwt/&quot;&gt;lwt&lt;/a&gt; and &lt;a href=&quot;https://realworldocaml.org/v1/en/html/concurrent-programming-with-async.html&quot;&gt;async&lt;/a&gt;. One of the
early considerations was not to restrict ourselves to any of those -- we wanted
to support them all.&lt;/p&gt;
&lt;p&gt;There were also two distinct basic &amp;quot;platforms&amp;quot; we wanted to target from the
outset: the case of a simple executable, and the case of &lt;code&gt;Mirage&lt;/code&gt; unikernels.&lt;/p&gt;
&lt;p&gt;So one of the first questions we faced was deciding how to represent
interactions with the network in a portable way. This can be done by
systematically abstracting out the API boundary which gives access to network
operations, but we had a third thing in mind as well: we wanted to exploit the
functional nature of OCaml to its fullest extent!&lt;/p&gt;
&lt;p&gt;Our various prior experiences with Haskell and Idris convinced us to adopt
what is called &amp;quot;purely functional&amp;quot; technique. We believe it to be an approach
which first forces the programmer to give principled answers to all the
difficult design questions (errors and global data-flow) &lt;em&gt;in advance&lt;/em&gt;, and then
leads to far cleaner and composable code later on. A purely functional system
has all the data paths made completely explicit in the form of function
arguments and results. There are no unaccounted-for interactions between
components mediated by shared state, and all the activity of the parts of the
system is exposed through types since, after all, it's only about computing
values from values.&lt;/p&gt;
&lt;p&gt;For these reasons, the library is split into two parts: the directory &lt;code&gt;/lib&lt;/code&gt;
(and the corresponding findlib package &lt;code&gt;tls&lt;/code&gt;) contains the core TLS logic, and
&lt;code&gt;/mirage&lt;/code&gt; and &lt;code&gt;/lwt&lt;/code&gt; (packaged as &lt;code&gt;tls.mirage&lt;/code&gt; and &lt;code&gt;tls.lwt&lt;/code&gt; respectively)
contain front-ends that tie the core to &lt;code&gt;Mirage&lt;/code&gt; and &lt;code&gt;Lwt_unix&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Core&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.mli&quot;&gt;core&lt;/a&gt; library is purely functional. A TLS session is represented by the
abstract type &lt;code&gt;Tls.Engine.state&lt;/code&gt;, and various functions consume this session
type together with raw bytes (&lt;code&gt;Cstruct.t&lt;/code&gt; -- which is by itself mutable, but
&lt;code&gt;ocaml-tls&lt;/code&gt; eschews this) and produce new session values and resulting buffers.&lt;/p&gt;
&lt;p&gt;The central entry point is &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L321&quot;&gt;handle_tls&lt;/a&gt;, which transforms an input state and a
buffer to an output state, a (possibly empty) buffer to send to the
communication partner, and an optional buffer of data intended to be received by
the application:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;type state

type ret = [
  | `Ok of [ `Ok of state | `Eof | `Alert of alert ] *
      [ `Response of Cstruct.t ] * [ `Data of Cstruct.t option ]
  | `Fail of alert * [ `Response of Cstruct.t ]
]

val handle_tls : state -&amp;gt; Cstruct.t -&amp;gt; ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the signature shows, errors are signalled through the &lt;code&gt;ret&lt;/code&gt; type, which is a &lt;a href=&quot;https://realworldocaml.org/v1/en/html/variants.html#polymorphic-variants&quot;&gt;polymorphic variant&lt;/a&gt;. This
reflects the actual internal structure: all the errors are represented as
values, and operations are composed using an error &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/control.ml&quot;&gt;monad&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Other entry points share the same basic behaviour: they transform the prior
state and input bytes into the later state and output bytes.&lt;/p&gt;
&lt;p&gt;Here's a rough outline of what happens in &lt;code&gt;handle_tls&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TLS packets consist of a header, which contains the protocol
version, length, and content type, and the payload of the given
content type. Once inside our &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L321&quot;&gt;main handler&lt;/a&gt;, we
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L150&quot;&gt;separate&lt;/a&gt; the buffer into TLS records, and
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L275&quot;&gt;process&lt;/a&gt; each individually. We first check that
the version number is correct, then &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L95&quot;&gt;decrypt&lt;/a&gt;, and &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L85&quot;&gt;verify
the mac&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Decrypted data is then &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L240&quot;&gt;dispatched&lt;/a&gt; to one of four
sub-protocol handlers (Handshake, Change Cipher Spec, Alert and
Application Data). Each handler can &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/state.ml#L109&quot;&gt;return&lt;/a&gt; a new
handshake state, outgoing data, application data, the new decryption
state or an error (with the outgoing data being an interleaved list
of buffers and new encryption states).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The outgoing buffers and the encryption states are
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L48&quot;&gt;traversed&lt;/a&gt; to produce the final output to be sent to the
communication partner, and the final encryption, decryption and
handshake states are combined into a new overall state which is
returned to the caller.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Handshake is (by far) the most complex TLS sub-protocol, with an elaborate state
machine. Our &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/handshake_client.ml#L285&quot;&gt;client&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/handshake_server.ml#L247&quot;&gt;server&lt;/a&gt; encode
this state as a &amp;quot;flat&amp;quot; &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/state.ml#L61&quot;&gt;sum type&lt;/a&gt;, with exactly one incoming
message allowed per state. The handlers first &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/reader.ml#L361&quot;&gt;parse&lt;/a&gt; the
handshake packet (which fails in case of malformed or unknown data) and then
dispatch it to the handling function. The &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/state.ml#L92&quot;&gt;handshake state&lt;/a&gt; is
carried around and a fresh one is returned from the handler in case it needs
updates. It consists of a protocol version, the handshake state, configuration,
renegotiation data, and possibly a handshake fragment.&lt;/p&gt;
&lt;p&gt;Logic of both handshake handlers is very localised, and does not mutate any
global data structures.&lt;/p&gt;
&lt;h3&gt;Core API&lt;/h3&gt;
&lt;p&gt;OCaml permits the implementation a module to be exported via a more
abstract &lt;em&gt;signature&lt;/em&gt; that hides the internal representation
details. Our public API for the core library consists of the
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.mli&quot;&gt;Tls.Engine&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/config.mli&quot;&gt;Tls.Config&lt;/a&gt; modules.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Tls.Engine&lt;/code&gt; contains the basic reactive function &lt;code&gt;handle_tls&lt;/code&gt;, mentioned above,
which processes incoming data and optionally produces a response, together with
several operations that allow one to initiate message transfer like
&lt;code&gt;send_application_data&lt;/code&gt; (which processes application-level messages for
sending), &lt;code&gt;send_close_notify&lt;/code&gt; (for sending the ending message) and &lt;code&gt;reneg&lt;/code&gt;
(which initiates full TLS renegotiation).&lt;/p&gt;
&lt;p&gt;The module also contains the only two ways to obtain the initial state:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;val client : Config.client -&amp;gt; (state * Cstruct.t)
val server : Config.server -&amp;gt; state
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is, one needs a configuration value to create it. The &lt;code&gt;Cstruct.t&lt;/code&gt;
that &lt;code&gt;client&lt;/code&gt; emits is the initial Client Hello since in TLS,
the client starts the session.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Tls.Config&lt;/code&gt; synthesizes configurations, separately for client and server
endpoints, through the functions &lt;code&gt;client_exn&lt;/code&gt; and &lt;code&gt;server_exn&lt;/code&gt;. They take a
number of parameters that define a TLS session, check them for consistency, and
return the sanitized &lt;code&gt;config&lt;/code&gt; value which can be used to create a &lt;code&gt;state&lt;/code&gt; and,
thus, a session. If the check fails, they raise an exception.&lt;/p&gt;
&lt;p&gt;The parameters include the pair of a certificate and its private key for the
server, and an &lt;code&gt;X509.Authenticator.t&lt;/code&gt; for the client, both produced by our
&lt;a href=&quot;https://github.com/mirleft/ocaml-x509&quot;&gt;ocaml-x509&lt;/a&gt; library and described in a &lt;a href=&quot;http://mirage.io/blog/introducing-x509&quot;&gt;previous article&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This design reflects our attempts to make the API as close to &amp;quot;fire and forget&amp;quot;
as we could, given the complexity of TLS: we wanted the library to be relatively
straightforward to use, have a minimal API footprint and, above all, fail very
early and very loudly when misconfigured.&lt;/p&gt;
&lt;h3&gt;Effectful front-ends&lt;/h3&gt;
&lt;p&gt;Clearly, reading and writing network data &lt;em&gt;does&lt;/em&gt; change the state of the world.
Having a pure value describing the state of a TLS session is not really useful
once we write something onto the network; it is certainly not the case that we
can use more than one distinct &lt;code&gt;state&lt;/code&gt; to process further data, as only one
value is in sync with the other endpoint at any given time.&lt;/p&gt;
&lt;p&gt;Therefore we wrap the core types into stateful structures loosely inspired by
sockets and provide IO operations on those. The structures of &lt;code&gt;mirage&lt;/code&gt; and &lt;code&gt;lwt&lt;/code&gt;
front-ends mirror one another.&lt;/p&gt;
&lt;p&gt;In both cases, the structure is pull-based in the sense that no processing is
done until the client requires a read, as opposed to a callback-driven design
where the client registers a callback and the library starts spinning in a
listening loop and invoking it as soon as there is data to be processed. We do
this because in an asynchronous context, it is easy to create a callback-driven
interface from a demand-driven one, but the opposite is possible only with
unbounded buffering of incoming data.&lt;/p&gt;
&lt;p&gt;One exception to demand-driven design is the initial session creation: the
library will only yield the connection after the first handshake is over,
ensuring the invariant that it is impossible to interact with a connection if it
hasn't already been fully established.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mirage&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Mirage&lt;/code&gt; &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/mirage/tls_mirage_types.mli&quot;&gt;interface&lt;/a&gt; matches the &lt;a href=&quot;https://github.com/mirage/mirage/blob/ae3c966f8d726dc97208595b8005e02e39478cb1/types/V1.mli#L136&quot;&gt;FLOW&lt;/a&gt;
signature (with additional TLS-specific operations). We provide a functor that
needs to be applied to an underlying TCP module, to obtain a TLS transport on
top. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;module Server (Stack: STACKV4) (Entropy: ENTROPY) (KV: KV_RO) =
struct

  module TLS  = Tls_mirage.Make (Stack.TCPV4) (Entropy)
  module X509 = Tls_mirage.X509 (KV) (Clock)

  let accept conf flow =
    TLS.server_of_tcp_flow conf flow &amp;gt;&amp;gt;= function
    | `Ok tls -&amp;gt;
      TLS.read tls &amp;gt;&amp;gt;= function
      | `Ok buf -&amp;gt;
        TLS.write tls buf &amp;gt;&amp;gt;= fun () -&amp;gt; TLS.close buf

  let start stack e kv =
    TLS.attach_entropy e &amp;gt;&amp;gt;= fun () -&amp;gt;
    lwt authenticator = X509.authenticator kv `Default in
    let conf          = Tls.Config.server_exn ~authenticator () in
    Stack.listen_tcpv4 stack 4433 (accept conf) ;
    Stack.listen stack

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Lwt&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;lwt&lt;/code&gt; interface has &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lwt/tls_lwt.mli&quot;&gt;two layers&lt;/a&gt;. &lt;code&gt;Tls_lwt.Unix&lt;/code&gt; is loosely based
on read/write operations from &lt;code&gt;Lwt_unix&lt;/code&gt; and provides in-place update of
buffers. &lt;code&gt;read&lt;/code&gt;, for example, takes a &lt;code&gt;Cstruct.t&lt;/code&gt; to write into and returns the
number of bytes read. The surrounding module, &lt;code&gt;Tls_lwt&lt;/code&gt;, provides a simpler,
&lt;code&gt;Lwt_io&lt;/code&gt;-compatible API built on top:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;let main host port =
  Tls_lwt.rng_init () &amp;gt;&amp;gt;= fun () -&amp;gt;
  lwt authenticator = X509_lwt.authenticator (`Ca_dir nss_trusted_ca_dir) in
  lwt (ic, oc)      = Tls_lwt.connect ~authenticator (host, port) in
  let req = String.concat &amp;quot;\\r\\n&amp;quot; [
    &amp;quot;GET / HTTP/1.1&amp;quot; ; &amp;quot;Host: &amp;quot; ^ host ; &amp;quot;Connection: close&amp;quot; ; &amp;quot;&amp;quot; ; &amp;quot;&amp;quot;
  ] in
  Lwt_io.(write oc req &amp;gt;&amp;gt;= fun () -&amp;gt; read ic &amp;gt;&amp;gt;= print)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have further plans to provide wrappers for &lt;a href=&quot;https://realworldocaml.org/v1/en/html/concurrent-programming-with-async.html&quot;&gt;&lt;code&gt;Async&lt;/code&gt;&lt;/a&gt; and plain &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; in a
similar vein.&lt;/p&gt;
&lt;h3&gt;Attacks on TLS&lt;/h3&gt;
&lt;p&gt;TLS the most widely deployed security protocol on the Internet and, at
over 15 years, is also showing its age. As such, a flaw is a valuable
commodity due to the commercially sensitive nature of data that is
encrypted with TLS. Various vulnerabilities on different layers of TLS
have been found - &lt;a href=&quot;https://en.wikipedia.org/wiki/Heartbleed&quot;&gt;heartbleed&lt;/a&gt; and others are implementation
specific, advancements in cryptanalysis such as &lt;a href=&quot;http://eprint.iacr.org/2005/067&quot;&gt;collisions of
MD5&lt;/a&gt; lead to vulnerabilities, and even others are due
to incorrect usage of TLS (&lt;a href=&quot;http://www.theregister.co.uk/2013/08/01/gmail_hotmail_hijacking/&quot;&gt;truncation attack&lt;/a&gt; or
&lt;a href=&quot;http://breachattack.com/&quot;&gt;BREACH&lt;/a&gt;). Finally, some weaknesses are in the protocol
itself. Extensive &lt;a href=&quot;http://eprint.iacr.org/2013/049.pdf&quot;&gt;overviews&lt;/a&gt; of &lt;a href=&quot;http://www.mitls.org/wsgi/tls-attacks&quot;&gt;attacks on
TLS&lt;/a&gt; are available.&lt;/p&gt;
&lt;p&gt;We look at protocol level attacks of TLS and how &lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;ocaml-tls&lt;/a&gt;
implements mitigations against these.  &lt;a href=&quot;https://tools.ietf.org/html/rfc5246#appendix-D.4&quot;&gt;TLS 1.2 RFC&lt;/a&gt; provides an
overview of attacks and mitigations, and we &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues/31&quot;&gt;track&lt;/a&gt; our progress in
covering them. This is slightly out of date as the RFC is roughly six years old and
in the meantime more attacks have been published, such as the &lt;a href=&quot;http://www.educatedguesswork.org/2009/11/understanding_the_tls_renegoti.html&quot;&gt;renegotiation
flaw&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As &lt;a href=&quot;http://mirage.io/blog/introducing-ocaml-tls&quot;&gt;already mentioned&lt;/a&gt;, we track all our
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues?labels=security%20concern&amp;amp;page=1&amp;amp;state=closed&quot;&gt;mitigated&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues?labels=security%20concern&amp;amp;page=1&amp;amp;state=open&quot;&gt;open&lt;/a&gt; security issues on our GitHub
issue tracker.&lt;/p&gt;
&lt;p&gt;Due to the choice of using OCaml, a memory managed programming
language, we obstruct entire bug classes, namely temporal and spatial
memory safety.&lt;/p&gt;
&lt;p&gt;Cryptanalysis and improvement of computational power weaken some
ciphers, such as RC4 and 3DES (see &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues/8&quot;&gt;issue 8&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues/10&quot;&gt;issue
10&lt;/a&gt;). If we phase these two ciphers out, there wouldn't be
any matching ciphersuite left to communicate with some compliant TLS-1.0
implementations, such as Windows XP, that do not support AES.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Timing attacks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When the timing characteristics between the common case and the error
case are different, this might potentially leak confidential
information. Timing is a very prominent side-channel and there are a huge
variety of timing attacks on different layers, which are observable by
different attackers. Small differences in timing behaviour might
initially be exploitable only by a local attacker, but advancements to
the attack (e.g. increasing the number of tests) might allow a
remote attacker to filter the noise and exploit the different timing
behaviour.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Timing of cryptographic primitives&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We &lt;a href=&quot;http://mirage.io/blog/introducing-nocrypto&quot;&gt;already mentioned&lt;/a&gt; &lt;a href=&quot;http://www.cs.tau.ac.il/~tromer/papers/cache.pdf&quot;&gt;cache&lt;/a&gt; &lt;a href=&quot;http://cr.yp.to/antiforgery/cachetiming-20050414.pdf&quot;&gt;timing&lt;/a&gt;
attacks on our AES implementation, and that we use &lt;a href=&quot;https://en.wikipedia.org/wiki/Blinding_(cryptography)&quot;&gt;blinding&lt;/a&gt;
techniques to mitigate RSA timing attacks.&lt;/p&gt;
&lt;p&gt;By using a memory managed programming language, we open the attack
vector of garbage collector (GC) timing attacks (also mentioned &lt;a href=&quot;http://mirage.io/blog/introducing-nocrypto&quot;&gt;in
our nocrypto introduction&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Furthermore, research has been done on virtual machine side channels
(&lt;a href=&quot;http://eprint.iacr.org/2013/448.pdf&quot;&gt;l3&lt;/a&gt;, &lt;a href=&quot;http://www.cs.unc.edu/~reiter/papers/2012/CCS.pdf&quot;&gt;cross vm&lt;/a&gt; and &lt;a href=&quot;http://fc12.ifca.ai/pre-proceedings/paper_70.pdf&quot;&gt;cache timing&lt;/a&gt;), which we
will need to study and mitigate appropriately.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For the time being we suggest to not use the stack on a multi-tenant
shared host or on a shared host which malicious users might have
access to.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bleichenbacher&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In 1998, Daniel Bleichenbacher discovered a &lt;a href=&quot;http://archiv.infsec.ethz.ch/education/fs08/secsem/Bleichenbacher98.pdf&quot;&gt;timing flaw in the
PKCS1&lt;/a&gt; encoding of the premaster secret: the TLS server
failed faster when the padding was wrong than when the decryption
failed. Using this timing, an attacker can run an adaptive chosen
ciphertext attack and find out the plain text of a PKCS1 encrypted
message. In TLS, when RSA is used as the key exchange method, this
leads to discovery of the premaster secret, which is used to derive the
keys for the current session.&lt;/p&gt;
&lt;p&gt;The mitigation is to have both padding and decryption failures use the
exact same amount of time, thus there should not be any data-dependent
branches or different memory access patterns in the code. We
implemented this mitigation in &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/handshake_server.ml#L45&quot;&gt;Handshake_server&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Padding oracle and CBC timing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.iacr.org/archive/eurocrypt2002/23320530/cbc02_e02d.pdf&quot;&gt;Vaudenay&lt;/a&gt; discovered a vulnerability involving block ciphers: if an
attacker can distinguish between bad mac and bad padding, recovery of
the plaintext is possible (within an adaptive chosen ciphertext
attack). Another approach using the same issue is to use
&lt;a href=&quot;http://lasecwww.epfl.ch/memo/memo_ssl.shtml&quot;&gt;timing&lt;/a&gt; information instead of separate error messages.
Further details are described &lt;a href=&quot;https://www.openssl.org/~bodo/tls-cbc.txt&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The countermeasure, which we implement &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/engine.ml#L100&quot;&gt;here&lt;/a&gt;, is to continue
with the mac computation even though the padding is
incorrect. Furthermore, we send the same alert (&lt;code&gt;bad_record_mac&lt;/code&gt;)
independent of whether the padding is malformed or the mac is
incorrect.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lucky 13&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An advancement of the CBC timing attack was discovered in 2013, named
&lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/Lucky13.html&quot;&gt;Lucky 13&lt;/a&gt;. Due to the fact that the mac is computed over the
plaintext without padding, there is a slight (but measurable)
difference in timing between computing the mac of the plaintext and
computing the fake mac of the ciphertext. This leaks information. We
do not have proper mitigation against Lucky 13 in place yet.  You can
find further discussion in &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues/7&quot;&gt;issue 7&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/pull/49&quot;&gt;pull request
49&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Renegotiation not authenticated&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In 2009, Marsh Ray published a vulnerability of the TLS protocol which
lets an attacker prepend arbitrary data to a session due to
&lt;a href=&quot;http://www.educatedguesswork.org/2009/11/understanding_the_tls_renegoti.html&quot;&gt;unauthenticated renegotiation&lt;/a&gt;. The attack
exploits the fact that a renegotiation of ciphers and key material is
possible within a session, and this renegotiated handshake is not
authenticated by the previous handshake. A man in the middle can
initiate a session with a server, send some data, and hand over the
session to a client. Neither the client nor the server can detect the
man in the middle.&lt;/p&gt;
&lt;p&gt;A fix for this issue is the &lt;a href=&quot;https://tools.ietf.org/html/rfc5746&quot;&gt;secure renegotiation extension&lt;/a&gt;,
which embeds authenticated data of the previous handshake into the
client and server hello messages. Now, if a man in the middle
initiates a renegotiation, the server will not complete it due to
missing authentication data (the client believes this is the first
handshake).&lt;/p&gt;
&lt;p&gt;We implement and require the secure renegotiation extension by
default, but it is possible to configure &lt;code&gt;ocaml-tls&lt;/code&gt; to not require
it -- to be able to communicate with servers and
clients which do not support this extension.&lt;/p&gt;
&lt;p&gt;Implementation of the mitigation is on the server side in
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/handshake_server.ml#L85&quot;&gt;ensure_reneg&lt;/a&gt; and on the client side in &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/handshake_client.ml#L50&quot;&gt;validate_reneg&lt;/a&gt;. The
data required for the secure renegotiation is stored in
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/state.ml#L97&quot;&gt;&lt;code&gt;handshake_state&lt;/code&gt;&lt;/a&gt; while sending and receiving Finished
messages. You can find further discussion in &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues/3&quot;&gt;issue 3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS 1.0 and known-plaintext (BEAST)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TLS 1.0 reuses the last ciphertext block as IV in CBC mode. If an attacker
has a (partially) known plaintext, she can find the remaining plaintext.
This is known as the &lt;a href=&quot;http://vnhacker.blogspot.co.uk/2011/09/beast.html&quot;&gt;BEAST&lt;/a&gt; attack and there is a &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=665814&quot;&gt;long discussion&lt;/a&gt;
about mitigations. Our mitigation is to prepend each TLS-1.0
application data fragment with an empty fragment to randomize the IV.
We do this exactly &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/engine.ml#L375&quot;&gt;here&lt;/a&gt;. There is further discussion in
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues/2&quot;&gt;issue 2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Our mitigation is slightly different from the 1/n-1 splitting proposed
&lt;a href=&quot;https://community.qualys.com/blogs/securitylabs/2013/09/10/is-beast-still-a-threat&quot;&gt;here&lt;/a&gt;: we split every application data frame into a 0 byte
and n byte frame, whereas they split into a 1 byte and a n-1 byte
frame.&lt;/p&gt;
&lt;p&gt;Researchers have exploited this vulnerability in 2011, although it was
known since &lt;a href=&quot;http://eprint.iacr.org/2006/136&quot;&gt;2006&lt;/a&gt;. TLS versions 1.1 and 1.2 use an explicit IV,
instead of reusing the last cipher block on the wire.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Compression and information leakage (CRIME)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When using compression on a chosen-plaintext, encrypting this can leak
information, known as &lt;a href=&quot;http://arstechnica.com/security/2012/09/crime-hijacks-https-sessions/&quot;&gt;CRIME&lt;/a&gt;. &lt;a href=&quot;http://breachattack.com/&quot;&gt;BREACH&lt;/a&gt; furthermore
exploits application layer compression, such as HTTP compression. We
mitigate CRIME by not providing any TLS compression support, while we
cannot do anything to mitigate BREACH.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Traffic analysis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Due to limited amount of padding data, the actual size of transmitted
data can be recovered. The mitigation is to implement &lt;a href=&quot;http://tools.ietf.org/html/draft-pironti-tls-length-hiding-02&quot;&gt;length hiding
policies&lt;/a&gt;. This is tracked as &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues/162&quot;&gt;issue 162&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Version rollback&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SSL-2.0 is insecure, a man in the middle can downgrade the version to
SSL-2.0. The mitigation we implement is that we do not support
SSL-2.0, and thus cannot be downgraded. Also, we check that the
version of the client hello matches the first two bytes in the
premaster secret &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/handshake_server.ml#L55&quot;&gt;here&lt;/a&gt;. You can find further discussion in
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues/5&quot;&gt;issue 5&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Triple handshake&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A vulnerability including session resumption and renegotiation was
discovered by the &lt;a href=&quot;http://www.mitls.org&quot;&gt;miTLS team&lt;/a&gt;, named &lt;a href=&quot;https://secure-resumption.com/&quot;&gt;triple
handshake&lt;/a&gt;.  Mitigations include disallowing renegotiation,
disallowing modification of the certificate during renegotiation, or
a hello extension. Since we do not support session resumption yet, we
have not yet implemented any of the mentioned mitigations. There is
further discussion in &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/issues/9&quot;&gt;issue 9&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Alert attack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A &lt;a href=&quot;http://www.mitls.org/wsgi/alert-attack&quot;&gt;fragment of an alert&lt;/a&gt; can be sent by a man in the
middle during the initial handshake. If the fragment is not cleared
once the handshake is finished, the authentication of alerts is
broken. This was discovered in 2012; our mitigation is to discard
fragmented alerts.&lt;/p&gt;
&lt;h3&gt;EOF.&lt;/h3&gt;
&lt;p&gt;Within six months, two hackers managed to develop a clean-slate TLS
stack, together with required crypto primitives, ASN.1, and X.509
handling, in a high-level pure language. We interoperate with widely
deployed TLS stacks, as shown by our &lt;a href=&quot;https://tls.nqsb.io&quot;&gt;demo server&lt;/a&gt;.  The code
size is nearly two orders of magnitude smaller than OpenSSL, the most
widely used open source library (written in C, which a lot of
programming languages wrap instead of providing their own TLS
implementation). Our code base seems to be robust -- the &lt;a href=&quot;https://tls.nqsb.io&quot;&gt;demo
server&lt;/a&gt; successfully finished over 22500 sessions in less than a
week, with only 11 failing traces.&lt;/p&gt;
&lt;p&gt;There is a huge need for high quality TLS implementations, because
several TLS implementations suffered this year from severe security
problems, such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Heartbleed&quot;&gt;heartbleed&lt;/a&gt;, &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1266&quot;&gt;goto fail&lt;/a&gt;, &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3466&quot;&gt;session
id&lt;/a&gt;, &lt;a href=&quot;http://armoredbarista.blogspot.de/2014/04/easter-hack-even-more-critical-bugs-in.html&quot;&gt;Bleichenbacher&lt;/a&gt;, &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0224&quot;&gt;change cipher
suite&lt;/a&gt; and &lt;a href=&quot;https://polarssl.org/tech-updates/security-advisories/polarssl-security-advisory-2014-02&quot;&gt;GCM DoS&lt;/a&gt;. The main cause is
implementation complexity due to lack of abstraction, and memory
safety issues.&lt;/p&gt;
&lt;p&gt;We still need to address some security issues, and improve our performance. We
invite people to do rigorous code audits (both manual and automated) and try
testing our code in their services.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Please be aware that this release is a &lt;em&gt;beta&lt;/em&gt; and is missing external code audits.
It is not yet intended for use in any security critical applications.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Acknowledgements&lt;/h3&gt;
&lt;p&gt;Since this is the final post in our series, we would like to thank all
people who reported issues so far: &lt;a href=&quot;http://anil.recoil.org/&quot;&gt;Anil Madhavapeddy&lt;/a&gt;, &lt;a href=&quot;https://github.com/edwintorok&quot;&gt;T&amp;ouml;r&amp;ouml;k
Edwin&lt;/a&gt;, &lt;a href=&quot;http://erratique.ch/&quot;&gt;Daniel B&amp;uuml;nzli&lt;/a&gt;, &lt;a href=&quot;http://blog.andreas.org/&quot;&gt;Andreas Bogk&lt;/a&gt;, &lt;a href=&quot;http://gregorkopf.de/blog/&quot;&gt;Gregor Kopf&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/graham_steel&quot;&gt;Graham
Steel&lt;/a&gt;, &lt;a href=&quot;https://github.com/vouillon&quot;&gt;Jerome Vouillon&lt;/a&gt;, &lt;a href=&quot;http://amirchaudhry.com/&quot;&gt;Amir Chaudhry&lt;/a&gt;,
&lt;a href=&quot;http://ashishagarwal.org&quot;&gt;Ashish Agarwal&lt;/a&gt;. Additionally, we want to thank the
&lt;a href=&quot;http://www.mitls.org&quot;&gt;miTLS&lt;/a&gt; team (especially Cedric and Karthikeyan) for fruitful
discussions, as well as the &lt;a href=&quot;http://www.cl.cam.ac.uk/projects/ocamllabs/&quot;&gt;OCaml Labs&lt;/a&gt; and
&lt;a href=&quot;http://mirage.io&quot;&gt;Mirage&lt;/a&gt; teams. And thanks to &lt;a href=&quot;http://www.cl.cam.ac.uk/~pes20/&quot;&gt;Peter Sewell&lt;/a&gt; and
&lt;a href=&quot;http://www.cs.nott.ac.uk/~rmm/&quot;&gt;Richard Mortier&lt;/a&gt; for funding within the &lt;a href=&quot;http://rems.io&quot;&gt;REMS&lt;/a&gt;, &lt;a href=&quot;http://usercentricnetworking.eu/&quot;&gt;UCN&lt;/a&gt;, and &lt;a href=&quot;http://www.horizon.ac.uk&quot;&gt;Horizon&lt;/a&gt;
projects. The software was started in &lt;a href=&quot;http://www.aftasmirleft.com/&quot;&gt;Aftas beach house&lt;/a&gt; in
Mirleft, Morocco.&lt;/p&gt;
&lt;img src=&quot;https://mirage.io/graphics/aftas-mirleft.jpg&quot; alt=&quot;Aftas Beach&quot;/&gt;
&lt;hr/&gt;
&lt;p&gt;Posts in this TLS series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-ocaml-tls&quot;&gt;Introducing transport layer security (TLS) in pure OCaml&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-nocrypto&quot;&gt;OCaml-TLS: building the nocrypto library core&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-x509&quot;&gt;OCaml-TLS: adventures in X.509 certificate parsing and validation&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-asn1&quot;&gt;OCaml-TLS: ASN.1 and notation embedding&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation&quot;&gt;OCaml-TLS: the protocol implementation and mitigations to known attacks&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </content><id>https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation</id><title type="text">OCaml-TLS: the protocol implementation and mitigations to known attacks</title><updated>2014-07-14T00:00:00-00:00</updated><author><name>David Kaloper</name></author></entry><entry><link href="https://mirage.io/blog/introducing-asn1" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;em&gt;This is the fourth in a series of posts that introduce new libraries for a pure OCaml implementation of TLS.
You might like to begin with the &lt;a href=&quot;https://mirage.io/blog/introducing-ocaml-tls&quot;&gt;introduction&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirleft/ocaml-asn1-combinators&quot;&gt;asn1-combinators&lt;/a&gt; is a library that allows one to express
&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One&quot;&gt;ASN.1&lt;/a&gt; grammars directly in OCaml, manipulate them as first-class entities,
combine them with one of several ASN encoding rules and use the result to parse
or serialize values.&lt;/p&gt;
&lt;p&gt;It is the parsing and serialization backend for our &lt;a href=&quot;https://github.com/mirleft/ocaml-x509&quot;&gt;X.509&lt;/a&gt;
certificate library, which in turn provides certificate handling for
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;ocaml-tls&lt;/a&gt;.
We wrote about the X.509 certificate handling &lt;a href=&quot;https://mirage.io/blog/introducing-x509&quot;&gt;yesterday&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;What is ASN.1, really?&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One&quot;&gt;ASN.1&lt;/a&gt; (Abstract Syntax Notation, version one) is a way to describe
on-the-wire representation of messages. It is split into two components: a way
to describe the content of a message, i.e. a notation for its abstract syntax,
and a series of standard encoding rules that define the exact byte
representations of those syntaxes. It is defined in ITU-T standards X.680-X.683
and X.690-X.695.&lt;/p&gt;
&lt;p&gt;The notation itself contains primitive grammar elements, such as &lt;code&gt;BIT STRING&lt;/code&gt; or
&lt;code&gt;GeneralizedTime&lt;/code&gt;, and constructs that allow for creation of compound grammars
from other grammars, like &lt;code&gt;SEQUENCE&lt;/code&gt;. The notation is probably best introduced
through a real-world example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- Simple name bindings
UniqueIdentifier ::= BIT STRING

-- Products
Validity ::= SEQUENCE {
  notBefore Time,
  notAfter  Time
}

-- Sums
Time ::= CHOICE {
  utcTime     UTCTime,
  generalTime GeneralizedTime
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Example from &lt;a href=&quot;http://tools.ietf.org/html/rfc5280#appendix-A.2&quot;&gt;RFC 5280&lt;/a&gt;, the RFC that describes X.509
certificates which heavily rely on ASN.)&lt;/p&gt;
&lt;p&gt;The first definition shows that we can introduce an alias for any existing ASN
grammar fragment, in this case the primitive &lt;code&gt;BIT STRING&lt;/code&gt;. The second and third
definitions are, at least morally, a product and a sum.&lt;/p&gt;
&lt;p&gt;At their very core, ASN grammars look roughly like algebraic data types, with a
range of pre-defined primitive grammar fragments like &lt;code&gt;BIT STRING&lt;/code&gt;, &lt;code&gt;INTEGER&lt;/code&gt;,
&lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;BOOLEAN&lt;/code&gt; or even &lt;code&gt;GeneralizedTime&lt;/code&gt;, and a number of combining
constructs that can be understood as denoting sums and products.&lt;/p&gt;
&lt;p&gt;Definitions such as the above are arranged into named modules. The standard even
provides for some abstractive capabilities: initially just a macro facility, and
later a form of parameterized interfaces.&lt;/p&gt;
&lt;p&gt;To facilitate actual message transfer, a grammar needs to be coupled with an
encoding. By far the most relevant ones are Basic Encoding Rules (BER) and
Distinguished Encoding Rules (DER), although other encodings exist.&lt;/p&gt;
&lt;p&gt;BER and DER are tag-length-value (TLV) encodings, meaning that every value is
encoded as a triplet containing a tag that gives the interpretation of its
contents, a length field, and the actual contents which can in turn contain
other TLV triplets.&lt;/p&gt;
&lt;p&gt;Let's drop the time from the example above, as time encoding is a little
involved, and assume a simpler version for a moment:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Pair ::= SEQUENCE {
  car Value,
  cdr Value
}

Value ::= CHOICE {
  v_str UTF8String,
  v_int INTEGER
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then two possible BER encodings of a &lt;code&gt;Pair&lt;/code&gt; &lt;code&gt;(&amp;quot;foo&amp;quot;, 42)&lt;/code&gt; are:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  30         - SEQUENCE            30         - SEQUENCE
  08         - length              0c         - length
  [ 0c       - UTF8String          [ 2c       - UTF8String, compound
    03       - length                07       - length
    [ 66     - 'f'                   [ 0c     - UTF8String
      6f     - 'o'                     01     - length
      6f ]   - 'o'                     [ 66 ] - 'f'
    02       - INTEGER                 0c     - UTF8String
    01       - length                  02     - length
    [ 2a ] ] - 42                      [ 6f   - 'o'
                                         6f ] - 'o'
                                     02       - INTEGER
                                     01       - length
                                     [ 2a ] ] - 42
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The left one is also the only valid DER encoding of this value: BER allows
certain freedoms in encoding, while DER is just a BER subset without those
freedoms. The property of DER that any value has exactly one encoding is useful,
for example, when trying to digitally sign a value.&lt;/p&gt;
&lt;p&gt;If this piqued your curiosity about ASN, you might want to take a detour and
check out this &lt;a href=&quot;http://luca.ntop.org/Teaching/Appunti/asn1.html&quot;&gt;excellent writeup&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;A bit of history&lt;/h3&gt;
&lt;p&gt;The description above paints a picture of a technology a little like &lt;a href=&quot;https://code.google.com/p/protobuf/&quot;&gt;Google's
Protocol Buffers&lt;/a&gt; or &lt;a href=&quot;https://thrift.apache.org/&quot;&gt;Apache Thrift&lt;/a&gt;: a way to declaratively
specify the structure of a set of values and derive parsers and serializers,
with the addition of multiple concrete representations.&lt;/p&gt;
&lt;p&gt;But the devil is in the detail. For instance, the examples above intentionally
gloss over the fact that often concrete tag values &lt;a href=&quot;http://tools.ietf.org/html/rfc5280#page-128&quot;&gt;leak&lt;/a&gt; into
the grammar specifications for various disambiguation reasons. And ASN has more
than 10 different &lt;a href=&quot;http://www.obj-sys.com/asn1tutorial/node128.html&quot;&gt;string types&lt;/a&gt;, most of which use
long-obsolete character encodings. Not to mention that the full standard is
close to 200 pages of relatively dense language and quite difficult to
follow. In general, ASN seems to have too many features for the relatively
simple task it is solving, and its specification has evolved over decades, apparently
trying to address various other semi-related problems, such as providing a
general &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_Object_Class_(ASN.1)&quot;&gt;Interface Description Language&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Which is to say, ASN is &lt;em&gt;probably&lt;/em&gt; not what you are looking for. So why
implement it?&lt;/p&gt;
&lt;p&gt;Developed in the context of the telecom industry around 30 years ago, modified
several times after that and apparently suffering from a lack of a coherent
goal, by the early 90s ASN was still probably the only universal, machine- and
architecture-independent external data representation.&lt;/p&gt;
&lt;p&gt;So it came easily to hand around the time RSA Security started publishing its
series of &lt;a href=&quot;https://en.wikipedia.org/wiki/PKCS&quot;&gt;PKCS&lt;/a&gt; standards, aimed at the standardization of
cryptographic material exchange. RSA keys and digital signatures are often
exchanged ASN-encoded.&lt;/p&gt;
&lt;p&gt;At roughly the same time, ITU-T started publishing the &lt;a href=&quot;https://en.wikipedia.org/wiki/X.500&quot;&gt;X.500&lt;/a&gt; series
of standards which aimed to provide a comprehensive directory service. Much of
this work ended up as LDAP, but one little bit stands out in particular: the
&lt;a href=&quot;https://en.wikipedia.org/wiki/X.509&quot;&gt;X.509&lt;/a&gt; PKI certificate.&lt;/p&gt;
&lt;p&gt;So a few years later, when Netscape tried to build an authenticated and
confidential layer to tunnel HTTP through, they based it on -- amongst other
things -- X.509 certificates. Their work went through several revisions as SSL
and was finally standardized as TLS. Modern TLS still requires X.509.&lt;/p&gt;
&lt;p&gt;Thus, even though TLS uses ASN only for encoding certificates (and the odd PKCS1
signature), every implementation needs to know how to deal with ASN. In fact,
many other general cryptographic libraries also need to deal with ASN, as various PKCS
standards mandate ASN as the encoding for exchange of cryptographic material.&lt;/p&gt;
&lt;h3&gt;The grammar of the grammar&lt;/h3&gt;
&lt;p&gt;As its name implies, ASN was meant to be used with a specialized compiler. ASN
is really a standard for &lt;em&gt;writing down&lt;/em&gt; abstract syntaxes, and ASN compilers
provided with the target encoding will generate code in your programming
language of choice that, when invoked, parses to or serializes from ASN.&lt;/p&gt;
&lt;p&gt;As long as your programming language of choice is C, C++, Java or C#, obviously
-- there doesn't seem to be one freely available that targets OCaml. In any case, generating code for such a high-level language feels wrong somehow. In
its effort to be language-neutral, ASN needs to deal with things like modules,
abstraction and composition. At this point, most functional programmers reading
this are screaming: &amp;quot;I &lt;em&gt;already&lt;/em&gt; have a language that can deal with modules,
abstraction and composition perfectly well!&amp;quot;&lt;/p&gt;
&lt;p&gt;So we're left with implementing ASN in OCaml.&lt;/p&gt;
&lt;p&gt;One strategy is to provide utility functions for parsing elements of ASN and
simply invoke them in the appropriate order, as imposed by the target grammar.
This amounts to hand-writing the parser and is what TLS libraries in C
typically do.&lt;/p&gt;
&lt;p&gt;As of release 1.3.7, &lt;a href=&quot;https://github.com/polarssl/polarssl/tree/development/library&quot;&gt;PolarSSL&lt;/a&gt; includes ~7,500 lines of rather
beautifully written C, that implement a specialized parser for dealing with
X.509. OpenSSL's &lt;a href=&quot;https://github.com/openssl/openssl&quot;&gt;libcrypto&lt;/a&gt; contains ~50,000 lines of C in its
&lt;a href=&quot;https://github.com/openssl/openssl/tree/e3ba6a5f834f24aa5ffe9bc1849e3410c87388d5/crypto/asn1&quot;&gt;'asn1'&lt;/a&gt;, &lt;a href=&quot;https://github.com/openssl/openssl/tree/e3ba6a5f834f24aa5ffe9bc1849e3410c87388d5/crypto/x509&quot;&gt;'x509'&lt;/a&gt; and
&lt;a href=&quot;https://github.com/openssl/openssl/tree/e3ba6a5f834f24aa5ffe9bc1849e3410c87388d5/crypto/x509v3&quot;&gt;'x509v3'&lt;/a&gt; directories, and primarily deals with X.509
specifically as required by TLS.&lt;/p&gt;
&lt;p&gt;In both cases, low-level control flow is intertwined with the parsing logic and,
above the ASN parsing level, the code that deals with interpreting the ASN
structure is not particularly concise.
It is certainly a far cry from the (relatively)
simple grammar description ASN itself provides.&lt;/p&gt;
&lt;p&gt;Since in BER every value fully describes itself, another strategy is to parse
the input stream without reference to the grammar. This produces a value that
belongs to the general type of all ASN-encoded trees, after which we need to
process the &lt;em&gt;structure&lt;/em&gt; according to the grammar. This is similar to a common
treatment of JSON or XML, where one decouples parsing of bytes from the
higher-level concerns about the actual structure contained therein. The problem
here is that either the downstream client of such a parser needs to constantly
re-check whether the parts of the structure it's interacting with are really
formed according to the grammar (probably leading to a tedium of
pattern-matches), or we have to turn around and solve the parsing problem
&lt;em&gt;again&lt;/em&gt;, mapping the uni-typed contents of a message to the actual, statically
known structure we require the message to have.&lt;/p&gt;
&lt;p&gt;Surely we can do better?&lt;/p&gt;
&lt;h3&gt;LAMBDA: The Ultimate Declarative&lt;/h3&gt;
&lt;p&gt;Again, ASN is a language with a number of built-in primitives, a few combining
constructs, (recursive) name-binding and a module system. Our target language is
a language with a perfectly good module system and it can certainly express
combining constructs. It includes an abstraction mechanism arguably far simpler
and easier to use than those of ASN, namely, functions. And the OCaml compilers
can already parse OCaml sources. So why not just reuse this machinery?&lt;/p&gt;
&lt;p&gt;The idea is familiar. Creating embedded languages for highly declarative
descriptions within narrowly defined problem spaces is the staple of functional
programming. In particular, combinatory parsing has been known, studied and
used for &lt;a href=&quot;http://comjnl.oxfordjournals.org/content/32/2/108.short&quot;&gt;decades&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, we also have to diverge from traditional parser combinators in two major ways.
Firstly, a single grammar expression needs to be able to generate
different concrete parsers, corresponding to different ASN encodings. More
importantly, we desire our grammar descriptions to act &lt;strong&gt;bidirectionally&lt;/strong&gt;,
producing both parsers and complementary deserializers.&lt;/p&gt;
&lt;p&gt;The second point severely restricts the signatures we can support. The usual
monadic parsers are off the table because the expression such as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;( (pa : a t) &amp;gt;&amp;gt;= fun (a : a) -&amp;gt;
  (pb : b t) &amp;gt;&amp;gt;= fun (b : b) -&amp;gt;
  return (b, b, a) ) : (b * b * a) t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... &amp;quot;hides&amp;quot; parts of the parser inside the closures, especially the method of
mapping the parsed values into the output values, and can not be run &amp;quot;in
reverse&amp;quot; [&lt;a href=&quot;https://mirage.io/feed.xml#footnote-1&quot;&gt;1&lt;/a&gt;].&lt;/p&gt;
&lt;p&gt;We have a similar problem with &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;applicative functors&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;( (fun a b -&amp;gt; (b, b, a))
  &amp;lt;$&amp;gt; (pa : a t)
  &amp;lt;*&amp;gt; (pb : b t) ) : (b * b * a) t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Given the usual &lt;code&gt;&amp;lt;$&amp;gt; : ('a -&amp;gt; 'b) -&amp;gt; 'a t -&amp;gt; 'b t&lt;/code&gt; and &lt;code&gt;&amp;lt;*&amp;gt; : ('a -&amp;gt; 'b) t -&amp;gt; 'a t -&amp;gt; 'b t&lt;/code&gt;.) Although the elements of ASN syntax are now exposed, the process
of going from intermediate parsing results to the result of the whole is still
not accessible.&lt;/p&gt;
&lt;p&gt;Fortunately, due to the regular structure of ASN, we don't really &lt;em&gt;need&lt;/em&gt; the
full expressive power of monadic parsing. The only occurrence of sequential
parsing is within &lt;code&gt;SEQUENCE&lt;/code&gt; and related constructs, and we don't need
look-ahead. All we need to do is provide a few specialized combinators to handle
those cases -- combinators the likes of which would be derived in a
more typical setting.&lt;/p&gt;
&lt;p&gt;So if we imagine we had a few values, like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;val gen_time : gen_time t
val utc_time : utc_time t
val choice   : 'a t -&amp;gt; 'b t -&amp;gt; ('a, 'b) choice t
val sequence : 'a t -&amp;gt; 'b t -&amp;gt; ('a * 'b) t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming appropriate OCaml types &lt;code&gt;gen_time&lt;/code&gt; and &lt;code&gt;utc_time&lt;/code&gt; that reflect their
ASN counterparts, and a simple sum type &lt;code&gt;choice&lt;/code&gt;, we could express the
&lt;code&gt;Validity&lt;/code&gt; grammar above using:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;type time = (gen_time, utc_time) choice
let time     : time t          = choice gen_time utc_time
let validity : (time * time) t = sequence time time
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In fact, ASN maps quite well to algebraic data types. Its &lt;code&gt;SEQUENCE&lt;/code&gt; corresponds
to n-ary products and &lt;code&gt;CHOICE&lt;/code&gt; to sums. ASN &lt;code&gt;SET&lt;/code&gt; is a lot like &lt;code&gt;SEQUENCE&lt;/code&gt;,
except the elements can come in any order; and &lt;code&gt;SEQUENCE_OF&lt;/code&gt; and &lt;code&gt;SET_OF&lt;/code&gt; are
just lifting an &lt;code&gt;'a&lt;/code&gt;-grammar into an &lt;code&gt;'a list&lt;/code&gt;-grammar.&lt;/p&gt;
&lt;p&gt;A small wrinkle is that &lt;code&gt;SEQUENCE&lt;/code&gt; allows for more contextual information on its
components (so does &lt;code&gt;CHOICE&lt;/code&gt; in reality, but we ignore that): elements can carry
labels (which are not used for parsing) and can be marked as optional. So
instead of working directly on the grammars, our &lt;code&gt;sequence&lt;/code&gt; must work on their
annotated versions. A second wrinkle is the arity of the &lt;code&gt;sequence&lt;/code&gt; combinator.&lt;/p&gt;
&lt;p&gt;Thus we introduce the type of annotated grammars, &lt;code&gt;'a element&lt;/code&gt;, which
corresponds to one &lt;code&gt;,&lt;/code&gt;-delimited syntactic element in ASN's own &lt;code&gt;SEQUENCE&lt;/code&gt;
grammar, and the type &lt;code&gt;'a sequence&lt;/code&gt;, which describes the entire contents (&lt;code&gt;{ ... }&lt;/code&gt;) of a &lt;code&gt;SEQUENCE&lt;/code&gt; definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;val required : 'a t -&amp;gt; 'a element
val optional : 'a t -&amp;gt; 'a option element
val ( -@ )   : 'a element -&amp;gt; 'b element -&amp;gt; ('a * 'b) sequence
val ( @ )    : 'a element -&amp;gt; 'a sequence -&amp;gt; ('a * 'b) sequence
val sequence : 'a sequence -&amp;gt; 'a t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following are then equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Triple ::= SEQUENCE {
  a INTEGER,
  b BOOLEAN,
  c BOOLEAN OPTIONAL
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;let triple : (int * (bool * bool option)) t =
  sequence (
      required int
    @ required bool
   -@ optional bool
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also re-introduce functions, but in a controlled manner:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;val map : ('a -&amp;gt; 'b) -&amp;gt; ('b -&amp;gt; 'a) -&amp;gt; 'a t -&amp;gt; 'b t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Keeping in line with the general theme of bidirectionality, we require functions
to come in pairs. The deceptively called &lt;code&gt;map&lt;/code&gt; could also be called &lt;code&gt;iso&lt;/code&gt;, and
comes with a nice property: if the two functions are truly inverses,
the serialization process is fully reversible, and so is parsing, under
single-representation encodings (DER)!&lt;/p&gt;
&lt;h3&gt;ASTs of ASNs&lt;/h3&gt;
&lt;p&gt;To go that last mile, we should probably also &lt;em&gt;implement&lt;/em&gt; what we discussed.&lt;/p&gt;
&lt;p&gt;Traditional parser combinators look a little like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;type 'a p = string -&amp;gt; 'a * string

let bool : bool p = fun str -&amp;gt; (s.[0] &amp;lt;&amp;gt; &amp;quot;\\000&amp;quot;, tail_of_string str)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Usually, the values inhabiting the parser type are the actual parsing functions,
and their composition directly produces larger parsing functions. We would
probably need to represent them with &lt;code&gt;'a p * 'a s&lt;/code&gt;, pairs of a parser and its
inverse, but the same general idea applies.&lt;/p&gt;
&lt;p&gt;Nevertheless, we don't want to do this.
The grammars need to support more than one concrete
parser/serializer, and composing what is common between them and extracting out
what is not would probably turn into a tangled mess. That is one reason. The other is that if we encode the grammar purely as
(non-function) value, we can traverse it for various other purposes.&lt;/p&gt;
&lt;p&gt;So we turn from what is sometimes called &amp;quot;shallow embedding&amp;quot; to &amp;quot;deep
embedding&amp;quot; and try to represent the grammar purely as an algebraic data type.&lt;/p&gt;
&lt;p&gt;Let's try to encode the parser for bools, &lt;code&gt;boolean : bool t&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;type 'a t =
  | Bool
  ...

let boolean : bool t = Bool
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately our constructor is fully polymorphic, of type &lt;code&gt;'a. 'a t&lt;/code&gt;. We can
constrain it for the users, but once we traverse it there is nothing left to
prove its intended association with booleans!&lt;/p&gt;
&lt;p&gt;Fortunately, starting with the release of &lt;a href=&quot;http://ocaml.org/releases/4.00.1.html&quot;&gt;OCaml 4.00.0&lt;/a&gt;,
OCaml joined the ranks of
languages equipped with what is probably the supreme tool of deep embedding,
&lt;a href=&quot;http://en.wikipedia.org/wiki/Generalized_algebraic_data_type&quot;&gt;GADTs&lt;/a&gt;. Using them, we can do things like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;type _ t =
  | Bool   : bool t
  | Pair   : ('a t * 'b t) -&amp;gt; ('a * 'b) t
  | Choice : ('a t * 'b t) -&amp;gt; ('a, 'b) choice t
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In fact, this is very close to how the library is &lt;a href=&quot;https://github.com/mirleft/ocaml-asn1-combinators/blob/4328bf5ee6f20ad25ff7971ee8013f79e5bfb036/src/core.ml#L19&quot;&gt;actually&lt;/a&gt;
implemented.&lt;/p&gt;
&lt;p&gt;There is only one thing left to worry about: ASN definitions can be recursive.
We might try something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;let rec list = choice null (pair int list)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this won't work. Being just trees of applications, our definitions never
contain &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml-400/manual021.html#toc70&quot;&gt;statically constructive&lt;/a&gt; parts -- this expression could never
terminate in a strict language.&lt;/p&gt;
&lt;p&gt;We can get around that by wrapping grammars in &lt;code&gt;Lazy.t&lt;/code&gt; (or just closures), but
this would be too awkward to use. Like many other similar libraries, we need to
provide a fixpoint combinator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;val fix : ('a t -&amp;gt; 'a t) -&amp;gt; 'a t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And get to write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;let list = fix @@ fun list -&amp;gt; choice null (pair int list)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This introduces a small problem. So far we simply reused binding inherited
from OCaml without ever worrying about identifiers and references, but with a
fixpoint, the grammar encodings need to be able to somehow express a cycle.&lt;/p&gt;
&lt;p&gt;Borrowing an idea from higher-order abstract syntax, we can represent the entire
fixpoint node using exactly the function provided to define it, re-using OCaml's
own binding and identifier resolution:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;type _ t =
  | Fix : ('a t -&amp;gt; 'a t) -&amp;gt; 'a t
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This treatment completely sidesteps the problems with variables. We need no
binding environments or De Brujin indices, and need not care about the desired
scoping semantics. A little trade-off is that with this simple encoding it
becomes more difficult to track cycles (when traversing the AST, if we keep
applying a &lt;code&gt;Fix&lt;/code&gt; node to itself while descending into it, it looks like an
infinite tree), but with a little opportunistic caching it all plays out well
[&lt;a href=&quot;https://mirage.io/feed.xml#footnote-2&quot;&gt;2&lt;/a&gt;].&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/mirleft/ocaml-asn1-combinators/blob/4328bf5ee6f20ad25ff7971ee8013f79e5bfb036/src/ber_der.ml#L49&quot;&gt;parser&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirleft/ocaml-asn1-combinators/blob/4328bf5ee6f20ad25ff7971ee8013f79e5bfb036/src/ber_der.ml#L432&quot;&gt;serializer&lt;/a&gt; proper then emerge as interpreters for
this little language of typed trees, traversing them with an input string, and
parsing it in a fully type-safe manner.&lt;/p&gt;
&lt;h3&gt;How does it play out?&lt;/h3&gt;
&lt;p&gt;The entire ASN library comes down to ~1,700 lines of OCaml, with around ~1,100
more in tests, giving a mostly-complete treatment of BER and DER.&lt;/p&gt;
&lt;p&gt;Its main use so far is in the context of the &lt;code&gt;X.509&lt;/code&gt; library
(discussed &lt;a href=&quot;https://mirage.io/blog/introducing-x509&quot;&gt;yesterday&lt;/a&gt;). It allowed the
grammar of certificates and RSA keys, together with a number of transformations
from the raw types to more pleasant, externally facing ones, to be written in
~900 &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/6c96f11a2c7911ae0b308af9b328aee38f48b270/lib/asn_grammars.ml&quot;&gt;lines&lt;/a&gt; of OCaml. And the code looks a lot like the
actual standards the grammars were taken from -- the fragment from the beginning
of this article becomes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;let unique_identifier = bit_string_cs

let time =
  map (function `C1 t -&amp;gt; t | `C2 t -&amp;gt; t) (fun t -&amp;gt; `C2 t)
      (choice2 utc_time generalized_time)

let validity =
  sequence2
    (required ~label:&amp;quot;not before&amp;quot; time)
    (required ~label:&amp;quot;not after&amp;quot;  time)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We added &lt;code&gt;~label&lt;/code&gt; to &lt;code&gt;'a element&lt;/code&gt;-forming injections, and have:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;val choice2 : 'a t -&amp;gt; 'b t -&amp;gt; [ `C1 of 'a | `C2 of 'b ] t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get a sense of how the resulting system eases the translation of standardized
ASN grammars into working code, it is particularly instructive to compare
&lt;a href=&quot;https://github.com/polarssl/polarssl/blob/b9e4e2c97a2e448090ff3fcc0f99b8f6dbc08897/library/x509_crt.c#L531&quot;&gt;these&lt;/a&gt; &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/asn_grammars.ml#L772&quot;&gt;two&lt;/a&gt; definitions.&lt;/p&gt;
&lt;p&gt;Reversibility was a major simplifying factor during development. Since the
grammars are traversable, it is easy to generate their &lt;a href=&quot;https://github.com/mirleft/ocaml-asn1-combinators/blob/cf1a1ffb4a31d02979a6a0bca8fe58856f8907bf/src/asn_random.ml&quot;&gt;random&lt;/a&gt;
inhabitants, encode them, parse the result and verify the reversibility still
&lt;a href=&quot;https://github.com/mirleft/ocaml-asn1-combinators/blob/cf1a1ffb4a31d02979a6a0bca8fe58856f8907bf/tests/testlib.ml#L83&quot;&gt;holds&lt;/a&gt;. This can't help convince us the parsing/serializing pair
is actually correct with respect to ASN, but it gives a simple tool to generate
large amounts of test cases and convince us that that pair is &lt;em&gt;equivalent&lt;/em&gt;. A
number of hand-written cases then check the conformance to the actual ASN.&lt;/p&gt;
&lt;p&gt;As for security, there were two concerns we were aware of. There is a history of
catastrophic &lt;a href=&quot;https://technet.microsoft.com/en-us/library/security/ms04-007.aspx&quot;&gt;buffer overruns&lt;/a&gt; in some ASN.1 implementations,
but -- assuming our compiler and runtime system are correct -- we are immune to
these as we are subject to bounds-checking. And
there are some documented &lt;a href=&quot;https://www.viathinksoft.de/~daniel-marschall/asn.1/oid_facts.html&quot;&gt;problems&lt;/a&gt; with security of X.509
certificate verification due to overflows of numbers in ASN OID types, which we
explicitly guard against.&lt;/p&gt;
&lt;p&gt;You can check our security status on our &lt;a href=&quot;https://github.com/mirleft/ocaml-asn1-combinators/issues?state=open&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Footnotes&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;footnote-1&quot;&gt; &lt;/a&gt; In fact, the problem with embedding functions in
combinator languages, and the fact that in a functional language it is not
possible to extract information from a function other than by applying it,
was discussed more than a decade ago. Such discussions led to the development of
&lt;a href=&quot;http://www.haskell.org/arrows/biblio.html#Hug00&quot;&gt;Arrows&lt;/a&gt;, amongst other things.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;footnote-2&quot;&gt; &lt;/a&gt; Actually, a version of the library used the more
&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=1411226&quot;&gt;proper&lt;/a&gt; encoding to be able to inject results of reducing
referred-to parts of the AST into the referring sites directly, roughly
like &lt;code&gt;Fix : ('r -&amp;gt; ('a, 'r) t) -&amp;gt; ('a, 'r) t&lt;/code&gt;. This approach was abandoned because terms need to be polymorphic in &lt;code&gt;'r&lt;/code&gt;, and this becomes
impossible to hide from the user of the library, creating unwelcome noise.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;
&lt;p&gt;Posts in this TLS series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/introducing-ocaml-tls&quot;&gt;Introducing transport layer security (TLS) in pure OCaml&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/introducing-nocrypto&quot;&gt;OCaml-TLS: building the nocrypto library core&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/introducing-x509&quot;&gt;OCaml-TLS: adventures in X.509 certificate parsing and validation&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/introducing-asn1&quot;&gt;OCaml-TLS: ASN.1 and notation embedding&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation&quot;&gt;OCaml-TLS: the protocol implementation and mitigations to known attacks&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </content><id>https://mirage.io/blog/introducing-asn1</id><title type="text">OCaml-TLS: ASN.1 and notation embedding</title><updated>2014-07-11T00:00:00-00:00</updated><author><name>David Kaloper</name></author></entry><entry><link href="https://mirage.io/blog/introducing-x509" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;em&gt;This is the third in a series of posts that introduce new libraries for a pure OCaml implementation of TLS.
You might like to begin with the &lt;a href=&quot;http://mirage.io/blog/introducing-ocaml-tls&quot;&gt;introduction&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;The problem of authentication&lt;/h3&gt;
&lt;p&gt;The authenticity of the remote server needs to be verified while
establishing a secure connection to it, or else an
attacker (&lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;MITM&lt;/a&gt;) between the client and the server can eavesdrop on
the transmitted data. To the best of our knowledge, authentication
cannot be done solely in-band, but needs external
infrastructure. The most common methods used in practice rely on
public key encryption.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Web of trust&lt;/em&gt; (used by &lt;a href=&quot;https://en.wikipedia.org/wiki/OpenPGP&quot;&gt;OpenPGP&lt;/a&gt;) is a decentralised public key
infrastructure. It relies on out-of-band verification of public keys
and transitivity of trust. If Bob signed Alice's public key, and
Charlie trusts Bob (and signed his public key), then Charlie can trust
that Alice's public key is hers.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Public key infrastructure&lt;/em&gt; (used by &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLS&lt;/a&gt;) relies on trust
anchors which are communicated out-of-band (e.g. distributed with the
client software). In order to authenticate a server, a chain of trust
between a trust anchor and the server certificate (public key) is
established. Only those clients which have the trust anchor deployed
can verify the authenticity of the server.&lt;/p&gt;
&lt;h3&gt;X.509 public key infrastructure&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/X.509&quot;&gt;X.509&lt;/a&gt; is an ITU standard for a public key infrastructure,
developed in 1988. Amongst other things, it specifies the format of
certificates, their attributes, revocation lists, and a path
validation algorithm. X.509 certificates are encoded using abstract
syntax notation one (ASN.1).&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;certificate&lt;/em&gt; contains a public key, a subject (server name), a
validity period, a purpose (i.e. key usage), an issuer, and
possibly other extensions. All components mentioned in the certificate
are signed by an issuer.&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;certificate authority&lt;/em&gt; (CA) receives a certificate signing request
from a server operator. It verifies that this signing request is
legitimate (e.g. requested server name is owned by the server
operator) and signs the request. The CA certificate must be trusted by
all potential clients. A CA can also issue intermediate CA
certificates, which are allowed to sign certificates.&lt;/p&gt;
&lt;p&gt;When a server certificate or intermediate CA certificate is
compromised, the CA publishes this certificate in its certificate
revocation list (CRL), which each client should poll periodically.&lt;/p&gt;
&lt;p&gt;The following certificates are exchanged before a TLS session:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CA -&amp;gt; Client: CA certificate, installed as trust anchor on the client
&lt;/li&gt;
&lt;li&gt;Server -&amp;gt; CA: certificate request, to be signed by the CA
&lt;/li&gt;
&lt;li&gt;CA -&amp;gt; Server: signed server certificate
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;During the TLS handshake the server sends the certificate chain to the
client. When a client wants to verify a certificate, it has to verify
the signatures of the entire chain, and find a trust anchor which
signed the outermost certificate. Further constraints, such as the
maximum chain length and the validity period, are checked as
well. Finally, the server name in the server certificate is checked to
match the expected identity.
For an example, you can see the sequence diagram of the TLS handshake your browser makes when you visit our &lt;a href=&quot;https://tls.nqsb.io&quot;&gt;demonstration server&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Example code for verification&lt;/h3&gt;
&lt;p&gt;OpenSSL implements &lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot;&gt;RFC5280&lt;/a&gt; path validation, but there is no
implementation to validate the identity of a certificate. This has to
be implemented by each client, which is rather complex (e.g. in
&lt;a href=&quot;https://github.com/freebsd/freebsd/blob/bf1a15b165af779577b0278b3d47151edb0d47f9/lib/libfetch/common.c#L326-665&quot;&gt;libfetch&lt;/a&gt; it spans over more than 300 lines). A client of the
&lt;code&gt;ocaml-x509&lt;/code&gt; library (such as our &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lwt/examples/http_client.ml&quot;&gt;http-client&lt;/a&gt;) has to
write only two lines of code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;lwt authenticator = X509_lwt.authenticator (`Ca_dir ca_cert_dir) in
lwt (ic, oc) =
  Tls_lwt.connect_ext
    (Tls.Config.client_exn ~authenticator ())
    (host, port)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The authenticator uses the default directory where trust anchors are
stored (&lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lwt/examples/ex_common.ml#L6&quot;&gt;'ca_cert_dir'&lt;/a&gt;), and this authenticator is
passed to the &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lwt/tls_lwt.ml#L227&quot;&gt;'connect_ext'&lt;/a&gt; function. This initiates
the TLS handshake, and passes the trust anchors and the hostname to
the TLS library.&lt;/p&gt;
&lt;p&gt;During the client handshake when the certificate chain is received by
the server, the given authenticator and hostname are used to
authenticate the certificate chain (in &lt;a href=&quot;https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/handshake_client.ml#L84&quot;&gt;'validate_chain'&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;match
 X509.Authenticator.authenticate ?host:server_name authenticator stack
with
 | `Fail SelfSigned         -&amp;gt; fail Packet.UNKNOWN_CA
 | `Fail NoTrustAnchor      -&amp;gt; fail Packet.UNKNOWN_CA
 | `Fail CertificateExpired -&amp;gt; fail Packet.CERTIFICATE_EXPIRED
 | `Fail _                  -&amp;gt; fail Packet.BAD_CERTIFICATE
 | `Ok                      -&amp;gt; return server_cert
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Internally, &lt;code&gt;ocaml-x509&lt;/code&gt; extracts the hostname list from a
certificate in &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L134-144&quot;&gt;'cert_hostnames'&lt;/a&gt;, and the
&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L325-L346&quot;&gt;wildcard or strict matcher&lt;/a&gt; compares it to the input.
In total, this is less than 50 lines of pure OCaml code.&lt;/p&gt;
&lt;h3&gt;Problems in X.509 verification&lt;/h3&gt;
&lt;p&gt;Several weaknesses in the verification of X.509 certificates have been
discovered, ranging from cryptographic attacks due to
&lt;a href=&quot;http://www.win.tue.nl/~bdeweger/CollidingCertificates/ddl-full.pdf&quot;&gt;collisions in hash algorithms&lt;/a&gt; (&lt;a href=&quot;http://www.win.tue.nl/hashclash/rogue-ca/&quot;&gt;practical&lt;/a&gt;) over
&lt;a href=&quot;http://www.blackhat.com/presentations/bh-usa-09/MARLINSPIKE/BHUSA09-Marlinspike-DefeatSSL-SLIDES.pdf&quot;&gt;misinterpretation of the name&lt;/a&gt; in the certificate (a C
string is terminated by a null byte), and treating X.509 version 1
certificates always as a &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0092&quot;&gt;trust anchor in GnuTLS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;An &lt;a href=&quot;https://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html&quot;&gt;empirical study of software that does certificate
verification&lt;/a&gt; showed that badly designed APIs are the
root cause of vulnerabilities in this area. They tested various
implementations by using a list of certificates, which did not form a
chain, and would not authenticate due to being self-signed, or
carrying a different server name.&lt;/p&gt;
&lt;p&gt;Another recent empirical study (&lt;a href=&quot;http://www.cs.utexas.edu/~suman/publications/frankencert.pdf&quot;&gt;Frankencert&lt;/a&gt;) generated random
certificates and validated these with various stacks. They found lots
of small issues in nearly all certificate verification stacks.&lt;/p&gt;
&lt;p&gt;Our implementation mitigates against some of the known attacks: we
require a complete valid chain, check the extensions of a certificate,
and implement hostname checking as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC6125&lt;/a&gt;. We have a
&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/tree/master/tests&quot;&gt;test suite&lt;/a&gt; with over 3200 tests and multiple CAs. We do not yet discard
certificates which use MD5 as hash algorithm. Our TLS stack
requires certificates to have at least 1024 bit RSA keys.&lt;/p&gt;
&lt;h3&gt;X.509 library internals&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;x509&lt;/code&gt; library uses &lt;a href=&quot;https://github.com/mirleft/ocaml-asn-combinators&quot;&gt;asn-combinators&lt;/a&gt; to parse X.509 certificates and
the &lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto&quot;&gt;nocrypto&lt;/a&gt; library for signature verification
(which we wrote about &lt;a href=&quot;http://mirage.io/blog/introducing-nocrypto&quot;&gt;previously&lt;/a&gt;).
At the moment we do not yet
expose certificate builders from the library, but focus on certificate parsing
and certificate authentication.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml&quot;&gt;x509&lt;/a&gt; module provides modules which parse
PEM-encoded (&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L18&quot;&gt;pem&lt;/a&gt;) certificates (&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L85&quot;&gt;Cert&lt;/a&gt;)
and private keys
(&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L105&quot;&gt;Pk&lt;/a&gt;), and an authenticator module
(&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L123&quot;&gt;Authenticators&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;So far we have two authenticators implemented:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L137&quot;&gt;'chain_of_trust'&lt;/a&gt;, which implements the basic path
validation algorithm from &lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot;&gt;RFC5280&lt;/a&gt; (section 6) and the hostname
validation from &lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC6125&lt;/a&gt;. To construct such an authenticator, a
timestamp and a list of trust anchors is needed.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L142&quot;&gt;'null'&lt;/a&gt;, which always returns success.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The method &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.mli#L42&quot;&gt;'authenticate'&lt;/a&gt;, to be called when a
certificate stack should be verified, receives an authenticator, a
hostname and the certificate stack. It returns either &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Fail&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Our &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/asn_grammars.ml#L734&quot;&gt;certificate type&lt;/a&gt; is very similar to the described structure in the RFC:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;type tBSCertificate = {
  version    : [ `V1 | `V2 | `V3 ] ;
  serial     : Z.t ;
  signature  : Algorithm.t ;
  issuer     : Name.dn ;
  validity   : Time.t * Time.t ;
  subject    : Name.dn ;
  pk_info    : PK.t ;
  issuer_id  : Cstruct.t option ;
  subject_id : Cstruct.t option ;
  extensions : (bool * Extension.t) list
}

type certificate = {
  tbs_cert       : tBSCertificate ;
  signature_algo : Algorithm.t ;
  signature_val  : Cstruct.t
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The certificate itself wraps the to be signed part (&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/asn_grammars.ml#L734&quot;&gt;'tBSCertificate'&lt;/a&gt;),
the used signature algorithm, and the actual signature. It consists of
a version, serial number, issuer, validity, subject, public key
information, optional issuer and subject identifiers, and a list of
extensions -- only version 3 certificates may have extensions.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.mli&quot;&gt;'certificate'&lt;/a&gt; module implements the actual
authentication of certificates, and provides some useful getters such
as &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.ml#L91&quot;&gt;'cert_type'&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.ml#L95&quot;&gt;'cert_usage'&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.ml#L100&quot;&gt;'cert_extended_usage'&lt;/a&gt;. The main entry for
authentication is &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.ml#L419&quot;&gt;'verify_chain_of_trust'&lt;/a&gt;,
which checks correct signatures of the chain, extensions and validity
of each certificate, and the hostname of the server certificate.&lt;/p&gt;
&lt;p&gt;The grammar of X.509 certificates is developed in the
&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/asn_grammars.ml&quot;&gt;'asn_grammars'&lt;/a&gt; module, and the object
identifiers are gathered in the &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/registry.ml&quot;&gt;'registry'&lt;/a&gt; module.&lt;/p&gt;
&lt;h3&gt;Implementation of certificate verification&lt;/h3&gt;
&lt;p&gt;We provide the function &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L438&quot;&gt;'valid_cas'&lt;/a&gt;, which takes a
timestamp and a list of certificate authorities. Each certificate
authority is checked to be &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L282&quot;&gt;valid&lt;/a&gt;, self-signed,
correctly signed, and having
&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L277&quot;&gt;proper X.509 v3 extensions&lt;/a&gt;.
As mentioned above, version 1 and version 2
certificates do not contain extensions. For a version 3 certificate,
&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L206&quot;&gt;'validate_ca_extensions'&lt;/a&gt; is called: The
basic constraints extensions must be present, and its value must be
true. Also, key usage must be present and the certificate must be
allowed to sign certificates. Finally, we reject the certificate if
there is any extension marked critical, apart from the two mentioned
above.&lt;/p&gt;
&lt;p&gt;When we have a list of validated CA certificates, we can use these to
&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.ml#L419&quot;&gt;verify the chain of trust&lt;/a&gt;, which gets a
hostname, a timestamp, a list of trust anchors and a certificate chain
as input. It first checks that the &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L384&quot;&gt;server certificate is
valid&lt;/a&gt;, the &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L264&quot;&gt;validity of the intermediate
certificates&lt;/a&gt;, and that the &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L421&quot;&gt;chain is complete&lt;/a&gt;
(the pathlen constraint is not validated) and rooted in a trust
anchor. A server certificate is valid if the validity period matches
the current timestamp, the given hostname &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L333&quot;&gt;matches&lt;/a&gt;
its subject alternative name extension or common name (might be
wildcard or strict matching, &lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC6125&lt;/a&gt;), and it does not have a
basic constraints extension which value is true.&lt;/p&gt;
&lt;h3&gt;Current status of ocaml-x509&lt;/h3&gt;
&lt;p&gt;We currently support only RSA certificates. We do not check revocation
lists or use the online certificate status protocol (&lt;a href=&quot;http://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol&quot;&gt;OCSP&lt;/a&gt;). Our
implementation does not handle name constraints and policies. However, if
any of these extensions is marked critical, we refuse to validate the
chain. To keep our main authentication free of side-effects, it currently uses
the timestamp when the authenticator was created rather than when it is used
(this isn't a problem if lifetime of the OCaml-TLS process is comparatively
short, as in the worst case the lifetime of the certificates can be extended by
the lifetime of the process).&lt;/p&gt;
&lt;p&gt;We invite people to read through the
&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml&quot;&gt;certificate verification&lt;/a&gt; and the
&lt;a href=&quot;https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/asn_grammars.ml&quot;&gt;ASN.1 parsing&lt;/a&gt;. We welcome discussion on the
&lt;a href=&quot;http://lists.xenproject.org/archives/html/mirageos-devel/&quot;&gt;mirage-devel mailing list&lt;/a&gt; and bug reports
on the &lt;a href=&quot;https://github.com/mirleft/ocaml-x509/issues&quot;&gt;GitHub issue tracker&lt;/a&gt;.&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Posts in this TLS series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-ocaml-tls&quot;&gt;Introducing transport layer security (TLS) in pure OCaml&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-nocrypto&quot;&gt;OCaml-TLS: building the nocrypto library core&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-x509&quot;&gt;OCaml-TLS: adventures in X.509 certificate parsing and validation&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-asn1&quot;&gt;OCaml-TLS: ASN.1 and notation embedding&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation&quot;&gt;OCaml-TLS: the protocol implementation and mitigations to known attacks&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </content><id>https://mirage.io/blog/introducing-x509</id><title type="text">OCaml-TLS: Adventures in X.509 certificate parsing and validation</title><updated>2014-07-10T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/introducing-nocrypto" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;em&gt;This is the second in a series of posts that introduce new libraries for a pure OCaml implementation of TLS.
You might like to begin with the &lt;a href=&quot;https://mirage.io/blog/introducing-ocaml-tls&quot;&gt;introduction&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;What is nocrypto?&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto&quot;&gt;nocrypto&lt;/a&gt; is the small cryptographic library behind the
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;ocaml-tls&lt;/a&gt; project. It is built to be straightforward to use, adhere to
functional programming principles and able to run in a Xen-based unikernel.
Its major use-case is &lt;code&gt;ocaml-tls&lt;/code&gt;, which we &lt;a href=&quot;https://mirage.io/blog/introducing-ocaml-tls&quot;&gt;announced yesterday&lt;/a&gt;, but we do intend to provide
sufficient features for it to be more widely applicable.&lt;/p&gt;
&lt;p&gt;&amp;quot;Wait, you mean you wrote your own &lt;em&gt;crypto library&lt;/em&gt;?&amp;quot;&lt;/p&gt;
&lt;h3&gt;&amp;quot;Never write your own crypto&amp;quot;&lt;/h3&gt;
&lt;p&gt;Everybody seems to recognize that cryptography is horribly difficult. Building
cryptography, it is all too easy to fall off the deep end and end up needing to
make decisions only a few, select specialists can make. Worse, any mistake is
difficult to uncover but completely compromises the security of the system. Or
in Bruce Schneier's &lt;a href=&quot;https://www.schneier.com/essays/archives/1998/01/security_pitfalls_in.html&quot;&gt;words&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Building a secure cryptographic system is easy to do badly, and very difficult
to do well. Unfortunately, most people can't tell the difference. In other
areas of computer science, functionality serves to differentiate the good from
the bad: a good compression algorithm will work better than a bad one; a bad
compression program will look worse in feature-comparison charts. Cryptography
is different. Just because an encryption program works doesn't mean it is
secure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Obviously, it would be far wiser not to attempt to do this and instead reuse
good, proven work done by others. And with the wealth of free cryptographic
libraries around, one gets to take their pick.&lt;/p&gt;
&lt;p&gt;So to begin with, we turned to &lt;a href=&quot;https://forge.ocamlcore.org/projects/cryptokit/&quot;&gt;cryptokit&lt;/a&gt;, the more-or-less
standard cryptographic library in the OCaml world. It has a decent coverage of
the basics: some stream ciphers (ARC4), some block ciphers (AES, 3DES and
Blowfish) the core hashes (MD5, SHA, the SHA2 family and RIPEMD) and the
public-key primitives (Diffie-Hellman and RSA). It is also designed with
composability in mind, exposing various elements as stream-transforming objects
that can be combined on top of one another.&lt;/p&gt;
&lt;p&gt;Unfortunately, its API was a little difficult to use. Suppose you have a secret
key, an IV and want to use AES-128 in CBC mode to encrypt a bit of data. You do
it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;let key = &amp;quot;abcd1234abcd1234&amp;quot;
and iv  = &amp;quot;1234abcd1234abcd&amp;quot;
and msg = &amp;quot;fire the missile&amp;quot;

let aes     = new Cryptokit.Block.aes_encrypt key
let aes_cbc = new Cryptokit.Block.cbc_encrypt ~iv aes

let cip =
  let size =
    int_of_float (ceil (float String.(length msg) /. 16.) *. 16.) in
  String.create size

let () = aes_cbc#transform msg 0 cip 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point, &lt;code&gt;cip&lt;/code&gt; contains our secret message. This being CBC, both &lt;code&gt;msg&lt;/code&gt; and
the string the output will be written into (&lt;code&gt;cip&lt;/code&gt;) need to have a size that is a
multiple of the underlying block size. If they do not, bad things will
happen -- silently.&lt;/p&gt;
&lt;p&gt;There is also the curious case of hashing-object states:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;let md5 = Cryptokit.Hash.md5 ()

let s1 = Cryptokit.hash_string md5 &amp;quot;bacon&amp;quot;
let s2 = Cryptokit.hash_string md5 &amp;quot;bacon&amp;quot;
let s3 = Cryptokit.hash_string md5 &amp;quot;bacon&amp;quot;

(*
  s1 = &amp;quot;x\\019%\\142\\248\\198\\1822\\221\\232\\204\\128\\246\\189\\166/&amp;quot;
  s2 = &amp;quot;'\\\\F\\017\\234\\172\\196\\024\\142\\255\\161\\145o\\142\\128\\197&amp;quot;
  s3 = &amp;quot;'\\\\F\\017\\234\\172\\196\\024\\142\\255\\161\\145o\\142\\128\\197&amp;quot;
*)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The error here is to try and carry a single instantiated hashing object around,
while trying to get hashes of distinct strings. But with the convergence after
the second step, the semantics of the hashing object still remains unclear to
us.&lt;/p&gt;
&lt;p&gt;One can fairly easily overcome the API style mismatches by making a few
specialized wrappers, of course, except for two major problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Cryptokit is pervasively stateful. While this is almost certainly a result of
performance considerations combined with its goals of ease of
compositionality, it directly clashes with the fundamental design property of
the TLS library we wanted to use it in: our &lt;code&gt;ocaml-tls&lt;/code&gt; library is stateless. We need to
be able to represent the state the encryption engine is in as a value.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cryptokit operates on strings. As a primary target of &lt;code&gt;ocaml-tls&lt;/code&gt; was
&lt;a href=&quot;https://mirage.io/&quot;&gt;Mirage&lt;/a&gt;, and Mirage uses separate, non-managed regions of memory to
store network data in, we need to be able to handle foreign-allocated
storage. This means &lt;code&gt;Bigarray&lt;/code&gt; (as exposed by &lt;code&gt;Cstruct&lt;/code&gt;), and it seems just
plain wrong to negate all the careful zero-copy architecture of the stack
below by copying everything into and out of strings.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are further problems. For example, Cryptokit makes no attempts to combat
well-known timing vulnerabilities. It has no support for elliptic curves. And it
depends on the system-provided random number generator, which does not exist
when running in the context of a unikernel.&lt;/p&gt;
&lt;p&gt;At this point, with the &lt;em&gt;de facto&lt;/em&gt; choice off the table, it's probably worth
thinking about writing OCaml bindings to a rock-solid cryptographic library
written in C.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nacl.cr.yp.to/&quot;&gt;NaCl&lt;/a&gt; is a modern, well-regarded crypto implementation, created by a
group of pretty famous and equally well-regarded cryptographers, and was the
first choice. Or at least its more approachable and packageable &lt;a href=&quot;http://labs.opendns.com/2013/03/06/announcing-sodium-a-new-cryptographic-library/&quot;&gt;fork&lt;/a&gt;
was, which already had &lt;a href=&quot;https://github.com/dsheets/ocaml-sodium&quot;&gt;OCaml bindings&lt;/a&gt;. Unfortunately, &lt;code&gt;NaCl&lt;/code&gt;
provides a narrow selection of implementations of various cryptographic
primitives, the ones its authors thought were best-of-breed (for example, the
only symmetric ciphers it implements are (X-)Salsa and AES in CTR mode). And
they are probably right (in some aspects they are &lt;em&gt;certainly&lt;/em&gt; right), but NaCl
is best used for implementations of newly-designed security protocols. It is
simply too opinionated to support an old, standardized behemoth like TLS.&lt;/p&gt;
&lt;p&gt;Then there is &lt;a href=&quot;https://www.openssl.org/docs/crypto/crypto.html&quot;&gt;crypto&lt;/a&gt;, the library OpenSSL is built on top of. It
is quite famous and provides optimized implementations of a wide range of
cryptographic algorithms. It also contains upwards of 200,000 lines of C and a
very large API footprint, and it's unclear whether it would be possible to run
it in the unikernel context. Recently, the parent project it is embedded in has
become highly suspect, with one high-profile vulnerability piling on top of
another and at least &lt;a href=&quot;http://www.libressl.org/&quot;&gt;two&lt;/a&gt; &lt;a href=&quot;https://boringssl.googlesource.com/boringssl/&quot;&gt;forks&lt;/a&gt; so far attempting to
clean the code base. It just didn't feel like a healthy code base to build
a new project on.&lt;/p&gt;
&lt;p&gt;There are other free cryptographic libraries in C one could try to bind, but at
a certain point we faced the question: is the work required to become intimately
familiar with the nuances and the API of an existing code base, and create
bindings for it in OCaml, really that much smaller than writing one from
scratch? When using a full library one commits to its security decisions and
starts depending on its authors' time to keep it up to date -- maybe this
effort is better spent in writing one in the first place.&lt;/p&gt;
&lt;p&gt;Tantalizingly, the length of the single OCaml source file in &lt;code&gt;Cryptokit&lt;/code&gt; is
2260 lines.&lt;/p&gt;
&lt;p&gt;Maybe if we made &lt;strong&gt;zero&lt;/strong&gt; decisions ourselves, informed all our work by published
literature and research, and wrote the bare minimum of code needed, it might not
even be dead-wrong to do it ourselves?&lt;/p&gt;
&lt;p&gt;And that is the basic design principle. Do nothing fancy. Do only documented
things. Don't write too much code. Keep up to date with security research. Open
up and ask people.&lt;/p&gt;
&lt;h3&gt;The anatomy of a simple crypto library&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nocrypto&lt;/code&gt; uses bits of C, similarly to other cryptographic libraries written in
high-level languages.&lt;/p&gt;
&lt;p&gt;This was actually less of a performance concern, and more of a security one: for
the low-level primitives which are tricky to implement and for which known,
compact and widely used code already exists, the implementation is probably
better reused. The major pitfall we hoped to avoid that way are side-channel
attacks.&lt;/p&gt;
&lt;p&gt;We use public domain (or BSD licenced) &lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto/tree/master/src/native&quot;&gt;C sources&lt;/a&gt; for the
simple cores of AES, 3DES, MD5, SHA and SHA2. The impact of errors in this code
is constrained: they contain no recursion, and they perform no allocation,
simply filling in caller-supplied fixed-size buffer by appropriate bytes.&lt;/p&gt;
&lt;p&gt;The block implementations in C have a simple API that requires us to provide the
input and output buffers and a key, writing the single encrypted (or decrypted)
block of data into the buffer. Like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void rijndaelEncrypt(const unsigned long *rk, int nrounds,
  const unsigned char plaintext[16], unsigned char ciphertext[16]);

void rijndaelDecrypt(const unsigned long *rk, int nrounds,
  const unsigned char ciphertext[16], unsigned char plaintext[16]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The hashes can initialize a provided buffer to serve as an empty accumulator,
hash a single chunk of data into that buffer and convert its contents into a
digest, which is written into a provided fixed buffer.&lt;/p&gt;
&lt;p&gt;In other words, all the memory management happens exclusively in OCaml and all
the buffers passed into the C layer are tracked by the garbage collector (GC).&lt;/p&gt;
&lt;h3&gt;Symmetric ciphers&lt;/h3&gt;
&lt;p&gt;So far, the only provided ciphers are AES, 3DES and ARC4, with ARC4 implemented
purely in OCaml (and provided only for TLS compatibility and for testing).&lt;/p&gt;
&lt;p&gt;AES and 3DES are based on core C code, on top of which we built some standard
&lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation&quot;&gt;modes of operation&lt;/a&gt; in OCaml. At the moment we support ECB, CBC
and CTR. There is also a nascent &lt;a href=&quot;https://en.wikipedia.org/wiki/Galois/Counter_Mode&quot;&gt;GCM&lt;/a&gt; implementation which is, at the time
of writing, known not to be optimal and possibly prone to timing attacks, and
which we are still working on.&lt;/p&gt;
&lt;p&gt;The exposed API strives to be simple and value-oriented. Each mode of each
cipher is packaged up as a module with a similar signature, with a pair of
functions for encryption and decryption. Each of those essentially takes a key
and a byte buffer and yields the resulting byte buffer, minimising hassle.&lt;/p&gt;
&lt;p&gt;This is how you encrypt a message:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-OCaml&quot;&gt;open Nocrypto.Block

let key = AES.CBC.of_secret Cstruct.(of_string &amp;quot;abcd1234abcd1234&amp;quot;)
and iv  = Cstruct.of_string &amp;quot;1234abcd1234abcd&amp;quot;
and msg = Cstruct.of_string &amp;quot;fire the missile&amp;quot;

let { AES.CBC.message ; iv } = AES.CBC.encrypt ~key ~iv msg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The hashes implemented are just MD5, SHA and the SHA2 family. Mirroring the
block ciphers, they are based on C cores, with the HMAC construction provided in
OCaml. The API is similarly simple: each hash is a separate module with the same
signature, providing a function that takes a byte buffer to its digest, together
with several stateful operations for incremental computation of digests.&lt;/p&gt;
&lt;p&gt;Of special note is that our current set of C sources will probably soon be
replaced. AES uses code that is vulnerable to a &lt;a href=&quot;http://cr.yp.to/antiforgery/cachetiming-20050414.pdf&quot;&gt;timing attack&lt;/a&gt;,
stemming from the fact that substitution tables are loaded into the CPU cache
as-needed. The code does not take advantage of the &lt;a href=&quot;https://en.wikipedia.org/wiki/AES_instruction_set&quot;&gt;AES-NI&lt;/a&gt;
instructions present in modern CPUs that allow AES to be hardware-assisted. SHA
and SHA2 cores turned out to be (comparatively) ill-performing, and static
analysis already uncovered some potential memory issues, so we are looking for
better implementations.&lt;/p&gt;
&lt;h3&gt;Public-key cryptography&lt;/h3&gt;
&lt;p&gt;Bignum arithmetic is provided by the excellent &lt;a href=&quot;https://forge.ocamlcore.org/projects/zarith&quot;&gt;zarith&lt;/a&gt; library, which
in turn uses &lt;a href=&quot;https://gmplib.org/&quot;&gt;GMP&lt;/a&gt;. This might create some portability problems later on,
but as GMP is widely used and well rounded code base which also includes some of
the needed auxiliary number-theoretical functions (its slightly extended
Miller-Rabin probabilistic primality test and the fast next-prime-scanning
function), it seemed like a much saner choice than redoing it from scratch.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto/blob/a52bba2dcaf1c5fd45249588254dff2722e9f960/src/rsa.mli&quot;&gt;RSA&lt;/a&gt; module provides the basics: raw encryption and decryption,
&lt;a href=&quot;https://en.wikipedia.org/wiki/PKCS_1&quot;&gt;PKCS1&lt;/a&gt;-padded versions of the same operations, and PKCS1 signing and
signature verification. It can generate RSA keys, which it does simply by
finding two large primes, in line with &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.310.4183&quot;&gt;Rivest's&lt;/a&gt; own
recommendation.&lt;/p&gt;
&lt;p&gt;Notably, RSA implements the standard &lt;a href=&quot;https://en.wikipedia.org/wiki/Blinding_(cryptography)&quot;&gt;blinding&lt;/a&gt; technique which can mitigate
some side-channel attacks, such as timing or &lt;a href=&quot;http://www.cs.tau.ac.il/~tromer/acoustic/&quot;&gt;acoustic&lt;/a&gt;
cryptanalysis. It seems to foil even stronger, &lt;a href=&quot;http://eprint.iacr.org/2013/448.pdf&quot;&gt;cache eviction&lt;/a&gt;
based attacks, but as of now, we are not yet completely sure.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto/blob/a52bba2dcaf1c5fd45249588254dff2722e9f960/src/dh.mli&quot;&gt;Diffie-Hellman&lt;/a&gt; module is also relatively basic. We implement some
&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.1921&quot;&gt;widely&lt;/a&gt; &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.21.639&quot;&gt;recommended&lt;/a&gt; checks on the incoming public key to
mitigate some possible MITM attacks, the module can generate strong DH groups
(using safe primes) with guaranteed large prime-order subgroup, and we provide
a catalogue of published DH groups ready for use.&lt;/p&gt;
&lt;h3&gt;Randomness&lt;/h3&gt;
&lt;p&gt;Random number generation used to be a chronically overlooked part of
cryptographic libraries, so much so that nowadays one of the first questions
about a crypto library is, indeed, &amp;quot;Where does it get randomness from?&amp;quot;&lt;/p&gt;
&lt;p&gt;It's an important question. A cryptographic system needs unpredictability in
many places, and violating this causes catastrophic &lt;a href=&quot;https://www.debian.org/security/2008/dsa-1571&quot;&gt;failures&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nocrypto&lt;/code&gt; contains its own implementation of &lt;a href=&quot;https://www.schneier.com/fortuna.html&quot;&gt;Fortuna&lt;/a&gt;. Like
&lt;a href=&quot;https://www.schneier.com/yarrow.html&quot;&gt;Yarrow&lt;/a&gt;, Fortuna uses a strong block cipher in CTR mode (AES in our
case) to produce the pseudo-random stream, a technique that is considered as
unbreakable as the underlying cipher.&lt;/p&gt;
&lt;p&gt;The stream is both self-rekeyed, and rekeyed with the entropy gathered into its
accumulator pool. Unlike the earlier designs, however, Fortuna is built without
entropy estimators, which usually help the PRNG decide when to actually convert
the contents of an entropy pool into the new internal state. Instead, Fortuna
uses a design where the pools are fed round-robin, but activated with an
exponential backoff. There is &lt;a href=&quot;https://eprint.iacr.org/2014/167&quot;&gt;recent research&lt;/a&gt; showing this
design is essentially sound: after a state compromise, Fortuna wastes no more
than a constant factor of incoming entropy -- whatever the amount of entropy is
-- before coming back to an unpredictable state. The resulting design is both
simple, and robust in terms of its usage of environmental entropy.&lt;/p&gt;
&lt;p&gt;The above paper also suggests a slight improvement to the accumulator regime,
yielding a factor-of-2 improvement in entropy usage over the original. We still
haven't implemented this, but certainly intend to.&lt;/p&gt;
&lt;p&gt;A PRNG needs to be fed with some actual entropy to be able to produce
unpredictable streams. The library itself contains no provisions for doing this
and its PRNG needs to be fed by the user before any output can be produced. We
are &lt;a href=&quot;https://github.com/mirage/mirage-entropy&quot;&gt;working with the Mirage team&lt;/a&gt; on exposing environmental
entropy sources and connecting them to our implementation of Fortuna.&lt;/p&gt;
&lt;h3&gt;Above &amp;amp; beyond&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nocrypto&lt;/code&gt; is still very small, providing the bare minimum cryptographic
services to support TLS and related X.509 certificate operations. One of the
goals is to flesh it out a bit, adding some more widely deployed algorithms, in
hopes of making it more broadly usable.&lt;/p&gt;
&lt;p&gt;There are several specific problems with the library at this stage:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C code&lt;/strong&gt; - As mentioned, we are seeking to replace some of the C code we use. The hash
cores are underperforming by about a factor of 2 compared to some other
implementations. AES implementation is on one hand vulnerable to a timing attack
and, on the other hand, we'd like to make use of hardware acceleration for this
workhorse primitive -- without it we lose about an order of magnitude of
performance.&lt;/p&gt;
&lt;p&gt;Several options were explored, ranging from looking into the murky waters of
OpenSSL and trying to exploit their heavily optimized primitives, to bringing
AES-NI into OCaml and redoing AES in OCaml. At this point, it is not clear which
path we'll take.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ECC&lt;/strong&gt; - Looking further, the library still lacks support for elliptic curve cryptography
and we have several options for solving this. Since it is used by TLS, ECC is
probably the missing feature we will concentrate on first.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Entropy on Xen&lt;/strong&gt; - The entropy gathering on Xen is incomplete. The current prototype uses current
time as the random seed and the effort to expose noisier sources like interrupt
timings and the RNG from dom0's kernel is still ongoing.  Dave Scott, for example, has
&lt;a href=&quot;http://lists.xen.org/archives/html/xen-devel/2014-06/msg01492.html&quot;&gt;submitted patches&lt;/a&gt; to upstream Xen to make it easier to establish low-bandwidth
channels to supplies guest VMs with strong entropy from a privileged domain
that has access to physical devices and hence high-quality entropy sources.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GC timing attacks?&lt;/strong&gt; - There is the question of GC and timing attacks: whether doing
cryptography in a high-level language opens up a completely new surface for
timing attacks, given that GC runs are very visible in the timing profile. The
basic approach is to leave the core routines which we know are potentially
timing-sensitive (like AES) and for which we don't have explicit timing
mitigations (like RSA) to C, and invoke them atomically from the perspective of
the GC. So far, it's an open question whether the constructions built on top
of them expose further side-channels.&lt;/p&gt;
&lt;p&gt;Still, we believe that the whole package is a pleasant library to work with. Its
simplicity contributes to the comparative simplicity of the entire TLS library,
and we are actively seeking input on areas that need further improvement.
Although we are obviously biased, we believe it is the best cryptographic base
library available for this project, and it might be equally suited for your next
project too!&lt;/p&gt;
&lt;p&gt;We are striving to be open about the current security status of our code. You
are free to check out our &lt;a href=&quot;https://github.com/mirleft/ocaml-nocrypto/issues?state=open&quot;&gt;issue tracker&lt;/a&gt; and invited to contribute
comments, ideas, and especially audits and code.&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Posts in this TLS series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/introducing-ocaml-tls&quot;&gt;Introducing transport layer security (TLS) in pure OCaml&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/introducing-nocrypto&quot;&gt;OCaml-TLS: building the nocrypto library core&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/introducing-x509&quot;&gt;OCaml-TLS: adventures in X.509 certificate parsing and validation&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/introducing-asn1&quot;&gt;OCaml-TLS: ASN.1 and notation embedding&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation&quot;&gt;OCaml-TLS: the protocol implementation and mitigations to known attacks&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </content><id>https://mirage.io/blog/introducing-nocrypto</id><title type="text">OCaml-TLS: building the nocrypto library core</title><updated>2014-07-09T00:00:00-00:00</updated><author><name>David Kaloper</name></author></entry><entry><link href="https://mirage.io/blog/mirage-1.2-released" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Summer is in full swing here in MirageOS HQ with torrential rainstorms, searing
sunshine, and our &lt;a href=&quot;http://www.oscon.com/oscon2014/public/schedule/detail/35024&quot;&gt;OSCON 2014&lt;/a&gt; talk
rapidly approaching in just a few weeks.  We've been steadily releasing point releases
since the &lt;a href=&quot;https://mirage.io/blog/mirage-1.1-released&quot;&gt;first release&lt;/a&gt; back in December, and today's &lt;a href=&quot;https://github.com/mirage/mirage/releases/tag/v1.2.0&quot;&gt;MirageOS
1.2.0&lt;/a&gt; is the last of the &lt;code&gt;1.x&lt;/code&gt; series.
The main improvements are usability-oriented:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The Mirage frontend tool now generates a &lt;code&gt;Makefile&lt;/code&gt; with a &lt;code&gt;make depend&lt;/code&gt;
target, instead of directly invoking OPAM as part of &lt;code&gt;mirage configure&lt;/code&gt;.
This greatly improves usability on slow platforms such as ARM, since the
output of OPAM as it builds can be inspected more easily. Users will now
need to run &lt;code&gt;make depend&lt;/code&gt; to ensure they have the latest package set
before building their unikernel.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Improve formatting of the &lt;code&gt;mirage&lt;/code&gt; output, including pretty colours!
This makes it easier to distinguish complex unikernel configurations
that have lots of deployment options.  The generated files are built
more verbosely by default to facilitate debugging, and with debug
symbols and backtraces enabled by default.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Added several &lt;a href=&quot;https://github.com/mirage/mirage/tree/master/types&quot;&gt;device module types&lt;/a&gt;, including &lt;code&gt;ENTROPY&lt;/code&gt; for random
noise, &lt;code&gt;FLOW&lt;/code&gt; for stream-oriented connections, and exposed the &lt;code&gt;IPV4&lt;/code&gt;
device in the &lt;code&gt;STACKV4&lt;/code&gt; TCP/IP stack type.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Significant bugfixes in supporting libraries such as the TCP/IP
stack (primarily thanks to &lt;a href=&quot;http://www.somerandomidiot.com/&quot;&gt;Mindy Preston&lt;/a&gt; fuzz testing
and finding some good &lt;a href=&quot;https://github.com/mirage/mirage-tcpip/issues/56&quot;&gt;zingers&lt;/a&gt;).  There are too many
library releases to list individually here, but you can &lt;a href=&quot;https://mirage.io/releases&quot;&gt;browse the changelog&lt;/a&gt; for more details.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####&amp;nbsp;Towards MirageOS 2.0&lt;/p&gt;
&lt;p&gt;We've also been working hard on the &lt;strong&gt;MirageOS 2.x series&lt;/strong&gt;, which introduces
a number of new features and usability improvements that emerged from actually
using the tools in practical projects.  Since there have been so many &lt;a href=&quot;https://mirage.io/blog/welcome-to-our-summer-hackers&quot;&gt;new
contributors&lt;/a&gt; recently,
&lt;a href=&quot;http://amirchaudhry.com&quot;&gt;Amir Chaudhry&lt;/a&gt; is coordinating a &lt;a href=&quot;https://github.com/mirage/mirage/issues/257&quot;&gt;series of blog
posts&lt;/a&gt; in the runup to
&lt;a href=&quot;http://www.oscon.com/oscon2014/public/schedule/detail/35024&quot;&gt;OSCON&lt;/a&gt; that
explains the new work in depth.  Once the release rush has subsided, we'll
be working on integrating these posts into our &lt;a href=&quot;https://mirage.io/docs&quot;&gt;documentation&lt;/a&gt;
properly.&lt;/p&gt;
&lt;p&gt;The new 2.0 features include the &lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;Irmin&lt;/a&gt; branch-consistent distributed storage
library, the pure OCaml &lt;a href=&quot;https://github.com/mirleft/&quot;&gt;TLS stack&lt;/a&gt;, &lt;a href=&quot;https://github.com/mirage/mirage-platform/pull/93&quot;&gt;Xen/ARM support&lt;/a&gt; and the Conduit I/O
subsystem for &lt;a href=&quot;http://anil.recoil.org/papers/2012-resolve-fable.pdf&quot;&gt;mapping names to connections&lt;/a&gt;.  Also included in the blog series
are some sample usecases on how these tie together for real applications (as a
teaser, here's a video of &lt;a href=&quot;https://www.youtube.com/watch?v=DSzvFwIVm5s&quot;&gt;Xen VMs booting using
Irmin&lt;/a&gt; thanks to &lt;a href=&quot;http://dave.recoil.org&quot;&gt;Dave
Scott&lt;/a&gt; and &lt;a href=&quot;http://gazagnaire.org&quot;&gt;Thomas Gazagnaire&lt;/a&gt;!)&lt;/p&gt;
&lt;h4&gt;Upcoming talks and tutorials&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://mort.io&quot;&gt;Richard Mortier&lt;/a&gt; and myself will be gallivanting around the world
to deliver a few talks this summer:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The week of &lt;a href=&quot;http://www.oscon.com/oscon2014&quot;&gt;OSCON&lt;/a&gt; on July 20th-24th.  Please get in touch via the conference website or a direct e-mail, or &lt;a href=&quot;http://www.oscon.com/oscon2014/public/schedule/detail/35024&quot;&gt;attend our talk&lt;/a&gt; on Thursday morning.
There's a &lt;a href=&quot;https://realworldocaml.org&quot;&gt;Real World OCaml&lt;/a&gt; book signing on Tuesday morning for the super keen as well.
&lt;/li&gt;
&lt;li&gt;The &lt;a href=&quot;http://ecoop14.it.uu.se/programme/ecoop-school.php&quot;&gt;ECOOP summer school&lt;/a&gt; in beautiful Uppsala in Sweden on Weds 30th July.
&lt;/li&gt;
&lt;li&gt;I'll be presenting the Irmin and Xen integration at &lt;a href=&quot;http://events.linuxfoundation.org/events/xen-project-developer-summit&quot;&gt;Xen Project Developer Summit&lt;/a&gt; in
Chicago on Aug 18th (as part of LinuxCon North America).  &lt;a href=&quot;http://mort.io&quot;&gt;Mort&lt;/a&gt; and &lt;a href=&quot;http://somerandomidiot.com&quot;&gt;Mindy&lt;/a&gt; (no jokes please) will be
joining the community panel about &lt;a href=&quot;https://mirage.io/blog/applying-for-gsoc2014&quot;&gt;GSoC/OPW&lt;/a&gt; participation.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As always, if there are any particular topics you would like to see more
on, then please comment on the &lt;a href=&quot;https://github.com/mirage/mirage/issues/257&quot;&gt;tracking issue&lt;/a&gt;
or &lt;a href=&quot;https://mirage.io/community&quot;&gt;get in touch directly&lt;/a&gt;.  There will be a lot of releases coming out
in the next few weeks (including a beta of the new version of &lt;a href=&quot;http://opam.ocaml.org&quot;&gt;OPAM&lt;/a&gt;,
so &lt;a href=&quot;https://github.com/mirage/mirage/issues&quot;&gt;bug reports&lt;/a&gt; are very much appreciated for those
things that slip past &lt;a href=&quot;http://travis-ci.org&quot;&gt;Travis CI&lt;/a&gt;!&lt;/p&gt;

      </content><id>https://mirage.io/blog/mirage-1.2-released</id><title type="text">MirageOS 1.2 released and the 2.0 runup begins</title><updated>2014-07-08T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/introducing-ocaml-tls" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We announce a &lt;strong&gt;beta&lt;/strong&gt; release of &lt;code&gt;ocaml-tls&lt;/code&gt;, a clean-slate implementation of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;Transport Layer Security&lt;/a&gt; (TLS) in
OCaml.&lt;/p&gt;
&lt;h3&gt;What is TLS?&lt;/h3&gt;
&lt;p&gt;Transport Layer Security (TLS) is probably the most widely deployed
security protocol on the Internet. It provides communication privacy
to prevent eavesdropping, tampering, and message forgery. Furthermore,
it optionally provides authentication of the involved endpoints. TLS
is commonly deployed for securing web services (&lt;a href=&quot;http://tools.ietf.org/html/rfc2818&quot;&gt;HTTPS&lt;/a&gt;), emails,
virtual private networks, and wireless networks.&lt;/p&gt;
&lt;p&gt;TLS uses asymmetric cryptography to exchange a symmetric key, and
optionally authenticate (using X.509) either or both endpoints. It
provides algorithmic agility, which means that the key exchange
method, symmetric encryption algorithm, and hash algorithm are
negotiated.&lt;/p&gt;
&lt;h3&gt;TLS in OCaml&lt;/h3&gt;
&lt;p&gt;Our implementation &lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;ocaml-tls&lt;/a&gt; is already able to interoperate with
existing TLS implementations, and supports several important TLS extensions
such as server name indication (&lt;a href=&quot;https://tools.ietf.org/html/rfc4366&quot;&gt;RFC4366&lt;/a&gt;, enabling virtual hosting)
and secure renegotiation (&lt;a href=&quot;https://tools.ietf.org/html/rfc5746&quot;&gt;RFC5746&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Our [demonstration server][^7] runs &lt;code&gt;ocaml-tls&lt;/code&gt; and renders exchanged
TLS messages in nearly real time by receiving a trace of the TLS
session setup. If you encounter any problems, please give us [feedback][^14].&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ocaml-tls&lt;/code&gt; and all dependent libraries are available via [OPAM][^18] (&lt;code&gt;opam install tls&lt;/code&gt;). The &lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;source is available&lt;/a&gt;
under a BSD license. We are primarily working towards completeness of
protocol features, such as client authentication, session resumption, elliptic curve and GCM
cipher suites, and have not yet optimised for performance.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ocaml-tls&lt;/code&gt; depends on the following independent libraries: [ocaml-nocrypto][^6] implements the
cryptographic primitives, [ocaml-asn1-combinators][^5] provides ASN.1 parsers/unparsers, and
[ocaml-x509][^8] implements the X509 grammar and certificate validation (&lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot;&gt;RFC5280&lt;/a&gt;). &lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;ocaml-tls&lt;/a&gt; implements TLS (1.0, 1.1 and 1.2; &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt;,
&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;We invite the community to audit and run our code, and we are particularly interested in discussion of our APIs.
Please use the [mirage-devel mailing list][^9] for discussions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Please be aware that this release is a &lt;em&gt;beta&lt;/em&gt; and is missing external code audits.
It is not yet intended for use in any security critical applications.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In our [issue tracker][^14] we transparently document known attacks against TLS and our mitigations
([checked][^4] and [unchecked][^11]).
We have not yet implemented mitigations against either the
[Lucky13][^12] timing attack or traffic analysis (e.g. [length-hiding padding][^13]).&lt;/p&gt;
&lt;h3&gt;Trusted code base&lt;/h3&gt;
&lt;p&gt;Designed to run on Mirage, the trusted code base of &lt;code&gt;ocaml-tls&lt;/code&gt; is small. It includes the libraries already mentioned,
&lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;&lt;code&gt;ocaml-tls&lt;/code&gt;&lt;/a&gt;, [&lt;code&gt;ocaml-asn-combinators&lt;/code&gt;][^5], [&lt;code&gt;ocaml-x509&lt;/code&gt;][^8],
and [&lt;code&gt;ocaml-nocrypto&lt;/code&gt;][^6] (which uses C implementations of block
ciphers and hash algorithms). For arbitrary precision integers needed in
asymmetric cryptography, we rely on [&lt;code&gt;zarith&lt;/code&gt;][^15], which wraps
[&lt;code&gt;libgmp&lt;/code&gt;][^16]. As underlying byte array structure we use
[&lt;code&gt;cstruct&lt;/code&gt;][^17] (which uses OCaml &lt;code&gt;Bigarray&lt;/code&gt; as storage).&lt;/p&gt;
&lt;p&gt;We should also mention the OCaml runtime, the OCaml compiler, the
operating system on which the source is compiled and the binary is executed, as
well as the underlying hardware. Two effectful frontends for
the pure TLS core are implemented, dealing
with side-effects such as reading and writing from the network: &lt;a href=&quot;http://ocsigen.org/lwt/api/Lwt_unix&quot;&gt;Lwt_unix&lt;/a&gt; and
Mirage, so applications can run directly as a Xen unikernel.&lt;/p&gt;
&lt;h3&gt;Why a new TLS implementation?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt;
Thanks to &lt;a href=&quot;http://frama-c.com/&quot;&gt;Frama-C&lt;/a&gt; guys for &lt;a href=&quot;https://twitter.com/spun_off/status/486535304426188800&quot;&gt;pointing&lt;/a&gt; &lt;a href=&quot;https://twitter.com/spun_off/status/486536572792090626&quot;&gt;out&lt;/a&gt;
that &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1266&quot;&gt;CVE-2014-1266&lt;/a&gt; and &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0224&quot;&gt;CVE-2014-0224&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; memory safety issues, but
logic errors. This article previously stated otherwise.&lt;/p&gt;
&lt;p&gt;There are only a few TLS implementations publicly available and most
programming languages bind to OpenSSL, an open source implementation written
in C. There are valid reasons to interface with an existing TLS library,
rather than developing one from scratch, including protocol complexity and
compatibility with different TLS versions and implementations. But from our
perspective the disadvantage of most existing libraries is that they
are written in C, leading to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Memory safety issues, as recently observed by &lt;a href=&quot;https://en.wikipedia.org/wiki/Heartbleed&quot;&gt;Heartbleed&lt;/a&gt; and GnuTLS
session identifier memory corruption (&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3466&quot;&gt;CVE-2014-3466&lt;/a&gt;) bugs;
&lt;/li&gt;
&lt;li&gt;Control flow complexity (Apple's goto fail, &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1266&quot;&gt;CVE-2014-1266&lt;/a&gt;);
&lt;/li&gt;
&lt;li&gt;And difficulty in encoding state machines (OpenSSL change cipher suite
attack, &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0224&quot;&gt;CVE-2014-0224&lt;/a&gt;).
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our main reasons for &lt;code&gt;ocaml-tls&lt;/code&gt; are that OCaml is a modern functional
language, which allows concise and declarative descriptions of the
complex protocol logic and provides type safety and memory safety to help
guard against programming errors. Its functional nature is extensively
employed in our code: the core of the protocol is written in purely
functional style, without any side effects.&lt;/p&gt;
&lt;p&gt;Subsequent blog posts &lt;a href=&quot;https://github.com/mirage/mirage/issues/257&quot;&gt;over the coming
days&lt;/a&gt; will examine in more detail
the design and implementation of the four libraries, as well as the security
trade-offs and some TLS attacks and our mitigations against them.  For now
though, we invite you to try out our &lt;strong&gt;[demonstration server][^7]&lt;/strong&gt;
running our stack over HTTPS.  We're particularly interested in feedback on our &lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;issue tracker&lt;/a&gt; about
clients that fail to connect, and any queries from anyone reviewing the &lt;a href=&quot;https://github.com/mirleft/&quot;&gt;source code&lt;/a&gt;
of the constituent libraries.&lt;/p&gt;
&lt;p&gt;[^3]: http://www.openbsd.org/papers/bsdcan14-libressl/mgp00026.html)
[^4]: https://github.com/mirleft/ocaml-tls/issues?labels=security+concern&amp;amp;page=1&amp;amp;state=open
[^5]: https://github.com/mirleft/ocaml-asn1-combinators
[^6]: https://github.com/mirleft/ocaml-nocrypto
[^7]: https://tls.nqsb.io/
[^8]: https://github.com/mirleft/ocaml-x509
[^9]: http://lists.xenproject.org/archives/html/mirageos-devel/
[^10]: https://github.com/mirage/mirage-entropy
[^11]: https://github.com/mirleft/ocaml-tls/issues?labels=security+concern&amp;amp;page=1&amp;amp;state=closed
[^12]: http://www.isg.rhul.ac.uk/tls/Lucky13.html
[^13]: http://tools.ietf.org/html/draft-pironti-tls-length-hiding-02
[^14]: https://github.com/mirleft/ocaml-tls/issues
[^15]: https://forge.ocamlcore.org/projects/zarith
[^16]: https://gmplib.org/
[^17]: https://github.com/mirage/ocaml-cstruct
[^18]: https://opam.ocaml.org/packages/tls/tls.0.1.0/&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Posts in this TLS series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-ocaml-tls&quot;&gt;Introducing transport layer security (TLS) in pure OCaml&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-nocrypto&quot;&gt;OCaml-TLS: building the nocrypto library core&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-x509&quot;&gt;OCaml-TLS: adventures in X.509 certificate parsing and validation&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/introducing-asn1&quot;&gt;OCaml-TLS: ASN.1 and notation embedding&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation&quot;&gt;OCaml-TLS: the protocol implementation and mitigations to known attacks&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </content><id>https://mirage.io/blog/introducing-ocaml-tls</id><title type="text">Introducing transport layer security (TLS) in pure OCaml</title><updated>2014-07-08T00:00:00-00:00</updated><author><name>Hannes Mehnert</name></author></entry><entry><link href="https://mirage.io/blog/welcome-to-our-summer-hackers" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Following our participation in the &lt;a href=&quot;https://mirage.io/blog/applying-for-gsoc2014&quot;&gt;Google Summer of Code&lt;/a&gt; program, we've now finalised selections.  We've also got a number of other visitors joining us to hack on Mirage over the summer time, so here are introductions!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SSL support&lt;/strong&gt;: &lt;a href=&quot;https://github.com/hannesm&quot;&gt;Hannes Mehnert&lt;/a&gt; and &lt;a href=&quot;https://github.com/pqwy&quot;&gt;David Kaloper&lt;/a&gt; have been working hard on a safe &lt;a href=&quot;https://github.com/mirleft/ocaml-tls&quot;&gt;OCaml TLS&lt;/a&gt; implementation. They're going to hack on &lt;a href=&quot;https://github.com/mirage/mirage/issues/242&quot;&gt;integrating it all&lt;/a&gt; into working under Xen so we can make HTTPS requests (and our Twitter bot will finally be able to tweet!).  Both are also interested in formal verification of the result, and several loooong conversations with &lt;a href=&quot;http://www.cl.cam.ac.uk/~pes20/&quot;&gt;Peter Sewell&lt;/a&gt; will magically transform into machine specifications by summer's end, I'm reliably informed.
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud APIs&lt;/strong&gt;: &lt;a href=&quot;http://1000hippos.wordpress.com/&quot;&gt;Jyotsna Prakash&lt;/a&gt; will spend her summer break as part of &lt;a href=&quot;http://www.google-melange.com/gsoc/org2/google/gsoc2014/xen_project&quot;&gt;Google Summer of Code&lt;/a&gt; working on improving cloud provider APIs in OCaml (modelled from her notes on how the &lt;a href=&quot;https://github.com/avsm/ocaml-github&quot;&gt;GitHub&lt;/a&gt; bindings &lt;a href=&quot;http://1000hippos.wordpress.com/2014/04/24/ocaml-github/&quot;&gt;are built&lt;/a&gt;).  This will let the &lt;code&gt;mirage&lt;/code&gt; command-line tool have much more natural integration with remote cloud providers for executing the unikernels straight from a command-line.  If you see Jyotsna wandering around aimlessly muttering darkly about HTTP, JSON and REST, then the project is going well.
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Network Stack fuzzing&lt;/strong&gt;: &lt;a href=&quot;http://www.somerandomidiot.com/&quot;&gt;Mindy Preston&lt;/a&gt; joins us for the summer after her &lt;a href=&quot;https://www.hackerschool.com/&quot;&gt;Hacker School&lt;/a&gt; stay, courtesy of the &lt;a href=&quot;https://opw.gnome.org&quot;&gt;OPW&lt;/a&gt; program.  She's been delving into the network stack running on EC2 and figuring out how to debug issues when the unikernel is running a cloud far, far away (see the post series here: &lt;a href=&quot;http://www.somerandomidiot.com/blog/2014/03/14/its-a-mirage/&quot;&gt;1&lt;/a&gt;, &lt;a href=&quot;http://www.somerandomidiot.com/blog/2014/03/24/advancing-toward-the-mirage/&quot;&gt;2&lt;/a&gt;, &lt;a href=&quot;http://www.somerandomidiot.com/blog/2014/04/02/tying-the-knot/&quot;&gt;3&lt;/a&gt;, &lt;a href=&quot;http://www.somerandomidiot.com/blog/2014/03/24/arriving-at-the-mirage/&quot;&gt;4&lt;/a&gt;).
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visualization&lt;/strong&gt;: &lt;a href=&quot;http://erratique.ch/contact.en&quot;&gt;Daniel Buenzli&lt;/a&gt; returns to Cambridge this summer to continue his work on extremely succinctly named graphics libaries.  His &lt;a href=&quot;https://github.com/dbuenzli/vz&quot;&gt;Vz&lt;/a&gt;, &lt;a href=&quot;https://github.com/dbuenzli/vg&quot;&gt;Vg&lt;/a&gt; and &lt;a href=&quot;https://github.com/dbuenzli/gg&quot;&gt;Gg&lt;/a&gt; libaries build a set of primitives for 2D graphics programming.  Since the libraries compile to JavaScript, we're planning to use this as the basis for &lt;a href=&quot;http://erratique.ch/software/vg/demos/rhtmlc&quot;&gt;visualization&lt;/a&gt; of Mirage applications via a built-in webserver.
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modular implicits&lt;/strong&gt;: &lt;a href=&quot;https://github.com/def-lkb&quot;&gt;Frederic Bour&lt;/a&gt;, author of the popular &lt;a href=&quot;https://github.com/the-lambda-church/merlin&quot;&gt;Merlin&lt;/a&gt; IDE tool is also in Cambridge this summer working on adding modular implicits to the core OCaml language. Taking inspiration from &lt;a href=&quot;http://www.mpi-sws.org/~dreyer/papers/mtc/main-long.pdf&quot;&gt;Modular Type-classes&lt;/a&gt; and Scala's &lt;a href=&quot;http://twitter.github.io/scala_school/advanced-types.html&quot;&gt;implicits&lt;/a&gt;,  modular implcits allow functions to take implicit module arguments which will be filled-in by the compiler by searching the environment for a module with the appropriate type. This enables ad-hoc polymorphism in a very similar way to Haskell's type classes.
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Irmin storage algorithms&lt;/strong&gt;: Benjamin Farinier (from &lt;a href=&quot;http://www.ens-lyon.eu/&quot;&gt;ENS Lyon&lt;/a&gt;) and Matthieu Journault (from &lt;a href=&quot;http://www.ens-cachan.fr/&quot;&gt;ENS Cachan&lt;/a&gt;) will work on datastructures for the &lt;a href=&quot;https://github.com/mirage/irmin/wiki/Getting-Started&quot;&gt;Irmin&lt;/a&gt; storage system that the next version of Mirage will use.  They'll be grabbing copies of the &lt;a href=&quot;http://www.amazon.co.uk/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504&quot;&gt;Okasaki&lt;/a&gt; classic text and porting some of them into a branch-consistent form.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, work continues apace by the rest of the team as usual, with a &lt;a href=&quot;https://mirage.io/releases&quot;&gt;steady stream of releases&lt;/a&gt; that are building up to some exciting new features.  We'll be blogging about ARM support, PVHVM, Irmin storage and SSL integration just as soon as they're pushed into the stable branches.  As always, &lt;a href=&quot;https://mirage.io/community/&quot;&gt;get in touch&lt;/a&gt; via the IRC channel (&lt;code&gt;#mirage&lt;/code&gt; on Freenode) or the mailing lists with questions.&lt;/p&gt;

      </content><id>https://mirage.io/blog/welcome-to-our-summer-hackers</id><title type="text">Welcome to the summer MirageOS hackers</title><updated>2014-05-08T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/applying-for-gsoc2014" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;MirageOS will part of the &lt;a href=&quot;https://www.google-melange.com/gsoc/homepage/google/gsoc2014&quot;&gt;Google Summer of Code&lt;/a&gt; 2014
program, thanks to the Xen Project's participation!  It's been a few years
since I've mentored for GSoc, but I still have fond memories of some great
projects in the past (such as the legendary &lt;a href=&quot;http://vmgl.sourceforge.net/&quot;&gt;Quake testing&lt;/a&gt;
we were forced to do for hours on end).  I've already received a number of
queries about this year's program from potential students, so here's a few
things to note to become a successful applicant.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Students still need to apply and be accepted. Your chances of being
selected are much higher if you demonstrate some participation and
code contributions (even minor) &lt;em&gt;before&lt;/em&gt; submitting an application.
Thus, even if you don't have a copy of Xen around, roll up your sleeves
and head over to the &lt;a href=&quot;https://mirage.io/docs/install&quot;&gt;installation instructions&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Contributions do not have to be just code.  They can be documentation,
help with packaging, wiki posts about a particular use, or test cases
to improve code coverage.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It's unlikely that we'll get students who are very familiar with both
OCaml and Xen (if you are, definitely get in touch with us!).  You should
therefore look over the &lt;a href=&quot;http://wiki.xen.org/wiki/GSoc_2014#Mirage_OS&quot;&gt;project ideas&lt;/a&gt;
as a set of guidelines and not firm suggestions.  If you have a particular
thing you'd like to do with Mirage (for example, work on the JavaScript
backend, an &lt;a href=&quot;https://github.com/andrewray/iocamljs&quot;&gt;IPython interface&lt;/a&gt; or
a particular protocol implementation such as XMPP, then that's fine.  Just
get in touch with us on the &lt;a href=&quot;https://mirage.io/community&quot;&gt;mailing lists&lt;/a&gt; or directly via
e-mail, and we can work through them.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Under some circumstances, we can provide resources such as a login to
a Xen machine, or delegated credits on a cloud provider.  Don't let that
stop you from applying for a project idea.  In general though, it's best
to only depend on your own computer resources if practical to do so.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </content><id>https://mirage.io/blog/applying-for-gsoc2014</id><title type="text">MirageOS is in Google Summer of Code 2014</title><updated>2014-02-25T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/mirage-1.1-released" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We've just released &lt;a href=&quot;https://github.com/ocaml/opam-repository/pull/1655&quot;&gt;MirageOS 1.1.0&lt;/a&gt; into OPAM.  Once the
live site updates, you should be able to run &lt;code&gt;opam update -u&lt;/code&gt; and get the latest
version.  This release is the &amp;quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Eating_your_own_dog_food&quot;&gt;eat our own
dogfood&lt;/a&gt;&amp;quot; release; as I
mentioned earlier in January, a number of the MirageOS developers have decided to
shift our own personal homepages onto MirageOS.  There's nothing better than
using our own tools to find all the little annoyances and shortcomings, and so
MirageOS 1.1.0 contains some significant usability and structural improvements
for building unikernels.&lt;/p&gt;
&lt;h4&gt;Functional combinators to build device drivers&lt;/h4&gt;
&lt;p&gt;MirageOS separates the
application logic from the concrete backend in use by writing the application
as an &lt;a href=&quot;https://realworldocaml.org/v1/en/html/functors.html&quot;&gt;OCaml functor&lt;/a&gt;
that is parameterized over module types that represent the device driver
signature.  All of the module types used in MirageOS can be browsed in &lt;a href=&quot;https://github.com/mirage/mirage/blob/1.1.0/types/V1.mli&quot;&gt;one
source file&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In MirageOS 1.1.0, &lt;a href=&quot;http://gazagnaire.org/&quot;&gt;Thomas Gazagnaire&lt;/a&gt; implemented a
a &lt;a href=&quot;https://github.com/mirage/mirage/blob/1.1.0/lib/mirage.mli#L28&quot;&gt;combinator library&lt;/a&gt;
that makes it easy to separate the definition of application logic from the details
of the device drivers that actually execute the code (be it a Unix binary or a
dedicated Xen kernel).  It lets us write code of this form
(taken from &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/tree/master/block&quot;&gt;mirage-skeleton/block&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;let () =
  let main = foreign &amp;quot;Unikernel.Block_test&amp;quot; (console @-&amp;gt; block @-&amp;gt; job) in
  let img = block_of_file &amp;quot;disk.img&amp;quot; in
  register &amp;quot;block_test&amp;quot; [main $ default_console $ img]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this configuration fragment, our unikernel is defined as a functor over a
console and a block device by using &lt;code&gt;console @-&amp;gt; block @-&amp;gt; job&lt;/code&gt;.  We then
define a concrete version of this job by applying the functor (using the &lt;code&gt;$&lt;/code&gt;
combinator) to a default console and a file-backed disk image.&lt;/p&gt;
&lt;p&gt;The combinator approach lets us express complex assemblies of device driver
graphs by writing normal OCaml code, and the &lt;code&gt;mirage&lt;/code&gt; command line tool
parses this at build-time and generates a &lt;code&gt;main.ml&lt;/code&gt; file that has all the
functors applied to the right device drivers. Any mismatches in module signatures
will result in a build error, thus helping to spot nonsensical combinations
(such as using a Unix network socket in a Xen unikernel).&lt;/p&gt;
&lt;p&gt;This new feature is walked through in the &lt;a href=&quot;https://mirage.io/docs/hello-world&quot;&gt;tutorial&lt;/a&gt;, which
now walks you through several skeleton examples to explain all the different
deployment scenarios.  It's also followed by the &lt;a href=&quot;https://mirage.io/docs/mirage-www&quot;&gt;website tutorial&lt;/a&gt;
that explains how this website works, and how our &lt;a href=&quot;https://mirage.io/docs/deploying-via-ci&quot;&gt;Travis autodeployment&lt;/a&gt;
throws the result onto the public Internet.&lt;/p&gt;
&lt;p&gt;Who will win the race to get our website up and running first?  Sadly for Anil,
&lt;a href=&quot;http://www.cs.nott.ac.uk/~rmm/&quot;&gt;Mort&lt;/a&gt; is currently &lt;a href=&quot;https://github.com/mor1/mort-www&quot;&gt;in the
lead&lt;/a&gt; with an all-singing, all-dancing shiny
new website.  Will he finish in the lead though? Stay tuned!&lt;/p&gt;
&lt;h4&gt;Less magic in the build&lt;/h4&gt;
&lt;p&gt;Something that's more behind-the-scenes, but important for easier development,
is a simplication in how we build libraries.  In MirageOS 1.0, we had several
packages that couldn't be simultaneously installed, as they had to be compiled
in just the right order to ensure dependencies.&lt;/p&gt;
&lt;p&gt;With MirageOS 1.1.0, this is all a thing of the past.  All the libraries can
be installed fully in parallel, including the network stack.  The 1.1.0
&lt;a href=&quot;https://github.com/mirage/mirage-tcpip&quot;&gt;TCP/IP stack&lt;/a&gt; is now built in the
style of the venerable &lt;a href=&quot;http://www.cs.cmu.edu/~fox/foxnet.html&quot;&gt;FoxNet&lt;/a&gt; network
stack, and is parameterized across its network dependencies.  This means
that once can quickly assemble a custom network stack from modular components,
such as this little fragment below from &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/blob/master/ethifv4/unikernel.ml&quot;&gt;mirage-skeleton/ethifv4/&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;module Main (C: CONSOLE) (N: NETWORK) = struct

  module E = Ethif.Make(N)
  module I = Ipv4.Make(E)
  module U = Udpv4.Make(I)
  module T = Tcpv4.Flow.Make(I)(OS.Time)(Clock)(Random)
  module D = Dhcp_clientv4.Make(C)(OS.Time)(Random)(E)(I)(U)
  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This functor stack starts with a &lt;code&gt;NETWORK&lt;/code&gt; (i.e. Ethernet) device, and then applies
functors until it ends up with a UDPv4, TCPv4 and DHCPv4 client.  See the &lt;a href=&quot;https://github.com/mirage/mirage-skeleton/blob/master/ethifv4/unikernel.ml&quot;&gt;full
file&lt;/a&gt;
to see how the rest of the logic works, but this serves to illustrate how
MirageOS makes it possible to build custom network stacks out of modular
components.  The functors also make it easier to embed the network stack in
non-MirageOS applications, and the &lt;code&gt;tcpip&lt;/code&gt; OPAM package installs pre-applied Unix
versions for your toplevel convenience.&lt;/p&gt;
&lt;p&gt;To show just how powerful the functor approach is, the same stack can also
be mapped onto a version that uses kernel sockets simply by abstracting the
lower-level components into an equivalent that uses the Unix kernel to provide
the same functionality.  We explain how to swap between these variants in
the &lt;a href=&quot;https://mirage.io/wiki/hello-world&quot;&gt;tutorials&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Lots of library releases&lt;/h4&gt;
&lt;p&gt;While doing the 1.1.0 release in January, we've also released quite a few libraries
into &lt;a href=&quot;https://opam.ocaml.org&quot;&gt;OPAM&lt;/a&gt;.  Here are some of the highlights.&lt;/p&gt;
&lt;p&gt;Low-level libraries:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/samoht/ocaml-mstruct/&quot;&gt;mstruct&lt;/a&gt; is a streaming layer for handling lists of memory buffers with a simpler read/write interface.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xapi-project/nbd/&quot;&gt;nbd&lt;/a&gt; is an implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Network_block_device&quot;&gt;Network Block Device&lt;/a&gt; protocol for block drivers.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Networking and web libraries:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-ipaddr&quot;&gt;ipaddr&lt;/a&gt; now has IPv6 parsing support thanks to &lt;a href=&quot;https://github.com/hhugo/&quot;&gt;Hugo Heuzard&lt;/a&gt; and David Sheets.  This is probably the hardest bit of adding IPv6 support to our network stack!
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/cowabloga&quot;&gt;cowabloga&lt;/a&gt; is slowly emerging as a library to handle the details of rendering Zurb Foundation websites.  It's still in active development, but being used for a few of our &lt;a href=&quot;https://github.com/mor1/mort-www&quot;&gt;personal websites&lt;/a&gt; as well as this website.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/avsm/ocaml-cohttp&quot;&gt;cohttp&lt;/a&gt; has had several releases thanks to external contributions, particular from &lt;a href=&quot;https://github.com/rgrinberg&quot;&gt;Rudy Grinberg&lt;/a&gt; who added s-expression support and several &lt;a href=&quot;https://github.com/avsm/ocaml-cohttp/blob/master/CHANGES&quot;&gt;other improvements&lt;/a&gt;.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/avsm/ocaml-uri&quot;&gt;uri&lt;/a&gt; features performance improvements and the elimination of Scanf (considered &lt;a href=&quot;http://www.lexifi.com/blog/note-about-performance-printf-and-format&quot;&gt;rather slow&lt;/a&gt; by OCaml standards).
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-cow&quot;&gt;cow&lt;/a&gt; continues its impossible push to make coding HTML and CSS a pleasant experience, with better support for Markdown now.
&lt;/li&gt;
&lt;li&gt;The &lt;a href=&quot;https://github.com/avsm/ocaml-github&quot;&gt;github&lt;/a&gt; bindings are now also in use as part of an experiment to make &lt;a href=&quot;http://gallium.inria.fr/blog/patch-review-on-github/&quot;&gt;upstream OCaml development&lt;/a&gt; easier for newcomers, thanks to Gabriel Scherer.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://dave.recoil.org&quot;&gt;Dave Scott&lt;/a&gt; led the splitting up of several low-level Xen libraries as part of the build simplication.  These now compile on both Xen (using the direct hypercall interface) and Unix (using the dom0 &lt;code&gt;/dev&lt;/code&gt; devices) where possible.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xapi-project/ocaml-evtchn&quot;&gt;xen-evtchn&lt;/a&gt; for the event notification mechanism. There are a couple of wiki posts that explain how &lt;a href=&quot;https://mirage.io/wiki/xen-events&quot;&gt;event channels&lt;/a&gt; and &lt;a href=&quot;https://mirage.io/wiki/xen-suspend&quot;&gt;suspend/resume&lt;/a&gt; work in MirageOS/Xen guests.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xapi-project/ocaml-gnt&quot;&gt;xen-gnt&lt;/a&gt; for the grant table mechanism that controls inter-process memory.
&lt;/li&gt;
&lt;li&gt;The &lt;a href=&quot;https://github.com/mirage/io-page&quot;&gt;io-page&lt;/a&gt; library no longer needs Unix and Xen variants, as the interface has been standardized to work in both.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of Dave's hacking on Xen device drivers is showcased in this &lt;a href=&quot;https://mirage.io/docs/xen-synthesize-virtual-disk&quot;&gt;xen-disk wiki post&lt;/a&gt; that
explains how you can synthesize your own virtual disk backends using MirageOS.  Xen uses a &lt;a href=&quot;https://www.usenix.org/legacy/event/usenix05/tech/general/full_papers/short_papers/warfield/warfield.pdf&quot;&gt;split device&lt;/a&gt; model,
and now MirageOS lets us build &lt;em&gt;backend&lt;/em&gt; device drivers that service VMs as well as the frontends!&lt;/p&gt;
&lt;p&gt;Last, but not least, &lt;a href=&quot;http://gazagnaire.org&quot;&gt;Thomas Gazagnaire&lt;/a&gt; has been building a brand new storage system for MirageOS guests that uses git-style branches under the hood to help coordinate clusters of unikernels.  We'll talk about how this works in a future update, but there are some cool libraries and prototypes available on OPAM for the curious.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/samoht/ocaml-lazy-trie/&quot;&gt;lazy-trie&lt;/a&gt; is a lazy version of the Trie data structure, useful for exposing Git graphs.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/samoht/ocaml-git&quot;&gt;git&lt;/a&gt; is a now-fairly complete implementation of the Git protocol in pure OCaml, which can interoperate with normal Git servers via the &lt;code&gt;ogit&lt;/code&gt; command-line tool that it installs.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/irmin&quot;&gt;irmin&lt;/a&gt; is the main library that abstracts Git DAGs into an OCaml programming API.  The homepage has &lt;a href=&quot;https://github.com/mirage/irmin/wiki/Getting-Started&quot;&gt;instructions&lt;/a&gt; on how to play with the command-line frontend to experiment with the database.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/samoht/git2fat&quot;&gt;git2fat&lt;/a&gt; converts a Git checkout into a FAT block image, useful when bundling up unikernels.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'd also like to thank several conference organizers for giving us the opportunity to demonstrate MirageOS.  The talk video from &lt;a href=&quot;http://www.infoq.com/presentations/mirage-os&quot;&gt;QCon SF&lt;/a&gt; is now live, and we also had a &lt;em&gt;great&lt;/em&gt; time at &lt;a href=&quot;http://fosdem.org&quot;&gt;FOSDEM&lt;/a&gt; recently (summarized by Amir &lt;a href=&quot;http://nymote.org/blog/2014/fosdem-summary/&quot;&gt;here&lt;/a&gt;).
So lots of activities, and no doubt little bugs lurking in places (particularly around installation).  As always, please do let us know of any problem by &lt;a href=&quot;https://github.com/mirage/mirage/issues&quot;&gt;reporting bugs&lt;/a&gt;, or feel free to &lt;a href=&quot;https://mirage.io/community&quot;&gt;contact us&lt;/a&gt; via our e-mail lists or IRC.  Next stop: our unikernel homepages!&lt;/p&gt;

      </content><id>https://mirage.io/blog/mirage-1.1-released</id><title type="text">MirageOS 1.1.0: the eat-your-own-dogfood release</title><updated>2014-02-11T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/decks-n-drums" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;A few months ago, partly as a stunt, mostly because we could, Anil and I put together &lt;a href=&quot;http://decks.openmirage.org/oscon13/&quot;&gt;a presentation&lt;/a&gt; for &lt;a href=&quot;http://www.oscon.com/oscon2013/&quot;&gt;OSCON'13&lt;/a&gt; about Mirage in Mirage. That is, as a self-hosting Mirage web application that served up slides using &lt;a href=&quot;http://lab.hakim.se/reveal-js/&quot;&gt;RevealJS&lt;/a&gt;. It was a bit of a hack, but it was cool (we thought!) and it worked. Several more presentations were written and given this way, at venues ranging from the [XenSummit 2013][xensummit] to [ACM FOCI 2013][foci] to the Cambridge Computer Lab's [MSc in Advanced Computer Science][acs].&lt;/p&gt;
&lt;p&gt;[foci]: https://www.usenix.org/conference/foci13&amp;lrm;
[xensummit]: http://www.youtube.com/watch?v=3Jype6sP6MQ
[acs]: http://decks.openmirage.org/cam13/&lt;/p&gt;
&lt;p&gt;With the &lt;a href=&quot;https://mirage.io/blog/announcing-mirage10&quot;&gt;release of Mirage 1.0&lt;/a&gt;, &lt;a href=&quot;http://github.com/mirage/ocaml-cohttp&quot;&gt;CoHTTP&lt;/a&gt;, &lt;a href=&quot;http://github.com/mirage/cowabloga&quot;&gt;Cowabloga&lt;/a&gt; and
the new &lt;a href=&quot;http://foundation.zurb.com/&quot;&gt;Zurb Foundation&lt;/a&gt; based &lt;a href=&quot;https://mirage.io/&quot;&gt;website&lt;/a&gt;, it was time to refresh them
and as a little seasonal gift, give them a shiny new index with some actual CSS
styling. So &lt;a href=&quot;http://decks.openmirage.org/&quot;&gt;here they are&lt;/a&gt;, a set of presentations that have been given
by various members of the Mirage team over the last 6 months or so. They cover
a range of topics, from general introductions to the Xen roadmap to more
detailed technical background. And, of course, as Mirage is under constant
rapid development, some of the older content may already be outdated. But &lt;a href=&quot;http://github.com/mirage/mirage-decks&quot;&gt;the
code for the site itself&lt;/a&gt; serves as another example of a simple --
somewhat simpler than the &lt;a href=&quot;https://mirage.io/&quot;&gt;Mirage website&lt;/a&gt; in fact -- Mirage web
application.&lt;/p&gt;

      </content><id>https://mirage.io/blog/decks-n-drums</id><title type="text">Presenting Decks</title><updated>2014-01-03T00:00:00-00:00</updated><author><name>Richard Mortier</name></author></entry><entry><link href="https://mirage.io/blog/mirage-1.0.3-released" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We've had a lot of people trying out MirageOS since the &lt;a href=&quot;https://mirage.io/blog/announcing-mirage10&quot;&gt;1.0 release&lt;/a&gt; last week, and so we've been steadily cutting point releases and new libraries to OPAM as they're done.
The most common build error by far has been people using outdated OPAM packages.  Do make sure that you have at least &lt;a href=&quot;http://opam.ocaml.org/doc/Quick_Install.html&quot;&gt;OPAM 1.1&lt;/a&gt; installed, and that you've run &lt;code&gt;opam update -u&lt;/code&gt; to get the latest package lists from the &lt;a href=&quot;https://github.com/ocaml/opam-repository&quot;&gt;package repository&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mirage/mirage/releases/tag/1.0.3&quot;&gt;MirageOS 1.0.3&lt;/a&gt; improves
Xen configuration generation, cleans up HTTP support, and adds support for FAT
filesystems.  Here are some of the libraries we've released this week to go along with it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-www&quot;&gt;mirage-www&lt;/a&gt; (update): the live website now runs on the 1.0 tools.  Explanation of how to build it in various configurations is available &lt;a href=&quot;https://mirage.io/wiki/mirage-www&quot;&gt;here&lt;/a&gt;.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/samoht/alcotest&quot;&gt;alcotest&lt;/a&gt; (new): a lightweight and colourful test framework built over &lt;a href=&quot;http://ounit.forge.ocamlcore.org/&quot;&gt;oUnit&lt;/a&gt;.  The interface is simpler to facilitate writing tests quickly, and it formats test results nicely.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-block-xen&quot;&gt;mirage-block-xen.1.0.0&lt;/a&gt; (new): is the stable release of the Xen &lt;code&gt;Blkfront&lt;/code&gt; driver for block devices.  The library supports both frontend and backend operation, but only the frontend is plumbed through to Mirage for now (although the backend can be manually configured).
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-block-unix&quot;&gt;mirage-block-unix.1.2.0&lt;/a&gt; (update): fixed some concurrency bugs and added support for buffered I/O to improve performance.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-fat&quot;&gt;fat-filesystem.0.10.0&lt;/a&gt; (update): copies with more sector sizes, uses buffered I/O on Unix, and adds a &lt;code&gt;KV_RO&lt;/code&gt; key/value interface as well as a more complicated filesystem one.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-fs-unix&quot;&gt;mirage-fs-unix.1.0.0&lt;/a&gt; (update): implements the &lt;code&gt;KV_RO&lt;/code&gt; signature as a passthrough to a Unix filesystem.  This is convenient during development to avoid recompile cycles while changing data.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-platform&quot;&gt;mirage-xen.1.0.0&lt;/a&gt; (update): removed several distracting-but-harmless linker warnings about code bloat.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-cohttp&quot;&gt;cohttp.0.9.14&lt;/a&gt; (update): supports Server-Side Events via better channel flushing, has a complete set of HTTP codes autogenerated from &lt;a href=&quot;https://github.com/citricsquid/httpstatus.es&quot;&gt;httpstatus.es&lt;/a&gt; and exposes a platform-independent &lt;code&gt;Cohttp_lwt&lt;/code&gt; module.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/ocaml-cow&quot;&gt;cow.0.8.1&lt;/a&gt; (update): switch to the &lt;a href=&quot;https://github.com/pw374/omd&quot;&gt;Omd&lt;/a&gt; library for Markdown parsing, which is significantly more compatible with other parsers.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/samoht/ezjsonm&quot;&gt;ezjsonm.0.2.0&lt;/a&gt; (new): a combinator library to parse, select and manipulate JSON structures.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/avsm/ezxmlm&quot;&gt;ezxmlm.1.0.0&lt;/a&gt; (new): a combinator library to parse, select and transform XML tags and attributes.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mirage/mirage-http-xen&quot;&gt;mirage-http-xen&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirage/mirage-http-unix&quot;&gt;mirage-http-unix&lt;/a&gt; provide the HTTP drivers on top of Cohttp for MirageOS. Although they are very similar at the moment, they will diverge as the Unix variant gains options to use kernel sockets instead of only the network stack.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We're making great progress on moving our personal homepages over to MirageOS.  The first two introductory wiki posts are also now available:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/wiki/hello-world&quot;&gt;Building a hello world example&lt;/a&gt; takes you through the basic steps to build a Unix and Xen binary.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mirage.io/wiki/mirage-www&quot;&gt;Building the MirageOS website&lt;/a&gt; lets you build this website with several variants, demonstrating the Unix passthrough filesystem, the OCaml FAT filesystem library, and how to attach a network stack to your application.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As always, please feel free to report any issues via the &lt;a href=&quot;https://github.com/mirage/mirage/issues&quot;&gt;bug tracker&lt;/a&gt; and ask questions on the &lt;a href=&quot;mailto:mirageos-devel@lists.xenproject.org&quot;&gt;mailing list&lt;/a&gt;.&lt;/p&gt;

      </content><id>https://mirage.io/blog/mirage-1.0.3-released</id><title type="text">MirageOS 1.0.3 released; tutorial on building this website available</title><updated>2013-12-19T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage10" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;em&gt;First&lt;/em&gt;: read the &lt;a href=&quot;https://mirage.io/wiki/overview-of-mirage&quot;&gt;overview&lt;/a&gt; and
&lt;a href=&quot;https://mirage.io/wiki/technical-background&quot;&gt;technical background&lt;/a&gt; behind the project.&lt;/p&gt;
&lt;p&gt;When we started hacking on MirageOS back in 2009, it started off looking like a
conventional OS, except written in OCaml.   The &lt;a href=&quot;https://github.com/mirage/mirage/tree/old-master&quot;&gt;monolithic
repository&lt;/a&gt; contained all the
libraries and boot code, and exposed a big &lt;code&gt;OS&lt;/code&gt; module for applications to use.
We used this to do several fun &lt;a href=&quot;http://cufp.org/conference/sessions/2011/t3-building-functional-os&quot;&gt;tutorials&lt;/a&gt; at conferences
such as ICFP/CUFP and get early feedback.&lt;/p&gt;
&lt;p&gt;As development continued though, we started to understand what it is we were
building: a &lt;a href=&quot;http://anil.recoil.org/papers/2013-asplos-mirage.pdf&quot;&gt;&amp;quot;library operating system&amp;quot;&lt;/a&gt;.  As the number of libraries grew,
putting everything into one repository just wasn't scaling, and it made it hard
to work with third-party code.  We spent some time developing tools to make
Mirage fit into the broader OCaml ecosystem.&lt;/p&gt;
&lt;p&gt;Three key things have emerged from this effort:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://opam.ocaml.org&quot;&gt;OPAM&lt;/a&gt;, a source-based package manager for
OCaml. It supports multiple simultaneous compiler installations, flexible
package constraints, and a Git-friendly development workflow.  Since
releasing 1.0 in March 2013 and 1.1 in October, the community has leapt
in to contribute over 1800 packages in this short time.  All of the
Mirage libraries are now tracked using it, including the Xen libraries.
&lt;/li&gt;
&lt;li&gt;The build system for embedded programming (such as the Xen target) is
a difficult one to get right.  After several experiments, Mirage provides
a single &lt;strong&gt;&lt;a href=&quot;https://github.com/mirage/mirage&quot;&gt;command-line tool&lt;/a&gt;&lt;/strong&gt; that
combines configuration directives (also written in OCaml) with OPAM to
make building Xen unikernels as easy as Unix binaries.
&lt;/li&gt;
&lt;li&gt;All of the Mirage-compatible libraries satisfy a set of module type
signatures in a &lt;strong&gt;&lt;a href=&quot;https://github.com/mirage/mirage-types/blob/master/lib/v1.mli&quot;&gt;single file&lt;/a&gt;&lt;/strong&gt;.
This is where Mirage lives up to its name: we've gone from the early
monolithic repository to a single, standalone interface file that
describes the interfaces.  Of course, we also have libraries to go along
with this signature, and they all live in the &lt;a href=&quot;https://github.com/mirage&quot;&gt;MirageOS GitHub organization&lt;/a&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With these components, I'm excited to announce that MirageOS 1.0 is finally ready
to see the light of day!  Since it consists of so many libraries, we've decided
not to have a &amp;quot;big bang&amp;quot; release where we dump fifty complex libraries on the
open-source community.  Instead, we're going to spend the month of December
writing a series of blog posts that explain how the core components work,
leading up to several use cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The development team have all decided to shift our personal homepages to be Mirage
kernels running on Xen as a little Christmas present to ourselves, so we'll work through that step-by-step how to build
a dedicated unikernel and maintain and deploy it (&lt;strong&gt;spoiler:&lt;/strong&gt; see &lt;a href=&quot;https://github.com/mirage/mirage-www-deployment&quot;&gt;this repo&lt;/a&gt;).  This will culminate in
a webservice that our colleagues at &lt;a href=&quot;http://horizon.ac.uk&quot;&gt;Horizon&lt;/a&gt; have been
building using Android apps and an HTTP backend.
&lt;/li&gt;
&lt;li&gt;The &lt;a href=&quot;http://xenserver.org&quot;&gt;XenServer&lt;/a&gt; crew at Citrix are using Mirage to build custom middlebox VMs
such as block device caches.
&lt;/li&gt;
&lt;li&gt;For teaching purposes, the &lt;a href=&quot;http://ocaml.io&quot;&gt;Cambridge Computer Lab team&lt;/a&gt; want a JavaScript backend,
so we'll explain how to port Mirage to this target (which is rather different
from either Unix or Xen, and serves to illustrate the portability of our approach).
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;How to get involved&lt;/h3&gt;
&lt;p&gt;Bear with us while we update all the documentation and start the blog posts off
today (the final libraries for the 1.0 release are all being merged into OPAM
while I write this, and the usually excellent &lt;a href=&quot;http://travis-ci.org&quot;&gt;Travis&lt;/a&gt; continuous integration system is down due to a &lt;a href=&quot;https://github.com/travis-ci/travis-ci/issues/1727&quot;&gt;bug&lt;/a&gt; on their side).  I'll edit this post to contain links to the future posts
as they happen.&lt;/p&gt;
&lt;p&gt;Since we're now also a proud Xen and Linux Foundation incubator project, our mailing
list is shifting to &lt;a href=&quot;http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel&quot;&gt;mirageos-devel@lists.xenproject.org&lt;/a&gt;, and we very much
welcome comments and feedback on our efforts over there.
The &lt;code&gt;#mirage&lt;/code&gt; channel on FreeNode IRC is also growing increasingly popular, as
is simply reporting issues on the main &lt;a href=&quot;http://github.com/mirage/mirage&quot;&gt;Mirage GitHub&lt;/a&gt; repository.&lt;/p&gt;
&lt;p&gt;Several people have also commented that they want to learn OCaml properly to
start using Mirage.  I've just co-published an O'Reilly book called
&lt;a href=&quot;https://realworldocaml.org&quot;&gt;Real World OCaml&lt;/a&gt; that's available for free online
and also as hardcopy/ebook.  Our Cambridge colleague John Whittington has
also written an excellent &lt;a href=&quot;http://ocaml-book.com/&quot;&gt;introductory text&lt;/a&gt;, and
you can generally find more resources &lt;a href=&quot;http://ocaml.org/docs/&quot;&gt;online&lt;/a&gt;.
Feel free to ask beginner OCaml questions on our mailing lists and we'll help
as best we can!&lt;/p&gt;

      </content><id>https://mirage.io/blog/announcing-mirage10</id><title type="text">MirageOS 1.0: not just a hallucination!</title><updated>2013-12-09T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/introducing-vchan" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;em&gt;Editor&lt;/em&gt;: Note that some of the toolchain details of this blog post are
now out-of-date with Mirage 1.1, so we will update this shortly.&lt;/p&gt;
&lt;p&gt;Unless you are familiar with Xen's source code, there is little chance
that you've ever heard of the &lt;em&gt;vchan&lt;/em&gt; library or
protocol. Documentation about it is very scarce: a description can be
found on vchan's
&lt;a href=&quot;http://xenbits.xen.org/gitweb/?p=xen.git%3Ba=blob%3Bf=xen/include/public/io/libxenvchan.h%3Bhb=HEAD&quot;&gt;public header file&lt;/a&gt;,
that I quote here for convenience:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Originally borrowed from the
&lt;a href=&quot;http://www.qubes-os.org&quot;&gt;Qubes OS Project&lt;/a&gt;, this code (i.e. libvchan)
has been substantially rewritten [...]
This is a library for inter-domain communication.  A standard Xen ring
buffer is used, with a datagram-based interface built on top.  The
grant reference and event channels are shared in XenStore under a
user-specified path.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This protocol uses shared memory for inter-domain communication,
i.e. between two VMs residing in the same Xen host, and uses Xen's
mechanisms -- more specifically,
&lt;a href=&quot;http://www.informit.com/articles/article.aspx?p=1160234&amp;amp;seqNum=3&quot;&gt;ring buffers&lt;/a&gt;
and
&lt;a href=&quot;http://xenbits.xen.org/gitweb/?p=xen.git%3Ba=blob%3Bf=tools/libxc/xenctrl.h%3Bh=f2cebafc9ddd4815ffc73fcf9e0d292b1d4c91ff%3Bhb=HEAD#l934&quot;&gt;event channels&lt;/a&gt;
-- in order to achieve its aims. &lt;em&gt;Datagram-based interface&lt;/em&gt; simply
means that the
&lt;a href=&quot;http://xenbits.xen.org/gitweb/?p=xen.git%3Ba=blob%3Bf=tools/libvchan/libxenvchan.h%3Bh=6365d36a06f8c8f56454724cefc4c2f1d39beba2%3Bhb=HEAD&quot;&gt;interface&lt;/a&gt;
resembles UDP, although there is support for stream based communication (like
TCP) as well.&lt;/p&gt;
&lt;p&gt;Over the last two months or so, I worked on a &lt;a href=&quot;http://github.com/mirage/ocaml-vchan&quot;&gt;pure OCaml
implementation&lt;/a&gt; of this library, meaning
that Mirage-based unikernels can now take full advantage of &lt;em&gt;vchan&lt;/em&gt; to
communicate with neighboring VMs! If your endpoint -- a Linux VM or another
unikernel -- is on the same host, it is much faster and more efficient to use
vchan rather than the network stack (although unfortunately, it is currently
incompatible with existing programs written against the &lt;code&gt;socket&lt;/code&gt; library under
UNIX or the &lt;code&gt;Flow&lt;/code&gt; module of Mirage, although this will improve). It also
provides a higher level of security compared to network sockets as messages
will never leave the host's shared memory.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Building the vchan echo domain&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Provided that you have a Xen-enabled machine, do the following from
dom0:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    opam install mirari mirage-xen mirage vchan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will install the library and its dependencies. &lt;code&gt;mirari&lt;/code&gt; is
necessary to build the &lt;em&gt;echo unikernel&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    git clone https://github.com/mirage/ocaml-vchan
    cd test
    mirari configure --xen --no-install
    mirari build --xen
    sudo mirari run --xen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will boot a &lt;code&gt;vchan echo domain&lt;/code&gt; for dom0, with connection
parameters stored in xenstore at &lt;code&gt;/local/domain/&amp;lt;domid&amp;gt;/data/vchan&lt;/code&gt;,
where &lt;code&gt;&amp;lt;domid&amp;gt;&lt;/code&gt; is the domain id of the vchan echo domain. The echo
domain is simply an unikernel hosting a vchan server accepting
connections from dom0, and echo'ing everything that is sent to it.&lt;/p&gt;
&lt;p&gt;The command &lt;code&gt;xl list&lt;/code&gt; will give you the domain id of the echo
server.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Building the vchan CLI from Xen's sources&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You can try it using a vchan client that can be found in Xen's sources
at &lt;code&gt;tools/libvchan&lt;/code&gt;: Just type &lt;code&gt;make&lt;/code&gt; in this directory. It will
compile the executable &lt;code&gt;vchan-node2&lt;/code&gt; that you can use to connect to
our freshly created echo domain:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    ./vchan-node2 client &amp;lt;domid&amp;gt;/local/domain/&amp;lt;domid&amp;gt;/data/vchan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If everything goes well, what you type in there will be echoed.&lt;/p&gt;
&lt;p&gt;You can obtain the full API documentation for &lt;em&gt;ocaml-vchan&lt;/em&gt; by doing a
&lt;code&gt;cd ocaml-vchan &amp;amp;&amp;amp; make doc&lt;/code&gt;. If you are doing network programming
under UNIX, vchan's interface will not surprise you. If you are
already using vchan for a C project, you will see that the OCaml API
is nearly identical to what you are used to.&lt;/p&gt;
&lt;p&gt;Please let us know if you use or plan to use this library in any way!
If you need tremedous speed or more security, this might fit your
needs.&lt;/p&gt;

      </content><id>https://mirage.io/blog/introducing-vchan</id><title type="text">Introducing vchan</title><updated>2013-08-23T00:00:00-00:00</updated><author><name>Vincent Bernardoff</name></author></entry><entry><link href="https://mirage.io/blog/oscon13-trip-report" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Now that Mirage OS is rapidly converging on a
&lt;a href=&quot;http://github.com/avsm/mirage/issues/102&quot;&gt;Developer Preview Release 1&lt;/a&gt;, we
took it for a first public outing at
&lt;a href=&quot;http://www.oscon.com/oscon2013/&quot;&gt;OSCON'13&lt;/a&gt;, the O'Reilly Open Source
Conference. OSCON is in its 15th year now, and is a meeting place for
developers, business people and investors. It was a great opportunity to show
MirageOS off to some of the movers and shakers in the OSS world.&lt;/p&gt;
&lt;p&gt;Partly because MirageOS is about synthesising extremely specialised guest
kernels from high-level code, and partly because both Anil and I are
constitutionally incapable of taking the easy way out, we self-hosted the
slide deck on Mirage: after some last-minute hacking -- on content not Mirage
I should add! -- we built a self-contained unikernel of the talk.&lt;/p&gt;
&lt;p&gt;This was what you might call a &amp;quot;full stack&amp;quot; presentation: the custom
unikernel (flawlessly!) ran a type-safe
&lt;a href=&quot;https://github.com/mirage/mirage-platform/blob/master/xen/lib/netif.ml&quot;&gt;network device driver&lt;/a&gt;,
OCaml &lt;a href=&quot;http://github.com/mirage/mirage-net&quot;&gt;TCP/IP stack&lt;/a&gt; supporting an OCaml
&lt;a href=&quot;http://github.com/mirage/ocaml-cohttp&quot;&gt;HTTP&lt;/a&gt; framework that served slides
rendered using &lt;a href=&quot;http://lab.hakim.se/reveal-js/&quot;&gt;reveal.js&lt;/a&gt;. The slide deck,
including the turbo-boosted
&lt;a href=&quot;http://www.youtube.com/watch?v=2Mx8Bd5JYyo&quot;&gt;screencast&lt;/a&gt; of the slide deck
compilation, is hosted as another MirageOS virtual machine at
&lt;a href=&quot;http://decks.openmirage.org/&quot;&gt;decks.openmirage.org&lt;/a&gt;. We hope to add more
slide decks there soon, including resurrecting the tutorial! The source code
for all this is in the &lt;a href=&quot;http://github.com/mirage/mirage-decks&quot;&gt;mirage-decks&lt;/a&gt;
GitHub repo.&lt;/p&gt;
&lt;h3&gt;The Talk&lt;/h3&gt;
&lt;p&gt;The talk went down pretty well -- given we were in a graveyard slot on Friday
after many people had left, attendance was fairly high (around 30-40), and the
&lt;a href=&quot;http://www.oscon.com/oscon2013/public/schedule/detail/28956&quot;&gt;feedback scores&lt;/a&gt;
have been positive (averaging 4.7/5) with comments including &amp;quot;excellent
content and well done&amp;quot; and &amp;quot;one of the most excited projects I heard about&amp;quot;
(though we are suspicious that just refers to Anil's usual high-energy
presentation style...).&lt;/p&gt;
&lt;iframe align=&quot;right&quot; style=&quot;margin-left: 10px;&quot; width=&quot;420&quot; height=&quot;235&quot; src=&quot;//www.youtube-nocookie.com/embed/2Mx8Bd5JYyo&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;1&quot;&gt; &lt;/iframe&gt;
&lt;p&gt;Probably the most interesting chat after the talk was with the Rust authors
at Mozilla (&lt;a href=&quot;http://twitter.com/pcwalton&quot;&gt;@pcwalton&lt;/a&gt; and
&lt;a href=&quot;https://github.com/brson&quot;&gt;@brson&lt;/a&gt;) about combining the Mirage
&lt;a href=&quot;http://anil.recoil.org/papers/2013-asplos-mirage.pdf&quot;&gt;unikernel&lt;/a&gt; techniques
with the &lt;a href=&quot;http://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt; runtime. But perhaps the most
surprising feedback was when Anil and I were stopped in the street while
walking back from some well-earned sushi, by a cyclist who loudly declared
that he'd really enjoyed the talk and thought it was a really exciting project
-- never done something that achieved public acclaim from the streets before
:)&lt;/p&gt;
&lt;h3&gt;Book Signing and Xen.org&lt;/h3&gt;
&lt;p&gt;Anil also took some time to sit in a book signing for his forthcoming
&lt;a href=&quot;http://realworldocaml.org&quot;&gt;Real World OCaml&lt;/a&gt; O'Reilly book.  This is
really important to making OCaml easier to learn, especially given that
all the Mirage libraries are using it.  Most of the dev team (and especially
thanks to &lt;a href=&quot;https://twitter.com/heidiann360&quot;&gt;Heidi Howard&lt;/a&gt; who bravely worked
through really early alpha revisions) have been giving
us feedback as the book is written, using the online commenting system.&lt;/p&gt;
&lt;p&gt;The Xen.org booth was also huge, and we spent quite a while plotting the
forthcoming Mirage/Xen/ARM backend. We're pretty much just waiting for the
&lt;a href=&quot;http://cubieboard.org&quot;&gt;Cubieboard2&lt;/a&gt; kernel patches to be upstreamed (keep an
eye &lt;a href=&quot;http://linux-sunxi.org/Main_Page&quot;&gt;here&lt;/a&gt;) so that we can boot Xen/ARM VMs
on tiny ARM devices.  There's a full report about this on the
&lt;a href=&quot;http://blog.xen.org/index.php/2013/07/31/the-xen-project-at-oscon/&quot;&gt;xen.org&lt;/a&gt;
blog post about OSCon.&lt;/p&gt;
&lt;h3&gt;Galois and HalVM&lt;/h3&gt;
&lt;p&gt;We also stopped by the &lt;a href=&quot;http://galois.com&quot;&gt;Galois&lt;/a&gt; to chat with &lt;a href=&quot;https://twitter.com/acwpdx&quot;&gt;Adam
Wick&lt;/a&gt;, who is the leader of the
&lt;a href=&quot;https://galois.com/project/halvm/&quot;&gt;HalVM&lt;/a&gt; project at Galois. This is a similar
project to Mirage, but, since it's written in Haskell, has more of a focus
on elegant compositional semantics rather than the more brutal performance
and predictability that Mirage currently has at its lower levels.&lt;/p&gt;
&lt;p&gt;The future of all this ultimately lies in making it easier for these
multi-lingual unikernels to be managed and for all of them to communicate more
easily, so we chatted about code sharing and common protocols (such as
&lt;a href=&quot;https://github.com/vbmithr/ocaml-vchan&quot;&gt;vchan&lt;/a&gt;) to help interoperability.
Expect to see more of this once our respective implementations get more
stable.&lt;/p&gt;
&lt;p&gt;All-in-all OSCON'13 was a fun event and definitely one that we look forward
returning to with a more mature version of MirageOS, to build on the momentum
begun this year!  Portland was an amazing host city too, but what happens in
Portland, stays in Portland...&lt;/p&gt;

      </content><id>https://mirage.io/blog/oscon13-trip-report</id><title type="text">MirageOS travels to OSCON'13: a trip report</title><updated>2013-08-08T00:00:00-00:00</updated><author><name>Richard Mortier</name></author></entry><entry><link href="https://mirage.io/blog/xen-block-devices-with-mirage" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;a href=&quot;https://mirage.io/&quot;&gt;MirageOS&lt;/a&gt; is a
&lt;a href=&quot;http://anil.recoil.org/papers/2013-asplos-mirage.pdf&quot;&gt;unikernel&lt;/a&gt;
or &amp;quot;library operating system&amp;quot; that allows us to build applications
which can be compiled to very diverse environments: the same code can be linked
to run as a regular Unix app, relinked to run as a &lt;a href=&quot;https://github.com/pgj/mirage-kfreebsd&quot;&gt;FreeBSD kernel module&lt;/a&gt;,
and even linked into a
self-contained kernel which can run on the &lt;a href=&quot;http://www.xenproject.org/&quot;&gt;Xen
hypervisor&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Mirage has access to an extensive suite of pure OCaml &lt;a href=&quot;https://github.com/mirage&quot;&gt;libraries&lt;/a&gt;,
covering everything from Xen &lt;a href=&quot;https://github.com/mirage/ocaml-xen-block-driver&quot;&gt;block&lt;/a&gt; and &lt;a href=&quot;https://github.com/mirage/mirage-platform/blob/master/xen/lib/netif.ml&quot;&gt;network&lt;/a&gt; virtual device drivers,
a &lt;a href=&quot;https://github.com/mirage/mirage-net&quot;&gt;TCP/IP stack&lt;/a&gt;, OpenFlow learning switches and controllers, to
SSH and &lt;a href=&quot;https://github.com/mirage/ocaml-cohttp&quot;&gt;HTTP&lt;/a&gt; server implementations.&lt;/p&gt;
&lt;p&gt;I normally use Mirage to deploy applications as kernels on top of
a &lt;a href=&quot;http://www.xenserver.org/&quot;&gt;XenServer&lt;/a&gt; hypervisor. I start by
first using the Mirage libraries within a normal Unix userspace
application -- where I have access to excellent debugging tools --
and then finally link my app as a high-performance Xen kernel for
production.&lt;/p&gt;
&lt;p&gt;However Mirage is great for more than simply building Xen kernels.
In this post I'll describe how I've been using Mirage to create
experimental virtual disk devices for existing Xen VMs (which may
themselves be Linux, *BSD, Windows or even Mirage kernels).
The Mirage libraries let me easily
experiment with different backend file formats and protocols, all while
writing only type-safe OCaml code thats runs in userspace in a normal
Linux domain 0.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Disk devices under Xen&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The protocols used by Xen disk and network devices are designed to
permit fast and efficient software implementations, avoiding the
inefficiencies inherent in emulating physical hardware in software.
The protocols are based on two primitives:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;shared memory pages&lt;/em&gt;: used for sharing both data and metadata
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;event channels&lt;/em&gt;: similar to interrupts, these allow one side to signal the other
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the disk block protocol, the protocol starts with the client
(&amp;quot;frontend&amp;quot; in Xen jargon) sharing a page with the server (&amp;quot;backend&amp;quot;).
This single page will contain the request/response metadata, arranged
as a circular buffer or &amp;quot;ring&amp;quot;. The client (&amp;quot;frontend&amp;quot;) can then start
sharing pages containing disk blocks with the backend and pushing request
structures to the ring, updating shared pointers as it goes. The client
will give the server end a kick via an event channel signal and then both
ends start running simultaneously. There are no locks in the protocol so
updates to the shared metadata must be handled carefully, using write
memory barriers to ensure consistency.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Xen disk devices in MirageOS&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Like everything else in Mirage, Xen disk devices are implemented as
libraries. The ocamlfind library called &amp;quot;xenctrl&amp;quot; provides support for
manipulating blocks of raw memory pages, &amp;quot;granting&amp;quot; access to them to
other domains and signalling event channels. There are two implementations
of &amp;quot;xenctrl&amp;quot;:
&lt;a href=&quot;https://github.com/mirage/mirage-platform/tree/master/xen/lib&quot;&gt;one that invokes Xen &amp;quot;hypercalls&amp;quot; directly&lt;/a&gt;
and one which uses the &lt;a href=&quot;https://github.com/xapi-project/ocaml-xen-lowlevel-libs&quot;&gt;Xen userspace library libxc&lt;/a&gt;.
Both implementations satisfy a common signature, so it's easy to write
code which will work in both userspace and kernelspace.&lt;/p&gt;
&lt;p&gt;The ocamlfind library
&lt;a href=&quot;https://github.com/mirage/shared-memory-ring&quot;&gt;shared-memory-ring&lt;/a&gt;
provides functions to create and manipulate request/response rings in shared
memory as used by the disk and network protocols. This library is a mix of
99.9% OCaml and 0.1% asm, where the asm is only needed to invoke memory
barrier operations to ensure that metadata writes issued by one CPU core
appear in the same order when viewed from another CPU core.&lt;/p&gt;
&lt;p&gt;Finally the ocamlfind library
&lt;a href=&quot;https://github.com/mirage/ocaml-xen-block-driver&quot;&gt;xenblock&lt;/a&gt;
provides functions to hotplug and hotunplug disk devices, together with an
implementation of the disk block protocol itself.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Making custom virtual disk servers with MirageOS&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Let's experiment with making our own virtual disk server based on
the Mirage example program, &lt;a href=&quot;https://github.com/mirage/xen-disk&quot;&gt;xen-disk&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First, install &lt;a href=&quot;http://www.xen.org/&quot;&gt;Xen&lt;/a&gt;, &lt;a href=&quot;http://www.ocaml.org/&quot;&gt;OCaml&lt;/a&gt;
and &lt;a href=&quot;http://opam.ocamlpro.com/&quot;&gt;OPAM&lt;/a&gt;. Second initialise your system:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  opam init
  eval `opam config env`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At the time of writing, not all the libraries were released as upstream
OPAM packages, so it was necessary to add some extra repositories. This
should not be necessary after the Mirage developer preview at
&lt;a href=&quot;http://www.oscon.com/oscon2013/public/schedule/detail/28956&quot;&gt;OSCON 2013&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  opam remote add mirage-dev https://github.com/mirage/opam-repo-dev
  opam remote add xapi-dev https://github.com/xapi-project/opam-repo-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install the unmodified &lt;code&gt;xen-disk&lt;/code&gt; package, this will ensure all the build
dependencies are installed:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  opam install xen-disk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When this completes it will have installed a command-line tool called
&lt;code&gt;xen-disk&lt;/code&gt;. If you start a VM using your Xen toolstack of choice
(&amp;quot;xl create ...&amp;quot; or &amp;quot;xe vm-install ...&amp;quot; or &amp;quot;virsh create ...&amp;quot;) then you
should be able to run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  xen-disk connect &amp;lt;vmname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will hotplug a fresh block device into the VM &amp;quot;&lt;code&gt;&amp;lt;vmname&amp;gt;&lt;/code&gt;&amp;quot; using the
&amp;quot;discard&amp;quot; backend, which returns &amp;quot;success&amp;quot; to all read and write requests,
but actually throws all data away. Obviously this backend should only be
used for basic testing!&lt;/p&gt;
&lt;p&gt;Assuming that worked ok, clone and build the source for &lt;code&gt;xen-disk&lt;/code&gt; yourself:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  git clone https://github.com/mirage/xen-disk
  cd xen-disk
  make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Making a custom virtual disk implementation&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;xen-disk&lt;/code&gt; program has a set of simple built-in virtual disk implementations.
Each one satisifies a simple signature, contained in
&lt;a href=&quot;https://github.com/mirage/xen-disk/blob/master/src/storage.mli&quot;&gt;src/storage.mli&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;type configuration = {
  filename: string;      (** path where the data will be stored *)
  format: string option; (** format of physical data *)
}
(** Information needed to &amp;quot;open&amp;quot; a disk *)

module type S = sig
  (** A concrete mechanism to access and update a virtual disk. *)

  type t
  (** An open virtual disk *)

  val open_disk: configuration -&amp;gt; t option Lwt.t
  (** Given a configuration, attempt to open a virtual disk *)

  val size: t -&amp;gt; int64
  (** [size t] is the size of the virtual disk in bytes. The actual
      number of bytes stored on media may be different. *)

  val read: t -&amp;gt; Cstruct.t -&amp;gt; int64 -&amp;gt; int -&amp;gt; unit Lwt.t
  (** [read t buf offset_sectors len_sectors] copies [len_sectors]
      sectors beginning at sector [offset_sectors] from [t] into [buf] *)

  val write: t -&amp;gt; Cstruct.t -&amp;gt; int64 -&amp;gt; int -&amp;gt; unit Lwt.t
  (** [write t buf offset_sectors len_sectors] copies [len_sectors]
      sectors from [buf] into [t] beginning at sector [offset_sectors]. *)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's make a virtual disk implementation which uses an existing disk
image file as a &amp;quot;gold image&amp;quot;, but uses copy-on-write so that no writes
persist.
This is a common configuration in Virtual Desktop Infrastructure deployments
and is generally handy when you want to test a change quickly, and
revert it cleanly afterwards.&lt;/p&gt;
&lt;p&gt;A useful Unix technique for file I/O is to &amp;quot;memory map&amp;quot; an existing file:
this associates the file contents with a range of virtual memory addresses
so that reading and writing within this address range will actually
read or write the file contents.
The &amp;quot;mmap&amp;quot; C function has a number of flags, which can be used to request
&amp;quot;copy on write&amp;quot; behaviour. Reading the
&lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.Genarray.html&quot;&gt;OCaml manual Bigarray.map_file&lt;/a&gt;
it says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If shared is true, all modifications performed on the array are reflected
in the file. This requires that fd be opened with write permissions. If
shared is false, modifications performed on the array are done in memory
only, using copy-on-write of the modified pages; the underlying file is
not affected.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So we should be able to make a virtual disk implementation which memory
maps the image file and achieves copy-on-write by setting &amp;quot;shared&amp;quot; to false.
For extra safety we can also open the file read-only.&lt;/p&gt;
&lt;p&gt;Luckily there is already an
&lt;a href=&quot;https://github.com/mirage/xen-disk/blob/master/src/backend.ml#L63&quot;&gt;&amp;quot;mmap&amp;quot; implementation&lt;/a&gt;
in &lt;code&gt;xen-disk&lt;/code&gt;; all we need to do is tweak it slightly.
Note that the &lt;code&gt;xen-disk&lt;/code&gt; program uses a co-operative threading library called
&lt;a href=&quot;http://ocsigen.org/lwt/&quot;&gt;lwt&lt;/a&gt;
which replaces functions from the OCaml standard library which might block
with non-blocking variants. In
particular &lt;code&gt;lwt&lt;/code&gt; uses &lt;code&gt;Lwt_bytes.map_file&lt;/code&gt; as a wrapper for the
&lt;code&gt;Bigarray.Array1.map_file&lt;/code&gt; function.
In the &amp;quot;open-disk&amp;quot; function we simply need to set &amp;quot;shared&amp;quot; to &amp;quot;false&amp;quot; to
achieve the behaviour we want i.e.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  let open_disk configuration =
    let fd = Unix.openfile configuration.filename [ Unix.O_RDONLY ] 0o0 in
    let stats = Unix.LargeFile.fstat fd in
    let mmap = Lwt_bytes.map_file ~fd ~shared:false () in
    Unix.close fd;
    return (Some (stats.Unix.LargeFile.st_size, Cstruct.of_bigarray mmap))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The read and write functions can be left as they are:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  let read (_, mmap) buf offset_sectors len_sectors =
    let offset_sectors = Int64.to_int offset_sectors in
    let len_bytes = len_sectors * sector_size in
    let offset_bytes = offset_sectors * sector_size in
    Cstruct.blit mmap offset_bytes buf 0 len_bytes;
    return ()

  let write (_, mmap) buf offset_sectors len_sectors =
    let offset_sectors = Int64.to_int offset_sectors in
    let offset_bytes = offset_sectors * sector_size in
    let len_bytes = len_sectors * sector_size in
    Cstruct.blit buf 0 mmap offset_bytes len_bytes;
    return () 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if we rebuild and run something like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  dd if=/dev/zero of=disk.raw bs=1M seek=1024 count=1
  losetup /dev/loop0 disk.raw
  mkfs.ext3 /dev/loop0
  losetup -d /dev/loop0

  dist/build/xen-disk/xen-disk connect &amp;lt;myvm&amp;gt; --path disk.raw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inside the VM we should be able to do some basic speed testing:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  # dd if=/dev/xvdb of=/dev/null bs=1M iflag=direct count=100
  100+0 records in
  100+0 records out
  104857600 bytes (105 MB) copied, 0.125296 s, 837 MB/s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Plus we should be able to mount the filesystem inside the VM, make changes and
then disconnect (send SIGINT to xen-disk by hitting Control+C on your terminal)
without disturbing the underlying disk contents.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;So what else can we do?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Thanks to Mirage it's now really easy to experiment with custom storage types
for your existing VMs. If you have a cunning scheme where you want to hash block contents,
and use the hashes as keys in some distributed datastructure -- go ahead, it's
all easy to do. If you have ideas for improving the low-level block access protocol
then Mirage makes those experiments very easy too.&lt;/p&gt;
&lt;p&gt;If you come up with a cool example with Mirage, then send us a
&lt;a href=&quot;https://github.com/mirage&quot;&gt;pull request&lt;/a&gt; or send us an email to the
&lt;a href=&quot;https://mirage.io/about/&quot;&gt;Mirage mailing list&lt;/a&gt; -- we'd
love to hear about it!&lt;/p&gt;

      </content><id>https://mirage.io/blog/xen-block-devices-with-mirage</id><title type="text">Creating Xen block devices with MirageOS</title><updated>2013-07-18T00:00:00-00:00</updated><author><name>Dave Scott</name></author></entry><entry><link href="https://mirage.io/blog/the-road-to-a-dev-release" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;There's been a crazy stream of activity since the start of the year, but the most important news is that we have a release target for an integrated developer preview of the Mirage stack: a talk at &lt;a href=&quot;http://www.oscon.com/oscon2013/public/schedule/detail/28956&quot;&gt;O'Reilly OSCon&lt;/a&gt; in July!  Do turn up there and find &lt;a href=&quot;http://dave.recoil.org&quot;&gt;Dave Scott&lt;/a&gt; and &lt;a href=&quot;http://anil.recoil.org&quot;&gt;Anil Madhavapeddy&lt;/a&gt; showing off interactive demonstrations.&lt;/p&gt;
&lt;p&gt;Meanwhile, another significant announcement has been that Xen is &lt;a href=&quot;http://www.linuxfoundation.org/news-media/announcements/2013/04/xen-become-linux-foundation-collaborative-project&quot;&gt;joining the Linux Foundation&lt;/a&gt; as a collaborative project.  This is great news for Mirage: as a library operating system, we can operate just as easily under other hypervisors, and even on bare-metal devices such as the &lt;a href=&quot;http://raspberrypi.org&quot;&gt;Raspberry Pi&lt;/a&gt;.  We're very much looking forward to getting the Xen-based developer release done, and interacting with the wider Linux community (and FreeBSD, for that matter, thanks to Gabor Pali's &lt;a href=&quot;https://github.com/pgj/mirage-kfreebsd&quot;&gt;kFreeBSD&lt;/a&gt; backend).&lt;/p&gt;
&lt;p&gt;Here's some other significant news from the past few months:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ocamlpro.com/blog/2013/03/14/opam-1.0.0.html&quot;&gt;OPAM 1.0 was released&lt;/a&gt;, giving Mirage a solid package manager for handling the many libraries required to glue an application together.  &lt;a href=&quot;https://github.com/vbmithr&quot;&gt;Vincent Bernardoff&lt;/a&gt; joined the team at Citrix and has been building a Mirage build-frontend called &lt;a href=&quot;https://github.com/mirage/mirari&quot;&gt;Mirari&lt;/a&gt; to hide much of the system complexity from a user who isn't too familiar with either Xen or OCaml.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A new group called the &lt;a href=&quot;http://ocaml.io&quot;&gt;OCaml Labs&lt;/a&gt; has started up in the &lt;a href=&quot;http://www.cl.cam.ac.uk&quot;&gt;Cambridge Computer Laboratory&lt;/a&gt;, and is working on improving the OCaml toolchain and platform.  This gives Mirage a big boost, as we can re-use several of the documentation, build and test improvements in our own releases.  You can read up on the group's activities via the &lt;a href=&quot;http://ocaml.io/news&quot;&gt;monthly updates&lt;/a&gt;, or browse through the various &lt;a href=&quot;http://ocaml.io/tasks&quot;&gt;projects&lt;/a&gt;.  One of the more important projects is the &lt;a href=&quot;http://www.cl.cam.ac.uk/projects/ocamllabs/tasks/platform.html#OCamlot&quot;&gt;OCamlot&lt;/a&gt; continuous build infrastructure, which will also be testing Mirage kernels as one of the supported backends.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;As we head into release mode, we've started &lt;a href=&quot;https://mirage.io/wiki#Weekly-calls-and-release-notes&quot;&gt;weekly meetings&lt;/a&gt; to coordinate all the activities.  We're keeping notes as we go along, so you should be able to skim the notes and &lt;a href=&quot;https://lists.cam.ac.uk/pipermail/cl-mirage/&quot;&gt;mailing list archives&lt;/a&gt; to get a feel for the overall activities.  Anil is maintaining a &lt;a href=&quot;https://mirage.github.io/wiki/dev-preview-checklist&quot;&gt;release checklist&lt;/a&gt; for the summer developer preview.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Anil (along with Yaron Minsky and Jason Hickey) is finishing up an O'Reilly book on &lt;a href=&quot;http://realworldocaml.org&quot;&gt;Real World OCaml&lt;/a&gt;, which will be a useful guide to using OCaml for systems and network programming. If you'd like to review an early copy, please get in touch.  The final book is anticipated to be released towards the end of the year, with a &lt;a href=&quot;http://shop.oreilly.com/category/roughcuts.do&quot;&gt;Rough Cut&lt;/a&gt; at the end of the summer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The core system was described in an &lt;a href=&quot;http://anil.recoil.org/papers/2013-asplos-mirage.pdf&quot;&gt;ASPLOS 2013&lt;/a&gt; paper, which should help you understand the background behind library operating systems. Some of the Mirage libraries are also currently being integrated into the next-generation &lt;a href=&quot;http://blogs.citrix.com/2012/05/17/introducing-windsor-a-new-xen-based-virtualization-architecture/&quot;&gt;Windsor&lt;/a&gt; release of the Xen Cloud Platform, which means that several of the libraries will be used in production and hence move beyond research-quality code.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the next few months, the installation notes and getting started guides will
all be revamped to match the reality of the new tooling, so expect some flux
there.   If you want to take an early try of Mirage beforehand, don't forget to
hop on the &lt;code&gt;#mirage&lt;/code&gt; IRC channel on Freenode and ping us with questions
directly.  We will also be migrating some of the project infrastructure to be fully
self-hosted on Mirage and Xen, and placing some of the services onto the new &lt;a href=&quot;http://xenproject.org&quot;&gt;xenproject.org&lt;/a&gt; infrastructure.&lt;/p&gt;

      </content><id>https://mirage.io/blog/the-road-to-a-dev-release</id><title type="text">The road to a developer preview at OSCON 2013</title><updated>2013-05-20T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/breaking-up-is-easy-with-opam" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;When we first started developing Mirage in 2009, we were rewriting huge chunks of operating system and runtime code in OCaml. This ranged from low-level device drivers to higher-level networking protocols such as TCP/IP or HTTP.  The changes weren't just straight rewrites of C code either, but also involved experimenting with interfaces such as iteratees and &lt;a href=&quot;https://mirage.io/wiki/tutorial-lwt&quot;&gt;lightweight threading&lt;/a&gt; to take advantage of OCaml's static type system.  To make all of this easy to work with, we decided to lump everything into a &lt;a href=&quot;http://github.com/avsm/mirage&quot;&gt;single Git repository&lt;/a&gt; that would bootstrap the entire system with a single &lt;code&gt;make&lt;/code&gt; invocation.&lt;/p&gt;
&lt;p&gt;Nowadays though, Mirage is self-hosting, the interfaces are settling down, the number of libraries are growing every day, and portions of it are being used in &lt;a href=&quot;https://mirage.io/blog/xenstore-stub-domain&quot;&gt;the Xen Cloud Platform&lt;/a&gt;. So for the first developer release, we wanted to split up the monolithic repository into more manageable chunks, but still make it as easy as possible for the average OCaml developer to try out Mirage.&lt;/p&gt;
&lt;p&gt;Thanks to much hard work from &lt;a href=&quot;http://gazagnaire.org&quot;&gt;Thomas&lt;/a&gt; and his colleagues at &lt;a href=&quot;http://ocamlpro.com&quot;&gt;OCamlPro&lt;/a&gt;, we now have &lt;a href=&quot;http://opam.ocamlpro.com&quot;&gt;OPAM&lt;/a&gt;: a fully-fledged package manager for Mirage!  OPAM is a source-based package manager that supports a growing number of community OCaml libraries.  More importantly for Mirage, it can also switch between multiple compiler installations, and so support cross-compiled runtimes and modified standard libraries.&lt;/p&gt;
&lt;p&gt;OPAM includes compiler variants for Mirage-friendly environments for Xen and the UNIX &lt;code&gt;tuntap&lt;/code&gt; backends.  The &lt;a href=&quot;https://mirage.io/wiki/install&quot;&gt;installation instructions&lt;/a&gt; now give you instructions on how to use OPAM, and the old monolithic repository is considered deprecated.  We're still working on full documentation for the first beta release, but all the repositories are on the &lt;a href=&quot;http://github.com/mirage&quot;&gt;Mirage organisation&lt;/a&gt; on Github, with some of the important ones being:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/mirage-platform&quot;&gt;mirage-platform&lt;/a&gt; has the core runtime for Xen and UNIX, implemented as the &lt;code&gt;OS&lt;/code&gt; module.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/mirage-net&quot;&gt;mirage-net&lt;/a&gt; has the TCP/IP networking stack.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/ocaml-cstruct&quot;&gt;ocaml-cstruct&lt;/a&gt; has the camlp4 extension to manipulate memory like C &lt;code&gt;struct&lt;/code&gt;s, but with type-safe accessors in OCaml.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/ocaml-xenstore&quot;&gt;ocaml-xenstore&lt;/a&gt; has a portable implementation of the Xenstore protocol to communicate with the Xen management stack from a VM (or even act as a &lt;a href=&quot;https://mirage.io/blog/xenstore-stub-domain&quot;&gt;server in a stub domain&lt;/a&gt;).
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/ocaml-dns&quot;&gt;ocaml-dns&lt;/a&gt; is a pure OCaml implementation of the DNS protocol, including a server and stub resolver.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/ocaml-re&quot;&gt;ocaml-re&lt;/a&gt; is a pure OCaml version of several regular expression engines, including Perl compatibility.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/ocaml-uri&quot;&gt;ocaml-uri&lt;/a&gt; handles parsing the surprisingly complex URI strings.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/ocaml-cohttp&quot;&gt;ocaml-cohttp&lt;/a&gt; is a portable HTTP parser, with backends for Mirage, Lwt and Core/Async. This is a good example of how to factor out OS-specific concerns using the OCaml type system (and I plan to blog more about this soon).
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/ocaml-cow&quot;&gt;ocaml-cow&lt;/a&gt; is a set of syntax extensions for JSON, CSS, XML and XHTML, which are explained &lt;a href=&quot;https://mirage.github.io/wiki/cow&quot;&gt;here&lt;/a&gt;, and used by this site.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/dyntype&quot;&gt;ocaml-dyntype&lt;/a&gt; uses camlp4 to &lt;a href=&quot;http://anil.recoil.org/papers/2011-dynamics-ml.pdf&quot;&gt;generate dynamic types&lt;/a&gt; and values from OCaml type declarations.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/orm&quot;&gt;ocaml-orm&lt;/a&gt; auto-generates SQL scheme from OCaml types via Dyntype, and currently supports SQLite.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/mirage/ocaml-openflow&quot;&gt;ocaml-openflow&lt;/a&gt; implements an OCaml switch and controller for the Openflow protocol.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are quite a few more that are still being hacked for release by the team, but we're getting there very fast now. We also have the Mirage ports of &lt;a href=&quot;http://github.com/avsm/ocaml-ssh&quot;&gt;SSH&lt;/a&gt; to integrate before the first release this year, and Haris has got some &lt;a href=&quot;http://github.com/mirage/ocaml-crypto-keys&quot;&gt;interesting DNSSEC&lt;/a&gt; code!  If you want to get involved, join the &lt;a href=&quot;https://mirage.io/about&quot;&gt;mailing list&lt;/a&gt; or IRC channel!&lt;/p&gt;

      </content><id>https://mirage.io/blog/breaking-up-is-easy-with-opam</id><title type="text">Breaking up is easy to do (with OPAM)</title><updated>2012-10-17T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/xenstore-stub-domain" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;[ &lt;em&gt;Due to continuing development, some of the details in this blog post are now out-of-date. It is archived here.&lt;/em&gt; ]&lt;/p&gt;
&lt;p&gt;On all hosts running &lt;a href=&quot;http://www.xen.org/&quot;&gt;Xen&lt;/a&gt;, there is a critical service called &lt;a href=&quot;http://wiki.xen.org/wiki/XenStore&quot;&gt;xenstore&lt;/a&gt;.
Xenstore is used to allow &lt;em&gt;untrusted&lt;/em&gt; user VMs to communicate with &lt;em&gt;trusted&lt;/em&gt; system VMs, so that&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;virtual disk and network connections can be established
&lt;/li&gt;
&lt;li&gt;performance statistics and OS version information can be shared
&lt;/li&gt;
&lt;li&gt;VMs can be remotely power-cycled, suspended, resumed, snapshotted and migrated.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If the xenstore service fails then at best the host cannot be controlled (i.e. no VM start or shutdown)
and at worst VM isolation is compromised since an untrusted VM will be able to gain unauthorised access to disks or networks.
This blog post examines how to disaggregate xenstore from the monolithic domain 0, and run it as an independent &lt;a href=&quot;http://www.cl.cam.ac.uk/~dgm36/publications/2008-murray2008improving.pdf&quot;&gt;stub domain&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Recently in the Xen community, Daniel De Graaf and Alex Zeffertt have added support for
&lt;a href=&quot;http://lists.xen.org/archives/html/xen-devel/2012-01/msg02349.html&quot;&gt;xenstore stub domains&lt;/a&gt;
where the xenstore service is run directly as an OS kernel in its own isolated VM. In the world of Xen,
a running VM is a &amp;quot;domain&amp;quot; and a &amp;quot;stub&amp;quot; implies a single-purpose OS image rather than a general-purpose
machine.
Previously if something bad happened in &amp;quot;domain 0&amp;quot; (the privileged general-purpose OS where xenstore traditionally runs)
such as an out-of-memory event or a performance problem, then the critical xenstore process might become unusable
or fail altogether. Instead if xenstore is run as a &amp;quot;stub domain&amp;quot; then it is immune to such problems in
domain 0. In fact, it will even allow us to &lt;em&gt;reboot&lt;/em&gt; domain 0 in future (along with all other privileged
domains) without incurring any VM downtime during the reset!&lt;/p&gt;
&lt;p&gt;The new code in &lt;a href=&quot;http://xenbits.xensource.com/xen-unstable.hg&quot;&gt;xen-unstable.hg&lt;/a&gt; lays the necessary groundwork
(Xen and domain 0 kernel changes) and ports the original C xenstored to run as a stub domain.&lt;/p&gt;
&lt;p&gt;Meanwhile, thanks to &lt;a href=&quot;http://tab.snarc.org&quot;&gt;Vincent Hanquez&lt;/a&gt; and &lt;a href=&quot;http://gazagnaire.org&quot;&gt;Thomas Gazagnaire&lt;/a&gt;, we also have an
&lt;a href=&quot;http://gazagnaire.org/pub/SSGM10.pdf&quot;&gt;OCaml implementation of xenstore&lt;/a&gt; which, as well as the offering
memory-safety, also supports a high-performance transaction engine, necessary for surviving a stressful
&amp;quot;VM bootstorm&amp;quot; event on a large server in the cloud. Vincent and Thomas' code is Linux/POSIX only.&lt;/p&gt;
&lt;p&gt;Ideally we would have the best of both worlds:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a fast, memory-safe xenstored written in OCaml,
&lt;/li&gt;
&lt;li&gt;running directly as a Xen stub domain i.e. as a specialised kernel image without Linux or POSIX
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can now do both, using Mirage!  If you're saying, &amp;quot;that sounds great! How do I do that?&amp;quot; then read on...&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Step 1: remove dependency on POSIX/Linux&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you read through the existing OCaml xenstored code, it becomes obvious that the main uses of POSIX APIs are for communication
with clients, both Unix sockets and for a special Xen inter-domain shared memory interface. It was a fairly
painless process to extract the required socket-like IO signature and turn the bulk of the server into
a &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual004.html&quot;&gt;functor&lt;/a&gt;. The IO signature ended up looking approximately like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;    type t
    val read: t -&amp;gt; string -&amp;gt; int -&amp;gt; int -&amp;gt; int Lwt.t
    val write: t -&amp;gt; string -&amp;gt; int -&amp;gt; int -&amp;gt; unit Lwt.t
    val destroy: t -&amp;gt; unit Lwt.t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For now the dependency on &lt;a href=&quot;http://ocsigen.org/lwt/&quot;&gt;Lwt&lt;/a&gt; is explicit but in future I'll probably make it more abstract so we
can use &lt;a href=&quot;https://ocaml.janestreet.com/?q=node/100&quot;&gt;Core Async&lt;/a&gt; too.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Step 2: add a Mirage Xen IO implementation&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In a stub-domain all communication with other domains is via shared memory pages and &amp;quot;event channels&amp;quot;.
Mirage already contains extensive support for using these primitives, and uses them to create fast
network and block virtual device drivers. To extend the code to cover the Xenstore stub domain case,
only a few tweaks were needed to add the &amp;quot;server&amp;quot; side of a xenstore ring communication, in addition
to the &amp;quot;client&amp;quot; side which was already present.&lt;/p&gt;
&lt;p&gt;In Xen, domains share memory by a system of explicit &amp;quot;grants&amp;quot;, where a client (called &amp;quot;frontend&amp;quot;)
tells the hypervisor to allow a server (called &amp;quot;backend&amp;quot;) access to specific memory pages. Mirage
already had code to create such grants, all that was missing was a few simple functions to receive
grants from other domains.&lt;/p&gt;
&lt;p&gt;These changes are all in the current &lt;a href=&quot;https://github.com/mirage/mirage-platform&quot;&gt;mirage-platform&lt;/a&gt;
tree.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Step 3: add a Mirage Xen &amp;quot;main&amp;quot; module and Makefile&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The Mirage &amp;quot;main&amp;quot; module necessary for a stub domain looks pretty similar to the normal Unix
userspace case except that it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arranges to log messages via the VM console (rather than a file or the network, since a disk or network device cannot be created without a working xenstore, and it's important not to introduce a bootstrap
problem here)
&lt;/li&gt;
&lt;li&gt;instantiates the server functor with the shared memory inter-domain IO module.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Makefile looks like a regular Makefile, invoking ocamlbuild. The whole lot is built with
&lt;a href=&quot;http://oasis.forge.ocamlcore.org/&quot;&gt;OASIS&lt;/a&gt; with a small extension added by &lt;a href=&quot;http://anil.recoil.org/&quot;&gt;Anil&lt;/a&gt; to set a few options
required for building Xen kernels rather than regular binaries.&lt;/p&gt;
&lt;p&gt;... and it all works!&lt;/p&gt;
&lt;p&gt;The code is in two separate repositories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/djs55/ocaml-xenstore&quot;&gt;ocaml-xenstore&lt;/a&gt;: contains all the generic stuff
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/djs55/ocaml-xenstore-xen&quot;&gt;ocaml-xenstore-xen&lt;/a&gt;: contains the unix userspace
and xen stub domain IO modules and &amp;quot;main&amp;quot; functions
&lt;/li&gt;
&lt;li&gt;(optional) To regenerate the OASIS file, grab the &lt;code&gt;add-xen&lt;/code&gt; branch from this &lt;a href=&quot;http://github.com/avsm/oasis&quot;&gt;OASIS fork&lt;/a&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Example build instructions&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you want to try building it yourself, try the following on a modern 64-bit OS. I've tested these
instructions on a fresh install of Debian Wheezy.&lt;/p&gt;
&lt;p&gt;First install OCaml and the usual build tools:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    apt-get install ocaml build-essential git curl rsync
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then install the OCamlPro &lt;code&gt;opam&lt;/code&gt; package manager to simplify the installation of extra packages&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    git clone https://github.com/OCamlPro/opam.git
    cd opam
    make
    make install
    cd ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Initialise OPAM with the default packages:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    opam --yes init
    eval `opam config -env`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add the &amp;quot;mirage&amp;quot; development package source (this step will not be needed once the package definitions are upstreamed)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    opam remote -add dev https://github.com/mirage/opam-repo-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Switch to the special &amp;quot;mirage&amp;quot; version of the OCaml compiler&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    opam --yes switch -install 3.12.1+mirage-xen
    opam --yes switch 3.12.1+mirage-xen
    eval `opam config -env`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install the generic Xenstore protocol libraries&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    opam --yes install xenstore
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install the Mirage development libraries&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    opam --yes install mirage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If this fails with &amp;quot;+ runtime/dietlibc/lib/atof.c:1: sorry, unimplemented: 64-bit mode not compiled in&amp;quot; it means you need a 64-bit build environment.
Next, clone the xen stubdom tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    git clone https://github.com/djs55/ocaml-xenstore-xen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build the Xen stubdom&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    cd ocaml-xenstore-xen
    make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The binary now lives in &lt;code&gt;xen/_build/src/server_xen.xen&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Deploying on a Xen system&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Running a stub Xenstored is a little tricky because it depends on the latest and
greatest Xen and Linux PVops kernel. In the future it'll become much easier (and probably
the default) but for now you need the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xen-4.2 with XSM (Xen Security Modules) turned on
&lt;/li&gt;
&lt;li&gt;A XSM/FLASK policy which allows the stubdom to call the &amp;quot;domctl getdomaininfo&amp;quot;. For the moment it's safe to skip this step with the caveat that xenstored will leak connections when domains die.
&lt;/li&gt;
&lt;li&gt;a Xen-4.2-compatible toolstack (either the bundled xl/libxl or xapi with &lt;a href=&quot;http://github.com/djs55/xen-api/tree/xen-4.2&quot;&gt;some patches&lt;/a&gt;)
&lt;/li&gt;
&lt;li&gt;Linux-3.5 PVops domain 0 kernel
&lt;/li&gt;
&lt;li&gt;the domain builder binary &lt;code&gt;init-xenstore-domain&lt;/code&gt; from &lt;code&gt;xen-4.2/tools/xenstore&lt;/code&gt;.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To turn the stub xenstored on, you need to edit whichever &lt;code&gt;init.d&lt;/code&gt; script is currently starting xenstore and modify it to call&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    init-xenstore-domain /path/to/server_xen.xen 256 flask_label
&lt;/code&gt;&lt;/pre&gt;

      </content><id>https://mirage.io/blog/xenstore-stub-domain</id><title type="text">Building a &quot;Xenstore stub domain&quot; with MirageOS</title><updated>2012-09-12T00:00:00-00:00</updated><author><name>Dave Scott</name></author></entry><entry><link href="https://mirage.io/blog/announcing-mirage-openflow" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;&lt;strong&gt;Due to continuing development, some of the details in this blog post are now out-of-date. It is archived here.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Something we've been working on for a little while now that we're pretty
excited about is an &lt;a href=&quot;http://openflow.org/&quot;&gt;OpenFlow&lt;/a&gt; implementation for
MirageOS. For those who're not networking types, in short, OpenFlow is a
protocol and framework for devolving network control to software running on
platforms other than the network elements themselves. It consists of three
main parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;em&gt;controller&lt;/em&gt;, responsible for exercising control over the network;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;switches&lt;/em&gt;, consisting of switching hardware, with flow tables that apply
forwarding behaviours to matching packets; and
&lt;/li&gt;
&lt;li&gt;the &lt;em&gt;protocol&lt;/em&gt;, by which controllers and switches communicate.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more -- and far clearer! -- explanations, see any of the many online
OpenFlow resources such as &lt;a href=&quot;http://openflowhub.org&quot;&gt;OpenFlowHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Within MirageOS we have an OpenFlow implementation in two parts: individual
libraries that provide controller and switch functionality. Linking the switch
library enables your application to become a software-based OpenFlow switch.
Linking in the controller library enables your application to exercise direct
control over OpenFlow network elements.&lt;/p&gt;
&lt;p&gt;The controller is modelled after the &lt;a href=&quot;http://noxrepo.org/&quot;&gt;NOX&lt;/a&gt; open-source
controller and currently provides only relatively low-level access to the
OpenFlow primitives: a very cool thing to build on top of it would be a
higher-level abstraction such as that provided by
&lt;a href=&quot;http://haskell.cs.yale.edu/?page_id=376&quot;&gt;Nettle&lt;/a&gt; or
&lt;a href=&quot;http://www.frenetic-lang.org/&quot;&gt;Frenetic&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The switch is primarily intended as an experimental platform -- it is
hopefully easier to extend than some of the existing software switches while
still being sufficiently high performance to be interesting!&lt;/p&gt;
&lt;p&gt;By way of a sample of how it fits together, here's a skeleton for a simple
controller application:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;type mac_switch = {
  addr: OP.eaddr; 
  switch: OP.datapath_id;
}

type switch_state = {
  mutable mac_cache: 
        (mac_switch, OP.Port.t) Hashtbl.t;
  mutable dpid: OP.datapath_id list
}

let switch_data = {
  mac_cache = Hashtbl.create 7; 
  dpid = [];
} 

let join_cb controller dpid evt =
  let dp = match evt with
      | OE.Datapath_join c -&amp;gt; c
      | _ -&amp;gt; invalid_arg &amp;quot;bogus datapath_join&amp;quot;
  in 
  switch_data.dpid &amp;lt;- switch_data.dpid @ [dp]

let packet_in_cb controller dpid evt =
  (* algorithm details omitted for space *)

let init ctrl = 
  OC.register_cb ctrl OE.DATAPATH_JOIN join_cb;
  OC.register_cb ctrl OE.PACKET_IN packet_in_cb

let main () =
  Net.Manager.create (fun mgr interface id -&amp;gt;
    let port = 6633 in 
    OC.listen mgr (None, port) init
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We've written up some of the gory details of the design, implementation and
performance in a &lt;a href=&quot;https://mirage.io/documents/iccsdn12-mirage.pdf&quot;&gt;short paper&lt;/a&gt; to the
&lt;a href=&quot;http://www.ieee-icc.org/&quot;&gt;ICC&lt;/a&gt;
&lt;a href=&quot;http://sdn12.mytestbed.net/&quot;&gt;Software Defined Networking&lt;/a&gt; workshop. Thanks to
some sterling work by &lt;a href=&quot;http://www.cl.cam.ac.uk/~cr409/&quot;&gt;Haris&lt;/a&gt; and
&lt;a href=&quot;mailto:balraj.singh@cl.cam.ac.uk&quot;&gt;Balraj&lt;/a&gt;, the headline numbers are pretty
good though: the unoptimised Mirage controller implementation is only 30--40%
lower performance than the highly optimised NOX &lt;em&gt;destiny-fast&lt;/em&gt; branch, which
drops most of the programmability and flexibility of NOX; but is about &lt;em&gt;six
times&lt;/em&gt; higher performance than the fully flexible current NOX release. The
switch's performance  running as a domU virtual machine is indistinguishable
from the current &lt;a href=&quot;http://openvswitch.org/&quot;&gt;Open vSwitch&lt;/a&gt; release.&lt;/p&gt;
&lt;p&gt;For more details see &lt;a href=&quot;https://mirage.io/documents/iccsdn12-mirage.pdf&quot;&gt;the paper&lt;/a&gt; or contact
&lt;a href=&quot;mailto:mort@cantab.net&quot;&gt;Mort&lt;/a&gt;,
&lt;a href=&quot;mailto:charalampos.rotsos@cl.cam.ac.uk&quot;&gt;Haris&lt;/a&gt; or
&lt;a href=&quot;mailto:anil@recoil.org&quot;&gt;Anil&lt;/a&gt;. Please do get in touch if you've any comments
or questions, or you do anything interesting with it!&lt;/p&gt;

      </content><id>https://mirage.io/blog/announcing-mirage-openflow</id><title type="text">Connected Cloud Control: OpenFlow in MirageOS</title><updated>2012-02-29T00:00:00-00:00</updated><author><name>Richard Mortier</name></author></entry><entry><link href="https://mirage.io/blog/an-outing-to-cufp" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;The team signed up to do a tutorial at &lt;a href=&quot;http://cufp.org&quot;&gt;CUFP&lt;/a&gt; on the topic of &lt;a href=&quot;http://cufp.org/conference/sessions/2011/t3-building-functional-os&quot;&gt;Building a Functional OS&lt;/a&gt;, which meant zooming off to Tokyo!  This was the first public show of the project, and resulted in a furious &lt;a href=&quot;https://github.com/avsm/mirage/graphs/impact&quot;&gt;flurry of commits&lt;/a&gt; from the whole team to get it ready. The 45-strong crowd at the tutorial were really full of feedback, and particular thanks to &lt;a href=&quot;http://www.deinprogramm.de/sperber/&quot;&gt;Michael&lt;/a&gt; for organising the event, and &lt;a href=&quot;http://ocaml.janestreet.com/?q=blog/5&quot;&gt;Yaron&lt;/a&gt;, &lt;a href=&quot;http://monkey.org/~marius/&quot;&gt;Marius&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/#!/stevej&quot;&gt;Steve&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/wil&quot;&gt;Wil&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/#!/adoemon&quot;&gt;Adrian&lt;/a&gt; and the rest for shouting out questions regularly!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;The tutorial&lt;/em&gt; is &lt;a href=&quot;http://github.com/avsm/mirage-tutorial&quot;&gt;a Mirage application&lt;/a&gt;, so you can clone it and view it locally through your web browser. The content is mirrored at &lt;a href=&quot;http://tutorial.openmirage.org&quot;&gt;tutorial.openmirage.org&lt;/a&gt;, although it does require cleanup to make it suitable to an online audience. The SVG integration is awkward and it only works on Chrome/Safari, so I will probably rewrite it using &lt;a href=&quot;http://imakewebthings.github.com/deck.js/&quot;&gt;deck.js&lt;/a&gt; soon. The tutorial is a good showcase of Mirage, as it compiles to Xen, UNIX (both kernel sockets and direct tuntap) with a RAMdisk or external filesystem, and is a good way to mess around with application synthesis (look at the &lt;code&gt;Makefile&lt;/code&gt; targets in &lt;code&gt;slides/&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Installation&lt;/em&gt;: &lt;a href=&quot;https://mirage.io/wiki/install&quot;&gt;instructions&lt;/a&gt; have been simplified, and we now only require OCaml on the host and include everything else in-tree. Thomas has also made Emacs and Vim plugins that are compatible with the ocamlbuild layout.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Lwt&lt;/em&gt;: a &lt;a href=&quot;https://mirage.io/wiki/tutorial-lwt&quot;&gt;new tutorial&lt;/a&gt; which walks you through the cooperative threading library we use, along with exercises (all available in &lt;a href=&quot;http://github.com/avsm/mirage-tutorial&quot;&gt;mirage-tutorial&lt;/a&gt;). Raphael and Balraj are looking for feedback on this, so get in touch!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Javascript&lt;/em&gt;: via &lt;a href=&quot;http://nodejs.org&quot;&gt;node.js&lt;/a&gt; did not work in time for the tutorial, as integrating I/O is a tangled web that will take some time to sort out. Raphael is working on this in a &lt;a href=&quot;https://github.com/raphael-proust/nodejs_of_ocaml&quot;&gt;separate tree&lt;/a&gt; for now.  As part of this effort though, he integrated a pure OCaml &lt;a href=&quot;https://mirage.io/blog/ocaml-regexp&quot;&gt;regular expression library&lt;/a&gt; that does not require C bindings, and is surprisingly fast.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Devices&lt;/em&gt;: we can now synthesise binaries that share common code but have very different I/O interfaces. This is due to a new device manager, and David also heroically wrote a complete &lt;a href=&quot;http://github.com/avsm/mirage/tree/master/lib/fs&quot;&gt;FAT12/16/32 library&lt;/a&gt; that we demonstrated.  Yaron Minsky suggested a &lt;a href=&quot;https://gist.github.com/1245418&quot;&gt;different approach&lt;/a&gt; to the device manager using &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec245&quot;&gt;first-class modules&lt;/a&gt; instead of objects, so I am experimentally trying this before writing documentation on it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;TCP&lt;/em&gt;: the notorious Mirage stack is far more robust due to our resident networking guru Balraj hunting down last-minute bugs. Although it held together with sticky tape during the tutorial, he is now adding retransmission and congestion control to make it actually standards-compliant.  Still, if you dont have any packet loss, the &lt;a href=&quot;http://xen.openmirage.org/&quot;&gt;unikernel version&lt;/a&gt; of this website does actually serve pages.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;OpenFlow&lt;/em&gt;: is a new &lt;a href=&quot;http://www.openflow.org/wk/index.php/OpenFlow_v1.0&quot;&gt;standard&lt;/a&gt; for &lt;a href=&quot;http://networkheresy.wordpress.com/&quot;&gt;Software Defined Networking&lt;/a&gt;, and Haris and Mort have been hacking away at a complete implementation directly in Mirage!  We will be giving a tutorial on this at the &lt;a href=&quot;http://changeofelia.info.ucl.ac.be/&quot;&gt;OFELIA summer school&lt;/a&gt; in November (it is summer somewhere, I guess). The prospect of a high-speed unikernel switching fabric for the cloud, programmed in a functional style, is something I am really looking forward to seeing!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Jane Street Core&lt;/em&gt;: preceeding us was Yaron's &lt;a href=&quot;http://cufp.org/conference/sessions/2011/t2-janestreets-ocaml-core-library&quot;&gt;Core&lt;/a&gt; tutorial. Since Mirage provides it own complete standard library, we can adopt portions of Core that do not require OS threads or UNIX-specific features.  I really like the idea that Mirage enforces a discipline on writing portable interfaces, as dependencies on OS-specific features do sneak in insiduously and make switching to different platforms very difficult (e.g. Windows support). Incidentally, Yaron's &lt;a href=&quot;http://queue.acm.org/detail.cfm?id=2038036&amp;amp;ref=fullrss&quot;&gt;ACM Queue&lt;/a&gt; article is a great introduction to OCaml.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So as you can see, it has been a busy few months!  Much of the core of Mirage is settling down now, and we are writing a paper with detailed performance benchmarks of our various backends.  Keep an eye on the &lt;a href=&quot;https://github.com/avsm/mirage/issues?milestone=2&amp;amp;state=open&quot;&gt;Github milestone&lt;/a&gt; for the preview release, join our &lt;a href=&quot;https://lists.cam.ac.uk/mailman/listinfo/cl-mirage&quot;&gt;new mailing list&lt;/a&gt;, or follow the newly sentient &lt;a href=&quot;http://twitter.com/openmirage&quot;&gt;openmirage on twitter&lt;/a&gt;!&lt;/p&gt;

      </content><id>https://mirage.io/blog/an-outing-to-cufp</id><title type="text">An Outing to CUFP 2011</title><updated>2011-09-29T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/ocaml-regexp" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;MirageOS targets different backends: micro-kernels for the Xen hypervisor, Unix
executables and Javascript programs. The recent inclusion of the Javascript
backend makes many C bindings unsuitable. In order to push backend incompatibilities
closer to the application level, it is necessary to either reimplement the C
bindings in Javascript or OCaml, or remove them completely. This is particularly
important for the standard library.&lt;/p&gt;
&lt;h2&gt;The &lt;code&gt;Str&lt;/code&gt; module has to go!&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Str&lt;/code&gt; provides regular expressions in a non-reentrant, non-functional fashion.
While the OCaml distribution provides it in &lt;code&gt;otherlibs&lt;/code&gt;, it is installed by
default and so widely used, and implemented under the hood via a C library.
Regular expressions are used in several places in MirageOS, mainly for small
operations (splitting, getting an offset, etc.), and so having a portable
fallback written in pure OCaml would be very useful.&lt;/p&gt;
&lt;p&gt;There are several possible ways to replace the &lt;code&gt;Str&lt;/code&gt; module, each with its own
set of perks and drawbacks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use a backend-neutral regexp library which &amp;quot;translates&amp;quot; to either &lt;code&gt;Str&lt;/code&gt;
or &lt;code&gt;Pcre&lt;/code&gt; for the Xen and Unix backends or Javascript native regexps for
the Javascript backend. This solution may be hard to maintain, especially if a
fourth backend is to be included. Moreover each regexp library uses a slightly
different convention for regexps (e.g. see the
&lt;a href=&quot;http://vimdoc.sourceforge.net/htmldoc/pattern.html#/magic&quot;&gt;magic&lt;/a&gt; option in
vim) which means that a lot of translation code might be needed.
&lt;/li&gt;
&lt;li&gt;Do string processing without regexps (using &lt;code&gt;String.index&lt;/code&gt; and the likes).
This solution is portable and potentially efficient. However, the potential
efficiency comes from a low-level way of doing things.
&lt;/li&gt;
&lt;li&gt;Use an OCaml regexp library without C bindings. We expected such a library to
be slower than &lt;code&gt;Str&lt;/code&gt; and needed an estimation of performance cost in order to
assess the practicality of the solution.
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Benchmarking &lt;code&gt;Str&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;There is a purely OCaml regexp library readily available, called &lt;code&gt;Regexp&lt;/code&gt; and
developed by Claude March&amp;eacute; from the LRI laboratory. You can find the
documentation and the source on the associated
&lt;a href=&quot;http://www.lri.fr/~marche/regexp/&quot;&gt;webpage&lt;/a&gt;. After getting rid of mutexes
(which, in MirageOS, are of no use, because of the &lt;code&gt;Lwt&lt;/code&gt; based
concurrency), we benchmarked it against &lt;code&gt;Str&lt;/code&gt;. We also included the popular
&lt;code&gt;Pcre&lt;/code&gt; (Perl Compatible Regular Expression) library that is widely used.&lt;/p&gt;
&lt;p&gt;The benchmark (available &lt;a href=&quot;http://github.com/raphael-proust/regexp-benchmark.git&quot;&gt;on github&lt;/a&gt;)
is really simple and measures three different factors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;regexp construction: the transformation of a string (or another representation
available to the programmer) into the internal representation of regexps used
by the library
&lt;/li&gt;
&lt;li&gt;regexp usage: the execution of operations using regexps
&lt;/li&gt;
&lt;li&gt;string size: the length of the string being matched
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MirageOS uses regexp in a specific pattern: a limited number of regexp
constructions with a potentially high number of invocation (e.g. HTTP header parsing).
The size of the strings on which regexps are used may vary.  Because of this pattern,
our benchmark does not take regexp construction overhead into account.&lt;/p&gt;
&lt;p&gt;Here are the execution times of approximately 35000 string matching operations
on strings of 20 to 60 bytes long.&lt;/p&gt;
&lt;img src=&quot;https://mirage.io/graphics/all_1_1000_10.png&quot;/&gt;
&lt;p&gt;Quite surprisingly for the string matching operation, the C based &lt;code&gt;Str&lt;/code&gt; module
is less efficient than the pure OCaml &lt;code&gt;Regexp&lt;/code&gt;. The &lt;code&gt;Pcre&lt;/code&gt; results were even worse
than &lt;code&gt;Str&lt;/code&gt;. Why?&lt;/p&gt;
&lt;h3&gt;A simple library for a simple task&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;Regexp&lt;/code&gt; library is lightweight, and so far faster than its C based
counterparts. One of the features &lt;code&gt;Regexp&lt;/code&gt; lacks is &amp;quot;group capture&amp;quot;: the ability
to refer to blocks of a previously matched string. In &lt;code&gt;Pcre&lt;/code&gt; it is possible to
explicitly and selectively turn group capturing off via special syntax,
instead of the regular parentheses. &lt;code&gt;Str&lt;/code&gt; does not offer  this, and thus
imposes the runtime cost of capture even when not necessary. In other words, the
slowdown/group capturing &amp;quot;is not a feature, it's a bug!&amp;quot;&lt;/p&gt;
&lt;h3&gt;The MirageOS Regexp library&lt;/h3&gt;
&lt;p&gt;With the introduction of &lt;code&gt;Regexp&lt;/code&gt; into the tree, the libraries available to MirageOS
applications are now &lt;code&gt;Str&lt;/code&gt;-free and safer to use across multiple backends. The main
drawback is a slight increase in verbosity of some parts of the code.
Benchmarking the substitution operation is also necessary to assess the
performance gain/loss (which we will do shortly).&lt;/p&gt;
&lt;p&gt;In addition to cosmetic and speed considerations, it is important to consider the
portability increase: MirageOS's standard library is &lt;a href=&quot;http://nodejs.org&quot;&gt;Node.js&lt;/a&gt; compatible,
a feature we will explore shortly!&lt;/p&gt;

      </content><id>https://mirage.io/blog/ocaml-regexp</id><title type="text">Portable Regular Expressions</title><updated>2011-08-12T00:00:00-00:00</updated><author><name>Raphael Proust</name></author></entry><entry><link href="https://mirage.io/blog/delimcc-vs-lwt" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;MirageOS is a fully event-driven system, with no support for conventional &lt;a href=&quot;http://en.wikipedia.org/wiki/POSIX_Threads&quot;&gt;preemptive threads&lt;/a&gt;.  Instead, programs are woken by events such as incoming network packets, and event callbacks execute until they themselves need to block (due to I/O or timers) or complete their task.&lt;/p&gt;
&lt;p&gt;Event-driven systems are simple to implement, scalable to lots of network clients, and very hip due to frameworks like &lt;a href=&quot;http://nodejs.org&quot;&gt;node.js&lt;/a&gt;. However, programming event callbacks directly leads to the control logic being scattered across many small functions, and so we need some abstractions to hide the interruptions of registering and waiting for an event to trigger.&lt;/p&gt;
&lt;p&gt;OCaml has the excellent &lt;a href=&quot;http://ocsigen.org&quot;&gt;Lwt&lt;/a&gt; threading library that utilises a monadic approach to solving this.
Consider this simplified signature:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  val return : 'a -&amp;gt; 'a Lwt.t 
  val bind : 'a Lwt.t -&amp;gt; ('a -&amp;gt; 'b Lwt.t) -&amp;gt; 'b Lwt.t
  val run : 'a Lwt.t -&amp;gt; 'a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Threads have the type &lt;code&gt;'a Lwt.t&lt;/code&gt;, which means that the thread will have a result of type &lt;code&gt;'a&lt;/code&gt; when it finishes.
The &lt;code&gt;return&lt;/code&gt; function is the simplest way to construct such a thread from an OCaml value.&lt;/p&gt;
&lt;p&gt;If we then wish to use the value of thread, we must compose a function that will be called in the future when the thread completes. This is what the &lt;code&gt;bind&lt;/code&gt; function above is for. For example, assume we have a function that will let us sleep for some time:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  val sleep: int -&amp;gt; unit Lwt.t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now use the &lt;code&gt;bind&lt;/code&gt; function to do something after the sleep is complete:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  let x = sleep 5 in
  let y = bind x (fun () -&amp;gt; print_endline &amp;quot;awake!&amp;quot;) in
  run y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; has the type &lt;code&gt;unit Lwt.t&lt;/code&gt;, and the closure passed to &lt;code&gt;bind&lt;/code&gt; will eventually be called with &lt;code&gt;unit&lt;/code&gt; when the sleep finishes. Note that we also need a function to actually begin evaluating an Lwt thread, which is the &lt;code&gt;run&lt;/code&gt; function.&lt;/p&gt;
&lt;h2&gt;Concerns&lt;/h2&gt;
&lt;p&gt;MirageOS currently uses Lwt extensively, and we have been very happy with using it to build a network stack. However, I was surprised to hear a lot of debate at the &lt;a href=&quot;http://anil.recoil.org/2011/04/15/ocaml-users-group.html&quot;&gt;2011 OCaml Users Group&lt;/a&gt; meeting that Lwt is not to everyone's tastes. There are a few issues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The monadic style means that existing code will not just work. Any code that might block must be adapted to use &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;bind&lt;/code&gt;, which makes integrating third-party code problematic.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;More concerningly, any potential blocking points require the allocation of a closure. This allocation is very cheap in OCaml, but is still not free. Jun Furuse notes that combinator-based systems are slower during the development of his &lt;a href=&quot;http://camlspotter.blogspot.com/2011/05/planck-small-parser-combinator-library.html&quot;&gt;Planck parser&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lwt addresses the first problem via a comprehensive &lt;a href=&quot;http://ocsigen.org/lwt/2.3.0/api/Pa_lwt&quot;&gt;syntax extension&lt;/a&gt; which provides Lwt equivalents for many common operations. For example, the above example with sleep can be written as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  lwt x = sleep 5 in
  print_endline &amp;quot;awake&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;lwt&lt;/code&gt; keyword indicates the result of the expression should be passed through &lt;code&gt;bind&lt;/code&gt;, and this makes it possible to write code that looks more OCaml-like. There are also other keywords like &lt;code&gt;for_lwt&lt;/code&gt; and &lt;code&gt;match_lwt&lt;/code&gt; that similarly help with common control flow constructs.&lt;/p&gt;
&lt;h2&gt;Fibers&lt;/h2&gt;
&lt;p&gt;After the meeting, I did get thinking about using alternatives to Lwt in MirageOS. One exciting option is the &lt;a href=&quot;http://okmij.org/ftp/continuations/implementations.html&quot;&gt;delimcc&lt;/a&gt; library which implements &lt;a href=&quot;http://en.wikipedia.org/wiki/Delimited_continuation&quot;&gt;delimited continuations&lt;/a&gt; for OCaml.  These can be used to implement restartable exceptions: a program can raise an exception which can be invoked to resume the execution as if the exception had never happened.
Delimcc can be combined with Lwt very elegantly, and Jake Donham did just this with the &lt;a href=&quot;http://ambassadortothecomputers.blogspot.com/2010/08/mixing-monadic-and-direct-style-code.html&quot;&gt;Lwt_fiber&lt;/a&gt; library. His post also has a detailed explanation of how &lt;code&gt;delimcc&lt;/code&gt; works.&lt;/p&gt;
&lt;p&gt;The interface for fibers is also simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  val start: (unit -&amp;gt; 'a) -&amp;gt; 'a Lwt.t
  val await : 'a Lwt.t -&amp;gt; 'a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A fiber can be launched with &lt;code&gt;start&lt;/code&gt;, and during its execution can block on another thread with &lt;code&gt;await&lt;/code&gt;.  When it does block, a restartable exception saves the program stack back until the point that &lt;code&gt;start&lt;/code&gt; was called, and it will be resumed when the thread it blocked on completes.&lt;/p&gt;
&lt;h2&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;I put together a few microbenchmarks to try out the performance of Lwt threads versus fibers. The fiber test looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  module Fiber = struct
    let basic fn yields =
      for i = 1 to 15000 do
        for x = 1 to yields do
          Lwt_fiber.await (fn ())
        done
      done

    let run fn yields =
      Lwt_fiber.start (fun () -&amp;gt; basic fn yields)
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We invoke the run function with two arguments: a thread to use for blocking and the number of times we should yield serially (so we can confirm that an increasing number of yields scales linearly).  The Lwt version is pretty similar:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  module LWT = struct
    let basic fn yields =
      for_lwt i = 1 to 15000 do
        for_lwt x = 1 to yields do
          fn ()
        done
      done
  
    let run = basic
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We do not need to do anything special to launch a thread since we are already in the Lwt main loop, and the syntax extension makes the &lt;code&gt;for&lt;/code&gt; loops look like the Fiber example above.&lt;/p&gt;
&lt;p&gt;The choice of blocking function is important. The first test runs using a fast &lt;code&gt;Lwt.return ()&lt;/code&gt; that returns immediately:&lt;/p&gt;
&lt;img src=&quot;http://chart.apis.google.com/chart?cht=lxy&amp;amp;chs=600x250&amp;amp;chtt=Direct%20non-blocking%20overhead&amp;amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;amp;chxt=x,x,y,y&amp;amp;chxl=1:%7Cnumber-of-yields%7C3:%7Cseconds&amp;amp;chds=a&amp;amp;chg=10,10,1,5&amp;amp;chd=t:50,100,200,300,400,600,800,1000%7C0.101,0.195,0.388,0.581,0.775,1.157,1.548,1.926%7C50,100,200,300,400,600,800,1000%7C0.095,0.188,0.371,0.553,0.737,1.104,1.469,1.836&amp;amp;chdl=delimcc-basic-quick%7Clwt-basic-quick&amp;amp;chdlp=t&amp;amp;chls=2%7C2&quot;/&gt;
&lt;p&gt;The x-axis on the above graph represents the number of yields in each loop. Both &lt;code&gt;Lwt_fiber&lt;/code&gt; and pure &lt;code&gt;Lwt&lt;/code&gt; optimise the case where a thread returns immediately, and so this graph simply tells us that the fast path is working (which is nice!). The next test replaces the blocking function with two alternatives that force the thread to yield:&lt;/p&gt;
&lt;img src=&quot;http://chart.apis.google.com/chart?cht=lxy&amp;amp;chs=600x250&amp;amp;chtt=Direct%20blocking%20overhead&amp;amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;amp;chxt=x,x,y,y&amp;amp;chxl=1:%7Cnumber-of-yields%7C3:%7Cseconds&amp;amp;chds=a&amp;amp;chg=10,10,1,5&amp;amp;chd=t:50,100,200,300,400,600,800,1000%7C2.601,5.204,10.401,15.611,20.783,31.221,41.606,52.016%7C50,100,200,300,400,600,800,1000%7C1.270,2.539,5.089,7.626,10.188,15.338,20.385,25.473%7C50,100,200,300,400,600,800,1000%7C4.011,8.013,15.973,23.995,32.075,47.940,63.966,79.914%7C50,100,200,300,400,600,800,1000%7C2.433,4.861,9.692,14.543,19.702,29.579,39.458,49.260&amp;amp;chdl=lwt-basic-slow%7Clwt-basic-medium%7Cdelimcc-basic-slow%7Cdelimcc-basic-medium&amp;amp;chdlp=t&amp;amp;chls=2%7C2%7C2%7C2&quot;/&gt;
&lt;p&gt;There are two blocking functions used in the graph above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &amp;quot;slow&amp;quot; version is &lt;code&gt;Lwt_unix.sleep 0.0&lt;/code&gt; which forces the registration of a timeout.
&lt;/li&gt;
&lt;li&gt;the &amp;quot;medium&amp;quot; version is &lt;code&gt;Lwt.pause ()&lt;/code&gt; which causes the thread to pause and drop into the thread scheduler. In the case of &lt;code&gt;Lwt_fiber&lt;/code&gt;, this causes an exception to be raised so we can benchmark the cost of using a delimited continuation.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Interestingly, using a fiber is slower than normal Lwt here, even though our callstack is not very deep.  I would have hoped that fibers would be significantly cheaper with a small callstack, as the amount of backtracking should be quite low.  Lets confirm that fibers do in fact slow down as the size of the callstack increases via this test:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  module Fiber = struct
    let recurse fn depth =
      let rec sum n = 
        Lwt_fiber.await (fn ());
        match n with
        |0 -&amp;gt; 0
        |n -&amp;gt; n + (sum (n-1)) 
      in
      for i = 1 to 15000 do
        ignore(sum depth)
      done

    let run fn depth = 
      Lwt_fiber.start (fun () -&amp;gt; recurse fn depth)
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;recurse&lt;/code&gt; function is deliberately not tail-recursive, so that the callstack increases as the &lt;code&gt;depth&lt;/code&gt; parameter grows.  The Lwt equivalent is slightly more clunky as we have to rewrite the loop to bind and return:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  module LWT = struct
    let recurse fn depth =
      let rec sum n =
        lwt () = fn () in
        match n with
        |0 -&amp;gt; return 0
        |n -&amp;gt;
          lwt n' = sum (n-1) in 
          return (n + n')
      in
      for_lwt i = 1 to 15000 do
        lwt res = sum depth in
        return ()
      done

   let run = recurse
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We then run the experiment using the slow &lt;code&gt;Lwt_unix.sleep 0.0&lt;/code&gt; function, and get this graph:&lt;/p&gt;
&lt;img src=&quot;http://chart.apis.google.com/chart?cht=lxy&amp;amp;chs=600x250&amp;amp;chtt=Recurse%20vs%20basic&amp;amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;amp;chxt=x,x,y,y&amp;amp;chxl=1:%7Cstack-depth%7C3:%7Cseconds&amp;amp;chds=a&amp;amp;chg=10,10,1,5&amp;amp;chd=t:50,100,200,300,400,600,800,1000%7C6.264,15.567,44.297,86.823,142.372,310.036,603.735,939.165%7C50,100,200,300,400,600,800,1000%7C2.601,5.204,10.401,15.611,20.783,31.221,41.606,52.016%7C50,100,200,300,400,600,800,1000%7C2.769,5.564,11.497,17.631,23.826,36.700,49.314,61.794%7C50,100,200,300,400,600,800,1000%7C4.011,8.013,15.973,23.995,32.075,47.940,63.966,79.914&amp;amp;chdl=delimcc-recurse-slow%7Clwt-basic-slow%7Clwt-recurse-slow%7Cdelimcc-basic-slow&amp;amp;chdlp=t&amp;amp;chls=2%7C2%7C2%7C2&quot;/&gt;
&lt;p&gt;The above graph shows the recursive Lwt_fiber getting slower as the recursion depth increases, with normal Lwt staying linear.  The graph also overlays the non-recursing versions as a guideline (&lt;code&gt;*-basic-slow&lt;/code&gt;).&lt;/p&gt;
&lt;h2&gt;Thoughts&lt;/h2&gt;
&lt;p&gt;This first benchmark was a little surprising for me:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I would have thought that &lt;code&gt;delimcc&lt;/code&gt; to be ahead of Lwt when dealing with functions with a small call-depth and a small amount of blocking (i.e. the traffic pattern that loaded network servers see). The cost of taking a restartable exception seems quite high however.
&lt;/li&gt;
&lt;li&gt;The fiber tests still use the Lwt machinery to manage the callback mechanism (i.e. a &lt;code&gt;select&lt;/code&gt; loop and the timer priority queue). It may be possible to create a really light-weight version just for &lt;code&gt;delimcc&lt;/code&gt;, but the Lwt UNIX backend is already pretty lean and mean and uses the &lt;a href=&quot;http://software.schmorp.de/pkg/libev.html&quot;&gt;libev&lt;/a&gt; to interface with the OS.
&lt;/li&gt;
&lt;li&gt;The problem of having to rewrite code to be Lwt-like still exists unfortunately, but it is getting better as the &lt;code&gt;pa_lwt&lt;/code&gt; syntax extension matures and is integrated into my &lt;a href=&quot;https://github.com/raphael-proust/ocaml_lwt.vim&quot;&gt;favourite editor&lt;/a&gt; (thanks Raphael!)
&lt;/li&gt;
&lt;li&gt;Finally, by far the biggest benefit of &lt;code&gt;Lwt&lt;/code&gt; is that it can be compiled straight into Javascript using the &lt;a href=&quot;http://ocsigen.org/js_of_ocaml/&quot;&gt;js_of_ocaml&lt;/a&gt; compiler, opening up the possibility of cool browser visualisations and tickets to cool &lt;code&gt;node.js&lt;/code&gt; parties that I don't normally get invited to.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I need to stress that these benchmarks are very micro, and do not take into account other things like memory allocation. The standalone code for the tests is &lt;a href=&quot;http://github.com/avsm/delimcc-vs-lwt&quot;&gt;online at Github&lt;/a&gt;, and I would be delighted to hear any feedback.&lt;/p&gt;
&lt;h2&gt;Retesting recursion [18th Jun 2011]&lt;/h2&gt;
&lt;p&gt;Jake Donham comments:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I speculated in my post that fibers might be faster if the copy/restore were amortized over a large stack. I wonder if you would repeat the experiment with versions where you call fn only in the base case of sum, instead of at every call. I think you're getting N^2 behavior here because you're copying and restoring the stack on each iteration.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When writing the test, I figured that calling the thread waiting function more often wouldn't alter the result (careless). So I modified the test suite to have a &lt;code&gt;recurse&lt;/code&gt; test that only waits a single time at the end of a long call stack (see below) as well as the original N^2 version (now called &lt;code&gt;recurse2&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  module Fiber = struct
    let recurse fn depth =
      let rec sum n = 
        match n with
        |0 -&amp;gt; Lwt_fiber.await (fn ()); 0
        |n -&amp;gt; n + (sum (n-1)) 
      in
      for i = 1 to 15000 do
        ignore(sum depth)
      done

    let run fn depth = 
      Lwt_fiber.start (fun () -&amp;gt; recurse fn depth)
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The N^2 version below of course looks the same as the previously run tests, with delimcc getting much worse as it yields more often:&lt;/p&gt;
&lt;img src=&quot;http://chart.apis.google.com/chart?cht=lxy&amp;amp;chs=600x250&amp;amp;chtt=Recurse2%20vs%20basic&amp;amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;amp;chxt=x,x,y,y&amp;amp;chxl=1:%7Cstack-depth%7C3:%7Cseconds&amp;amp;chds=a&amp;amp;chg=10,10,1,5&amp;amp;chd=t:50,100,200,300,400,600,800,1000%7C0.282,0.566,1.159,1.784,2.416,3.719,5.019,6.278%7C50,100,200,300,400,600,800,1000%7C0.658,1.587,4.426,8.837,14.508,31.066,60.438,94.708&amp;amp;chdl=lwt-recurse2-slow%7Cdelimcc-recurse2-slow&amp;amp;chdlp=t&amp;amp;chls=2%7C2&quot;/&gt; 
&lt;p&gt;However, when we run the &lt;code&gt;recurse&lt;/code&gt; test with a single yield at the end of the long callstack, the situation reverses itself and now &lt;code&gt;delimcc&lt;/code&gt; is faster. Note that this test ran with more iterations than the &lt;code&gt;recurse2&lt;/code&gt; test to make the results scale, and so the absolute time taken cannot be compared.&lt;/p&gt;
&lt;img src=&quot;http://chart.apis.google.com/chart?cht=lxy&amp;amp;chs=600x250&amp;amp;chtt=Recurse%20vs%20basic&amp;amp;chco=00FF00,FF0000,0000FF,FFAA00,AA00FF,00FFFF&amp;amp;chxt=x,x,y,y&amp;amp;chxl=1:%7Cstack-depth%7C3:%7Cseconds&amp;amp;chds=a&amp;amp;chg=10,10,1,5&amp;amp;chd=t:50,100,200,300,400,600,800,1000%7C0.162,0.216,0.341,0.499,0.622,0.875,1.194,1.435%7C50,100,200,300,400,600,800,1000%7C0.128,0.207,0.394,0.619,0.889,1.538,2.366,3.373&amp;amp;chdl=delimcc-recurse-slow%7Clwt-recurse-slow&amp;amp;chdlp=t&amp;amp;chls=2%7C2&quot;/&gt;
&lt;p&gt;The reason for Lwt being slower in this becomes more clear when we examine what the code looks like after it has been passed through the &lt;code&gt;pa_lwt&lt;/code&gt; syntax extension. The code before looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  let recurse fn depth =
    let rec sum n =
      match n with
      | 0 -&amp;gt; 
          fn () &amp;gt;&amp;gt; return 0
      | n -&amp;gt;
          lwt n' = sum (n-1) in 
          return (n + n') in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and after &lt;code&gt;pa_lwt&lt;/code&gt; macro-expands it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;  let recurse fn depth =
    let rec sum n =
      match n with
      | 0 -&amp;gt;
          Lwt.bind (fn ()) (fun _ -&amp;gt; return 0)
      | n -&amp;gt;
          let __pa_lwt_0 = sum (n - 1)
          in Lwt.bind __pa_lwt_0 (fun n' -&amp;gt; return (n + n')) in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Every iteration of the recursive loop requires the allocation of a closure (the &lt;code&gt;Lwt.bind&lt;/code&gt; call). In the &lt;code&gt;delimcc&lt;/code&gt; case, the function operates as a normal recursive function that uses the stack, until the very end when it needs to save the stack in one pass.&lt;/p&gt;
&lt;p&gt;Overall, I'm convinced now that the performance difference is insignificant for the purposes of choosing one thread system over the other for MirageOS.  Instead, the question of code interoperability is more important. Lwt-enabled protocol code will work unmodified in Javascript, and Delimcc code helps migrate existing code over.&lt;/p&gt;
&lt;p&gt;Interestingly, &lt;a href=&quot;https://developer.mozilla.org/en/new_in_javascript_1.7&quot;&gt;Javascript 1.7&lt;/a&gt; introduces a &lt;em&gt;yield&lt;/em&gt; operator, which &lt;a href=&quot;http://parametricity.net/dropbox/yield.subc.pdf&quot;&gt;has been shown&lt;/a&gt; to have comparable expressive power to the &lt;em&gt;shift-reset&lt;/em&gt; delimcc operators. Perhaps convergence isn't too far away after all...&lt;/p&gt;

      </content><id>https://mirage.io/blog/delimcc-vs-lwt</id><title type="text">Delimited Continuations vs Lwt for Threads</title><updated>2011-06-18T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/spring-cleaning" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;We've been plugging away on Mirage for the last few months, and things are starting to take shape nicely. As the older blog entries were out-of-date, we have shifted the descriptive material to a new &lt;a href=&quot;https://mirage.io/wiki&quot;&gt;wiki&lt;/a&gt; section instead. What else has been happening?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Xen unikernel backend is fully event-driven (no interrupts) and very stable under stress testing now. The TCP stack is also complete enough to self-host this website, and you can try it out by navigating to &lt;a href=&quot;http://xen.openmirage.org&quot;&gt;xen.openmirage.org&lt;/a&gt;. The stack doesnt actually do retransmissions yet, so your user experience may &amp;quot;vary&amp;quot;. Check out the &lt;a href=&quot;https://mirage.io/wiki/install&quot;&gt;installation&lt;/a&gt; and &lt;a href=&quot;https://mirage.io/wiki/hello-world&quot;&gt;hello world&lt;/a&gt; guides to try it out for yourself.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.nott.ac.uk/~rmm/&quot;&gt;Richard Mortier&lt;/a&gt; has put together a performance testing framework that lets us analyse the performance of Mirage applications on different backends (e.g. UNIX vs Xen), and against other conventional applications (e.g. BIND for DNS serving). Read more in the wiki &lt;a href=&quot;https://mirage.io/wiki/performance&quot;&gt;here&lt;/a&gt;.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gazagnaire.org&quot;&gt;Thomas Gazagnaire&lt;/a&gt; has rewritten the website to use the COW syntax extensions. He has also started a new job with &lt;a href=&quot;http://www.ocamlpro.com/&quot;&gt;OCamlPro&lt;/a&gt; doing consultancy on OCaml, so congratulations are in order!
&lt;/li&gt;
&lt;li&gt;Thomas has also started integrating experimental Node.js support to fill in our buzzword quota for the year (and more seriously, to explore alternative VM backends for Mirage applications).
&lt;/li&gt;
&lt;li&gt;The build system (often a bugbear of such OS projects) now fully uses &lt;a href=&quot;https://github.com/ocaml/ocamlbuild&quot;&gt;ocamlbuild&lt;/a&gt; for all OCaml and C dependencies, and so the whole OS can be rebuilt with different compilers (e.g. LLVM) or flags with a single invocation.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are some exciting developments coming up later this year too!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/raphael-proust&quot;&gt;Raphael Proust&lt;/a&gt; will be joining the Mirage team in Cambridge over the summer in an internship.
&lt;/li&gt;
&lt;li&gt;Anil Madhavapeddy will be giving several &lt;a href=&quot;https://mirage.io/wiki/talks&quot;&gt;tech talks&lt;/a&gt; on Mirage: at the &lt;a href=&quot;https://forge.ocamlcore.org/plugins/mediawiki/wiki/ocaml-meeting/index.php/OCamlMeeting2011&quot;&gt;OCaml User's Group&lt;/a&gt; in Paris this Friday, at &lt;a href=&quot;http://acunu.com&quot;&gt;Acunu&lt;/a&gt; in London on May 31st, and at Citrix Cambridge on June 3rd. If you are interested, please do drop by and say hi.
&lt;/li&gt;
&lt;li&gt;Verisign has supported the project with an &lt;a href=&quot;http://www.marketwire.com/press-release/Verisign-Announces-Winners-of-Grants-Aimed-at-Strengthening-Internet-Infrastructure-NASDAQ-VRSN-1412893.htm&quot;&gt;Internet Infrastructure Grant&lt;/a&gt;.
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dave.recoil.org&quot;&gt;David Scott&lt;/a&gt; (chief architect of the Xen Cloud Platform) and &lt;a href=&quot;http://anil.recoil.org&quot;&gt;Anil Madhavapeddy&lt;/a&gt; will give a joint tutorial on constructing functional operating systems at the &lt;a href=&quot;http://cufp.org&quot;&gt;Commercial Users of Functional Programming&lt;/a&gt; workshop in Tokyo, Japan in September.
&lt;/li&gt;
&lt;/ul&gt;

      </content><id>https://mirage.io/blog/spring-cleaning</id><title type="text">A Spring Wiki Cleaning</title><updated>2011-04-11T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry><entry><link href="https://mirage.io/blog/self-hosting-mirage-website" rel="alternate"/><contributor><uri>https://mirage.io/feed.xml</uri><name>mirage</name></contributor><content type="html">
        &lt;p&gt;Welcome to the new self-hosting website for the Mirage project!  As we go about preparing a release for later in the year, this blog will contain technical musings and work-in-progress reports of various bits of the operating system as they mature. Since there's so much to talk about, we decided to start with a blog format, and eventually collect things into a proper document as they stabilise.&lt;/p&gt;
&lt;p&gt;Feel free to subscribe to the &lt;a href=&quot;https://mirage.io/blog/atom.xml&quot;&gt;Atom&lt;/a&gt; feed to keep up-to-date with our progress, or just e-mail us or comment on individual posts with any queries.&lt;/p&gt;

      </content><id>https://mirage.io/blog/self-hosting-mirage-website</id><title type="text">Self-hosting MirageOS website</title><updated>2010-10-11T00:00:00-00:00</updated><author><name>Anil Madhavapeddy</name></author></entry></feed>