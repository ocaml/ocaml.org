---
title: 'Size matters: how Mirage got smaller and less magical'
description:
url: https://mirage.io/blog/mirage-3-smaller
date: 2017-02-27T00:00:00-00:00
preview_image:
featured:
authors:
- Hannes Mehnert
---


        <p>In this article, some technical background and empirical evidence is given how
we reduced the lines of code in Mirage3, which has about 25% fewer lines of
code than Mirage2, while providing <a href="https://mirage.io/blog/announcing-mirage-30-release">more features</a>.</p>
<p>Mirage does a fair amount of code generation since its initial release to extend
target-agnostic unikernels to target-specific virtual machine images (or Unix
binaries).
Until Mirage 2.7, string concatenation <a href="https://github.com/mirage/mirage/blob/v2.6.1/lib/mirage.ml">was used
heavily</a>.  Since the
Mirage 2.7.0 release (February 2016), it is based on
<a href="https://mirage.io/blog/introducing-functoria">functoria</a>, &quot;a DSL to describe a
set of modules and functors, their types and how to apply them in order to
produce a complete application&quot;.
The code generated by Mirage3 is less complex than the Mirage2 one and contains up to 45% fewer
lines of code.</p>
<h2>Generating code considered harmful</h2>
<p>Code generated by a program with intricate control flow and automatically
generated identifier names is difficult to understand by a human - in case the
generated code is incorrect and needs to be debugged (or the compiler chokes on
it with an error message pointing in the middle of intricate generated code).
It is also a burden on the developer, since generated code should not be part of
the version control system, thus the build system needs to include another step.
If the code generator is buggy, or not easily extendible for new features,
developers may want to manually modify the generated code - which then turns
into a release nightmare, since you need to maintain a set of patches on top of
generated code, while the code generator may is developed alongside.  Generating
code is best avoided - maybe there is a feature in the programming language to
solve the boilerplate without code generators.</p>
<p>Having said this, there's nothing wrong with LISP macros or MetaOCaml.</p>
<p>Mirage uses code generation to complete backend-agnostic unikernels with the
required boilerplate to compile for a specific backend - by selecting the
network device driver, the console, the network stack, and other devices -
taking user-supplied configuration arguments into account.  In Mirage, the OCaml
TCP/IP stack requires any network device which implements the
<a href="http://docs.mirage.io/mirage-net/Mirage_net/module-type-S/index.html"><code>Mirage_net.S</code></a>
module type.</p>
<p>At the end of the day, some mechanism needs to be in place which links the
<a href="https://github.com/mirage/mirage-net-solo5">mirage-net-solo5</a> library if
compiling for Solo5 (or
<a href="https://github.com/mirage/mirage-net-xen">mirage-net-xen</a> if compiling for xen,
or <a href="https://github.com/mirage-net-unix">mirage-net-unix</a> for Unix, or
<a href="https://github.com/mirage/mirage-net-macosx">mirage-net-macosx</a> for MacOSX).
This can be left to each unikernel developer, which would require having the
same boilerplate code all over, which needs to be updated if a new backend
becomes available (Mirage2 knew about Xen, Unix, and MacOSX, Mirage3 extends
this with Solo5 and Qubes).  Instead, the mirage tool generates this boilerplate
by knowing about all supported devices, and which library a unikernel has to
link for a device depending on the target and command line arguments.
That's not exactly the ideal solution.  But it works good enough for us right
now (<a href="https://github.com/mirage/mirage/pull/750">more or less</a>).  A single place - the mirage tool - needs to be extended whenever a new backend becomes
available.</p>
<h2>Device initialisation - <code>connect</code></h2>
<p>Devices may depend on each other, e.g. a TCP stack requires a monotonic clock and a
random number generator, which influences the initialisation order.  Mirage
generates the device initialisation startup code based on the configuration and
data dependencies (which hopefully form an acyclic graph).  Mirage2 allowed to
handle initialisation errors (the type of <code>connect</code> used to be <code>unit -&gt; [ `Ok of t | `Error of error ] io</code>), but calls to <code>connect</code> were automatically
generated, and the error handler always spit out an error message and exited.
Becaus the <code>error</code> was generic, Mirage2 didn't know how to properly print it,
and instead failed with some incomprehensible error message.  Pretty printing
errors is solved in Mirage3 by our <a href="https://github.com/mirage/mirage/pull/743">re-work of errors</a>, which now use the <code>result</code>
type, are extendible, and can be pretty printed.  Calls to <code>connect</code> are
automatically generated, and handling errors gracefully is out of scope for a
unikernel -- where should it get the other 2 network devices promised at
configuration time from, if they're not present on the (virtual) PCI bus?</p>
<p>The solution we <a href="https://lists.xenproject.org/archives/html/mirageos-devel/2016-09/msg00050.html">discussed</a>
and <a href="https://github.com/mirage/mirage/pull/602">implemented</a> (also in <a href="https://github.com/mirage/functoria/pull/71">functoria</a>) was to always fail hard (i.e. crash) in <code>connect : unit -&gt; t</code>.  This lead to a series of patches for all implementors of <code>connect</code>,
where lots of patches removed control flow complexity (and less complex test
cases, see e.g.
<a href="https://github.com/mirage/mirage-net-unix/pull/27/files">mirage-net-unix</a>, or
<a href="https://github.com/mirage/mirage-tcpip/pull/251/files">tcpip</a>).  Lots of common
boilerplate (like <code>or_error</code>, which throws an exception if <code>connect</code> errored)
could be removed.</p>
<p>Comparing the generated <code>main.ml</code> between Mirage 2.9.1 and 3.0.0 for various
unikernels on both unix and xen code reductions up to 45% (<a href="http://www.cl.cam.ac.uk/~hm519/mirage-2.9.1-3.0.0-diffs/">diffs are
here</a>)</p>
<ul>
<li>console (device-usage) xen: +35 -41 (now 81) unix: +32 -39 (now 80)
</li>
<li>block (device-usage) xen: +36 -45 (now 87) unix: +34 -44 (now 86)
</li>
<li>kv_ro (device-usage) xen: +34 -59 (now 75) unix: +39 -51 (now 86)
</li>
<li>network (device-usage) xen: +82 -134 (now 178) unix: +79 -133 (now 177)
</li>
<li>conduit_server (device-usage) xen: +86 -152 (now 200) unix: +84 -213 (now 199)
</li>
<li>dhcp (applications) xen: +44 -51 (now 93) unix: +41 -49 (now 92)
</li>
<li>dns (applications) xen: +86 -143 (now 190) unix: +83 -141 (now 189)
</li>
<li>static_website_tls (applications) xen: +97 -176 (now 230) unix: +108 -168 (now 237)
</li>
<li>nqsb.io xen: +122 -171 (now 223) unix: +65 -85 (now 133)
</li>
<li>btc-pinata xen: +119 -155 (now 217) unix: +64 -73 (now 127)
</li>
<li>canopy xen: +106 -180 (now 245) unix: +61 -106 (now 159)
</li>
</ul>
<h2>Workflow, phase separation, versioned opam dependencies</h2>
<p>The workflow to build a unikernel used to be <code>mirage configure</code> followed by
<code>make</code>.  During the configure phase, a <code>Makefile</code> was generated with the right
build and link commands (depending on configuration target and other
parameters).  Mirage2 installed opam packages and system packages as a side
effect during configuration.  This lead to several headaches: you needed to have the
target-specific libraries installed while you were configuring (you couldn't
even test the configuration for xen if you didn't have xen headers and support
libraries installed).  Reconfiguration spawned yet another <code>opam</code> process (which
even if it does not install anything since everything required is already
installed, takes some time since the solver has to evaluate the universe) -
unless the <code>--no-opam</code> option was passed to <code>mirage configure</code>.</p>
<p>A second issue with the Mirage2 approach was that dependent packages were listed
in the unikernel <code>config.ml</code>, and passed as string to opam.  When version
constraints were included, this lead either shell (calling out <code>opam</code>) or make
(embedding the packages in the Makefile) or both to choke.  Being able to
express version constraints for dependencies in <code>config.ml</code> was one of the most
wanted features for Mirage3.  It is crucial for further development (to continue
allowing API breakage and removing legacy): a unikernel author, and the mirage
tool, can now embed versioned dependencies onto device interfaces.  Instead of a
garbled error message from mirage trying to compile a unikernel where the
libraries don't fit the generated code, opam will inform which updates are
necessary.</p>
<p>In a <a href="https://github.com/mirage/mirage/pull/691">first rampage</a> (<a href="https://github.com/mirage/functoria/pull/82">functoria</a>) instead of
manual executions of <code>opam</code> processes, an opam package file was generated by
mirage at configuration time for the given target.  This allowed to express
version constraints in each <code>config.ml</code> file (via the <code>package</code> function).  This
change also separated the configuration phase, the dependency installation
phase, and the build phase - which included delayed invocations of <code>pkg-config</code>
to pass parameters to <code>ld</code>.  A mess, especially if your goal is to generate
Makefiles which run both on GNU make and BSD make.</p>
<p>A <a href="https://github.com/mirage/mirage/pull/703">second approach</a> (<a href="https://github.com/mirage/functoria/pull/84">functoria</a>) digged a bit
deeper down the rabbit hole, and removed complex selection and adjustment of
strings to output the Makefile, by implementing this logic in OCaml (and calling
out to <code>ocamlbuild</code> and <code>ld</code>).  Removing an uneeded layer of code generation is
easier to read and understand, less code, and includes stronger guarantees.
More potential errors are caught during compile time, instead of generating
(possible ill-formed) Makefiles.  <a href="http://erratique.ch/software/bos">Bos</a> is a
concise library interacting with basic operating system services, and solves
once and for all common issues in that area, such as properly escaping of
arguments.</p>
<p>Mirage3 contains, instead of a single <code>configure_makefile</code> function which
generated the entire makefile, the build and link logic is separated into
functions, and only a simplistic makefile is generated which invokes <code>mirage build</code> to build the unikernel, and expects all dependent libraries to be
installed (e.g. using <code>make depend</code>, which invokes <code>opam</code>) -- no need for
delaying <code>pkg-config</code> calls anymore.</p>
<p>This solution has certainly less complex string concatenation, and mirage has
now a clearer phase distinction - configure, depend, compile &amp; link.  (This
workflow (still) <a href="https://github.com/mirage/mirage/issues/694">lacks a provisioning
step</a> (e.g. private key material,
if provided as static binary blob, needs to be present during compilation atm),
but can easily be added later.)  There are drawbacks: the mirage utility is now
needed during compilation and linking, and needs to preserve command line
arguments between configuration and build phase.  Maybe the build step should be
in the opam file, then we would need to ensure unique opam package names and we
would need to communicate to the user where the binary got built and installed.</p>
<h2>Other functionality removed or replaced</h2>
<p>The first commit to mirage is from 2004, back then opam was an infant.  Mirage2
ensured that a <a href="https://github.com/mirage/mirage/blob/v2.9.1/lib/mirage.ml#L1462-L1487">not-too-ancient version of
OCaml</a>
is installed (<a href="https://github.com/mirage/functoria/blob/1.1.1/lib/functoria_misc.ml#L298-L309">functoria contained a similar piece of
code</a>).
Mirage3 relies on opam to require a certain OCaml version (at the moment 4.03).</p>
<p>Mirage and functoria were developed while support libraries were not yet
available - worth mentioning <a href="http://erratique.ch/software/bos">bos</a> (mentioned
above), <a href="http://erratique.ch/software/fpath">fpath</a>,
<a href="http://erratique.ch/software/logs">logs</a>, and
<a href="http://erratique.ch/software/astring">astring</a>.  Parts of those libraries were
embedded in functoria, and are now replaced by the libraries. (See
<a href="https://github.com/mirage/mirage/pull/703">mirage#703</a> and
<a href="https://github.com/mirage/functoria/pull/84">functoria#84</a> in case you want to
know the details.)</p>
<p>Functoria support for OCaml <code>&lt;4.02</code> has been
<a href="https://github.com/mirage/functoria/pull/75">dropped</a>, also
<a href="https://github.com/mirage/functoria/pull/77">astring</a> is now in use.
Mirage support for OCaml <code>&lt;4.01</code> has been
<a href="https://github.com/mirage/mirage/blob/v2.9.1/lib/mirage.ml#L1318-L1355">dropped</a>
from Mirage.</p>
<p>Some C bits and pieces, namely <code>str</code>, <code>bignum</code>, and <code>libgcc.a</code>, are no longer linked and part
of every unikernel.  This is documented in
<a href="https://github.com/mirage/mirage/pull/544">mirage#544</a> and
<a href="https://github.com/mirage/mirage/issues/663">mirage#663</a>.</p>
<h2>Conclusion</h2>
<p>The overall statistics of Mirage3 look promising: more libraries, more
contributors, less code, uniform error treatment, unified logging support.  Individual unikernels
contain slightly less boilerplate code (as shown
<a href="http://www.cl.cam.ac.uk/~hm519/mirage-2.9.1-3.0.0-diffs/">by these unified diffs</a>).</p>
<p>The binary sizes of the above mentioned examples (mirage-skeleton, nqsb, Canopy,
pinata) between Mirage2 and Mirage3 results on both Unix and Xen only in small
differences (in the range of kilobytes).  We are working on a <a href="https://github.com/mirage/mirage/issues/685">performance harness</a>
to evaluate the performance of
<a href="https://blogs.janestreet.com/flambda/">flambda</a> intermediate language in OCaml
and <a href="https://github.com/ocaml/ocaml/pull/608">dead code elimination</a>.  These should
decrease the binary size and improve the performance.</p>

      
