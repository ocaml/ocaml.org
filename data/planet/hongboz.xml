<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://hongboz.wordpress.com/feed/</id><title type="text">hongboz</title><updated>2023-06-07T05:45:50-00:00</updated><entry><link href="https://hongboz.wordpress.com/2013/09/16/code-layout-of-fan-a-metaprogramming-tool-for-ocaml/" rel="alternate"/><contributor><uri>https://hongboz.wordpress.com/feed/</uri><name>hongboz</name></contributor><content type="html">&lt;div&gt;
&lt;p&gt;
Fan is a metaprogramming tool for OCaml.  I believe it would be an&lt;br/&gt;
invaluable tool for the community when it&amp;rsquo;s production ready.
&lt;/p&gt;
&lt;p&gt;
If you are attracted by the power of Camlp4 while frustrated with the&lt;br/&gt;
complexity, or slowness, I would be very glad that you could join and contribute.
&lt;/p&gt;
&lt;p&gt;
It&amp;rsquo;s already ready for accepting external contribution, since the&lt;br/&gt;
development of Fan would be pinned to &lt;a href=&quot;http://caml.inria.fr/pub/distrib/ocaml-4.01/&quot;&gt;OCaml 4.01.0&lt;/a&gt; for a while.
&lt;/p&gt;
&lt;div class=&quot;outline-2&quot;&gt;
&lt;h2&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; Code layout&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot;&gt;
&lt;p&gt;
The source is scattered in four directories&lt;br/&gt;
&lt;code&gt;common&lt;/code&gt;, &lt;code&gt;treeparser&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;cold&lt;/code&gt;, and &lt;code&gt;unitest&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt;
In the common directory, all sources are written in &lt;i&gt;vanilla OCaml&lt;/i&gt;,&lt;br/&gt;
it defines basic primitives which dumps Fan&amp;rsquo;s abstract syntax into&lt;br/&gt;
OCaml&amp;rsquo;s abstract syntax.
&lt;/p&gt;
&lt;p&gt;
Note that all compiler related modules is isolated in this&lt;br/&gt;
directory. That said, in the future, if we would like to support&lt;br/&gt;
different patched compiler, for example, metaocaml or Lexifi&amp;rsquo;s mlfi&lt;br/&gt;
compiler, only this directory needs to be touched.
&lt;/p&gt;
&lt;p&gt;
In the treeparser directory, it is also written in &lt;i&gt;vanilla Ocaml&lt;/i&gt;,&lt;br/&gt;
it defines the runtime of the parsing structure.
&lt;/p&gt;
&lt;p&gt;
The &lt;code&gt;src&lt;/code&gt; directory is written in Fan&amp;rsquo;s syntax.&lt;br/&gt;
Keep in mind that Fan&amp;rsquo;s syntax is essentially the same as OCaml&amp;rsquo;s&lt;br/&gt;
syntax, except that it allows quotations, and other tiny&lt;br/&gt;
differences (parens around tuple is necessary, not optional).
&lt;/p&gt;
&lt;p&gt;
The &lt;code&gt;cold&lt;/code&gt; directory is a mirror of &lt;code&gt;src&lt;/code&gt; directory in &lt;i&gt;vanilla&lt;br/&gt;
ocaml&lt;/i&gt;, though it is much verbose compared with src.
&lt;/p&gt;
&lt;p&gt;
So when you get the source tree, the initial build  is typically
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-sh&quot;&gt;ocamlbuild cold/fan.native
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
The first command &lt;code&gt;ocamlbuild cold/fan.native&lt;/code&gt; would build a binary&lt;br/&gt;
composed of modules from &lt;code&gt;common&lt;/code&gt;, &lt;code&gt;treeparser&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt;. Since&lt;br/&gt;
they are all written in &lt;i&gt;vanilla ocaml&lt;/i&gt;, no preprocessors are&lt;br/&gt;
needed for the initial compilation.
&lt;/p&gt;
&lt;p&gt;
If you are a third party user, that&amp;rsquo;s pretty much all you need to&lt;br/&gt;
know. As a developer of Fan, the next command is
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-sh&quot;&gt;./re cold fan.native
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
This shell script would symlink &lt;code&gt;_build/cold/fan.native&lt;/code&gt; to&lt;br/&gt;
&lt;code&gt;_build/boot/fan&lt;/code&gt;, which would be used by compiling src.
&lt;/p&gt;
&lt;p&gt;
Now you can compile the src directory
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-sh&quot;&gt;ocamlbuild src/fan.native
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
The command &lt;code&gt;ocamlbuild cold/fan.native&lt;/code&gt; would build a binary&lt;br/&gt;
composed of modules from &lt;code&gt;common&lt;/code&gt;, &lt;code&gt;treeparser&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
Note that at this time src is a mirror of cold, after preprocessored&lt;br/&gt;
by fan, the produced binary &lt;code&gt;src/fan.native&lt;/code&gt; should be the same as&lt;br/&gt;
&lt;code&gt;cold/fan.native&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
Now you can
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-sh&quot;&gt;./re src fan.native
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
But this does not make much sense since &lt;code&gt;src/fan.native&lt;/code&gt; is exactly&lt;br/&gt;
the same as &lt;code&gt;./cold/fan.native&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
Okay, in most cases, your development would be in such directories:&lt;br/&gt;
common, treeparser, src and unitest.
&lt;/p&gt;
&lt;p&gt;
If you only touch common, treeparser or unitest, commit the changes&lt;br/&gt;
and send me a pull request.
&lt;/p&gt;
&lt;p&gt;
If you also touch the files in &lt;code&gt;src&lt;/code&gt; directory, you should mirror&lt;br/&gt;
those changes back to &lt;code&gt;cold&lt;/code&gt; directory. Here we go:
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-sh&quot;&gt;./snapshot
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
Yes, now all the changes in &lt;code&gt;src&lt;/code&gt; will be mirrored back to &lt;code&gt;cold&lt;/code&gt;&lt;br/&gt;
directory.&lt;br/&gt;
For a simple change, commit and done. For a complex change that you&lt;br/&gt;
are not sure whether it would break anything or not, try to run:
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-sh&quot;&gt;./hb fan.native
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
The command above would first build &lt;code&gt;src/fan.native&lt;/code&gt; using the&lt;br/&gt;
current preprocessor &lt;code&gt;_build/boot/fan&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
When it&amp;rsquo;s done, it would first remove the directories &lt;code&gt;_build/src&lt;/code&gt;,&lt;br/&gt;
and &lt;code&gt;_build/common&lt;/code&gt;, &lt;code&gt;_build/treeparser&lt;/code&gt;. Then it would set&lt;br/&gt;
&lt;code&gt;_build/boot/fan&lt;/code&gt; to be the new build preprocessor &lt;code&gt;src/fan.native&lt;/code&gt;.&lt;br/&gt;
After that it would call &lt;code&gt;ocamlbuild src/fan.native&lt;/code&gt; to build a new&lt;br/&gt;
preprocessor based on the existing preprocessor.
&lt;/p&gt;
&lt;p&gt;
Then it would compare the two preprocessors, if they are exactly the&lt;br/&gt;
same, it means we manage to have a successful bootstrap. There is a&lt;br/&gt;
large chance that your change is correct.
&lt;/p&gt;
&lt;p&gt;
Then
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-sh&quot;&gt;make test
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
If everything goes well, it&amp;rsquo;s safe to commit now.
&lt;/p&gt;
&lt;p&gt;
When the bootstrap fails, generally two cases: 1. the comparison&lt;br/&gt;
does not tell you the two preprocessors are the same, the normal&lt;br/&gt;
workflow is to repeat the command &lt;code&gt;./hb fan.native&lt;/code&gt; again. 2. It&lt;br/&gt;
fails to compile, since you always have &lt;code&gt;cold/fan.native&lt;/code&gt; compiled,&lt;br/&gt;
fall back to such preprocessor and see where you made wrong.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><id>https://hongboz.wordpress.com/2013/09/16/code-layout-of-fan-a-metaprogramming-tool-for-ocaml/</id><title type="text">Code layout of Fan (a metaprogramming tool for OCaml)</title><updated>2013-09-16T19:04:58-00:00</updated><author><name>hongboz</name></author></entry><entry><link href="https://hongboz.wordpress.com/2013/02/05/syntactic-meta-programming-in-ocaml-ii-5/" rel="alternate"/><contributor><uri>https://hongboz.wordpress.com/feed/</uri><name>hongboz</name></contributor><content type="html">&lt;p&gt;In this post, we continue discussing syntactic meta-programming&lt;br/&gt;
following &lt;a href=&quot;https://hongboz.wordpress.com/2013/01/28/random-thoughts-about-syntactic-meta-programming-i/&quot;&gt;last post&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
My years of experience in different meta-program system(Common Lisp,&lt;br/&gt;
Template Haskell, Camlp4) tell me that quosi-quotation is the most&lt;br/&gt;
essential part in syntactic meta programming. Though all three claims&lt;br/&gt;
they have quosi-quotation support. But Template Haskell&amp;rsquo;s&lt;br/&gt;
quosi-quotation falls far behind either Camlp4 or Common Lisp. For a&lt;br/&gt;
decent quosi-quotation system, first, nested quotation and&lt;br/&gt;
anti-quotation is necessary, second, like Lisp, every part should be&lt;br/&gt;
able to be quoted and antiquoted except keywords position, that&amp;rsquo;s to&lt;br/&gt;
say, each part of the code fragment can be parametrized.
&lt;/p&gt;
&lt;p&gt;
For the notation, we denote &lt;code&gt;Ast^0&lt;/code&gt; as the normal Ast, &lt;code&gt;Ast^1&lt;/code&gt; as Ast&lt;br/&gt;
encoding &lt;code&gt;Ast^0&lt;/code&gt;, the same as &lt;code&gt;Ast^n&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
So in this post, we discuss the quosi-quotation first.
&lt;/p&gt;
&lt;p&gt;
The implementation of quosi-quotation heavily relies on the&lt;br/&gt;
implementation of the compiler, so let&amp;rsquo;s limit the scope of how to get&lt;br/&gt;
quosi-quotation done to OCaml.
&lt;/p&gt;
&lt;p&gt;
Let&amp;rsquo;s ignore the antiquote part, and focus the quote part first, the&lt;br/&gt;
essential of quosi-quotation is to encode the Ast using Ast itself in&lt;br/&gt;
the meta level: there are different technologies to implement&lt;br/&gt;
quosi-quotations, to my knowledge, I summarized three here:
&lt;/p&gt;
&lt;div class=&quot;outline-3&quot;&gt;
&lt;h3&gt;Raw String manipulation&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot;&gt;
&lt;p&gt;   This is the most intuitive way, given a string input, the normal&lt;br/&gt;
   way of parsing is transform it into a parsetree,
&lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#ffa500;font-weight:bold;&quot;&gt;val&lt;/span&gt; &lt;span style=&quot;color:#dfaf8f;&quot;&gt;parse&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#8cd0d3;&quot;&gt;string &lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#8cd0d3;&quot;&gt; ast&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
   To encode the meta-level ast, we can do the unparsing again,&lt;br/&gt;
   assume we have an unparsing function which unparse the ast
&lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#ffa500;font-weight:bold;&quot;&gt;val&lt;/span&gt; &lt;span style=&quot;color:#dfaf8f;&quot;&gt;unparse&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#8cd0d3;&quot;&gt;ast &lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#8cd0d3;&quot;&gt; string&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
   so after the composition of parse and unparse, you transformed a&lt;br/&gt;
   string into the meta-level
&lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt;parse &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;)&lt;/span&gt;
&lt;span style=&quot;color:#f0e68c;&quot;&gt;-&lt;/span&gt; `Int &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt;
unparse&lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt;parse &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;)&lt;/span&gt;
&lt;span style=&quot;color:#f0e68c;&quot;&gt;-&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;`Int \&amp;quot;3\&amp;quot;&amp;quot;&lt;/span&gt;

&lt;/pre&gt;
&lt;p&gt;
   Then you can do &lt;code&gt;parse&lt;/code&gt; again, after &lt;code&gt;parse(unparse (parse &amp;quot;3&amp;quot;))&lt;/code&gt;,&lt;br/&gt;
   we managed to lift the Ast in the meta level. There are serious&lt;br/&gt;
   defects with this way, First, it&amp;rsquo;s very brittle, since we are doing&lt;br/&gt;
   string manipulation in different levels, second, after &lt;b&gt;unparsing&lt;/b&gt;,&lt;br/&gt;
   the location is totally lost, location is one of the most tedious&lt;br/&gt;
   but necessary part for a practical meta programming system, third,&lt;br/&gt;
   there is no easy way to integrate with antiquot. This technique is&lt;br/&gt;
   quite intuitive and easy to understand, but I don&amp;rsquo;t know any&lt;br/&gt;
   meta-system do it this way, so feel free to tell me if you know&lt;br/&gt;
   anyone does similar work &lt;img src=&quot;https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/72x72/1f609.png&quot; alt=&quot;&amp;#128521;&quot; class=&quot;wp-smiley&quot; style=&quot;height: 1em; max-height: 1em;&quot;/&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;outline-3&quot;&gt;
&lt;h3&gt;Maintaining different parsers&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot;&gt;
&lt;p&gt;
   Unlike the string manipulation, it write different parsers for&lt;br/&gt;
   different actions. Suppose we are in OCaml, if we want to support&lt;br/&gt;
   quosi-quotations in such syntax categories
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;sig_item, str_item, patt, expr, module_type, module_expr, class_type
class_expr, class_sig_item, class_str_item, with_constr, binding, rec_binding,
match_case,
&lt;/pre&gt;
&lt;p&gt;
   And you want the quosi-quotaion appears in both &lt;code&gt;expr&lt;/code&gt; and &lt;code&gt;patt&lt;/code&gt;&lt;br/&gt;
   positions, then you have to write &lt;code&gt;14 x (2+1)&lt;/code&gt; parsers, the parser can&lt;br/&gt;
   not be re-usable, if you want to support &lt;code&gt;overloaded quotations&lt;/code&gt; (I&lt;br/&gt;
   will talk about it later), then you have to roll your own parser&lt;br/&gt;
   again. Writing parser is not hard, but it&amp;rsquo;s not fun either, and&lt;br/&gt;
   keeping sync up different parsers is a nightmare.
&lt;/p&gt;
&lt;p&gt;
   To make things worse, once anti-quotation is considered, for each&lt;br/&gt;
   category, there are three parsers to write, but anti-quot makes&lt;br/&gt;
   them slightly different. To be honest, this way is impractical.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;outline-3&quot;&gt;
&lt;h3&gt;Ast Lifting&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot;&gt;
&lt;p&gt;   Another mechanism to do quosi-quotation is that imaging we have a&lt;br/&gt;
   powerful function:
&lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#ffa500;font-weight:bold;&quot;&gt;val&lt;/span&gt; &lt;span style=&quot;color:#dfaf8f;&quot;&gt;meta&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#8cd0d3;&quot;&gt;ast&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;^&lt;/span&gt;0 &lt;span style=&quot;color:#f0e68c;&quot;&gt;-&amp;gt;&lt;/span&gt; ast&lt;span style=&quot;color:#f0e68c;&quot;&gt;^&lt;/span&gt;1
&lt;/pre&gt;
&lt;p&gt;
   This seems magic, but it&amp;rsquo;s possible even though in OCaml we don&amp;rsquo;t&lt;br/&gt;
   have generic programming support, since we have the definition&lt;br/&gt;
   of ast.
&lt;/p&gt;
&lt;p&gt;
   The problem with this technique is that it requires an explicit&lt;br/&gt;
   &lt;code&gt;Ant&lt;/code&gt; tag in the ast representation, since at &lt;code&gt;ast^0&lt;/code&gt; level, you&lt;br/&gt;
   have to store &lt;code&gt;Ant&lt;/code&gt; as intermediate node which will be removed when&lt;br/&gt;
   applied &lt;code&gt;meta&lt;/code&gt; function.
&lt;/p&gt;
&lt;p&gt;
   Let&amp;rsquo;s walk through each phase in Fan
&lt;/p&gt;
&lt;p&gt;
   Think about how such piece of code would be parsed in Fan:
&lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;{:&lt;/span&gt;&lt;span style=&quot;color:#8cd0d3;&quot;&gt;expr&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;|&lt;/span&gt; &lt;span style=&quot;color:#f0e68c;&quot;&gt;$&lt;/span&gt;x &lt;span style=&quot;color:#f0e68c;&quot;&gt;+&lt;/span&gt; y&lt;span style=&quot;color:#f0e68c;&quot;&gt;|}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
   For the first phase (I removed the location for simplicity)
&lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;`App&lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt;`App
      &lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;)),&lt;/span&gt;
        `Ant &lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt; &lt;span style=&quot;color:#f0e68c;&quot;&gt;{&lt;/span&gt;cxt &lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;expr&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;;&lt;/span&gt; sep &lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt; None&lt;span style=&quot;color:#f0e68c;&quot;&gt;;&lt;/span&gt; decorations &lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;;&lt;/span&gt; content &lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;})),&lt;/span&gt;
     `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;)))&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
   Here &lt;code&gt;Ant&lt;/code&gt; exists only as intermediate node, it will be eliminated&lt;br/&gt;
   in the meta-step
&lt;/p&gt;
&lt;p&gt;
   after applied with &lt;code&gt;meta&lt;/code&gt; function
&lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#8cd0d3;&quot;&gt;Filters&lt;/span&gt;.&lt;span style=&quot;color:#8cd0d3;&quot;&gt;ME&lt;/span&gt;.meta_expr _loc &lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt;t expr &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;$x + y&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;));&lt;/span&gt;
&lt;span style=&quot;color:#f0e68c;&quot;&gt;-&lt;/span&gt; &lt;span style=&quot;color:#f0e68c;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#8cd0d3;&quot;&gt;FanAst.expr &lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt;
`App
  &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt;
   `App
     &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;App&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt;
      `App
        &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt;
         `App
           &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;App&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt;
            `App
              &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;Id&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt;
               `App
                 &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;Lid&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt;
                  `Str &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;)))),&lt;/span&gt;
         `Ant &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#f0e68c;&quot;&gt;{&lt;/span&gt;cxt &lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;expr&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;;&lt;/span&gt; sep &lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt; None&lt;span style=&quot;color:#f0e68c;&quot;&gt;;&lt;/span&gt; decorations &lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;;&lt;/span&gt; content &lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;}))),&lt;/span&gt;
   `App
     &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;Id&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt;
      `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;Lid&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt; `Str &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))))&lt;/span&gt;   
&lt;/pre&gt;
&lt;p&gt;
   (t is a parsing function)&lt;br/&gt;
   Here we see that &lt;code&gt;Ant&lt;/code&gt; node is still kept and it will be&lt;br/&gt;
   filtering, now we can filter the &lt;code&gt;Ant&lt;/code&gt; node into a normal Ast,
&lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#8cd0d3;&quot;&gt;Ant&lt;/span&gt;.antiquot_expander &lt;span style=&quot;color:#f0e68c;&quot;&gt;~&lt;/span&gt;parse_patt &lt;span style=&quot;color:#f0e68c;&quot;&gt;~&lt;/span&gt;parse_expr&lt;span style=&quot;color:#f0e68c;&quot;&gt;)#&lt;/span&gt;expr &lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#8cd0d3;&quot;&gt;Filters&lt;/span&gt;.&lt;span style=&quot;color:#8cd0d3;&quot;&gt;ME&lt;/span&gt;.meta_expr _loc &lt;span style=&quot;color:#f0e68c;&quot;&gt;(&lt;/span&gt;t expr &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot; $x + y&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;));&lt;/span&gt;
&lt;span style=&quot;color:#f0e68c;&quot;&gt;-&lt;/span&gt; &lt;span style=&quot;color:#f0e68c;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#8cd0d3;&quot;&gt;FanAst.expr &lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt;
`App
  &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt;
   `App
     &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;App&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt;
      `App
        &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt;
         `App
           &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;App&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt;
            `App
              &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;Id&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt;
               `App
                 &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;Lid&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt;
                  `Str &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;)))),&lt;/span&gt;
         `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;)))),&lt;/span&gt;
   `App
     &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;Id&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt;
      `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `App &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Vrn &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;Lid&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;),&lt;/span&gt; `Id &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; `Lid &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;_loc&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))),&lt;/span&gt; `Str &lt;span style=&quot;color:#f0e68c;&quot;&gt;(,&lt;/span&gt; &lt;span style=&quot;color:#cc9393;&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;))))&lt;/span&gt;   
&lt;/pre&gt;
&lt;p&gt;
   (location in the meta-level is ignored)&lt;br/&gt;
   If we want to share the same grammar between the &lt;code&gt;Ast^n(n=0,1,2,...)&lt;/code&gt;,&lt;br/&gt;
   Ast lifting (a function of type &lt;code&gt;Ast^0 -&amp;gt; Ast^1&lt;/code&gt;) is necessary.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;outline-2&quot;&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot;&gt;
&lt;p&gt;
  We see the three techniques introduced here to do the&lt;br/&gt;
  quosi-quotation, Fan adopts the third one, suppose we pick the&lt;br/&gt;
  third one, let&amp;rsquo;s discuss what kind of Ast representation we need to&lt;br/&gt;
  make life easier.
&lt;/p&gt;
&lt;p&gt;
  As we discussed previously, introducing records in the Abstract Syntax&lt;br/&gt;
  brings in un-necessary complexity when you want to encode the Ast&lt;br/&gt;
  using the Ast itself since you have to express the record in the&lt;br/&gt;
  meta-level as well.
&lt;/p&gt;
&lt;p&gt;
  Another defect with current Parsetree is that it was designed without&lt;br/&gt;
  meta-programming in mind, so it does not provide an &lt;code&gt;Ant&lt;/code&gt; tag in all&lt;br/&gt;
  syntax categories, so in the zero stage &lt;code&gt;Ast^0&lt;/code&gt;, you can not have an&lt;br/&gt;
  Ast node &lt;code&gt;$x&lt;/code&gt; in the outermost, since it&amp;rsquo;s semantically incorrect in&lt;br/&gt;
  &lt;code&gt;Ast^0&lt;/code&gt;, but syntactically correct in &lt;code&gt;Ast^n(n=0,1,2,...)&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt;
  The third defect with the &lt;code&gt;Parsetree&lt;/code&gt; is that it&amp;rsquo;s quite irregular,&lt;br/&gt;
  so you can not do any meta-programming with the parsetree itself, for&lt;br/&gt;
  example, stripping all the location from the Ast node to derive a new&lt;br/&gt;
  type without locations, deriving a new type without anti-quot tags (we&lt;br/&gt;
  will see that such ability is quite important in &lt;a href=&quot;https://github.com/bobzhang/Fan&quot;&gt;Fan&lt;/a&gt;)
&lt;/p&gt;
&lt;p&gt;
  The fourth defect is more serious from the point of view of&lt;br/&gt;
  semantics, since in OCaml, there is no way to express absolute path,&lt;br/&gt;
  when you do the Ast lifting, the time you define Ast lifting is&lt;br/&gt;
  different from the time you use the quotations
&lt;/p&gt;
&lt;p&gt;
  Camlp4&amp;rsquo;s Ast is slightly better than Parsetree, since it does not&lt;br/&gt;
  introduce records to increase the complexity.
&lt;/p&gt;
&lt;p&gt;
  However, Camlp4&amp;rsquo;s Ast can not express the absolute path which&lt;br/&gt;
  results in a semantics imprecise, another serious implementation&lt;br/&gt;
  defect is that it tries to encode the anti-quote using both two&lt;br/&gt;
  techniques: either explicit &lt;code&gt;Ant&lt;/code&gt; tag or via string mangling, prefix&lt;br/&gt;
  the string with &lt;code&gt;\\$:&lt;/code&gt;, and Camlp4&amp;rsquo;s tag name is totally not&lt;br/&gt;
  meaningful.
&lt;/p&gt;
&lt;p&gt;
  Think a bit further , about syntactic meta-programming, what we&lt;br/&gt;
  really care about is purely syntax, &lt;code&gt;Int &amp;quot;3&amp;quot;= should not be   different whether it is of type =expr&lt;/code&gt; or &lt;code&gt;patt&lt;/code&gt;, if we take a&lt;br/&gt;
  location of ast node, we should not care about whether its type is&lt;br/&gt;
  &lt;code&gt;expr&lt;/code&gt; or &lt;code&gt;patt&lt;/code&gt; or &lt;code&gt;str_item&lt;/code&gt;, right?
&lt;/p&gt;
&lt;p&gt;
  If we compose two ast node using semi syntax &lt;code&gt;;&lt;/code&gt;, we really don&amp;rsquo;t&lt;br/&gt;
  care about whether it&amp;rsquo;s expr node or patt node
&lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#ffa500;font-weight:bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color:#8cd0d3;&quot;&gt;sem&lt;/span&gt;&lt;span style=&quot;color:#dfaf8f;&quot;&gt; a b &lt;/span&gt;&lt;span style=&quot;color:#f0e68c;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#f0e68c;&quot;&gt;{|&lt;/span&gt; &lt;span style=&quot;color:#f0e68c;&quot;&gt;$&lt;/span&gt;a&lt;span style=&quot;color:#f0e68c;&quot;&gt;;&lt;/span&gt; &lt;span style=&quot;color:#f0e68c;&quot;&gt;$&lt;/span&gt;b &lt;span style=&quot;color:#f0e68c;&quot;&gt;|}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
  The code above should work well under already syntax categories as&lt;br/&gt;
  long as it support &lt;code&gt;`Sem&lt;/code&gt; tag.
&lt;/p&gt;
&lt;p&gt;
  Changing the underlying representation of Ast means all existing&lt;br/&gt;
  code in Camlp4 engine can not be reused, since the quotation-kit no&lt;br/&gt;
  longer apply in Fan, but the tough old days are already gone, Fan&lt;br/&gt;
  already managed to provide the whole quotation kit from scratch.  In&lt;br/&gt;
  the next post we will talk about the underly Ast using polymorphic&lt;br/&gt;
  variants in Fan, and argue why it&amp;rsquo;s the right direction.
&lt;/p&gt;
&lt;p&gt;
  Thanks for your reading!(btw, there&amp;rsquo;s a bug in Emacs org/blog, sorry for posting several times)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

</content><id>https://hongboz.wordpress.com/2013/02/05/syntactic-meta-programming-in-ocaml-ii-5/</id><title type="text">Syntactic Meta-Programming in OCaml (II)</title><updated>2013-02-05T19:57:31-00:00</updated><author><name>hongboz</name></author></entry><entry><link href="https://hongboz.wordpress.com/2013/01/31/discussions-on-the-syntactic-meta-programmingwg-camlp4-list/" rel="alternate"/><contributor><uri>https://hongboz.wordpress.com/feed/</uri><name>hongboz</name></contributor><content type="html">&lt;p&gt;There are some interesting discussions in the wg-camlp4 mailing list, I wrote a long mail yesterday, I cleaned it a bit, pasted it here&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;
&lt;div&gt;&amp;nbsp;I rewrite the whole camlP4(named Fan) from scratch, building the quotation kit and throw away the crappy grammar parser, so plz believe me&amp;nbsp;&lt;b&gt;that I do understand the whole technology stack of camlP4&lt;/b&gt;, if we could reach some consensus, I would be happy to handle over the maintaining of &amp;nbsp;Fan, Fan does not loose any feature compared with camlP4, in fact it has more interesting featrues.&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp;Let&amp;rsquo;s begin with some easy, not too technical parts which has a significant effect on user experience though:&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp;1. Performance&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Performance does matter, it&amp;rsquo;s a shame that &amp;nbsp;the most time spent in compiling the ocaml compiler is dedicated to camlP4, but it is an engineering problem, currently compiling Fan only takes less than 20s, and it can be improved further&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp;2. Building issues&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; The design of having side effects by dynamic loading is generically a bad idea, in Fan&lt;b&gt;&amp;nbsp;the dynamic loading only register some functionality the Fan support,&lt;/b&gt;&amp;nbsp;it&amp;nbsp;&lt;b&gt;does not have any other side effec&lt;/b&gt;t, each file stands alone says which (ppx , or filters, or syntax) it want to use with a good default option. so the building is always something like &amp;lsquo;-pp fan pluging1 plugin2 plugin3&amp;rsquo;,&amp;nbsp;&lt;b&gt;the order of pulgings does not matter&lt;/b&gt;, also, l&lt;b&gt;oading all the plugins you have does not have any side effect, even better, you can do the static linking all the plugins you collected, the building process is simplified. &amp;nbsp;&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;&lt;b&gt;&amp;nbsp;&lt;/b&gt;&amp;nbsp;3. Grammar Extension (&lt;b&gt;Language namespace&lt;/b&gt;)&lt;/div&gt;
&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/b&gt;I concur that grammar extension arbitrarily is a bad idea, and I agree with Gabrier that so far only the quotation(Here &amp;nbsp;quotation means delimited DSL, quosi-quotation means Lisp style macros) is modular, composable, and &amp;nbsp;I also agree with Gabrier -ppx&lt;b&gt;&amp;nbsp;should not be used to do syntax overriding (this should not be called syntax extension actually),&amp;nbsp;&lt;/b&gt;that&amp;rsquo;s a terrible idea to do syntax overriding, since the user never understand what&amp;rsquo;s going on underly without reading the Makefile. So here some my suggestion is that some really conevenient syntax extesion, i.e, (let try.. in) should be merged to the built in parser. quotations does not bring too much heavy syntax (imho). In Fan, we proposed the concept of a hierarchical language name space, since once quotation is heavily used, it&amp;rsquo;s really easy to introduce conflict,&amp;nbsp;&lt;b&gt;the language namespace querying is exactly like java package namespace,&lt;/b&gt;&amp;nbsp;you can import, close import to save some typing.&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; Here is a taste&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;{:.Fan.Lang.Meta.expr| a + b |} &amp;mdash;&amp;mdash;&amp;gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;`App (`App ((`Id (`Lid &amp;ldquo;+&amp;rdquo;)), (`Id (`Lid &amp;ldquo;a&amp;rdquo;)))), (`Id (`Lid &amp;ldquo;b&amp;rdquo;)))&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;{:.Fan.Lang.Meta.N.expr| a + b |} &amp;nbsp;&amp;mdash;&amp;ndash;&amp;gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;`App&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; (_loc,&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; (`App&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;(_loc, (`Id (_loc, (`Lid (_loc, &amp;ldquo;+&amp;rdquo;)))),&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;(`Id (_loc, (`Lid (_loc, &amp;ldquo;a&amp;rdquo;)))))),&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; (`Id (_loc, (`Lid (_loc, &amp;ldquo;b&amp;rdquo;)))))&amp;nbsp;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;&amp;nbsp;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;the .Fan.Lang.Meta.expr the first &amp;lsquo;.&amp;rsquo; means it&amp;rsquo;s from the absolute namespace, &amp;nbsp;the&amp;nbsp;&lt;b&gt;N.expr shares exactly the same syntax without location&lt;/b&gt;, though&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp;4. Portable to diffierrent compiler extensions(like LexiFi&amp;rsquo;s fork of ocaml)&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;I am pretty sure it&amp;rsquo;s pretty easy to do in Fan, only Ast2pt (dumping the intemediate Ast into Parsetree) part need to be changed to diffierent compilers.
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/div&gt;
&lt;div&gt;Now let&amp;rsquo;s talk about some internal parts of SMP.&lt;/div&gt;
&lt;div&gt;Quasi-Quotation is the essential part of SMP, &amp;nbsp;I am surprised so far that the discussion&amp;nbsp;&lt;b&gt;silently ignores the quasi-quotation,&lt;/b&gt;&amp;nbsp;Leo&amp;rsquo;s answer of writing &amp;nbsp; three parsers is neither satisfying nor practical(imho).&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;Camlp4 is mainly composed of two parts, one is the extensible parser and&amp;nbsp;&lt;b&gt;the other significant part is Ast Lifting&lt;/b&gt;. Since we all agree that extensible parser increases the complexity too much, let&amp;rsquo;s simply ignore that part.&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;The Ast Lifting are tightly coupled&amp;nbsp;&lt;b&gt;with the design of the Abstract Syntax Tree.&lt;/b&gt;&amp;nbsp; People complain about that Camlp4 Ast is hard to learn and using quasi-quotation to do the pattern match is a bad idea.&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;Let me explain the topic a bit:&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; Camlp4Ast is hard to learn, I agree, it has some alien names that nobody understand what it &amp;nbsp;means, quosi-quotation&amp;nbsp;&lt;b&gt;is definitely a great idea&lt;/b&gt;&amp;nbsp;to boom the meta-programming, but my experience here is&amp;nbsp;&lt;b&gt;for very very small Ast fragment, using the Abstract Syntax Tree directly,&lt;/b&gt;&amp;nbsp;otherwise Quasi-quotation is a life saver to do the meta programming.&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp;Luckily the quotation kit has nothing to do with the parser part, it&amp;rsquo;s simply several functions(I did some simplify a bit) which turns a normal runtime &amp;nbsp;&lt;/div&gt;
&lt;div&gt;value into an Ast node generically,&amp;nbsp;&lt;b&gt;such kind functions are neither easy to write nor easy to read&lt;/b&gt;,&lt;b&gt;the idea case is that it should be generated once for all, and all the data types in normal ocaml&lt;/b&gt;&lt;b&gt;should be derived automatically&lt;/b&gt;(some ADT with functions can not be derived).&amp;nbsp;&lt;b&gt;I bet it&amp;rsquo;s mostly likely a nightmare if we maintain 3 parsers for the ocaml grammar while two other parsers dumping to a meta-level&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp;So, how to make Ast Lifting easier,&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; The first guideline is&amp;nbsp;&lt;b&gt;&amp;ldquo;Don&amp;rsquo;t mixing with records&amp;rdquo;,&amp;nbsp;&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/b&gt;Once you encoding AST with records, you have to encode the records in the meta level which increases the complexity without bringing any new features,&amp;nbsp;&lt;b&gt;it&amp;rsquo;s simply not worthwhile.&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;&lt;b&gt;&amp;nbsp;&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/b&gt;&amp;nbsp;The second guideline is &amp;ldquo;Don&amp;rsquo;t do&amp;nbsp;&lt;b&gt;any&amp;nbsp;&lt;/b&gt;syntax desugaring&amp;rdquo; , syntax desguaring makes the semantics of syntax meta programming a bit weird. Syntax desguaring happens everywhere in Parsetree, think about the list literals, it uses the syntax desuaring, if you don&amp;rsquo;t use any syntax desugaring, for example, you want to match the bigarray access, you simply needed to match `Bigarray(..)&amp;rsquo; instead of&amp;nbsp;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;Pexp_apply&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ({pexp_desc=Pexp_ident&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;{txt= Ldot (Ldot (Lident &amp;ldquo;Bigarray&amp;rdquo;, array), (&amp;ldquo;get&amp;rdquo;|&amp;rdquo;set&amp;rdquo; as gs)) ;_};_},&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;label_exprs)&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;The third guideline is to&lt;b&gt;&amp;nbsp;&lt;/b&gt;make it&amp;nbsp;&lt;b&gt;as uniform as possible&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/b&gt;This not only helps the user, but&amp;nbsp;&lt;b&gt;it helps the meta-programming over types to derive some utility types.&amp;nbsp;&lt;/b&gt;Take a look at my Ast encoding in Fan&amp;nbsp;&lt;a href=&quot;https://github.com/bobzhang/Fan/blob/master/src/Ast.ml&quot; target=&quot;_blank&quot;&gt;https://github.com/bobzhang/Fan/blob/master/src/Ast.ml&lt;/a&gt;&amp;nbsp;(it needs to be polished, plz don&amp;rsquo;t panic when you see variants I use here)&lt;/div&gt;
&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/b&gt;The initial Ast has locations and ant support, but&lt;b&gt;&amp;nbsp;here we derive 3 other Asts thanks to my very regular design&lt;/b&gt;.&lt;b&gt;&amp;nbsp;AstN is the Ast without locations&lt;/b&gt;, the locations are important, but it is simply not too much helpful when you only do the code generation, but it complicates the expanded code a lot),&amp;nbsp;&lt;b&gt;AstA is the Ast without antiquotations(simply remove the ant branch),&amp;nbsp;&lt;/b&gt;it is a subtype of Ast(thanks to the choice we use variants here),&amp;nbsp;&lt;b&gt;AstNA is the Ast without neither locations nor antiquotations&lt;/b&gt;), it is a subtype of AstN. &amp;nbsp;&lt;b&gt;In practice, I found the Ast without locations is particular helpful when you only do the code generation, it simplifies this part significantly.&lt;i&gt;&lt;span style=&quot;text-decoration:underline;&quot;&gt;&amp;nbsp;The beautif&lt;/span&gt;&lt;/i&gt;&lt;/b&gt;&lt;span style=&quot;text-decoration:underline;&quot;&gt;&lt;b&gt;&lt;i&gt;u&lt;/i&gt;&lt;/b&gt;&lt;i&gt;l part is that &amp;nbsp;all the four Ast share the same grammar with the same quosiquotatoin mechanism, as I showed .Fan.Lang.N.expr and .Fan.Lang.expr&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; I don&amp;rsquo;t know how many parsers you have to maintain to reach such a goal or it&amp;rsquo;s never going to happen.&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp; Using variants to encode the intermediate ast has a lots of other benefits, but I don&amp;rsquo;t want to cover it in such a short mail.&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&amp;nbsp; &amp;nbsp;So,&lt;b&gt;&amp;nbsp;my proposal is that the community design an Intermediate Ast together, and write a built-in parser to such Intermediate Ast then dump to Parsetree, but I am for that Parsetree still needs to be cleaned a bit but not too much change . &amp;nbsp;&lt;/b&gt;I do appreciate you can take something away from Fan, I think the Parsetree is&lt;b&gt;&amp;nbsp;not the ideal part&lt;/b&gt;&amp;nbsp;to do SMP, HTH&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content><id>https://hongboz.wordpress.com/2013/01/31/discussions-on-the-syntactic-meta-programmingwg-camlp4-list/</id><title type="text">Discussions on the Syntactic Meta Programming(wg-camlp4 list)</title><updated>2013-01-31T04:47:09-00:00</updated><author><name>hongboz</name></author></entry><entry><link href="https://hongboz.wordpress.com/2013/01/28/random-thoughts-about-syntactic-meta-programming-i/" rel="alternate"/><contributor><uri>https://hongboz.wordpress.com/feed/</uri><name>hongboz</name></contributor><content type="html">
&lt;p&gt;I should write this blog long time ago, but I am so adddicted to &lt;a href=&quot;https://github.com/bobzhang/Fan&quot;&gt;Fan&lt;/a&gt;  that I don&amp;rsquo;t have time to write it, programming is much more fun than blogging. &lt;/p&gt;
&lt;p&gt; Anyway, better late than never, XD. &lt;/p&gt;
&lt;div class=&quot;outline-2&quot;&gt;
&lt;h2&gt;What&amp;rsquo;s syntactic meta programming?&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot;&gt;     &lt;/div&gt;
&lt;div class=&quot;outline-3&quot;&gt;
&lt;h3&gt;What&amp;rsquo;s meta programming?&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot;&gt;
&lt;p&gt;    Meta programming is an interesting but also challenging domain, the    essential idea is that &amp;ldquo;program as data&amp;rdquo;. Wait, you may wonder that    in &lt;a href=&quot;http://en.wikipedia.org/wiki/Von_Neumann_architecture&quot;&gt;Von Neumann architecture&lt;/a&gt;, program is &lt;b&gt;always&lt;/b&gt; data, so to be more    precise, meta programming is kinda &amp;ldquo;program as structured data&amp;rdquo;, the    structured data should be easy to manipulate and generate. Think    about Lisp, since it does not have any concrete syntax, its program    is always &lt;a href=&quot;http://en.wikipedia.org/wiki/S-expression&quot;&gt;S-expression&lt;/a&gt;, a hierachical data structure which is easy    to manipulate and process. &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;outline-3&quot;&gt;
&lt;h3&gt;Meta-program at different layers&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot;&gt;
&lt;p&gt;    When you write a compiler, the program should have different    representations in different stages, think about the ocaml compiler    workflow &lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;Raw String --&amp;gt;  Token Stream --&amp;gt;
Parsetree --&amp;gt; Typedtree --&amp;gt; Lambda --&amp;gt;
ULambda --&amp;gt; C-- --&amp;gt; Mach --&amp;gt; Linear --&amp;gt;
Assembly
&lt;/pre&gt;
&lt;p&gt;    So, at different stages, the program as a structured data can be    processed in different ways. &lt;/p&gt;
&lt;p&gt;    You can insert plugins per level, for example, the c macros mainly    does the token stream transformation, but there is a problem with    the token stream that it is not a structured data. &lt;/p&gt;
&lt;p&gt;    Ther earlier stage you do the transformation, the easier it is to    be mapped to you original source program, the later stage you do    the transformation, the compiler do more program analysis, but it&amp;rsquo;s    harder to map to the original program. So each stage has its use    case. &lt;/p&gt;
&lt;p&gt;    Here we only talk about syntactic meta programming(SMP), where the    layer is in the parsetree or called Abstract Syntax and we only    talk about the host language &lt;a href=&quot;http://caml.inria.fr/&quot;&gt;OCaml&lt;/a&gt; (OCaml is really a great    language, you should have a try!), but some high level design    choices should be applied to other host languages as well. &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;outline-2&quot;&gt;
&lt;h2&gt;The essential part of SMP&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot;&gt;
&lt;p&gt;   I suggest anyone who are interested in SMP should learn &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Lisp&quot;&gt;Common Lisp&lt;/a&gt;,   there are so many brilliant ideas there and forgotten by people   outside the community. And two books are really fun, one is &lt;a href=&quot;http://www.paulgraham.com/onlisp.html&quot;&gt;On Lisp&lt;/a&gt;,   the other is &lt;a href=&quot;http://letoverlambda.com/&quot;&gt;Let Over Lambda&lt;/a&gt; . &lt;/p&gt;
&lt;p&gt;   The essential part of SMP is Quasi-Quotation. There is a nice paper   introduces the benefits of Quasi-Quotation: &lt;a href=&quot;https://hongboz.wordpress.com/feed/#people.csail.mit.edu-alan-ftp-quasiquote-v59.ps.gz&quot;&gt;Quasiquotation in Lisp&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;   Here we only scratch its surface a tiny bit: &amp;ldquo;Quasiquotation is a   &lt;b&gt;parameterized version&lt;/b&gt; of ordinary quotation, where instead of   specifying a value exactly, some &lt;b&gt;holes&lt;/b&gt; are left to be filled in   later. A quasiquotation is a template.&amp;rdquo;, breifly, quasi-quotation   entitiles you the ability to &lt;b&gt;abstraction over code&lt;/b&gt;. &lt;/p&gt;
&lt;p&gt;   As the paper said, a typical use of quasiquotation in a macro   definition looks like &lt;/p&gt;
&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color:#af00ff;&quot;&gt;defmacro&lt;/span&gt; (&lt;span style=&quot;color:#0000ff;&quot;&gt;push&lt;/span&gt; expr var)
 `(set! ,var (cons ,expr ,var)))
&lt;/pre&gt;
&lt;p&gt;   Here the &amp;ldquo;`&amp;rdquo; introduces a quasi-quotaion, and &amp;ldquo;,&amp;rdquo; introduces a   parameter(we also call it anti-quote), there are a number of   languages which supports quasiquotation except the lisp family, but   &lt;b&gt;none&lt;/b&gt; of them are even close to Lisp. &lt;/p&gt;
&lt;p&gt;   One challenging part lies not in quote part, it lies in &lt;b&gt;anti-quote&lt;/b&gt;   part, however. In lisp, you can antiquote &lt;b&gt;everywhere&lt;/b&gt;, suppose you   are writing &lt;code&gt;Template Haskell&lt;/code&gt;, you can write some thing like this &lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;[| import $module |]
&lt;/pre&gt;
&lt;p&gt;   In lisp, it allows very &lt;b&gt;fine-grained&lt;/b&gt; quasi-quote. &lt;/p&gt;
&lt;p&gt;   The other challegning part is &lt;b&gt;nested quosi-quotation&lt;/b&gt;. Since   meta-program itself  is a normal program, when you do meta   programming a lot in Common Lisp, you will find you wrote a lot of   duplicated meta-programs, here nested quasi-quotation came to   rescue. &lt;/p&gt;
&lt;p&gt;   Discussing nested quasi-quotation may goes beyond the scope of the   first blog, but you can have a taste here &lt;/p&gt;
&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color:#af00ff;&quot;&gt;defmacro&lt;/span&gt; (&lt;span style=&quot;color:#0000ff;&quot;&gt;def-caller&lt;/span&gt; abbrev proc)
 `(&lt;span style=&quot;color:#af00ff;&quot;&gt;defmacro&lt;/span&gt; (,abbrev var expr)
    `(,`,proc (&lt;span style=&quot;color:#af00ff;&quot;&gt;lambda&lt;/span&gt; (,var) ,expr))))
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;outline-3&quot;&gt;
&lt;h3&gt;Some defects in Lisp Style Macors&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot;&gt;
&lt;p&gt;    Though I really enjoyed Lisp Macros, to be honest, the S-expression    as concrete syntax to represent a program is not the optimal way to    express ideas. &lt;/p&gt;
&lt;p&gt;    For the extreme flexibility, you have to pay that for each program    you use a sub-optimal concrete syntax. &lt;/p&gt;
&lt;p&gt;    The second problem is that Lisp is a dynamically typed language,    though currently practical type system can help catch only some    trivial errors, but they &lt;b&gt;do help a lot&lt;/b&gt;. &lt;/p&gt;
&lt;p&gt;    For a sufficient smart compiler, like &lt;a href=&quot;http://www.sbcl.org/&quot;&gt;SBCL&lt;/a&gt;, they did type inference    or constraint propgation, and that &lt;b&gt;emits really helpful warnings&lt;/b&gt;,    the type checking may not be that important there, but that depends    on the compiler implementation, some young implementations, like    &lt;a href=&quot;http://clojure.org/&quot;&gt;clojure&lt;/a&gt;, the compiler is not smart enough to help diagnose, yet. &lt;/p&gt;
&lt;p&gt;    The third problem is that Lisp macros ignore &lt;b&gt;locations&lt;/b&gt; totally,    when you process the raw S-expression, no location is kept, in some    domains, code generation, for example, location is not that    important since you only emit a large trunk of code, in other    domains, Ast transformation, location is important to help emit    helpful error messages. Keeping location correct is very tedious    but necessary, IMHO. Some meta programming system, Template    Haskell, ignores locations as well. &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;outline-2&quot;&gt;
&lt;h2&gt;How to do SMP in rich syntax language&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot;&gt;
&lt;p&gt;   Now let&amp;rsquo;s go back to OCaml, the great language XD. &lt;/p&gt;
&lt;p&gt;   It is the same as Lisp, you have to encode the Ast in the host   language, you can encode the ocaml&amp;rsquo;s Ast using S-expression as well. &lt;/p&gt;
&lt;p&gt;   S-expression is a viable option, &lt;a href=&quot;http://felix-lang.org/&quot;&gt;Felix&lt;/a&gt; adopts this mechanism. The   advantage of using S-exprssion to encode the S-expression is that   you can reach &lt;b&gt;the maximum code reuse&lt;/b&gt; and &lt;b&gt;don&amp;rsquo;t need to fight   against the type system&lt;/b&gt; from time to time. &lt;/p&gt;
&lt;p&gt;   For example, in &lt;a href=&quot;http://brion.inria.fr/gallium/index.php/Camlp4&quot;&gt;Camlp4&lt;/a&gt;, once you want to get the location of an Ast   node, you have to fix its type, so if have to write a lot of   bolierpolate code like this &lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#0000ee;font-weight:bold;&quot;&gt;val&lt;/span&gt; &lt;span style=&quot;color:#af5f00;&quot;&gt;loc_of_expr&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#008700;&quot;&gt;expr &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#008700;&quot;&gt; loc&lt;/span&gt;
&lt;span style=&quot;color:#0000ee;font-weight:bold;&quot;&gt;val&lt;/span&gt; &lt;span style=&quot;color:#af5f00;&quot;&gt;loc_of_ctyp&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#008700;&quot;&gt;ctyp &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#008700;&quot;&gt; loc&lt;/span&gt;
&lt;span style=&quot;color:#0000ee;font-weight:bold;&quot;&gt;val&lt;/span&gt; &lt;span style=&quot;color:#af5f00;&quot;&gt;loc_of_patt&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#008700;&quot;&gt;patt &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#008700;&quot;&gt; loc&lt;/span&gt;
&lt;span style=&quot;color:#af0000;&quot;&gt;....&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;   Things turn out to be better with &lt;a href=&quot;http://en.wikipedia.org/wiki/Type_class&quot;&gt;type class&lt;/a&gt; support in Haskell, but   that&amp;rsquo;s another story.  &lt;/p&gt;
&lt;p&gt;   Think about the case you want to use a &lt;b&gt;semi&lt;/b&gt; &lt;code&gt;;&lt;/code&gt; to connect two Ast   node, you have to write things like &lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#0000ee;font-weight:bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;sem&lt;/span&gt;&lt;span style=&quot;color:#af5f00;&quot;&gt; e1 e2 &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;=&lt;/span&gt;
   &lt;span style=&quot;color:#0000ee;font-weight:bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color:#af5f00;&quot;&gt;_loc &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color:#008700;&quot;&gt;Loc&lt;/span&gt;.merge &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;loc_of_expr e1 &lt;span style=&quot;color:#af0000;&quot;&gt;)&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;loc_of_expr e2&lt;span style=&quot;color:#af0000;&quot;&gt;)&lt;/span&gt; &lt;span style=&quot;color:#0000ee;font-weight:bold;&quot;&gt;in&lt;/span&gt;
   Sem&lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;_loc&lt;span style=&quot;color:#af0000;&quot;&gt;,&lt;/span&gt; e1&lt;span style=&quot;color:#af0000;&quot;&gt;,&lt;/span&gt;e2&lt;span style=&quot;color:#af0000;&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;   Everytime you want to fetch the location, you have to &lt;b&gt;fix its   type&lt;/b&gt;,  that&amp;rsquo;s too bad, the API to process the Syntax is &lt;b&gt;too verbose&lt;/b&gt; &lt;/p&gt;
&lt;p&gt;   But using Algebraic Data Type &lt;b&gt;does have some advantages&lt;/b&gt;, the first   is &lt;b&gt;pattern match&lt;/b&gt; (with exhuastive check), the second is type   checking, we do tell some difference between &lt;code&gt;Ast.expr&lt;/code&gt; and   &lt;code&gt;Ast.patt&lt;/code&gt;, and that helps, but you can not tell whether it&amp;rsquo;s an   expresson of type int or type boolean, for example  &lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;Int &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#008700;&quot;&gt;expr&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;)&lt;/span&gt;
&lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;String &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;:&lt;/span&gt;&lt;span style=&quot;color:#008700;&quot;&gt;expr&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;   &lt;a href=&quot;https://hongboz.wordpress.com/feed/#http-www.metaocaml.org&quot;&gt;MetaOCaml&lt;/a&gt; can guarantees the type correctness, but there is always a   trade off between expressivity and type safety. Anyway, in a   staticly typed language, i.e, OCaml, the generated program is always   type checked.  &lt;/p&gt;
&lt;p&gt;   So, in OCaml or other ML dialects , you can encode the Abstract   Syntax using one of those: untyped s-expression, partial typed sum   types, records, GADT, or mixins of records and sum types.   there is another unique solution which exists in OCaml, &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual006.html&quot;&gt;variants&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;   We will discuss it further in the next post. &lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;outline-3&quot;&gt;
&lt;h3&gt;Quasi-quotation in OCaml&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot;&gt;
&lt;p&gt;       Quasi-quotation in lisp is free, since the concrete syntax is    exactly the same as abstract syntax. &lt;/p&gt;
&lt;pre class=&quot;src src-lisp&quot;&gt;(+ a 3 4) &lt;span style=&quot;color:#af0000;&quot;&gt;;; &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;program&lt;/span&gt;

`(+ a 3 4) &lt;span style=&quot;color:#af0000;&quot;&gt;;; &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;data &lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;    There is a paper which summarizes how to do quasi-quotation in rich    syntax language: &lt;a href=&quot;http://ipaper.googlecode.com/git-history/969fbd798753dc0b10ea9efe5af7773ff10f728a/Miscs/why-its-nice-to-be-quoted.pdf&quot;&gt;Why it&amp;rsquo;s nice to be quoted.&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;    Unlike Lisp, the different between program and data is obvious &lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;3 &lt;span style=&quot;color:#af0000;&quot;&gt;(* &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;program &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;*)&lt;/span&gt;
`Int &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;_loc&lt;span style=&quot;color:#af0000;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;)&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(* &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;data &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;*)&lt;/span&gt;

&lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(* &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;program &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;*)&lt;/span&gt;
`String &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;_loc&lt;span style=&quot;color:#af0000;&quot;&gt;,&lt;/span&gt; &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;)&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(* &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;data &lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;*)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;    (Here we use a qutoe &amp;ldquo;`&amp;rdquo; to denote that it&amp;rsquo;s an Ast ) &lt;/p&gt;
&lt;p&gt;    Let&amp;rsquo;s take a look at the parsing phase (for simplicity, we ignore    the locations). &lt;/p&gt;
&lt;p&gt;    When you do the parsing, the normal behavior  is as follows: &lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt; &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;3 + 4&amp;quot;&lt;/span&gt;
 &lt;span style=&quot;color:#af0000;&quot;&gt;==&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#af00ff;&quot;&gt;to&lt;/span&gt; the Ast 
`App &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`App &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`Id &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`Lid &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;)),&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`Int &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;))),&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`Int &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;4&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;    But to do the quasi-quotation, you need to turn the Ast itself into    data, so you need to encode the Ast using the Ast itself &lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;3+4&amp;quot;&lt;/span&gt;
&lt;span style=&quot;color:#af0000;&quot;&gt;==&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#af00ff;&quot;&gt;to&lt;/span&gt; the Ast
`App &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`App &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`Id &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`Lid &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;)),&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`Int &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;))),&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`Int &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;4&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;))&lt;/span&gt;

&lt;span style=&quot;color:#af0000;&quot;&gt;==&amp;gt;&lt;/span&gt; &lt;span style=&quot;color:#af00ff;&quot;&gt;to&lt;/span&gt; the Data
`App
 &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`App
     &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`Vrn &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;App&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;),&lt;/span&gt;
       &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`App
          &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`App
              &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`Vrn &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;App&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;),&lt;/span&gt;
                &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`App &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`Vrn &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;Id&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;),&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`App &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`Vrn &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;Lid&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;),&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`Str &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;))))))),&lt;/span&gt;
            &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`App &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`Vrn &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;Int&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;),&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`Str &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;))))))),&lt;/span&gt;
   &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`App &lt;span style=&quot;color:#af0000;&quot;&gt;((&lt;/span&gt;`Vrn &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;Int&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;),&lt;/span&gt; &lt;span style=&quot;color:#af0000;&quot;&gt;(&lt;/span&gt;`Str &lt;span style=&quot;color:#87005f;&quot;&gt;&amp;quot;4&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;))))&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;    So, to do it once for all, we needs      a function (for simplicty) &lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#0000ee;font-weight:bold;&quot;&gt;val&lt;/span&gt; &lt;span style=&quot;color:#af5f00;&quot;&gt;meta_expr&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#008700;&quot;&gt;expr&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;^&lt;/span&gt;0 &lt;span style=&quot;color:#af0000;&quot;&gt;-&amp;gt;&lt;/span&gt; expr&lt;span style=&quot;color:#af0000;&quot;&gt;^&lt;/span&gt;1 
&lt;/pre&gt;
&lt;p&gt;    Luckily since &lt;code&gt;expr^1&lt;/code&gt; is a subset of &lt;code&gt;expr^0&lt;/code&gt;, so you get the    belowing function for free &lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color:#0000ee;font-weight:bold;&quot;&gt;val&lt;/span&gt; &lt;span style=&quot;color:#af5f00;&quot;&gt;meta_expr&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color:#008700;&quot;&gt;expr&lt;/span&gt;&lt;span style=&quot;color:#af0000;&quot;&gt;^&lt;/span&gt;1 &lt;span style=&quot;color:#af0000;&quot;&gt;-&amp;gt;&lt;/span&gt; expr&lt;span style=&quot;color:#af0000;&quot;&gt;^&lt;/span&gt;2 
&lt;/pre&gt;
&lt;p&gt;    Actually you may find that the category &lt;code&gt;expr^2&lt;/code&gt; is exactly the    same as &lt;code&gt;expr^1&lt;/code&gt;, so once you have &lt;code&gt;expr^0 -&amp;gt; expr^1&lt;/code&gt;, you have    &lt;code&gt;expr^0 -&amp;gt; expr^n&lt;/code&gt;. (antiquotation will be discussed later). &lt;/p&gt;
&lt;p&gt;    So the problem only lies into how to write the function    &lt;code&gt;expr^0-&amp;gt;expr^1&lt;/code&gt;,  you need to encode the Ast using the Ast itself,    this requires that the Ast should be expressive enough to express    itself. This is alwasy not true, suppose you use the &lt;a href=&quot;http://en.wikipedia.org/wiki/Higher-order_abstract_syntax&quot;&gt;HOAS&lt;/a&gt;, HOAS is    not expressive enough to express itself. &lt;/p&gt;
&lt;p&gt;    If you mixin the records with sum types, you have to express both    records and sum types, the Ast lifting is &lt;b&gt;neither easy to write&lt;/b&gt;,    &lt;b&gt;nor easy to read&lt;/b&gt;, with locations, it becomes even more cmoplex,    the best case is to &lt;b&gt;do it automatically and once for all&lt;/b&gt;. &lt;/p&gt;
&lt;p&gt;    Suppose you only use sum types, luckily we might find that only    &lt;b&gt;five tags&lt;/b&gt; are expressive enough to express this function &lt;code&gt;expr^0    -&amp;gt; expr^1&lt;/code&gt;, here are &lt;b&gt;five tags&lt;/b&gt; &lt;/p&gt;
&lt;pre class=&quot;src src-ocaml&quot;&gt;App Vrn Str Tup Com
&lt;/pre&gt;
&lt;p&gt;    Here &lt;code&gt;Tup&lt;/code&gt; means &amp;ldquo;tuple&amp;rdquo;, and &lt;code&gt;Com&lt;/code&gt; means &amp;ldquo;Comma&amp;rdquo;. &lt;/p&gt;
&lt;p&gt;       The minimal, the better, this means as long as the changes to the    Abstract Syntax Tree does not involves the &lt;b&gt;five tags&lt;/b&gt;, it will    always work out of the box. &lt;/p&gt;
&lt;p&gt;    So, to design the right Ast for meta programming, the first thing    is to &lt;b&gt;keep it simple&lt;/b&gt;, don&amp;rsquo;t use &lt;b&gt;Records&lt;/b&gt; or other complex data    types , Sum types or polymorphic variants are rich enough to    express the who syntax of ocaml but itself is very simple to do the    Ast Lifting. &lt;/p&gt;
&lt;p&gt;    In the next blog, we may discuss tThe right way to design an    Abstract Syntax Tree for SMP. &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><id>https://hongboz.wordpress.com/2013/01/28/random-thoughts-about-syntactic-meta-programming-i/</id><title type="text">Random thoughts about Syntactic Meta Programming (I)</title><updated>2013-01-28T05:00:00-00:00</updated><author><name>hongboz</name></author></entry><entry><link href="https://hongboz.wordpress.com/2012/11/13/fan-a-langugage-to-implement-languages-i/" rel="alternate"/><contributor><uri>https://hongboz.wordpress.com/feed/</uri><name>hongboz</name></contributor><content type="html">
&lt;p&gt;This will be a series of blogs introducing a new programming language &lt;a href=&quot;https://github.com/bobzhang/Fan&quot;&gt;Fan&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt; Fan is OCamlPlus, it provides all features what &lt;a href=&quot;http://caml.inria.fr/&quot;&gt;OCaml&lt;/a&gt; provides and a language to manipulate programs. I am also &lt;b&gt;seeking collaboration&lt;/b&gt; if you are interested in such a fascinating project. &lt;/p&gt;
&lt;p&gt; It aims to provide the &lt;code&gt;OCaml + A Compiler Domain Specific Language&lt;/code&gt;. The compiler domain is a bit special, it&amp;rsquo;s the compiler domain which can be used by users to create their own domain specific languages, e.g, database query, financial modelling. Our purpose is to make you write a practical compiler &lt;code&gt;in one day&lt;/code&gt;, yes, this is not a joke, with the right tools and nice abstraction, it&amp;rsquo;s very promising to help average programmers to create their own languages to fit their domains in a short term. &lt;/p&gt;
&lt;p&gt; The compiler domain is a rather large domain, it consists of several sub-domains, so the compiler of Fan itself also benefits from the Domain specific language(DSL). Unlike other bootstrapping model, &lt;b&gt;all features&lt;/b&gt; of the previous version of Fan compiler is &lt;b&gt;usable&lt;/b&gt; for the next release. Yes, Fan is written using itself, it&amp;rsquo;s really Fun &lt;img src=&quot;https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/72x72/1f642.png&quot; alt=&quot;&amp;#128578;&quot; class=&quot;wp-smiley&quot; style=&quot;height: 1em; max-height: 1em;&quot;/&gt; &lt;/p&gt;
&lt;p&gt; Fan evolved from the &lt;a href=&quot;http://brion.inria.fr/gallium/index.php/Camlp4&quot;&gt;Camlp4&lt;/a&gt;, but with a more ambitious goal and different underlying engines, I will compare them later. &lt;/p&gt;
&lt;p&gt; Ok, let&amp;rsquo;s talk business. &lt;/p&gt;
&lt;p&gt; Why a new programming language? Because I don&amp;rsquo;t find a programming language make me happy (yet). &lt;/p&gt;
&lt;p&gt; Thinking about how you solve a problem. &lt;/p&gt;
&lt;p&gt; It&amp;rsquo;s mainly divided into two steps. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first step is to think of an algorithm to tackle the problem,   without ambiguity. This is what we call &lt;b&gt;inherent complexity&lt;/b&gt;,   however fancy the programming language it is, you still have to think   of a way to solve it.  &lt;/li&gt;
&lt;li&gt;The second step is to map your algorithm into your favourite   language, i.e, Haskell. Ideally, it should be straightforward, but   in reality, it will bring a lot of trouble, and we call it   &lt;b&gt;accidental complexity&lt;/b&gt;. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;   What we can do to enhance a programmer&amp;rsquo;s productivity lies in how to avoid the &lt;b&gt;accidental complexity&lt;/b&gt;, the second step. &lt;/p&gt;
&lt;p&gt; The problem lies that your favourite language was not designed for your specific domain, it&amp;rsquo;s a &lt;b&gt;general&lt;/b&gt; purpose programming language. When you transfer your ideas into your language, you have to do &lt;code&gt;a lot of dirty work&lt;/code&gt;. With the help of modern IDE, people may be alleviated a bit, but programs are not just written to execute, its more functional goal is to help exchange ideas. When you want to understand how a piece of program work, you have to do the &lt;code&gt;reverse-engineering&lt;/code&gt; to map your programs back into your ideas. Because when you do the translation from your ideas into your programs, you will lose the big picture, the initial brief ideas are mixed with a lot of noises. &lt;/p&gt;
&lt;p&gt; This is a sad fact that how programmers do the work nowadays. &lt;img src=&quot;https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/72x72/1f626.png&quot; alt=&quot;&amp;#128550;&quot; class=&quot;wp-smiley&quot; style=&quot;height: 1em; max-height: 1em;&quot;/&gt; &lt;/p&gt;
&lt;p&gt; &amp;ldquo;When you have a hammer, everything is a nail&amp;rdquo;. &lt;/p&gt;
&lt;p&gt; One difference between human being and animals is the fact that man can use tools, the fact that man can not only use tools but also create tools makes human-beings so intelligent. It&amp;rsquo;s a sad fact that most programmers still live in the cave-age, they can only accept what tools provided. Smart programmers should create a tool which is best fit for their domain. &lt;/p&gt;
&lt;p&gt; So, what&amp;rsquo;s the right way to solve a problem? &lt;/p&gt;
&lt;p&gt; When you find some similar problems appear once and again, try to design your language which makes you can express your ideas &lt;b&gt;as isomorphic as possible&lt;/b&gt; to the problem&amp;rsquo;s descriptions, then write a compiler to compile the language. Then it&amp;rsquo;s done. People who read your program will understand it straight-forward, you write your programs quickly, everything seems to be perfect, everyone is happy. &lt;/p&gt;
&lt;p&gt; Wait, you may find that I am cheating, writing a toy-language is not hard, writing a medium language is painful, creating a general purpose language is too hard, and communicating your legacy library with your new language will drive you crazy. So you may say:&amp;rdquo;let&amp;rsquo;s forget about it&amp;rdquo; and shy away. &lt;/p&gt;
&lt;p&gt; Yes, that&amp;rsquo;s true, and that&amp;rsquo;s why I design a new programming language to address such an issue, remember that creating a language itself &lt;b&gt;is a domain&lt;/b&gt;, this domain shares some similar abstractions which should be factored out. And to make life happier, you are extending a general purpose programming language to fit your domain instead of creating a brand new language, and they are compiled into &lt;b&gt;the same intermediate representation&lt;/b&gt;, like C# and VB, you never have an inter-operation problem. &lt;/p&gt;
&lt;p&gt; Once you finished the language for one domain, your productivity will be boosted exponentially in such a domain. &lt;/p&gt;
&lt;p&gt; Fan is created to help you achieve such a goal! &lt;/p&gt;
&lt;p&gt; There are different abstraction and DSL solutions, next post I will compare them and talk about the solution Fan chooses and its good and bad effects. &lt;/p&gt;
</content><id>https://hongboz.wordpress.com/2012/11/13/fan-a-langugage-to-implement-languages-i/</id><title type="text">Fan, A langugage to implement languages (I)</title><updated>2012-11-13T05:00:00-00:00</updated><author><name>hongboz</name></author></entry></feed>