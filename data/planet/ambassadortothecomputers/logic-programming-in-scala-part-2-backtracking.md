---
title: 'Logic programming in Scala, part 2: backtracking'
description: "In the previous post  we saw how to write computations in a logic monad,
  where a \u201Cvalue\u201D is a choice among alternatives, and operating on a ..."
url: http://ambassadortothecomputers.blogspot.com/2011/04/logic-programming-in-scala-part-2.html
date: 2011-04-30T05:07:00-00:00
preview_image:
featured:
authors:
- ambassadortothecomputers
---

<p>In the <a href="http://ambassadortothecomputers.blogspot.com/2011/04/logic-programming-in-scala-part-1.html">previous post</a> we saw how to write computations in a logic monad, where a &ldquo;value&rdquo; is a choice among alternatives, and operating on a value means operating on all the alternatives.</p> 
 
<p>Our first implementation of the logic monad represents a choice among alternatives as a list, and operating on a value means running the operation for each alternative immediately (to produce a new list of alternatives). If we imagine alternatives as leaves of a tree (with <code>|</code> indicating branching), the first implementation explores the tree breadth-first.</p> 
 
<p>This is OK for some problems, but we run into trouble when there are a large or infinite number of alternatives. For example, a choice among the natural numbers:</p> 
<div class="highlight"><pre><code class="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">LogicList._</span> 
<span class="k">import</span> <span class="nn">LogicList._</span> 
 
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nat</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">unit</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">|</span> <span class="n">nat</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> 
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">NullPointerException</span> 
        <span class="o">...</span> 
</code></pre> 
</div> 
<p>This goes wrong because even though the right-hand argument to <code>|</code> is by-name, we immediately try to use it, and fail because <code>nat</code> is not yet defined.</p> 
<div class="highlight"><pre><code class="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">nat</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">unit</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">|</span> <span class="n">nat</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> 
<span class="n">nat</span><span class="k">:</span> <span class="kt">LogicList.T</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> 
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">nat</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span> 
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">StackOverflowError</span> 
        <span class="o">...</span> 
</code></pre> 
</div> 
<p>With <code>def</code> we can successfully define <code>nat</code>, because the right-hand side isn&rsquo;t evaluated until <code>nat</code> is used in the call to <code>run</code>, but we overflow the stack trying to compute all the natural numbers.</p> 
 
<p>Let&rsquo;s repair this with a fancier implementation of the logic monad, translated from Kiselyov et al.&rsquo;s <a href="http://okmij.org/ftp/Computation/LogicT.pdf">Backtracking, Interleaving, and Terminating Monad Transformers</a>. This implementation will explore the tree depth-first.</p> 
<b>Success and failure continuations</b> 
<p>The idea is to represent a choice of alternatives by a function, which takes as arguments two functions: a <em>success continuation</em> and a <em>failure continuation</em>. The success continuation is just a function indicating what to do next with each alternative; the failure continuation is what to do next when there are no more alternatives.</p> 
 
<p>For success, what we do next is either return the alternative (when we have reached a leaf of the tree), or perform some operation on it (possibly forming new branches rooted at the alternative). For failure, what we do next is back up to the last branch point and succeed with the next alternative. If there are no more alternatives at the previous branch point we back up again, and so on until we can succeed or finally run out of alternatives. In other words, we do depth-first search on the tree, except that the tree isn&rsquo;t a materialized data structure&mdash;it&rsquo;s created on the fly.</p> 
 
<p>(In the jargon of logic programming, a branch point is called a &ldquo;choice point&rdquo;, and going back to an earlier choice point is called &ldquo;backtracking&rdquo;.)</p> 
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">LogicSFK</span> <span class="k">extends</span> <span class="nc">Logic</span> <span class="o">{</span> 
  <span class="k">type</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">R</span> 
  <span class="k">type</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="nc">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">R</span> 
 
  <span class="k">trait</span> <span class="nc">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span><span class="k">:</span> <span class="kt">R</span> <span class="o">}</span> 
</code></pre> 
</div> 
<p>The continuations can return a result of some arbitrary type <code>R</code>. This means that the function representing a choice has a &ldquo;rank-2&rdquo; polymorphic type&mdash;it takes functions which are themselves polymorphic&mdash;which is not directly representable in Scala. But we can encode it by making the representation function a method on a trait.</p> 
 
<p>The success continuation takes a value of the underlying type (i.e. an alternative), and also a failure continuation, to call in case this branch of the tree eventually fails (by calling <code>fail</code>, or <code>filter</code> when no alternative satisfies the predicate). The failure continuation is also called to succeed with the next alternative after returning a leaf (see <code>split</code>).</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">fail</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
      <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">=</span> <span class="n">fk</span><span class="o">()</span> 
    <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
      <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">=</span> <span class="n">sk</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> 
    <span class="o">}</span> 
</code></pre> 
</div> 
<p>To fail, just call the failure continuation. To succeed with one alternative, call the success continuation with the single alternative and the passed-in failure continuation&mdash;there are no more alternatives to try, so if this branch fails the <code>unit</code> fails.</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">or</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t1</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">t2</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
      <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">=</span> 
        <span class="n">t1</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="o">{</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">t2</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="o">})</span> 
    <span class="o">}</span> 
</code></pre> 
</div> 
<p><code>Or</code> creates a choice point. We want to explore the alternatives in both <code>t1</code> and <code>t2</code>, so we pass the success continuation to <code>t1</code> (which calls it on each alternative); when <code>t1</code> is exhausted we pass the success continuation to <code>t2</code>; finally we fail with the caller&rsquo;s failure continuation&mdash;that is, we backtrack.</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span> 
      <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">B</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">=</span> 
        <span class="n">t</span><span class="o">(({</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="o">}</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">]),</span> <span class="n">fk</span><span class="o">)</span> 
    <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span> 
      <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">B</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">=</span> 
        <span class="n">t</span><span class="o">(({</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sk</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">fk</span><span class="o">)</span> <span class="o">}</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">]),</span> <span class="n">fk</span><span class="o">)</span> 
    <span class="o">}</span> 
</code></pre> 
</div> 
<p>For <code>bind</code> we extend each branch by calling <code>f</code> on the current leaf. To succeed we call <code>f</code> on the alternative <code>a</code>. Now <code>f(a)</code> returns a choice of alternatives, so we pass it the original success continuation (which says what to do next with alternatives resulting from the <code>bind</code>), and the failure continuation in force at the point <code>a</code> was generated (which succeeds with the next available alternative from <code>f(a)</code>).</p> 
 
<p>For <code>apply</code> things are simpler, since <code>f(a)</code> returns a single value rather than a choice of alternatives: we succeed immediately with the returned value.</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">filter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
      <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span> 
        <span class="k">val</span> <span class="n">sk2</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">]</span> <span class="k">=</span> 
          <span class="o">{</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="n">sk</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="k">else</span> <span class="n">fk</span><span class="o">()</span> <span class="o">}</span> 
        <span class="n">t</span><span class="o">(</span><span class="n">sk2</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> 
      <span class="o">}</span> 
    <span class="o">}</span> 
</code></pre> 
</div> 
<p>To filter a choice of alternatives, each time we succeed with a value we see if it satisfies the predicate <code>p</code>; if it does, we succeed with that value (extending the branch), otherwise we fail (pruning the branch).</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">split</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span> 
    <span class="k">def</span> <span class="n">unsplit</span><span class="o">(</span><span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])]])</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
      <span class="n">fk</span><span class="o">()</span> <span class="k">match</span> <span class="o">{</span> 
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">fail</span> 
        <span class="k">case</span> <span class="nc">Some</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">or</span><span class="o">(</span><span class="n">unit</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">t</span><span class="o">)</span> 
      <span class="o">}</span> 
    <span class="k">def</span> <span class="n">sk</span> <span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])]]</span> <span class="k">=</span> 
      <span class="o">{</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">bind</span><span class="o">(</span><span class="n">unit</span><span class="o">(</span><span class="n">fk</span><span class="o">),</span> <span class="n">unsplit</span><span class="o">)))</span> <span class="o">}</span> 
    <span class="n">t</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="o">{</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">None</span> <span class="o">})</span> 
  <span class="o">}</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p>The point of <code>split</code> is to pull a single alternative from a choice, returning along with it a choice of the remaining alternatives. In the list implementation we just returned the head and tail of the list. In this implementation, the alternatives are computed on demand; we want to be careful to do only as much computation as needed to pull the first alternative</p> 
 
<p>The failure continuation we pass to <code>t</code> just returns <code>None</code> when there are no more alternatives. The success continuation <code>sk</code> returns the first alternative and a choice of the remaining alternatives (wrapped in <code>Some</code>).</p> 
 
<p>The tricky part is the choice of remaining alternatives. We&rsquo;re given the failure continuation <code>fk</code>; calling it calls <code>sk</code> on the next alternative, which ultimately returns <code>Some(a, t)</code> where <code>a</code> is the next alternative, or <code>None</code> if there are no more alternatives. We repackage this <code>Option</code> as a choice of alternatives with <code>unsplit</code>. So that we don&rsquo;t call <code>fk</code> too soon, we call <code>unsplit</code> via <code>bind</code>, which defers the call until the resulting choice of alternatives is actually used.</p> 
 
<p>Now we can write infinite choices:</p> 
<div class="highlight"><pre><code class="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">LogicSFK._</span> 
<span class="k">import</span> <span class="nn">LogicSFK._</span> 
 
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nat</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">unit</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">|</span> <span class="n">nat</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> 
<span class="n">nat</span><span class="k">:</span> <span class="kt">LogicSFK.T</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">LogicSFK$$anon$3</span><span class="o">@</span><span class="mi">27</span><span class="n">aea0c1</span> 
 
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">nat</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span> 
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span> 
</code></pre> 
</div> 
<p>Well, this is a pretty complicated way to generate the natural numbers up to 10&hellip;</p> 
 
<p>While <code>nat</code> looks like a lazy stream (as you might write in Haskell), no results are memoized (as they are in Haskell). To compute each successive number all the previous ones must be recomputed, and the running time of <code>run(nat, N)</code> is O(N<sup>2</sup>).</p> 
<b>Defunctionalization</b> 
<p>The code above is a fairly direct translation of the Haskell code from the paper. But its use of continuation-passing style doesn&rsquo;t map well to Scala, because Scala doesn&rsquo;t implement tail-call elimination (because the JVM doesn&rsquo;t). Every call to a success or failure continuation adds a frame to the stack, even though all we ever do with the result is return it (i.e. the call is in <em>tail-position</em>), so the stack frame could be eliminated.</p> 
 
<p>Surprisingly, we run out of memory before we run out of stack:</p> 
<div class="highlight"><pre><code class="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">nat</span><span class="o">,</span> <span class="mi">2000</span><span class="o">)</span> 
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">OutOfMemoryError</span><span class="k">:</span> <span class="kt">Java</span> <span class="kt">heap</span> <span class="kt">space</span> 
 <span class="o">...</span> 
</code></pre> 
</div> 
<p>A little heap profiling shows that we&rsquo;re using quadratic space as well as quadratic time. It turns out that the implementation of <code>Logic.run</code> (from the previous post) has a space leak. The call to <code>run</code> is not tail-recursive, so the stack frame hangs around, and although <code>t</code> is dead after <code>split(t)</code>, there&rsquo;s still a reference to it on the stack.</p> 
 
<p>We can rewrite <code>run</code> with an accumulator to be tail-recursive:</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> 
    <span class="k">def</span> <span class="n">runAcc</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">acc</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">acc</span><span class="o">.</span><span class="n">reverse</span> <span class="k">else</span> 
        <span class="n">split</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span> 
          <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">acc</span><span class="o">.</span><span class="n">reverse</span> 
          <span class="k">case</span> <span class="nc">Some</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">runAcc</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">a</span> <span class="o">::</span> <span class="n">acc</span><span class="o">)</span> 
        <span class="o">}</span> 
    <span class="n">runAcc</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> 
  <span class="o">}</span> 
</code></pre> 
</div> 
<p>Now <code>scalac</code> compiles <code>runAcc</code> as a loop, so there are no stack frames holding on to dead values of <code>t</code>, and we get the expected:</p> 
<div class="highlight"><pre><code class="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">nat</span><span class="o">,</span> <span class="mi">9000</span><span class="o">)</span> 
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">StackOverflowError</span> 
 <span class="o">...</span> 
</code></pre> 
</div> 
<p>To address the stack overflow we turn to <em>defunctionalization</em>. The idea (from John Reynold&rsquo;s classic paper <a href="http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.110.5892&amp;rep=rep1&amp;type=pdf">Definitional Interpreters for Higher-Order Programming Languages</a>) is to replace functions and their applications with data constructors (we&rsquo;ll use case classes) and an <code>apply</code> function, which matches the data constructor and does whatever the corresponding function body does. If a function captures variables, the data constructor must capture the same variables.</p> 
 
<p>After defunctionalization we&rsquo;re left with three mutually recursive <code>apply</code> functions (one for each of <code>T</code>, <code>FK</code>, and <code>SK</code>) where each recursive call is in tail position. In theory the compiler could transform these into code that takes only constant stack space (since they are local functions private to <code>split</code>). But in fact it will do so only for single recursive functions, so we will need to do this transformation by hand.</p> 
 
<p>There is one hitch: the original code is not completely tail-recursive, because of <code>unsplit</code>, which calls a failure continuation then matches on the result. To fix this we need to add yet another continuation, which represents what to do after returning a result from a success or failure continuation.</p> 
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">LogicSFKDefunc</span> <span class="k">extends</span> <span class="nc">Logic</span> <span class="o">{</span> 
  <span class="k">type</span> <span class="kt">O</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])]</span> 
 
  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> 
  <span class="nc">case</span> <span class="k">class</span> <span class="nc">Fail</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Unit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Or</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t1</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">t2</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Bind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="n">T</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Apply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">extends</span> <span class="n">T</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Filter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Unsplit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">O</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="k">extends</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> 
 
  <span class="k">def</span> <span class="n">fail</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fail</span><span class="o">()</span> 
  <span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Unit</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> 
  <span class="k">def</span> <span class="n">or</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t1</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">t2</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Or</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="o">{</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">t2</span> <span class="o">})</span> 
  <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Bind</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> 
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Apply</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> 
  <span class="k">def</span> <span class="n">filter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Filter</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> 
</code></pre> 
</div> 
<p>A choice of alternatives <code>T[A]</code> is now represented symbolically by case classes, and the functions which operate on choices just return the corresponding case. The cases capture the same variables that were captured in the original functions.</p> 
 
<p>We have an additional case <code>Unsplit</code> which represents the <code>bind(unit(fk), unsplit)</code> combination from <code>split</code>. And we use <code>O[A]</code> as a convenient abbreviation.</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span> 
  <span class="nc">case</span> <span class="k">class</span> <span class="nc">FKOr</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> 
    <span class="k">extends</span> <span class="nc">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">FKSplit</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">R</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span> 
 
  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">]</span> 
  <span class="nc">case</span> <span class="k">class</span> <span class="nc">SKBind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">R</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">B</span>,<span class="kt">R</span><span class="o">])</span> 
    <span class="k">extends</span> <span class="nc">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">SKApply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">R</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">B</span>,<span class="kt">R</span><span class="o">])</span> 
    <span class="k">extends</span> <span class="nc">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">SKFilter</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">])</span> 
    <span class="k">extends</span> <span class="nc">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">SKSplit</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">R</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">]</span> 
 
  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">K</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R2</span><span class="o">]</span> 
  <span class="nc">case</span> <span class="k">class</span> <span class="nc">KReturn</span><span class="o">[</span><span class="kt">R</span><span class="o">]()</span> <span class="k">extends</span> <span class="n">K</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R</span><span class="o">]</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">KUnsplit</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span>,<span class="kt">R2</span><span class="o">](</span><span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span><span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">],</span> <span class="n">k</span><span class="k">:</span> <span class="kt">K</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R2</span><span class="o">])</span> 
    <span class="k">extends</span> <span class="n">K</span><span class="o">[</span><span class="kt">O</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>,<span class="kt">R2</span><span class="o">]</span> 
</code></pre> 
</div> 
<p>Each case for <code>FK</code> (respectively <code>SK</code>) corresponds to a success (respectively failure) continuation function in the original code&mdash;it&rsquo;s easy to match them up.</p> 
 
<p>The <code>K</code> cases are for the new return continuation. They are defunctionalized from functions <code>R =&gt; R2</code>; we can either return a value directly, or match on whether it is <code>Some</code> or <code>None</code> as in <code>unsplit</code>. (If <code>K</code> is hard to understand you might try &ldquo;refunctionalizing&rdquo; it by replacing the cases with functions.)</p> 
 
<p>We see that case classes are more powerful than variants in OCaml, without <a href="https://sites.google.com/site/ocamlgadt/">GADTs</a> at least. Cases can have &ldquo;input&rdquo; type variables (appearing in arguments) which do not appear in the &ldquo;output&rdquo; (the type the case extends). When we match on the case these are treated as existentials. And the output type of a case can be more restrictive than type it extends; when we match on the case we can make more restrictive assumptions about types in that branch of the match. More on this in Emir, Odersky, and Williams&rsquo; <a href="http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5295&amp;rep=rep1&amp;type=pdf">Matching Objects with Patterns</a>.</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">split</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span> 
 
    <span class="k">def</span> <span class="n">applyT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span>,<span class="kt">R2</span><span class="o">]</span> 
      <span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">],</span> <span class="n">k</span><span class="k">:</span> <span class="kt">K</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R2</span><span class="o">])</span><span class="k">:</span> <span class="kt">R2</span> <span class="o">=</span> 
      <span class="n">t</span> <span class="k">match</span> <span class="o">{</span> 
        <span class="k">case</span> <span class="nc">Fail</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">applyFK</span><span class="o">(</span><span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">case</span> <span class="nc">Unit</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applySK</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">case</span> <span class="nc">Or</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applyT</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">sk</span><span class="o">,</span> <span class="nc">FKOr</span><span class="o">(</span><span class="n">t2</span><span class="o">,</span> <span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">),</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">case</span> <span class="nc">Bind</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applyT</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="nc">SKBind</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">sk</span><span class="o">),</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">case</span> <span class="nc">Apply</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applyT</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="nc">SKApply</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">sk</span><span class="o">),</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">case</span> <span class="nc">Filter</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applyT</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="nc">SKFilter</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">sk</span><span class="o">),</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">case</span> <span class="nc">Unsplit</span><span class="o">(</span><span class="n">fk2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applyFK</span><span class="o">(</span><span class="n">fk2</span><span class="o">,</span> <span class="nc">KUnsplit</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> 
      <span class="o">}</span> 
 
    <span class="k">def</span> <span class="n">applyFK</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R2</span><span class="o">](</span><span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">],</span> <span class="n">k</span><span class="k">:</span> <span class="kt">K</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R2</span><span class="o">])</span><span class="k">:</span> <span class="kt">R2</span> <span class="o">=</span> 
      <span class="n">fk</span> <span class="k">match</span> <span class="o">{</span> 
        <span class="k">case</span> <span class="nc">FKOr</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applyT</span><span class="o">(</span><span class="n">t</span><span class="o">(),</span> <span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">case</span> <span class="nc">FKSplit</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applyK</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> 
      <span class="o">}</span> 
 
    <span class="k">def</span> <span class="n">applySK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span>,<span class="kt">R2</span><span class="o">]</span> 
      <span class="o">(</span><span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">],</span> <span class="n">k</span><span class="k">:</span> <span class="kt">K</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R2</span><span class="o">])</span><span class="k">:</span> <span class="kt">R2</span> <span class="o">=</span> 
      <span class="n">sk</span> <span class="k">match</span> <span class="o">{</span> 
        <span class="k">case</span> <span class="nc">SKBind</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">sk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applyT</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">case</span> <span class="nc">SKApply</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">sk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applySK</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">case</span> <span class="nc">SKFilter</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">sk</span><span class="o">)</span> <span class="k">=&gt;</span> 
          <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="n">applySK</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="k">else</span> <span class="n">applyFK</span><span class="o">(</span><span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">case</span> <span class="nc">SKSplit</span><span class="o">(</span><span class="n">rf</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">applyK</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">rf</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">))</span> 
      <span class="o">}</span> 
</code></pre> 
</div> 
<p>Again, each of these cases corresponds directly to a function in the original code, and again it is easy to match them up (modulo the extra return continuation argument) to see that all we have done is separated the data part of the function (i.e. the captured variables) from the code part.</p> 
 
<p>The exception is <code>Unsplit</code>, which again corresponds to <code>bind(unit(fk),
unsplit)</code>. To apply it, we apply <code>fk</code> (which collapses <code>unit(fk)</code>, <code>bind</code>, and the application of <code>fk</code> in <code>unsplit</code>) with <code>KUnsplit</code> as continuation, capturing <code>sk</code>, <code>fk</code>, and <code>k</code> (corresponding to their capture in the success continuation of <code>bind</code>).</p> 
<div class="highlight"><pre><code class="scala">    <span class="k">def</span> <span class="n">applyK</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R2</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="kt">K</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R2</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R2</span> <span class="o">=</span> 
      <span class="n">k</span> <span class="k">match</span> <span class="o">{</span> 
        <span class="k">case</span> <span class="nc">KReturn</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">R2</span><span class="o">]</span> 
        <span class="k">case</span> <span class="nc">KUnsplit</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> 
          <span class="n">r</span> <span class="k">match</span> <span class="o">{</span> 
            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">applyFK</span><span class="o">(</span><span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
            <span class="k">case</span> <span class="nc">Some</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">applyT</span><span class="o">(</span><span class="n">or</span><span class="o">(</span><span class="n">unit</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">t</span><span class="o">),</span> <span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
          <span class="o">}</span> 
        <span class="o">}</span> 
      <span class="o">}</span> 
</code></pre> 
</div> 
<p>For <code>KReturn</code> we just return the result. Although <code>KReturn</code> extends <code>K[R,R]</code>, Scala doesn&rsquo;t deduce from this that <code>R</code> = <code>R2</code>, so we must coerce the result. For <code>KUnsplit</code> we do the same match as <code>unsplit</code>, then apply the resulting <code>T</code> (for the <code>None</code> case we call the failure continuation directly instead of applying <code>fail</code>). Here Scala deduces from the return type of <code>KUnsplit</code> that is safe to treat <code>r</code> as an <code>Option</code>.</p> 
<div class="highlight"><pre><code class="scala">    <span class="n">applyT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">O</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>,<span class="kt">O</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span> 
      <span class="n">t</span><span class="o">,</span> 
      <span class="nc">SKSplit</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="nc">Unsplit</span><span class="o">(</span><span class="n">fk</span><span class="o">)))),</span> 
      <span class="nc">FKSplit</span><span class="o">(</span><span class="nc">None</span><span class="o">),</span> 
      <span class="nc">KReturn</span><span class="o">())</span> 
  <span class="o">}</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p>Finally we apply the input <code>T</code> in correspondence to the original <code>split</code>.</p> 
<b>Tail call elimination</b> 
<p>(This section has been revised; you can see the original <a href="https://github.com/jaked/ambassadortothecomputers.blogspot.com/tree/ba9621fc48ff84e01d9f70d076cc912b8185729d">here</a>.)</p> 
 
<p>To eliminate the stack frames from tail calls, we next rewrite the four mutually-recursive functions into a single recursive function (which Scala compiles as a loop). To do this we have to abandon some type safety (but only in the implementation of the <code>Logic</code> monad; we&rsquo;ll still present the same safe interface).</p> 
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">LogicSFKDefuncTailrec</span> <span class="k">extends</span> <span class="nc">Logic</span> <span class="o">{</span> 
  <span class="k">type</span> <span class="kt">O</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])]</span> 
 
  <span class="k">type</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">I</span> 
 
  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Fail</span><span class="o">()</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Unit</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Or</span><span class="o">(</span><span class="n">t1</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">t2</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="n">I</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Bind</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="n">I</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Apply</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="nc">Any</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Filter</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Unsplit</span><span class="o">(</span><span class="n">fk</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">FKOr</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="n">I</span><span class="o">,</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">FKSplit</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">O</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span> <span class="k">extends</span> <span class="n">I</span> 
 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">SKBind</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="n">I</span><span class="o">,</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">SKApply</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="nc">Any</span><span class="o">,</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">SKFilter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">SKSplit</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="o">(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">I</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">O</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span> <span class="k">extends</span> <span class="n">I</span> 
 
  <span class="k">case</span> <span class="k">object</span> <span class="nc">KReturn</span> <span class="k">extends</span> <span class="n">I</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">KUnsplit</span><span class="o">(</span><span class="n">sk</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">k</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span> <span class="k">extends</span> <span class="n">I</span> 
</code></pre> 
</div> 
<p>This is all pretty much as before except that we erase all the type parameters. Having done so we can combine the four defunctionalized types into a single type <code>I</code> (for &ldquo;instruction&rdquo; perhaps), which will allow us to write a single recursive <code>apply</code> function. The type parameter in <code>T[A]</code> is then a <em>phantom type</em> since it does not appear on the right-hand side of the definition; it is used only to enforce constraints outside the module.</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">fail</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fail</span><span class="o">()</span> 
  <span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Unit</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> 
  <span class="k">def</span> <span class="n">or</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t1</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">t2</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Or</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="o">{</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">t2</span> <span class="o">})</span> 
  <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nc">Bind</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">f</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span> <span class="k">=&gt;</span> <span class="kt">I</span><span class="o">])</span> 
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nc">Apply</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">f</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span> <span class="k">=&gt;</span> <span class="kt">I</span><span class="o">])</span> 
  <span class="k">def</span> <span class="n">filter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nc">Filter</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Any</span> <span class="k">=&gt;</span> <span class="kt">Boolean</span><span class="o">])</span> 
</code></pre> 
</div> 
<p>The functions for building <code>T[A]</code> values are mostly the same. We have to cast passed-in functions since <code>Any</code> is not a subtype of arbitrary <code>A</code>. The return type annotations don&rsquo;t seem necessary but I saw some strange type errors without them (possibly related to the phantom type?) when using the <code>Logic.Syntax</code> wrapper.</p> 
<div class="highlight"><pre><code class="scala"><span class="k">def</span> <span class="n">split</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">O</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> 
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">O</span><span class="o">[</span><span class="kt">Any</span><span class="o">],</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">I</span><span class="o">,</span> <span class="n">k</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span><span class="k">:</span> <span class="kt">O</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> 
    <span class="n">i</span> <span class="k">match</span> <span class="o">{</span> 
      <span class="k">case</span> <span class="nc">Fail</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="n">fk</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
      <span class="k">case</span> <span class="nc">Unit</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
      <span class="k">case</span> <span class="nc">Or</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="n">apply</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">sk</span><span class="o">,</span> <span class="nc">FKOr</span><span class="o">(</span><span class="n">t2</span><span class="o">,</span> <span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">),</span> <span class="n">k</span><span class="o">)</span> 
      <span class="k">case</span> <span class="nc">Bind</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">SKBind</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">sk</span><span class="o">),</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
      <span class="k">case</span> <span class="nc">Apply</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">SKApply</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">sk</span><span class="o">),</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
      <span class="k">case</span> <span class="nc">Filter</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">SKFilter</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">sk</span><span class="o">),</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
      <span class="k">case</span> <span class="nc">Unsplit</span><span class="o">(</span><span class="n">fk2</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="n">apply</span><span class="o">(</span><span class="n">fk2</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">KUnsplit</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> 
 
      <span class="k">case</span> <span class="nc">FKOr</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="o">(),</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
      <span class="k">case</span> <span class="nc">FKSplit</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span> 
 
      <span class="k">case</span> <span class="nc">SKBind</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">sk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
      <span class="k">case</span> <span class="nc">SKApply</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">sk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
      <span class="k">case</span> <span class="nc">SKFilter</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">sk</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> 
          <span class="n">apply</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="k">else</span> 
          <span class="n">apply</span><span class="o">(</span><span class="n">fk</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
      <span class="k">case</span> <span class="nc">SKSplit</span><span class="o">(</span><span class="n">rf</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="n">apply</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">rf</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">),</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span> 
 
      <span class="k">case</span> <span class="nc">KReturn</span> <span class="k">=&gt;</span> <span class="n">r</span> 
      <span class="k">case</span> <span class="nc">KUnsplit</span><span class="o">(</span><span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> 
        <span class="n">r</span> <span class="k">match</span> <span class="o">{</span> 
          <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="n">fk</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
          <span class="k">case</span> <span class="nc">Some</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">))</span> <span class="k">=&gt;</span> 
            <span class="n">apply</span><span class="o">(</span><span class="n">or</span><span class="o">(</span><span class="n">unit</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">t</span><span class="o">),</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">sk</span><span class="o">,</span> <span class="n">fk</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> 
        <span class="o">}</span> 
      <span class="o">}</span> 
    <span class="o">}</span> 
 
  <span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> 
        <span class="kc">null</span><span class="o">,</span> 
        <span class="kc">null</span><span class="o">,</span> 
        <span class="nc">SKSplit</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">fk</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="nc">Unsplit</span><span class="o">(</span><span class="n">fk</span><span class="o">)))),</span> 
        <span class="nc">FKSplit</span><span class="o">(</span><span class="nc">None</span><span class="o">),</span> 
        <span class="nc">KReturn</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">O</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p>The original functions took varying arguments; the single function takes all the arguments which the original ones did. We pass <code>null</code> for unused arguments in each call, but otherwise the cases are the same as before.</p> 
 
<p>Now we can evaluate <code>nat</code> to large N without running out of stack (but since the running time is quadratic it takes longer than I care to wait to complete):</p> 
<div class="highlight"><pre><code class="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">nat</span><span class="o">,</span> <span class="mi">100000</span><span class="o">)</span> 
<span class="o">^</span><span class="n">C</span> 
</code></pre> 
</div> 
<p>See the complete code <a href="https://github.com/jaked/ambassadortothecomputers.blogspot.com/tree/master/_code/scala-logic">here</a>.</p> 
 
<p>Next time we&rsquo;ll thread state through this backtracking logic monad, and use it to implement unification.</p>
