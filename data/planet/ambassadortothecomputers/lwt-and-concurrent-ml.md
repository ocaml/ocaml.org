---
title: Lwt and Concurrent ML
description: Programming concurrent systems with threads and locks is famously, even
  fabulously, error-prone. With Lwt's cooperative threads you don't ha...
url: http://ambassadortothecomputers.blogspot.com/2009/05/lwt-and-concurrent-ml.html
date: 2009-05-28T03:28:00-00:00
preview_image:
authors:
- Jake Donham
source:
---

<p>Programming concurrent systems with threads and locks is famously, even fabulously, error-prone. With Lwt's cooperative threads you don't have to worry so much about protecting data structures against concurrent modification, since your code runs atomically between <code>bind</code>s. Still, the standard concurrency primitives (mutexes, condition variables) are sometimes useful; but using them with Lwt is not much less painful than with preemptive threads. In this post I want to explore the combination of Lwt with the concurrency primitives of <a href="http://cml.cs.uchicago.edu/">Concurrent ML</a>. I hope to convince you that CML's primitives are easier to use, and a good match for Lwt.<br/>
</p><b>Blocking queues in Lwt</b><br/>
<p>I got started with Lwt when I was writing a work queue (as an Ocamlnet RPC service using <a href="http://code.google.com/p/orpc2/">orpc</a>). The server keeps a queue of jobs, and workers poll for a task via RPC. An RPC request turns into an Lwt thread; all these threads share the queue. If there's no job in the queue, a request blocks until one is available. So I needed a blocking queue, with the following signature:<br/>
</p><pre><span class="htmlize-tuareg-font-lock-governing">type</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">create </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-type">unit </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">add </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> unit</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">take </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a Lwt.t</span>
</pre>The queue is unbounded, so you can <code>add</code> without blocking, but a <code>take</code> may block. (It's nice how in Lwt the possibility of blocking is revealed in the type). Here's the implementation: <pre><span class="htmlize-tuareg-font-lock-governing">type</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t </span><span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-tuareg-font-lock-operator">{</span>
  <span class="htmlize-variable-name">m</span> <span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-type">Lwt_mutex.t</span><span class="htmlize-tuareg-font-lock-operator">;</span>
  <span class="htmlize-variable-name">c</span> <span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-type">Lwt_condition.t</span><span class="htmlize-tuareg-font-lock-operator">;</span>
  <span class="htmlize-variable-name">q</span> <span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a Queue.t</span><span class="htmlize-tuareg-font-lock-operator">;</span>
<span class="htmlize-tuareg-font-lock-operator">}</span>

<span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-function-name">create</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-tuareg-font-lock-operator">{</span>
  m <span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-type">Lwt_mutex</span>.create <span class="htmlize-tuareg-font-lock-operator">();</span>
  c <span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-type">Lwt_condition</span>.create <span class="htmlize-tuareg-font-lock-operator">();</span>
  q <span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-type">Queue</span>.create <span class="htmlize-tuareg-font-lock-operator">();</span>
<span class="htmlize-tuareg-font-lock-operator">}</span>
</pre>A queue is made up of a regular OCaml queue, a condition variable (signaled when there's something in the queue), and a mutex for use with the condition variable. (The <a href="http://code.google.com/p/orpc2/source/browse/trunk/src/lwt-equeue/lwt_condition.ml"><code>Lwt_condition</code></a> module is based on the <code>Condition</code> module of the standard OCaml threads library.) <pre><span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-function-name">add</span><span class="htmlize-variable-name"> e t </span><span class="htmlize-tuareg-font-lock-operator">=</span>
  <span class="htmlize-type">Queue</span>.add e t.q<span class="htmlize-tuareg-font-lock-operator">;</span>
  <span class="htmlize-type">Lwt_condition</span>.signal t.c<span class="htmlize-tuareg-font-lock-operator"></span>

<span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-function-name">take</span><span class="htmlize-variable-name"> t </span><span class="htmlize-tuareg-font-lock-operator">=</span>
  <span class="htmlize-type">Lwt_mutex</span>.lock t.m <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;=</span> <span class="htmlize-keyword">fun</span> <span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
  <span class="htmlize-keyword">if</span> <span class="htmlize-type">Queue</span>.is_empty t.q
  <span class="htmlize-keyword">then</span> <span class="htmlize-type">Lwt_condition</span>.wait t.c t.m
  <span class="htmlize-keyword">else</span> <span class="htmlize-type">Lwt</span>.return <span class="htmlize-tuareg-font-lock-operator">()</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;=</span> <span class="htmlize-keyword">fun</span> <span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
  <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-variable-name">e </span><span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-type">Lwt</span>.return <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-type">Queue</span>.take t.q<span class="htmlize-tuareg-font-lock-operator">)</span> <span class="htmlize-tuareg-font-lock-governing">in</span>
  <span class="htmlize-type">Lwt_mutex</span>.unlock t.m<span class="htmlize-tuareg-font-lock-operator">;</span>
  e
</pre>Since Lwt threads are cooperative we don't need to worry about concurrent access to the underlying queue. The role of the mutex here is only to ensure that when a thread blocked on the condition gets signaled, another thread can't take the element first.<br/>
<b>Timeouts?</b><br/>
<p>What if there are no entries in the queue for a while? Within a single process, no big deal, the thread can keep waiting forever. That doesn't seem like a good idea over a network connection; we should time out at some point and return a response indicating that no task is available.  Here is a first attempt at taking an element from the queue with a timeout: </p><pre><span class="htmlize-type">Lwt</span>.choose <span class="htmlize-tuareg-font-lock-operator">[</span>
  <span class="htmlize-type">Lwt_queue</span>.take q<span class="htmlize-tuareg-font-lock-operator">;</span>
  <span class="htmlize-type">Lwt_unix</span>.sleep timeout <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;=</span> <span class="htmlize-keyword">fun</span> <span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
    <span class="htmlize-type">Lwt</span>.fail <span class="htmlize-tuareg-font-lock-operator">(</span>Failure <span class="htmlize-string">&quot;timeout&quot;</span><span class="htmlize-tuareg-font-lock-operator">);</span>
<span class="htmlize-tuareg-font-lock-operator">]</span>
</pre>The <code>Lwt.choose</code> function &quot;behaves as the first thread [...] to terminate&quot;. However, the other threads are still running after the first one terminates. It doesn't matter if the <code>sleep</code> is still running after the <code>take</code> completes, but if the <code>sleep</code> finishes first, then the <code>take</code> thread is still waiting to take an element from the queue. When an element becomes available, this thread takes it, and drops it on the floor (since the <code>choose</code> has already finished). And in general this sort of thing can happen whenever a thread you <code>choose</code> between has some effect; the effect still happens even if the thread is not chosen.  A thread can block on only one condition at a time. In order to <code>take</code> an element with a timeout, we're forced to build timeouts into the queue, so we can get at the queue's condition variable. We add an optional argument to <code>take</code>: <pre><span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">take </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">?</span><span class="htmlize-type">timeout</span><span class="htmlize-tuareg-font-lock-operator">:</span>float <span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-tuareg-font-lock-operator">'</span>a t <span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-tuareg-font-lock-operator">'</span>a <span class="htmlize-type">Lwt</span>.t
</pre>and modify the implementation: <pre><span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-function-name">take</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">?(</span>timeout<span class="htmlize-tuareg-font-lock-operator">=(-</span>1.<span class="htmlize-tuareg-font-lock-operator">))</span> t <span class="htmlize-tuareg-font-lock-operator">=</span>
  <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-variable-name">timed_out </span><span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-tuareg-font-lock-operator">ref</span> <span class="htmlize-constant">false</span> <span class="htmlize-tuareg-font-lock-governing">in</span>
  <span class="htmlize-keyword">if</span> timeout <span class="htmlize-tuareg-font-lock-operator">&gt;=</span> 0.
  <span class="htmlize-keyword">then</span>
    <span class="htmlize-type">Lwt</span>.ignore_result
      <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-type">Lwt_unix</span>.sleep timeout <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;=</span> <span class="htmlize-keyword">fun</span> <span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
        timed_out <span class="htmlize-tuareg-font-lock-operator">:=</span> <span class="htmlize-constant">true</span><span class="htmlize-tuareg-font-lock-operator">;</span>
        <span class="htmlize-type">Lwt_condition</span>.broadcast t.c<span class="htmlize-tuareg-font-lock-operator">;</span>
        <span class="htmlize-type">Lwt</span>.return <span class="htmlize-tuareg-font-lock-operator">());</span>
  <span class="htmlize-type">Lwt_mutex</span>.lock t.m <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;=</span> <span class="htmlize-keyword">fun</span> <span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
    <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-tuareg-font-lock-governing">rec</span> <span class="htmlize-function-name">while_empty</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">=</span>
      <span class="htmlize-keyword">if</span> <span class="htmlize-tuareg-font-lock-operator">!</span>timed_out <span class="htmlize-keyword">then</span> <span class="htmlize-type">Lwt</span>.return <span class="htmlize-constant">false</span>
      <span class="htmlize-keyword">else</span> <span class="htmlize-keyword">if</span> <span class="htmlize-tuareg-font-lock-operator">not</span> <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-type">Queue</span>.is_empty t.q<span class="htmlize-tuareg-font-lock-operator">)</span> <span class="htmlize-keyword">then</span> <span class="htmlize-type">Lwt</span>.return <span class="htmlize-constant">true</span>
      <span class="htmlize-keyword">else</span> <span class="htmlize-type">Lwt_condition</span>.wait t.c t.m <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;=</span> while_empty <span class="htmlize-tuareg-font-lock-governing">in</span>
    while_empty <span class="htmlize-tuareg-font-lock-operator">()</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;=</span> <span class="htmlize-keyword">fun</span> <span class="htmlize-variable-name">not_empty </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
    <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-variable-name">e </span><span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-keyword">if</span> not_empty <span class="htmlize-keyword">then</span> Some <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-type">Queue</span>.take t.q<span class="htmlize-tuareg-font-lock-operator">)</span> <span class="htmlize-keyword">else</span> None <span class="htmlize-tuareg-font-lock-governing">in</span>
    <span class="htmlize-type">Lwt_mutex</span>.unlock t.m<span class="htmlize-tuareg-font-lock-operator">;</span>
    <span class="htmlize-type">Lwt_condition</span>.signal t.c<span class="htmlize-tuareg-font-lock-operator">;</span>
    <span class="htmlize-keyword">match</span> e <span class="htmlize-keyword">with</span> Some e <span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-type">Lwt</span>.return e <span class="htmlize-tuareg-font-lock-operator">|</span> _ <span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-type">Lwt</span>.fail Timeout
</pre>In an auxilliary thread we wait for the timeout, then set a timeout flag for the main thread and broadcast the condition. It's important to use <code>broadcast</code>, which signals all waiting threads, instead of <code>signal</code>, which signals an arbitrary waiter, in order to be sure that we wake up the timed-out thread. But now it's possible for a thread to be signaled when neither the timeout has expired nor an element is available, so we must loop around waiting on the condition. And a <code>signal</code> from adding an element may be sent to a timed-out thread, so we need to <code>signal</code> another thread to avoid forgetting the added element.  This is not very nice. First, the interface isn't modular. We've hard-coded a particular pair of events to wait for; what if we wanted to wait on two queues at once, or a queue and network socket? Second, the implementation is tricky to understand. We have to reason about how multiple threads, each potentially at a different point in the program, interact with the shared state.<br/>
<b>Lwt_event</b><br/>
<p>Concurrent ML provides a different set of primitives. It makes the notion of an <em>event</em>--something that may happen in the future, like a timeout or a condition becoming true--into an explicit datatype, so you can return it from a function, store it in a data structure, and so on: </p><pre><span class="htmlize-tuareg-font-lock-governing">type</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a event</span>
</pre>When an event occurs, it carries a value of type <code>'a</code>. The act of <em>synchronizing</em> on (waiting for) an event is a separate function: <pre><span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">sync </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a event </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a Lwt.t</span>
</pre>Of course it returns <code>Lwt.t</code> since it may block; the returned value is the value of the event occurrence. You can make an event that occurs when any of several events occurs, so a thread can wait on several events at once: <pre><span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">choose </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a event list </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a event</span>
</pre>When one event occurs, the thread is no longer waiting on the other events (in contrast to <code>Lwt.choose</code>). Since synchronizing on a choice of events is a very common pattern, there's also <pre><span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">select </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a event list </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a Lwt.t</span>
</pre>which is the same as <code>sync</code> of <code>choose</code>. Its meaning is very similar to <code>Unix.select</code>: block until one of the events occurs.  A <em>channel</em> is sort of like a zero-length queue: both reader and writer must synchronize on the channel at the same time to pass a value from one to the other: <pre><span class="htmlize-tuareg-font-lock-governing">type</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a channel</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">new_channel </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-type">unit </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a channel</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">send </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a channel </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> unit event</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">receive </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a channel </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a event</span>
</pre>Both <code>send</code> and <code>receive</code> are blocking operations, so they return <code>event</code>s. Finally, there's a way to map the value of an event when it occurs: <pre><span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">wrap </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a event </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">('</span><span class="htmlize-type">a </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">b Lwt.t</span><span class="htmlize-tuareg-font-lock-operator">)</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">b event</span>
</pre>The event <code>wrap e f</code> occurs when <code>e</code> occurs, with value <code>f v</code> (where <code>v</code> is the value returned by the occurrence of <code>e</code>).  (Here's the full <a href="http://code.google.com/p/orpc2/source/browse/trunk/src/lwt-equeue/lwt_event.mli">interface</a> of <code>Lwt_event</code>. There are events for Unix file descriptor operations in <a href="http://code.google.com/p/orpc2/source/browse/trunk/src/lwt-equeue/lwt_event_unix.mli"><code>Lwt_event_unix</code></a>.)<br/>
<b>Blocking queues with Lwt_event</b><br/>
<p>Now I want to reimplement blocking queues using these new primitives: </p><pre><span class="htmlize-tuareg-font-lock-governing">type</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t</span>

<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">create </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-type">unit </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">add </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> unit Lwt.t</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">take </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a Lwt_event.event</span>
</pre>The interface is similar. As before, <code>take</code> is a blocking operation, but it returns an <code>event</code> instead of <code>Lwt.t</code> so we can combine it with other events using <code>choose</code>. The new <code>add</code> returns <code>Lwt.t</code>, but this is an artifact: a thread calling <code>add</code> won't actually block (we'll see why below). For this reason, <code>add</code> doesn't need to return <code>event</code>. <pre><span class="htmlize-tuareg-font-lock-governing">type</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t </span><span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-tuareg-font-lock-operator">{</span>
  <span class="htmlize-variable-name">inch</span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a channel</span><span class="htmlize-tuareg-font-lock-operator">;</span>
  <span class="htmlize-variable-name">ouch</span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a channel</span><span class="htmlize-tuareg-font-lock-operator">;</span>
<span class="htmlize-tuareg-font-lock-operator">}</span>
<span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-function-name">add</span><span class="htmlize-variable-name"> e t </span><span class="htmlize-tuareg-font-lock-operator">=</span> sync <span class="htmlize-tuareg-font-lock-operator">(</span>send t.inch e<span class="htmlize-tuareg-font-lock-operator">)</span>
<span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-function-name">take</span><span class="htmlize-variable-name"> t </span><span class="htmlize-tuareg-font-lock-operator">=</span> receive t.ouch
</pre>A queue consists of two channels, one for adding items into the queue and one for taking them out. The functions implementing the external interface just send and receive on these channels. <pre><span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-function-name">create</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">=</span>
  <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-variable-name">q </span><span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-type">Queue</span>.create <span class="htmlize-tuareg-font-lock-operator">()</span> <span class="htmlize-tuareg-font-lock-governing">in</span>
  <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-variable-name">inch </span><span class="htmlize-tuareg-font-lock-operator">=</span> new_channel <span class="htmlize-tuareg-font-lock-operator">()</span> <span class="htmlize-tuareg-font-lock-governing">in</span>
  <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-variable-name">ouch </span><span class="htmlize-tuareg-font-lock-operator">=</span> new_channel <span class="htmlize-tuareg-font-lock-operator">()</span> <span class="htmlize-tuareg-font-lock-governing">in</span>
</pre>To <code>create</code> a queue, we make the channels and the underlying queue (we don't need to store it in the record; it will be hidden in a closure). We're going to have an internal thread to manage the queue; next we need some events for it to interact with the channels:<br/>
<pre>  <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-variable-name">add </span><span class="htmlize-tuareg-font-lock-operator">=</span>
    wrap <span class="htmlize-tuareg-font-lock-operator">(</span>receive inch<span class="htmlize-tuareg-font-lock-operator">)</span> <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-keyword">fun</span> <span class="htmlize-variable-name">e </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
      <span class="htmlize-type">Queue</span>.add e q<span class="htmlize-tuareg-font-lock-operator">;</span>
      <span class="htmlize-type">Lwt</span>.return <span class="htmlize-tuareg-font-lock-operator">())</span> <span class="htmlize-tuareg-font-lock-governing">in</span>

  <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-function-name">take</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">=</span>
    wrap <span class="htmlize-tuareg-font-lock-operator">(</span>send ouch <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-type">Queue</span>.peek q<span class="htmlize-tuareg-font-lock-operator">))</span> <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-keyword">fun</span> <span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
      ignore <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-type">Queue</span>.take q<span class="htmlize-tuareg-font-lock-operator">);</span>
      <span class="htmlize-type">Lwt</span>.return <span class="htmlize-tuareg-font-lock-operator">())</span> <span class="htmlize-tuareg-font-lock-governing">in</span>
</pre>Here <code>add</code> receives an element from the input channel and adds it to the underlying queue; and <code>take</code> sends the top element of the queue on the output channel. Keep in mind that these events don't occur (and the function passed to <code>wrap</code> is not executed) until there's actually a thread synchronizing on the complementary event on the channel. We call <code>Queue.peek</code> in <code>take</code> because at the point that we offer to send an element on a channel, we have to come up with the element; but we don't want to take it off the underlying queue, because there might never be a thread synchronizing on the complementary event on the channel. (Maybe there should be a version of <code>send</code> that takes a thunk?)<br/>
<pre>  <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-tuareg-font-lock-governing">rec</span> <span class="htmlize-function-name">loop</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">=</span>
    <span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-variable-name">evs </span><span class="htmlize-tuareg-font-lock-operator">=</span>
      <span class="htmlize-keyword">if</span> <span class="htmlize-type">Queue</span>.is_empty q
      <span class="htmlize-keyword">then</span> <span class="htmlize-tuareg-font-lock-operator">[</span> add <span class="htmlize-tuareg-font-lock-operator">]</span>
      <span class="htmlize-keyword">else</span> <span class="htmlize-tuareg-font-lock-operator">[</span> add<span class="htmlize-tuareg-font-lock-operator">;</span> take <span class="htmlize-tuareg-font-lock-operator">()</span> <span class="htmlize-tuareg-font-lock-operator">]</span> <span class="htmlize-tuareg-font-lock-governing">in</span>
    select evs <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;=</span> loop <span class="htmlize-tuareg-font-lock-governing">in</span>
  ignore <span class="htmlize-tuareg-font-lock-operator">(</span>loop <span class="htmlize-tuareg-font-lock-operator">());</span>

  <span class="htmlize-tuareg-font-lock-operator">{</span> inch <span class="htmlize-tuareg-font-lock-operator">=</span> inch<span class="htmlize-tuareg-font-lock-operator">;</span> ouch <span class="htmlize-tuareg-font-lock-operator">=</span> ouch <span class="htmlize-tuareg-font-lock-operator">}</span>
</pre>Here's the internal thread. If the queue is empty all we can do is wait for an element to be added; if not, we wait for an element to be added or taken. Now we can see why the <code>add</code> function of the external queue interface can't block: we always <code>select</code> the <code>add</code> event, so as soon as another thread wants to send an element on the input channel, the internal thread is available to receive it.<br/>
<b>Timeouts!</b><br/>
<p>Now, the punchline: we didn't build timeouts into the queue; still we can select between taking an element or timing out: </p><pre>select <span class="htmlize-tuareg-font-lock-operator">[</span>
  <span class="htmlize-type">Lwt_event_queue</span>.take q<span class="htmlize-tuareg-font-lock-operator">;</span>
  wrap <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-type">Lwt_event_unix</span>.sleep timeout<span class="htmlize-tuareg-font-lock-operator">)</span>
    <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-keyword">fun</span> <span class="htmlize-tuareg-font-lock-operator">()</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-type">Lwt</span>.fail <span class="htmlize-tuareg-font-lock-operator">(</span>Failure <span class="htmlize-string">&quot;timeout&quot;</span><span class="htmlize-tuareg-font-lock-operator">));</span>
<span class="htmlize-tuareg-font-lock-operator">]</span>
</pre>Much better.  Moreover, I think this queue implementation is easier to reason about (once you're comfortable with the CML primitives), even compared to our first version (without timeouts). The difference is that only the internal thread touches the state of the queue--in fact it's the only thread for which the state is even in scope! We don't need to worry conditions and signaling; we just offer an element on the output channel when one is available. This is only an inkling of the power of CML; the book <a href="http://www.amazon.com/dp/0521714729">Concurrent Programming in ML</a> contains much more, including some large examples.
<p>Why is this style of concurrency not more common? I think there are several reasons: First, idiomatic CML programming requires very lightweight threads (you don't want a native thread, or even an OCaml bytecode thread, for every queue). Second, the <code>wrap</code> combinator, essential for building complex events, requires higher-order functions, so there's no similarly concise translation into, say, Java. Finally, I think it's not widely appreciated that concurrent programming is useful without <em>parallel</em> programming. The mutex approach works fine for parallel programming, while CML has <a href="http://manticore.cs.uchicago.edu/papers/submitted09-parallel-cml.pdf">only</a> <a href="http://clip.dia.fi.upm.es/Conferences/DAMP08/papers/7.pdf">recently</a> been implemented in a parallel setting. None of these reasons applies to Lwt programming; Concurrent ML is a good fit with Lwt.</p>
<p>In an <a href="http://ambassadortothecomputers.blogspot.com/2009/02/equeue-compared-to-lwt.html">earlier post</a> I asserted (without much to back it up) that Ocamlnet's Equeue gives better low-level control over blocking than Lwt. The <code>Lwt_event</code> and <code>Lwt_event_unix</code> modules provide a similar degree of control, with a higher-level interface.</p>
