---
title: 'Logic programming in Scala, part 3: unification and state'
description: In this post I want to build on the backtracking logic monad we covered
  last time  by adding unification , yielding an embedded DSL for Prol...
url: http://ambassadortothecomputers.blogspot.com/2011/06/logic-programming-in-scala-part-3.html
date: 2011-06-09T03:41:00-00:00
preview_image:
authors:
- Jake Donham
source:
---

<p>In this post I want to build on the backtracking logic monad we covered <a href="http://ambassadortothecomputers.blogspot.com/2011/04/logic-programming-in-scala-part-2.html">last time</a> by adding <em>unification</em>, yielding an embedded DSL for Prolog-style logic programming.</p> 
<b>Prolog</b> 
<p>Here is a small Prolog example, the rough equivalent of <code>List.contains</code> in Scala:</p> 
<div class="highlight"><pre><code class="prolog">  <span class="nf">member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">X</span><span class="p">|</span><span class="nv">T</span><span class="p">]).</span> 
  <span class="nf">member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="k">_</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="p">:-</span> <span class="nf">member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span> 
</code></pre> 
</div> 
<p><code>Member</code> doesn&rsquo;t return a boolean; instead it succeeds or fails (in the same way as the logic monad). The <em>goal</em> <code>member(1, [1,2,3])</code> succeeds; the goal <code>member(4, [1,2,3])</code> fails. (What happens for <code>member(1, [1,1,3])</code>?)</p> 
 
<p>A Prolog <em>predicate</em> is defined by one or more <em>clauses</em> (each ending in a period), made up of a <em>head</em> (the predicate and arguments before the <code>:-</code>) and zero or more <em>subgoals</em> (goals after the <code>:-</code>, separated by commas; if there are no subgoals the <code>:-</code> is omitted). To solve a goal, we <em>unify</em> it (match it) with each clause head, then solve each subgoal in the clause. If a subgoal fails we backtrack and try the next matching head; if there is no matching head the goal fails. A goal may succeed more than once.</p> 
 
<p>For <code>member</code> we have two clauses: the first says that <code>member</code> succeeds if <code>X</code> is the head of the list (<code>[X|T]</code> is the same as <code>x::t</code> in Scala); the second says that <code>member</code> succeeds if <code>X</code> is a member of the tail of the list, regardless of the head. There is no clause where the list is empty (written <code>[]</code>); a goal with an empty list fails since there is no matching clause head.</p> 
 
<p>Prolog unification is more expressive than pattern matching as found in Scala, OCaml, etc. Both sides of a unification may contain variables; unification attempts to instantiate them so that the two sides are equal. Variables are instantiated by <em>terms</em>, which themselves may contain variables; unification finds the most general instantiation which makes the sides equal.</p> 
 
<p>As a small example of this expressivity, we can run <code>member</code> &ldquo;backwards&rdquo;: the goal <code>member(X, [1,2,3])</code> succeeds once for each element of the list, with <code>X</code> bound to the element.</p> 
 
<p>There is much more on Prolog and logic programming in <a href="http://www.cs.cmu.edu/~fp/courses/lp/lectures/lp-all.pdf">Frank Pfenning&rsquo;s course notes</a>, which I recommend highly.</p> 
<b>Unification</b> 
<p>For each type we want to use in unification we&rsquo;ll define a corresponding type of terms, which have the same structure as the underlying type but can also contain variables. These aren&rsquo;t Scala variables (which of course can&rsquo;t be stored in a data structure) but &ldquo;existential variables&rdquo;, or <em>evars</em>. Evars are just tags; computations will carry an <em>environment</em> mapping evars to terms, which may be updated after a successful unification.</p> 
<div class="highlight"><pre><code class="scala"><span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">Map</span><span class="o">,</span><span class="nc">HashMap</span><span class="o">}</span> 
 
<span class="k">class</span> <span class="nc">Evar</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> 
<span class="k">object</span> <span class="nc">Evar</span> <span class="o">{</span> <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Evar</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">name</span><span class="o">)</span> <span class="o">}</span> 
 
<span class="k">trait</span> <span class="nc">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
  <span class="c1">// invariant: on call to unify, this and t have e substituted</span> 
  <span class="k">def</span> <span class="n">unify</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Env</span><span class="o">]</span> 
 
  <span class="k">def</span> <span class="n">occurs</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Evar</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> 
  <span class="k">def</span> <span class="n">subst</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> 
  <span class="k">def</span> <span class="n">ground</span><span class="k">:</span> <span class="kt">A</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p>The important property of an evar is that it is distinct from every other evar; the name attached to it is just a label. An evar is indexed by a phantom type indicating the underlying type of terms which may be bound to it.</p> 
 
<p>A term is indexed by its underlying type. So <code>Int</code> becomes <code>Term[Int]</code>, <code>String</code> becomes <code>Term[String]</code>, and so on; an evar of type <code>Evar[A]</code> may only be bound to a term of type <code>Term[A]</code>. (Prolog is dynamically typed, but this statically-typed treatment of evars and terms fits better with Scala.)</p> 
 
<p>The <code>unify</code> method unifies a term with another term of the same type, taking an environment and returning an updated environment (or <code>None</code> if the unification fails). <code>Occurs</code> checks if an evar occurs in a term (as we will see this is used to prevent circular bindings). <code>Subst</code> substitutes the variables in a term with their bindings in an environment, and <code>ground</code> returns the underlying Scala value represented by the term (provided the term contains no evars).</p> 
<div class="highlight"><pre><code class="scala"><span class="k">class</span> <span class="nc">Env</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Evar</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>,<span class="kt">Term</span><span class="o">[</span><span class="kt">Any</span><span class="o">]])</span> <span class="o">{</span> 
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Evar</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> 
    <span class="n">m</span><span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Evar</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> 
  <span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Evar</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> 
    <span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Evar</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">]]]</span> 
  <span class="k">def</span> <span class="n">updated</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Evar</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Env</span> <span class="o">=</span> <span class="o">{</span> 
    <span class="k">val</span> <span class="n">v2</span> <span class="k">=</span> <span class="n">v</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Evar</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]</span> 
    <span class="k">val</span> <span class="n">t2</span> <span class="k">=</span> <span class="n">t</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]</span> 
    <span class="k">val</span> <span class="n">e2</span> <span class="k">=</span> <span class="nc">Env</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="n">v2</span> <span class="o">-&gt;</span> <span class="n">t2</span><span class="o">))</span> 
    <span class="k">val</span> <span class="n">m2</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="n">_</span><span class="o">.</span><span class="n">subst</span><span class="o">(</span><span class="n">e2</span><span class="o">))</span> 
    <span class="nc">Env</span><span class="o">(</span><span class="n">m2</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">v2</span><span class="o">,</span> <span class="n">t2</span><span class="o">))</span> 
  <span class="o">}</span> 
<span class="o">}</span> 
<span class="k">object</span> <span class="nc">Env</span> <span class="o">{</span> 
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Evar</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>,<span class="kt">Term</span><span class="o">[</span><span class="kt">Any</span><span class="o">]])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Env</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> 
  <span class="k">def</span> <span class="n">empty</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Env</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">())</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p>An environment is just a map from evars to terms. Because we need to store evars and terms of different types in the same environment, we cast them to and from <code>Any</code>; this is safe because of the phantom type on <code>Evar</code>. For simplicity we maintain the invariant that the term bound to each evar is already substituted by the rest of the environment.</p> 
<div class="highlight"><pre><code class="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">VarTerm</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Evar</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
  <span class="k">def</span> <span class="n">unify</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> 
    <span class="n">t</span> <span class="k">match</span> <span class="o">{</span> 
      <span class="k">case</span> <span class="nc">VarTerm</span><span class="o">(</span><span class="n">v2</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">v2</span> <span class="o">==</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> 
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="n">occurs</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="nc">None</span> 
        <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">t</span><span class="o">))</span> 
    <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">occurs</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">v2</span><span class="k">:</span> <span class="kt">Evar</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="n">v2</span> <span class="o">==</span> <span class="n">v</span> 
 
  <span class="k">def</span> <span class="n">subst</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="k">=</span> 
    <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span> 
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">t</span> 
      <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="k">this</span> 
    <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">ground</span> <span class="k">=</span> 
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;not ground&quot;</span><span class="o">)</span> 
 
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="o">{</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span>  <span class="o">}</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p>The <code>VarTerm</code> class represents terms consisting of an evar. To unify a <code>VarTerm</code> with another <code>VarTerm</code> containing the same evar, we just return the environment unchanged (since there is no new information). Otherwise we check that the evar doesn&rsquo;t appear in the term (since a unification <code>x =:= List(x)</code> would create a circular term) then return the updated environment.</p> 
 
<p>To substitute a <code>VarTerm</code> we return the term bound to the evar in the environment if one exists, otherwise the unsubstituted <code>VarTerm</code>. A <code>VarTerm</code> is never ground (we assume <code>ground</code> is called only on terms which are already substituted by the environment).</p> 
<div class="highlight"><pre><code class="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">LitTerm</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
  <span class="k">def</span> <span class="n">unify</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> 
    <span class="n">t</span> <span class="k">match</span> <span class="o">{</span> 
      <span class="k">case</span> <span class="nc">LitTerm</span><span class="o">(</span><span class="n">a2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span> <span class="nc">Some</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">else</span> <span class="nc">None</span> 
      <span class="k">case</span> <span class="n">_:</span> <span class="nc">VarTerm</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">unify</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span> 
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span> 
    <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">occurs</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Evar</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="kc">false</span> 
  <span class="k">def</span> <span class="n">subst</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span> 
  <span class="k">def</span> <span class="n">ground</span> <span class="k">=</span> <span class="n">a</span> 
 
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="o">{</span> <span class="n">a</span><span class="o">.</span><span class="n">toString</span> <span class="o">}</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p><code>LitTerm</code> represents terms of literal Scala values. A <code>LitTerm</code> unifies with another <code>LitTerm</code> containing an equal value, but that adds nothing to the environment. Then we have two cases which we need for every term type&mdash;to unify with a <code>VarTerm</code> call <code>unify</code> back on it; otherwise fail.</p> 
<div class="highlight"><pre><code class="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">NilTerm</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Term</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span> 
  <span class="k">def</span> <span class="n">unify</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="k">=</span> 
    <span class="n">t</span> <span class="k">match</span> <span class="o">{</span> 
      <span class="k">case</span> <span class="nc">NilTerm</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> 
      <span class="k">case</span> <span class="n">_:</span> <span class="nc">VarTerm</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">unify</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span> 
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span> 
    <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">occurs</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Evar</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="kc">false</span> 
  <span class="k">def</span> <span class="n">subst</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span> 
  <span class="k">def</span> <span class="n">ground</span> <span class="k">=</span> <span class="nc">Nil</span> 
 
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="o">{</span> <span class="nc">Nil</span><span class="o">.</span><span class="n">toString</span> <span class="o">}</span> 
<span class="o">}</span> 
 
<span class="k">case</span> <span class="k">class</span> <span class="nc">ConsTerm</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> 
  <span class="k">extends</span> <span class="nc">Term</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> 
<span class="o">{</span> 
  <span class="k">def</span> <span class="n">unify</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="k">=</span> 
    <span class="n">t</span> <span class="k">match</span> <span class="o">{</span> 
      <span class="k">case</span> <span class="nc">ConsTerm</span><span class="o">(</span><span class="n">hd2</span><span class="o">,</span> <span class="n">tl2</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="k">for</span> <span class="o">{</span> 
          <span class="n">e1</span> <span class="k">&lt;-</span> <span class="n">hd</span><span class="o">.</span><span class="n">unify</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">hd2</span><span class="o">)</span> 
          <span class="n">e2</span> <span class="k">&lt;-</span> <span class="n">tl</span><span class="o">.</span><span class="n">subst</span><span class="o">(</span><span class="n">e1</span><span class="o">).</span><span class="n">unify</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">tl2</span><span class="o">.</span><span class="n">subst</span><span class="o">(</span><span class="n">e1</span><span class="o">))</span> 
        <span class="o">}</span> <span class="k">yield</span> <span class="n">e2</span> 
      <span class="k">case</span> <span class="n">_:</span> <span class="nc">VarTerm</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">unify</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span> 
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span> 
    <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">occurs</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Evar</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span> <span class="k">=</span> <span class="n">hd</span><span class="o">.</span><span class="n">occurs</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">||</span> <span class="n">tl</span><span class="o">.</span><span class="n">occurs</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> 
  <span class="k">def</span> <span class="n">subst</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="k">=</span> <span class="nc">ConsTerm</span><span class="o">(</span><span class="n">hd</span><span class="o">.</span><span class="n">subst</span><span class="o">(</span><span class="n">e</span><span class="o">),</span> <span class="n">tl</span><span class="o">.</span><span class="n">subst</span><span class="o">(</span><span class="n">e</span><span class="o">))</span> 
  <span class="k">def</span> <span class="n">ground</span> <span class="k">=</span> <span class="n">hd</span><span class="o">.</span><span class="n">ground</span> <span class="o">::</span> <span class="n">tl</span><span class="o">.</span><span class="n">ground</span> 
 
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="o">{</span> <span class="n">hd</span><span class="o">.</span><span class="n">toString</span> <span class="o">+</span> <span class="s">&quot; :: &quot;</span> <span class="o">+</span> <span class="n">tl</span><span class="o">.</span><span class="n">toString</span> <span class="o">}</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p><code>NilTerm</code> and <code>ConsTerm</code> represent the <code>Nil</code> and <code>::</code> constructors for lists. <code>Nil</code> is sort of like a literal, so the methods for <code>NilTerm</code> are similar to those for <code>LitTerm</code>. For <code>ConsTerm</code> we unify by unifying the heads and tails, calling <code>subst</code> on the tails since unifying the heads may have added bindings to the environment. (Here it&rsquo;s convenient to use a for-comprehension on the <code>Option[Env]</code> type since either unification may fail.) Similarly we implement <code>occurs</code>, <code>subst</code>, and <code>ground</code> by calling them on the head and tail.</p> 
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">Term</span> <span class="o">{</span> 
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">var2Term</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Evar</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">VarTerm</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> 
  <span class="c1">//implicit def lit2term[A](a: A): Term[A] = LitTerm(a)</span> 
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">int2Term</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">LitTerm</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> 
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">list2Term</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> 
    <span class="n">l</span> <span class="k">match</span> <span class="o">{</span> 
      <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">NilTerm</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> 
      <span class="k">case</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="k">=&gt;</span> <span class="nc">ConsTerm</span><span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="n">list2Term</span><span class="o">(</span><span class="n">tl</span><span class="o">))</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p>Finally we have some implicit conversions to make it a little easier to build <code>Term</code> values. The <code>lit2term</code> conversion turned out to be a bad idea; in particular you don&rsquo;t want a <code>LitTerm[List[A]]</code> since it doesn&rsquo;t unify with a <code>ConsTerm[A]</code> or <code>NilTerm[A]</code>.</p> 
<b>State</b> 
<p>In order to combine unification with backtracking, we need to keep track of the environment along each branch of the tree of choices. We don&rsquo;t want the environments from different branches to interfere, so it&rsquo;s convenient to use a purely functional environment representation; we pass the current environment down the tree as computation proceeds. However, we can hide this state passing in the monad interface:</p> 
<div class="highlight"><pre><code class="scala"><span class="k">trait</span> <span class="nc">LogicState</span> <span class="o">{</span> <span class="n">L</span> <span class="k">=&gt;</span> 
  <span class="k">type</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">]</span> 
  <span class="c1">// as before</span> 
  <span class="k">def</span> <span class="n">split</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">S</span>,<span class="kt">A</span>,<span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">])]</span> 
 
  <span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">S</span><span class="o">]</span> 
  <span class="k">def</span> <span class="n">set</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Unit</span><span class="o">]</span> 
 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Syntax</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">])</span> <span class="o">{</span> 
    <span class="c1">// as before</span> 
    <span class="k">def</span> <span class="o">&amp;[</span><span class="kt">B</span><span class="o">](</span><span class="n">t2</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">L</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="o">{</span> <span class="n">_:</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">t2</span> <span class="o">})</span> 
  <span class="o">}</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p><code>LogicState</code> is mostly the same as <code>Logic</code>, except that the type of choices has an extra parameter for the type of the state. The <code>get</code> and <code>set</code> functions get and set the current state. To <code>split</code> we need an initial state to get things started, and each result includes an updated state. Finally we add the syntax <code>&amp;</code> to sequence two computations, ignoring the value of the first. We&rsquo;ll use this to sequence goals, since we care only about the updated environment.</p> 
 
<p>The simplest implementation of <code>LogicState</code> builds on <code>Logic</code>:</p> 
<div class="highlight"><pre><code class="scala"><span class="k">trait</span> <span class="nc">LogicStateT</span> <span class="k">extends</span> <span class="nc">LogicState</span> <span class="o">{</span> 
  <span class="k">val</span> <span class="nc">Logic</span><span class="k">:</span> <span class="kt">Logic</span> 
 
  <span class="k">type</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">S</span> <span class="k">=&gt;</span> <span class="nc">Logic</span><span class="o">.</span><span class="n">T</span><span class="o">[(</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">)]</span> 
</code></pre> 
</div> 
<p>We embed state-passing in a <code>Logic.T</code> as a function from an initial state to a choice of alternatives, where each alternative includes an updated state along with its value.</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">fail</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">s</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="nc">Logic</span><span class="o">.</span><span class="n">fail</span> <span class="o">}</span> 
  <span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">s</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="nc">Logic</span><span class="o">.</span><span class="n">unit</span><span class="o">((</span><span class="n">s</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">or</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">t1</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">],</span> <span class="n">t2</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=</span> 
    <span class="o">{</span> <span class="n">s</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="nc">Logic</span><span class="o">.</span><span class="n">or</span><span class="o">(</span><span class="n">t1</span><span class="o">(</span><span class="n">s</span><span class="o">),</span> <span class="n">t2</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span> 
    <span class="k">val</span> <span class="n">f2</span><span class="k">:</span> <span class="o">((</span><span class="kt">S</span><span class="o">,</span><span class="kt">A</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Logic</span><span class="o">.</span><span class="n">T</span><span class="o">[(</span><span class="kt">S</span>,<span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">s</span><span class="o">)</span> <span class="o">}</span> 
    <span class="o">{</span> <span class="n">s</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="nc">Logic</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">t</span><span class="o">(</span><span class="n">s</span><span class="o">),</span> <span class="n">f2</span><span class="o">)</span> <span class="o">}</span> 
  <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> 
    <span class="k">val</span> <span class="n">f2</span><span class="k">:</span> <span class="o">((</span><span class="kt">S</span><span class="o">,</span><span class="kt">A</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="o">((</span><span class="n">S</span><span class="o">,</span><span class="n">B</span><span class="o">))</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="o">}</span> 
    <span class="o">{</span> <span class="n">s</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="nc">Logic</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="o">(</span><span class="n">s</span><span class="o">),</span> <span class="n">f2</span><span class="o">)</span> <span class="o">}</span> 
  <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">filter</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> 
    <span class="k">val</span> <span class="n">p2</span><span class="k">:</span> <span class="o">((</span><span class="kt">S</span><span class="o">,</span><span class="kt">A</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">}</span> 
    <span class="o">{</span> <span class="n">s</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="nc">Logic</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">t</span><span class="o">(</span><span class="n">s</span><span class="o">),</span> <span class="n">p2</span><span class="o">)</span> <span class="o">}</span> 
  <span class="o">}</span> 
</code></pre> 
</div> 
<p>All of these operations pass the state through unchanged. Note that <code>or</code> passes the same state to both alternatives&mdash;different branches of the tree cannot interfere with one another&rsquo;s state.</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">split</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span> 
    <span class="nc">Logic</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="n">t</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="k">match</span> <span class="o">{</span> 
      <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span> 
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(((</span><span class="n">s</span><span class="o">,</span> <span class="n">a</span><span class="o">),</span> <span class="n">t</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">((</span><span class="n">s</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="o">{</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">t</span> <span class="o">}))</span> 
    <span class="o">}</span> 
  <span class="o">}</span> 
 
  <span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">s</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="nc">Logic</span><span class="o">.</span><span class="n">unit</span><span class="o">((</span><span class="n">s</span><span class="o">,</span><span class="n">s</span><span class="o">))</span> <span class="o">}</span> 
  <span class="k">def</span> <span class="n">set</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">_:</span> <span class="n">S</span> <span class="k">=&gt;</span> <span class="nc">Logic</span><span class="o">.</span><span class="n">unit</span><span class="o">((</span><span class="n">s</span><span class="o">,()))</span> <span class="o">}</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p>In <code>split</code> we pass the given state to the underlying <code>Logic.T</code>, and for each alternative we unpack the pair of state and value. The choice of remaining alternatives <code>t</code> encapsulates the current state, so when we return it we ignore the input state. In <code>get</code> and <code>set</code> we return and replace the current state.</p> 
 
<p>Another approach is to pass state explicitly through <code>LogicSFK</code>:</p> 
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">LogicStateSFK</span> <span class="k">extends</span> <span class="nc">LogicState</span> <span class="o">{</span> 
  <span class="k">type</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">R</span> 
  <span class="k">type</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span>,<span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">S</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="nc">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">R</span> 
 
  <span class="k">trait</span> <span class="nc">T</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">sk</span><span class="k">:</span> <span class="kt">SK</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span>,<span class="kt">R</span><span class="o">],</span> <span class="n">fk</span><span class="k">:</span> <span class="kt">FK</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span><span class="k">:</span> <span class="kt">R</span> <span class="o">}</span> 
</code></pre> 
</div> 
<p>This is not really any different from <code>LogicStateT</code> applied to <code>LogicSFK</code>&mdash;we have just uncurried the state argument. We can take the same path as last time and defunctionalize this into a tail-recursive implementation (see the <a href="https://github.com/jaked/ambassadortothecomputers.blogspot.com/tree/master/_code/scala-logic">full code</a>) although <code>LogicStateT</code> applied to <code>LogicSFKDefuncTailrec</code> inherits tail-recursiveness from the underlying <code>Logic</code> monad.</p> 
<b>Scrolog</b> 
<p>Finally we can put the pieces together into a Prolog-like embedded DSL:</p> 
<div class="highlight"><pre><code class="scala"><span class="k">trait</span> <span class="nc">Scrolog</span> <span class="o">{</span> 
  <span class="k">val</span> <span class="nc">LogicState</span><span class="k">:</span> <span class="kt">LogicState</span> 
  <span class="k">import</span> <span class="nn">LogicState._</span> 
 
  <span class="k">type</span> <span class="kt">G</span> <span class="o">=</span> <span class="n">T</span><span class="o">[</span><span class="kt">Env</span>,<span class="kt">Unit</span><span class="o">]</span> 
</code></pre> 
</div> 
<p>From our point of view, a goal is a stateful choice among alternatives, where we don&rsquo;t care about the value returned, only the environment.</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">class</span> <span class="nc">TermSyntax</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span> 
    <span class="k">def</span> <span class="o">=:=(</span><span class="n">t2</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span> 
      <span class="k">for</span> <span class="o">{</span> 
        <span class="n">env</span> <span class="k">&lt;-</span> <span class="n">get</span> 
        <span class="n">env2</span> <span class="k">&lt;-</span> <span class="o">{</span> 
          <span class="n">t</span><span class="o">.</span><span class="n">subst</span><span class="o">(</span><span class="n">env</span><span class="o">).</span><span class="n">unify</span><span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">t2</span><span class="o">.</span><span class="n">subst</span><span class="o">(</span><span class="n">env</span><span class="o">))</span> <span class="k">match</span> <span class="o">{</span> 
            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">fail</span><span class="o">[</span><span class="kt">Env</span>,<span class="kt">Unit</span><span class="o">]</span> 
            <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">set</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> 
          <span class="o">}</span> 
        <span class="o">}</span> 
      <span class="o">}</span> <span class="k">yield</span> <span class="n">env2</span> 
  <span class="o">}</span> 
 
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">termSyntax</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TermSyntax</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> 
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">syntax</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">G</span><span class="o">)</span> <span class="k">=</span> <span class="nc">LogicState</span><span class="o">.</span><span class="n">syntax</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> 
</code></pre> 
</div> 
<p>We connect term unification to the stateful logic monad with a wrapper class defining a <code>=:=</code> operator. To unify terms in the monad, we get the current environment, substitute it into the two terms (to satisfy the invariant above), then call <code>unify</code>; if it fails we fail the computation, else we set the new state.</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">G</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">tm</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> 
    <span class="nc">LogicState</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="nc">Env</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> 
      <span class="o">.</span><span class="n">map</span><span class="o">({</span> <span class="k">case</span> <span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">tm</span><span class="o">.</span><span class="n">subst</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">})</span> 
<span class="o">}</span> 
</code></pre> 
</div> 
<p>The <code>run</code> function solves a goal, taking as arguments the goal, the maximum number of solutions to find, and a term to be evaluated in the environment of each solution.</p> 
<b>Examples</b> 
<p>First we need to set up Scrolog:</p> 
<div class="highlight"><pre><code class="scala"><span class="k">val</span> <span class="nc">Scrolog</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">Scrolog</span> <span class="o">{</span> <span class="k">val</span> <span class="nc">LogicState</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="nc">LogicStateT</span> <span class="o">{</span> <span class="k">val</span> <span class="nc">Logic</span> <span class="k">=</span> <span class="nc">LogicSFKDefuncTailrec</span> <span class="o">}</span> 
  <span class="o">}</span> 
<span class="k">import</span> <span class="nn">Scrolog._</span> 
</code></pre> 
</div> 
<p>Here is a translation of the <code>member</code> predicate:</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">member</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">l</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span> <span class="o">{</span> 
    <span class="k">val</span> <span class="n">hd</span> <span class="k">=</span> <span class="nc">Evar</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="s">&quot;hd&quot;</span><span class="o">);</span> <span class="k">val</span> <span class="n">tl</span> <span class="k">=</span> <span class="nc">Evar</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="s">&quot;tl&quot;</span><span class="o">)</span> 
    <span class="nc">ConsTerm</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="o">=:=</span> <span class="n">l</span> <span class="o">|</span> 
    <span class="o">(</span><span class="nc">ConsTerm</span><span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="o">=:=</span> <span class="n">l</span> <span class="o">&amp;</span> <span class="n">member</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">tl</span><span class="o">))</span> 
  <span class="o">}</span> 
</code></pre> 
</div> 
<p>We implement predicates by functions, and goals by function calls. To implement matching the clause head, we explicitly unify the input arguments against each clause head, and combine the clauses with <code>|</code>. Subgoals are sequenced with <code>&amp;</code>. Finally, we must create local evars explicitly, since they are fresh for each call (just as local variables are in Scala).</p> 
 
<p>Finally we can run the goal above:</p> 
<div class="highlight"><pre><code class="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Evar</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">&quot;x&quot;</span><span class="o">)</span> 
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">member</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)),</span> <span class="mi">3</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> 
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> 
</code></pre> 
</div> 
<p>As another example, we can implement addition over unary natural numbers. In Prolog this would be</p> 
<div class="highlight"><pre><code class="prolog">  <span class="nf">sum</span><span class="p">(</span><span class="s-Atom">z</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">N</span><span class="p">).</span> 
  <span class="nf">sum</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="nv">M</span><span class="p">),</span> <span class="nv">N</span><span class="p">,</span> <span class="nf">s</span><span class="p">(</span><span class="nv">P</span><span class="p">))</span> <span class="p">:-</span> <span class="nf">sum</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">P</span><span class="p">).</span> 
</code></pre> 
</div> 
<p>In Prolog we can just invent symbols like <code>s</code> and <code>z</code>; in Scala we need first to define a type of natural numbers, then terms over that type:</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Nat</span> 
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Z</span> <span class="k">extends</span> <span class="nc">Nat</span> 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">S</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Nat</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Nat</span> 
 
  <span class="k">case</span> <span class="k">object</span> <span class="nc">ZTerm</span> <span class="k">extends</span> <span class="nc">Term</span><span class="o">[</span><span class="kt">Nat</span><span class="o">]</span> <span class="o">{</span> 
    <span class="c1">// like NilTerm</span> 
 
  <span class="k">case</span> <span class="k">class</span> <span class="nc">STerm</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">Nat</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Term</span><span class="o">[</span><span class="kt">Nat</span><span class="o">]</span> <span class="o">{</span> 
    <span class="c1">// like ConsTerm</span> 
</code></pre> 
</div> 
<p>Then we can define <code>sum</code>, again separating the clauses by <code>|</code> and explicitly unifying the clause heads:</p> 
<div class="highlight"><pre><code class="scala">  <span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">Nat</span><span class="o">],</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">Nat</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Term</span><span class="o">[</span><span class="kt">Nat</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span> <span class="o">{</span> 
    <span class="k">val</span> <span class="n">m2</span> <span class="k">=</span> <span class="nc">Evar</span><span class="o">[</span><span class="kt">Nat</span><span class="o">](</span><span class="s">&quot;m&quot;</span><span class="o">);</span> <span class="k">val</span> <span class="n">p2</span> <span class="k">=</span> <span class="nc">Evar</span><span class="o">[</span><span class="kt">Nat</span><span class="o">](</span><span class="s">&quot;p&quot;</span><span class="o">)</span> 
    <span class="o">(</span><span class="n">m</span> <span class="o">=:=</span> <span class="n">Z</span> <span class="o">&amp;</span> <span class="n">n</span> <span class="o">=:=</span> <span class="n">p</span><span class="o">)</span> <span class="o">|</span> 
    <span class="o">(</span><span class="n">m</span> <span class="o">=:=</span> <span class="nc">STerm</span><span class="o">(</span><span class="n">m2</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">=:=</span> <span class="nc">STerm</span><span class="o">(</span><span class="n">p2</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">sum</span><span class="o">(</span><span class="n">m2</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">p2</span><span class="o">))</span> 
  <span class="o">}</span> 
</code></pre> 
</div> 
<p>We can use <code>sum</code> to do addition:</p> 
<div class="highlight"><pre><code class="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Evar</span><span class="o">[</span><span class="kt">Nat</span><span class="o">](</span><span class="s">&quot;x&quot;</span><span class="o">);</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="nc">Evar</span><span class="o">[</span><span class="kt">Nat</span><span class="o">](</span><span class="s">&quot;y&quot;</span><span class="o">)</span> 
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">sum</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">),</span> <span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">)),</span> <span class="n">x</span><span class="o">),</span> <span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> 
<span class="n">res8</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">Nat</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">))))</span> 
</code></pre> 
</div> 
<p>or subtraction:</p> 
<div class="highlight"><pre><code class="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">sum</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">)),</span> <span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">)))),</span> <span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> 
<span class="n">res10</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">Nat</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">))</span> 
 
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">sum</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">),</span> <span class="n">x</span><span class="o">,</span> <span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">)))),</span> <span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> 
<span class="n">res11</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">Nat</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">)))</span> 
</code></pre> 
</div> 
<p>or even to find all the pairs of naturals which sum to 3:</p> 
<div class="highlight"><pre><code class="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">sum</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">)))),</span> <span class="mi">10</span><span class="o">,</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">Nat</span><span class="o">]](</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> 
<span class="n">res14</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Term</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Nat</span><span class="o">]]]</span> <span class="k">=</span> 
  <span class="nc">List</span><span class="o">(</span><span class="n">Z</span> <span class="o">::</span> <span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">)))</span> <span class="o">::</span> <span class="nc">List</span><span class="o">(),</span> 
       <span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">)</span> <span class="o">::</span> <span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">))</span> <span class="o">::</span> <span class="nc">List</span><span class="o">(),</span> 
       <span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">))</span> <span class="o">::</span> <span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">)</span> <span class="o">::</span> <span class="nc">List</span><span class="o">(),</span> 
       <span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">S</span><span class="o">(</span><span class="n">Z</span><span class="o">)))</span> <span class="o">::</span> <span class="n">Z</span> <span class="o">::</span> <span class="nc">List</span><span class="o">())</span> 
</code></pre> 
</div> 
<p>although the printing of <code>Term[List]</code> could be better.</p> 
 
<p>This is only a small taste of the expressivity of Prolog-style logic programming. Again let me recommend <a href="http://www.cs.cmu.edu/~fp/courses/lp/lectures/lp-all.pdf">Frank Pfenning&rsquo;s course notes</a>, which explore the semantics of Prolog in a &ldquo;definitional interpreters&rdquo; style, by gradually refining an interpreter to expose more of the machinery of the language.</p> 
 
<p>See the <a href="https://github.com/jaked/ambassadortothecomputers.blogspot.com/tree/master/_code/scala-logic">full code</a>.</p>
