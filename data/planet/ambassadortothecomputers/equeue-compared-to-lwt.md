---
title: Equeue compared to Lwt
description: 'I feel like taking a break from Camlp4, so in this post I''ll take a
  look at two libraries for asynchronous networking programming in OCaml: ...'
url: http://ambassadortothecomputers.blogspot.com/2009/02/equeue-compared-to-lwt.html
date: 2009-02-10T07:43:00-00:00
preview_image:
authors:
- Jake Donham
source:
---

<p>I feel like taking a break from Camlp4, so in this post I'll take a look at two libraries for asynchronous networking programming in OCaml: <a href="http://projects.camlcity.org/projects/dl/ocamlnet-2.2.9/doc/html-main/Equeue_intro.html">Equeue</a> and <a href="http://www.ocsigen.org/lwt">Lwt</a>. Each provides cooperative multithreading and asynchronous access to networking calls; each has protocol implementations built on top of it (e.g. Nethttpd for Equeue and Ocsigen's HTTP implementation for of Lwt). So why would you want to use one over the other? Let's start with an overview of each.<br/>
</p><b>Equeue</b><br/>
<p>An Equeue <em>event system</em> comprises a queue of events and a set of event handlers. A running event system just pulls events off the queue and passes them to the event handlers. You can think of a group of related handlers as a thread (the thread is blocked until one of its handlers is called; when the handler returns the thread yields) but there is no particular data structure tying them together.<br/>
</p><p>The <code>Unixqueue</code> module specializes Equeue to the case where the source of events is the Unix <code>select</code> call. It adds the idea of <em>resources</em>, which are operations that may cause an event. For example, the operation <code>Wait_in</code> on some file descriptor can cause the event <code>Input_arrived</code> for that descriptor. A resource also has an associated timeout (the <code>Timeout</code> event fires if the timeout is exceeded). <code>Unixqueue</code> also adds a way to group resources and handlers; a group can be removed from the event system with one call, so everything associated with a thread can be cleaned up at once.<br/>
</p><p>On top of the low-level event queue mechanism, Equeue builds <em>engines</em>, which package up some event handlers and some internal state with a particular interface: </p><pre><span class="htmlize-tuareg-font-lock-governing">type</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">t engine_state </span><span class="htmlize-tuareg-font-lock-operator">=</span>
  <span class="htmlize-tuareg-font-lock-operator">[</span> `Working <span class="htmlize-tuareg-font-lock-operator">of</span> int
  <span class="htmlize-tuareg-font-lock-operator">|</span> `Done <span class="htmlize-tuareg-font-lock-operator">of</span> <span class="htmlize-tuareg-font-lock-operator">'</span>t
  <span class="htmlize-tuareg-font-lock-operator">|</span> `Error <span class="htmlize-tuareg-font-lock-operator">of</span> exn
  <span class="htmlize-tuareg-font-lock-operator">|</span> `Aborted
  <span class="htmlize-tuareg-font-lock-operator">]</span>

<span class="htmlize-tuareg-font-lock-governing">class</span> <span class="htmlize-tuareg-font-lock-governing">type</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">[</span> <span class="htmlize-tuareg-font-lock-operator">'</span>t <span class="htmlize-tuareg-font-lock-operator">]</span> engine <span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-tuareg-font-lock-governing">object</span>
  <span class="htmlize-tuareg-font-lock-governing">method</span> <span class="htmlize-function-name">state</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">t engine_state</span>
  <span class="htmlize-tuareg-font-lock-governing">method</span> <span class="htmlize-function-name">abort</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-type">unit </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> unit</span>
  <span class="htmlize-tuareg-font-lock-governing">method</span> <span class="htmlize-function-name">request_notification</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-type">unit </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> bool</span><span class="htmlize-tuareg-font-lock-operator">)</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> unit</span>
  <span class="htmlize-tuareg-font-lock-governing">method</span> <span class="htmlize-function-name">event_system</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-type">Unixqueue.event_system</span>
<span class="htmlize-tuareg-font-lock-governing">end</span>
</pre>An engine runs for a while, then finishes with some value, fails with an exception, or becomes aborted. Code that's interested in the result of an engine can use <code>request_notification</code> to find out when the state of the engine has changed.<br/>
<p>Equeue provides a number of engines for networking tasks (such as connecting to a socket), and also for hooking engines together in various ways. Maybe the most interesting one (when comparing to Lwt at least) is: </p><pre><span class="htmlize-tuareg-font-lock-governing">class</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">['</span>a<span class="htmlize-tuareg-font-lock-operator">,</span> <span class="htmlize-tuareg-font-lock-operator">'</span>b<span class="htmlize-tuareg-font-lock-operator">]</span> <span class="htmlize-variable-name">seq_engine</span> <span class="htmlize-tuareg-font-lock-operator">:</span>
  <span class="htmlize-tuareg-font-lock-operator">'</span>a <span class="htmlize-tuareg-font-lock-operator">#</span>engine <span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
  <span class="htmlize-tuareg-font-lock-operator">('</span>a <span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-tuareg-font-lock-operator">'</span>b <span class="htmlize-tuareg-font-lock-operator">#</span>engine<span class="htmlize-tuareg-font-lock-operator">)</span> <span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
  <span class="htmlize-tuareg-font-lock-operator">['</span>b<span class="htmlize-tuareg-font-lock-operator">]</span> engine
</pre>which feeds the result of one engine into a function that creates another engine. Does this look familiar?<br/>
<b>Lwt</b><br/>
<p>Lwt provides no equivalent to Equeue's low-level event handling. But an Lwt thread is quite similar to an Equeue engine, in that it runs for a while then finishes successfully with a value or fails with an exception (there is no aborted state). However, the type <code>'a Lwt.t</code> of threads returning values of type <code>'a</code> is abstract; to implement your own thread you must build it out of the functions provided by Lwt. Here are some important ones: </p><pre><span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">return </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">fail </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-type">exn </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t</span>
</pre>You create an already-terminated thread with a value or exception with <code>return</code> and <code>fail</code> respectively. (Equeue has <code>epsilon_engine</code> which does essentially the same thing.) <pre><span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">wait </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-type">unit </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">wakeup </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> unit</span>
<span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">wakeup_exn </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> exn </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> unit</span>
</pre>These functions give you a way to make threads that return only after some event occurs. A thread created with <code>wait</code> is blocked until woken either with a value or an exception. Any threads using its value block until it's woken. But how does a thread use another thread's value? <pre><span class="htmlize-tuareg-font-lock-governing">val</span> <span class="htmlize-variable-name">bind </span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">a t </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">('</span><span class="htmlize-type">a </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">b t</span><span class="htmlize-tuareg-font-lock-operator">)</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">'</span><span class="htmlize-type">b t</span>
</pre>This function feeds the result of one thread into a function that creates another thread, just like Equeue's <code>seq_engine</code> above. The important thing is that the value may not be available yet. In that case the function you give as the second argument is added to a notification list and called when the value arrives. This is similar to Equeue's <code>request_notification</code>, except that with Lwt notification is entirely under the hood: asking to be notified and getting the value of the thread are the same operation.<br/>
<p>(Maybe you noticed that the type <code>Lwt.t</code> together with the functions <code>return</code> and <code>bind</code> form a monad. It would appear that the same is true of Equeue's <code>engine</code>, <code>epsilon_engine</code>, and <code>seq_engine</code>, although I haven't checked that they satisfy the monad laws.)<br/>
</p><p>The <code>Lwt_unix</code> module provides a set of Unix I/O functions that match many of the ordinary ones in the <code>Unix</code> module, but return <code>Lwt.t</code> values (i.e. threads). In order to use the value you have to bind the thread, and possibly block until the value arrives.<br/>
</p><b>Comparison</b><br/>
<p>Lwt is a very beautiful library. The monadic interface encourages you to think about interacting threads in terms of values and dependencies, rather than states and callbacks. Lwt code can be very concise, and with the help of <a href="http://www.cas.mcmaster.ca/~carette/pa_monad/">pa_monad</a>, it can look pretty much just like straight-line code. Equeue engines require more machinery to implement (in particular, <code>request_notification</code>, although the <code>engine_mixin</code> class helps with that), and this increased overhead makes it less convenient to use threads in a fine-grained way.<br/>
</p><p>Lwt is particularly nice with exception handling. In most cases, if a thread raises an exception it will be converted to a failing thread, rather than escaping the thread machinery (as would happen in an Equeue engine if you don't explicitly catch the exception). Unfortunately there are places this doesn't work (in order to support constant-space tail calls), which can be surprising.<br/>
</p><p>Equeue, on the other hand, gives you much better low-level control. Lwt gives you the monadic equivalent of a blocking threads interface: you get a <code>read</code> call that blocks until data is ready. Equeue separates notification of events from the actual I/O operations, so if you want to do something other than read when data is ready you can. You can also remove a resource, to indicate that you're no longer interested in its events. With Lwt once a thread is waiting to read, it keeps waiting until data is ready or the channel is aborted (using <code>Lwt_unix.abort</code>). This covers the common case where you want to close the connection on a timeout, but more complicated things are harder. In addition, since you always care about timeouts when doing network programming, it's convenient that Equeue builds them into the resource interface.<br/>
</p><p>Equeue may be more efficient in low-level ways: for instance, if you're going to repeatedly read a socket you can leave the resource and handler in the event system; in Lwt every <code>read</code> adds a new action (the Lwt equivalent of a handler). But I bet this doesn't matter almost all the time.<br/>
</p><b>So which one?</b><br/>
<p>Lwt definitely wins on clarity, simplicity, and concision for higher-level coding. Equeue wins if you need low-level control, or possibly if you need the absolute most performance.<br/>
</p><p>Another factor, however, is that Equeue works with the rest of Ocamlnet, and in particular the ONC RPC implementation and the awesome Netplex server framework. For this reason I've adapted Lwt to run on top of Equeue, in the <a href="http://code.google.com/p/orpc2/source/browse/#svn/trunk/src/lwt-equeue">lwt-equeue</a> library that comes with <a href="http://code.google.com/p/orpc2/">orpc</a>. (I hope to do another orpc release soon with the latest version of lwt-equeue; in the meantime you can try the trunk version.) With lwt-equeue it's straightforward to mix Lwt and Equeue code, so you can use each when it's most appropriate.<br/>
</p><p>(By the way, <a href="http://portal.acm.org/citation.cfm?id=1411304.1411307">J&eacute;r&ocirc;me Vouillon's ML Workshop paper on Lwt</a> is really nice; it explains some tricky details of the implementation.)<br/>
</p><p>Next time back to Camlp4.<br/>
</p>
