---
title: 'Reading Camlp4, part 3: quotations in depth'
description: (I set myself the goal of posting every week, but the latest Skydeck
  release  has kept me busy, and it turned out I didn't understand the fo...
url: http://ambassadortothecomputers.blogspot.com/2009/01/reading-camlp4-part-3-quotations-in.html
date: 2009-01-22T22:18:00-00:00
preview_image:
authors:
- Jake Donham
source:
---

<p>(I set myself the goal of posting every week, but the <a href="http://skydeck.com/blog/announcements/yourcellphoneonline/">latest Skydeck release</a> has kept me busy, and it turned out I didn't understand the following as well as I thought.)<br/>
</p><p>After seeing the examples of Camlp4 quotations in my <a href="http://ambassadortothecomputers.blogspot.com/2009/01/reading-camlp4-part-2-quotations_04.html">last post</a>, you may wonder: </p><ul><li>what are all the quotations (<code>str_item</code>, <code>ctyp</code>, etc.)?</li>
<li>what are all the antiquotations (<code>uid</code>, <code>`str</code>, etc.)?</li>
<li>which antiquotations are allowed where?</li>
</ul>To answer these questions, we're going to look at how quotations are implemented in Camlp4. We'll need to learn a little about Camlp4's extensible parsers, and look at the OCaml parser in Camlp4.<br/>
<b>Parsing OCaml</b><br/>
<p>A small complication is that there is more than one concrete syntax for OCaml in Camlp4: the <em>original</em> (i.e. normal OCaml syntax) and <em>revised</em> syntaxes. The original syntax parser is given as an extension of the revised syntax one. So we'll begin in <a href="http://camlcvs.inria.fr/cgi-bin/cvsweb/~checkout~/ocaml/camlp4/Camlp4Parsers/Camlp4OCamlRevisedParser.ml?content-type=text/plain">camlp4/Camlp4Parsers/Camlp4OCamlRevisedParser.ml</a> (line 588 in the 3.10.2 source):<br/>
</p><pre>    <span class="htmlize-variable-name">expr</span><span class="htmlize-tuareg-font-lock-operator">:</span>
      <span class="htmlize-tuareg-font-lock-operator">[</span> <span class="htmlize-string">&quot;top&quot;</span> RIGHTA
        <span class="htmlize-tuareg-font-lock-operator">[</span> <span class="htmlize-comment">(* ... *)</span>
        <span class="htmlize-tuareg-font-lock-operator">|</span> <span class="htmlize-string">&quot;if&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span> e1 <span class="htmlize-tuareg-font-lock-operator">=</span> SELF<span class="htmlize-tuareg-font-lock-operator">;</span> <span class="htmlize-string">&quot;then&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span> e2 <span class="htmlize-tuareg-font-lock-operator">=</span> SELF<span class="htmlize-tuareg-font-lock-operator">;</span> <span class="htmlize-string">&quot;else&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span> e3 <span class="htmlize-tuareg-font-lock-operator">=</span> SELF <span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
            <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">expr</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-keyword">if</span> <span class="htmlize-tuareg-font-lock-operator">$</span>e1<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-keyword">then</span> <span class="htmlize-tuareg-font-lock-operator">$</span>e2<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-keyword">else</span> <span class="htmlize-tuareg-font-lock-operator">$</span>e3<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span>
</pre>You can read the parser more or less as a BNF grammar. This code defines a nonterminal <code>expr</code> by giving a bunch of cases. The cases are grouped together into <em>levels</em>, which can be labeled and given an associativity (that's what <code>&quot;top&quot;</code> and <code>NONASSOC</code> are). Levels are used to indicate the precedence of operators, and also to provide hooks into the parser for extending it; for our purpose here you can skip over them.<br/>
<p>You can read a case like a pattern match: match the stuff to the left of the arrow, return the stuff to the right. (What's being matched is a stream of tokens from the lexer.) A parser pattern can contain literal strings like <code>&quot;if&quot;</code>, backquoted data constructors like <code>`INT</code> (which can carry additional data), nonterminals, and some special keywords like <code>SELF</code>. You can bind variables using ordinary pattern-matching syntax within token literals, and use <code>x = y</code> syntax to bind the result of a call to a nonterminal.<br/>
</p><p>The right side is a piece of AST representing what was parsed, and in most cases it is given <em>as a quotation</em>. This is pretty confusing, because often the left and right sides of a case look very similar, and you can't tell what AST node is produced. However, it gives us lots of examples of tricky quotations, and since we have already seen how to expand quotations we can deal with it. (If you're curious how Camlp4 is written using itself see <a href="http://camlcvs.inria.fr/cgi-bin/cvsweb/~checkout~/ocaml/camlp4/boot/">camlp4/boot</a>.)<br/>
</p><p>Focusing on the <code>if</code> case: the keywords <code>if</code>, <code>then</code>, and <code>else</code> are parsed with an expression after each (at least we know that's the syntax of normal OCaml, and that gives a clue to what <code>SELF</code> means: parse the current nonterminal); the expressions are bound to a variables; then the pieces are put together into an <code>ExIfe</code> AST node.<br/>
</p><p>(Some other special keywords you'll see are <code>OPT</code>, which makes the next item optional, and <code>LIST0</code>/<code>LIST1</code>, which parse a list of items separated by the token after <code>SEP</code>. <code>LIST1</code> means there must be at least one item.)<br/>
</p><p>OCaml allows you to leave off the <code>else</code> part; where is the code for that? Turns out this is not allowed in revised syntax, and the original syntax overrides this part of the parser. Take a look at <a href="http://camlcvs.inria.fr/cgi-bin/cvsweb/~checkout~/ocaml/camlp4/Camlp4Parsers/Camlp4OCamlParser.ml?content-type=text/plain">camlp4/Camlp4Parsers/Camlp4OCamlParser.ml</a> (line 292):<br/>
</p><pre>    <span class="htmlize-variable-name">expr</span><span class="htmlize-tuareg-font-lock-operator">:</span> <span class="htmlize-type">LEVEL </span><span class="htmlize-string">&quot;top&quot;</span>
      <span class="htmlize-tuareg-font-lock-operator">[</span> <span class="htmlize-tuareg-font-lock-operator">[</span> <span class="htmlize-comment">(* ... *)</span>
        <span class="htmlize-tuareg-font-lock-operator">|</span> <span class="htmlize-string">&quot;if&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span> e1 <span class="htmlize-tuareg-font-lock-operator">=</span> SELF<span class="htmlize-tuareg-font-lock-operator">;</span> <span class="htmlize-string">&quot;then&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span> e2 <span class="htmlize-tuareg-font-lock-operator">=</span> expr LEVEL <span class="htmlize-string">&quot;top&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span>
          <span class="htmlize-string">&quot;else&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span> e3 <span class="htmlize-tuareg-font-lock-operator">=</span> expr LEVEL <span class="htmlize-string">&quot;top&quot;</span> <span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
            <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">expr</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-keyword">if</span> <span class="htmlize-tuareg-font-lock-operator">$</span>e1<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-keyword">then</span> <span class="htmlize-tuareg-font-lock-operator">$</span>e2<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-keyword">else</span> <span class="htmlize-tuareg-font-lock-operator">$</span>e3<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span>
        <span class="htmlize-tuareg-font-lock-operator">|</span> <span class="htmlize-string">&quot;if&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span> e1 <span class="htmlize-tuareg-font-lock-operator">=</span> SELF<span class="htmlize-tuareg-font-lock-operator">;</span> <span class="htmlize-string">&quot;then&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span> e2 <span class="htmlize-tuareg-font-lock-operator">=</span> expr LEVEL <span class="htmlize-string">&quot;top&quot;</span> <span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
            <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">expr</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-keyword">if</span> <span class="htmlize-tuareg-font-lock-operator">$</span>e1<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-keyword">then</span> <span class="htmlize-tuareg-font-lock-operator">$</span>e2<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-keyword">else</span> <span class="htmlize-tuareg-font-lock-operator">()</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span>
</pre>(Notice how the <code>expr</code> definition is qualified with the level in the revised grammar where it should slot in.)<br/>
<b>Quotations and antiquotations</b><br/>
<p>Hopefully that is enough about parsing to muddle through; let's move on to quotations. Here's another piece of the revised parser (line 670)--these are still cases of <code>expr</code>:<br/>
</p><pre>  <span class="htmlize-tuareg-font-lock-operator">[</span> `QUOTATION x <span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-type">Quotation</span>.expand _loc x <span class="htmlize-type">Quotation</span>.<span class="htmlize-type">DynAst</span>.expr_tag
</pre>The <code>`QUOTATION</code> token contains a record including the body of the quotation and the tag. The record is passed off to the <code>Quotation</code> module to be expanded. The actual expansion happens in <a href="http://camlcvs.inria.fr/cgi-bin/cvsweb/~checkout~/ocaml/camlp4/Camlp4Parsers/Camlp4QuotationCommon.ml?content-type=text/plain">camlp4/Camlp4Parsers/Camlp4QuotationCommon.ml</a>. Looking to the bottom of that file, there are several lines like:<br/>
<pre>  add_quotation <span class="htmlize-string">&quot;sig_item&quot;</span> sig_item_quot <span class="htmlize-type">ME</span>.meta_sig_item <span class="htmlize-type">MP</span>.meta_sig_item<span class="htmlize-tuareg-font-lock-operator">;</span>
</pre>This installs a quotation expander for the <code>sig_item</code> tag. The expander parses the quotation starting at the <code>sig_item_quot</code> nonterminal in the parser, then runs the result through the antiquotation expander (see below). (The last two arguments to <code>add_quotation</code> have to do with the context where a quotation appears: inside a pattern you get <code>PaFoo</code> nodes while inside an expression you get <code>ExBar</code> nodes.) So we can answer one of the questions posed at the beginning: what are all the quotation tags? We can see here that there is a quotation for each type in <a href="http://camlcvs.inria.fr/cgi-bin/cvsweb/~checkout~/ocaml/camlp4/Camlp4Parsers/?content-type=text/plain">camlp4/Camlp4/Camlp4Ast.partial.ml</a>.<br/>
<p>Now let's look at antiquotations, which are more complicated (line 671):<br/>
</p><pre>        <span class="htmlize-tuareg-font-lock-operator">|</span> `ANTIQUOT <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-string">&quot;exp&quot;</span><span class="htmlize-tuareg-font-lock-operator">|</span><span class="htmlize-string">&quot;&quot;</span><span class="htmlize-tuareg-font-lock-operator">|</span><span class="htmlize-string">&quot;anti&quot;</span> <span class="htmlize-keyword">as</span> n<span class="htmlize-tuareg-font-lock-operator">)</span> s <span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
            <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">expr</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-tuareg-font-lock-operator">$</span>anti<span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-type">mk_anti </span><span class="htmlize-tuareg-font-lock-operator">~</span><span class="htmlize-variable-name">c</span><span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-string">&quot;expr&quot;</span> n s<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span>
</pre>The <code>`ANTIQUOT</code> token contains the tag and the body again (and the parser can choose a case based on the tag). The <code>anti</code> antiquotation creates a special AST node to hold the body of the antiquotation; each type in the AST has a constructor (<code>ExAnt</code>, <code>TyAnt</code>, etc.) for this purpose. The <code>mk_anti</code> function adds another tag, which is not always the same as the one we parsed; the <code>~c</code> argument adds a suffix giving the context where the antiquotation appeared.<br/>
<p>There are two places where antiquotations are interpreted. First, in <a href="http://camlcvs.inria.fr/cgi-bin/cvsweb/~checkout~/ocaml/camlp4/Camlp4Parsers/Camlp4QuotationCommon.ml?content-type=text/plain">camlp4/Camlp4Parsers/Camlp4QuotationCommon.ml</a> (line 89):<br/>
</p><pre>            <span class="htmlize-tuareg-font-lock-operator">[</span> <span class="htmlize-string">&quot;`int&quot;</span> <span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">expr</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> string_of_int <span class="htmlize-tuareg-font-lock-operator">$</span>e<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span>
</pre>This is one of a bunch of cases in a map over the syntax tree. It handles antiquotations like <code><span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">expr</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-tuareg-font-lock-operator">$</span>`<span class="htmlize-variable-name">int</span><span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-type">5</span><span class="htmlize-tuareg-font-lock-operator">$</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span></code>, which turns into an <code>ExInt</code>. You can also see cases here for the <code>anti</code> antiquotations, and some things to do with <code>list</code> antiquotations we haven't seen yet (more on this below).<br/>
<p>Things that don't match these cases are handled when the AST is pretty-printed. Let's look at <a href="http://camlcvs.inria.fr/cgi-bin/cvsweb/~checkout~/ocaml/camlp4/Camlp4/Printers/OCaml.ml?content-type=text/plain">camlp4/Camlp4/Printers/OCaml.ml</a> (line 510):<br/>
</p><pre>    <span class="htmlize-tuareg-font-lock-operator">|</span> <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">expr</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-tuareg-font-lock-operator">$</span>int<span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-type">s</span><span class="htmlize-tuareg-font-lock-operator">$</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> o</span><span class="htmlize-tuareg-font-lock-operator">#</span>numeric f s <span class="htmlize-string">&quot;&quot;</span>
</pre>This case handles antiquotations like <code><span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">expr</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-tuareg-font-lock-operator">$</span>int<span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-string">&quot;5&quot;</span><span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span></code>. Again, this produces an <code>ExInt</code>, but you give it a string instead of an int.<br/>
<b>What we have learned</b><br/>
<p>Teaching a person to fish is fine, unless that person starves while trying to finish their PhD in theoretical pescatology. But I hope that you can see how we might go about answering the remaining questions--what are all the antiquotations, and where are they allowed--by examining all the <code>`ANTIQUOT</code> cases in the parser and puzzling out where they get expanded.<br/>
</p><p>Let's look at a particular example, by way of addressing the <a href="http://ambassadortothecomputers.blogspot.com/2009/01/reading-camlp4-part-2-quotations_04.html#comments">comment</a> Nicolas Pouillard (aka Ertai) made on the last post. He points out that the final <code>McOr</code> in <code>of_string</code> can go outside the antiquotation. How could we learn this from the Camlp4 code? Let's find where the antiquotation is expanded, starting at the point where the <code>function</code> keyword is parsed (<a href="http://camlcvs.inria.fr/cgi-bin/cvsweb/~checkout~/ocaml/camlp4/Camlp4Parsers/Camlp4OCamlParser.ml?content-type=text/plain">Camlp4OCamlParser.ml</a> line 299):<br/>
</p><pre>  <span class="htmlize-tuareg-font-lock-operator">|</span> <span class="htmlize-string">&quot;function&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span> a <span class="htmlize-tuareg-font-lock-operator">=</span> match_case <span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
      <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">expr</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-keyword">fun</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">[</span> <span class="htmlize-tuareg-font-lock-operator">$</span>a<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">]</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span>
</pre>(the right side is revised syntax) which uses <code>match_case</code> (line 350):<br/>
<pre>    <span class="htmlize-variable-name">match_case</span><span class="htmlize-tuareg-font-lock-operator">:</span>
      <span class="htmlize-tuareg-font-lock-operator">[</span> <span class="htmlize-tuareg-font-lock-operator">[</span> OPT <span class="htmlize-string">&quot;|&quot;</span><span class="htmlize-tuareg-font-lock-operator">;</span> l <span class="htmlize-tuareg-font-lock-operator">=</span> LIST1 match_case0 SEP <span class="htmlize-string">&quot;|&quot;</span> <span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-type">Ast</span>.mcOr_of_list l <span class="htmlize-tuareg-font-lock-operator">]</span> <span class="htmlize-tuareg-font-lock-operator">]</span>
</pre>You might think that <code>match_case0</code> parses a single case, but let's check (<a href="http://camlcvs.inria.fr/cgi-bin/cvsweb/~checkout~/ocaml/camlp4/Camlp4Parsers/Camlp4OCamlRevisedParser.ml?content-type=text/plain">Camlp4OCamlRevisedParser.ml</a> line 778):<br/>
<pre>    <span class="htmlize-variable-name">match_case0</span><span class="htmlize-tuareg-font-lock-operator">:</span>
      <span class="htmlize-tuareg-font-lock-operator">[</span> <span class="htmlize-tuareg-font-lock-operator">[</span> `ANTIQUOT <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-string">&quot;match_case&quot;</span><span class="htmlize-tuareg-font-lock-operator">|</span><span class="htmlize-string">&quot;list&quot;</span> <span class="htmlize-keyword">as</span> n<span class="htmlize-tuareg-font-lock-operator">)</span> s <span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
            <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">match_case</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-tuareg-font-lock-operator">$</span>anti<span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-type">mk_anti </span><span class="htmlize-tuareg-font-lock-operator">~</span><span class="htmlize-variable-name">c</span><span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-string">&quot;match_case&quot;</span> n s<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span>
        <span class="htmlize-tuareg-font-lock-operator">|</span> `ANTIQUOT <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-string">&quot;&quot;</span><span class="htmlize-tuareg-font-lock-operator">|</span><span class="htmlize-string">&quot;anti&quot;</span> <span class="htmlize-keyword">as</span> n<span class="htmlize-tuareg-font-lock-operator">)</span> s <span class="htmlize-tuareg-font-lock-operator">-&gt;</span>
            <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">match_case</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-tuareg-font-lock-operator">$</span>anti<span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-type">mk_anti </span><span class="htmlize-tuareg-font-lock-operator">~</span><span class="htmlize-variable-name">c</span><span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-string">&quot;match_case&quot;</span> n s<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span>
</pre>We're interested in the second case for the moment: here's the antiquotation with no tag used in <code>of_string</code>. So the list of cases is returned by <code>match_case0</code> (as an <code>McAnt</code> with <code>match_case</code> as its tag) and more cases can be parsed following it.<br/>
<p>(Now we can see a justification for a puzzling design decision in the AST: instead of collecting match cases in a list, it collects them with <code>McOr</code> nodes. Many arrangements of <code>McOr</code> nodes correspond to the same list of cases. As the above possibility shows, this is useful: an antiquotation can return zero, one, or several match cases, and we don't have to worry about splicing them into the list. On the other hand, it makes consuming the AST a little more complicated.)<br/>
</p><p>We can go one step further: if we use the <code>list</code> antiquotation, the first case in <code>match_case0</code> returns an antiquotation with tag <code>listmatch_case</code>, and we get the following expansion (<a href="http://camlcvs.inria.fr/cgi-bin/cvsweb/~checkout~/ocaml/camlp4/Camlp4Parsers/Camlp4QuotationCommon.ml?content-type=text/plain">Camlp4QuotationCommon.ml</a> line 117):<br/>
</p><pre>            <span class="htmlize-tuareg-font-lock-operator">|</span> <span class="htmlize-string">&quot;listmatch_case&quot;</span> <span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">expr</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-type">Ast</span>.mcOr_of_list <span class="htmlize-tuareg-font-lock-operator">$</span>e<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;</span>
</pre>So our final <code>of_string</code> becomes: <pre><span class="htmlize-tuareg-font-lock-governing">let</span> <span class="htmlize-function-name">of_string</span><span class="htmlize-variable-name"> </span><span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-keyword">function</span>
    <span class="htmlize-tuareg-font-lock-operator">$</span>list<span class="htmlize-tuareg-font-lock-operator">:</span>
      <span class="htmlize-type">List</span>.map
        <span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-keyword">fun</span> <span class="htmlize-variable-name">c </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">match_case</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-tuareg-font-lock-operator">$</span>`<span class="htmlize-variable-name">str</span><span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-type">c</span><span class="htmlize-tuareg-font-lock-operator">$</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">$</span><span class="htmlize-type">uid</span><span class="htmlize-tuareg-font-lock-operator">:</span>c<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">&gt;&gt;)</span>
        cons<span class="htmlize-tuareg-font-lock-operator">$</span>
  <span class="htmlize-tuareg-font-lock-operator">|</span> _ <span class="htmlize-tuareg-font-lock-operator">-&gt;</span> invalid_arg <span class="htmlize-string">&quot;bad string&quot;</span>
</pre>Can we do something similar with the generation of the variant type? No, as it turns out. In the revised syntax, the arms of a variant are given inside square brackets, so we can say: <pre><span class="htmlize-tuareg-font-lock-governing">type</span> <span class="htmlize-type">t </span><span class="htmlize-tuareg-font-lock-operator">=</span> <span class="htmlize-tuareg-font-lock-operator">[</span> <span class="htmlize-tuareg-font-lock-operator">$</span>list<span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-type">List.map </span><span class="htmlize-tuareg-font-lock-operator">(</span><span class="htmlize-keyword">fun</span> <span class="htmlize-variable-name">c </span><span class="htmlize-tuareg-font-lock-operator">-&gt;</span> <span class="htmlize-tuareg-font-lock-operator">&lt;:</span><span class="htmlize-type">ctyp</span><span class="htmlize-tuareg-font-lock-operator">&lt;</span> <span class="htmlize-tuareg-font-lock-operator">$</span>uid<span class="htmlize-tuareg-font-lock-operator">:</span><span class="htmlize-type">c</span><span class="htmlize-tuareg-font-lock-operator">$</span><span class="htmlize-type"> </span><span class="htmlize-tuareg-font-lock-operator">&gt;&gt;)</span> cons<span class="htmlize-tuareg-font-lock-operator">$</span> <span class="htmlize-tuareg-font-lock-operator">]</span>
</pre>But in the original syntax, without at least one constructor to make clear that we're defining a variant, there's no context to interpret a list, and this is reflected in the parser, which doesn't allow a <code>list</code> antiquotation there. This kind of problem is apparently why the revised syntax was introduced.<br/>
<p>So far I've talked only about generating OCaml code; next time I'll cover how to use Camlp4 to consume OCaml, and build a simple code analysis tool.<br/>
</p>
