---
title: Implementing an Echo Server in Coq with coqffi.1.0.0
description: In this article, we will demonstrate how coqffi can be used to implement
  an echo server, i.e., a TCP server which sends back any input it receives from its
  clients.
url: https://soap.coffee/~lthms/posts/CoqffiEcho.html
date: 2020-12-10T00:00:00-00:00
preview_image: https://soap.coffee/~lthms/img/thinking.png
authors:
- "Thomas Letan\u2019s Blog"
source:
---


        
        <h1>Implementing an Echo Server in Coq with <code class="hljs">coqffi.1.0.0</code></h1><div><span class="icon"><svg><use href="/~lthms/img/icons.svg#tag"></use></svg></span>&nbsp;<a href="https://soap.coffee/~lthms/tags/coq.html" marked="" class="tag">coq</a> <span class="icon"><svg><use href="/~lthms/img/icons.svg#tag"></use></svg></span>&nbsp;<a href="https://soap.coffee/~lthms/tags/ocaml.html" marked="" class="tag">ocaml</a> <span class="icon"><svg><use href="/~lthms/img/icons.svg#tag"></use></svg></span>&nbsp;<a href="https://soap.coffee/~lthms/tags/coqffi.html" marked="" class="tag">coqffi</a> </div>
<p>In this article, we will demonstrate how <code class="hljs">coqffi</code> can be used to
implement an echo server, <em>i.e.</em>, a TCP server which sends back any
input it receives from its clients.  In addition to <code class="hljs">coqffi</code>, you will need to
install <code class="hljs">coq-simple-io</code>.  The latter is available in the <a href="https://github.com/coq/opam-coq-archive" marked=""><code class="hljs">released</code> repository
of the Opam Coq Archive&nbsp;<span class="icon"><svg><use href="/~lthms/img/icons.svg#github"></use></svg></span></a>.</p>
<pre><code class="hljs language-bash">opam install coq-coqffi coq-simple-io
</code></pre>
<p>Besides,  you can download <a href="https://soap.coffee/~lthms/files/coqffi-tutorial.tar.gz" marked="">the source tree presented in this
article</a> if you want to try to read the source
directly, or modify it to your taste.</p>
<h2>Project Layout</h2>
<p>Before diving too much into the implementation of our echo server, we
first give an overview of the resulting project’s layout. Since we aim
at implementing a program, we draw our inspiration from the idiomatic
way of organizing a OCaml project.</p>
<p>We have three directories at the root of the project.</p>
<ul>
<li><strong><code class="hljs">ffi/</code> contains the low-level OCaml code:</strong>
It provides an OCaml library (<code class="hljs">ffi</code>), and a Coq theory (<code class="hljs language-coq">FFI</code>) which
gathers the FFI modules generated by <code class="hljs">coqffi</code>.</li>
<li><strong><code class="hljs">src/</code> contains the Coq implementation of our echo server:</strong> It provides a
Coq theory (<code class="hljs language-coq">Echo</code>) which depends on the <code class="hljs language-coq">FFI</code> theory the
<code class="hljs language-coq">SimpleIO</code> theory of <code class="hljs">coq-simple~io</code>. This theory provides the
implementation of our echo server in Coq.</li>
<li><strong><code class="hljs">bin/</code> contains the pieces of code to get an executable program:</strong> It
contains a Coq module (<code class="hljs">echo.v</code>) which configures and uses the extraction
mechanism to generate an OCaml module (<code class="hljs">echo.ml</code>). This OCaml module can be
compiled to get an executable program.</li>
</ul>
<p>Note that we could have decided to only have one Coq theory. We could
also have added a fourth directory (<code class="hljs">theories/</code>) for formal
verification specific code, but this is out of the scope of this
tutorial.</p>
<p>Overall, we use <code class="hljs">dune</code> to compile and compose the different parts of
the echo server. <code class="hljs">dune</code> has a native —yet unstable at the time of
writing— support for building Coq projects, with very convenient
stanzas like <code class="hljs">coq.theory</code> and <code class="hljs">coq.extraction</code>.</p>
<p>The following graph summarizes the dependencies between each component
(plain arrows symbolize software dependencies).</p>
<p></p><figure><img src="https://soap.coffee/~lthms/img/echo-deps.svg" alt="The echo server dependy graph"><figcaption><p>The echo server dependency graph. Dashed boxes are generated.</p></figcaption></figure><p></p>
<p>We enable Coq-related stanza with <code class="hljs language-lisp">(<span class="hljs-name">using</span> coq <span class="hljs-number">0.2</span>)</code> in the
<code class="hljs language-dune">dune-project</code>. file.</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">lang</span> dune <span class="hljs-number">2.7</span>)
(<span class="hljs-name">using</span> coq <span class="hljs-number">0.2</span>)
</code></pre>
<p>The rest of this tutorial proceeds by diving into each directory.</p>
<h2>FFI Bindings</h2>
<p>Our objective is to implement an echo server, <em>i.e.</em>, a server which
(1) accepts incoming connections, and (2) sends back any incoming
messages. We will consider two classes of effects. One is related to
creating and manipulating TCP sockets. The other is dedicated to
process management, more precisely to be able to fork when receiving
incoming connections.</p>
<p>Therefore, the <code class="hljs">ffi</code> library will provide two modules. Likewise, the
<code class="hljs language-coq">FFI</code> theory will provide two analogous modules generated by <code class="hljs">coqffi</code>.</p>
<p>In the <code class="hljs">ffi/</code> directory, we add the following stanza to the <code class="hljs">dune</code> file.</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">library</span>
  (<span class="hljs-name">name</span> ffi)
  (<span class="hljs-name">libraries</span> unix))
</code></pre>
<p><code class="hljs">dune</code> will look for any <code class="hljs">.ml</code> and <code class="hljs">.mli</code> files within the directory and will
consider they belong to the <code class="hljs">ffi</code> library. We use the
<a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html" marked=""><code class="hljs">unix</code>&nbsp;<span class="icon"><svg><use href="/~lthms/img/icons.svg#external-link"></use></svg></span></a> library
to implement the features we are looking for.</p>
<p>Then, we add the following stanza to the <code class="hljs">dune</code> file of the <code class="hljs">ffi/</code>
directory.</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">coq</span>.theory
  (<span class="hljs-name">name</span> FFI))
</code></pre>
<p>This tells <code class="hljs">dune</code> to look for <code class="hljs">.v</code> file within the <code class="hljs">ffi/</code> directory,
in order to build them with Coq.  A nice feature of <code class="hljs">dune</code> is that if we
automatically generate Coq files, they will be automatically “attached” to this
theory.</p>
<h3>Sockets</h3>
<p>Sockets are boring. The following OCaml module interface provides the
necessary type and functions to manipulate them.</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">type</span> socket_descr

<span class="hljs-keyword">val</span> open_socket : <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">int</span> -&gt; socket_descr
<span class="hljs-keyword">val</span> listen : socket_descr -&gt; <span class="hljs-built_in">unit</span>
<span class="hljs-keyword">val</span> recv : socket_descr -&gt; <span class="hljs-built_in">string</span>
<span class="hljs-keyword">val</span> send : socket_descr -&gt; <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">int</span>
<span class="hljs-keyword">val</span> accept_connection : socket_descr -&gt; socket_descr
<span class="hljs-keyword">val</span> close_socket : socket_descr -&gt; <span class="hljs-built_in">unit</span>
</code></pre>
<p>Our focus is how to write the interface modules for <code class="hljs">coqffi</code>. Since the object
of this tutorial is not the implementation of an echo server in itself, the
implementation details of the <code class="hljs">ffi</code> library will not be discussed, but is
provided at the end of this article.</p>
<p><code class="hljs">dune</code> generates <code class="hljs">.cmi</code> files for the <code class="hljs">.mli</code> files of our library, and
provides the necessary bits to easily locate them. Besides, the
<code class="hljs">action</code> stanza can be used here to tell to <code class="hljs">dune</code> how to generate the
module <code class="hljs">Socket.v</code> from <code class="hljs">file.cmi</code>. We add the following entry to
<code class="hljs">ffi/dune</code>.</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">rule</span>
  (<span class="hljs-name">target</span> Socket.v)
  (<span class="hljs-name">action</span> (<span class="hljs-name">run</span> coqffi %{cmi<span class="hljs-symbol">:socket</span>} -o %{target})))
</code></pre>
<p>We call <code class="hljs">coqffi</code> without any feature-related command-line argument,
which means only the <code class="hljs">simple-io</code> feature is enabled. As a consequence,
the <code class="hljs">socket_descr</code> type is axiomatized in Coq, and in addition to a
<code class="hljs">MonadSocket</code> monad, <code class="hljs">coqffi</code> will generate an instance for this monad
for the <code class="hljs">IO</code> monad of <code class="hljs">coq-simple-io</code>.</p>
<p>The stanza generates the following Coq module.</p>
<pre><code class="hljs language-coq"><span class="hljs-comment">(* This file has been generated by coqffi. *)</span>

<span class="hljs-keyword">Set</span> <span class="hljs-keyword">Implicit</span> <span class="hljs-keyword">Arguments</span>.
<span class="hljs-keyword">Unset</span> Strict <span class="hljs-keyword">Implicit</span>.
<span class="hljs-keyword">Set</span> Contextual <span class="hljs-keyword">Implicit</span>.
<span class="hljs-keyword">Generalizable</span> <span class="hljs-keyword">All</span> <span class="hljs-keyword">Variables</span>.
<span class="hljs-keyword">Close</span> <span class="hljs-keyword">Scope</span> nat_scope.

<span class="hljs-keyword">From</span> CoqFFI <span class="hljs-keyword">Require</span> <span class="hljs-keyword">Export</span> <span class="hljs-keyword">Extraction</span>.
<span class="hljs-keyword">From</span> SimpleIO <span class="hljs-keyword">Require</span> <span class="hljs-keyword">Import</span> IO_Monad.

<span class="hljs-keyword">Axiom</span> socket_descr : <span class="hljs-keyword">Type</span>.

<span class="hljs-keyword">Extract</span> <span class="hljs-keyword">Constant</span> socket_descr =&gt; <span class="hljs-string">"Ffi.Socket.socket_descr"</span>.

<span class="hljs-comment">(** * Impure Primitives *)</span>

<span class="hljs-comment">(** ** Monad Definition *)</span>

<span class="hljs-keyword">Class</span> MonadSocket (m : <span class="hljs-keyword">Type</span> -&gt; <span class="hljs-keyword">Type</span>) : <span class="hljs-keyword">Type</span> :=
  { open_socket : string -&gt; i63 -&gt; m socket_descr
  ; listen : socket_descr -&gt; m unit
  ; recv : socket_descr -&gt; m string
  ; send : socket_descr -&gt; string -&gt; m i63
  ; accept_connection : socket_descr -&gt; m socket_descr
  ; close_socket : socket_descr -&gt; m unit
  }.

<span class="hljs-comment">(** ** [IO] Instance *)</span>

<span class="hljs-keyword">Axiom</span> io_open_socket : string -&gt; i63 -&gt; IO socket_descr.
<span class="hljs-keyword">Axiom</span> io_listen : socket_descr -&gt; IO unit.
<span class="hljs-keyword">Axiom</span> io_recv : socket_descr -&gt; IO string.
<span class="hljs-keyword">Axiom</span> io_send : socket_descr -&gt; string -&gt; IO i63.
<span class="hljs-keyword">Axiom</span> io_accept_connection : socket_descr -&gt; IO socket_descr.
<span class="hljs-keyword">Axiom</span> io_close_socket : socket_descr -&gt; IO unit.

<span class="hljs-keyword">Extract</span> <span class="hljs-keyword">Constant</span> io_open_socket
  =&gt; <span class="hljs-string">"(fun x1 x2 k__ -&gt; k__ ((Ffi.Socket.open_socket x1 x2)))"</span>.
<span class="hljs-keyword">Extract</span> <span class="hljs-keyword">Constant</span> io_listen =&gt; <span class="hljs-string">"(fun x1 k__ -&gt; k__ ((Ffi.Socket.listen x1)))"</span>.
<span class="hljs-keyword">Extract</span> <span class="hljs-keyword">Constant</span> io_recv =&gt; <span class="hljs-string">"(fun x1 k__ -&gt; k__ ((Ffi.Socket.recv x1)))"</span>.
<span class="hljs-keyword">Extract</span> <span class="hljs-keyword">Constant</span> io_send
  =&gt; <span class="hljs-string">"(fun x1 x2 k__ -&gt; k__ ((Ffi.Socket.send x1 x2)))"</span>.
<span class="hljs-keyword">Extract</span> <span class="hljs-keyword">Constant</span> io_accept_connection
  =&gt; <span class="hljs-string">"(fun x1 k__ -&gt; k__ ((Ffi.Socket.accept_connection x1)))"</span>.
<span class="hljs-keyword">Extract</span> <span class="hljs-keyword">Constant</span> io_close_socket
  =&gt; <span class="hljs-string">"(fun x1 k__ -&gt; k__ ((Ffi.Socket.close_socket x1)))"</span>.

<span class="hljs-keyword">Instance</span> IO_MonadSocket : MonadSocket IO :=
  { open_socket := io_open_socket
  ; listen := io_listen
  ; recv := io_recv
  ; send := io_send
  ; accept_connection := io_accept_connection
  ; close_socket := io_close_socket
  }.

<span class="hljs-comment">(* The generated file ends here. *)</span>
</code></pre>
<h3>Process Management</h3>
<p>In order to avoid a client to block the server by connecting to it
without sending anything, we can fork a new process for each client.</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">type</span> identity = <span class="hljs-type">Parent</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span> | <span class="hljs-type">Child</span>

<span class="hljs-keyword">val</span> fork : <span class="hljs-built_in">unit</span> -&gt; identity
</code></pre>
<p>This time, the <code class="hljs">proc.mli</code> module interface introduces a transparent
type, /i.e./, it also provides its definition. This is a good use case
for the <code class="hljs">transparent-types</code> feature of <code class="hljs">coqffi</code>. In the stanza for
generating <code class="hljs">Proc.v</code>, we enable it with the <code class="hljs">-ftransparent-types</code>
command-line argument, like this.</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">rule</span>
  (<span class="hljs-name">target</span> Proc.v)
  (<span class="hljs-name">action</span> (<span class="hljs-name">run</span> coqffi -ftransparent-types %{cmi<span class="hljs-symbol">:proc</span>} -o %{target})))
</code></pre>
<p>which generates the following Coq module.</p>
<pre><code class="hljs language-coq"><span class="hljs-comment">(* This file has been generated by coqffi. *)</span>

<span class="hljs-keyword">Set</span> <span class="hljs-keyword">Implicit</span> <span class="hljs-keyword">Arguments</span>.
<span class="hljs-keyword">Unset</span> Strict <span class="hljs-keyword">Implicit</span>.
<span class="hljs-keyword">Set</span> Contextual <span class="hljs-keyword">Implicit</span>.
<span class="hljs-keyword">Generalizable</span> <span class="hljs-keyword">All</span> <span class="hljs-keyword">Variables</span>.
<span class="hljs-keyword">Close</span> <span class="hljs-keyword">Scope</span> nat_scope.

<span class="hljs-keyword">From</span> CoqFFI <span class="hljs-keyword">Require</span> <span class="hljs-keyword">Export</span> <span class="hljs-keyword">Extraction</span>.
<span class="hljs-keyword">From</span> SimpleIO <span class="hljs-keyword">Require</span> <span class="hljs-keyword">Import</span> IO_Monad.

<span class="hljs-keyword">Inductive</span> identity : <span class="hljs-keyword">Type</span> :=
| <span class="hljs-type">Parent</span> (x0 : i63) : identity
| <span class="hljs-type">Child</span> : identity.

<span class="hljs-keyword">Extract</span> <span class="hljs-keyword">Inductive</span> identity =&gt; <span class="hljs-string">"Ffi.Proc.identity"</span>
  [ <span class="hljs-string">"Ffi.Proc.Parent"</span> <span class="hljs-string">"Ffi.Proc.Child"</span> ].

<span class="hljs-comment">(** * Impure Primitives *)</span>

<span class="hljs-comment">(** ** Monad Definition *)</span>

<span class="hljs-keyword">Class</span> MonadProc (m : <span class="hljs-keyword">Type</span> -&gt; <span class="hljs-keyword">Type</span>) : <span class="hljs-keyword">Type</span> := { fork : unit -&gt; m identity
                                             }.

<span class="hljs-comment">(** ** [IO] Instance *)</span>

<span class="hljs-keyword">Axiom</span> io_fork : unit -&gt; IO identity.

<span class="hljs-keyword">Extract</span> <span class="hljs-keyword">Constant</span> io_fork =&gt; <span class="hljs-string">"(fun x1 k__ -&gt; k__ ((Ffi.Proc.fork x1)))"</span>.

<span class="hljs-keyword">Instance</span> IO_MonadProc : MonadProc IO := { fork := io_fork
                                        }.

<span class="hljs-comment">(* The generated file ends here. *)</span>
</code></pre>
<p>We now have everything we need to implement an echo server in Coq.</p>
<h2>Implementing an Echo Server</h2>
<p>Our implementation will be part of a dedicated Coq theory, called <code class="hljs language-coq">Echo</code>.
This is done easily a <code class="hljs language-coq">dune</code> file in the <code class="hljs">src/</code> directory, with the
following content.</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">coq</span>.theory
  (<span class="hljs-name">name</span> Echo)
  (<span class="hljs-name">theories</span> FFI))
</code></pre>
<p>In the rest of this section, we will discuss the content of the unique
module of this theory. Hopefully, readers familiar with programming
impurity by means of monads will not find anything particularly
surprising here.</p>
<p>Let us start with the inevitable sequence of import commands. We use
the <code class="hljs language-coq">Monad</code> and <code class="hljs language-coq">MonadFix</code> typeclasses of <code class="hljs language-coq">ExtLib</code>, and our
FFI modules from the <code class="hljs language-coq">FFI</code> theory we have previously defined.</p>
<pre><code class="hljs language-coq"><span class="hljs-keyword">From</span> ExtLib <span class="hljs-keyword">Require</span> <span class="hljs-keyword">Import</span> Monad MonadFix.
<span class="hljs-keyword">From</span> FFI <span class="hljs-keyword">Require</span> <span class="hljs-keyword">Import</span> Proc Socket.
</code></pre>
<p>Letting Coq guess the type of unintroduced variables using the <code class="hljs">`</code>
annotation (<em>e.g.</em>, in presence of<code class="hljs language-coq"> `{Monad m}</code>, Coq understands <code class="hljs">m</code>
is of type <code class="hljs">Type -&gt; Type</code>) is always nice, so we enable it.</p>
<pre><code class="hljs language-coq"><span class="hljs-keyword">Generalizable</span> <span class="hljs-keyword">All</span> <span class="hljs-keyword">Variables</span>.
</code></pre>
<p>We enable the monad notation provided by <code class="hljs">ExtLib</code>. In this article, we
prefer the <code class="hljs">let*</code> notation (as recently introduced by OCaml) over the
<code class="hljs">&lt;-</code> notation of Haskell, but both are available.</p>
<pre><code class="hljs language-coq"><span class="hljs-keyword">Import</span> MonadLetNotation.
<span class="hljs-keyword">Open</span> <span class="hljs-keyword">Scope</span> monad_scope.
</code></pre>
<p>Then, we define a notation to be able to define local, monadic
recursive functions using the <code class="hljs">mfix</code> combinator of the <code class="hljs">MonadFix</code>
typeclass.</p>
<pre><code class="hljs language-coq"><span class="hljs-keyword">Notation</span> <span class="hljs-string">"'let_rec*' f x ':`' p 'in' q"</span> :`
  (<span class="hljs-keyword">let</span> f :` mfix (<span class="hljs-keyword">fun</span> f x `&gt; p) <span class="hljs-built_in">in</span> q)
    (<span class="hljs-built_in">at</span> level <span class="hljs-number">61</span>, x <span class="hljs-built_in">pattern</span>, f name, q <span class="hljs-built_in">at</span> next level, <span class="hljs-built_in">right</span> associativity).
</code></pre>
<p>Note that <code class="hljs">mfix</code> does /not/ check whether or not the defined function
will terminate (contrary to the <code class="hljs">fix</code> keyword of Coq). This is
fortunate because in our case, we do not want our echo server to
converge, but rather to accept an infinite number of connections.</p>
<p>We can demonstrate how this notation can be leveraged by defining a
generic TCP server, parameterized by a handler to deal with incoming
connections.</p>
<pre><code class="hljs language-coq"><span class="hljs-keyword">Definition</span> tcp_srv `{Monad m, MonadFix m, MonadProc m, MonadSocket m}
    (handler : socket_descr -&gt; m unit)
  : m unit :=
  <span class="hljs-keyword">let</span>* srv := open_socket <span class="hljs-string">"127.0.0.1"</span> <span class="hljs-number">8888</span> <span class="hljs-built_in">in</span>
  listen srv;;

  let_rec* tcp_aux <span class="hljs-keyword">_</span> :=
    <span class="hljs-keyword">let</span>* client := accept_connection srv <span class="hljs-built_in">in</span>
    <span class="hljs-keyword">let</span>* res := fork tt <span class="hljs-built_in">in</span>
    <span class="hljs-keyword">match</span> res <span class="hljs-built_in">with</span>
    | <span class="hljs-type">Parent</span> <span class="hljs-keyword">_</span> =&gt; close_socket client &gt;&gt;= tcp_aux
    | <span class="hljs-type">Child</span> =&gt;  handler client
    <span class="hljs-keyword">end</span>
  <span class="hljs-built_in">in</span>

  tcp_aux tt.
</code></pre>
<p>The handler for the echo server is straightforward: it just reads
incoming bytes from the socket, sends it back, and closes the socket.</p>
<pre><code class="hljs language-coq"><span class="hljs-keyword">Definition</span> echo_handler `{Monad m, MonadSocket m} (sock : socket_descr)
  : m unit :=
  <span class="hljs-keyword">let</span>* msg := recv sock <span class="hljs-built_in">in</span>
  send sock msg;;
  close_socket sock.
</code></pre>
<p>Composing our generic TCP server with our echo handler gives us an
echo server.</p>
<pre><code class="hljs language-coq"><span class="hljs-keyword">Definition</span> echo_server `{Monad m, MonadFix m, MonadProc m, MonadSocket m}
  : m unit :=
  tcp_srv echo_handler.
</code></pre>
<p>Because <code class="hljs">coqffi</code> has generated typeclasses for the impure primitives
of <code class="hljs">proc.mli</code> and <code class="hljs">socket.mli</code>, <code class="hljs">echo_server</code> is polymorphic, and can
be instantiated for different monads. When it comes to extracting our
program, we will generally prefer the <code class="hljs">IO</code> monad of <code class="hljs">coq-simple-io</code>.
But we could also imagine verifying the client handler with FreeSpec,
or the generic TCP server with Interaction Trees (which support
diverging computations). Overall, we can have different verification
strategies for different parts of our program, by leveraging the most
relevant framework for each part, yet being able to extract it in an
efficient form.</p>
<p>The next section shows how this last part is achieved using, once
again, a convenient stanza of dune.</p>
<h2>Extracting and Building an Executable</h2>
<p>The <code class="hljs">0.2</code> version of the Coq-related stanzas of <code class="hljs">dune</code> provides the
<code class="hljs">coq.extraction</code> stanza, which can be used to build a Coq module
expected to generate <code class="hljs">ml</code> files.</p>
<p>In our case, we will write <code class="hljs">bin/echo.v</code> to extract the <code class="hljs">echo_server</code>
in a <code class="hljs">echo.ml</code> module, and uses the <code class="hljs">executable</code> stanza of <code class="hljs">dune</code> to
get an executable from this file. To achieve this, the <code class="hljs">bin/dune</code>
file simply requires these two stanzas.</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">coq</span>.extraction
  (<span class="hljs-name">prelude</span> echo)
  (<span class="hljs-name">theories</span> Echo)
  (<span class="hljs-name">extracted_modules</span> echo))

(<span class="hljs-name">executable</span>
  (<span class="hljs-name">name</span> echo)
  (<span class="hljs-name">libraries</span> ffi))
</code></pre>
<p>We are almost done. We now need to write the <code class="hljs">echo.v</code> module, which
mostly consists of (1) providing a <code class="hljs">MonadFix</code> instance for the <code class="hljs">IO</code>
monad, (2) using the <code class="hljs">IO.unsafe_run</code> function to escape the <code class="hljs">IO</code>
monad, (3) calling the <code class="hljs language-coq"><span class="hljs-keyword">Extraction</span></code> command to wrap it up.</p>
<pre><code class="hljs language-coq"><span class="hljs-keyword">From</span> Coq <span class="hljs-keyword">Require</span> <span class="hljs-keyword">Extraction</span>.
<span class="hljs-keyword">From</span> ExtLib <span class="hljs-keyword">Require</span> <span class="hljs-keyword">Import</span> MonadFix.
<span class="hljs-keyword">From</span> SimpleIO <span class="hljs-keyword">Require</span> <span class="hljs-keyword">Import</span> SimpleIO.
<span class="hljs-keyword">From</span> Echo <span class="hljs-keyword">Require</span> <span class="hljs-keyword">Import</span> Server.

<span class="hljs-keyword">Instance</span> MonadFix_IO : MonadFix IO :=
  { mfix := @IO.fix_io }.

<span class="hljs-keyword">Definition</span> main : io_unit :=
  IO.unsafe_run echo_server.

<span class="hljs-keyword">Extraction</span> <span class="hljs-string">"echo.ml"</span> main.
</code></pre>
<p>Since we are using the <code class="hljs language-coq">i63</code> type (signed 63bits integers) of the
<code class="hljs">CoqFFI</code> theory, and since <code class="hljs language-coq">i63</code> is implemented under the hood with Coq
primitive integers, we <em>also</em> need to provide a <code class="hljs language-ocaml"><span class="hljs-type">Uint63</span></code> module with a
<code class="hljs language-ocaml">of_int</code> function. Fortunately, this module is straightforward to
write.</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">let</span> of_int x = x
</code></pre>
<p>And <em>voilà</em>. A call to <code class="hljs">dune</code> at the root of the repository will
build everything (Coq and OCaml alike). Starting the echo server
is as simple as</p>
<pre><code class="hljs language-bash">dune <span class="hljs-built_in">exec</span> bin/echo.exe
</code></pre>
<p>And connecting to it can be achieved with a program like <code class="hljs">telnet</code>.</p>
<pre><code class="hljs language-console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">telnet 127.0.0.1 8888</span>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
hello, echo server!
hello, echo server!
Connection closed by foreign host.
</code></pre>
<h2>Appendix</h2>
<h3>The <code class="hljs">Socket</code> OCaml Module</h3>
<p>There is not much to say, except that (as already stated) we use the
<code class="hljs language-ocaml"><span class="hljs-type">Unix</span></code> module to manipulate sockets, and we attach to each socket a
buffer to store incoming bytes.</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">let</span> buffer_size = <span class="hljs-number">1024</span>

<span class="hljs-keyword">type</span> socket_descr = {
  fd : <span class="hljs-type">Unix</span>.file_descr;
  recv_buffer : <span class="hljs-built_in">bytes</span>;
}

<span class="hljs-keyword">let</span> from_fd fd =
  <span class="hljs-keyword">let</span> rbuff = <span class="hljs-type">Bytes</span>.create buffer_size <span class="hljs-keyword">in</span>
  { fd ` fd; recv_buffer ` rbuff }

<span class="hljs-keyword">let</span> open_socket hostname port =
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">open</span> <span class="hljs-type">Unix</span> <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">let</span> addr = inet_addr_of_string hostname <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">let</span> fd = socket <span class="hljs-type">PF_INET</span> <span class="hljs-type">SOCK_STREAM</span> <span class="hljs-number">0</span> <span class="hljs-keyword">in</span>
  setsockopt fd <span class="hljs-type">SO_REUSEADDR</span> <span class="hljs-literal">true</span>;
  bind fd (<span class="hljs-type">ADDR_INET</span> (addr, port));
  from_fd fd

<span class="hljs-keyword">let</span> listen sock = <span class="hljs-type">Unix</span>.listen sock.fd <span class="hljs-number">1</span>

<span class="hljs-keyword">let</span> recv sock =
  <span class="hljs-keyword">let</span> s = <span class="hljs-type">Unix</span>.read sock.fd sock.recv_buffer <span class="hljs-number">0</span> buffer_size <span class="hljs-keyword">in</span>
  <span class="hljs-type">Bytes</span>.sub_string sock.recv_buffer <span class="hljs-number">0</span> s

<span class="hljs-keyword">let</span> send sock msg =
  <span class="hljs-type">Unix</span>.write_substring sock.fd msg <span class="hljs-number">0</span> (<span class="hljs-type">String</span>.length msg)

<span class="hljs-keyword">let</span> accept_connection sock =
  <span class="hljs-type">Unix</span>.accept sock.fd |&gt; fst |&gt; from_fd

<span class="hljs-keyword">let</span> close_socket sock = <span class="hljs-type">Unix</span>.close sock.fd
</code></pre>
<h3>The <code class="hljs">Proc</code> OCaml Module</h3>
<p>Thanks to the <code class="hljs">Unix</code> module, the implementation is pretty straightforward.</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">type</span> identity = <span class="hljs-type">Parent</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span> | <span class="hljs-type">Child</span>

<span class="hljs-keyword">let</span> fork x =
  <span class="hljs-keyword">match</span> <span class="hljs-type">Unix</span>.fork x <span class="hljs-keyword">with</span>
  | <span class="hljs-number">0</span> -&gt; <span class="hljs-type">Child</span>
  | x -&gt; <span class="hljs-type">Parent</span> x
</code></pre>
        
      
