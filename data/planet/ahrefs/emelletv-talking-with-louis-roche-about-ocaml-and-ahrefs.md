---
title: "EmelleTV: Talking with Louis Roche\u0301 about OCaml and Ahrefs"
description: Transcript
url: https://tech.ahrefs.com/emelletv-talking-with-louis-roche%CC%81-about-ocaml-and-ahrefs-7767afbfbdb9?source=rss----303662d88bae--ocaml
date: 2023-06-29T14:32:40-00:00
preview_image:
authors:
- Ahrefs
source:
---

<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fo2u9irv1tnE%3Fstart%3D9%26feature%3Doembed%26start%3D9&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Do2u9irv1tnE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2Fo2u9irv1tnE%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/aef5aa9cb9b71aaafb0a07cb48cb312d/href">https://medium.com/media/aef5aa9cb9b71aaafb0a07cb48cb312d/href</a></iframe><h3>Transcript</h3><p><strong>David: [00:00:00]</strong> Hello, my name is David. I run <a href="https://emelle.tv/">EmelleTV</a>. It&rsquo;s a talk show about OCaml, ReScript, and Reason. I often bring guests from the community to talk about them and meet them and asking a lot of questions about the language or what they&rsquo;re working on, and of course having fun with Hindley&ndash;Milner type system. That&rsquo;s part of the show. I work for Ahrefs, it&rsquo;s actually this&nbsp;company.</p><p>Today I&rsquo;m interviewing a coworker, so it&rsquo;s going to be a little bit a branded stream. Hope you understand. It&rsquo;s a lovely company. Apply if you&rsquo;re looking for a job to work on OCaml or Reason. Aside from that, I maintain styled-ppx and implementation of React on server, but that&rsquo;s just enough about me, and I&rsquo;m going to introduce our guest, Louis. Hello, Louis. How are&nbsp;you?</p><p><strong>Louis: [00:00:59]</strong> Good, and&nbsp;you?</p><p><strong>David: [00:01:01]</strong> Good. Very good. You obviously work at Ahrefs. At what team do you&nbsp;work?</p><p><strong>Louis: [00:01:10]</strong> This is recently changing, but I have been in the back-end forever, since like seven years ago and I still have some of the projects that I had when I joined. This was stable. I&rsquo;m in this new team called middle-end. Ahrefs is not very good with naming. We say that it&rsquo;s the hardest thing in computer science. We have front-end that is actually full stack, then we have a back-end, which is more like data, and now we have middle-end, which is somewhere in the middle. I&rsquo;m supposed to lead this new middle-end team.</p><p><strong>David: [00:01:48]</strong> Nice.</p><p><strong>Louis: [00:01:49]</strong> We&rsquo;ll see how it&nbsp;goes.</p><p><strong>David: [00:01:49]</strong> Nice. Today I think we&rsquo;re going to answer a few questions about Ahrefs, I think has been a mysterious company, if you look at it from the outside. When I joined, I think you helped me understand a lot of things that I didn&rsquo;t know about Ahrefs. I might just fire the same questions that I did, just recorded so everybody can understand them. Aside from from Ahrefs, who are you and can you present a little about yourself?</p><p><strong>Louis: [00:02:21]</strong> This is a tough question. Who am I? I grew up in France. I&rsquo;m French, still I&rsquo;m French, but I&rsquo;ve been living in Singapore for seven years, with Ahrefs for seven years. I&rsquo;ve been working in OCaml my whole life basically because my first job was in OCaml, and Ahrefs which is my second job, is in OCaml too. I cannot say that it&rsquo;s better than the rest because I never tried the rest. I&rsquo;ve been involved with OCaml, like the OCaml meetup in Paris for some&nbsp;time.</p><p>I&rsquo;m on the online community. I&rsquo;m part of the OCaml Code of Conduct committee, which is an effort that was started last year, I think. So far we don&rsquo;t have a lot of work, so that&rsquo;s good. I&rsquo;m one of five doing this. Then outside of that, I&rsquo;m a pretty normal person. I&rsquo;m 31 years old, and that&rsquo;s about it, I would&nbsp;say.</p><p><strong>David: [00:03:35]</strong> That&rsquo;s the whole idea. You have been been writing OCaml for a long, long time. That&rsquo;s fair to&nbsp;say.</p><p><strong>Louis: [00:03:40]</strong> I&rsquo;ve been writing OCaml since I&rsquo;m 16 or 17 was when I wrote my first line, like 14 years ago, something like this. There was no Merlin at the&nbsp;time.</p><p><strong>David: [00:03:52]</strong> There was no LSP. The first question is, 15 years, this is a long time, but how do you see the evolution of entire language? Would you split it in chunks? How have you seen the progress of the language?</p><p><strong>Louis: [00:04:08]</strong> It&rsquo;s hard to say. When I joined the OCaml world, it was because of people who nowadays are fairly important like Gabriel Scherer, who&rsquo;s working in Inria, I think, but he&rsquo;s one of the main maintainer for OCaml. He was in this French forum, pushing very hard people to try OCaml and I got convinced. I started just writing a few lines here and there, and then I just stick to that for a long time. I&rsquo;ve been mostly a user like this. My usage has extended over time, but I&rsquo;ve never been called a contributor. My point of view is more as a&nbsp;user.</p><p>The biggest difference is the size of the community, I would say. It&rsquo;s much more dynamic than it used to be. We used to install packages like OCaml libraries, using Debian packages. It was apt install something. There was no opam, there was no Merlin, there was no vscode,&nbsp;right?</p><p><strong>David: [00:05:25]</strong> Right.</p><p><strong>Louis: [00:05:25]</strong> LSP didn&rsquo;t exist, so way less library. I think you can see today how it was in the past because you can see, we have 10 different libraries to do HTTP 1.1. We have 10 different standard libraries, and it&rsquo;s legacy of what OCaml was in the past. We used to have all those smart people, but they had no way to collaborate. There was no opam, there was no way to share your work. Everyone was smart enough to rewrite&nbsp;&mdash;</p><p><strong>David: [00:06:04]</strong> Build your own library for&nbsp;http.</p><p><strong>Louis: [00:06:05]</strong> Yes.</p><p><strong>David: [00:06:06]</strong> Right. That&rsquo;s always interesting for me, how OCaml got so many different things that are hard to create, like standard libraries. I think recently, Containers reached 10 years, so it&rsquo;s like what? [chuckles] It doesn&rsquo;t make much sense. If you look at now, it doesn&rsquo;t make much sense, but if you look at historically, it does make&nbsp;sense.</p><p><strong>Louis: [00:06:35]</strong> When you have no choice, you do it. You don&rsquo;t know that it&rsquo;s harder, you just see &ldquo;Oh, I can do it,&rdquo; and you do&nbsp;it.</p><p><strong>David: [00:06:42]</strong> Yes. You need to think it&rsquo;s easy. You need to start a standard library or http library saying, &ldquo;Oh, it&rsquo;s easy.&rdquo; Then, you start a little bit, and eventually, you create something. Last week&#8202;&mdash;&#8202;Oh, sorry, go&nbsp;on.</p><p><strong>Louis: [00:06:57]</strong> No, go&nbsp;ahead.</p><p><strong>David: [00:06:59]</strong> Last week, I tweeted that OCaml suffers a lot from the Python Paradox. The Python Paradox, I think somebody write it, I think it was, I don&rsquo;t remember the name of the guy, but somebody write it in 2004, that when you use Python for a company, and you get the smartest people that they want to innovate, and you have the pioneers of the language. Then, by default, you try to hire people that are in love with software, so eventually, they create good software or they are willing to suffer from getting out of the comfort zone and create software. I believe the combination is the same spot. Can you see, is that true? Do you&nbsp;agree?</p><p><strong>Louis: [00:07:49]</strong> I don&rsquo;t know if that&rsquo;s true. Partially, it&rsquo;s a strategy of Ahrefs, so I have to say it&rsquo;s&nbsp;true.</p><p><strong>David: [00:07:55]</strong> [laughs]</p><p><strong>Louis: [00:07:58]</strong> Yes, I think it&rsquo;s partially true, but it&rsquo;s not completely correct. For OCaml, at least it&rsquo;s a bit different from Python, because OCaml has this strong academic influence, so a lot of people are actually researcher. There is a big benefit that they have, not free time, but they manage their time, they manage what they work on, and they decide what is important. They got all this time to actually write this complicated code many times because actually, it&rsquo;s part of their job to just redo the same thing in better ways. It&rsquo;s normal you have to explore a&nbsp;subject.</p><p>It&rsquo;s okay to do it multiple times. It&rsquo;s a combination of those people are working in the right place, they have the right time, and they have the correct background. A lot of people were working on subjects that allowed them to do it. Some, it&rsquo;s because they were very strong in writing languages. Some, it&rsquo;s because they have this strong Unix background, I would&nbsp;say.</p><p><strong>David: [00:09:05]</strong> Right. It&rsquo;s very unixy. The start of OCaml is very unixy. That&rsquo;s&nbsp;true.</p><p><strong>Louis: [00:09:14]</strong> Xavier Leroy wrote LinuxThreads, I think that was used in Linux forever, so there is this background. Probably, it&rsquo;s a bit different in Python because it grew more in the industry rather than in an academic setup. For sure, if you try to target people who live in a niche, you find people with a different interest from the main programming community, I would say. At the same time, I think some of the best meetup or conference I&rsquo;ve been to were Java&nbsp;meetup.</p><p><strong>David: [00:09:59]</strong> All&nbsp;right.</p><p><strong>Louis: [00:10:00]</strong> They know that their language is boring. The language is the same since 20 years or 30 years. There are some changes but they don&rsquo;t really care about the language too much. It&rsquo;s a huge, huge community. Basically, everything already exists. There is no big bragging, everyone can do everything. There are 10 versions of everything, whatever. The benefit is that they are super open-minded.</p><p>Oh, something is new. Something is different. Okay. Let&rsquo;s see that. You go to that meetup and they will not talk only about all the fancy new feature in Java. It&rsquo;s like, &ldquo;Oh, I saw this new git tool. Oh, it&rsquo;s funny. Okay, let&rsquo;s try to use this.&rdquo; A new way to do web development. Okay, let&rsquo;s study the subject. It&rsquo;s not about Java itself because the language is not interesting enough. It&rsquo;s about other programming stuff. It&rsquo;s very fun to&nbsp;attend.</p><p><strong>David: [00:11:03]</strong> That&rsquo;s a good one. Actually, many people that now are starting to hear OCaml for the first time, after they leave or they got disappointed with the Rust policy drama. These people cannot get into OCaml because some influencer wanted to bash on Rust. They started exploring all the languages and of course Ocaml was one of those. Aside from Zed or whatever you compare it with, low level programming languages. Do you see those influencers move people to actually try the language and deploy it into users and doing serious stuff, or it&rsquo;s more like vain marketing?</p><p><strong>Louis: [00:11:56]</strong> I&rsquo;m not a big Twitch person. I don&rsquo;t know [crosstalk] modern influencers.</p><p><strong>David: [00:12:02]</strong> That&rsquo;s&nbsp;true.</p><p><strong>Louis: [00:12:03]</strong> I think it exists in two forms. In the past it existed in two forms. You had influencers, you had Rob Pike and- who&rsquo;s the other person? The two person who are behind Go. They do not make a good language but they are influencers. They were like, &ldquo;Oh, yes. We did UTF-8 and a Plan 9 in the past and we work at Google. Oh, it&rsquo;s going to be amazing.&rdquo; No, it&rsquo;s a crappy language, but they are influencers. They move&nbsp;people.</p><p><strong>David: [00:12:32]</strong> [laughs] Okay. Would you say that Go is&nbsp;crap?</p><p><strong>Louis: [00:12:38]</strong> Go is a language. I haven&rsquo;t used Go 2 extensively.</p><p><strong>David: [00:12:42]</strong> This is recorded. This is not a beer in Singapore. This is recorded. You can obviously bash go, that&rsquo;s part of the&nbsp;game.</p><p><strong>Louis: [00:12:50]</strong> Let&rsquo;s say Go is not the most modern language there&nbsp;is.</p><p><strong>David: [00:12:54]</strong> Right. Thank you. This is just for the headline. We don&rsquo;t want the headlines- because Ahrefs is going to be like&#8202;&mdash;&#8202;No, I&rsquo;m joking. [crosstalk] Yes, go on.&nbsp;Sorry.</p><p><strong>Louis: [00:13:10]</strong> On the same topic of influencer, we saw it with Reason. When the Reason comes, it&rsquo;s not just a random person creating Reason. It&rsquo;s Jordan and he comes with a React background, and he comes with followers. He is not doing videos online but it&rsquo;s the same idea. I think yes, it has definitely an influence and OCaml grew a lot when Reason&nbsp;started.</p><p><strong>David: [00:13:38]</strong> Yes, that&rsquo;s&nbsp;true.</p><p><strong>Louis: [00:13:39]</strong> I definitely think it has an influence.</p><p><strong>David: [00:13:43]</strong> That&rsquo;s true. From the community, how have you seen the Reason creation and adoption from your point of view? You can bash Reason if you&nbsp;want.</p><p><strong>[00:13:43]</strong> [crosstalk]</p><p><strong>Louis: [00:13:56]</strong> At that time I think the OCaml community was one IRC channel. It was a bit different from now. I think what I was not super convinced by when Reason to syntax arrived, I think the original claim by Jordan was he&rsquo;s making a better syntax. I was not super convinced that the syntax was better. It was developed independently from&nbsp;OCaml.</p><p>By experience I already knew at the time that if you start to fork or develop on your side and don&rsquo;t integrate fairly quickly with upstream it&rsquo;s actually never going to be integrated with upstream.</p><p><strong>David: [00:14:53]</strong> Right.</p><p><strong>Louis: [00:14:54]</strong> I don&rsquo;t know why exactly, but it has happened a few times. Then there is a question of bucklescript because if you write Reason it&rsquo;s two sides. There is a syntax which I only partially understood too because I was not a web developer, I&rsquo;m still not a web developer. I did not know about JSX. I did not know how powerful it was and I think React was not as big at the time too, but I think JSX is a nice idea and there are a lot of things in the syntax that are nice, like parentheses around arguments is a problem but it has some benefits, too.</p><p><strong>David: [00:15:42]</strong> Yes, I think some trade-offs from OCaml, or at least some edge cases from the syntax from OCaml got resolved in Reason just by adding more- like the parentheses or the braces or the semicolons. But yes, the others are, can remove some problems from the syntax. Not problems, but just the edge cases from the cleanness for&nbsp;OCaml.</p><p><strong>Louis: [00:16:10]</strong> Yes. Even sometimes it&rsquo;s not edge case but it&rsquo;s nice to see very clearly for example, when you apply a function, where are the arguments? Where it starts where it ends? There are benefits, obviously, like the OCaml syntax or Haskell syntax is lighter, we will say, have some benefits. The other one is nice,&nbsp;too.</p><p><strong>David: [00:16:36]</strong> Yes, definitely and you mentioned BuckleScript?</p><p><strong>Louis: [00:16:40]</strong> Yes. BuckleScript, they didn&rsquo;t have&nbsp;&mdash;</p><p><strong>David: [00:16:42]</strong> That was not so well received.</p><p><strong>Louis: [00:16:47]</strong> Yes, I think because there was Js_of_ocaml idea. There was js_of_ocaml and so again, it was like yes, I do something different and- I think Bob developed it fully inside Bloomberg at the time. Basically, he came out and he had, &ldquo;Oh, yes, I have a new project and it&rsquo;s working already.&rdquo; He didn&rsquo;t start to develop it in public. The community was much smaller, too so every time you split efforts like this, it&rsquo;s kind of costly. People will say, &ldquo;Yes, we will try to collaborate. We&rsquo;ll try to make the two projects work together,&rdquo; or whatever and it never works. Never works. I don&rsquo;t think I understood all the trade-off. I&rsquo;m happy that I invited Bob to the OCaml meetup in Paris which retrospectively, it was a good thing to&nbsp;do.</p><p><strong>David: [00:17:50]</strong> Yes, for the record, Louis was running the OCaml Paris Meetup, I think. Yes, go on with the&nbsp;story.</p><p><strong>Louis: [00:18:00]</strong> Yes, so when I moved to Singapore, I still organized one meetup, even though I was in Singapore and I invited Bob to present BuckleScript. At the time, it was a bit controversial, because many people were a bit unhappy with what he was doing, but I&rsquo;m happy that I did it. I didn&rsquo;t understood what I was doing exactly but at the end, I think it was the right thing to do. Even if the project died later on, you have to give such projects a&nbsp;chance.</p><p><strong>David: [00:18:35]</strong> Yes, I think I wouldn&rsquo;t say that BuckleScript died. It&rsquo;s more like BuckleScript has been working for seven years, I&nbsp;think.</p><p><strong>Louis: [00:18:42]</strong> Yes, no, even if it was a failure, which it was not, but maybe like six months later, it could have died and disappeared. Yes, I think when people have a drastically different approach, usually they have a reason. It&rsquo;s worth listening. A lot of what Bob defended, I&rsquo;m not sure I completely agree with it. He wants a very stable compiler, for example. He said, in Bloomberg, they are using GCC 3 or 4, I don&rsquo;t remember, since&nbsp;forever.</p><p>So they don&rsquo;t need to upgrade the compiler, the GCC compiler, for example. He thought the same idea can apply to OCaml, we don&rsquo;t need to follow the upstream compiler all the&nbsp;time.</p><p><strong>David: [00:19:27]</strong> Right.&nbsp;Yes.</p><p><strong>Louis: [00:19:29]</strong> Most companies actually they don&rsquo;t want to change compiler version. They want something stable. They want no surprise, which has some value, or the stability has some&nbsp;value.</p><p><strong>David: [00:19:40]</strong> Yes, that&rsquo;s true but I think when he mentioned about the compatibility with the compiler, I think it&rsquo;s mostly OCaml has been very stable since, what 6, 7 years ago, I think. I think there were some small changes or some addition features, but nothing really break, but mostly the syntax. Then he complained about the parsing, like the AST modifications, those were present, those were changing between versions. He wanted to not- because BuckleScript is a fork of the common compiler and embedded into ReScript&nbsp;now.</p><p>Yes, he was complaining about the AST transformations because every version changes a lot. There are migrations. You could write some logic to migrate from one to another. It&rsquo;s painful if you maintain a fork of this, you might suffer a lot from updating from one compiler to&nbsp;another.</p><p><strong>Louis: [00:20:41]</strong> Yes, and I think for him, even as an end user, the stability has some value. It&rsquo;s interesting for him to have a stable compiler and even for his target, the people he&rsquo;s targeting, the stability has some value&nbsp;too.</p><p><strong>David: [00:21:00]</strong> After you mentioned that people were installing or sharing libraries through Debian packages, which maybe- I&rsquo;m as old as you, but maybe I&rsquo;m too young to see how those package managers could work with apt get. What&rsquo;s the position of the tooling? Right now I think we are in a state where we have two bigger players such as opam and dune, as Package Manager and Build Infrastructure, we&rsquo;d call it, I don&rsquo;t know. Now dune is exploring installing packages. How do you see the tooling these recent&nbsp;years?</p><p><strong>Louis: [00:21:48]</strong> It&rsquo;s amazing. It&rsquo;s completely incredible. Then people will have different opinions on is opam perfect or whatever. If you compare to what it was before, it&rsquo;s incredible. I think even if you compare to other languages, it&rsquo;s a fairly solid experience now. Opam is working well. You just need to learn the UI, but it&rsquo;s working fairly well. Dune is relatively fast, easy to use. The LSP is pretty magical. Merlin is a very solid tool. It was one of the first, I think I would say, like a small language with a tool as powerful as&nbsp;Merlin.</p><p>It&rsquo;s not only powerful, it&rsquo;s avantgarde. It understood already that you had to be able to do error recovery and that you had to change the way you parse files to be able to work with something that is half&nbsp;broken.</p><p><strong>David: [00:22:57]</strong> Yes, that&rsquo;s&nbsp;true.</p><p><strong>Louis: [00:23:00]</strong> The people behind Merlin are super smart. In a way, it&rsquo;s not a surprise.</p><p><strong>David: [00:23:05]</strong> Right. You actually contributed to the LSP and dune, to both projects, I saw your contributions.</p><p><strong>Louis: [00:23:13]</strong> Yes, I have commits on many small- it&rsquo;s mostly small contributions, but I have commit on everything, I think at some&nbsp;point.</p><p><strong>David: [00:23:19]</strong> Right.</p><p><strong>Louis: [00:23:21]</strong> LSP, I participated in putting some ppx deriving stuff and I wrote a bunch of commands. I implemented some Merlin behavior inside LSP. If you hover multiple times on the same value, the type will be more and more verbose. I took this behavior back to LSP. Dune I have mostly bug fixes, probably small documentation, nothing&nbsp;big.</p><p><strong>David: [00:23:58]</strong> One of the things that you mentioned as well, I think we talked about this before. When OCaml was very young, all features that got added into the language were PhD projects, where it&rsquo;s a student that is very passionate or maybe just his guidance is OCaml fan, he just explored with a language in the theory on academia. Then he worked on a paper and eventually it gets released as part of the language. That was the times where maybe Jane Street not even started using OCaml seriously. Do you see that now? Do you see that those features or academic features got into language? Do you think it&rsquo;s a weird mix now or they compose well together? How do you see language after these contributions?</p><p><strong>Louis: [00:25:04]</strong> I was looking today at the OCaml change log because I was wondering when was the release of OCaml 4, and that was 11 years ago because OCaml 4 is- before to OCaml Multicore is the last time there was a big change which was GADT. In the meantime there was mostly small changes. I don&rsquo;t think the language changed much. If we look what were the big features we could say like the objects in OCaml, GADT, OCaml Multicore.</p><p>They all were developed by people in a research setup and somehow it seems to work. I&rsquo;m not a maintainer on OCaml. I think it works also because they don&rsquo;t have a lot of energy to integrate a lot of new features, they are very, very picky on what they actually accept in the compiler. Only the most solid implementations will get&nbsp;in.</p><p><strong>David: [00:26:36]</strong> Yes, that&rsquo;s true. I think the quality is something that everything core team members says all the time that all these things would be amazing to do but our quality bar is very high. Yes, you need to work on it much more to let us just even look at it. Yes, that&rsquo;s&nbsp;true.</p><p><strong>Louis: [00:26:54]</strong> Then there are things that do not compose super, super well. There are part of the module language and part of the object language that do not compose very well. You can make the compiler more or less blow up or the compilation time will become crazy. Actually, those are parts that I don&rsquo;t know very well. I very seldom combine first-class modules and&nbsp;objects.</p><p><strong>David: [00:27:21]</strong> Objects, yes. That&rsquo;s something I haven&rsquo;t done yet. I think the only experience with that combination might be ppxlib maybe, because you have the traversers. Yes, you use them. You instantiate the traverser. You don&rsquo;t do anything with internal states of anything. Good point. One thing that maybe it&rsquo;s worth saying is that right now you work at Ahrefs for seven&nbsp;years.</p><p>At the beginning when Ahrefs pick OCaml or Igor, our CTO came with OCaml in the back, there were not many companies working on- using it, using OCaml. Now we have Tezos, Tarides, Ahrefs of course, LexiFi, Bloomberg, BeSport. Many companies that have- even some of them have their own forks of OCaml that they are experimenting and deploying it or whatever. Seven years ago, do you think it&rsquo;s a risky decision? The second question is how can you convince your boss about using&nbsp;OCaml?</p><p><strong>Louis: [00:28:35]</strong> For sure, I think picking OCaml at the time was a risky choice because who do you hire? It&rsquo;s like there were five OCaml developers. In Paris, you can find people. In Paris, you can find students. You go to the OCaml meetup and socialize and you can more or less build a company, which is what the previous company I was in called Cryptosense was doing. This is how BeSport came to life. BeSport just picked a few people around Vincent Balat and then you meet people. You steal one or two person from the OCaml meetup and you tell them, &ldquo;Oh, join my company,&rdquo; and now you have enough people to push a project forward. How do you do this from another country? Even today, I think it&rsquo;s not an easy&nbsp;choice.</p><p><strong>David: [00:29:35]</strong> Somehow risky, yes. That&rsquo;s&nbsp;true.</p><p><strong>Louis: [00:29:38]</strong> Today, you can hire, but even if you have, I don&rsquo;t know, 2,000 packages on opam, the tooling is still- the libraries are not, there are not libraries for everything like you have in some other languages.</p><p><strong>David: [00:30:00]</strong> Right. It&rsquo;s big enough, but it&rsquo;s not populated with everything.</p><p><strong>Louis: [00:30:07]</strong> I don&rsquo;t know if we have full support of GRPC. I&rsquo;m not sure that we have complete support of http2 or 3. It&rsquo;s not that small, but many things like this. I would say, today I would say it&rsquo;s a risk. How would I convince my boss to move to OCaml? I would&nbsp;&mdash;</p><p><strong>David: [00:30:34]</strong> Would you do it? Maybe you would not do it. Maybe you say, &ldquo;It&rsquo;s fine, we can do with whatever,&rdquo; with Java you said that you enjoy the Java meetup, then you join your company writing Java. Would you be happy writing Java? Would you be fine? Or you would say &ldquo;Oh, OCaml here makes sense, let&rsquo;s try to change it.&rdquo; How would you do&nbsp;it?</p><p><strong>Louis: [00:30:57]</strong> I think if I was in a small company, it would definitely make sense to use OCaml. It&rsquo;s interesting because in a small company you could say all the Java tooling has more value than in a big company, but at the same time you have less hands. You need to be more productive per person and you have less time for maintenance, and those are two things for which OCaml is very strong. You can write few lines of code that do many things, so it&rsquo;s very expressive. At the same time, it&rsquo;s solid enough that when you write your code, you can launch it in prod and you can leave it there for some time and hopefully nothing&nbsp;breaks.</p><p>The language is stable, the compiler is stable, so there will be no big surprises. I think that&rsquo;s very valuable, and then you compare, what are the alternatives today? Rust is incredibly hard. It&rsquo;s very, very hard language to use. You can do fancy stuff, you have incredible community but it&rsquo;s a super hard language to use. You have what, Python, but then you are losing all the type safety. You have Go, which is a bit in between those. You have a fast Python I would say. Then you have Java. Java which has a huge community, and is a fast language.</p><p>In a way I think OCaml is closer to Java. It&rsquo;s one easy language to use, solid, no surprises. The feature set is not incredible but it&rsquo;s working well enough and you can do more or less what you want with it. You can do work in the back end, work in the front end, it&rsquo;s approachable. To me it&rsquo;s a replacement to Java. It&rsquo;s a light&nbsp;Java.</p><p><strong>David: [00:33:04]</strong> I&rsquo;m mostly front-end. Now I&rsquo;m doing some back-end stuff but I mostly am experienced from front-end. You are experienced from back-end of course and when I&rsquo;m talking to back-end persons from OCaml, every time I talk with a back-end person who only writes OCaml they mention then the runtime. From the front-end, it&rsquo;s a problem that I have never, ever thought. I know that the problem exists because I studied computer science and all these things, but it&rsquo;s something that in the front-end I never think about&nbsp;it.</p><p>How could you describe to me that- I know a little bit about the memory presentation and about the stack, the heap, how memory works, even the O(n) notation, O big notation. How can you describe the runtime of OCaml, from someone who doesn&rsquo;t know much about runtimes, so has nothing else to compare, rather than notes, for example. That&rsquo;s my experience.</p><p><strong>Louis: [00:34:08]</strong> Yes, I&rsquo;m not an expert either, but it&rsquo;s an interesting point, actually, because if you go on, for example, the real-world OCaml, there is a whole chapter on the runtime. I think it&rsquo;s important for the OCaml people because of their background. We have those unixy people, so they have experience with C before and because in C you need to know what is a representation in memory of everything you manipulate, they took that from C and bring it to OCaml. Those people, they like to know, when I have an integer, it&rsquo;s going to be nowadays, 64&nbsp;bits.</p><p><strong>David: [00:34:56]</strong> 63 right? That&rsquo;s the&nbsp;&mdash;</p><p><strong>Louis: [00:34:59]</strong> Yes, one bits for the right GC, and then we have 63 bits for the&nbsp;value.</p><p><strong>David: [00:35:05]</strong> Right. Yes, people love the runtime. I think it&rsquo;s like those things when&#8202;&mdash;&#8202;You guys started talking about the front-end. For me, I love CSS. I can talk all the time about CSS, but if you never have experience with a language or with designing the UI, CSS means nothing. You understand what they are saying because the thing makes sense, but semantically it doesn&rsquo;t. When you talk about the run time at the beginning, for me it felt like I have never, ever thought of&nbsp;this.</p><p><strong>Louis: [00:35:41]</strong> I guess it&rsquo;s two sides. There is the technical side, how it&rsquo;s actually implemented that when you allocate a value, where do you put it in memory? What is the representation of that value in memory? For example, we said that the int are 63 bits actually, that when you allocate the value, you allocate by words in OCaml. You have one word, for example, if you allocate the values that is on the heap, you have potentially two words. You have one word, which is a pointer to the actual value, and then the values, which is like a number of words afterwards.</p><p>You have the GC, so when is it triggered? Actually, the GC can be running every time you can allocate a value which means that you can write code that will not trigger the GC. It means you can write code that is very fast because there will be no interruption, and I think that&rsquo;s critical for companies like Jane Street. Then yes, the other side is the runtime from a user perspective. I see it two way. I see one way that it&rsquo;s like no one knows about the runtime because it&rsquo;s very, very simple in OCaml. You don&rsquo;t need to deal with the runtime very&nbsp;often.</p><p>You just know that you pass values by reference, so you don&rsquo;t make many copies, and then the GC is fairly fast and will not stop for too long. That&rsquo;s probably what 99% of the normal OCaml people know about the runtime. Then an interesting fact that comes with that is that the OCaml compiler is bad by modern standards, that it&rsquo;s not doing any kind of optimization or very little optimization, yet the native code is fairly fast. The native code that is generated for an OCaml program is fairly fast. I think if you look at the benchmark it&rsquo;s not too far away from C++, which is surprising, and it means that the language is pushing you to write code that by default is fairly efficient.</p><p><strong>David: [00:38:06]</strong> That&rsquo;s exactly my experience.</p><p><strong>Louis: [00:38:09]</strong> The types that are offered and the functions, the APIs that are offered, somehow allow you to write code that is not too, too bad. I think it&rsquo;s a miracle, but it&rsquo;s an interesting one.</p><p><strong>David: [00:38:23]</strong> Yes, that&rsquo;s exactly my experience. At Ahrefs, the formula of the Coca-Cola of Ahrefs is like the crawler, the thing that navigates the internet and saves data. After that, we have storage and all of these pieces that are complex. What can you explain about the secret sauce of Ahrefs? What are they from the outside? Many people would never, ever write a crawler or a very dummy one, but for one that indexes 9 billion pages, 1 trillion? I don&rsquo;t know the numbers but insane amount of numbers. What can you&nbsp;explain?</p><p><strong>Louis: [00:39:10]</strong> I guess the first question is what is a&nbsp;crawler?</p><p><strong>David: [00:39:13]</strong> Yes, yes, because you read the webpage, you scrap a webpage, that&rsquo;s fairly simple. You can do it in any language, but then what do you extract about this page, and more importantly, how you navigate to the next one. I think that these are the two main questions.</p><p><strong>Louis: [00:39:35]</strong> What you extract, depends. Ahrefs, we care about the links. What is Ahrefs building is more or less a map of the internet. The crawler is running all the time. It&rsquo;s downloading, I don&rsquo;t know, like 4 million pages per minute or something like this. There is a counter. Every minute we crawl 5 million pages. We have been talking for 40 minutes. You can count how many pages we have downloaded in a period of time. We download those pages and then we extract the links. That is the main information we care about. This is not the only information.</p><p>First is how do you parse HTML and how broken is HTML on the internet? This is horrible. The internet is broken. You have to extract all the links in a page and then you have to store all those links. When you store links, because&#8202;&mdash;&#8202;What is a crawler exactly? Where does it start and where does it end? Is it only the part that is downloading the html? Or is it actually the parsing too, and it&rsquo;s influencing how you are storing your data, because&#8202;&mdash;&#8202;Let&rsquo;s say you download a page and you have a 100 links in it, you do at least two things with those 100 links that you want to reuse them in your scheduler to decide what do I crawl&nbsp;next.</p><p>You also want to update counters, because you want to update your map of the internet. You downloaded a page, you know that there are links and you want to update the map. How do you update the map, because you have a 100 new links? What do you do? You update a 100 small counters, a 100 small integers. Then can you do it 5 million times per minute? Then can you do it in many direction, because it&rsquo;s a&nbsp;graph.</p><p><strong>David: [00:41:48]</strong> You would loop. If you don&rsquo;t do it properly, you would loop&nbsp;forever.</p><p><strong>Louis: [00:41:55]</strong> You have links between pages, but then you want to also count links between domains and you want to count the links inside the domain. Then how do you decide it&rsquo;s an interesting link or not? Then when you index a link, what do you index? You need to index the link itself, but you want to index the text that is attached to the link, maybe the paragraph that is around that specific link. You could look where it is in the page. Is it visible or not? You have&#8202;&mdash;&#8202;It&rsquo;s an open question.</p><p>That&rsquo;s an interesting question, because there is no one that can say, &ldquo;I&rsquo;m doing a crawler and this is the right way to do it.&rdquo; Even big companies like Google, they make tradeoffs. They decide, &ldquo;We do it in one way.&rdquo; Then they gather information they can gather. They cannot download every page on the internet all the time. They cannot download and process stuff fast enough. There is more content that is created than content that can be downloaded.</p><p><strong>David: [00:43:00]</strong> It&rsquo;s interesting, because if you think about fixing a bug on the crawler, it&rsquo;s usually when you have a database, you can run migrations or you can get out data. You can store data broken or whatever. You can fix it. If you have the history of internet, that&rsquo;s another source of data. It is life. I don&rsquo;t know the right metaphor, but it&rsquo;s&#8202;&mdash;&#8202;If you have to fix a bug on the crawler, that means that you stored information wrongly. That can affect the next version of your map, because it&rsquo;s not only a map, it&rsquo;s a map and a timeline. You can just look it up. It&rsquo;s an archive as well. I think internet archives, they don&rsquo;t have a crawler. I think they don&rsquo;t have a&nbsp;crawler.</p><p>It&rsquo;s the idea of&#8202;&mdash;&#8202;You can improve the crawler. Something that you didn&rsquo;t look before, now you are going to look it up now. I don&rsquo;t know, when&#8202;&mdash;&#8202;I think at some point we&#8202;&mdash;&#8202;At the beginning, either we started indexing, I think videos was&#8202;&mdash;&#8202;I don&rsquo;t remember. Some media, I don&rsquo;t know. That, of course, blowed up immensely, everything- they complicated everything.</p><p><strong>Louis: [00:44:14]</strong> Yes. That&rsquo;s an interesting question. Actually, Because, it is right that your database is very big so you cannot just migrate stuff. The big data page says we have 170 trillion rows in the database, so we cannot just push this to somewhere else.</p><p><strong>David: [00:44:35]</strong> First of all, what technology is that running&nbsp;on?</p><p><strong>Louis: [00:44:40]</strong> I think that&rsquo;s a combination of different technologies. That will be a ClickHouse and then some internal database. Custom&nbsp;stuff.</p><p><strong>David: [00:44:52]</strong> At Ahrefs, correct me if I&rsquo;m wrong, we like to build our own things mostly. When I have it in other companies, you would use Sentry for reporting, or you would use PagerDuty for live crashing, or you would use whatever tool that you- or a web server, like a framework that runs your server. I think we implemented all of this by ourselves. That sounds both crazy from the outside, but when you join Ahrefs, if you ever join the company, you understand perfectly why has it been done like that. Yes, we have our own database. It&rsquo;s&nbsp;scary.</p><p><strong>Louis: [00:45:41]</strong> It&rsquo;s not completely our own database, it&rsquo;s more like a wrapper around existing database. It&rsquo;s partially because we have no choice. The problem is large enough that you don&rsquo;t have a ready made solution. Google was like this for a very long time. They had MySQL, I think that they used very extensively MySQL and it&rsquo;s just that they used it in a way that was working for them. They don&rsquo;t have a giant MySQL database, but probably they just sharded the&nbsp;problem.</p><p>They have one small database per server and they have a smart way to send the tasks to the right server to retrieve the data they want. Because you have to build on top of something, we are a small company. The total number of employees, I don&rsquo;t know, it&rsquo;s 100 plus now, but the back-end team is still 15 people or something like this. We don&rsquo;t have too many&nbsp;hands.</p><p><strong>David: [00:46:43]</strong> Yes. That&rsquo;s&nbsp;insane.</p><p><strong>Louis: [00:46:47]</strong> You ask what you do when there is a bug in the crawler and it affects how you conceive the programs because you know that something will run forever. The strategy becomes, I don&rsquo;t want to fix bug by hands. It&rsquo;s, you have an auto healing index. You crawl a page for the first time, and let&rsquo;s say you make a mistake. The number of links you counted is off by one. You know it was like this for three days because you deployed, it was broken. Three days later, you notice it, and you cannot go back in time. It&rsquo;s already too&nbsp;late.</p><p>Instead, what you do is that you fix your crawler. The way you store the data, you make sure that the next time you crawl the page, it overrides the previous version with something that is correct now. You have to have those auto healing processes, and you cannot attend to every small detail by hand, and the full rebuild of the index will be the last resort. Only if you have absolutely &mdash;</p><p><strong>David: [00:48:01]</strong> Did that ever&nbsp;happen?</p><p><strong>Louis: [00:48:06]</strong> It partially happened. Not everything, but there are things that were rebuilt once in a while. We were storing two things because we download pages, we download the HTML that we store, and then we have two counters. We have the counters we extract from the page. Let&rsquo;s say you have one link that you see twice in a page. You have this link and the number two attached to it, and then you have diff. You store diff, let&rsquo;s say, because you downloaded that page that belongs to the domain ahrefs.com. Now you see that that specific URL, for example, has three links that were not present&nbsp;before.</p><p>You store somewhere plus three, and later on you will aggregate all those plus three, plus one, minus one together. There are two different things. You have the absolute numbers and then you have those diffs. Once in a while, we have a bug that we didn&rsquo;t compute the diff correctly. Then we will rebuild the diff from scratch. We will go back to those absolute numbers, process them altogether and then restore it. Then when it happens, it can take a month, but it hasn&rsquo;t been done in a long time. It&rsquo;s a long&nbsp;process.</p><p><strong>David: [00:49:28]</strong> Right. That&rsquo;s interesting.</p><p><strong>Louis: [00:49:32]</strong> This is where OCaml is shining, too, because it&rsquo;s very easy to have multiple versions of the same type, for example. If you store data, with a version number in the database, you have a&nbsp;variant.</p><p><strong>David: [00:49:48]</strong> Yes, you treat it differently or?</p><p><strong>Louis: [00:49:50]</strong> It&rsquo;s fairly automatic and-&nbsp;yes.</p><p><strong>David: [00:49:59]</strong> Yes, as well we have diffing on HTML. One of the big features that we did, I think that was last year, that we have diffing for the content of the page, or the diffing of links, we have as well diffing of content. That&rsquo;s very&nbsp;good.</p><p><strong>Louis: [00:50:18]</strong> We have a lot of small funny features. We are one of the first company after Google, obviously, to render pages at scale. We have hundreds of servers running chrome, and as much as possible, when we download the HTML of a page, which is the raw HTML, then we will put it in Chrome, let it run for a while and then get the rendered version of that. Which is incredibly expensive time-wise, because it&rsquo;s much harder work than just downloading the HTML. We couldn&rsquo;t do this if there was no project like Chrome that would be open source and usable for free. We are standing on the shoulders of giants for&nbsp;this.</p><p><strong>David: [00:51:08]</strong> Imagine trying to create a web engine just to see a page from the server. That&rsquo;s very good. What&rsquo;s the favorite part of working at&nbsp;Ahrefs?</p><p><strong>Louis: [00:51:26]</strong> To me, is the people. I&rsquo;m not a SEO expert, and I&rsquo;m not a SEO fan either. I didn&rsquo;t join Ahrefs because I love to study the internet, that was not my goal, and I&rsquo;m not a marketing person, so I don&rsquo;t have a big use for SEO by myself. At first when I joined, the technical challenge was fun, but nowadays to me, the value is more the people. You get to meet smart people who work on complicated projects. I spend a lot of time dealing with interns, for example, which is super gratifying, I feel. I try to spend a good amount of time sharing with other people, working on the tooling or stuff like this. I really like that part, you can see the influence you have on other people when you make their life&nbsp;easier.</p><p><strong>David: [00:52:32]</strong> That&rsquo;s good. What&rsquo;s your favorite part of&nbsp;OCaml?</p><p><strong>Louis: [00:52:37]</strong> Of&nbsp;OCaml?</p><p><strong>David: [00:52:38]</strong> Yes. You can say the&nbsp;people.</p><p><strong>Louis: [00:52:41]</strong> When it compiles, it works. That&rsquo;s the key point. Unlike Go, we have some&nbsp;types.</p><p><strong>[00:52:41]</strong> [laughter]</p><p><strong>Louis: [00:52:59]</strong> If we are a bit serious, maybe not the language itself, but the LSP is super, super good nowadays. It&rsquo;s definitely a very good experience. We have to thank Tarides for all the work they are doing on the tooling over the past three years now, because it&rsquo;s&nbsp;crazy.</p><p><strong>David: [00:53:21]</strong> I think Tarides is carrying most of the boring work. Not boring work, but work that is always hidden. That you don&rsquo;t get any fame, but you will only get the trash. When the toolings don&rsquo;t work, you complain, and when tooling works, you just don&rsquo;t celebrate it. Tarides is behind, for sure. You have been going to ICFP, ICFP is international conference for functional programming, for quite some time. One of the verticals, or one of the parts of ICFP is&nbsp;OCaml.</p><p>Last year we outgrow our neighbors, our language neighbors, I think it was Scala, maybe, Haskell. I think we outgrow them. What do you think about the conference?</p><p><strong>Louis: [00:54:20]</strong> Same thing, it&rsquo;s amazing to go there and meet the people actually, because ICFP, it has multiple parts. The main track is a bit more academic. Even though some people who work at Ahrefs, they published there, but they were students when they did it. It&rsquo;s a bit more academic. Then you have all the workshops that are a bit more approachable, at least for me, but you spend one week with smart people who are very excited by what they&rsquo;re doing. This is the amazing part. Once a year, everyone is super happy to meet each other. This is very much a good experience, but it&rsquo;s- about conferences, I think the ReasonML ones were very, very nice&nbsp;too.</p><p>Again, I&rsquo;m a back-end person, but it was super cool to attend a conference on a different topic where people have different interests, and it was the early days of the language for people who were super interesting, the people who attended were curious and wanted to see something new. They had different ideas. I think that was super&nbsp;good.</p><p><strong>David: [00:55:36]</strong> Yes, those conferences were very good. I haven&rsquo;t attended any, actually, but yes, I heard Javi saying amazing things about them. Almost everybody who attended said good things. Why there&rsquo;s no OCaml conference?</p><p><strong>Louis: [00:56:00]</strong> This is a multifold answer, because it&rsquo;s actually a question that was asked. There is this, how is it called, the OCaml Software Foundation, because if we can explain how OCaml, the management of OCaml is that&nbsp;&mdash;</p><p><strong>David: [00:56:23]</strong> Please do. As core contributor of the code of conduct, please&nbsp;do.</p><p><strong>Louis: [00:56:27]</strong> There is the core group of contributors for the language, and out of that before there was something called the OCaml Consortium, I think, where companies could pay few thousand USD a year and it will give them a license to use OCaml not as an open source project. You could get the compiler and do changes on it and you didn&rsquo;t have to publish the changes again. It was also a way to just sponsor the OCaml development. They took it to a different level. They created this OCaml Software Foundation that is pushing some efforts around&nbsp;OCaml.</p><p>One question was, do we want to have an OCaml conference or do we want to have OCaml- maybe not conference, but smaller events but that could happen more often. Where will we put those events in the world? You need people with time, you need people with money, and you need to find the right place for the right people to attend. I think no one has all those resources, including the mental space to build fancy ideas on what to put in a conference. I cannot provide a definitive answer because I&rsquo;m not the one deciding on all those things, but I think it&rsquo;s a combination of all those that makes the ICFP the place to&nbsp;be.</p><p><strong>David: [00:58:05]</strong> Right, because this year is on Seattle. Every year it changes the location.</p><p><strong>Louis: [00:58:13]</strong> Yes.</p><p><strong>David: [00:58:16]</strong> Last year we released we- I didn&rsquo;t but yes, OCaml released multicore and effects or handling effects. We chatted a bit, a lot at work about this, and I think you said multicore was not something that needs to happen, but you are not very excited. On the contrary, you said the effects are a big deal. Thinking about the person that doesn&rsquo;t know a bunch about what effects are, could you do a short summary and then explain why those are exciting?</p><p><strong>Louis: [00:59:01]</strong> I&rsquo;m not a specialist with effects either but to me, a parallel will be to talk about Rust. In Rust, you have those ways to, how is it called? Borrow checker. You have a way to know to who one value belongs. It heavily affects how you are writing code because then you need to architecture your code in a way that is safe. Do you know that, for example, that value can only be used by one bit of code at a&nbsp;time?</p><p><strong>David: [00:59:45]</strong> Right. Otherwise, you would have crazy bugs. Data corruption</p><p><strong>Louis: [00:59:56]</strong> That would be C. Rust came in and was provided this safety. That&rsquo;s a bit the same idea in OCaml. It&rsquo;s like you come with effects and I think it has many usages that I do not completely understand, but some of them allow us to change the way we do concurrent or parallel computations, and it makes it safe. Like the borrow checker makes the Rust code safe. This is definitely affecting the way you write code because now you have one more tool to express your ideas. I think this is definitely changing the way the language will be&nbsp;used.</p><p>While the multicore, it&rsquo;s just in the background, it is happening, but this is not the tool. This is just a mean, so it&rsquo;s like, how do we do fast computation? Do we need to split stuff on different cores and how do you do it? Either you fork or you do multicore. In a way, it could be completely hidden behind a magic API and I will not know if it&rsquo;s fork or multicore, and it&rsquo;ll be fine to me as a user. If you have something like the borrow checker in Rust, this is actually a language feature, and this is something I see day to day and it is affecting how I can think and what I can&nbsp;express.</p><p><strong>David: [01:01:36]</strong> Right. I see, I see. Yes, because right now one of the features that Jane Street, the famous company that does the Wall Street and whatnot and pushes OCaml for the next level, they have a team working on the OCaml compiler, and one of the big fears that they want to work on, I think, they call it locality or local, global variables. Would that express, I have no idea about those rather than watching Stephen Dolan at the presentation on last ICFP, but would that allow some of the users of OCaml that they do care about the memory layout or the owner of the variables to express those different changes regarding using multicore?</p><p><strong>Louis: [01:02:34]</strong> I don&rsquo;t know exactly&#8202;&mdash;&#8202;My own&#8202;&mdash;&#8202;I mean, I have a light understanding of that. To me, I think it would be interesting even if there was no multicore, the stuff they&rsquo;re doing local/global because we already had concurrency with lwt or stuff like this. It has benefits because you control your allocations too. You can decide what is allocated on the stack versus what is allocated on the heap. It can have big performance implication.</p><p>This is an exciting feature, but this is maybe where you see my C background that when I was in uni, the first year was just writing some C code and we had to rewrite Bash. We had our own version of Bash. We spent two months writing in Bash or stuff like this. We had to deal with many of the small like&#8202;&mdash;&#8202;You are launching a bunch of processes together and you have to manage your memory or whatever, or we had to rewrite malloc, so we&nbsp;&mdash;</p><p><strong>David: [01:03:53]</strong> Okay.</p><p><strong>Louis: [01:03:56]</strong> I know little bits about memory management and how to deal with pointers because I did those projects in the past. These local, global things seems appealing, but at the same time, it&rsquo;s probably not critical. It&rsquo;s not going to change the vast majority of the code that is written in general. All my small personal projects or even most of the code that is running at Ahrefs, performance is not key. I care more about the fact that the code is readable and stable rather than performance, I would&nbsp;say.</p><p><strong>David: [01:04:42]</strong> Yes. Only in somewhere else. Yes, I see your point. Usually, code, for example, just like a web API were way, way fast enough. There&rsquo;s no point to optimize the endpoints. Most of our endpoints I think we have 500 endpoints. That&rsquo;s optimizing one by one or optimizing 10% of them, they would not change absolutely anything.</p><p><strong>Louis: [01:05:10]</strong> We spend so much time doing queries to different databases or http query to gather whatever we need to gather before to answer a request. This is so expensive compared to what we do most of the&nbsp;time.</p><p><strong>David: [01:05:28]</strong> Right. That&rsquo;s true. That&rsquo;s true. Why do you think Ahrefs is such a different company? When I have experience with the&#8202;&mdash;&#8202;It&rsquo;s because of the culture maybe? Here we don&rsquo;t have real management, we don&rsquo;t have product owner. We don&rsquo;t have many things that when you come from working on the SaaS companies that are from the culture of US maybe, or some Europe companies. In Ahrefs we don&rsquo;t have anything like that. Can you say that it&rsquo;s good or bad and&nbsp;why?</p><p><strong>Louis: [01:06:07]</strong> It&rsquo;s good and bad. There are definitely some downsides. Why it&rsquo;s like this, is also because the company is young and small too. It&rsquo;s what? 10 years old so it takes time. Every time you want to make a change company-wide, it probably takes two years to actually make change&nbsp;happen.</p><p><strong>David: [01:06:33]</strong> Okay.</p><p><strong>Louis: [01:06:35]</strong> This is not the only company with a structure that is not well&nbsp;defined.</p><p><strong>David: [01:06:44]</strong> Right.</p><p><strong>Louis: [01:06:44]</strong> What happens is that there is a structure, it&rsquo;s just people don&rsquo;t have the title because actually when you have been in the company for a long time, you own some bits of codes and there are people who are expert on the subject. Then there are people that you trust for something and people that you trust for something else. Even though there is no direct management, there are people taking decisions, so who is taking the decision, right?</p><p><strong>David: [01:07:16]</strong> Right.</p><p><strong>Louis: [01:07:17]</strong> It&rsquo;s good to be flexible and it allows more or less anyone at some point to take a decision if they want to and if they dare to. The downside is that sometimes you don&rsquo;t know if you can take the decision or not, and you don&rsquo;t know who you should talk to and then there are some hidden politics because some products, some features there, they belong to someone. You don&rsquo;t want to offend that person so you can&rsquo;t go and touch this or stuff like&nbsp;this.</p><p><strong>David: [01:07:51]</strong> Well, I need to interrupt here. I think you have been way too long at Ahrefs to realize what politics&#8202;&mdash;&#8202;What it means because in Ahrefs there&rsquo;s literally zero politics or not politics, but battles or discussions for the sake of discussion, it&rsquo;s nearly zero. I think that&rsquo;s one of the things that at the beginning of like, are we not talking about this and somebody said no need to. It&rsquo;s the culture of getting very direct and very technical focus.</p><p>I think when you work in a company that you can be weeks without knowing what to do or just months working on so many processes that are close to useless from your point of view or maybe very beneficial from an individual contributor, you feel like you are losing your time. In Ahrefs I don&rsquo;t think I have been noticing a layer I thought I&rsquo;m losing time because of the company it&rsquo;s the other way around. Oh, my peer is asking me to implement something that needs to be done and I haven&rsquo;t finished yet. That&rsquo;s more the feeling of the work,&nbsp;right?</p><p><strong>Louis: [01:09:09]</strong> I guess it&rsquo;s not politics looking for power because there is no power to&nbsp;gain.</p><p><strong>David: [01:09:16]</strong> Exactly.</p><p><strong>Louis: [01:09:17]</strong> What do you want to own? There is nothing to own. You can try, but there is nothing to win at the&nbsp;end.</p><p><strong>David: [01:09:26]</strong> Getting to the last questions now, but have you been following a little what Javi and Antonio and a little bit of myself having worked in Melange. What&rsquo;s your opinion about&nbsp;Melange?</p><p><strong>Louis: [01:09:43]</strong> I know what Melange&nbsp;is.</p><p><strong>David: [01:09:46]</strong> Definitely.</p><p><strong>Louis: [01:09:47]</strong> Okay. What do I think about Melange? Again, it&rsquo;s a question that is hiding other questions. Let&rsquo;s say technically, for example, this is pretty impressive. What the four of you have been able to do in a few months is amazing. Because just to give some context, it&rsquo;s like moving&#8202;&mdash;&#8202;Okay, Melange was not super, super alive, six months ago. The project was moving but slowly. There was no Dune support, there was not much stuff happening. Then six months later, you have the whole Ahrefs front-end, which is like, hundreds of thousands of lines of code that are written by what? 30 people maybe&nbsp;now.</p><p>It&rsquo;s completely moved to Melange. This is amazing. I&rsquo;m able to compile all this code in one comment. I go in the repo, I do &ldquo;make dev&rdquo; and everything works.</p><p><strong>David: [01:10:56]</strong> These and many more advances, but yes, that&rsquo;s the part that it&rsquo;s&nbsp;funny.</p><p><strong>Louis: [01:11:04]</strong> Yes, it&rsquo;s amazing. It automatically works and it didn&rsquo;t break the experience of anyone so it&rsquo;s compatible with what was bucklescript or rescript beforehand. It&rsquo;s compatible with native code at the same time. It&rsquo;s amazing. What do I think about the project? Another side of the question will be, was it the right thing to do to fork rescript? Or, is it the right way to do it? Is it good to have a fork of the compiler inside of Melange to achieve that project? I don&rsquo;t have a strong opinion on&nbsp;it.</p><p>I don&rsquo;t have enough experience. After all those years of seeing Reason and Bucklescript evolving, I believe that the experience of the end user, so the developer that is using these tools, is more important than the technical implementation. Is it the best way to do it? I don&rsquo;t know. Does it give a good end user experience? Yes, then that was the right thing to&nbsp;do.</p><p><strong>David: [01:12:21]</strong> On those tools, you would always prioritize the developer experience, rather than technical merits? How would you choose&nbsp;&mdash;</p><p><strong>Louis: [01:12:33]</strong> As a user or as a developer of those&nbsp;tools?</p><p><strong>David: [01:12:36]</strong> As a developer of those&nbsp;tools.</p><p><strong>Louis: [01:12:39]</strong> As a developer of those tools, given the target, given what I see of how you build a community and it&rsquo;s like the early days of Melange, I would prioritize user experience. I think, for example, all the efforts that have been put into making Dune work, I think the target was the user experience at the end. Because we couldn&rsquo;t make it work another way. If we didn&rsquo;t have this, I&rsquo;m not sure that we would have moved to Melange, for&nbsp;example.</p><p><strong>David: [01:13:19]</strong> I&nbsp;see.</p><p><strong>Louis: [01:13:20]</strong> What&rsquo;s the downside was that for example, this is not the fastest implementation there is. I think there is some many different calls to this Melange compiler that are not the fastest way to do it, but the UI is good so we still use&nbsp;it.</p><p><strong>David: [01:13:44]</strong> What I would like to feature, knowing that at the start Bucklescript got born, even though they were like js_of_ocaml. Now, I think, eight or nine years past, Rescript got its own path, but then Melange is trying to again, be part of the OCaml to Javascript compilation, or Reason to Javascript compilation. How do you see the future? Because eventually, nobody wants to have two ways to Javascript.</p><p><strong>Louis: [01:14:16]</strong> I&rsquo;m not sure that&rsquo;s true. Why would people not want many ways to do the same thing? It&rsquo;s like if you look at other languages, actually, many of them have different ways to do the same thing. Why not OCaml? As long as the projects don&rsquo;t die, it&rsquo;s not like Melange is attacking jsoo or jsoo is attacking Melange. It&rsquo;s like, people don&rsquo;t hate each other. They are not fighting for users; I think the targets are a bit different.</p><p><strong>David: [01:14:53]</strong> You would want different ways of combining to Javascript? Because the sane competition? That&rsquo;s&nbsp;true-</p><p><strong>Louis: [01:15:03]</strong> To me it&rsquo;s not the sane competition. It&rsquo;s more that I think it targets different audience. It tries to do different things. One example will be during one of the Reason conferences, we wanted to do a workshop and we wanted to show atdgen which is a tool we&rsquo;re using a Ahrefs lots to parse and write JSON. It&rsquo;s protobuf but for&nbsp;JSON.</p><p><strong>David: [01:15:34]</strong> Yes, it would give us type safety from front end all the way down. Sorry, backend all the way&nbsp;down.</p><p><strong>Louis: [01:15:43]</strong> Yes.</p><p><strong>David: [01:15:43]</strong> Sorry, go&nbsp;on.</p><p><strong>Louis: [01:15:46]</strong> You have as with protobuf or with Graphql too you have a definition, you have a file with type definitions and from the definition you derive OCaml code or Python code or TypeScript code. It supports multiple languages. To do so you need an atdgen binary. In the Reason conference, you have people using Linux, Windows, Mac, different version, whatever so how do you give a binary that everyone can use? In two minutes, I just went into the atdgen repo and I enabled js_of_ocaml compilation inside Dune and now my binary is actually JS file that I can run in node&nbsp;JS.</p><p><strong>David: [01:16:34]</strong> Right.</p><p><strong>Louis: [01:16:35]</strong> I don&rsquo;t think that Melange aims to do that. Because then&nbsp;&mdash;</p><p><strong>David: [01:16:41]</strong> I think that&rsquo;s the magic. Yes, I&nbsp;agree.</p><p><strong>Louis: [01:16:44]</strong> In Melange you will have one file per module or something like this, which means I will need to run through webpack or something like this later&nbsp;on.</p><p><strong>David: [01:16:51]</strong> Yes, you could but you would face a few problems. Marshall for example, that it&rsquo;s the encoding/decoding on bytes, that doesn&rsquo;t work in&nbsp;Melange.</p><p><strong>Louis: [01:17:01]</strong> Well, it doesn&rsquo;t work in js_of_ocaml I think&nbsp;too.</p><p><strong>David: [01:17:05]</strong> Yes, but I think you can stub it, right? I think you can&nbsp;&mdash;</p><p><strong>Louis: [01:17:10]</strong> But I would say most of the time actually you don&rsquo;t care because it&rsquo;s corner cases, it&rsquo;s just that the UI they provide is good enough for OCaml people and Melange, it provides the nice, what? FFI, for example, to interact with the JavaScript code. The way it outputs code is closer to the JavaScript way too; I would say so it&rsquo;s easier to make webpack or other tools like this work&nbsp;together</p><p><strong>David: [01:17:39]</strong> Yes, I agree that those are different targets. It just my point of view was more like, okay, js_of_ocaml the crazy thing is that you have entire project in OCaml. You add one line say in Dune compile to node JS please and then you have a single file that is compiled to JavaScript. That&rsquo;s insane so if you have, for example, a compiler written in Menhir it&rsquo;s a language to write compilers in OCaml, you can compile it to JavaScript in one line or any library, even drivers, even anything that you can imagine. That&rsquo;s the valuable position or thing that gets people to try js_of_ocaml very fast. But on the contrary, the documentation is very&nbsp;bad.</p><p>It&rsquo;s the classic OCaml project that you need to understand 50% of the project to even start it so that&rsquo;s like&#8202;&mdash;&#8202;For people like me, I invest a lot of time trying js_of_ocaml and even try to write bindings to React and succeed but I did not succeed convincing people in Ahrefs, front end of Ahrefs to try js_of_ocaml. For me, that was the&#8202;&mdash;&#8202;That technology is not good enough for prime time or not good enough to convince my team, then yes, there&rsquo;s no way to convince any&nbsp;other.</p><p>On the opposite, Melange fits together the low barrier to try and good documentation and at some point, it gets complex but the ease of experience I think it&rsquo;s much better. But yes, you don&rsquo;t have a one line&#8202;&mdash;&#8202;You need to meddle it a bit on building the integration with your front end or your pipeline but yes, once it is done, it works. But yes, you would never do that with atd. The experience in atdgen that&rsquo;s not going to happen in&nbsp;Melange.</p><p><strong>Louis: [01:19:41]</strong> It&rsquo;s funny how you say it and it&rsquo;s true that it&rsquo;s easier. Many things in Melange are easier to experiment with and at the same time it&rsquo;s more complicated. For example, in js_of_ocaml you have a clear separation between OCaml types and JavaScript types. String that is an OCaml string is a different type from JavaScript string.</p><p><strong>David: [01:20:10]</strong> You have like a wrapper,&nbsp;right?</p><p><strong>Louis: [01:20:12]</strong> It&rsquo;s very explicit and it&rsquo;s good for the OCaml person because then you know when this is a part of the language you are comfortable with and then when it starts with JS, it&rsquo;s okay, be careful because you don&rsquo;t know what you are doing. This is easy and in js_of_ocaml. Because it&rsquo;s very easy. You see JS dot and then you know now I have a JavaScript value. In Melange it&rsquo;s your string is what? And you have to deal with the encoding. What is the actual encoding of a string in&nbsp;Ocaml?</p><p><strong>David: [01:20:57]</strong> Do you remember that I said that every time that I&rsquo;ll talk with a backend person, they always mention the runtime. Exactly that moment. You always think about the&nbsp;runtime.</p><p><strong>Louis: [01:21:06]</strong> Actually, I&rsquo;m not&nbsp;sure.</p><p><strong>David: [01:21:08]</strong> It&rsquo;s not the runtime itself, but the encoding. In Melange for example, of course, all the types not of course, but all the types that you have in language are the same representation as a JavaScript value. For example, a string is in a string, integration is a number, float is a number and so on and so forth. Variant is an object; a record is an object. Melange maps perfectly or as good as possible to JavaScript values. It&rsquo;s cool that you said that when every time that you work with js_of_ocaml, once you see JS dot, whatever this is the namespace and you know that you&rsquo;re treating with things that come from the&nbsp;client.</p><p>For example, that&rsquo;s a barrier for people that tried rescript or tried Melange in the first place because they don&rsquo;t understand why do I need a wrapper? Why do we need a generic for at type that already have? Because it&rsquo;s the mentality of why do I need to care about the&nbsp;runtime?</p><p><strong>Louis: [01:22:17]</strong> Yes, basically you pay a cost but at a different time, like in js_of_ocaml, you pay the cost very early because as soon as you write code you need to make the difference between the two words. In Melange you will only pay the cost if you write FFI and you need to care about the representation. It&rsquo;s if there is a string with something weird in it, you don&rsquo;t know the encoding of the string, for example, then you need to be&nbsp;careful.</p><p>The experience by default is much easier. It&rsquo;s just that when you are dealing with the boundaries then things can be a bit more implicit and probably you need to know the language better to do things the right way. It&rsquo;s easier and it&rsquo;s actually more complicated in some&nbsp;bits.</p><p><strong>David: [01:23:08]</strong> Yes, I think if you look now, js_of_ocaml and Melange are very drawn line. You can draw a line between the tradeoffs. One side is very clear, one side is very clear. Now, I would say that I&rsquo;m comfortable saying that both are balanced for the users, even rescript now. For me now, I have a feeling the three of projects are in the right column. You can classify them perfectly now. If you get into, &ldquo;Oh, I want to try this ML or like OCaml, whatever language as a whole,&rdquo; you can choose&#8202;&mdash;&#8202;Based on your team or your decision. You can choose clearly one&nbsp;another.</p><p><strong>Louis: [01:23:57]</strong> Yes. Actually, you said you couldn&rsquo;t sell js_of_ocaml to Ahrefs, but we can probably talk a bit about what was the discussion, what happened, because Javi and you, you actually tried to do something so that it could happen. You work on the React bindings and then you try to show that it could work. In a way, I think that js_of_ocaml, it could fit what we do because we don&rsquo;t depend on a lot of external code. One very interesting thing in Melange is that the FFI is very good. It&rsquo;s easy, convenient, to interface with other existing JavaScript libraries.</p><p>In Ahrefs, we have bindings to what, React, and then maybe one or two library to deal with the timestamps and charts. We don&rsquo;t have millions of bindings. We have maybe five big libraries we have bindings for, and then a bunch of smaller stuff. We don&rsquo;t bind to so many things and we don&rsquo;t need FFI that is amazing. It&rsquo;s not a priority. js_of_ocaml could have&nbsp;worked.</p><p><strong>David: [01:25:14]</strong> Could have worked. I&nbsp;agree.</p><p><strong>Louis: [01:25:16]</strong> The fact that even in this perfect setup for js_of_ocaml it fails is interesting. You find the right company with many OCaml people, many people who understand js_of_ocaml, and you don&rsquo;t need one of the best features of Melange and still, this is not actually the tool that won at the&nbsp;end.</p><p><strong>David: [01:25:42]</strong> Yes, that&rsquo;s true. The experience, I think that&rsquo;s exactly what you said, it could work, theoretically if you look at the direct from the outside or even if you look at far from the front end, it makes a lot of sense. Once we were working on this, I was working on this middle-end team, before it was not called middle-end. I was working on the middle-end, and most of my assumptions were like, &ldquo;It&rsquo;s going to work perfectly.&rdquo;</p><p>Because of what you said, right? Then when we try to&#8202;&mdash;&#8202;How can we write React, we are married to React. I think we like the model of components. We like the model of data; we like the composition. We&rsquo;re not going to change React. Let&rsquo;s bind it to React, so we create the same PPX and the same library to React. I think that was how Javi started and then we end up finishing.</p><p>did the emotion binding, so I know the CSS, everything worked and we felt like js_of_ocaml was very mature, but there were a few problems that you could not solve easily at the time. At the time js_of_ocaml didn&rsquo;t have Unicode support. Now they have some Unicode support or the parsing, I haven&rsquo;t followed that closely, but you would need another library to run to get the Unicode support that in Melange or Bucklescript at the time was natively. That was an issue. The other issue or biggest issue that you can&rsquo;t bypass is that js_of_ocaml, you compile it in one file, one gigantic&nbsp;file.</p><p>Incremental migrations were very hard or very difficult to iterate over time. You could migrate parts of the app, but then you would need to compile everything in both, have two duplicated apps. It was definitely not&#8202;&mdash;&#8202;The migration plan was impossible. We could try. I think we tried in one of the small apps, I think we could try wordcount, is one of the verticals we have at Ahrefs, with js_of_ocaml, and once we were trying those, we find the wrapper, it was very hard to&nbsp;sell.</p><p>The wrapper is like the Js.t that we call it in Recript, in js_of_ocaml I think it&rsquo;s JS.object. It&rsquo;s unsafe. You have JS.unsafe. There are many, yes, many constructions you can track with JavaScript differently from what we do with the bindings. That part was&#8202;&mdash;&#8202;With these three things that I said Rusty, which is one of let&rsquo;s say the only Tech Lead at Ahrefs, like the only person that&#8202;&mdash;&#8202;He&rsquo;s the CTO in the frontend, how I call&nbsp;it.</p><p>He was the person who we would need to convince to migrate to the frontend. He was definitely not on board with the idea. I think that&rsquo;s the main reason. He would chat with our people and people would say, &ldquo;Yes, fine, if Javi and David are happy, then we are all happy,&rdquo; but even though we migrate one small app, the experience was worse. The user experience of iterating over React components was worse or even the data was worse because you had this&nbsp;wrapper.</p><p><strong>Louis: [01:29:23]</strong> There were too honest in the way they named functions in the API. For example, all those unsafe functions, they exist in every FFI, it&rsquo;s just not called unsafe, but because it&rsquo;s called unsafe, people are like, &ldquo;They&rsquo;re not going to use this, you are not supposed to use it.&rdquo; Yes, you&rsquo;re supposed to use it. Just be careful when you do&nbsp;it.</p><p><strong>David: [01:29:47]</strong> I think you explain to me that anecdote, is that somebody asked Xavier Leroy the creator, the author of OCaml, they ask, &ldquo;What do you think about Objec.magic?&rdquo; Right? Object.magic is the method of OCaml that you can, like unsafe, coerce any variable, right? You can light the typechecker and say, &ldquo;Trust me, this is whatever, an array and it&rsquo;s a list or whatever&rdquo;. His answer was, it is like when you are working in the street, would you inject&#8202;&mdash;&#8202;How is that called? I don&rsquo;t remember the thing, but would you become a&nbsp;junkie?</p><p>You get a syringe, I don&rsquo;t know how to say in English, but would you inject some random thing on the street? That&rsquo;s not part of the language. I think you&rsquo;re explained me the anecdote, or maybe it&rsquo;s Javi, How do you see the purity of OCaml? Do you think that the OCaml is very pure or has some pragmatism on safety? Because of course it&rsquo;s type safe, of course, the compiler when it compiles it works, but you can bypass it from time to time. What&rsquo;s your&nbsp;opinion?</p><p><strong>Louis: [01:31:10]</strong> I don&rsquo;t think it&rsquo;s pure in any way, shape, or&nbsp;form.</p><p><strong>David: [01:31:17]</strong> You can write pure code,&nbsp;right?</p><p><strong>Louis: [01:31:20]</strong> Yes. You can write pure code. But for example, you have exceptions that are very pregnant, that are everywhere and you don&rsquo;t have any way to know if a function can raise an exception or&nbsp;not.</p><p><strong>David: [01:31:37]</strong> Right.</p><p><strong>Louis: [01:31:38]</strong> Okay, it depends what program you write, but basic things, you run your program, like a CLI that is running&#8202;&mdash;&#8202;I don&rsquo;t know, downloading something and you press control C like you want to stop your program. There is&#8202;&mdash;&#8202;It&rsquo;s a signal, and in OCaml it&rsquo;ll raise an exception that you need to&#8202;&mdash;&#8202;You can catch and you can do something with it, right? At any point in time, the user of your CLI can come and interrupt the program, right? Which means at any point in your program, you need to be able to deal with this interruption.</p><p><strong>David: [01:32:18]</strong> Right.</p><p><strong>Louis: [01:32:19]</strong> It&rsquo;s like as soon as you have these where is the purity, what is&#8202;&mdash;&#8202;You have no good way to protect yourself against all these issues. At the same time, I&rsquo;m probably biased because I have been using the language for long. It provides you what is good enough. There was some improvements because, I don&rsquo;t know if you remember, but at some point, the strings were mutable in&nbsp;OCaml.</p><p><strong>David: [01:32:51]</strong> Yes.</p><p><strong>Louis: [01:32:53]</strong> By defaults, the strings were actually what is called Bytes nowadays. It has been a big change. People had to fight to turn Bytes into string, because it was breaking code, obviously. There was more mutability. It was not as pure as it is nowadays, I would say that the balance is not too bad. Could it be more? Probably. There are some things that we can&rsquo;t really express in OCaml, like ownership of a&nbsp;value.</p><p>Like you open connection to a database, you have a handler or something like this that you want to use only at one point in time and you don&rsquo;t want to share. You have no way to express it. Then you can&rsquo;t really protect yourself against the steal. The code can take that value, put it in a global reference, and it can be suddenly reused elsewhere. This is where, for example, the local/global stuff&nbsp;&mdash;</p><p><strong>David: [01:34:06]</strong> Yes, solve exactly that&nbsp;issue.</p><p><strong>Louis: [01:34:09]</strong> Yes. This kind of issue. Is it a problem? Yes. Is it a problem that we face at work? Yes. For example, we see like&#8202;&mdash;&#8202;We have one problem where people can open the connection to a DB using one of those&#8202;&mdash;&#8202;A common pattern in the ocaml to do like &ldquo;with_db&rdquo; for example. Then you pass a continuation, you pass a function, and then this with_db function will create a DB handler and pass it to your function later&nbsp;on.</p><p>Inside your function, you can do one more with_db. This is something that you probably want to forbid because you don&rsquo;t want to open connections after connection after connection when there is already one available.</p><p><strong>David: [01:34:57]</strong> Right.</p><p><strong>Louis: [01:35:00]</strong> For now, how do you fix this? This is an actual problem and you have no good solution. But maybe you write different code than I do. You write code that is in the browser or just behind the browser so maybe you have different views. You have to deal with more mutability than I do, for example the whole DOM, before React. Yes, but before React no one assumed that anything was immutable in a browser. Everything could be changed at any point in&nbsp;time.</p><p><strong>David: [01:35:43]</strong> Yes. That&rsquo;s why in the browser many APIs were pushing for observables, right? You accept mutability into all your values and then you say any value can change in any time and you need to subscribe to&#8202;&mdash;&#8202;Listen to the changes or not and that&rsquo;s the trend of&#8202;&mdash;&#8202;I think that was one of the biggest inclusions of ES4 that didn&rsquo;t get published and they tried with ES5 and they didn&rsquo;t get to the language neither that are like these observables concept. I think they come from React JS and they come from reactive programming from, I don&rsquo;t know, 30 years ago where sometimes reactive is very useful. Before React, I would say that not many people did&#8202;&mdash;&#8202;The immutability was not part of their fashion of writing&nbsp;code.</p><p>We are very far from those problems. We do immutability in a few places, for example, we have a global theme, a CSS theme, right? You can have a dark or light theme. We interact with the browser directly. We opt out from React to do that because the performance is better. You can load that at the beginning, you can then allow React later. But the way it&rsquo;s just very self-contained, right? You will never want to write your data reactive.</p><p>Maybe you want, but for example, for Ahrefs it doesn&rsquo;t make any sense because our data is you have tabular data that never changes on your session, right? It&rsquo;s not live data. It&rsquo;s like you open a report and the report is the moment time that you request. There&rsquo;s no live thing. Nothing is very reactive in nature so yes, for us it&rsquo;s just like a perfect&nbsp;sense.</p><p><strong>Louis: [01:37:41]</strong> You would be happy with more&nbsp;purity?</p><p><strong>David: [01:37:45]</strong> Would we be happy with more purity? No, I think&nbsp;&mdash;</p><p><strong>Louis: [01:37:49]</strong> Would you wish to have a language that is closer to Haskell that is like&nbsp;&mdash;</p><p><strong>David: [01:37:54]</strong> No, I don&rsquo;t think so. I think no, because purity makes&#8202;&mdash;&#8202;Purity in some places makes your life so much better, right? But often you want the tools to be pure so like libraries that you create or you consume need to be pure but your application needs to do all sort of things, right? Your application or when you are a product engineer, you want to just ship fast and if something gets you in your way and you store it globally and deal with it later or store it globally and be safe and then forget about&nbsp;it.</p><p>You need to do things perfectly and draw the line and architect things that slows you down insanely. I think the line&#8202;&mdash;&#8202;OCaml is very well position where you can opt out, do your life easy and then move back and run fast. But yes, my tools to be pure or libraries that I&rsquo;m using or even&#8202;&mdash;&#8202;I know I&rsquo;m working on styled-ppx so making types safe, like your styles. I think that&rsquo;s something that I&rsquo;ve been pushing but yes, you want that tool to be type&nbsp;safe.</p><p>You don&rsquo;t want to do all your things on your app perfectly, to demand it perfectly mostly because on the web, everything is changing all the time. On the backend it&rsquo;s a little bit different but on the web, iterations are just much more common than in the&nbsp;backend</p><p><strong>Louis: [01:39:31]</strong> I find it interesting that everyone is pushing for immutable stuff. At least my impression is that in the front end React maybe didn&rsquo;t create this trend but made it popular. My understanding is that you deal with the DOM as an immutable object. You never manipulate the DOM directly anymore. You do it through React. You have an immutable object, more or less, which goes against many things that happened, historically in a browser, the way the DOM is implemented is completely not like this. It has some interesting benefits.</p><p>You can have any extension in your browser that are changing part of your page. I&rsquo;m using one daily. I&rsquo;m using Dashlane to store my passwords. It does stuff for&#8202;&mdash;&#8202;If there is an input field, it&rsquo;s creating a popup and I can click, input my password in that specific&nbsp;field.</p><p>To do this, it has to inject HTML in the page actually. But it breaks. Some apps are crashing because of this. Some apps, some websites, they&rsquo;re not crashing. They will just see that there is a change coming from my extension and they will just discard it and rerender without my&nbsp;stuff.</p><p><strong>I</strong>t goes against many things that happened for 20 years, more or less. You have to make both of those worlds still somehow work together.</p><p><strong>David: [01:41:18]</strong> I think React did&#8202;&mdash;&#8202;I think not even React, Meta did that all the time. They pushed for a solution that is way better in some areas but destroys previous effort insanely. For example, with GraphQL, I think it&rsquo;s happened the same. They say, &ldquo;You&rsquo;re going to have one endpoint. It&rsquo;s going to be through POST.&rdquo; You would call this endpoint all the time, which goes against completely about REST what we were doing&nbsp;before.</p><p>Of course, with all the tradeoffs, if you go 10 times&#8202;&mdash;&#8202;10 years back and you say to a person, &ldquo;No, we call all the time same endpoint.&rdquo; You will say, &ldquo;You guys are&nbsp;stupid.&rdquo;</p><p><strong>Louis: [01:41:58]</strong> RESTful was a&nbsp;trend.</p><p><strong>David: [01:42:00]</strong> Exactly. The RESTful, you will need to add the link to go to the next resource. Of course, all the people would scream at you. Similarly, it happens now with server components. I don&rsquo;t know if you are following the thing. Again, they are pushing for a new concept that they have mined in their business and works well. The rest of the people are like, &ldquo;No, that&rsquo;s just insanity.&rdquo; I think React, the first concept is you&#8202;&mdash;&#8202;The insert and update are the same operations.</p><p>There&rsquo;s no create the DOM and then update the DOM. It&rsquo;s always like, &ldquo;Do the thing.&rdquo; It&rsquo;s just rerender. Just because they push for that approach and they delay, of course, the first load is going to be slower. You don&rsquo;t have serialization. Then later updates are going to be&nbsp;faster.</p><p><strong>Louis: [01:42:58]</strong> Actually, even the later update are slower, because you need React to do this diff between the two version and to only update the relevant part of the DOM. React is doing what the browser was actually doing. You are duplicating the work and you are doing it in JavaScript, which is slow. The browser was doing it in a very optimized C++&nbsp;code</p><p><strong>David: [01:43:26]</strong> Fair point, but the DOM is fast enough. I think I read a lot of articles about anti-React that the DOM is fast enough. I think that&rsquo;s&#8202;&mdash;&#8202;These benchmarks are nonsense. Those benchmarks&#8202;&mdash;&#8202;Even the benchmarks that&#8202;&mdash;&#8202;I would call it micro-benchmarks. Even microbench like&#8202;&mdash;&#8202;I don&rsquo;t know, work faster, implement some charting library mutable to DOM and using whatever, Vanilla JavaScript or using React. Of course, you can outperform React but at what&nbsp;cost.</p><p>The cost of creating two charts, two components of a chart, the API nicely, blah blah blah blah rather than mutating the DOM all the time. That&rsquo;s super expensive. When you&rsquo;re working, for example, for Ahrefs, I think we have&#8202;&mdash;&#8202;I don&rsquo;t know, 2 million lines of code in reason. I don&rsquo;t know, 5,000 components. Some insane amount of number of components. If you do that in mutable or maybe not mutable but maybe just going to DOM and listening to DOM and hoping that everybody is a good citizen. It&rsquo;s just you would slow down development so hard that it doesn&rsquo;t make any&nbsp;sense.</p><p>I think React draw this line where virtual DOM is like if you know how to create the structures, know how to trigger the renders, I think can be as good as the DOM, of course. In general terms, I think it&rsquo;s good enough. I think the balance is very OCamly. [laughs] You know that Jordan was behind, when&#8202;&mdash;&#8202;Jordan is an OCamler that knows this balance, that&nbsp;&mdash;</p><p><strong>Louis: [01:45:23]</strong> It&rsquo;s funny, because you could say that for example Facebook has enough resources to make it work, right? They could have decided it is going to be a more troublesome for our developers, but we are going to offer a faster experience for the customers, the people actually visiting the website. But even them with their infinite resources, they decided to go in a different direction. Is it because it&rsquo;s a tech company? I feel that some big tech company, they run the way they do, because they are led by technical people, so they can make technical choices instead of business choices sometimes.</p><p><strong>David: [01:46:08]</strong> React is that, exactly that case. I think I saw the documentary about React, and it&rsquo;s more the idea just spreaded everywhere. I think they have that competing library; I don&rsquo;t know how, I think it&rsquo;s called Jacks or something. I don&rsquo;t the name, but they have a competing library that was written with PHP and XML, and the whole stack on meta back in the days. The idea of React spreads everywhere. The point that you made before of developer experience leads everything in the early days. I think that it just applied exponentially, because at some point they released publicly, everybody hated JSX. Then after one year it was the most famous library used. Then from now on, the monopoly went for, I don&rsquo;t know, six, four years, I don&rsquo;t know. So many years that now everybody has the component model, the hooks, the state. It spread the idea everywhere. It&rsquo;s interesting, but I think it&rsquo;s just like <strong>[unintelligible 01:47:11]</strong>&nbsp;,&nbsp;so.</p><p><strong>Louis: [01:47:13]</strong> How smart do you need to be to Jordan and be correct about React was the right thing to do, and to do it properly, and then Reason was the right thing to do, and to do it properly?</p><p><strong>David: [01:47:25]</strong> How smart need to do. I don&rsquo;t know. Uncountable, I would say. Hard to quantify smartness. It&rsquo;s hard to quantify smartness, but I think it&rsquo;s even harder when you look at what Jordan has been doing. I think Jordan is the kind of person when you speak with him, he talks, or he says things that doesn&rsquo;t make sense at the beginning. It&rsquo;s his way of thinking. He&rsquo;s thinking three, five years ahead, and when he explains the idea to you, you are like, &ldquo;I got the sense that I didn&rsquo;t understand anything.&rdquo; After a few months you start saying, &ldquo;Oh, right, it made sense.&rdquo; I think everybody on the React team only says how brilliant Jordan is. So,&nbsp;yes.</p><p><strong>Louis: [01:48:18]</strong> It&rsquo;s interesting that you interviewed Rudi, the author of Dune, and he said that even him, for example, originally when he saw the Reason syntax, he was like, &ldquo;meh,&rdquo; like, &ldquo;What is this thing?&rdquo; Like, &ldquo;Yet again?&rdquo; He say, &ldquo;Yes, at the end it was right to make it more approachable.&rdquo; This was from a user experience perspective. It&rsquo;s a clear&nbsp;benefit.</p><p><strong>David: [01:48:44]</strong> Yes. I love that interview, because Rudi said exactly that, like, &ldquo;Oh, at the beginning Reason felt like a toy, but then we were doing tooling for OCaml, and the language and a lot of work on the actual language. Reason was the thing that bring more people on OCaml, than we never, ever did. Even though it&rsquo;s not a competing language, even though the person that created has so much power into the frontend people, even that the number of people that got into OCaml community, it was bigger than any other effort that we made. [laughs] Which for me is super funny at the end of the day, because most of us came from the JavaScript and end up doing OCaml and mixing everything. That was the&nbsp;idea.</p><p><strong>Louis: [01:49:40]</strong> It&rsquo;s funny how you need a little bit of luck for all those things to work. You need, for example, Rudi to decide early on, &ldquo;Okay, I don&rsquo;t really trust this thing, but I still I&rsquo;m a good citizen, so I will add the support inside&nbsp;Dune&rdquo;</p><p><strong>David: [01:49:56]</strong> Yes. That&rsquo;s very&nbsp;noble.</p><p><strong>Louis: [01:49:58]</strong> It&rsquo;s like if you don&rsquo;t have those people who are able to compute this is maybe good or maybe bad, and are able to balance their opinion, versus the community thing. They have to do it early enough, at the right time. It&rsquo;s interesting that somehow&nbsp;&mdash;</p><p><strong>David: [01:50:24]</strong> Of course, not what everything Jordan says is correct, I think in the sense of, of course, he created stuff that was definitely not on shape or not on the area of success of React, of course. I think he created React and then React native. Of course, they both are insanely successful. Reason I would call it successful as well, but actually, push the idea of Esy. Esy is the package manager that is still somehow used, and some people love it. Even myself, I have a lot of respect for Esy, and use it from time to time. That you can consume JavaScript libraries, npm packages as well as OPAM packages.</p><p>This project has been suffering for long, that it&rsquo;s definitely not the right solution, or at least, it didn&rsquo;t create these ideas, this sudden idea to the rest of people to continue pushing for&nbsp;it.</p><p><strong>Louis: [01:51:27]</strong> This is one of those tools where I think the technical implementation was good, but the UI was not great. The output is just not nice, for example. You run it, and then it displays&nbsp;some-</p><p><strong>David: [01:51:44]</strong> You mean, the actual UI, the&nbsp;CLI?</p><p><strong>Louis: [01:51:46]</strong> Yes, because opam, which is not the most fancy tool ever, but still when you opam install, it has some colors. It doesn&rsquo;t display one line production. It&rsquo;s some kind of somehow clean output that Esy doesn&rsquo;t have. You had to learn this weird JSON syntax to put your package, and it outputs ugly text after that. The idea was very good, but the UI was not completely working.</p><p><strong>David: [01:52:24]</strong> I think Esy has some, people call it state-of-the-art ideas, the end goal of our package manager, what do you want to do, or we want to use. The efforts of maintaining the overrides or being on top of all the libraries or even compiles Esy, there&rsquo;s a lot of maintenance that needs to get done. At some point, we have a team of, I think, six, seven persons working on it, and that experience was very good, but from when Reason got a little bit lost, this team, those people&nbsp;&mdash;</p><p>Of course, when the blockchain companies started hiring all of them to work for Web3 and paying them insanely amount of money, then the project got a little bit carried over, got a little bit less maintenance then is likely in a stale mode that you can use, but you could get not as good as&nbsp;opam.</p><p><strong>Louis: [01:53:35]</strong> This exactly why there is no Rust code inside Ahrefs, because all the developers got stolen by the blockchain companies.</p><p><strong>David: [01:53:45]</strong> That&rsquo;s fair. That&rsquo;s fair. I think, Louis, we are running out of time. For me is daytime, I can do stuff, but for you is definitely night time. I can work, talk with you for hours and hours, but I think the show is reaching to a point to finish. It was a pleasure to have you, of&nbsp;course.</p><p><strong>Louis: [01:54:07]</strong> It&rsquo;s a pleasure.</p><p><strong>David: [01:54:09]</strong> If somebody attends to ICFP, please go to Louis, I think he&rsquo;s the party manager, and as well, a person very interesting to talk to. Please, bother him. I think he&rsquo;ll be in Seattle on September.</p><p><strong>Louis: [01:54:26]</strong> Yes, Seattle, September 4th to 9th, I think, something like that. It will be online too, this year. I think it will be online and for free. All the talks, at least all the ML, or maybe not ML, but the OCaml workshop will be online of free. There is no need to travel all the way to Seattle to see the talks, at least to see the OCaml workshop.</p><p><strong>David: [01:54:52]</strong> Makes sense. In this era of internet, I think that makes sense. Cool. Thanks everybody for being here. You&rsquo;re having a little bit late day, but that was perfect. Thanks, Louis, to spend time with&nbsp;us.</p><p><strong>Louis: [01:55:07]</strong> Thank for having me. That was&nbsp;fun.</p><p><strong>David: [01:55:10]</strong> See you&nbsp;guys.</p><p><strong>[01:55:13] [END OF&nbsp;AUDIO]</strong></p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7767afbfbdb9" width="1" height="1" alt=""/><hr/><p><a href="https://tech.ahrefs.com/emelletv-talking-with-louis-roche%CC%81-about-ocaml-and-ahrefs-7767afbfbdb9">EmelleTV: Talking with Louis Roche&#769; about OCaml and Ahrefs</a> was originally published in <a href="https://tech.ahrefs.com">Ahrefs</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
