---
title: OpenAI and structured outputs from OCaml
description: with magic, without (touching) JSON
url: https://tech.ahrefs.com/openai-and-structured-outputs-from-ocaml-b198fcf701ca?source=rss----303662d88bae--ocaml
date: 2025-03-07T14:00:13-00:00
preview_image: https://miro.medium.com/v2/resize:fit:1200/1*fqTZQ1N1O61fct-kRKAXSA.jpeg
authors:
- Ahrefs
source:
---

<figure><img src="https://cdn-images-1.medium.com/max/1024/1*fqTZQ1N1O61fct-kRKAXSA.jpeg" alt=""></figure><h3>What makes this approach&nbsp;special?</h3><p>OpenAI offers a way to have (relatively) typed communication through <a href="https://platform.openai.com/docs/guides/structured-outputs">structured outputs</a>. A json schema must be passed alongside the prompt. And the answer is guaranteed to follow that&nbsp;schema.</p><p>When working with OpenAI’s structured outputs, you typically need&nbsp;to:</p><ol><li>Define your data structures</li><li>Create a JSON schema that describes these structures</li><li>Parse the API responses back into your data structures</li></ol><p>This usually involves writing and maintaining JSON schemas by hand, which can be error-prone and tedious. The approach we’ll explore in this project eliminates this manual work&nbsp;by:</p><ul><li>Using <a href="https://github.com/ahrefs/ppx_deriving_jsonschema">ppx_deriving_jsonschema</a> to automatically generate JSON schemas from OCaml&nbsp;types</li><li>Combining it with ppx_yojson_conv to handle JSON serialization/deserialization</li><li>Creating a type-safe pipeline from OCaml types to OpenAI API and&nbsp;back</li></ul><p>This means you can define your data model once in OCaml and get both the schema for OpenAI and the parsing logic for&nbsp;free!</p><h3>Setting up the OpenAI&nbsp;client</h3><p>The bindings to the API are kept fairly minimal in this example. We are using <a href="https://github.com/ahrefs/devkit">Devkit</a> for the http client. And ppx_yojson_conv to conveniently emit/parse the necessary json.</p><pre>open Ppx_yojson_conv_lib.Yojson_conv.Primitives<br><br>let api_key = Sys.getenv "OPENAI_API_KEY"<br><br>module OpenAI = struct<br>  let model = "gpt-4o"<br><br>  type json = Yojson.Safe.t<br>  let yojson_of_json x = x<br><br>  module Response = struct<br>    type response_message = { content : string option }<br>    [@@deriving of_yojson] [@@yojson.allow_extra_fields]<br><br>    type choice = { message : response_message }<br>    [@@deriving of_yojson] [@@yojson.allow_extra_fields]<br><br>    type response = { choices : choice list }<br>    [@@deriving of_yojson] [@@yojson.allow_extra_fields]<br>  end<br><br>  module Request = struct<br>    type message = {<br>      role : string;<br>      content : string;<br>    }<br>    [@@deriving yojson_of]<br><br>    type json_schema = {<br>      name : string;<br>      schema : json;<br>    }<br>    [@@deriving yojson_of]<br><br>    type response_format = {<br>      typ : string; [@key "type"]<br>      json_schema : json_schema;<br>    }<br>    [@@deriving yojson_of]<br><br>    type request = {<br>      model : string;<br>      messages : message list;<br>      response_format : response_format;<br>    }<br>    [@@deriving yojson_of]<br>  end<br><br>  let send ?(debug = false) request =<br>    let body = `Raw ("application/json", request |&gt; Request.yojson_of_request |&gt; Yojson.Safe.to_string) in<br>    let () =<br>      if debug then (<br>        let (`Raw (_, body)) = body in<br>        Printf.eprintf "Body: %s\n" body)<br>    in<br>    let headers = [ "Authorization: Bearer " ^ api_key ] in<br>    match Devkit.Web.http_request ~headers ~body `POST "https://api.openai.com/v1/chat/completions" with<br>    | `Error e -&gt; Error e<br>    | `Ok response -&gt;<br>    try Ok (response |&gt; Yojson.Safe.from_string |&gt; Response.response_of_yojson)<br>    with exn -&gt; Error (Printf.sprintf "error while parsing the response %s: %S" (Printexc.to_string exn) response)<br>end</pre><p>The types defined in the Request and Response modules are straight translation of the <a href="https://platform.openai.com/docs/api-reference/chat/create">OpenAI API reference</a>. The [@@deriving of_yojson] annotation generates functions to convert JSON from/into these types. The [@@yojson.allow_extra_fields] attribute ensures our code won't break if OpenAI adds new fields to their API responses.</p><p>The send function is a thin wrapper around the HTTP request to OpenAI's API, serializing our request to JSON, sending it, and then parsing the response back into our OCaml&nbsp;types.</p><p>Notice how we’re using PPX extensions throughout this code to minimize boilerplate. Without these extensions, we would already need to write a lot of manual serialization and deserialization code.</p><h3>Creating a structured schema for math problem&nbsp;solving</h3><p>In this example, I will demonstrate how to use OpenAI as a math tutor to solve problems with step-by-step details. Instead of receiving a single block of text that would require parsing to extract individual steps, I’ll define a structured JSON schema. The schema requires each step to include both an explanation and an intermediate output, along with a final&nbsp;answer.</p><p>Here’s where the magic of ppx_deriving_jsonschema comes&nbsp;in:</p><pre>module Math_reasoning = struct<br>  type step = {<br>    explanation : string;<br>    output : int;<br>  }<br>  [@@deriving jsonschema, yojson]<br><br>  type math_reasoning = {<br>    steps : step list;<br>    final_answer : int;<br>  }<br>  [@@deriving jsonschema, yojson] [@@yojson.allow_extra_fields]<br>end</pre><p>Let’s break down what’s happening here:</p><ol><li>We define OCaml types that model our desired response structure</li><li>The [@@deriving jsonschema] annotation automatically generates a JSON schema value called TYPENAME_jsonschema for each&nbsp;type</li><li>The [@@deriving yojson] annotation generates functions to convert between our OCaml types and&nbsp;JSON</li><li>These PPX extensions work together seamlessly — the schema generated by jsonschema is compatible with the JSON handling from&nbsp;yojson</li></ol><p>Without these PPX extensions, we would need&nbsp;to:</p><ul><li>Manually write a JSON schema as a string or build it with&nbsp;yojson</li><li>Write custom code to parse the API responses into our OCaml&nbsp;types</li><li>Ensure the schema and parsing logic stay in sync when our types&nbsp;change</li></ul><p>Instead, we get all of this automatically from a single type definition!</p><h3>Using the schema in our OpenAI&nbsp;request</h3><p>Once our schema is ready, it is easy to insert it in the request, alongside with the&nbsp;prompt.</p><pre>let math_tutor_request user_prompt =<br>  {<br>    OpenAI.Request.model = OpenAI.model;<br>    messages =<br>      [<br>        {<br>          role = "system";<br>          content =<br>            "You are a helpful math tutor. You will be provided with a math \<br>             problem, and your goal will be to output a step by step solution, \<br>             along with a final answer. For each step, just provide the output \<br>             as an equation and use the explanation field to detail the \<br>             reasoning.";<br>        };<br>        { role = "user"; content = user_prompt };<br>      ];<br>    response_format =<br>      {<br>        typ = "json_schema";<br>        json_schema =<br>          {<br>            name = "math_reasoning";<br>            schema = Math_reasoning.math_reasoning_jsonschema;<br>          };<br>      };<br>  }</pre><h3>Processing the structured response</h3><p>The remaining task is to retrieve the steps and display them. OpenAI has the ability to return multiple versions of its answer, calling it choices. Here we will only process one choice for simplicity.</p><pre>let extract_steps { OpenAI.Response.message = { content }; _ } =<br>  match content with<br>  | None -&gt; ()<br>  | Some content -&gt;<br>  match content |&gt; Yojson.Safe.from_string |&gt; Math_reasoning.math_reasoning_of_yojson with<br>  | exception Ppx_yojson_conv_lib.Yojson_conv.Of_yojson_error (exn, json) -&gt;<br>    Printf.eprintf "unable to parse response, error %s: %s\n" (Printexc.to_string exn) (Yojson.Safe.to_string json)<br>  | { Math_reasoning.steps; final_answer } -&gt;<br>    List.iteri<br>      (fun i { Math_reasoning.explanation; output } -&gt;<br>        Printf.printf "Step %d: %s\n" i explanation;<br>        Printf.printf "Output: %f\n" output)<br>      steps;<br>    Printf.printf "Final answer: %f\n" final_answer</pre><p>Notice how we’re using the math_reasoning_of_yojson function that was automatically generated by the [@@deriving yojson] annotation. Once we have the properly typed OCaml value, we can safely access its fields and process the steps in a type-safe manner. This is much more robust than manually parsing the JSON or using string manipulation to extract the information.</p><h3>Putting it all&nbsp;together</h3><p>Finally we only have to do a little bit of plumbing to make the program work. We get the question of the user from the command line, query the OpenAI API, and display the response.</p><pre>let run user_prompt =<br>  let request = math_tutor_request user_prompt in<br>  match OpenAI.send request with<br>  | Error e -&gt; Printf.eprintf "error: %s\n" e<br>  | Ok { OpenAI.Response.choices = []; _ } -&gt; Printf.eprintf "no choices returned by OpenAI\n"<br>  | Ok { OpenAI.Response.choices; _ } -&gt; List.iter extract_steps choices<br><br>let () =<br>  let user_prompt = Sys.argv.(1) in<br>  run user_prompt</pre><p>The output should look like&nbsp;this:</p><pre>$ dune exec ./openai_demo.exe "compute 3+4*17-4/5"<br>Step 0: First, follow the order of operations, known as PEMDAS (Parentheses, Exponents, Multiplication and Division (from left to right), Addition and Subtraction (from left to right)). Start by handling the multiplication: Calculate 4 * 17 = 68.<br>Output: 68.000000<br>Step 1: Next, handle the division: Calculate 4 / 5 = 0.8.<br>Output: 0.800000<br>Step 2: Now, handle the addition to and subtraction from the result of the multiplication: Calculate 3 + 68 = 71.<br>Output: 70.200000<br>Step 3: Lastly, subtract the result of the division from the addition result: Calculate 71 - 0.8 = 70.2.<br>Output: 70.200000<br>Final answer: 70.200000</pre><p>As you can see, the output of some of the steps is not correct. This is expected when performing mathematical operations using an LLM. Please always review the output with&nbsp;care.</p><p>The whole project can be found at <a href="https://github.com/ahrefs/ocaml-openai-demo">https://github.com/ahrefs/ocaml-openai-demo</a>.</p><p>The dependencies of the project can be installed from&nbsp;opam:</p><pre>opam switch create . 5.3.0<br>opam install dune devkit ppx_yojson_conv ppx_yojson_conv_lib ppx_deriving_jsonschema</pre><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b198fcf701ca" width="1" height="1" alt=""><hr><p><a href="https://tech.ahrefs.com/openai-and-structured-outputs-from-ocaml-b198fcf701ca">OpenAI and structured outputs from OCaml</a> was originally published in <a href="https://tech.ahrefs.com">Ahrefs</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
