---
title: 'Beyond TypeScript: Differences Between Typed Languages'
description: "For the past six years, I have been working with OCaml, most of this
  time has been spent writing code at Ahrefs to process a lot of data\u2026"
url: https://tech.ahrefs.com/beyond-typescript-differences-between-typed-languages-f3e14253?source=rss----303662d88bae--ocaml
date: 2023-09-14T14:32:06-00:00
preview_image: https://miro.medium.com/v2/resize:fit:1200/0*-TBMmfXVVLs-Kmqj.jpg
featured:
authors:
- Ahrefs
source:
---
    
<p>For the past six years, I have been working with OCaml, most of this time has been spent writing code at <a href="https://ahrefs.com/">Ahrefs</a> to process <a href="https://ahrefs.com/big-data">a lot of data</a> and show it to users in a way that makes&nbsp;sense.</p><p>OCaml is a language designed with types in mind. It took me some time to learn the language, its syntax, and semantics, but once I did, I noticed a significant difference in the way I would write code and colaborate with&nbsp;others.</p><p>Maintaining codebases became much easier, regardless of their size. And day-to-day work felt more like having a super pro sidekick that helped me identify issues in the code as I refactored it. This was a very different feeling from what I had experienced with TypeScript and&nbsp;Flow.</p><p>Most of the differences, especially those related to the type system, are quite subtle. Therefore, it is not easy to explain them without experiencing them firsthand while working with a real-world codebase.</p><p>However, in this post, I will attempt to compare some of the things you can do in OCaml, and explain them from the perspective of a TypeScript developer.</p><p>Before every snippet of code, we will provide links like this: (<a href="https://melange.re/unstable/playground/?language=OCaml&amp;code=bGV0ICgpID0gcHJpbnRfZW5kbGluZSAiaGVsbG8gd29ybGQi&amp;live=off">try</a>). These links will go either to the <a href="https://www.typescriptlang.org/play">TypeScript playground</a> for TypeScript snippets, or to the <a href="https://melange.re/unstable/playground">Melange playground</a>, for OCaml snippets. <a href="https://melange.re/">Melange</a> is a backend for the OCaml compiler that emits JavaScript.</p><p>Without further ado, let&rsquo;s&nbsp;go!</p><figure><img src="https://cdn-images-1.medium.com/max/1024/0*-TBMmfXVVLs-Kmqj.jpg" alt=""/></figure><p><em>Photo by </em><a href="https://unsplash.com/@bernicehtong"><em>Bernice Tong</em></a><em> on&nbsp;</em><a href="https://unsplash.com/photos/VPTSmbGba7Q?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText"><em>Unsplash</em></a></p><h3>Syntax</h3><p>OCaml&rsquo;s syntax is very minimal (and, in my opinion, quite nice once you get used to it), but it is also quite different from the syntax in mainstream languages like JavaScript, C, or&nbsp;Java.</p><p>Here is a simple snippet of code in OCaml syntax&nbsp;(<a href="https://melange.re/unstable/playground/?language=OCaml&amp;code=bGV0IHJlYyByYW5nZSBhIGIgPQogIGlmIGEgPiBiIHRoZW4gW10KICBlbHNlIGEgOjogcmFuZ2UgKGEgKyAxKSBiCgpsZXQgbXlfcmFuZ2UgPSByYW5nZSAwIDEw&amp;live=off">try</a>):</p><pre>let rec range a b =<br/>  if a &gt; b then []<br/>  else a :: range (a + 1) b<br/><br/>let my_range = range 0 10</pre><p>OCaml is built on a mathematical foundation called <a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">lambda calculus</a>. In lambda calculus, function definitions and applications don&rsquo;t use parentheses. So it was natural to design OCaml with similar syntax to that of lambda calculus.</p><p>However, the syntax might be too foreign for someone used to JavaScript. Luckily, there is a way to write OCaml programs using a different syntax which is much closer to the JavaScript one. This syntax is called <a href="https://reasonml.github.io/">Reason</a> syntax, and it will make it much easier to get started with OCaml if you are familiar with JavaScript.</p><p>Let&rsquo;s translate the example above into Reason syntax (you can translate any OCaml program to Reason syntax from <a href="https://melange.re/unstable/playground/?language=Reason&amp;code=bGV0IHJlYyByYW5nZSA9IChhLCBiKSA9PgogIGlmIChhID4gYikgewogICAgW107CiAgfSBlbHNlIHsKICAgIFthLCAuLi5yYW5nZShhICsgMSwgYildOwogIH07CgpsZXQgbXlSYW5nZSA9IHJhbmdlKDAsIDEwKTs=&amp;live=off">the playground</a>!):</p><pre>let rec range = (a, b) =&gt;<br/>  if (a &gt; b) {<br/>    [];<br/>  } else {<br/>    [a, ...range(a + 1, b)];<br/>  };<br/><br/>let myRange = range(0, 10);</pre><p>This syntax is fully supported throughout the entire OCaml ecosystem, and you can use it to&nbsp;build:</p><ul><li>native applications if you need fast startups or high speed of execution</li><li>or compile to JavaScript if you need to run your application in the&nbsp;browser.</li></ul><p>To use Reason syntax, you just need to name your source file with the&nbsp;.re extension instead of.ml, and you're good to&nbsp;go.</p><p>Since Reason syntax is widely supported and is closer to TypeScript than OCaml syntax, we will use Reason syntax for all code snippets throughout the rest of the article. Although understanding OCaml syntax has some advantages, such as allowing us to understand a larger body of source code, blog posts, and tutorials, there is absolutely no rush to do so, and you can always learn it at any time in the future. If you&rsquo;re curious, we&rsquo;ll provide links to the Melange playground for every snippet, so you can switch syntaxes to see how a Reason program looks in OCaml syntax, or vice&nbsp;versa.</p><h3>Data types</h3><p>OCaml has great support for data types, which are types that allow values to be contained within them. They are sometimes called <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>&nbsp;(ADTs).</p><p>One example is tuples, which can be used to represent a point in a 2-dimensional space&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=dHlwZSBwb2ludCA9IChmbG9hdCwgZmxvYXQpOwoKbGV0IHAxOiBwb2ludCA9ICgxLjIsIDQuMyk7&amp;live=off">try</a>):</p><pre>type point = (float, float);<br/><br/>let p1: point = (1.2, 4.3);</pre><p>One difference with TypeScript is that OCaml tuples are their own type, different from lists or arrays, whereas in TypeScript, tuples are a subtype of&nbsp;arrays.</p><p>Let&rsquo;s see this in practice. This is a valid TypeScript program&nbsp;(<a href="https://www.typescriptlang.org/play#code/DYUwLgBGCuAOoC4IG0DOYBOBLAdgcwBoJ1t8BdCAXhQCIAzAewZqJoCMBDDGsgbgCh%2BoSKBxUIACg5ISuPMjIBKKgD4IHAHSi8YABYCh4CNHGiJMeCEVA">try</a>):</p><pre>let tuple: [string, string] = [&quot;foo&quot;, &quot;bar&quot;];<br/><br/>let len = (a: string[]) =&gt; a.length;<br/><br/>let u = len(tuple)</pre><p>Note how the len function is annotated to take an array of strings as input, but then we apply it and pass tuple, which has a type [string,&nbsp;string].</p><p>In OCaml, this will fail to compile&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=bGV0IHR1cGxlOiAoc3RyaW5nLCBzdHJpbmcpID0gKCJmb28iLCAiYmFyIik7CgpsZXQgbGVuID0gKGE6IGFycmF5KHN0cmluZykpID0%2BIEFycmF5Lmxlbmd0aChhKTsKCmxldCB1ID0gbGVuKHR1cGxlKTsK&amp;live=off">try</a>):</p><pre>let tuple: (string, string) = (&quot;foo&quot;, &quot;bar&quot;);<br/><br/>let len = (a: array(string)) =&gt; Array.length(a);<br/><br/>let u = len(tuple)<br/>//          ^^^^^<br/>// Error This expression has type (string, string)<br/>// but an expression was expected of type array(string)</pre><p>Another data type is records. Records are similar to tuples, but each &ldquo;container&rdquo; in the type is labeled.&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=dHlwZSBwb2ludCA9IHsKICB4OiBmbG9hdCwKICB5OiBmbG9hdCwKfTsKCmxldCBwMTogcG9pbnQgPSB7eDogMS4yLCB5OiA0LjN9Ow==&amp;live=off">try</a>):</p><pre>type point = {<br/>  x: float,<br/>  y: float,<br/>};<br/><br/>let p1: point = {x: 1.2, y: 4.3};</pre><p>Records are similar to object types in TypeScript, but there are subtle differences in how the type system works with these types. In TypeScript, object types are structural, which means a function that works over an object type can be applied to another object type as long as they share some properties. Here&rsquo;s an example (&nbsp;<a href="https://www.typescriptlang.org/play#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbAJ4Q4UaiACuAWwBG0VgF98%2BUJFiIUAZQAW6KDozY8bEuSq16TVkQ5de-QXZFiN%2BBALrFSCmQAXmQACjAsdGojEzMogEoQgD5kXxAadAoAOjJ0Rgio7OsKBNYfPzBiKOpzHFDcAJtqACIYdHQWgBp2Tm5gPmABVqVpbuRJaWoAJgAGaYBGZG8SiELsBKA">try</a>):</p><pre>interface Todo {<br/>  title: string;<br/>  description: string;<br/>  year: number;<br/>}<br/><br/>interface ShorterTodo {<br/>  title: string;<br/>  description: string;<br/>}<br/><br/>const title = (todo: ShorterTodo) =&gt; console.log(todo.title);<br/><br/>const todo: Todo = { title: &quot;foo&quot;, description: &quot;bar&quot;, year: 2021 }<br/><br/>title(todo)</pre><p>In OCaml, you have a choice. Record types are nominal, so a function that takes a record type can only take values of that type. Let&rsquo;s look at the same example&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=dHlwZSB0b2RvID0gewogIHRpdGxlOiBzdHJpbmcsCiAgZGVzY3JpcHRpb246IHN0cmluZywKICB5ZWFyOiBpbnQsCn07Cgp0eXBlIHNob3J0ZXJUb2RvID0gewogIHRpdGxlOiBzdHJpbmcsCiAgZGVzY3JpcHRpb246IHN0cmluZywKfTsKCmxldCB0aXRsZSA9ICh0b2RvOiBzaG9ydGVyVG9kbykgPT4gSnMubG9nKHRvZG8udGl0bGUpOwoKbGV0IHRvZG86IHRvZG8gPSB7dGl0bGU6ICJmb28iLCBkZXNjcmlwdGlvbjogImJhciIsIHllYXI6IDIwMjF9OwoKdGl0bGUodG9kbyk7&amp;live=off">try</a>):</p><pre>type todo = {<br/>  title: string,<br/>  description: string,<br/>  year: int,<br/>};<br/><br/>type shorterTodo = {<br/>  title: string,<br/>  description: string,<br/>};<br/><br/>let title = (todo: shorterTodo) =&gt; Js.log(todo.title);<br/><br/>let todo: todo = {title: &quot;foo&quot;, description: &quot;bar&quot;, year: 2021};<br/><br/>title(todo);<br/>//    ^^^^<br/>// Error This expression has type todo but an expression was expected of<br/>// type shorterTodo</pre><p>But if we want to use structural types, OCaml objects also offer that option. Here is an example using Js.t object types in Melange&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=bGV0IHByaW50VGl0bGUgPSB0b2RvID0%2BIHsKICBKcy5sb2codG9kbyMjdGl0bGUpOwp9OwoKbGV0IHRvZG8gPSB7InRpdGxlIjogImZvbyIsICJkZXNjcmlwdGlvbiI6ICJiYXIiLCAieWVhciI6IDIwMjF9OwpwcmludFRpdGxlKHRvZG8pOwpsZXQgc2hvcnRlclRvZG8gPSB7InRpdGxlIjogImZvbyIsICJkZXNjcmlwdGlvbiI6ICJiYXIifTsKcHJpbnRUaXRsZShzaG9ydGVyVG9kbyk7&amp;live=off">try</a>):</p><pre>let printTitle = todo =&gt; {<br/>  Js.log(todo##title);<br/>};<br/><br/>let todo = {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;, &quot;year&quot;: 2021};<br/>printTitle(todo);<br/>let shorterTodo = {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;};<br/>printTitle(shorterTodo);</pre><p>To conclude the topic of ADTs, one of the most useful tools in the OCaml toolbox are variants, also known as sum types or <a href="https://en.wikipedia.org/wiki/Tagged_union">tagged&nbsp;unions</a>.</p><p>The simplest variants are similar to TypeScript <a href="https://www.typescriptlang.org/docs/handbook/enums.html">enums</a>&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=dHlwZSBzaGFwZSA9CiAgfCBQb2ludAogIHwgQ2lyY2xlCiAgfCBSZWN0YW5nbGU7&amp;live=off">try</a>):</p><pre>type shape =<br/>  | Point<br/>  | Circle<br/>  | Rectangle;</pre><p>The individual names of the values of a variant are called <em>constructors</em> in OCaml. In the example above, the constructors are Point, Circle, and Rectangle. Constructors in OCaml have a different meaning than the reserved word<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor">constructor</a> in JavaScript.</p><p>Unlike TypeScript enums, OCaml does not require prefixing variant values with the type name. The type inference system will automatically infer them as long as the type is in&nbsp;scope.</p><p>This TypeScript code&nbsp;(<a href="https://www.typescriptlang.org/play#code/KYOwrgtgBAygFgQwA7CgbwFBSgBQPYCWIALgDRZQDCBATgMYA2w52ASsHcQiAOZMYBfDBibEoAZ0QpxUALxQA2hXjJgAOnxEyyqeur0mLWLrXtO3PswwBdANxA">try</a>):</p><pre>enum Shape {<br/>  Point,<br/>  Circle,<br/>  Rectangle<br/>}<br/><br/>let shapes = [<br/>  Shape.Point,<br/>  Shape.Circle,<br/>  Shape.Rectangle,<br/>];</pre><p>Can be written like&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=dHlwZSBzaGFwZSA9CiAgfCBQb2ludAogIHwgQ2lyY2xlCiAgfCBSZWN0YW5nbGU7CgpsZXQgc2hhcGVzID0gW1BvaW50LCBDaXJjbGUsIFJlY3RhbmdsZV07&amp;live=off">try</a>):</p><pre>type shape =<br/>  | Point<br/>  | Circle<br/>  | Rectangle;<br/><br/>let shapes = [Point, Circle, Rectangle];</pre><p>Another difference is that, unlike TypeScript enums, OCaml variants can hold data for each constructor. Let&rsquo;s improve the shape type to include more information about each constructor (<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=dHlwZSBwb2ludCA9IChmbG9hdCwgZmxvYXQpOwp0eXBlIHNoYXBlID0KICB8IFBvaW50KHBvaW50KQogIHwgQ2lyY2xlKHBvaW50LCBmbG9hdCkgLyogY2VudGVyIGFuZCByYWRpdXMgKi8KICB8IFJlY3QocG9pbnQsIHBvaW50KTsgLyogbG93ZXItbGVmdCBhbmQgdXBwZXItcmlnaHQgY29ybmVycyAqLwo=&amp;live=off">try</a>):</p><pre>type point = (float, float);<br/>type shape =<br/>  | Point(point)<br/>  | Circle(point, float) /* center and radius */<br/>  | Rect(point, point); /* lower-left and upper-right corners */</pre><p>Something like this is possible in TypeScript using <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions">discriminated unions</a> (&nbsp;<a href="https://www.typescriptlang.org/play#code/C4TwDgpgBACg9gSwHbCgXigbysAhgcwC4oByeZYEgbigGM44AnAEwGdiBtJAVwFsAjCIwA0UHgKEBdKAF8qAKFCQoAYQSNaAG2gZseIqTUbt1OhBRDO4wSLF8bkmo1zME3dnYmNZCpdABKELSoujgExCSBwaaacADuQgAyEABmwFb2QqLWUjTcYJCM-gj4ABbpUFyZtjmM0nKK4NAAyqW4yhjkKFAAPqrqWtB9UcBUQA">try</a>):</p><pre>type Point = { tag: 'Point'; coords: [number, number] };<br/>type Circle = { tag: 'Circle'; center: [number, number]; radius: number };<br/>type Rect = { tag: 'Rect'; lowerLeft: [number, number]; upperRight: [number, number] };<br/>type Shape = Point | Circle | Rect;</pre><p>The TypeScript representation is slightly more verbose than the OCaml one, as we need to use object literals with a tag property to achieve the same effect. On top of that, there are greater advantages of variants that we will see just right&nbsp;next.</p><h3>Pattern matching</h3><p>Pattern matching is one of the killer features of OCaml, along with the inference engine (which we will discuss in the next section).</p><p>Let&rsquo;s take the shape type we defined in the previous example. Pattern matching allows us to conditionally act on values of any type in a concise way. For example&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=dHlwZSBwb2ludCA9IChmbG9hdCwgZmxvYXQpOwp0eXBlIHNoYXBlID0KICB8IFBvaW50KHBvaW50KQogIHwgQ2lyY2xlKHBvaW50LCBmbG9hdCkgLyogY2VudGVyIGFuZCByYWRpdXMgKi8KICB8IFJlY3QocG9pbnQsIHBvaW50KTsgLyogbG93ZXItbGVmdCBhbmQgdXBwZXItcmlnaHQgY29ybmVycyAqLwoKbGV0IGFyZWEgPSBzaGFwZSA9PgogIHN3aXRjaCAoc2hhcGUpIHsKICB8IFBvaW50KF8pID0%2BIDAuMAogIHwgQ2lyY2xlKF8sIHIpID0%2BIEZsb2F0LnBpICouIHIgKiogMi4wCiAgfCBSZWN0KCh4MSwgeTEpLCAoeDIsIHkyKSkgPT4KICAgIGxldCB3ID0geDIgLS4geDE7CiAgICBsZXQgaCA9IHkyIC0uIHkxOwogICAgdyAqLiBoOwogIH07&amp;live=off">try</a>):</p><pre>type point = (float, float);<br/>type shape =<br/>  | Point(point)<br/>  | Circle(point, float) /* center and radius */<br/>  | Rect(point, point); /* lower-left and upper-right corners */<br/><br/>let area = shape =&gt;<br/>  switch (shape) {<br/>  | Point(_) =&gt; 0.0<br/>  | Circle(_, r) =&gt; Float.pi *. r ** 2.0<br/>  | Rect((x1, y1), (x2, y2)) =&gt;<br/>    let w = x2 -. x1;<br/>    let h = y2 -. y1;<br/>    w *. h;<br/>  };</pre><p>Here is the equivalent code in TypeScript (<a href="https://www.typescriptlang.org/play#code/C4TwDgpgBACg9gSwHbCgXigbysAhgcwC4oByeZYEgbigGM44AnAEwGdiBtJAVwFsAjCIwA0UHgKEBdKAF8qAKFCQoAYQSNaAG2gZseIqTUbt1OhBRDO4wSLF8bkmo1zME3dnYmNZCpdABKELSoujgExCSBwaaacADuQgAyEABmwFb2QqLWUjTcYJCM-gj4ABbpUFyZtjmM0nKK4NAAyqW4yhjkKFAAPqrqWtB9UcAK8vRIrKi4jBC46FAAFKxtkMSt7RAAlMS16AB8WPJQUKxxCMC0pUsrmwB0%2BltHJye0uKzQZIgoJITHLydZsBuIwkFAAAx3cEKAFvD6GAYmP4AwEQYGgqAAWVwwFKdxgAEkoAAqLE4vFgeLLVYQO7OVzuUQAJi2MJecM%2BI1%2B-1hcEmqDiC1ukDu%2BUKxTKwA44OkAFpTjS7rEEoxkmlpY4eey%2BVMoNcMMLaWKhBLyhwAIxyhX3ZVJVJSy1sgFAkFgwWk0pOqDMVK4biadJak4AemDUAAopMQdAIAAPNruYAIABu0CuQQA1sh8KIIKmwbi4NwyjhSghWHR3tAVkXNMwxHmhFBBFBZrh08wg3Qdag4wmpimICpSpndo3vAaaV7UeiwX2-QPU8PM2yZPI5EA">try</a>):</p><pre>type Point = { tag: 'Point'; coords: [number, number] };<br/>type Circle = { tag: 'Circle'; center: [number, number]; radius: number };<br/>type Rect = { tag: 'Rect'; lowerLeft: [number, number]; upperRight: [number, number] };<br/>type Shape = Point | Circle | Rect;<br/><br/>const area = (shape: Shape): number =&gt; {<br/>  switch (shape.tag) {<br/>    case 'Point':<br/>      return 0.0;<br/>    case 'Circle':<br/>      return Math.PI * Math.pow(shape.radius, 2);<br/>    case 'Rect':<br/>      const w = shape.upperRight[0] - shape.lowerLeft[0];<br/>      const h = shape.upperRight[1] - shape.lowerLeft[1];<br/>      return w * h;<br/>    default:<br/>      // Ensure exhaustive checking, even though this case should never be reached<br/>      const exhaustiveCheck: never = shape;<br/>      return exhaustiveCheck;<br/>  }<br/>};</pre><p>We can observe how in OCaml, the values inside each constructor can be extracted directly from each branch of the switch statement. On the other hand, in TypeScript, we need to first check the tag, and then access the other properties of the object. Additionally, ensuring coverage of all cases in TypeScript using the never type can be more verbose, and functions may be more error-prone if we forget to handle it. In OCaml, exhaustiveness is ensured when using variants, and covering all cases requires no extra&nbsp;effort.</p><p>The best thing about pattern matching is that it can be used for anything: basic types like string or int, records, lists,&nbsp;etc.</p><p>Here is another example using pattern matching with lists&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=bGV0IHJlYyBzdW1MaXN0ID0gbHN0ID0%2BCiAgc3dpdGNoIChsc3QpIHsKICAvKiBCYXNlIGNhc2U6IGFuIGVtcHR5IGxpc3QgaGFzIGEgc3VtIG9mIDAuICovCiAgfCBbXSA9PiAwCiAgLyogU3BsaXQgdGhlIGxpc3QgaW50byBoZWFkIGFuZCB0YWlsLiAqLwogIHwgW2hlYWQsIC4uLnRhaWxdID0%2BCiAgICAvKiBSZWN1cnNpdmVseSBzdW0gdGhlIHRhaWwgb2YgdGhlIGxpc3QuICovCiAgICBoZWFkICsgc3VtTGlzdCh0YWlsKQogIH07CgpsZXQgbnVtYmVycyA9IFsxLCAyLCAzLCA0LCA1XTsKbGV0IHJlc3VsdCA9IHN1bUxpc3QobnVtYmVycyk7CmxldCAoKSA9IEpzLmxvZyhyZXN1bHQpOwo=&amp;live=off">try</a>):</p><pre>let rec sumList = lst =&gt;<br/>  switch (lst) {<br/>  /* Base case: an empty list has a sum of 0. */<br/>  | [] =&gt; 0<br/>  /* Split the list into head and tail. */<br/>  | [head, ...tail] =&gt;<br/>    /* Recursively sum the tail of the list. */<br/>    head + sumList(tail)<br/>  };<br/><br/>let numbers = [1, 2, 3, 4, 5];<br/>let result = sumList(numbers);<br/>let () = Js.log(result);</pre><h3>Type annotations are&nbsp;optional</h3><p>If we wanted to write some identity function in TypeScript, we would do something like&nbsp;(<a href="https://www.typescriptlang.org/play#code/MYewdgzgLgBAlgEwFwwDwBUB8AKAbgQwBsV0BKGAXkxnUpgMMuoYCgWAzAVzGCjnBicIAUwCSCbIhQYcDEuSo1yAbxYx1MAE7ConTWBgBtRNgCMABlIBdFgF8gA">try</a>):</p><pre>const id: &lt;T&gt;(val: T) =&gt; T = val =&gt; val<br/><br/>function useId(id: &lt;T&gt;(val: T) =&gt; T) {<br/>    return [id(10)]<br/>}</pre><p>While TypeScript <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">generics</a> are very powerful, they lead to really verbose type annotations. As soon as our functions start taking more parameters, or increasing in complexity, the type signatures length increases accordingly.</p><p>Plus, the generic annotations have to be carried over to any other functions that compose with the original ones, making maintenance quite cumbersome in some&nbsp;cases.</p><p>In OCaml, the type system is based on <a href="https://www.cs.cornell.edu/courses/cs3110/2011sp/Lectures/lec26-type-inference/type-inference.htm">unification of types</a>. This differs from TypeScript, and allow to infer types for functions (even with generics) without the need of type annotations.</p><p>For example, here is how we would write the above snippet in OCaml&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=bGV0IGlkID0gdmFsdWUgPT4gdmFsdWU7CgpsZXQgdXNlSWQgPSBpZCA9PiBbaWQoMTApXTs=&amp;live=off">try</a>):</p><pre>let id = value =&gt; value;<br/><br/>let useId = id =&gt; [id(10)];</pre><p>The compiler can infer correctly the type of useId is (int =&gt; 'a) =&gt; list('a).</p><p>With OCaml, type annotations are optional. But we can still add type annotations anywhere optionally, if we think it will be useful for documentation purposes&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=bGV0IGlkOiAnYSA9PiAnYSA9IHZhbHVlID0%2BIHZhbHVlOwoKbGV0IHVzZUlkOiAoaW50ID0%2BICdhKSA9PiBsaXN0KCdhKSA9IGlkID0%2BIFtpZCgxMCldOw==&amp;live=off">try</a>):</p><pre>let id: 'a =&gt; 'a = value =&gt; value;<br/><br/>let useId: (int =&gt; 'a) =&gt; list('a) = id =&gt; [id(10)];</pre><p>I can not emphasize enough how the simplification seen above, which only involves a single function, can affect a codebase with hundreds, or thousands of more complex functions in&nbsp;it.</p><h3>Immutability</h3><p>JavaScript is a language where mutability is pervasive, and working with immutable data structures often require using third party libraries or other complex solutions.</p><p>Trying to obtain real immutable values in TypeScript is quite challenging. Historically, it has been hard to prevent mutation of properties inside objects, which was mitigated with as&nbsp;const.</p><p>But still, the way the type system has to be flexible to adapt for the dynamism of JavaScript can lead to &ldquo;leaks&rdquo; in immutable values.</p><p>Let&rsquo;s see an example&nbsp;(<a href="https://www.typescriptlang.org/play#code/JYOwLgpgTgZghgYwgAgLIFcxwEYBsIBqcu6EAPACoB8yA3gFDJPIBuxpAXMhQNz0C%2B9eqEixEKAJIBbKZhz4iJctTqNmUCHAAmAexC4Anq3YQuvAUIR6AzmGTAu02VjyETZW1FABzGgF46YyUuACIAC2AQ5H4%2BeisQW2QpLgwXBXdPH397PikAOjYlZADwuDCQniA">try</a>):</p><pre>interface MutableValue&lt;T&gt; {<br/>    value: T;<br/>}<br/><br/>interface ImmutableValue&lt;T&gt; {<br/>    readonly value: T;<br/>}<br/><br/>const i: ImmutableValue&lt;string&gt; = { value: &quot;hi&quot; };<br/><br/>const m: MutableValue&lt;string&gt; = i;<br/>m.value = &quot;hah&quot;;</pre><p>As you can see, even when being strict about defining the immutable nature of the value i using TypeScript expressiveness, it is fairly easy to mutate values of that type if they happen to be passed to a function that expects a type similar in shape, but without the readonly&nbsp;flag.</p><p>In OCaml, immutability is the default, and it&rsquo;s guaranteed. Records are immutable (like tuples, lists, and most basic types), but even if we can define mutable fields in them, something like the previous TypeScript leak is not possible&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=dHlwZSBpbW11dGFibGVWYWx1ZSgnYSkgPSB7dmFsdWU6ICdhfQp0eXBlIG11dGFibGVWYWx1ZSgnYSkgPSB7bXV0YWJsZSB2YWx1ZSA6ICdhfQoKbGV0IGk6IGltbXV0YWJsZVZhbHVlKHN0cmluZykgPSB7IHZhbHVlOiAiaGkiIH07CgpsZXQgbTogbXV0YWJsZVZhbHVlKHN0cmluZykgPSBpOwptLnZhbHVlID0gImhhaCI7&amp;live=off">try</a>):</p><pre>type immutableValue('a) = {value: 'a}<br/>type mutableValue('a) = {mutable value : 'a}<br/><br/>let i: immutableValue(string) = { value: &quot;hi&quot; };<br/><br/>let m: mutableValue(string) = i;<br/>m.value = &quot;hah&quot;;</pre><p>When trying to assign i to m we get an error: This expression has type immutableValue(string) but an expression was expected of type mutableValue(string).</p><h3>No imports</h3><p>This might not be as impactful of a feature as the ones we just went through, but it is really nice that in OCaml there is no need to manually import values from other&nbsp;modules.</p><p>In TypeScript, to use some function bar defined in a module located in../../foo.ts, we have to&nbsp;write:</p><pre>import {bar} from &quot;../../foo.ts&quot;;<br/>let t = bar();</pre><p>In OCaml, libraries and modules in your project are all available for your program to use, so we would just&nbsp;write:</p><pre>let t = Foo.bar()</pre><p>The compiler will figure out how to find the paths to the&nbsp;module.</p><h3>Currying</h3><p><a href="https://en.wikipedia.org/wiki/Currying">Currying</a> is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument. It is a feature that might be more desirable for those looking into learning more about functional programming techniques.</p><p>While it is possible to use currying in TypeScript, but it becomes quite verbose&nbsp;(<a href="https://www.typescriptlang.org/play#code/MYewdgzgLgBAtgSwB4wLwwBQEMBcNoBOCYA5gJRoB8mARnoceVTDTANQwBEX7MWA3AChQkWDQCm4gGZp4yDJwggsAa3EATGMRgAhHQEV8WAK7BxnMgonSLQkdBjAsBAiFjopxsMCgJwmCgBvQRhQx3AHGXREJAV1BAAHLTAYAAtjODhjCFsQsIJxKGMCFKkFJxc3XIBfDDJ%2BIA">try</a>):</p><pre>const mix = (a: string) =&gt; (b: string) =&gt; b + &quot; &quot; + a;<br/>const beef = mix(&quot;soaked in BBQ sauce&quot;)(&quot;beef&quot;);<br/>const carrot = function () {<br/>    const f = mix(&quot;dip in hummus&quot;);<br/>    return f(&quot;carrot&quot;);<br/>}();</pre><p>In OCaml, all functions are curried by default. This is how a similar code would look like&nbsp;(<a href="https://melange.re/unstable/playground/?language=Reason&amp;code=bGV0IG1peCA9IChhLCBiKSA9PiBiICsrICIgIiArKyBhOwpsZXQgYmVlZiA9IG1peCgic29ha2VkIGluIEJCUSBzYXVjZSIsICJiZWVmIik7CmxldCBjYXJyb3QgPSB7CiAgbGV0IGYgPSBtaXgoImRpcCBpbiBodW1tdXMiKTsKICBmKCJjYXJyb3QiKTsKfTsK&amp;live=off">try</a>):</p><pre>let mix = (a, b) =&gt; b ++ &quot; &quot; ++ a;<br/>let beef = mix(&quot;soaked in BBQ sauce&quot;, &quot;beef&quot;);<br/>let carrot = {<br/>  let f = mix(&quot;dip in hummus&quot;);<br/>  f(&quot;carrot&quot;);<br/>};</pre><h3>Build native apps that run&nbsp;fast</h3><p>One of the best parts of OCaml is how flexible it is in the amount of places your code can run. Your applications written in OCaml can run natively on multiple devices, with very fast starts, as there is no need to start a virtual&nbsp;machine.</p><p>The nice thing is that OCaml does not compromise expressiveness or ergonomics to obtain really fast execution times. As this <a href="http://blog.gmarceau.qc.ca/2009/05/speed-size-and-dependability-of.html">study shows</a>, the language hits a great balance between verbosity (Y axis) and performance (X axis). It provides features like garbage collection or a powerful type system as we have seen, while producing small, fast binaries.</p><h3><strong>Write your client and server with the same&nbsp;language</strong></h3><p>This is not a particular feature of OCaml, as JavaScript has allowed to write applications that run in the server and the client for years. But I want to mention it because with OCaml one can obtain the upsides of sharing the same language across boundaries, together with a precise type system, a fast compiler, and an expressive and consistent functional language.</p><p>At Ahrefs, we work with the same language in frontend and backend, including tooling like build system and package manager (we wrote about it <a href="https://tech.ahrefs.com/ahrefs-is-now-built-with-melange-b14f5ec56df4">here</a>). Having the OCaml compiler know about all our code allows us to support several number of applications and systems with a reasonably sized team, working across different timezones.</p><p>I hope you enjoyed the article. If you want to learn more about OCaml as a TypeScript developer I can recommend the Melange documentation site, which has plenty of information about how to get started. This page in particular, <a href="https://melange.re/v1.0.0/melange-for-x-developers/">Melange for X developers</a>, summarizes some of the things we have discussed, and expanding on&nbsp;others.</p><p>If you want to share any feedback or comments, please comment <a href="https://twitter.com/javierwchavarri/">on Twitter</a>, or join the <a href="https://discord.gg/reasonml">Reason Discord</a> to ask questions or share your progress on any project or idea built with&nbsp;OCaml.</p><p><em>Originally published at </em><a href="https://www.javierchavarri.com/beyond-typescript/"><em>https://www.javierchavarri.com</em></a><em>.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f3e14253" width="1" height="1" alt=""/><hr/><p><a href="https://tech.ahrefs.com/beyond-typescript-differences-between-typed-languages-f3e14253">Beyond TypeScript: Differences Between Typed Languages</a> was originally published in <a href="https://tech.ahrefs.com">Ahrefs</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
