<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>http://gallium.inria.fr/blog/index.rss</id><title type="text">gallium</title><updated>2023-07-13T05:47:27-00:00</updated><entry><link href="http://cambium.inria.fr/blog/florian-compiler-weekly-2023-07-05" rel="alternate"/><contributor><uri>http://gallium.inria.fr/blog/index.rss</uri><name>gallium</name></contributor><content type="html">


&lt;p&gt;This series of blog posts aims to give a short weekly glimpse into my
(Florian Angeletti) daily work on the OCaml compiler. The subject this
week is a cartography of the source of opam packages breakage in OCaml
5.1.0 .&lt;/p&gt;


  

&lt;p&gt;With the recent release of the first beta for OCaml 5.1, I have spent
some time at the state of the opam ecosystem looking for package that
broke with OCaml 5.1 .&lt;/p&gt;
&lt;p&gt;Interestingly, for this beta there most of those incompatibility
stemmed from 7 changes in OCaml 5.1, which is a small enough number that
I can list all those potentially package-breaking changes in this blog
post.&lt;/p&gt;
&lt;h3&gt;Stdlib changes&lt;/h3&gt;
&lt;p&gt;Unsurprisingly, most of the package build failures finds their source
in small changes of the standard library. Those changes accounts for at
least 8 package build failures in the opam repository at the time of the
first beta release.&lt;/p&gt;
&lt;h4&gt;Updated module
types in the standard library&lt;/h4&gt;
&lt;p&gt;More precisely, one source of build failure is the changes in module
types defined in the standard library. Such module types are a known
source of backward compatibility difficulty. Depending on the uses of
those module types, any change in the module types can create a build
failure.&lt;/p&gt;
&lt;p&gt;And OCaml 5.1 updated three of such module types.&lt;/p&gt;
&lt;p&gt;First, the &lt;code&gt;hash&lt;/code&gt; function inside the
&lt;code&gt;Hashtbl.SeededHashedType&lt;/code&gt; module type has been renamed to
&lt;code&gt;seeded_hash&lt;/code&gt;. This changes make it possible for a module to
implement both &lt;code&gt;Hashtbl.SeededHashedType&lt;/code&gt; and
&lt;code&gt;Hashtbl.HashedType&lt;/code&gt; (&lt;a href=&quot;https://github.com/ocaml/ocaml/pull/11157&quot;&gt;#11157&lt;/a&gt;).
Unfortunately, this change breaks modules that were using
&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; with the previous signature for the
argument of the functor.&lt;/p&gt;
&lt;p&gt;When the change was proposed there were only 6 opam packages affected
by this change. Thus, the improved usability for the
&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; functor seemed worth the price. And at
the time of the first beta release, I have only seen two remaining
packages still affected by this change.&lt;/p&gt;
&lt;p&gt;Second, a more subtle problem occurred for libraries that were using
the &lt;code&gt;Map.S&lt;/code&gt; or &lt;code&gt;Set.S&lt;/code&gt; module types: the
signatures has been expanded with new functions (&lt;code&gt;to_list&lt;/code&gt;
for &lt;code&gt;Set.S&lt;/code&gt; and &lt;code&gt;to_list&lt;/code&gt; &lt;code&gt;of_list&lt;/code&gt;,
and &lt;code&gt;add_to_list&lt;/code&gt; for &lt;code&gt;Map.S&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Consequently, three libraries that were defining new &lt;code&gt;Map&lt;/code&gt;
or &lt;code&gt;Set&lt;/code&gt; functors using this signature as a constraint need
to add those missing functions to their &lt;code&gt;Map&lt;/code&gt; and
&lt;code&gt;Set&lt;/code&gt; implementations. Those failures are maybe less
surprising: if one library use a module type provided by the standard
library for one of its own implementation, it inevitably couple strongly
itself to the standard library specification.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/pull/11581&quot;&gt;New modules in the
standard library&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Another source of difficulty is that the standard library has been
added a new &lt;code&gt;Type&lt;/code&gt; module in OCaml 5.1. This new module
defines the well-know equality GADT (Generalized Abstract Data
Type):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;type (_, _) eq = Equal : ('a, 'a) eq
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;and type identity witnesses. In other words, this is mostly a module
for heavy users of GADTs.&lt;/p&gt;
&lt;p&gt;Normally, adding a new module to the standard library can be done
painlessly: Standard library modules have a lower priority compared to
local modules. Thus, if someone has a project which defines a
&lt;code&gt;Type&lt;/code&gt; module, the non-qualified name &lt;code&gt;Type&lt;/code&gt; will
refer to the local module, and the standard library module will be
accessible with &lt;code&gt;Stdlib.Type&lt;/code&gt;. However, this low priority
behaviour requires some special support in the compiler and alternative
standard library lacks this support. Consequently, libraries (at least
three) that are defining a local &lt;code&gt;Type&lt;/code&gt; module while using
alternative standard library (like &lt;code&gt;base&lt;/code&gt;) might be required
to find a non-conflicting short-name for their local &lt;code&gt;Type&lt;/code&gt;
module (which might be as simple as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ty&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;! &lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;)&lt;/p&gt;
&lt;h3&gt;Internal API changes&lt;/h3&gt;
&lt;p&gt;The second ex &amp;aelig;quo source of build failures in opam packages is the
changes in internal API, either in the OCaml runtime or in the compiler
library.&lt;/p&gt;
&lt;h4&gt;Changes in the runtime
internal API&lt;/h4&gt;
&lt;p&gt;The internal runtime function &lt;code&gt;caml_shared_try_alloc&lt;/code&gt; now
takes the number of reserved bits in the header as a supplementary
argument. This change affected at least one opam package.&lt;/p&gt;
&lt;h4&gt;Change in the compiler-libs
API&lt;/h4&gt;
&lt;p&gt;To improve the rendering of weakly polymorphic row variables, OCaml
5.1 has switched its high-level display representation of type aliases
to make it easier to display &amp;ldquo;weakly polymorphic aliases&amp;rdquo;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; [&amp;gt; `X of int]  as _weak1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;rather than&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;_[&amp;gt; `X of int]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This caused a build failure for at least one package that was relying
on the previous API.&lt;/p&gt;
&lt;h3&gt;Type system change&lt;/h3&gt;
&lt;p&gt;The third ex &amp;aelig;quo source of build failures is small changes in the
type system, where package that were at the frontier of the technically
correct and bugs ended up falling on the other side of the fence during
this release.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/pull/12211&quot;&gt;Inexact explicit type
annotation for anonymous row variable&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;For instance, due to a bug fix, OCaml 5.1 is stricter when mixing
explicitly polymorphic type annotations and anonymous row variables.
Even with all the precautions described in
http://gallium.inria.fr/blog/florian-compiler-weekly-2023-04-28, there
was at least one opam package that was affected. On the bright side,
this was probably a bug in the lone affected package.&lt;/p&gt;
&lt;h4&gt;Generative
functors must be used generatively&lt;/h4&gt;
&lt;p&gt;When a functor is defined as an applicative functor&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;App&lt;/span&gt;() = &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;t&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;OCaml 5.1 forbids now to apply as if it was a generative functor:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ok&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;App&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;end&lt;/span&gt;)
&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;New_error&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;App&lt;/span&gt;()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Previous version of OCaml did not make any difference between
&lt;code&gt;struct end&lt;/code&gt; or &lt;code&gt;()&lt;/code&gt; in functor applications and
thus allowed the form &lt;code&gt;App(struct end)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The reverse situation, where a generative functor is applied to
&lt;code&gt;struct end&lt;/code&gt; is allowed but emits a warning&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Gen&lt;/span&gt;() = &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;t&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;New_warning&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Gen&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;end&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Warning&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;73&lt;/span&gt; [&lt;span class=&quot;nv&quot;&gt;generative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;expects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;unit&lt;/span&gt;]: &lt;span class=&quot;nv&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;generative&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;functor&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;should&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;applied&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; using '(struct end)' is deprecated.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This restriction is there to make clearer the distinction between
applicative and generative application. But at least $one opam package
needed to be updated (at the time of the beta release).&lt;/p&gt;
&lt;h3&gt;Unique case&lt;/h3&gt;
&lt;p&gt;Sometimes, there are also backward compatible issue with packages
that were using the compiler in surprising ways. For instance, this
time, one package build failed because it was trying to link without
&lt;code&gt;-for-pack&lt;/code&gt; modules compiled with &lt;code&gt;-for-pack&lt;/code&gt;,
which happened to sometimes work in previous version of OCaml. OCaml 5.1
took the decision to stop relying on such happenstance, and mixing
different &lt;code&gt;-for-pack&lt;/code&gt; mode now always result in an error.&lt;/p&gt;

</content><id>http://cambium.inria.fr/blog/florian-compiler-weekly-2023-07-05</id><title type="text">Florian's OCaml compiler weekly, 5 July 2023</title><updated>2023-07-05T08:00:00-00:00</updated><author><email>Florian Angeletti</email><name>gallium</name></author></entry><entry><link href="http://cambium.inria.fr/blog/florian-compiler-weekly-2023-06-20" rel="alternate"/><contributor><uri>http://gallium.inria.fr/blog/index.rss</uri><name>gallium</name></contributor><content type="html">


&lt;p&gt;This series of blog posts aims to give a short weekly glimpse into my
(Florian Angeletti) daily work on the OCaml compiler. This quiet week
was focused on finishing ongoing tasks and discussing future
collaborations.&lt;/p&gt;


  

&lt;h3&gt;A few finished tasks&lt;/h3&gt;
&lt;p&gt;Last week was a quiet week, in term of new activities. However, I was
able to push few of my ongoing tasks over the finish line:&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/pull/12210&quot;&gt;Semantic tag for inline
code in the compiler&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;I have at last finalized this pull request that introduces an uniform
quoting style for inline code inside all the messages across the
compilers. With more than 300 hundred source files (fortunately mostly
tests) changed, this is the kind of Pull Request that one is glad to see
merged. At the very least, because this means no more lengthy
rebasing.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/pull/12031&quot;&gt;A type for symbol
identifiers in the bytecode&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Working with S&amp;eacute;bastien Hinderer, I have completed a final review on
his work on switching to a narrower type for global symbols in the
bytecode backend. His PR has been merged on last Friday. Hopefully, it
shall make further work in this area of the compiler simpler by making
it clearer when global symbols are compilation unit names, or when they
might be predefined exceptions.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/ocaml/opam-repository/pull/23965&quot;&gt;ppxlib 0.30
ready to be&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;In the beginning of the week, I have spent some time with the ppxlib
team to check that the new version of ppxlib (with the compatibility fix
for the second alpha release of OCaml 5.1.0) is ready.&lt;/p&gt;
&lt;p&gt;Once this new version of ppxlib is out-of-the-door, I will restart my
survey of the state of the opam ecosystem before the release of the
first beta for OCaml 5.1.0&lt;/p&gt;
&lt;h3&gt;Discussing future
collaborations with Tarides&lt;/h3&gt;
&lt;p&gt;In parallel, I have been discussing with the benchmarking team and
odoc team at Tarides on collaborating on two subjects in the medium term
future:&lt;/p&gt;
&lt;h4&gt;Continuous benchmarks
for the compiler&lt;/h4&gt;
&lt;p&gt;A common subject of interest with Tarides benchmarking team is to try
to set us a pipeline for continuously monitoring the performance of the
OCaml compiler.&lt;/p&gt;
&lt;p&gt;Having such continuous monitoring would bring two major advantages
from my perspective:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;monitoring long term trends: a 0.1% weekly slowdown of the
compiler speed might not be worth worrying. One year of accumulated 0.1%
weekly slowdowns &lt;em&gt;is&lt;/em&gt; worrying.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;catching performance accident early: conversely, a significant
unexpected drop or increase in a Pull Request is a worrying concern that
we want to detect as early to possible to investigate (and possibly) the
cause of this change&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Better
integration of the OCaml manual with &lt;a href=&quot;https://ocaml.org&quot;&gt;ocaml.org&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Currently, the integration of the OCaml manual and API documentation
within the &lt;a href=&quot;https://ocaml.org&quot;&gt;ocaml.org&lt;/a&gt; is very barebone:
The main &lt;code&gt;ocaml.org&lt;/code&gt; site links towards the old
&lt;code&gt;v2.ocaml.org&lt;/code&gt; website where the manual is still hosted
through redirection.&lt;/p&gt;
&lt;p&gt;This setup was supposed to be temporary, but I have not yet found the
time to improve this integration. I hope to fix this in time for the
release of OCaml 5.1.0 in July. In particular, this would be a good time
for transitioning the &lt;code&gt;ocaml.org&lt;/code&gt; hosted API reference to the
odoc version which has been dormant hidden with the compiler repository
for few years now.&lt;/p&gt;

</content><id>http://cambium.inria.fr/blog/florian-compiler-weekly-2023-06-20</id><title type="text">Florian's OCaml compiler weekly, 20 June 2023</title><updated>2023-06-20T08:00:00-00:00</updated><author><email>Florian Angeletti</email><name>gallium</name></author></entry><entry><link href="http://cambium.inria.fr/blog/florian-compiler-weekly-2023-06-12" rel="alternate"/><contributor><uri>http://gallium.inria.fr/blog/index.rss</uri><name>gallium</name></contributor><content type="html">


&lt;p&gt;This series of blog post aims to give a short weekly glimpse into my
(Florian Angeletti) daily work on the OCaml compiler. This week, the
focus is on my roadmap for OCaml 5.2.0 .&lt;/p&gt;


  

&lt;h3&gt;My roadmap for 5.2.0&lt;/h3&gt;
&lt;p&gt;With the stabilisation of OCaml 5.1.0, I have been taking the time to
write down some of my main objectives for OCaml 5.2. There are two
improvements on the compiler interfaces, that I really want to see
materialise in OCaml 5.2: a structured output for compiler messages and
an unified &lt;code&gt;short-paths&lt;/code&gt; implementation between Merlin and
the compiler.&lt;/p&gt;
&lt;h4&gt;A structured output
for compiler messages.&lt;/h4&gt;
&lt;p&gt;In order to better communicate with the various OCaml development
tools, it should be possible to emit compiler messages in a structured
format (JSON or SEXP). One of the Outreachy internship that I mentored
implemented a &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/9979&quot;&gt;first
version of JSON messages&lt;/a&gt; few years ago in 2020.&lt;/p&gt;
&lt;p&gt;However, one criticism of this approach was that it was not clear if
the format would be useful for tools like dune. Similarly, it was not
clear if this format could evolve in a backward compatible way.&lt;/p&gt;
&lt;p&gt;After discussing the issue further with dune developers, the
conclusion was that if any kind of structured output would be useful for
dune, a versioned and backward compatible output would be
&lt;em&gt;really&lt;/em&gt; helpful.&lt;/p&gt;
&lt;p&gt;This is why I am planning to go back on my structured output work in
OCaml 5.2 while focusing on a versioned and structured log facility,
that can be connected to various backend.&lt;/p&gt;
&lt;h4&gt;Unified short paths in
compiler messages&lt;/h4&gt;
&lt;p&gt;When printing type paths in error messages, it is useful to print
user-friendly type names like &lt;code&gt;M.t&lt;/code&gt; and not whatever path the
typechecker stumbled upon after various expansions like
&lt;code&gt;A.Very.Long(Type).Application.t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Both the compiler type pretty-printer and Merlin have an
implementation for discovering and computing canonical type paths in
error messages, which is enabled by the &lt;code&gt;-short-paths&lt;/code&gt;
option.&lt;/p&gt;
&lt;p&gt;However, the implementation of this path normalisation is completely
different between Merlin and the compiler. Having two implementations is
painful in term of both maintenance and evolution of this feature.
Moreover, the compiler implementation was originally meant to be a
temporary prototype for OCaml 4.01.0, ten years ago.&lt;/p&gt;
&lt;p&gt;This is why I am hoping to find the time to finally upstream Merlin&amp;rsquo;s
implementation of the &lt;code&gt;-short-path&lt;/code&gt; flag.&lt;/p&gt;
&lt;h3&gt;Updating
&lt;code&gt;ppxlib&lt;/code&gt; after a parsetree refinement&lt;/h3&gt;
&lt;p&gt;Last week, I also spent some of my time working with the ppxlib team
to iron out the last wrinkles of the second alpha for 5.1.0.&lt;/p&gt;
&lt;p&gt;From the point of view of ppxlib, one of the interesting challenge
introduced by the &lt;code&gt;value binding&lt;/code&gt; parsetree change in 5.1.0
is that it added a new way to represent an old construct&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;let x : typ = expr
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;rather than a completely new construct.&lt;/p&gt;
&lt;p&gt;Indeed, before OCaml 5.1, this construct was desugared to&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;let (x:&amp;oslash;. typ) = (expr:typ)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;whereas in OCaml 5.1, this construct is a new distinct parsetree
node.&lt;/p&gt;
&lt;p&gt;This new parsetree node lead to some interesting questions when
migrating Abstract Syntax Tree between version:&lt;/p&gt;
&lt;h4&gt;When
migrating from the 5.1 to 5.0, can we reproduce the old encoding down to
the location&lt;/h4&gt;
&lt;p&gt;information?&lt;/p&gt;
&lt;p&gt;Maybe surprisingly, the answer is &lt;em&gt;no&lt;/em&gt;. This is due to the
ghost location used in the ghost constraint node: when desugaring
&lt;code&gt;let x: (((int))) = 0&lt;/code&gt; to&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;&amp;oslash;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the 5.0 parser attributed to the pattern &lt;code&gt;x:&amp;oslash;. typ&lt;/code&gt; the
ghost location&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;^^^^^^^^^^^^^^^&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But the new parsetree node only contains the location of the type
&lt;code&gt;int&lt;/code&gt; and not the location of the end of the parentheses. We
are thus losing a bit of information because the former encoding was
using a concrete syntax tree location that we no longer have access to.
Fortunately, this only happens on a ghost location of a ghost parsetree
node.&lt;/p&gt;
&lt;h4&gt;Is
the migration from the 5.1 parsetree to the 5.0 parsetree always
injective?&lt;/h4&gt;
&lt;p&gt;Most of the time, it is possible to map an OCaml 5.1 value binding
onto an unique OCaml 5.0 encoded value binding. This works because the
encoding used for value bindings in 5.0 constructs type expressions of
the form &lt;code&gt;&amp;oslash;. typ&lt;/code&gt; that are not allowed in OCaml. We can thus
use those special type expressions to recognise desugared value
bindings.&lt;/p&gt;
&lt;p&gt;Unfortunately, this is only the case when binding variables. Indeed,
as soon as the pattern in the value binding is not a variable&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the 5.0 parser desugars this value binding to&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;without any encoding of the type constraint. This means in particular
that the 5.0 parser creates the same AST node for both&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;and&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;which are two different constructs in OCaml 5.1.&lt;/p&gt;
&lt;p&gt;Consequently, when we migrate a 5.0 parsetree of this form to the
5.1, we have to decide if we should migrate this syntactic construct to
the old parsetree node or to the new node. In this case, since the new
syntactic node corresponds to a &amp;ldquo;more pleasant&amp;rdquo; syntactic form, we
decided to favour this form.&lt;/p&gt;

</content><id>http://cambium.inria.fr/blog/florian-compiler-weekly-2023-06-12</id><title type="text">Florian's OCaml compiler weekly, 12 June 2023</title><updated>2023-06-12T08:00:00-00:00</updated><author><email>Florian Angeletti</email><name>gallium</name></author></entry><entry><link href="http://cambium.inria.fr/blog/florian-compiler-weekly-2023-05-06" rel="alternate"/><contributor><uri>http://gallium.inria.fr/blog/index.rss</uri><name>gallium</name></contributor><content type="html">


&lt;p&gt;This series of blog post aims to give a short weekly glimpse into my
(Florian Angeletti) daily work on the OCaml compiler. This week, the
focus is on the release of the second alpha for OCaml 5.1.0.&lt;/p&gt;


  

&lt;h3&gt;OCaml 5.1.0 second alpha
release:&lt;/h3&gt;
&lt;p&gt;The last two weeks I have spent most of my time preparing for the
second alpha release of OCaml 5.1.0. This second alpha has just been
published last Friday. This new alpha release is quite heavy in term of
bug fixes. Indeed, this release contains two major fixes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/pull/11903&quot;&gt;Garbage
Collector fix&lt;/a&gt;: before this second alpha, an idle domain (or more
precisely a non-allocating domain) could slow down considerably the
major collection. Indeed, the work attributed to each domain during a
major collection was scaled in function of the local domain allocation
rate. Consequently, a non-allocating domain would choose to do little to
no GC work, leaving the GC unable to keep up with the real allocation
rate. To solve this issue, the new alpha has introduced a global
accounting for the allocation rate and a global distribution of GC work
along the domains.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/pull/11846&quot;&gt;Windows ABI
fix&lt;/a&gt;, the full separation of the OCaml and C stacks in OCaml 5.0.0
created an ABI violation on Windows. More precisely, the new OCaml stack
was still satisfying the Windows x64 ABI requirements even if it was no
longer necessary. Contrarily C functions might end up called with a
malformed C stack. With this fix, the OCaml stack has been freed from
the Windows C ABI while the C stack fulfils the correct
requirements.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Slightly less visible, we also have an important fix in the OCaml
compiler-libs and a type system backward compatibility enhancement:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/pull/12191&quot;&gt;compiler-libs
fix&lt;/a&gt;: as discussed [previously]
(http://gallium.inria.fr/blog/florian-compiler-weekly-2023-04-24/), the
parser published in OCaml 5.1.0~alpha1 was dropping constraints on value
bindings (for instance &lt;code&gt;let x :&amp;gt; [&amp;gt; X of int] = ...&lt;/code&gt;).
This has been fixed in 5.1.0~alpha2. Unfortunately such changes this
late in the release cycle will require more work in the ppxlib
library.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/pull/12211&quot;&gt;type system
compatibility enhancement&lt;/a&gt;: similarly, the backward compatibility
improvement that I was discussing in my &lt;a href=&quot;http://gallium.inria.fr/blog/florian-compiler-weekly-2023-04-28&quot;&gt;last
April blog post&lt;/a&gt; has been integrated in this second alpha. This
change restores compatibility with some accidentally compiling OCaml
code by using a more charitable interpretation for type annotation of
the form &lt;code&gt;'a . [&amp;gt; X of 'a ] -&amp;gt; 'a -&amp;gt; 'a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, this second alpha release also contains a new backend for
IBM s390x (which was contributed by IBM). Including a new architecture
in an alpha release feels a bit daring. However, new backends have no
effects on existing users and give us a wider testing environment for
the new port. Consequently, I thought that it was sensible to integrate
the new backend in the last alpha.&lt;/p&gt;
&lt;p&gt;Overall, this second alpha release feels less stable that I would
have wished, but the release process is definitively going forward. With
this late release out of the door, my current plan is to focus on
releasing a first beta release of OCaml 5.1.0 in the upcoming weeks. If
everything goes well, we could have a final release of OCaml 5.1.0
around mid-July.&lt;/p&gt;

</content><id>http://cambium.inria.fr/blog/florian-compiler-weekly-2023-05-06</id><title type="text">Florian's OCaml compiler weekly, 5 June 2023</title><updated>2023-06-05T08:00:00-00:00</updated><author><email>Florian Angeletti</email><name>gallium</name></author></entry><entry><link href="http://cambium.inria.fr/blog/two-variants-of-the-bind-rule" rel="alternate"/><contributor><uri>http://gallium.inria.fr/blog/index.rss</uri><name>gallium</name></contributor><content type="html">

&lt;p&gt;This post discusses two ways of writing the Bind rule of Separation
Logic. They are logically equivalent, but in practice, one should choose
wisely between them.&lt;/p&gt;




&lt;p&gt;The Bind rule of Separation Logic is the rule that allows reasoning
about a sequence of two instructions. In the statements that follow,
such a sequence takes the form &lt;code&gt;bind m1 m2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are several ways of writing this rule. The form that is
traditionally used in the Hoare logic community has two premises, along
the following lines:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;  WP m1 &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;{{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;phi;&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; -&amp;lowast;&lt;/span&gt;
&lt;span class=&quot;x&quot;&gt;  (&amp;forall; v, &amp;phi; v -&amp;lowast; WP (m2 v) &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;{{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;psi;&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;) -&amp;lowast;&lt;/span&gt;
&lt;span class=&quot;x&quot;&gt;  WP (bind m1 m2) &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;{{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;psi;&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This means that, to verify the program &lt;code&gt;bind m1 m2&lt;/code&gt;, one
must first verify the subprogram &lt;code&gt;m1&lt;/code&gt; and establish that,
when &lt;code&gt;m1&lt;/code&gt; terminates, some property &lt;code&gt;&amp;phi;&lt;/code&gt; holds.
Then, under the assumption that &lt;code&gt;&amp;phi;&lt;/code&gt; holds when the execution
of &lt;code&gt;m2&lt;/code&gt; begins, one must prove that it is safe to run
&lt;code&gt;m2&lt;/code&gt;. It is up to the user to choose or guess the logical
assertion &lt;code&gt;&amp;phi;&lt;/code&gt; that describes the intermediate state.&lt;/p&gt;
&lt;p&gt;The form that is most often used in the Iris community has only one
premise:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;  WP m1 &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;{{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lambda;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;WP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m2&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;psi;&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; }} -&amp;lowast;&lt;/span&gt;
&lt;span class=&quot;x&quot;&gt;  WP (bind m1 m2) &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;{{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;psi;&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This means that, to verify the program &lt;code&gt;bind m1 m2&lt;/code&gt;, one
must first verify establish that, when &lt;code&gt;m1&lt;/code&gt; terminates, it is
safe to run &lt;code&gt;m2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;These two forms of the Bind rule are logically equivalent. The second
form follows from the first one by instantiating &lt;code&gt;&amp;phi;&lt;/code&gt; with
&lt;code&gt;&amp;lambda; v, WP (m2 v) {{ &amp;psi; }}&lt;/code&gt;. Conversely, the first form follows
from the second one and from the Consequence rule of Separation
Logic.&lt;/p&gt;
&lt;h3&gt;Which form is preferable?&lt;/h3&gt;
&lt;p&gt;Does this mean that the two forms of the Bind rule are
interchangeable? Not quite; there are practical reasons for preferring
one over the other.&lt;/p&gt;
&lt;p&gt;The second form can seem preferable because it does not require
guessing or choosing a suitable postcondition &lt;code&gt;&amp;phi;&lt;/code&gt;. Indeed, it
automatically uses the most permissive &lt;code&gt;&amp;phi;&lt;/code&gt;, which is
&lt;code&gt;&amp;lambda; v, WP (m2 v) {{ &amp;psi; }}&lt;/code&gt;. Thus, this form may seem as though
it is more amenable to automation.&lt;/p&gt;
&lt;p&gt;However, this second form comes with a caveat. If the verification of
the subprogram &lt;code&gt;m1&lt;/code&gt; involves a case analysis, then it is
usually desirable to limit the scope of this case analysis to just
&lt;code&gt;m1&lt;/code&gt;. In other words, the scope of the case analysis must not
encompass &lt;code&gt;m2&lt;/code&gt;, because that would imply that &lt;code&gt;m2&lt;/code&gt;
must be verified several times.&lt;/p&gt;
&lt;p&gt;Because the first form of the Bind rule introduces two subgoals (one
for &lt;code&gt;m1&lt;/code&gt; and one for &lt;code&gt;m2&lt;/code&gt;), the scope of a case
analysis inside &lt;code&gt;m1&lt;/code&gt; is naturally limited to the first
subgoal. The second form of the Bind rule does not have this property:
because it has just one premise, a user who naively performs a case
analysis while verifying &lt;code&gt;m1&lt;/code&gt; ends up having to verify
&lt;code&gt;m2&lt;/code&gt; several times.&lt;/p&gt;
&lt;p&gt;In summary, if &lt;code&gt;m1&lt;/code&gt; is a conditional construct (e.g., an
&lt;code&gt;if&lt;/code&gt; or &lt;code&gt;match&lt;/code&gt; construct) then the middle point
between &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; is a &lt;em&gt;join point&lt;/em&gt; and
the first form of the Bind rule, where the user must provide
&lt;code&gt;&amp;phi;&lt;/code&gt;, should be preferred. Otherwise, the second form of the
Bind rule can be used and there is no need for the user to provide
&lt;code&gt;&amp;phi;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is not a deep remark. It is just a possibly-useful reminder that
two logically equivalent statements can have quite different qualities
in practical usage scenarios.&lt;/p&gt;

</content><id>http://cambium.inria.fr/blog/two-variants-of-the-bind-rule</id><title type="text">Two variants of the Bind rule</title><updated>2023-05-30T08:00:00-00:00</updated><author><email>François Pottier</email><name>gallium</name></author></entry><entry><link href="http://gallium.inria.fr/blog/function-specs-2023-05-12" rel="alternate"/><contributor><uri>http://gallium.inria.fr/blog/index.rss</uri><name>gallium</name></contributor><content type="html">

&lt;p&gt;In this post, I discuss two approaches to writing formal
specifications for (possibly curried) functions of multiple arguments. I
refer to these two styles as &lt;em&gt;callee-side reasoning&lt;/em&gt; and
&lt;em&gt;caller-side reasoning&lt;/em&gt;. While the former style is very much
standard, the latter style is perhaps relatively little known.&lt;/p&gt;





&lt;h3&gt;Specifying Functions: Two
Styles&lt;/h3&gt;
&lt;p&gt;In OCaml, the definitions &lt;code&gt;let f = fun (x1, x2) -&amp;gt; e&lt;/code&gt;
and &lt;code&gt;let g = fun x1 -&amp;gt; fun x2 -&amp;gt; e&lt;/code&gt; both define
functions. The function &lt;code&gt;f&lt;/code&gt; is &lt;em&gt;uncurried&lt;/em&gt;: it expects
one argument, which must be a pair. The function &lt;code&gt;g&lt;/code&gt; is
&lt;em&gt;curried&lt;/em&gt;: it expects one argument and returns a function of one
argument.&lt;/p&gt;
&lt;p&gt;In both cases, the function invocation process is non-atomic. From
the moment where the function application &lt;code&gt;f (v1, v2)&lt;/code&gt; or
&lt;code&gt;g v1 v2&lt;/code&gt; begins, until the moment where the function body
&lt;code&gt;e&lt;/code&gt; is executed, in a context where the name &lt;code&gt;x1&lt;/code&gt;
is bound to the value &lt;code&gt;v1&lt;/code&gt; and the name &lt;code&gt;x2&lt;/code&gt; is
bound to the value &lt;code&gt;v2&lt;/code&gt;, a number of computation steps take
place. In the case of the function application &lt;code&gt;f (v1, v2)&lt;/code&gt;,
the pair &lt;code&gt;(v1, v2)&lt;/code&gt; is first transmitted to the function;
then, this pair is decomposed; and only then is the function body
executed. In the case of the function application &lt;code&gt;g v1 v2&lt;/code&gt;,
the value &lt;code&gt;v1&lt;/code&gt; is first transmitted to the function; then,
some kind of nameless function, or closure, is returned; then, the value
&lt;code&gt;v2&lt;/code&gt; is transmitted to this nameless function; and only then
is the function body executed.&lt;/p&gt;
&lt;p&gt;In either case, the purpose of the function invocation process is to
eventually bind the formal parameters &lt;code&gt;x1&lt;/code&gt; and
&lt;code&gt;x2&lt;/code&gt; to the actual arguments &lt;code&gt;v1&lt;/code&gt; and
&lt;code&gt;v2&lt;/code&gt;. However, the details of the process vary. Furthermore,
in the case of a curried function, this process can be
&lt;em&gt;interrupted&lt;/em&gt; in the middle and resumed at a later time, because
&lt;em&gt;partial applications&lt;/em&gt; are permitted: the function application
&lt;code&gt;g v1&lt;/code&gt; returns a perfectly valid function of one
argument.&lt;/p&gt;
&lt;p&gt;How does one describe the behavior of the functions &lt;code&gt;f&lt;/code&gt;
and &lt;code&gt;g&lt;/code&gt; in precise informal prose or in a formal program
logic, such as Hoare logic or Separation Logic?&lt;/p&gt;
&lt;p&gt;Two distinct approaches emerge, depending on &lt;em&gt;who&lt;/em&gt; reasons
about the function invocation process: the callee, or the caller?&lt;/p&gt;
&lt;p&gt;In the first style, &lt;em&gt;callee-side reasoning&lt;/em&gt;, one publishes a
specification of &lt;em&gt;the function&lt;/em&gt;; whereas in the second style,
&lt;em&gt;caller-side reasoning&lt;/em&gt;, one publishes a specification of &lt;em&gt;the
function&amp;rsquo;s body&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Callee-Side Reasoning&lt;/h4&gt;
&lt;p&gt;It may seem more natural to let the callee reason about the function
invocation process. Indeed, this process is then analyzed just once, at
the function definition site, as opposed to once at each call site.
Furthermore, this approach results in more abstract specifications,
along the following lines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;After the definition &lt;code&gt;let f = fun (x1, x2) -&amp;gt; e&lt;/code&gt;,
the name &lt;code&gt;f&lt;/code&gt; is bound to some value &lt;code&gt;v&lt;/code&gt; such that,
for all values &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;, the application of
&lt;code&gt;v&lt;/code&gt; to the pair &lt;code&gt;(v1, v2)&lt;/code&gt; results in &amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After the definition
&lt;code&gt;let g = fun x1 -&amp;gt; x2 -&amp;gt; e&lt;/code&gt;, the name &lt;code&gt;g&lt;/code&gt; is
bound to some value &lt;code&gt;v&lt;/code&gt; such that, for all values
&lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;, the application of &lt;code&gt;v&lt;/code&gt;
to the values &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; result in &amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In these specifications, the value &lt;code&gt;v&lt;/code&gt; remains abstract.
It is a runtime representation of a function (presumably a code pointer
or some kind of closure), but the caller does not have to know.&lt;/p&gt;
&lt;p&gt;This is the most common style.&lt;/p&gt;
&lt;p&gt;An upside of this style is its high level of abstraction: functions
are viewed as abstract objects.&lt;/p&gt;
&lt;p&gt;A downside of this style is that it does not support partial
applications in a very natural way. The above specification of
&lt;code&gt;g&lt;/code&gt; describes only what happens when &lt;code&gt;g&lt;/code&gt; is
applied to &lt;em&gt;two&lt;/em&gt; values &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;. If
one wishes to allow the partial application &lt;code&gt;g v1&lt;/code&gt;, then one
must write a more complex specification. This is possible, but slightly
cumbersome.&lt;/p&gt;
&lt;h4&gt;Caller-Side Reasoning&lt;/h4&gt;
&lt;p&gt;The other, less common, approach is to publish a specification of the
function&amp;rsquo;s &lt;em&gt;body&lt;/em&gt;, along the following lines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For all values &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;, if the names
&lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are bound to the values
&lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;, then the execution of the
expression &lt;code&gt;e&lt;/code&gt; results in &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then, the functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; can be
described in a concrete manner, along the following lines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;After the definition &lt;code&gt;let f = fun (x1, x2) -&amp;gt; e&lt;/code&gt;,
the name &lt;code&gt;f&lt;/code&gt; is bound to the function
&lt;code&gt;fun (x1, x2) -&amp;gt; e&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After the definition
&lt;code&gt;let g = fun x1 -&amp;gt; x2 -&amp;gt; e&lt;/code&gt;, the name &lt;code&gt;g&lt;/code&gt; is
bound to the function &lt;code&gt;fun x1 -&amp;gt; fun x2 -&amp;gt; e&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are not traditional specifications in the tradition of Floyd
and Hoare. Instead of describing the &lt;em&gt;abstract behavior of an
application&lt;/em&gt; of the functions &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;g&lt;/code&gt;, they
are &lt;em&gt;concrete descriptions of the runtime values&lt;/em&gt; that represent
the functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It is then up to the caller, at each call site, to reason about the
function invocation process.&lt;/p&gt;
&lt;p&gt;A downside of this style is its lower level of abstraction: functions
are viewed as concrete values whose runtime representation is exposed.
(For example, whether a function is recursive or not recursive becomes
visible.)&lt;/p&gt;
&lt;p&gt;An upside of this style is that it naturally offers support for
partial applications, without any extra effort. The above specifications
expose sufficient information for the caller to reason about a partial
application.&lt;/p&gt;
&lt;h4&gt;Bottom Line&lt;/h4&gt;
&lt;p&gt;As far as I know, the existence of these two styles is discussed
nowhere in the literature. I can see two reasons why this is so:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The distinction between these styles arises only because the
function invocation process is not atomic. In a language where n-ary
functions are primitive, the function invocation process atomically
binds &lt;code&gt;x1&lt;/code&gt; to &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; to
&lt;code&gt;v2&lt;/code&gt;. The program logic can take care of reasoning about this
step, so neither the callee nor the caller need to reason about
it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Caller-side reasoning is less abstract and requires a mixture of
Hoare-style reasoning (that is, reasoning in terms of logical
assertions) and symbolic execution (that is, reasoning by simulating
steps of execution). The tradition and culture of Hoare-style reasoning
is so prevalent that this style may seem quite alien to most researchers
and practitioners.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</content><id>http://gallium.inria.fr/blog/function-specs-2023-05-12</id><title type="text">Specifying Functions: Two Styles</title><updated>2023-05-12T08:00:00-00:00</updated><author><email>François Pottier</email><name>gallium</name></author></entry><entry><link href="http://gallium.inria.fr/blog/florian-compiler-weekly-2023-04-28" rel="alternate"/><contributor><uri>http://gallium.inria.fr/blog/index.rss</uri><name>gallium</name></contributor><content type="html">

    &lt;p&gt;This series of blog post aims to give a short weekly glimpse into my
(Florian Angeletti) daily work on the OCaml compiler. This week, the
focus is on compiler messages and backward compatibility.&lt;/p&gt;


  

  
&lt;h3&gt;A tag for quoting inline
code&lt;/h3&gt;
&lt;p&gt;Last week, while I was investigating the breaking change in behavior
for polymorphic variants, I have also started a much more boring change:
uniformizing the quoting style for inline code in the compiler
messages.&lt;/p&gt;
&lt;p&gt;Currently, this quoting style is mostly left to the appreciation of
authors of every compiler messages. This has lead the OCaml compiler
messages to be quite heterogeneous, with different messages using
&lt;code&gt;&amp;quot;...&amp;quot;&lt;/code&gt;, other &lt;code&gt;'...'&lt;/code&gt;, or &lt;code&gt;`...'&lt;/code&gt;,
depending on the preference of the initial author.&lt;/p&gt;
&lt;p&gt;To make the compiler message, I spent the time to introduce a new
&lt;code&gt;inline_code&lt;/code&gt; tag in the set of &lt;code&gt;Format&lt;/code&gt; tags used
by the compiler.&lt;/p&gt;
&lt;p&gt;With this new tag, the compiler message&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;The external function `%s' is not available&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;can be rewritten as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;The external function %a is not available&amp;quot;&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inline_code&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;which has the advantage of centralizing the styling of inline code
fragment in a single location. In particular, this means that we could
adapt the styling to the rendering medium (fancy terminal could use
fancy styling while basic terminal use a textual quote).&lt;/p&gt;
&lt;p&gt;My proposal with this change is currently available as a &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/12210&quot;&gt;pull request&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Cleaning-up error messages&lt;/h3&gt;
&lt;p&gt;Adding an &lt;code&gt;inline_code&lt;/code&gt; tag was also a good occasion to
spot small mistakes in error messages. For example, the error message
for non-overriding inheritance&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;also_empty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inherit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;lost a word at some point it time, yielding the following error
message&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;This&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inheritance&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;does&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;override&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;which may confuse reader wondering what is a
&lt;code&gt;method instance variable&lt;/code&gt;. The sentence is quite easier to
read once we add back the missing &lt;code&gt;and&lt;/code&gt; and plurals&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;This&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inheritance&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;does&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;override&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;or&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Backward
compatibility and polymorphic variants&lt;/h3&gt;
&lt;p&gt;As discussed last week, I have been working with Gabriel Scherer on a
way to preserve backward compatibility for programs that mix open
polymorphic variant types and explicit polymorphic annotation in OCaml
5.1:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The backward compatibility hack that we came up with last week is to
automatically add the missing annotations:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, while writing a description of this hack in &lt;a href=&quot;https://github.com/ocaml/ocaml#12211&quot;&gt;my pull request&lt;/a&gt;, I
realized that this change was breaking backward compatibility in
&lt;em&gt;another&lt;/em&gt; corner case:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|_)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here the issue is that writing such type annotation let the
typechecker infers that the real type of the row variable is
&lt;code&gt;[&amp;gt; `Foo | `Bar` ]&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|_)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;and not just &lt;code&gt;[&amp;gt; `Foo ]&lt;/code&gt;. However, with our hack, this
code will be converted to&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;([&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|_)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;where suddenly we cannot widen &lt;code&gt;[&amp;gt; `Foo ]&lt;/code&gt; to
&lt;code&gt;[&amp;gt; `Foo | `Bar` ]&lt;/code&gt;. And thus the line above fails to
compile with&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;This&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[?&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;       &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;but&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;was&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;which&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;       &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;The&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;variant&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bound&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;the&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;universal&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;       &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;may&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allow&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;the&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To avoid this regression, Jacques Garrigue proposed to only add
annotations to polymorphic variant types that contains references to
universal type variables. In other words, with this updated rule&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|_)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;is kept unchanged because &lt;code&gt;[&amp;gt; `Foo ]&lt;/code&gt; does not point to
&lt;code&gt;'b&lt;/code&gt; (or any universally quantified type variables).&lt;/p&gt;
&lt;p&gt;Contrarily&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;is transformed into&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;([&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;because &lt;code&gt;[&amp;gt; `X  of 'a ]&lt;/code&gt; refers to the explicitly
quantified type variable &lt;code&gt;'a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Moreover, this rule is still well behaved in presence of nested
explicitly polymorphic annotations. For instance, looking at&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a.&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;  &amp;lt;m: '&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'irr. ('&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;irr&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a | `Y of '&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a) &amp;gt;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;  &amp;gt; -&amp;gt; '&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;we can see that the nearest explicit annotation where all universal
variables involved in &lt;code&gt;[&amp;gt; `X of 'a | `Y of 'b]&lt;/code&gt; are bound
is the one the method &lt;code&gt;m&lt;/code&gt;. Thus the type above is equivalent
with the new rule to:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nested&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;irr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;irr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(([&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On the one hand, I am not sure if the restoration of backward
compatibility in OCaml 5.1 is really worth the complexity of this new
rule. On the other hand, the new rule is conservative enough that we
could use it to emit warnings or hint messages with a sensible
resolution if the missing feature for constrained abstract types lands
in OCaml.&lt;/p&gt;


  </content><id>http://gallium.inria.fr/blog/florian-compiler-weekly-2023-04-28</id><title type="text">Florian's OCaml compiler weekly, 28 April 2023</title><updated>2023-04-28T08:00:00-00:00</updated><author><email>Florian Angeletti</email><name>gallium</name></author></entry><entry><link href="http://cambium.inria.fr/blog/florian-compiler-weekly-2023-04-24" rel="alternate"/><contributor><uri>http://gallium.inria.fr/blog/index.rss</uri><name>gallium</name></contributor><content type="html">

  &lt;p&gt;This series of blog post aims to give a short weekly glimpse into my
(Florian Angeletti) daily work on the OCaml compiler. This week, the
focus is on two interesting bugs in the first alpha release of OCaml
5.1.0.&lt;/p&gt;


  

&lt;p&gt;With the release of the first alpha for OCaml 5.1.0, I have shifted a
part of my time towards updating core tools like &lt;a href=&quot;https://github.com/ocaml/odoc/pull/956&quot;&gt;odoc&lt;/a&gt; for OCaml 5.1 and
hunting bugs in the new release.&lt;/p&gt;
&lt;p&gt;Last Monday, working with Kate Deplaix, we found two interesting bugs
by looking at &lt;a href=&quot;http://check.ocamllabs.io&quot;&gt;the opam-health-check
reports&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A bug in the new parsetree node for value bindings&lt;/li&gt;
&lt;li&gt;A potentially painful change of behavior for explicitly polymorphic
with open polymorphic variant types.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Coercion on value
definitions&lt;/h3&gt;
&lt;p&gt;The first bug stems from a rare construct in the OCaml language:
coercion in value definition:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here, we are coercing the body of the value definition to the type
&lt;code&gt;&amp;lt;x:int&amp;gt;&lt;/code&gt; masking the method &lt;code&gt;m&lt;/code&gt;. This
syntax is a bit surprising we have an explicit coercion which is an
expression which is applied on the pattern side of the definition.&lt;/p&gt;
&lt;p&gt;Before OCaml 5.1, such constructions were desugared in the parser
itself to:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When I updated the abstract syntax tree to avoid desugaring value
bindings of the form&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;let pat: typ = exp
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;in the parsetree, I forgot this case which means that the AST dropped
the coercion part of the annotation.&lt;/p&gt;
&lt;p&gt;This mistake ought to be fixed but it leads to an interesting
question on how to represent constraints on value bindings. Should we be
generic and represent the constraints as:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value_constraint&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locally_abstract_types&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;typ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type_expr&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;typ&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coercion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type_expr&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;typ&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, with this representation, we cover two possible new cases
that could be written in fantasy syntax as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;type a b c. typ :&amp;gt; coercion
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;and&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;type a b c. :&amp;gt; coercion
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;More problematically, this product type allows for constraints
without any real constraints&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;type a b c.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Thus the generic product feels a tad too wide.&lt;/p&gt;
&lt;p&gt;Another option is to tailor a type closer to the currently supported
syntax with&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value_constraint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Constraint&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;locally_abstract_types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;(* type a b c . ... *)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;typ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type_expr&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;(* ...: typ *)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Coercion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;ground&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type_expr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;(* typ? ...* );&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;      coercion: type_expr  (* ...  :&amp;gt; typ *)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This representation has the disadvantage of losing part of the
similarity between the &lt;code&gt;Coercion&lt;/code&gt; and &lt;code&gt;constraint&lt;/code&gt;
case but it covers exactly the constructs allowed in the syntax.&lt;/p&gt;
&lt;p&gt;This my &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/12191&quot;&gt;current
bug fix proposal&lt;/a&gt; for OCaml 5.1.0 .&lt;/p&gt;
&lt;h3&gt;Polymorphic
variants and explicit universal quantification&lt;/h3&gt;
&lt;p&gt;Another interesting difference of behavior between OCaml 5.1.0 and
5.0.0 appears when writing code that mix both open polymorphic variant
types and explicit polymorphic annotation:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This code compiled in OCaml 5.0.0, but fails in OCaml 5.1.0 with&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;This&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[?&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'b ]&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;      but a pattern was expected which matches values of type [&amp;gt; `X of '&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;The&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;universal&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;would&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;escape&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;its&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;because the universal variable &lt;code&gt;'a&lt;/code&gt; might escape through
the global row variable hidden in &lt;code&gt;[&amp;gt; X of _ ]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The issue can be fixed by making sure that the row variable is also
bound by the explicit universal quantification:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Not only this fix is not that obvious, but it is not compatible with
the short syntax for universal-outside and locally abstract-inside type
variables. For instance, if we start with&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;adding a local type &lt;code&gt;r&lt;/code&gt; doesn&amp;rsquo;t help&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a,'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a ] as '&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;This&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;should&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;be&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;an&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;because we would need a constrained abstract type.&lt;/p&gt;
&lt;p&gt;Thus, we are left with no other options than desugaring the short
hand to:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;which is a bit of mouthful compared to our starting point.&lt;/p&gt;
&lt;p&gt;Thus, I have been investigating with Gabriel Scherer a possibility to
keep the previous definition working&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a. [&amp;gt; `X of '&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a = function (`X x) -&amp;gt; x | _ -&amp;gt; assert false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;by making the assumption that any row variables that are unnamed in
an explicit type annotation under an explicit universal quantification
should be bound by the binder. In other words, we could consider that
whenever an user write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a. [&amp;gt; `X of '&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a = function (`X x) -&amp;gt; x | _ -&amp;gt; assert false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;they meant to write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a '&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a ] as '&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a = function (`X x) -&amp;gt; x | _ -&amp;gt; assert false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;and thus the typechecker ought to add implicitly the row variable
&lt;code&gt;'r'&lt;/code&gt; to the list of bound variables in the left-hand side of
&lt;code&gt;.&lt;/code&gt;.&lt;/p&gt;

</content><id>http://cambium.inria.fr/blog/florian-compiler-weekly-2023-04-24</id><title type="text">Florian's OCaml compiler weekly, 24 April 2023</title><updated>2023-04-24T08:00:00-00:00</updated><author><email>Florian Angeletti</email><name>gallium</name></author></entry><entry><link href="http://cambium.inria.fr/blog/florian-compiler-weekly-2023-04-17" rel="alternate"/><contributor><uri>http://gallium.inria.fr/blog/index.rss</uri><name>gallium</name></contributor><content type="html">

  &lt;p&gt;This series of blog post aims to give a short weekly glimpse into my
(Florian Angeletti) daily work on the OCaml compiler. This week, the
focus is on the first alpha release of OCaml 5.1.0 and some discussion
with the ocamlformat team.&lt;/p&gt;


  

&lt;h3&gt;First alpha release for
OCaml 5.1.0&lt;/h3&gt;
&lt;p&gt;Between Friday and Saturday, I have published the first alpha for
OCaml 5.1.0. As the first version of OCaml 5 published after the feature
freeze for OCaml 5, this version feels like a midpoint between the usual
release process for OCaml 4 and the experimental release of OCaml 5.0.0
.&lt;/p&gt;
&lt;p&gt;In particular, this release will integrate many features that were
either frozen during the development of OCaml 5 or merged in the
development version after the branch for OCaml 5.0 was cut. For
instance, the support for Risc-V was merged in July last year, but it
will only be available with OCaml 5.1 around next July.&lt;/p&gt;
&lt;p&gt;Contrarily, the development windows for contributors that were busy
with OCaml 5.0.0 bug fixing was especially short since there was only
four months between the OCaml 5.0.0 release and the feature freeze for
OCaml 5.1 .&lt;/p&gt;
&lt;p&gt;It is a bit too soon right now to try to summarize the new features
in OCaml 5.1, since unexpected problems might still require to remove
some of the new features (even if that happens rarely in practice).&lt;/p&gt;
&lt;p&gt;However, I have a quite interesting early example of unexpected
incompatibility due to a refactoring: the more precise support for
generative functors break the menhir parser generator.&lt;/p&gt;
&lt;h4&gt;An
example on unintended breakage for generative functor&lt;/h4&gt;
&lt;p&gt;What are generative functors?&lt;/p&gt;
&lt;p&gt;In brief, generative functors are a way to express the fact that
evaluating a functor create side-effect that meaningfully impact the
types that the functor creates and thus two successive applications of
the functor should away yield different types.&lt;/p&gt;
&lt;p&gt;This would be hopefully clearer with the following example, consider
the functor:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Make_counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sig&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sig&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stride&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;meta&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;meta&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stride&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stride&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here, the functor is applicative, and unsafe! We can break the
internal assertion that we only add &lt;code&gt;stride&lt;/code&gt; to our counters
by using the fact that the two modules &lt;code&gt;Counter_1&lt;/code&gt; and
&lt;code&gt;Counter_2&lt;/code&gt; share the same types &lt;code&gt;t&lt;/code&gt; in&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Make_counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Make_counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Thus, we can mix calls to functions of the two modules to break one
of the internal invariants:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assert_failure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Counter_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;nn&quot;&gt;Counter_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nn&quot;&gt;Counter_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Of course, here the issue is that the functor &lt;code&gt;Counter&lt;/code&gt;
was intended to be used only with anonymous structure as an argument&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Make_counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here, since we have lost the identity of the anonymous module after
the application, we are guaranteed that the type &lt;code&gt;Counter.t&lt;/code&gt;
is fresh.&lt;/p&gt;
&lt;p&gt;Generative functors (available since OCaml 4.02) makes it possible to
express this intent in the module type system. By defining the functor
&lt;code&gt;Make_counter&lt;/code&gt; as generative with&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Generative_make_counter&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sig&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stride&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;meta&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;meta&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stride&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stride&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Generative_make_counter&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;we inform the module system that&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Counter_1&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Generative_make_counter&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;is an error which is rejected with&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;This&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;generative&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;It&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;can&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;only&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;be&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;applied&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Consequently, we are guaranteed that each call to
&lt;code&gt;Make_counter&lt;/code&gt; creates a fresh type &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, back in 4.02 and 2014, it was decided to represent the
generative application as an application to a syntactic empty structure.
In other words,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Make_counter&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;was represented as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Make_counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This choice of the representation was simpler but it has the
disadvantage of allowing some confusing code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, applicative functors could applied to the unit argument:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Make_counter&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;Second, generative functors could be applied to a syntactically
empty structure:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Generative_make_counter&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;end&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;At least, both options make it clear that the types of the generated
modules would be fresh.&lt;/p&gt;
&lt;p&gt;Nevertheless, with more hindsight, it seems better to make the
distinction between the two cases clearer. Thus starting with OCaml 5.1,
the parser and the typechecker distinguishes between &lt;code&gt;F()&lt;/code&gt;
and &lt;code&gt;F(struct end)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In OCaml 5.1, applying a functor to a syntactically empty
structure&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Warning&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Generative_make_counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;generates a warning&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Warning&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;73&lt;/span&gt; [&lt;span class=&quot;nv&quot;&gt;generative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;expects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;unit&lt;/span&gt;]: &lt;span class=&quot;nv&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;generative&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;functor&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;should&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;applied&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; using '(struct end)' is deprecated.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This warning is here to let some breathing room for ppxs that had to
use this syntax before OCaml 5.1 .&lt;/p&gt;
&lt;p&gt;Contrarily, applying an applicative functor to the empty argument
generates an error&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Make_counter&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;The&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functor&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;was&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;be&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;applicative&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;During the review of this change, I didn&amp;rsquo;t think about the
possibility that some OCaml programs would have switch to generative
syntax for application without making the change to the type of the
functor itself.&lt;/p&gt;
&lt;p&gt;But this was too optimistic for at least one opam package. This
package is now fixed, but it remains to be seen if this was an
unfortunate and rare accident. If this is not the case, we will need to
add a deprecation warning on this side too.&lt;/p&gt;
&lt;h3&gt;OCaml Parser and ocamlformat&lt;/h3&gt;
&lt;p&gt;This week, I also had an interesting discussions with members of the
ocamlformat team concerning upstreaming some of the ocamlformat patches
to the compiler.&lt;/p&gt;
&lt;p&gt;As a code formatter, ocamlformat needs to maintain a more precise
mapping between its syntax tree and the code source that the main OCaml
parser. Indeed, ocamlformat cannot afford to discard meaningful
distinction in the code source due to some synctactic sugar. Contrarily,
the main compiler only need to keep enough information about the code
source to be able to report errors, and prints the parsed abstract
syntax tree in a good-enough format.&lt;/p&gt;
&lt;p&gt;The objectives of the two parsers are thus not completely aligned.
However, comparing notes from time to time is a good way to catch
potential issues.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is the compiler loosing important location information?&lt;/li&gt;
&lt;li&gt;Is the compiler mixing different concern in the parsing of the code
source?&lt;/li&gt;
&lt;li&gt;Is the compiler making ppxs transformation harder to express because
the AST veer too far from the surface language?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A good example of the last two categories was my &lt;a href=&quot;https://cambium.inria.fr/blog/florian-weekly-2023-03-27/&quot;&gt;change&lt;/a&gt;
for type constraints on value binding. Indeed, before this change the
OCaml parser read&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;as if the programmer had written:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Of course, the two construct are defined to be equivalent at the
level of the typechecker. It is however pretty clear that the
distinction between the two is very meaningful for the programmer.
Moreover, the transformation is complex enough that ppx authors would
probably rather not try to undo the transformation.&lt;/p&gt;
&lt;p&gt;Moving the transformation from the parser to the typechecker was thus
deemed a good move.&lt;/p&gt;
&lt;p&gt;For OCaml 5.2, we will try to seek other refactoring to the parser
that would make sense in the main parser while reducing ocamlformat
maintenance burden.&lt;/p&gt;


  </content><id>http://cambium.inria.fr/blog/florian-compiler-weekly-2023-04-17</id><title type="text">Florian's OCaml compiler weekly, 17 April 2023</title><updated>2023-04-17T08:00:00-00:00</updated><author><email>Florian Angeletti</email><name>gallium</name></author></entry><entry><link href="http://gallium.inria.fr/blog/florian-compiler-weekly-2023-04-11" rel="alternate"/><contributor><uri>http://gallium.inria.fr/blog/index.rss</uri><name>gallium</name></contributor><content type="html">

  &lt;p&gt;This series of blog post aims to give a short weekly glimpse into my
(Florian Angeletti) daily work on the OCaml compiler. This week, the
focus is on the newly tagged OCaml 5.1 branch.&lt;/p&gt;


  

&lt;h3&gt;A branch for OCaml 5.1&lt;/h3&gt;
&lt;p&gt;Last week, I have mostly worked on preparing the branching of OCaml
5.1. Before creating the new branch I try to check that there are no new
features that are really on the fence to be integrated and that there
are no bugs that would hinder the CI process on the new branch.&lt;/p&gt;
&lt;p&gt;For this new branch, it was the last point that was an unexpected
source of delays.&lt;/p&gt;
&lt;p&gt;Indeed, during a refactoring of the parsetree AST (Abstract syntax
tree) I had introduced a bug in ocamldep that was not caught by CI tests
for ocamldep itself. However, once I updated the bootstrapped compiler
when cutting the new branch, the bug surfaced when compiling the
dependency graph of the compiler itself.&lt;/p&gt;
&lt;p&gt;Consequently, I had to interrupt the publication of the new branch to
fix this issue in &lt;a href=&quot;https://github.com/ocaml/ocaml/pull/12164&quot;&gt;a
short pull request&lt;/a&gt;. The fix was merged last week, and I have
published the fixed OCaml 5.1 branch today.&lt;/p&gt;
&lt;h3&gt;Retrospective
on my work before OCaml 5.1 feature freeze&lt;/h3&gt;
&lt;p&gt;Now that we have a branch for OCaml 5.1, the branch will only receive
bug fixes until the final release in summer (probably in July?). It thus
seems a good time to reflect a bit on my work in this first half of
OCaml 5.1 release cycle. Beware however that new features can still be
released before the first beta of OCaml 5.1.0.&lt;/p&gt;
&lt;p&gt;Overall, I have reviewed 19 pull requests, written 9 pull requests
implementing new features, and 3 pull requests implementing bug
fixes.&lt;/p&gt;
&lt;p&gt;Overall, the merged pull requests should provide an incremental but
noticeable improvement to error messages which where the main theme of
most the pull requests that I reviewed or authored.&lt;/p&gt;
&lt;h4&gt;Reviewing pull requests&lt;/h4&gt;
&lt;p&gt;Looking at my reviewed pull requests, I have indeed reviewed 9 pull
requests improving error messages. Then with 4 reviews, the type system
was another area where my work was focused.&lt;/p&gt;
&lt;h5&gt;Error messages&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Most of the improvements for error messages made the messages
more explicit by trying to present more contextual information to the
user:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11530&quot;&gt;#11530&lt;/a&gt;:
Include kinds in kind mismatch error message. (Leonhard Markert, review
by Gabriel Scherer and Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11888&quot;&gt;#11888&lt;/a&gt;:
Improve the error message when type variables cannot be deduced from the
type parameters. (Stefan Muenzel, review by Florian Angeletti and
Gabriel Scherer)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12051&quot;&gt;#12051&lt;/a&gt;:
Improve the error messages when type variables cannot be generalized
(Stefan Muenzel, review by Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/10818&quot;&gt;#10818&lt;/a&gt;:
Preserve integer literal formatting in type hint. (Leonhard Markert,
review by Gabriel Scherer and Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Other pull requests improved the structure of the error messages
by making a better use of highlights and locations:&lt;/p&gt;
&lt;ol start=&quot;5&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11679&quot;&gt;#11679&lt;/a&gt;:
Improve the error message about too many arguments to a function (Jules
Aguillon, review by Gabriel Scherer and Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12116&quot;&gt;#12116&lt;/a&gt;:
Don&amp;rsquo;t suggest to insert a semicolon when the type is not unit (Jules
Aguillon, review by Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There were also two formatting improvements:&lt;/p&gt;
&lt;ol start=&quot;7&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11646&quot;&gt;#11646&lt;/a&gt;:
Add colors to error message hints. (Christiana Anthony, review by
Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12024&quot;&gt;#12024&lt;/a&gt;:
insert a blank line between separate compiler messages (Gabriel Scherer,
review by Florian Angeletti, report by David Wong)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finally, there was one improvement on the ability to
cross-reference the reference manual within error or warning
messages:&lt;/p&gt;
&lt;ol start=&quot;9&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12125&quot;&gt;#12125&lt;/a&gt;:
Add Misc.print_see_manual and modify &lt;span class=&quot;citation&quot; data-cites=&quot;manual_ref&quot;&gt;[@manual_ref]&lt;/span&gt; to accept lists for simpler
printing of manual references (Stefan Muenzel, review by Florian
Angeletti)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Type system&lt;/h5&gt;
&lt;p&gt;On the type system side, I have most reviewed internal refactoring
changes that are probably not that user visible (even when they remove
some bugs).&lt;/p&gt;
&lt;ol start=&quot;10&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/6941&quot;&gt;#6941&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11187&quot;&gt;#11187&lt;/a&gt;:
prohibit using classes through recursive modules inheriting or including
a class belonging to a mutually-recursive module would previous behave
incorrectly, and now results in a clean error. (Leo White, review by
Gabriel Scherer and Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11912&quot;&gt;#11912&lt;/a&gt;:
Refactoring handling of scoped type variables (Richard Eisenberg, review
by Gabriel Scherer and Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11569&quot;&gt;#11569&lt;/a&gt;:
Remove hash type encoding (Hyunggyu Jang, review by Gabriel Scherer and
Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11984&quot;&gt;#11984&lt;/a&gt;:
Add dedicated syntax for generative functor application. Previously,
OCaml did not disinguish between &lt;code&gt;F ()&lt;/code&gt; and
&lt;code&gt;F (struct end)&lt;/code&gt;, even though the latter looks applicative.
Instead, the decision between generative and applicative functor
application was made based on the type of &lt;code&gt;F&lt;/code&gt;. With this
patch, we now distinguish these two application forms; writing
&lt;code&gt;F (struct end)&lt;/code&gt; for a generative functor leads to new
warning 73. (Frederic Bour and Richard Eisenberg, review by Florian
Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Internal refactoring&lt;/h5&gt;
&lt;ol start=&quot;14&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11745&quot;&gt;#11745&lt;/a&gt;:
Debugger and toplevels: embed printer types rather than reading their
representations from topdirs.cmi at runtime]. (S&amp;eacute;bastien Hinderer,
review by Florian Angeletti, Nicol&amp;aacute;s Ojeda B&amp;auml;r and Gabriel Scherer)&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;CLI interface&lt;/h5&gt;
&lt;ol start=&quot;15&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11653&quot;&gt;#11653&lt;/a&gt;:
Add the -no-absname option to ocamlc, ocamlopt and ocamldep. (Abiola
Abdulsalam, review by S&amp;eacute;bastien Hinderer and Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11696&quot;&gt;#11696&lt;/a&gt;:
Add the -no-g option to ocamlc and ocamlopt. (Abiola Abdulsalam, review
by S&amp;eacute;bastien Hinderer, Nicol&amp;aacute;s Ojeda B&amp;auml;r and Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Standard library&lt;/h5&gt;
&lt;ol start=&quot;17&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11128&quot;&gt;#11128&lt;/a&gt;:
Add In_channel.isatty, Out_channel.isatty. (Nicol&amp;aacute;s Ojeda B&amp;auml;r, review by
Gabriel Scherer and Florian Angeletti)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12103&quot;&gt;#12103&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12104&quot;&gt;#12104&lt;/a&gt;: fix a
concurrency memory-safety bug in Buffer (Gabriel Scherer, review by
Florian Angeletti, report by Samuel Hym)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Documentation&lt;/h5&gt;
&lt;ol start=&quot;19&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11676&quot;&gt;#11676&lt;/a&gt;:
Fix missing since annotation in the &lt;code&gt;Sys&lt;/code&gt; and
&lt;code&gt;Format&lt;/code&gt; modules (Github user Bukolab99, review by Florian
Angeletti)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Authored feature pull
requests&lt;/h4&gt;
&lt;p&gt;As it is was the case before the OCaml 5.0 multicore freeze, my
personal contribution was focused on error messages during the last
month with 5 pull requests on this thematic for a total of 9 pull
requests.&lt;/p&gt;
&lt;h5&gt;Error messages&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;In particular, the new release will hopefully see an improvement
in the way that types are printed in error messages, both when
identifiers collide&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11286&quot;&gt;#11286&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11515&quot;&gt;#11515&lt;/a&gt;:
disambiguate identifiers by using how recently they have been bound in
the current environment (Florian Angeletti, review by Gabriel
Scherer)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11910&quot;&gt;#11910&lt;/a&gt;:
Simplify naming convention for shadowed or ephemeral identifiers in
error messages (eg:
&lt;code&gt;Illegal shadowing of included type t/2 by t&lt;/code&gt;) (Florian
Angeletti, review by Jules Aguillon)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;or when a weak row type variable rears its head:&lt;/p&gt;
&lt;ol start=&quot;3&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12107&quot;&gt;#12107&lt;/a&gt;:
use aliases to mark weak row variables: &lt;code&gt;_[&amp;lt; ... ]&lt;/code&gt;,
&lt;code&gt;&amp;lt; _..&amp;gt;&lt;/code&gt;, &lt;code&gt;_#ct&lt;/code&gt; are now rendered as
&lt;code&gt;[&amp;lt; ...] as '_weak1&lt;/code&gt; ,
&lt;code&gt;&amp;lt; .. &amp;gt; as '_weak1&lt;/code&gt;, and &lt;code&gt;#ct as '_weak1&lt;/code&gt;.
(Florian Angeletti, suggestion by Stefan Muenzel, review by Gabriel
Scherer)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I also implemented or participated to two relatively small
improvement on warnings:&lt;/p&gt;
&lt;ol start=&quot;4&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11235&quot;&gt;#11235&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11864&quot;&gt;#11864&lt;/a&gt;: usage
warnings for constructors and fields can now be disabled on
field-by-field or constructor-by-constructor basis (Florian Angeletti,
review by Gabriel Scherer)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/10931&quot;&gt;#10931&lt;/a&gt;:
Improve warning 14 (illegal backslash) with a better explanation of the
causes and how to fix it. (David Allsopp, Florian Angeletti, Lucas De
Angelis, Gabriel Scherer, review by Nicol&amp;aacute;s Ojeda B&amp;auml;r, Florian
Angeletti, David Allsopp and Gabriel Scherer)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;OCamldoc maintenance&lt;/h5&gt;
&lt;p&gt;I still keep maintaining ocamldoc in a minimal working state, but I
hope to switch to odoc for the manual in time for the release of OCaml
5.1 .&lt;/p&gt;
&lt;ol start=&quot;6&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11889&quot;&gt;#11889&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11978&quot;&gt;#11978&lt;/a&gt;:
ocamldoc: handle injectivity annotations and wildcards in type
parameters. (Florian Angeletti, report by Wiktor Kuchta, review by Jules
Aguillon)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12165&quot;&gt;#12165&lt;/a&gt;:
ocamldoc, use standard doctype to avoid quirk mode. (Florian Angeletti,
review by Gabriel Scherer)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Documentation&lt;/h5&gt;
&lt;ol start=&quot;8&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12028&quot;&gt;#12028&lt;/a&gt;:
Update format documentation to make it clearer that
&lt;code&gt;pp_print_newline&lt;/code&gt; flushes its newline (Florian Angeletti,
review by Gabriel Scherer)&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Internal refactoring&lt;/h5&gt;
&lt;ol start=&quot;9&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12119&quot;&gt;#12119&lt;/a&gt;:
mirror type constraints on value binding in the parsetree: the
constraint &lt;code&gt;typ&lt;/code&gt; in &lt;code&gt;let pat : typ = exp&lt;/code&gt; is now
directly stored in the value binding node in the parsetree. (Florian
Angeletti, review by Richard Eisenberg)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Authored bug fixes:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Least but not last, I have fixed two of my mistakes in previous
pull requests&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11450&quot;&gt;#11450&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12018&quot;&gt;#12018&lt;/a&gt;: Fix
erroneous functor error messages that were too eager to cast
&lt;code&gt;struct end&lt;/code&gt; functor arguments as unit modules in
&lt;code&gt;F(struct end)&lt;/code&gt;. (Florian Angetti, review by Gabriel
Scherer)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12061&quot;&gt;#12061&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/12063&quot;&gt;#12063&lt;/a&gt;: don&amp;rsquo;t
add inconsistent equalities when computing high-level error messages for
functor applications and inclusions. (Florian Angeletti, review by
Gabriel Scherer)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;and fixed what was maybe one of the fastest bug to trigger in
OCaml history&lt;/p&gt;
&lt;ol start=&quot;3&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ocaml/ocaml/issues/11824&quot;&gt;#11824&lt;/a&gt;:
Fix a crash when calling &lt;code&gt;ocamlrun -b&lt;/code&gt; (Florian Angeletti,
review by S&amp;eacute;bastien Hinderer)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;since the bug did not require any code source to trigger.&lt;/p&gt;


  </content><id>http://gallium.inria.fr/blog/florian-compiler-weekly-2023-04-11</id><title type="text">Florian's OCaml compiler weekly, 11 April 2023</title><updated>2023-04-11T08:00:00-00:00</updated><author><email>Florian Angeletti</email><name>gallium</name></author></entry></feed>