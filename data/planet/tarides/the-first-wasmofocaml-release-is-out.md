---
title: The First Wasm_of_ocaml Release is Out!
description: "Discover what's new with the release of Js_of_ocaml 6.0.1 \u2013 including
  Wasm support!"
url: https://tarides.com/blog/2025-02-19-the-first-wasm-of-ocaml-release-is-out
date: 2025-02-19T00:00:00-00:00
preview_image: https://tarides.com/blog/images/helloworld-1360w.webp
authors:
- Tarides
source:
---

<p>The first feature-complete release of <a href="https://github.com/ocaml-wasm/wasm_of_ocaml">Wasm_of_OCaml</a> (also known as WSOO) is out! A low-level virtual machine and portable compilation target, Wasm is popular with many developers thanks to its flexibility and wide compatibility.</p>
<p>We introduced you to Wasm and the benefits of bringing support for it to OCaml in our <a href="https://tarides.com/blog/2023-11-01-webassembly-support-for-ocaml-introducing-wasm-of-ocaml/">blog post on it in 2023</a>. Since then, Wasm_of_ocaml has undergone new developments, so let’s take a look at what’s new and give you an overview of the release.</p>
<h2>What is Wasm_of_ocaml?</h2>
<p>Let’s start with a quick recap. Wasm_of_ocaml is a fork of the popular <a href="https://github.com/ocsigen/js_of_ocaml">Js_of_ocaml</a> compiler, translating OCaml bytecode to <a href="https://webassembly.org/">WebAssembly</a>.  It is web-oriented and relies on a JavaScript environment, and is designed to be an alternative to Js_of_ocaml. Since WebAssembly provides a sandboxed environment and enforces memory safety it is well-suited for security-critical applications, such as blockchain applications and programs running in the cloud. We plan to target these environments in the future.</p>
<p>Wasm_of_ocaml builds on the WebAssembly garbage collection extension (WasmGC), which is available by default on Chrome, Safari, and Firefox. This design means we don’t need to reimplement a garbage collector, and - as an added benefit - gives us good interoperability with JavaScript. Js_of_ocaml translates OCaml bytecode to JavaScript and is a well-liked, industrial-strength compiler for running OCaml on the web. The goal of Wasm_of_ocaml’s development is to retain the strengths of Js_of_ocaml and offer feature parity and inter-compatibility between the two compilers. You can compile your programs with Wasm_of_ocaml instead of Js_of_ocaml (you may have to make a few adjustments) and experience overall better performance.</p>
<p>Because of its popularity and versatility, creating an OCaml to Wasm translator has been a big priority for the team, and they continue to improve and optimise Wasm_of_ocaml over time.</p>
<h2>What’s New?</h2>
<p>Over the past year, much work has been done to get Wasm_of_ocaml to release readiness. Some of the changes include:</p>
<ul>
<li><strong>Putting Wasm_of_ocaml into the same development repo as Js_of_ocaml</strong>: This was a natural step due to how much code the two tools share, considering Wasm_of_ocaml is a fork of Js_of_ocaml. However, the two have diverged since the former was forked away from Js_of_ocaml. To put them in the same repo required changes to bring them back in sync. This change was necessary for the first public release of Wasm_of_ocaml, and you can check out the work <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/135">in the associated PR</a>.</li>
<li><strong>Support for Wasm_of_ocaml in Dune</strong>: An important milestone on the road to the public release, this change allowed users to compile Wasm in Dune, making it much easier for existing OCaml projects to adopt the new tool. Wasm_of_ocaml support has been <a href="https://github.com/ocaml/dune/releases/tag/3.17.0">released in Dune 3.17.0</a>, which you can upgrade to if you haven’t already.</li>
<li><strong>Separate compilation</strong>: Support for separate compilation enables much faster compilation when building a program. There are two PRs: the <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/36">first PR brings the main update</a>, and the <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/43">second PR makes it more fine-grained</a> and avoids having to load too many modules.</li>
<li><strong>Sourcemap support</strong>: <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/27">PR #27</a> introduces support for source-level debugging of Wasm executables, implementing mapping between source and Wasm locations.</li>
<li><strong>Support the JS String Builtins Extension</strong>: <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/33">PR #33</a> change enables the use of JS string builtins when available for JS engines, which allows for more efficient operations on strings.</li>
<li><strong>Minimise the use of the unsafe JS command eval</strong>: The JS command <code>eval</code> is known for being unsafe, and <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/24">PR #24</a> creates an alternative workflow that minimises its use. Instead of using <code>eval</code>, strings can be emitted as external JavaScript fragments whenever the value of the string is known at compile time.</li>
<li><strong>Store long-lived top-level values into global variables</strong>: <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/30">PR #30</a> introduces a change where any variable that is used a number of instructions after being defined is stored as a global variable rather than a local variable. This change improves performance and reduces the compilation time of Wasm projects.</li>
<li><strong>Updates to make Wasm_of_ocaml compatible with OCaml 5.2 and 5.3</strong>: Two PRs, <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/54">#54</a> and <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/59">#59</a>, brought changes that made Wasm_of_ocaml compatible with OCaml: 5.2. For 5.3, <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/136">PR #136</a> included updates to make Wasm_of_ocaml compatible with the then latest OCaml update.</li>
<li><strong>Bugfixes</strong>: Let’s round off with some bug fixes! <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/22">PR #22</a> ensured that locals are always explicitly initialised before being used, <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/31">PR #31</a> fixed the spec-compliance of some emitted tuple instructions, and <a href="https://github.com/ocaml-wasm/wasm_of_ocaml/pull/46">PR #46</a> fixed a stack resizing bug in structural value comparison.</li>
</ul>
<p>These are just a subset of all the fixes and contributions, and I recommend that you explore the <a href="https://github.com/ocaml-wasm/wasm_of_ocaml">Wasm_of_ocaml repo</a> for a more complete picture.</p>
<h2>Benchmarks and Performance</h2>
<p>The team has run several benchmarks with exciting results. When comparing the performance of Wasm_of_ocaml to Js_of_ocaml and the native code of OCaml’s compiler <code>ocamlopt</code>, the results consistently show that programs compiled with Wasm_of_ocaml are faster than ones compiled with Js_of_ocaml (but two times slower than native code). This holds true not only for microbenchmarks but on macroscopic benchmarks as well. Even more impressively, Jane Street reports that they have observed 2x-8x performance improvements using Wasm_of_ocaml compared to Js_of_ocaml.</p>
<p>Another aspect of performance lies in casts and bound checks. Wasm_of_ocaml uses a generic representation of values, which means that, at run time, a number of casts might be required to ensure safety. Furthermore, due to the nature of the data representation the team has chosen, a bound check is required whenever a field of value is accessed. The team found that the Wasm_of_ocaml checks take up around 10% of the execution overtime on the V8 engine and 20% on the Bonsai benchmark. The goal is to keep improving performance by reducing the amount of needless casts.</p>
<p>Regarding file size, Wasm_of_ocaml output code takes up more space than Js_of_ocaml, which is likely due to Wasm being a lower-level language than JavaScript. For example, Wasm_of_ocaml has to generate explicit code to allocate closures and access the environment, both implicit in JavaScript.</p>
<p>If you’re curious to learn more about Wasm_of_ocaml’s benchmarks and performance, Jérôme Vouillon’s <a href="https://www.youtube.com/live/KLWiEf3x3kc?t=26981s">talk from the ML track at ICFP 2024</a> goes more in-depth.</p>
<h2>Release process, Plus a New Version of <code>js_of_ocaml</code></h2>
<p>From now on, wasm_of_ocaml and js_of_ocaml will be released jointly. For this reason, this first public release of wasm_of_ocaml is numbered 6.0.1 since it is synchronised with the release of js_of_ocaml 6.0.1.</p>
<p>A new and important feature of js_of_ocaml 6.0.0 is <em>double translation</em>, a way of making programs that use effect handlers faster. Effect handler support is realised by compiling some functions to Javascript code in continuation passing-style (CPS), which incurs a performance penalty. By passing <code>--effects=double-translation</code>, some functions are compiled in several versions, and the choice of which version of the function to run is made at run time. This improves performance at the cost of slightly larger Javascript bundles. More details are available on <a href="https://ocsigen.org/js_of_ocaml/latest/manual/effects">the effect handlers page</a> of the js_of_ocaml manual.</p>
<h2>Until Next Time</h2>
<p>If you try Wasm_of_ocaml yourself and have any feedback or questions, please see our post on <a href="https://discuss.ocaml.org">Discuss</a>. You can also create issues in <a href="https://github.com/ocaml-wasm/wasm_of_ocaml">the Wasm_of_ocaml repo</a> if you spot something that can be improved.</p>
<p>Connect with Tarides online on <a href="https://bsky.app/profile/tarides.com">Bluesky</a>, <a href="https://twitter.com/tarides_">X</a>, <a href="https://mastodon.social/@tarides">Mastodon</a>, <a href="https://www.threads.net/@taridesltd">Threads</a>, and <a href="https://www.linkedin.com/company/tarides">LinkedIn</a> or sign up for our mailing list to stay updated on our latest projects.</p>

