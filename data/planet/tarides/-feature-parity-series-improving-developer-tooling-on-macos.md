---
title: ' Feature Parity Series: Improving Developer Tooling on macOS'
description: Discover the work that went into improving OCaml debugging for macOS
  including frame pointers, CFI fixes and CI improvements.
url: https://tarides.com/blog/2025-06-18-feature-parity-series-improving-developer-tooling-on-macos
date: 2025-06-18T00:00:00-00:00
preview_image: https://tarides.com/blog/images/macos-blue-1360w.webp
authors:
- Tarides
source:
ignore:
---

<p>When considering which projects to focus on, our highest priority tends to be those that restore support for tools users rely on or introduce new tools that address a compelling problem. One of those tools is the <a href="https://lldb.llvm.org/">LLDB</a> debugger, which needed some attention after the OCaml 5 update.</p>
<p>LLDB is the primary supported debugger for macOS and comes included with <a href="https://developer.apple.com/xcode/">Xcode</a> as part of Apple's developer tools. It supports both the ARM64 and AMD64 platforms, which OCaml also supports. Ensuring a smooth macOS experience is crucial, as it enables development on the Apple hardware used in the community and by Tarides engineers. This post provides an overview of the work done to enhance the macOS debugging experience for OCaml developers.</p>
<h2>LLDB and Our Goals</h2>
<p>Let's begin with some context about the technology we're discussing today. Debuggers are tools used to trace, manipulate, and visualise the state of a target program running on a target system. Developers use debuggers for tasks like tracing a program's control flow, inspecting the values of variables during execution, halting the program at predetermined locations, and executing functions within the running process.</p>
<p>Why focus on LLDB? It is a well-maintained project that supports a wide range of platforms we target, including macOS, iOS, FreeBSD, Windows, and Linux. Most significantly, for OCaml, LLDB is the only supported choice for ARM64 MacOS (an important and popular developer platform) and comes included with XCode. This means that providing a debugging experience on macOS requires LLDB. Unfortunately, GDB, another well-known open-source debugger, is unavailable for ARM64 macOS.</p>
<p>Based on our usage, we recognised that LLDB needed some attention and initially raised issue <a href="https://github.com/ocaml/ocaml/issues/12933">#12933</a>, highlighting that setting breakpoints within LLDB was broken. Further investigation revealed other problems, such as printing backtraces producing incorrect results. Additionally, we saw the opportunity to integrate GDB features, such as printing OCaml values and running debugger tests within OCaml's test suite.</p>
<p>To make an impact with LLDB support, we focused on:</p>
<ul>
<li>Fixing how to create breakpoints in LLDB</li>
<li>Porting GDB's Python-based value printers to LLDB</li>
<li>Improving the debugging information emitted by the OCaml compiler</li>
</ul>
<h2>Breakpoints and Name Mangling</h2>
<p>Breakpoints are a common feature in debuggers; they allow developers to halt program execution when a specific piece of code is executed. LLDB provides several methods for creating breakpoints. Firstly, you can use a memory address, or secondly, you can specify the name of a function, or finally, use a combination of a filename and a line number. Happily, using memory addresses to create breakpoints worked, but the other two ways were broken.</p>
<p>To understand how LLDB can set a breakpoint using a function name, we must explain how the compiler treats source-level names in OCaml and how that impacts LLDB. In the OCaml compiler, there is a process called <code>name mangling</code>, which involves turning the name of a program entity in OCaml into a form that is unique and can be linked against. Often, there are repeated names for particular functions or even modules in an OCaml codebase, and the compiler needs to generate unique names for them before sending them all to the linker, which is responsible for producing the final executable as a <a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html">Mach-O</a> binary.</p>
<p>Concretely, when setting a breakpoint based on a function name, it is necessary to use the mangled name produced by OCaml. During OCaml 5 development (while fixing a linking bug), the name mangler was changed to generate names like <code>camlModule.function_name</code>. Let's illustrate how this works with an example, consider this Fibonacci program:</p>
<pre><code><span class="ocaml-comment-block">(*</span><span class="ocaml-comment-block"> fib.ml </span><span class="ocaml-comment-block">*)</span><span class="ocaml-source">
</span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-keyword">rec </span><span class="ocaml-entity-name-function-binding">fib</span><span class="ocaml-source"> </span><span class="ocaml-source">n</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source">
</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">if</span><span class="ocaml-source"> </span><span class="ocaml-source">n</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">0</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">then</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">0</span><span class="ocaml-source">
</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">else</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">if</span><span class="ocaml-source"> </span><span class="ocaml-source">n</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">1</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">then</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">1</span><span class="ocaml-source">
</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">else</span><span class="ocaml-source"> </span><span class="ocaml-source">fib</span><span class="ocaml-source"> </span><span class="ocaml-source">(</span><span class="ocaml-source">n</span><span class="ocaml-keyword-operator">-</span><span class="ocaml-constant-numeric-decimal-integer">1</span><span class="ocaml-source">)</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">+</span><span class="ocaml-source"> </span><span class="ocaml-source">fib</span><span class="ocaml-source"> </span><span class="ocaml-source">(</span><span class="ocaml-source">n</span><span class="ocaml-keyword-operator">-</span><span class="ocaml-constant-numeric-decimal-integer">2</span><span class="ocaml-source">)</span><span class="ocaml-source">
</span><span class="ocaml-source">
</span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">main</span><span class="ocaml-source"> </span><span class="ocaml-constant-language-unit">()</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source">
</span><span class="ocaml-source"> </span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">r</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-source">fib</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">20</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">in</span><span class="ocaml-source">
</span><span class="ocaml-source"> </span><span class="ocaml-constant-language-capital-identifier">Printf</span><span class="ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator">.</span><span class="ocaml-source">printf</span><span class="ocaml-source"> </span><span class="ocaml-string-quoted-double">"</span><span class="ocaml-string-quoted-double">fib(20) = </span><span class="ocaml-constant-character-printf">%d</span><span class="ocaml-string-quoted-double">"</span><span class="ocaml-source"> </span><span class="ocaml-source">r</span><span class="ocaml-source">
</span><span class="ocaml-source">
</span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">_</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-source">main</span><span class="ocaml-source"> </span><span class="ocaml-constant-language-unit">()</span><span class="ocaml-source">
</span></code></pre>
<p>The <code>main</code> function would get the name <code>camlFib.main_123</code>, and the <code>fib</code> function would be <code>camlFib.fib_271</code>; note that the trailing number can change between different runs of the compiler. These names are then used to create breakpoints within LLDB. Tab completion helps out, allowing you to specify part of the name and use tab to fill in the rest.</p>
<p>Unfortunately, using <code>.</code> in these names conflicted with LLDB, which used <code>.</code> for other purposes and wouldn't accept names with it present. Rather than modifying LLDB itself, we needed to alter the separator used in mangled names.</p>
<p>A one-character change seems simple, right? The other program that consumes these mangled names is called a <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linker</a>, and they have restrictions on what characters can be used in a name, often restricted to a printable subset of ASCII characters. This problem already appeared in the <a href="https://github.com/ocaml/ocaml/pull/12640">MSVC</a> porting work, where the linker on that platform wouldn't accept <code>.</code> either and a workaround was introduced to use <code>$</code> instead. That was the approach we decided to take, and we modified name mangling for all platforms to use <code>$</code>. More details about how this change impacts other areas are detailed in <a href="https://github.com/ocaml/ocaml/pull/13050">PR #13050</a>. This change will appear in OCaml 5.4, fixing the problem of setting breakpoints using mangled names and providing consistent names across platforms.</p>
<p>Setting breakpoints based on filename and line number was a more exciting experience, which we will cover in a later post.</p>
<h2>Printing OCaml Values Using Python</h2>
<p>OCaml uses a uniform memory representation in which all values can be kept in a single machine word, typically 64 bits on modern hardware. An OCaml value is either an immediate integer or a pointer to some other memory representing the value. This representation has implications for debuggers, as understanding how to print an OCaml value requires familiarity with this memory structure.</p>
<p>Both GDB and LLDB can be extended using Python as a scripting language. This capability enables developers to implement custom printing formats for values, add new commands, and perform various other useful functions. There were pre-existing macros for GDB for printing OCaml values, these could be rewritten into Python which would allow them to be used with both debuggers.</p>
<p>The resulting core <a href="https://github.com/ocaml/ocaml/blob/trunk/tools/ocaml.py"><code>ocaml.py</code></a> library understands OCaml's uniform memory representation and how to print out values. The GDB-specific file <a href="https://github.com/ocaml/ocaml/blob/trunk/tools/gdb.py"><code>gdb.py</code></a> handles integrating with GDB's value printer, and a similar <a href="https://github.com/ocaml/ocaml/blob/trunk/tools/lldb.py"><code>lldb.py</code></a> exists for LLDB. The previous GDB macro file was retained for backward compatibility, but now it prints a deprecated warning when used. Beyond the core printing functionality, the new system also introduces improved commands <code>ocaml</code> and <code>ocaml find</code>, the former of which is introduced with the <a href="https://github.com/ocaml/ocaml/pull/13136">PR #13136</a> and allows for future sub-commands, and the latter being the heap search command, which was changed from <code>gdb-macros</code>.</p>
<p>Check out <a href="https://github.com/ocaml/ocaml/pull/13136">PR #13136</a> for more details, including several examples of what formatting you can expect when working with the debuggers. The end result is a Python-based solution shared between the two debuggers that can be easily extended in future.</p>
<h2>Improving the Debugging Information</h2>
<p>Debugging information is any data that is required by the debugger to perform its task. Often, this is extra information outside of the main executable. For example, a debugger needs to associate machine code in an executable with the source code used to produce it. DWARF is one such debug information format used on macOS and Linux systems.</p>
<p>We identified two issues with the debug information produced by OCaml:</p>
<ol>
<li>Printing backtraces produced incorrect results</li>
<li>LLDB would not display the OCaml source for an executable</li>
</ol>
<p>A backtrace is a visual representation of the current call stack for a program. There are two ways a debugger generates a backtrace (a process called <code>unwinding</code>): Call Frame Information (CFI) or Frame Pointers. CFI is part of the larger DWARF specification and is already used in the OCaml compiler. Clearly, the team needed to start by understanding the CFI information emitted by the compiler and validating the fixes. What followed was a series of PRs improving CFI.</p>
<p>The first PR, <a href="https://github.com/ocaml/ocaml/pull/13079">#13079</a>, focused on fixing the backtraces for macOS on the ARM64 platform. Somewhere in the 5.1.1 update, a change happened to the CFI information OCaml produced that caused LLDB to lose part of the stack trace when moving between C and OCaml frames.</p>
<p>The bug was caused by the difference in handling frame pointers: C frames maintained them while OCaml frames did not. The OCaml code generator reused the <code>x29</code> frame pointer register in the <code>Iextcall</code> fast path when calling from OCaml to C. Once identified, the fix involved correctly saving the <code>x29</code> register, resulting in better backtraces for ARM64 on macOS, and Linux. <a href="https://github.com/ocaml/ocaml/pull/13595">#13595</a> is a follow-up bugfix for CFI-based backtraces, where the wrong CFA register was used. This part of the code was rewritten when adding frame pointer support for ARM64 on macOS and Linux <a href="https://github.com/ocaml/ocaml/pull/13500">#13500</a>. Speaking of frame pointers, <a href="https://github.com/ocaml/ocaml/pull/13163">#13163</a> enabled frame pointers on the other macOS platform, AMD64. Now, printing backtraces can use either CFI or frame pointers to unwind the call stack.</p>
<p>The issue of LLDB not displaying OCaml source code for an executable was due to missing DWARF information, which is necessary on macOS but not on other platforms. We understand how to fix it and are working on a solution. Interestingly, the same lack of DWARF information is why setting breakpoints based on filenames and line numbers is broken.</p>
<h2>Extras</h2>
<p>While working on CFI for ARM64, we found and fixed CFI issues on other platforms. In particular, Linux for ARM64 and Risc-V platforms. The three PRs, <a href="https://github.com/ocaml/ocaml/pull/13241">#13241</a>, <a href="https://github.com/ocaml/ocaml/pull/13261">#13261</a>, and <a href="https://github.com/ocaml/ocaml/pull/13271">#13271</a>, address incorrect Call Frame Information (CFI) for LLDB and GDB. These bugs highlighted the difficulty in ensuring the CFI information is correct and that debuggers work as expected. Although both GDB and LLDB use CFI, their interpretations of the specification sometimes differ, leading to subtle bugs.</p>
<p>To allow users to check their debugger's functionality and to help ensure that future changes don't break the debugging experience, the team enabled both the GDB and LLDB native debuggers to run as part of the OCaml test suite. Since both debuggers provide Python APIs to facilitate interaction between them and the test suite, programmers can write Python-scripted tests for their code. The PR <a href="https://github.com/ocaml/ocaml/pull/13199">#13199</a> has more details. Since merging this change, we have discovered a few bugs, such as <a href="https://github.com/ocaml/ocaml/issues/13509">#13509</a>. The idea of writing a debugger test suite in Python is so good that it is what <a href="https://github.com/llvm/llvm-project/tree/main/lldb/test/API">LLDB does</a>, so we are in good company!</p>
<p>Finally, we gathered all the details we discovered about OCaml debugging and added a chapter to the OCaml manual documenting what we learnt. PR <a href="https://github.com/ocaml/ocaml/pull/13747">#13737</a> does just that, covering more technical details that might be interesting.</p>
<h2>Until Next Time</h2>
<p>Let us know your experience with debugging OCaml 5 programs! You can always share your feedback or questions on <a href="https://discuss.ocaml.org">Discuss</a>. For more information on how to debug OCaml with LLDB, check out <a href="https://lambdafoo.com/posts/2024-08-03-lldb-ocaml.html">Tim McGilchrist's blog post</a>, which provides an excellent overview.</p>
<p>You can connect with us on <a href="https://bsky.app/profile/tarides.com">Bluesky</a>, <a href="https://mastodon.social/@tarides">Mastodon</a>, <a href="https://www.threads.net/@taridesltd">Threads</a>, and <a href="https://www.linkedin.com/company/tarides">LinkedIn</a> or sign up for our mailing list to stay updated on our latest projects. We look forward to hearing from you!</p>

