---
title: Porting Charrua-Unix and Rawlink to Eio
description: "This article describes the porting of the DHCP daemon charrua-unix and
  its companion library rawlink to Eio for the upcoming OCaml 5 release\u2026"
url: https://tarides.com/blog/2022-10-19-porting-charrua-unix-and-rawlink-to-eio
date: 2022-10-19T00:00:00-00:00
preview_image: https://tarides.com/static/674773ed3cc5b11161973c10d44bd4c5/dfe86/EioPic.jpg
authors:
- Tarides
source:
---

<p>This article describes the porting of the DHCP daemon <code>charrua-unix</code> and its companion library <code>rawlink</code> to <a href="https://github.com/ocaml-multicore/eio">Eio</a> for the upcoming OCaml 5 release. Before we get started, it makes sense to briefly describe what DHCP is and how we use it in production.</p>
<h1 style="position:relative;"><a href="https://tarides.com/feed.xml#what-is-dhcp" aria-label="what is dhcp permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is DHCP?</h1>
<p>DHCP stands for Dynamic Host Configuration Protocol, and it's described in <a href="https://www.rfc-editor.org/rfc/rfc2131.txt">RFC2131</a>, <a href="https://www.rfc-editor.org/rfc/rfc2132.txt">RFC2132</a>, and others. It was first published in 1993, so it's considerably old, yet very much alive in virtually every network these days&mdash;from your home, to your office, to your ISP Wide Area Network.</p>
<p>When your computer, laptop, phone, or any IP-connected device boots up or changes network, it requests network parameters via broadcast. These parameters are requested and answered via the DHCP protocol. The common/minimum parameters a client requests are:</p>
<ul>
<li>An IPv4 address</li>
<li>An IPv4 gateway</li>
<li>The address of a DNS resolver</li>
</ul>
<p>This is enough to get connectivity in most networks. DHCP can also provide many extra parameters, but they are outside of the scope of this document.</p>
<h1 style="position:relative;"><a href="https://tarides.com/feed.xml#what-is-charrua-dhcp" aria-label="what is charrua dhcp permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is <code>charrua-dhcp</code>?</h1>
<p><code>charrua-dhcp</code> is a DHCP library suite written in pure OCaml. You might not know it, but if you have ever used Docker Desktop, be it on Windows or macOS, you're a user of <code>charrua-dhcp</code> already !</p>
<p>In Docker Desktop, a complete Linux VM is run in the background in order to be able to run Docker containers. This VM needs to acquire network parameters from the host operating system, and this is done via <code>charrua-dhcp</code>. You can check more details on how OCaml and <code>charrua</code> are used to power Docker Desktop in <a href="https://www.docker.com/blog/how-docker-desktop-networking-works-under-the-hood/">this article</a>.</p>
<p><code>charrua-dhcp</code> is also the standard DHCP implementation used in <a href="https://mirageos.org/">Mirage OS</a>, both when used as a server or a client, and perhaps more importantly, it is used on high profile, critical cases, like the home network of yours truly. It is a stable and tested library that has been in use for years, and it has also been put to the challenge against <a href="https://github.com/stedolan/crowbar">Crowbar</a>. See more details in <a href="https://somerandomidiot.com/blog/2017/04/26/crowbar-dhcp/">this article</a> by Mindy Preston.</p>
<p><code>charrua-dhcp</code> is split into <code>charrua-core</code> and <code>charrua-unix</code>:</p>
<p><code>charrua-core</code> implements the DHCP server and client logic in pure OCaml, as well as providing serialisers and deserialisers for the protocol wire format. It also provides a textual configuration interface, like <a href="https://www.isc.org/dhcp/">ISC-DHCP</a> does.</p>
<p>When we say pure OCaml, we mean it! <code>charrua-core</code> is purely functional and doesn't produce anything via side-effects; therefore, it also does not perform any kind of I/O.</p>
<p><code>charrua-unix</code> implements the effect-full bits, and it does I/O, feeding incoming packets to <code>charrua-core</code> and sending out replies given by <code>charrua-core</code>.</p>
<p>The idea is that <code>charrua-core</code> has the complex DHCP logic, while <code>charrua-unix</code> does the basic things: logging, sending/receiving packets, making sure the environment is secure, and so on.</p>
<p>The name <code>charrua</code> is a reference to the seminomadic tribe Charr&uacute;a from what is today Uruguay, Argentina, and southern Brazil. The rationale is that DHCP serves parameters to roaming (nomadic) clients.</p>
<h1 style="position:relative;"><a href="https://tarides.com/feed.xml#what-is-rawlink" aria-label="what is rawlink permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is <code>rawlink</code>?</h1>
<p>DHCP is not an IP protocol. It sits above the Ethernet layer, which means a DHCP application must be able to craft and receive the full Ethernet packet, not just the layers above IP.</p>
<p>Each operating system provides a slightly different mechanism on how to accomplish this. Linux provides a special socket family called AF_SOCKET, whereas BSDs (OpenBSD, FreeBSD, macOS...) and most other Unix systems provide the same via BPF.</p>
<p><code>rawlink</code> is an OCaml library with C stubs that abstracts these differences away. You get a link on a network interface, which you use to craft and receive full Ethernet packets, bypassing most of the operating system network stack. In other words, <code>rawlink</code> allows you to work with <code>raw</code> packets on an Ethernet <code>link</code>.</p>
<p><span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; ">
      <a href="https://tarides.com/static/caca7d8be3e9041f4b48945ca49762f5/ab98c/charrua.png" class="gatsby-resp-image-link" style="display: block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom: 128.23529411764707%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsTAAALEwEAmpwYAAADRklEQVR42qWUaW/jNhCG/f//TfupRZEP22w2PpI4cWzH9xnbkmUd1k1K1LOgfGTdTbZIO8ALasjhg5FmNJXw9oa4USOuV/+fqt/YNx+oJHd1xOMDonn/k2TznuS+wfLqL3Y318gP4krdN/BbLSph9ZaoUSe+q5drdKefG2fpvX31G36tejj/QRdxtSpus0kl3FpEls12tsRbGwTmFne9xltvcFdrAlOf70qF2zfpOzpexxmTGYGxJbJdKhxNyoxcKebLV7q9PqPJlMF4QipkeV4UnK04OpPZnHa3R3KM0VYJw5A4ToiThDiK8VwPx3GJ45goisv1UhFJHBEEPp7nEYZBuXeIj6gkSUqhJNJ/QQUdpPdM4jxRhC9k+za59FEKlCrIZYw0n8jMFmrbLpVv2wdfhriuT0XodIuUYl8Hv4E9v8JeXKG8OuyrFNJ+e1URULzeol4b2J2rUtmiBqsapB6eH52AAuVVwa8hdl8Ru2sKr4rybn4CqsV1CU0mX0gnX1DLW4rlVxBHYCqEDqUQJqEzpEjXIDblWkqJN6DKKPzlQcErhCsCo4/aL6DI8PY+lTRNzxfSVJKrguJYVaWl1Lmq75lO6HTueftLYBSF9Ho9RqMR4/GI0WhIv9/Hdd3yXMOlFCS6omGIlLJUUaj3gXmekyQJek8riuPSV8UhayEltu0wGAzodDpl2+jsPszwn6bynCzLeGt+WX7vj+yXQJnDxklY7SLcGOxQYbgCN8w/RL4LPAXbQUZ3ldF5FTxOAlqzqPQHhkTm6j8A/YzeRvE8j7jtGDT6O/qbnKGRITP1+VcOEsXYlMysjKWjWNg5w03CysnL3/DTwFOb5Mei6AK5jkOSxGU3fAqoQXpy+P6+nCbadLWHw0O7+L5/Mcb+Faj3dEPPZzNm0xlCiMusP5uhNp2FyAWZHm15SpodJZPPAYtjne3QorV+pLV6pLl44GnZLP2e2SVT2a+A4jziDwPhALRCi7bxTG1Y5fe/f+PP+h88r1u8mF1EJsr+Ot15A/ofZ+glDl2zTW/b5cVo0zXavGy7jHZ98h8y1IU5DQnLsqnsdk5Jdt39hRzHY2OZZxmWydoyMHfWRZxtu0ync8bjKaPxlO9L0cNJXs7d6AAAAABJRU5ErkJggg=='); background-size: cover; display: block;"></span>
  <img src="https://tarides.com/static/caca7d8be3e9041f4b48945ca49762f5/c5bb3/charrua.png" class="gatsby-resp-image-image" alt="charrua" title="" srcset="/static/caca7d8be3e9041f4b48945ca49762f5/04472/charrua.png 170w,
/static/caca7d8be3e9041f4b48945ca49762f5/9f933/charrua.png 340w,
/static/caca7d8be3e9041f4b48945ca49762f5/c5bb3/charrua.png 680w,
/static/caca7d8be3e9041f4b48945ca49762f5/b12f7/charrua.png 1020w,
/static/caca7d8be3e9041f4b48945ca49762f5/b5a09/charrua.png 1360w,
/static/caca7d8be3e9041f4b48945ca49762f5/ab98c/charrua.png 2356w" sizes="(max-width: 680px) 100vw, 680px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h1 style="position:relative;"><a href="https://tarides.com/feed.xml#what-changes-in-ocaml-5" aria-label="what changes in ocaml 5 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What Changes in OCaml 5?</h1>
<p>OCaml 5 provides two main new features:</p>
<ul>
<li>Parallelism</li>
<li>Effect handlers</li>
</ul>
<p>Parallelism makes little sense on a slow, control protocol like DHCP, so we don't use it and it's not the focus of this article.</p>
<p>Effect handlers allow OCaml programs to write non-blocking code as <em>if</em> they were blocking.</p>
<p>Until OCaml 5 and effect handlers, the common way to write non-blocking code was through <a href="https://github.com/ocsigen/lwt">Lwt</a>, a concurrent programming library for OCaml. Lwt provides a concurrent scheduler and a monadic style of writing programs through promises. With it, the program becomes a long string of binding promises.</p>
<p>One issue with Lwt is that it's very &quot;infectious,&quot; and as soon as you add the first Lwt promise (called &quot;thread&quot; in Lwt lingo), the whole code must now behave as a promise as well. Another issue is that the monadic programming is somewhat syntax heavy, so it can clutter the code. Since the promises are allocations themselves, it can also negatively affect performance. Lwt is a great library, but with OCaml 5 and effects we can do better.</p>
<p>With OCaml 5 and effect handlers we can have the best of both worlds. We can write non-blocking code in a blocking style without the monadic clutter imposed by Lwt. The library we are proposing to replace Lwt in OCaml 5 is <a href="https://github.com/ocaml-multicore/eio">Eio</a>, which takes full advantage of the effect system, as well as providing a framework to express parallelism.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#lwt-vs-eio" aria-label="lwt vs eio permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lwt vs. Eio</h2>
<p>This code snippet is the main function of <code>charrua-unix</code>, using Eio (left) and Lwt (right). We can summarize what is happening as follows:</p>
<p>1 - We read a packet from the network.
2 - We feed the packet to <code>charrua-core</code>, which then gives us a possible <code>Reply (reply, db)</code>, the packet to be sent out and the new DHCP database state, respectively.
3 - We send the reply out and loop for more packets.</p>
<p>It's a fairly simple code, but it shows how much less cluttered the Eio version can be by removing all Lwt decorators. Another nice advantage is that if we were to write a blocking version of the same code, we would only need to change <code>Eio_rawlink.{read,write}_packet</code> to <code>Rawlink.{read,write}_packet</code> as their signatures remain the same, something impossible with Lwt.</p>
<p><span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; ">
      <a href="https://tarides.com/static/2a50353585ea9fc610d27062d645f482/9b29b/code_Eio.png" class="gatsby-resp-image-link" style="display: block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom: 28.235294117647058%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvklEQVR42m1Q0W6DMAwkCSRlpZSvKHFIKMR2gGj//10T0lhZN+nsB59Pd3bRxrWZculY9FH0WPTxBwaom7b6uUng8/yFjnIz549puwTWA0kgcXCV4xvm63NRQMpGBSTsmxizHlcdkhmT8VQ6lvDtLy3ecbuMaxWS9qgHUkC/xHVIxnPpUzmwsFFYFPYVvo1Li59VWIxH7Vk5PrPFXo9YPOa9/7mqmdc6sHQkARWgtCjOC/9/4ohtxmXP9WZ44AvH5y0zJGHlegAAAABJRU5ErkJggg=='); background-size: cover; display: block;"></span>
  <img src="https://tarides.com/static/2a50353585ea9fc610d27062d645f482/c5bb3/code_Eio.png" class="gatsby-resp-image-image" alt="code Eio" title="" srcset="/static/2a50353585ea9fc610d27062d645f482/04472/code_Eio.png 170w,
/static/2a50353585ea9fc610d27062d645f482/9f933/code_Eio.png 340w,
/static/2a50353585ea9fc610d27062d645f482/c5bb3/code_Eio.png 680w,
/static/2a50353585ea9fc610d27062d645f482/b12f7/code_Eio.png 1020w,
/static/2a50353585ea9fc610d27062d645f482/b5a09/code_Eio.png 1360w,
/static/2a50353585ea9fc610d27062d645f482/9b29b/code_Eio.png 3840w" sizes="(max-width: 680px) 100vw, 680px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#rawlink-and-eio-switches" aria-label="rawlink and eio switches permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>rawlink</code> and Eio Switches</h2>
<p><code>rawlink</code> uses a file descriptor that Eio knows nothing about, so in order for us to use Eio with it, we want to attach an <code>Eio.Flow.t</code> to the file descriptor. An <code>Eio.Flow.t</code> is an Eio abstraction of a bidirectional <code>socket</code>, even though it was designed mostly for a <code>STREAM</code>-like <code>socket</code> in mind, the semantics fit <code>rawlink</code> case. We do this in <code>Rawlink_eio.opensock</code>:</p>
<div class="gatsby-highlight" data-language="ocaml"><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> open_link <span class="token operator">?</span>filter <span class="token operator">?</span><span class="token punctuation">(</span>promisc<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span> ifname <span class="token label property">~sw</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> fd <span class="token operator">=</span> Rawlink_lowlevel<span class="token punctuation">.</span>opensock <span class="token operator">?</span>filter<span class="token punctuation">:</span>filter <span class="token label property">~promisc</span> ifname <span class="token keyword">in</span>
  <span class="token keyword">let</span> flow <span class="token operator">=</span> Eio_unix<span class="token punctuation">.</span>FD<span class="token punctuation">.</span>as_socket <span class="token label property">~sw</span> <span class="token label property">~close_unix</span><span class="token punctuation">:</span><span class="token boolean">true</span> fd <span class="token keyword">in</span>
  <span class="token punctuation">{</span> flow<span class="token punctuation">;</span> fd<span class="token punctuation">;</span> packets <span class="token operator">=</span> ref <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> buffer <span class="token operator">=</span> <span class="token punctuation">(</span>Cstruct<span class="token punctuation">.</span>create <span class="token number">65536</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre></div>
<p><code>Rawlink_lowlevel.opensock</code> is a call into the actual C stub that returns a BPF or AF_PACKET descriptor, we then create the <code>Eio.Flow.t</code> with <code>Eio_unix.FD.as_socket</code>.</p>
<p>Two things appear out of the ordinary in the flow creation call: The <code>sw (Eio.Switch.t)</code> and <code>close_unix</code> arguments, in order to make sense of them we have to understand what an <code>Eio.Switch.t</code> is.</p>
<p>A long standing issue with Lwt was &quot;how to make sure my file descriptors are not leaked if something goes wrong.&quot; Eio attempts to solve this by forcing each <code>Eio.Flow.t</code> to belong to a <code>Eio.Switch.t</code>. You can't create a <code>Eio.Flow.t</code> without giving it a <code>Eio.Switch.t</code>, so this is what the <code>Eio_unix.FD.as_socket</code> does. Since <code>Flows</code> are also attached to normal file descriptors, <code>Eio.Switch.t</code> also takes care of them.</p>
<p>An Eio program creates one or more <code>Eio.Switch.t</code> in order to attach a <code>Eio.Flow.t</code> to it. An <code>Eio.Switch.t</code> can also be nested, creating a tree-like structure, as every new <code>Eio.Switch.t</code> becomes a child of its parent <code>Eio.Switch.t</code>. When an <code>Eio.Switch.t</code> terminates, either succesfully or by some exception, all of its children <code>Eio.Flow.t</code> are also terminated, automatically closing the file descriptor and guaranteeing we don't have a descriptor leak.</p>
<p><code>close_unix</code> tells Eio to call <code>close(2)</code> when the <code>Eio.Switch.t</code> terminates.</p>
<p>Imagine a TCP server where each client has at least one dedicated <code>Eio.Switch.t</code>, and some of these clients create additional <code>Eio.Switch.t</code> to handle a specific unit of work:</p>
<p><span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; ">
      <a href="https://tarides.com/static/3d6e942b36d24d68b9c132d5d9720910/70d4c/switch.png" class="gatsby-resp-image-link" style="display: block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom: 102.94117647058825%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAClklEQVR42p1UiW7aQBDl/3+nbZBapVGSpgEalBRKuS9DbMDG13rvXb8Kc6QoQaEdabXSzOzTzJs3W8I7liMv7iBbob/sob/oYeQPkAlyFN9b6VzAaTTB1a8rlKtl1MY1rGJ/G8//EXBvRGRwQw/PgYtl7INL8Wbe2YAbU0ohy+iblf0XoLsW+DVNQLg5mXMScFOBMaY41hhIZfA4iFDphOjNElijX+LWvg+YUQpKKRhju0Phrhm6c4qFn4BzdogRQg4UnASklJ3gKd+d49x9lScB0zSFteYVFN7wbCrctH4EuNdbyhMMgwF+jp4w8PsISHCiSoArjkk4LnJ7iy68xPsLcNeen61QHVVwcf8JleE9xqvJSbGnIkXdqaNcucBt+wYdt4vSBsdYC6V1cVPB4CxnePZdTD0HEYkLvzYGWhts8vfUGmsQkhBu4BWbk9B0W2GSxMW0OBeQQkErDUYZpJCQUhV+ISQozcA5fyXsjGSwZjcUKnIMXQIutw5lJIhMMffniFkEqeXh4dynmHjJUfva5hh5BGuitoBtJ8Vda4XmMDhw+K1ziy/1z7htX2Oy4zBlFl8fJrisjRARfQCcrRi+t3w8dAMwoVByQ4nmhGLspkVCwhM0pk1Uf9fwNHqCFy4Kv9A5GsMI9Y4PQtUBMM40Wg5Dx0mhlN4MJQdlshCmFKLgLk0JGONI4rTYFrHjTRkLKV/vMeO6WM0jHRpj4a/j4i5aD2JovW1tFURQ2pz1gZT2Mh15Ger9CH4isQgFfvQizHyGkCg8DhL0njNoY098wi9bVNrqKcd9w8GH6xaa/SUafQ8fb9qoNh30nQDluy4uqwNkTO4kg/e/r0xYzHwOyiWUzjH3BeKUw9ocm8GtInZWy38AQodde6NKPlEAAAAASUVORK5CYII='); background-size: cover; display: block;"></span>
  <img src="https://tarides.com/static/3d6e942b36d24d68b9c132d5d9720910/c5bb3/switch.png" class="gatsby-resp-image-image" alt="switch" title="" srcset="/static/3d6e942b36d24d68b9c132d5d9720910/04472/switch.png 170w,
/static/3d6e942b36d24d68b9c132d5d9720910/9f933/switch.png 340w,
/static/3d6e942b36d24d68b9c132d5d9720910/c5bb3/switch.png 680w,
/static/3d6e942b36d24d68b9c132d5d9720910/b12f7/switch.png 1020w,
/static/3d6e942b36d24d68b9c132d5d9720910/b5a09/switch.png 1360w,
/static/3d6e942b36d24d68b9c132d5d9720910/70d4c/switch.png 2548w" sizes="(max-width: 680px) 100vw, 680px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#conclusion" aria-label="conclusion permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>Both Lwt and Eio provide means to achieve concurrency, but they only provide parallelism with <code>Domains</code>. Lwt uses monadic-style promises to achieve concurrency, which pollutes the code and makes it harder to reason about it. Eio makes full use of the new effect handlers and Domains of OCaml 5, providing concurrency and parallelism while maintaining the same programming style of synchronous blocking programs.</p>
<p>Eio is a library that aims to replace Lwt, but with a more modern style and feature set. It provides abstractions for sockets, fibers, streams, flows, and more.</p>
<p>To review,<code>charrua-unix</code> is a feature-packed, yet simple DHCP server implementation for Unix systems based on the OCaml library <code>charrua-core</code>.<code>rawlink</code> makes it possible to read and craft Ethernet packets on most Unix-like systems through an easy-to-use library.</p>
<p>It's relatively easy to port <code>rawlink</code> to Eio by attaching an Eio abstraction of a bidirectional socket, namely <code>Eio.Flow.t</code>, to the file descriptor.</p>
<p>We hope you enjoyed this article and found it helpful. As always, if there are any questions or concerns, feel free to <a href="https://tarides.com/company">reach out</a>.</p>
