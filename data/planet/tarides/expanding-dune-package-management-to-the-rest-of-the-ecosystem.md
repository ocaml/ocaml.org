---
title: Expanding Dune Package Management to the Rest of the Ecosystem
description: Explanation of our learnings from attempting to build all Dune packages
  in opam-repository using Dune package management.
url: https://tarides.com/blog/2025-04-11-expanding-dune-package-management-to-the-rest-of-the-ecosystem
date: 2025-04-11T00:00:00-00:00
preview_image: https://tarides.com/blog/images/dunepkgmain-1360w.webp
authors:
- Tarides
source:
---

<p>Since we published <a href="https://preview.dune.build">The Dune Developer Preview</a> a lot of things have improved on the package management front. While the developer preview has demonstrated how Dune can manage dependencies in a unified workflow, we have been working on making it practical for more projects to adopt Dune to handle their package dependencies. Our goal is to slowly move from a developer preview to a mature feature that the general public can use and rely on.</p>
<p>What do we mean by maturation? The goal is fuzzy (as with every software, it is never 'done'), but we want to get Dune package management into a shape where we can consistently recommend that people use it for their projects.&nbsp; They should be confident that their workflows will continue to work while unlocking the new features that <a href="https://dune.readthedocs.io/en/stable/tutorials/dune-package-management/dependencies.html">Dune package management</a> brings.</p>
<p>The core points of this are:</p>
<ul>
<li>The OCaml Platform Tools should work at least as well with Dune package management as they work with <code>opam</code>. With the new features in Dune, this interoperability should work even better as users do not have to share dependencies with the project in the local switch since tools can be installed automatically, possibly even from precompiled binaries. Do you want MDX? Declare a dependency, and voila, you have MDX.</li>
<li>Most projects can start using Dune with little to no adjustments. The majority will work out of the box, and the most frequent fix required is to correct the list of project dependencies. No substantial code changes are necessary, and all projects should continue to be compatible with both <code>opam</code> and <code>dune</code>; there is no lock-in to one tool or the other.</li>
</ul>
<p>Our goal is to successfully build as many projects as possible using Dune's package management feature. But to evaluate what we have left to do, we need to know where we stand now. This blog post will give you an overview of the project's scope and biggest challenges.&nbsp;</p>
<h2>Building "All" Packages</h2>
<p>What if we want to try to build all the existing OCaml packages? Opam-repository to the rescue! While it might not include proprietary code bases, there are still a significant number of projects we can try to build with it. Fortunately, there has already been prior work done on this subject. <a href="https://github.com/ocurrent/opam-health-check/">Opam-health-check</a> is an existing tool mostly written by <a href="https://github.com/kit-ty-kate">Kate</a> that can determine whether packages can be installed on different historical, current, and future OCaml versions. It continuously monitors the state of the opam ecosystem, which inspired its name.</p>
<p>Tarides is running and maintaining multiple <code>opam-health-check</code> instances for the community. The most well-known is <a href="https://check.ci.ocaml.org">check.ci.ocaml.org</a> which regularly builds thousands of <code>opam</code> packages on Linux, <a href="https://freebsd.check.ci.dev">freebsd.check.ci.dev</a> which does the same thing but on FreeBSD, and <a href="https://windows.check.ci.dev">windows.check.ci.dev</a> which as the name implies builds packages on Windows to help us with the effort to deliver a better OCaml experience on Windows.</p>
<p>We were wondering whether we could use the tool when building with Dune instead of <code>opam</code>. Fortunately, the software is free, so we could extend the functionality to build Dune projects instead of installing opam packages. This gave rise to the next instance of opam-health-check, <a href="https://dune.check.ci.dev">dune.check.ci.dev</a> which, instead of using <code>opam</code>, builds them using Dune package management.</p>
<h3>Which Packages are we Building, Actually?</h3>
<p>Wer misst, misst Mist. â€“ German proverb</p>
<p>Opam takes its installation instructions from the <code>opam</code> metadata files that are collected in <code>opam</code> repositories like <a href="https://github.com/ocaml/opam-repository">opam-repository</a>. This is how the regular <code>opam</code> health check works, it selects (nearly all) packages, and attempts to build them.</p>
<p>However, only projects that already use Dune to build can use package management. This happens because, when building a project, you need to know which dependencies to build, where these dependencies get built and installed, and which paths to pass to the compiler so it can find the modules that the dependencies install. Unlike in <code>opam</code>, the packages don't get installed into a location containing all installed libraries (a switch), but into separate directories that will be composed together when building.</p>
<p>That means we need to be a bit more selective about which packages we are going to pick for testing. Picking projects that don't use Dune will fail in 100% of the cases and will not let us draw useful conclusions besides telling us that you need Dune projects to use Dune package management, which we already know.&nbsp;</p>
<p>So, when determining which packages we want to include as our candidates, we need to filter the list of packages to ones that use Dune. The <code>opam-health-check</code> tool expects to call a shell command to generate the list. However, the process of determining which packages count as 'are using Dune' is more complicated, since the best way to determine that would be to detect whether <code>dune build</code> is used in a package and whether the package depends on the <code>dune</code> package.</p>
<p>It's a bit fuzzy, but we decided to only include packages that depend on the 'dune' package. This leaves us with a few false positives (e.g. packages that don't support the most recent versions of Dune) and also some false negatives (packages that accidentally capture a 'dune' dependency through their own dependencies), so this will probably need a bit of revision in the future, but for now, it should be good enough.</p>
<h3>What About the Rest?</h3>
<p>There are a significant number of projects using Dune and this is far from all of them. While we can't build them directly because every build system works differently, all <code>opam</code> packages can be used as dependencies and should <em>just work</em>.</p>
<p>How do we know this? We run different kinds of tests before using an internal tool that is quite similar but less sophisticated than <code>opam-health-check</code>. In a previous run on OCaml 4.14, we tested using an <code>opam</code> package as a dependency, attempting to build a project, and then checking the results. For that test, we selected 2505 <code>opam</code> packages (since they were compatible with 4.14, <code>opam install</code> could find a solution) and ran it over a few days. Ultimately, we only had 36 failures; thus, our success rate was a whopping 98%! This means that users can safely start using Dune for package management in their projects as the overwhelming majority of dependencies are compatible.</p>
<h2>What is Building a Package, Really?</h2>
<p>The biggest challenge is that much of the package metadata in the source archives is incorrect. As a result, <code>dune pkg lock</code> almost certainly picks invalid versions of dependencies. Why is that?</p>
<h3>Dependencies Galore</h3>
<p>Opam installs packages by inspecting the files in its own metadata repository, <code>opam-repository</code>. This repository is created by authors submitting their packages on release, and from there on, it is maintained by the <code>opam-repository</code> maintainers. They will make sure to add dependencies that have been accidentally left out or adjust when new, incompatible versions of dependencies get published. Older package definitions will be updated to include upper version constraints.</p>
<p>However, if we check out a repository via git or download the source archive and try to build it with Dune, we don't have all these updates. Without them, many packages will fail to build (be it with opam or Dune).</p>
<p>These issues can often be fixed very easily by the author of the package, and having Dune fail to build packages due to invalid dependencies is very disappointing. If the dependencies were to be fixed, the project would either work just fine with Dune package management (success, hooray!) or at least fail with a more interesting error. Marking it as a dependency failure does us a disservice by hiding potential errors.</p>
<p>Our hack to test for Dune package management compatibility rather than accurate dependency declarations was to replace the dependencies from the source archive with information from <code>opam-repository</code>. This was a two-step process:</p>
<ol>
<li>Overwriting the <code>opam</code> files with the opam files from <code>opam-repository</code>.</li>
<li>Removing the dependency information from <code>dune-project</code> because Dune prioritises the information in this file by default.</li>
</ol>
<p>Step two had an additional challenge as the <code>dune-project</code> file is in S-expression syntax, but the usual helpful processing tools like <code>jq</code> do not support S-expressions. So, we used Jane Street's <a href="https://github.com/janestreet/sexp">sexp</a> tool to do the processing, along with a generous helping of common Unix shell tools.</p>
<p>This is not to say that users should be migrating their dependency specifications out of <code>dune-project</code> (they shouldn't), but for our automated processing it was easier to take the updated opam files and use them as-is, instead of migrating them back into the <code>dune-project</code> syntax.</p>
<h3>What is a Package, Actually?</h3>
<p>When <code>opam</code> builds a package that uses Dune, it usually calls <code>dune build -p &lt;package-name&gt;</code>, which makes Dune ignore everything in the source repository that is not attached to the package name. However, it doesn't work for the health check, as you want all projects in the source archive to be built, not just the current one that is to be tested. But you also don't want to build every package from the source archive, as that might introduce additional dependencies and unrelated failures. Likewise, you don't want to build code that is not part of any package (e.g. examples, benchmark, utilities).</p>
<p>In the end, we solve it by determining the internal dependencies of the project to be built and then collecting these dependencies. We start the build by calling <code>dune build --only-packages &lt;packages-discovered&gt;</code> to restrict the build to only these packages.</p>
<h2>Ok, Ok, but Show Me the Results!</h2>
<p><img src="https://tarides.com/blog/images/dunepkgscreen-1360w~CIZK07raZiNDJPM-1kezpw.webp" sizes="(min-width: 1360px) 1360px, (min-width: 680px) 680px, 100vw" srcset="/blog/images/dunepkgscreen-170w~1TZEWWngxwWZsoqI6dxswg.webp 170w, /blog/images/dunepkgscreen-340w~g14Dv1h3bLnE2yJArixSZA.webp 340w, /blog/images/dunepkgscreen-680w~PUjt3ohsCeVZPn7jMJWw0A.webp 680w, /blog/images/dunepkgscreen-1360w~CIZK07raZiNDJPM-1kezpw.webp 1360w" alt="Output of a run of opam-health-check building Dune packages, ordered by amount of reverse dependencies"></p>
<p>The output of these runs is published on <a href="https://dune.check.ci.dev/">dune.check.ci.dev</a>, where we build the candidate packages on Linux amd64 using the <a href="https://preview.dune.build/">Dune developer preview binaries</a>. We chose this platform because it will give us the biggest set of candidates since most packages are developed on systems similar to it. On the website, you can see all the packages we selected and the result of the build. At the time of writing we have selected 2243 packages to build and 1866 have completed the build successfully, which means that, at the time of writing, we have an 83% success rate in building projects directly! For the remaining 377 packages, the failures can be seen when clicking the entries since <code>opam-health-check</code> keeps logs of all the builds. It is our main tool to determine which issues to tackle next. So as we go forward we expect the success rate to rise to match <code>opam</code> as closely as possible!</p>
<h2>Where Do We Go From Here?</h2>
<p>Now that we have <code>opam-health-check</code> running and reporting build successes and failures, we can look into the build issues that it has revealed. A lot of them were small stumbling blocks which could have nevertheless been blockers to adoption:</p>
<ul>
<li>The potentially simplest issue arose from the Dune not supporting packages distributed in ZIP archives. Due to OCaml's strong origins on Unix, most packages are distributed as compressed tarballs (often <code>gzip</code> or <code>bzip2</code> compressed). However, especially on Windows, the ZIP format is more popular and is also supported in <code>opam</code>. In <a href="https://github.com/ocaml/dune/pull/11511">#11511</a>, we added Dune support for uncompressing ZIP files. We usually call programs to decompress the data to avoid shipping implementations of compression algorithms. However, to use these programs, they need to be available, and what is available depends on the platform. The simplest command to call is <code>unzip</code> from the Info-ZIP project. Still, on some platforms, the <code>tar</code> command also supports decompressing ZIP files as if they were tarballs, so we're trying to use whatever the user might have available.</li>
<li>When pinning a package, we assume it uses Dune. This works most of the time because a significant number of packages use Dune to build, but if a package does not, we will have to build and install it using the commands that it declares in its <code>opam</code> file. <a href="https://github.com/ocaml/dune/pull/11513">#11513</a> does just that. It extracts the commands when pinned and uses them when the pinned package needs to be built.</li>
<li>A somewhat obscure semantic of the way dependencies and conflicts are represented in <code>opam</code> files is that packages which are dependencies are implicitly conjunctions (depending on <code>foo</code>, <code>bar</code> means depending on <code>foo</code> AND <code>bar</code>); however, for conflicts, they are implicitly disjunctions (conflicting with <code>foo</code> and <code>bar</code> means to conflict with <code>foo</code> OR <code>bar</code>). This makes a lot of sense intuitively but is easily forgotten. Dune used to accept a conflict only if all packages were conflicting, and this behaviour flew under the radar for a long time because conflicts are rare. Most of the time, the conflict is only a single package, in which case it doesn't make a difference. This was fixed in&nbsp; <a href="https://github.com/ocaml/dune/pull/11515">#11515</a>, which also simplified the code.</li>
<li>When solving a project's dependencies, the solver has to go through all of them and find a solution that satisfies all constraints, or it will display an error. These constraints are usually declared in your <code>dune-project</code> or <code>.opam</code> files, but when using Dune package management, there is an additional constraint: the solution needs to be buildable with the currently running version of Dune. Unfortunately, in such a case, the solver would crash. In <a href="https://github.com/ocaml/dune/pull/11554">#11554</a>, we solved the issue to some degree: instead of crashing, the solver will display an error message, which will hopefully make it clearer why it can't find a solution.</li>
<li>Opam has a little-known but very useful feature when declaring package dependencies. Instead of depending on a specific version, the user can use the current version of the package as a variable. This allows projects that consist of multiple packages to depend on each other without having to update all dependencies on every release (an example of this is <code>ocaml-zmq</code>, which comes with <code>async</code> and <code>lwt</code> variants which depend on a common core). However, these constraints don't matter much when building the packages, so we always set the version to <code>dev</code>. Unfortunately, this can cause subtle issues where no solution can be found, so in&nbsp; <a href="https://github.com/ocaml/dune/pull/11517">#11517</a>, the code was changed to attempt to read the <code>version</code> fields to populate the variable with the value the user declared.</li>
<li>At the moment, Dune handles the compiler in a special way. When attempting to build the compiler, instead of building it in the project, it will build it in a separate location in the user's home directory. This is due to the fact that the compiler can't be moved to a different location at the moment (work is underway to improve the situation - that effort is called "relocatable OCaml"). How OCaml 5.3.0 is packaged in <code>opam-repository</code> changed and introduced a new transitive dependency for the compiler. Thus, the code would not be able to properly detect which <code>opam</code> package is the compiler. This was fixed in <a href="https://github.com/ocaml/dune/pull/11310">#11310</a> by computing the dependency cone of all possible compiler packages that are currently used to detect which package contains the compiler.</li>
<li>Opam has a way to mark a package as 'do not pick this package unless requested explicitly' - <code>avoid-version</code>. This is, for example, used to mark beta versions of packages that can be installed manually but should not be automatically picked. The solver in Dune does not have such a feature, so originally, Dune sorted these packages to the end of the candidate list, but it would not match the semantics of <code>opam</code>. Dune would then interpret them as forbidden dependencies. However, some older packages failed to build without access to these dependencies, so <a href="https://github.com/ocaml/dune/pull/11494">#11494</a> was implemented where, instead of failing, the solver tries to minimise the number of dependencies picked that have the <code>avoid-version</code> flag.</li>
<li>Findlib, the tool whose package specification format is prevalent in the OCaml ecosystem and is also used by Dune, has a feature where parts of packages are installed in subdirectories. These subdirectories can also be optional when certain package features are enabled or disabled during building. It is a rare feature, but some real-world packages use it. Unfortunately, Dune would always assume that these directories existed if they were declared and try to read their contents. But if the directory does not exist (e.g. the feature is disabled), this would lead to a crash. The fix in <a href="https://github.com/ocaml/dune/pull/11569">#11569</a> is short and shows that all bugs are shallow if enough eyes inspect the code.</li>
</ul>
<p>Fixing these issues has gotten us to an (at the time of writing) 83% success rate in building projects according to <code>opam-heath-check</code>. That's a pretty good result and makes us confident that the package management feature is on the right track.</p>
<p>The issues above, as well as future issues related to package coverage and their status, are collected in a <a href="https://github.com/ocaml/dune/issues/11601">tracking issue</a> on the Dune bug tracker.</p>
<h2>How You Can Help</h2>
<p>If you want to take part in improving our OCaml ecosystem to have a simple, one-stop-shop for building and installing packages check out <a href="https://preview.dune.build/">the nightly developer preview</a> and try it with your projects. The team is looking for feedback on how they can improve Dune package management, so please share your thoughts on <a href="https://discuss.ocaml.org">Discuss</a>, and report any issues on <a href="https://github.com/ocaml/dune/issues">GitHub</a>!</p>
<p>Stay in touch with us on <a href="https://bsky.app/profile/tarides.com">Bluesky</a>, <a href="https://mastodon.social/@tarides">Mastodon</a>, <a href="https://www.threads.net/@taridesltd">Threads</a>, and <a href="https://www.linkedin.com/company/tarides">LinkedIn</a>. We look forward to hearing from you!</p>

