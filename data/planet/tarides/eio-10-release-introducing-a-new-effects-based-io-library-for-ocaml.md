---
title: 'Eio 1.0 Release: Introducing a new Effects-Based I/O Library for OCaml'
description: "The OCaml 5 update brought much-anticipated support for programming
  on multiple cores. It also introduced support for concurrency via effect\u2026"
url: https://tarides.com/blog/2024-03-20-eio-1-0-release-introducing-a-new-effects-based-i-o-library-for-ocaml
date: 2024-03-20T00:00:00-00:00
preview_image: https://tarides.com/static/96c10d8b128f4298bb84a3dbe343ead3/0132d/eio-port.jpg
featured:
authors:
- Tarides
source:
---

<p>The OCaml 5 update brought much-anticipated support for programming on multiple cores. It also introduced support for concurrency via effect handlers &ndash; one of the first mainstream languages to do so. This significant update has had <a href="https://tarides.com/blog/2023-07-07-making-ocaml-5-succeed-for-developers-and-organisations/">profound performance and UX implications</a>, propelling OCaml into new areas of software development. At the core of this leap forward is the ambition to craft a modern, direct-style I/O stack that seamlessly interfaces with the latest kernel I/O advancements, such as <a href="https://unixism.net/loti/what_is_io_uring.html">io_uring</a>. This is where <a href="https://github.com/ocaml-multicore/eio">Eio</a> comes in.</p>
<p>When we started work on the I/O stack there was no previous ecosystem to build upon, and we had to break new ground for everything (threading, scheduling, and so on). As users started to port large applications to Eio - such as <a href="https://routine.co">Routine</a>, <a href="https://github.com/talex5/ocaml-wayland">ocaml-wayland</a> or <a href="https://irmin.io">Irmin</a> - we learnt a lot. We received many suggestions for how to improve various aspects of the I/O project, especially on how to write large-scale applications combining effect-handlers. This feedback loop accelerated the ecosystem's evolution and led to new research and community insights, such as those discussed in <a href="https://kcsrk.info/papers/compose_ocaml22.pdf">&quot;Composing Schedulers using Effect Handlers&quot;</a>, and experiments with lightweight effect-based concurrency models like <a href="https://github.com/ocaml-multicore/picos">Picos</a>. Today, Eio has matured to a point where it is the first &quot;feature complete&quot; direct-style effects library, and we are calling this version 1.0.</p>
<p><em>But this is just the start of our shared journey to figure out what the effects story is</em>! There will be plenty of iterations as we go through future releases, and we look forward to continuing the community-driven exploration. If you're looking to get stuck in with Eio immediately, we recommend <a href="https://github.com/ocaml-multicore/eio/blob/v1.0/README.md">exploring its documentation on OCaml.org</a>, including installation instructions. If, however, you want to know more about the context and features of the I/O stack, this post has you covered. We will guide you through the motivations and history behind Eio as well as some of its most prominent features.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#why-eio" aria-label="why eio permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why Eio?</h2>
<p>Eio provides an effects-based direct-style I/O stack for OCaml 5. You can use Eio to read and write files, make network connections, or perform CPU-intensive calculations running multiple operations simultaneously. After much hard work and optimisations, the <a href="https://ocaml.org/p/eio_main/1.0">first full release of Eio 1.0</a> is now publicly available. This release focuses on two main areas:</p>
<ul>
<li><strong>Performance:</strong></li>
</ul>
<p>Eio 1.0 capitalises on newer kernel I/O interfaces for enhanced parallelism efficiency. It features <a href="https://github.com/ocaml-multicore/eio/tree/main/lib_eio_posix">Eio_posix</a> for broad platform compatibility, whilst also targeting optimal support for various modern (and often incompatible) kernel interfaces. Notably, Eio 1.0 introduces an <code>io_uring</code> backend for Linux and a specialised <a href="https://github.com/ocaml-multicore/eio_js">Eio_js</a> scheduler for JavaScript platforms. Moreover, we developed prototype backends for extensive support across systems: aiming to accommodate <a href="https://github.com/patricoferris/eio/tree/apple-gcd/lib_eio_gcd">Grand Central Dispatch</a> on macOS, <a href="https://github.com/ocaml-multicore/eio/issues/125">IOCP</a> on Windows, <a href="https://github.com/patricoferris/eio/tree/kqueue/lib_eio_kqueue">kqueue</a> on BSD*, and <a href="https://github.com/TheLortex/eio-solo5">Solo5</a> for MirageOS, demonstrating our confidence in the API's versatility for future adaptations.</p>
<ul>
<li><strong>Security:</strong></li>
</ul>
<p>First, to improve safety, some parts of Eio have been <a href="https://github.com/ocaml-multicore/eio/blob/main/HACKING.md#formal-verification">formally verified</a>. Second, the landscape of containment approaches across macOS, Windows, Linux, BSD, as well as within hypervisors, containers, and WebAssembly (Wasm), has diversified significantly necessitating new strategies that ensure portability. Eio addresses this with distinct interfaces: a &quot;low-level&quot; interface tailored to each supported system, which offers the best platform-specific control but isn't portable, and a &quot;high-level&quot; portable interface designed for applications, which prioritises security by not exposing ambient resources. Instead, it provides an <a href="https://roscidus.com/blog/blog/2023/04/26/lambda-capabilities">interface that grants capabilities</a>, facilitating a secure and controlled environment for application development (further details below). These capabilites can also be enforced at runtime: for instance, Eio 1.0 comes with <a href="https://ocaml-multicore.github.io/eio/eio/Eio_unix/Cap/index.html"><code>capsicum</code></a> support on systems that provide the <code>cap_enter</code> system call (FreeBSD). This is similar to Rust's <a href="https://github.com/bytecodealliance/cap-std/tree/main/cap-std"><code>cap-std</code></a> (and to a lesser extent to Scala 3's <a href="https://dotty.epfl.ch/docs/reference/experimental/canthrow.html#from-effects-to-capabilities-1">checked effects</a>).</p>
<p>As an important side note, the compiler itself remains unopinionated about the user's choice of scheduling policies. While you may want to use Eio to benefit from its features, you do not <em>have</em> to use Eio with OCaml 5.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#the-improvements-coming-with-eio" aria-label="the improvements coming with eio permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Improvements Coming With Eio</h2>
<p>What makes Eio different from its predecessors? The Unix library, which uses blocking I/O operations, provided the previous I/O stack for OCaml. Blocking operations are not well suited for concurrent programming and hence with OCaml 4.*, two libraries provide this support instead: <a href="https://dev.realworldocaml.org/concurrent-programming.html">Async</a> and <a href="https://ocsigen.org/lwt/latest/manual/manual">Lwt</a>, which both have a monadic interface. These libraries let the developer write code as if there are multiple threads of execution running, each with their own stack, where the stacks are simulated using the heap. However, these libraries require the developer to <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">use non-concurrent and concurrent code in different ways</a>, modifying the style in which they write their code depending on the context. Doing so causes extra work while reading and writing code. Eio uses effect handlers instead which enable users to write their code in a natural direct style (as opposed to the callback-oriented style), while still benefiting from performant asynchronous I/O.</p>
<h3 style="position:relative;"><a href="https://tarides.com/feed.xml#effects" aria-label="effects permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Effects</h3>
<p>OCaml 5 added support for effects, removing the need for monadic code in the I/O stack and making an effects-based I/O stack like Eio possible. The <a href="https://v2.ocaml.org/manual/effects.html">OCaml Manual</a> describes effect handlers as follows: &quot;Effect handlers are a mechanism for modular programming with user-defined effects. Effect handlers allow the programmers to describe <em>computations</em> that <em>perform</em> effectful <em>operations</em>, whose meaning is described by <em>handlers</em> that enclose the computations.&quot;</p>
<p>Using effect handlers has several advantages:</p>
<ol>
<li><strong>Speed</strong>: Using effects speeds up the code since no heap allocations are needed to simulate a stack.</li>
<li><strong>Ease-of-use</strong>: Developers can write concurrent code in the same style as plain non-concurrent code.</li>
<li><strong>Language Features</strong>: Developers can now use OCaml language features like <code>try ... with</code> in their concurrent code.</li>
</ol>
<p>In addition to these benefits from effects, having an effects-based I/O stack lets users take advantage of some additional features of modern operating systems. Many modern operating systems provide high-performance alternatives to the traditional Unix <code>select</code> call. For example, Linux's alternative <code>io_uring</code> has applications that write the operations they want to perform to a ring buffer, which can then handle those operations asynchronously, something Eio can take advantage of.</p>
<h3 style="position:relative;"><a href="https://tarides.com/feed.xml#eio-10-features" aria-label="eio 10 features permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Eio 1.0 Features</h3>
<p>Let's take a look at some of Eio's main features. If you want to discover more, including some code examples, I recommend you check out the <a href="https://github.com/ocaml-multicore/eio">readme in the repo</a>.</p>
<ul>
<li><strong>Tracing</strong></li>
</ul>
<p>Eio 1.0 can take advantage of the <a href="https://tarides.com/blog/2024-01-31-are-your-programs-doing-what-you-think-they-re-doing-introducing-monitoring-tools-for-multicore-ocaml/">tracing tools</a> available with OCaml 5.1. When switched on, Eio can write events about various actions, such as creating fibres or resolving promises. <a href="https://github.com/ocaml-multicore/eio-trace"><code>Eio-trace</code></a> and third-party tools like  <a href="https://github.com/tarides/runtime_events_tools?tab=readme-ov-file#trace"><code>olly</code></a> can capture and display the traces of these events in a window (for example using <a href="https://perfetto.dev/">Perfetto</a>, giving users a visual representation of their data. Having an I/O stack compatible with the tracing capabilities of OCaml 5.1 gives developers the tools to visualise what their code is doing and monitor it for changes.</p>
<p><span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; ">
      <a href="https://tarides.com/static/db38025f9929ceb50a28e29dbfd89e7b/dec58/eio_trace.png" class="gatsby-resp-image-link" style="display: block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom: 14.117647058823529%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAqUlEQVR42k2JsW7CMBgG8/4vUiNZSmy1m5FsywFH9m+nQAYWFhbe4kppB4ZPd/puyLdMvETct2N/3uOjxzmH954YIyEEQgxMcWK0I9ZatNaM49Mni/pSmIMhnAM+e4bH/cF23VjygixCKYVa64vv/tuNN+hPjfpQqEmxMzucd5Tjsx8XTtuJodSCVKG1Ruvtj+/7/3rv5JZJh8ScZuY8k3JCuryaiLCuKz/2EcXT2Ob+7AAAAABJRU5ErkJggg=='); background-size: cover; display: block;"></span>
  <img src="https://tarides.com/static/db38025f9929ceb50a28e29dbfd89e7b/c5bb3/eio_trace.png" class="gatsby-resp-image-image" alt="Eio-trace providing a graphical representation of the Eio tutorial's networking example" title="" srcset="/static/db38025f9929ceb50a28e29dbfd89e7b/04472/eio_trace.png 170w,
/static/db38025f9929ceb50a28e29dbfd89e7b/9f933/eio_trace.png 340w,
/static/db38025f9929ceb50a28e29dbfd89e7b/c5bb3/eio_trace.png 680w,
/static/db38025f9929ceb50a28e29dbfd89e7b/b12f7/eio_trace.png 1020w,
/static/db38025f9929ceb50a28e29dbfd89e7b/b5a09/eio_trace.png 1360w,
/static/db38025f9929ceb50a28e29dbfd89e7b/dec58/eio_trace.png 2133w" sizes="(max-width: 680px) 100vw, 680px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<ul>
<li><strong>Multicore Support</strong></li>
</ul>
<p>OCaml 5 now lets programs create multiple domains to run code, meaning that programs can use multiple CPUs simultaneously. This significantly speeds up processing time, especially for CPU-intensive tasks.</p>
<p>Eio 1.0 provides <a href="https://ocaml-multicore.github.io/eio/eio/Eio/Executor_pool/index.html"><code>Eio.Executor_pool</code></a>, which distributes jobs (functions to execute) among a pool of domain workers. Domains are reused and can execute multiple jobs concurrently, and jobs are queued up if they cannot be started immediately due to all workers being busy. Having an I/O stack that can run on multiple domains lets developers create more efficient code, reducing the time it takes to perform a task. <code>Eio.Executor_pool</code> is the recommended module for leveraging OCaml 5's multicore capabilities. It is built on top of the low-level <a href="https://ocaml-multicore.github.io/eio/eio/Eio/Domain_manager/index.html"><code>Eio.Domain.manager</code></a>, which lets developers use multiple domains by having the fibres of the calling domain run in parallel with another, new, domain.</p>
<ul>
<li><strong>Integrations</strong></li>
</ul>
<p>It was essential to the team designing Eio that it was <a href="https://github.com/ocaml-multicore/eio?tab=readme-ov-file#integrations">compatible with other I/O libraries</a> and that you could use Eio in the same domain as Async and Lwt. For example, you can use <a href="https://github.com/ocaml-multicore/lwt_eio"><code>Lwt_eio</code></a> and <a href="https://github.com/talex5/async_eio"><code>Async_eio</code></a> to run Lwt, Async, and Eio fibres together in a single domain and to convert promises from Lwt and Async to Eio. This is useful when porting existing code to Eio.</p>
<p>You can use Eio with OCaml's Unix module by using <code>Eio_unix</code>, and <a href="https://github.com/ocaml-multicore/domainslib">Domainslib</a> and <a href="https://github.com/ocaml-multicore/kcas"><code>kcas</code></a> can also interact with Eio. It can be helpful to send work to a pool of Domainslib worker domains when managing compute-intensive tasks. Helpfully, resolving an Eio promise from a non-Eio domain is possible, making the results easy to retrieve. Eio is compatible with <code>kcas</code> which provides blocking in lock-free software transactional memory (STM) implementations.</p>
<p>Integration is important because it gives users the flexibility to use multiple tools and the tools they prefer for the job. Rather than forcing everyone to use one workflow, the team behind Eio wanted to open up possibilities for the user whilst giving them an upgraded I/O that leverages effects and multicore programming.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#history-of-eio" aria-label="history of eio permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>History of Eio</h2>
<p>Originally, OCaml 5 was not supposed to include support for effects! Therefore, Eio started out as a prototype by the same team working on OCaml Multicore at Tarides. To explore and test the experimental I/O design, we ported it to several large libraries and applications with the help of other open-source maintainers. A special thanks go to <a href="https://tezos.com/">Tezos</a> and <a href="https://mirage.io">MirageOS</a> maintainers for early reviews and discussions!</p>
<p>During the porting and testing, we discovered and fixed <a href="https://github.com/ocaml/ocaml/issues/12948%5D">several</a> <a href="https://github.com/ocaml/ocaml/issues/12584">bugs</a> in the OCaml 5 runtime. The Tarides team also created and upstreamed many different <a href="https://tarides.com/blog/2022-12-22-ocaml-5-multicore-testing-tools/">testing</a> and <a href="https://tarides.com/blog/2024-01-31-are-your-programs-doing-what-you-think-they-re-doing-introducing-monitoring-tools-for-multicore-ocaml/">monitoring</a> tools that make concurrent programming with effects easier. Thanks to this rigorous process, Eio is now a very efficient, portable (it's the only OCaml scheduler compatible with Linux, MacOS, Windows, JavaScript and MirageOS!), and flexible stack. These efforts also laid the groundwork for other scheduler libraries to take advantage of new tools and past learnings to explore new design options (while - hopefully - keeping the ecosystems compatible). See for instance <a href="https://github.com/riot-ml/riot">RIOT</a> that brings Erlang-style concurrency to OCaml using a multicore actor-model, or <a href="https://discuss.ocaml.org/t/ann-miou-a-simple-scheduler-for-ocaml-5/12963">Miou</a>, <a href="https://github.com/c-cube/fuseau">Fuseau</a>,or <a href="https://github.com/dbuenzli/affect">Affect</a>, and so on.</p>
<p>We can't just focus on the positives &ndash; as with any new workflow, Eio has had its share of growing pains. Early in its development, the community gave constructive criticism about the API design. Some users didn't like the explicit capability model -- other disliked the use objects in the API as it was yet another feature of the language that newcomers would have to learn before writing a relatively 'simple' direct-style I/O application. As a response we tried to keep the explicit capability model, but without using objects. While some users appreciated the change, the resulting API is more complex. We need more community input to decide what to do for Eio 2.0, so please continue to voice your opinions on the relevant <a href="https://github.com/ocaml-multicore/eio/pull/553">GitHub issue</a>.</p>
<p>Finally, some users found the API surface too big and making it difficult to compose with other schedulers. We explored several solutions for better composability and our latest effort is <a href="https://github.com/ocaml-multicore/picos">Picos</a>. We plan to integrate Picos with Eio once the project is more mature. We've also received feedback that the capability API is too intrusive for some users. Whilst its model works well with modern sandboxing tools like Wasm and Capsicum and is compatible with <a href="https://www.janestreet.com/tech-talks/effective-programming/">typed effects</a>, we understand it's a divisive design choice. To address these comments, which we have already begun to do with Picos, we are open to collaborate further with the community on a design that works the best for everyone.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#stay-in-touch" aria-label="stay in touch permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stay in Touch</h2>
<p>The focus for the upcoming months is to gather information about how the I/O stack is performing and whether there are any pain points or improvement opportunities. The team appreciates your feedback, so if you are using Eio in your projects or are curious to test it out, please share your experience directly <a href="https://github.com/ocaml-multicore/eio/issues">in the repo</a> or on <a href="https://discuss.ocaml.org/">OCaml Discuss</a>. There are also <a href="https://docs.google.com/document/d/1ZBfbjAkvEkv9ldumpZV5VXrEc_HpPeYjHPW_TiwJe4Q">regular developer meetings</a> and <a href="https://matrix.to/#/%23eio:roscidus.com">forum discussions</a> that are open to everyone. We also recommend our <a href="https://tarides.com/blog/2023-09-27-tutorial-how-to-port-lwt-applications-to-eio/">tutorial on porting Lwt applications to Eio</a> if you want to get started with porting some of your on applications to the new I/O stack.</p>
<p>Want to stay in touch? You can follow us on <a href="https://twitter.com/tarides_">X</a> (formerly known as Twitter) and <a href="https://www.linkedin.com/company/tarides/">LinkedIN</a> to keep up-to-date with our projects and events.</p>
<blockquote>
<p>Tarides invites potential sponsors interested in utilising Eio commercially to <a href="https://tarides.com/contact/">reach out</a>. Your support is crucial for the ongoing development of our open-source projects!</p>
</blockquote>
<h3 style="position:relative;"><a href="https://tarides.com/feed.xml#acknowledgements" aria-label="acknowledgements permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Acknowledgements</h3>
<p>We would like to thank all the Eio contributors, including but not limited to: Bikal Gurung, Patrick Ferris, Simon Grondin, Christiano Haesbaert, Lucas Pluvinage, and Vesa Karvonen and the Tarides Multicore Application team, notably Sudha Parimala, for their support. The initial development of Eio has been partly sponsored by Jane Street and the Tezos Foundation.</p>
