---
title: Improving Memory Profiler Visualisations for OCaml
description: Discover our Internship project focusing on building new visualisations
  for OCaml's memory profiler "statmemprof".
url: https://tarides.com/blog/2025-07-04-improving-memory-profiler-visualisations-for-ocaml
date: 2025-07-04T00:00:00-00:00
preview_image: https://tarides.com/blog/images/memtrace-1360w.webp
authors:
- Tarides
source:
ignore:
---

<p>Each year, Tarides has the pleasure of hosting several interns who work across different areas within the company. This year, we welcomed Kashish, who joined us to work on enhancing the visualisations for OCaml's memory profiling (you can check out our blog post about the return of <a href="https://tarides.com/blog/2025-03-06-feature-parity-series-statmemprof-returns/">Statmemprof</a> for some more context). This post will explore Kashish's project and the steps we took to improve the visualisations available with OCaml's memory profiling tools.</p>
<h2>Background: Improving the OCaml 5 Memory Profiler</h2>
<p>First, a little background on the area. In OCaml, we have support for statistical memory profiling built into the runtime, called <strong>statmemprof</strong>.  The basic idea is the OCaml runtime provides an interface for registering callbacks to be called when interesting Garbage Collection events occur, such that we can track memory allocation activity for some statistical sample of allocations in an OCaml program. <a href="https://github.com/ocaml/ocaml/pull/12923">PR #12923</a> has more technical details of the implementation.</p>
<p>Built on top of this is <a href="https://github.com/janestreet/memtrace/">memtrace</a>, a library that uses the <strong>statmemprof</strong> interface to produce trace files formatted in the Common Trace Format (CTF). Memtrace has a <a href="https://github.com/janestreet/memtrace/blob/master/docs/internal.md">detailed technical description</a> of how it works. Finally, there is a web app, <a href="https://github.com/janestreet/memtrace_viewer">memtrace_viewer</a>, that displays information about memory allocations using a 'FlameGraph' format to visualise the allocations. Below is a sample of what such a trace might look like.</p>
<p><img src="https://tarides.com/blog/images/2025-05-26.memtrace-internship/memtrace-viewer-1360w~0vRDcnfMCo67E2WX6yBDGg.webp" sizes="(min-width: 1360px) 1360px, (min-width: 680px) 680px, 100vw" srcset="/blog/images/2025-05-26.memtrace-internship/memtrace-viewer-170w~4oRYdhhNZp8ZrL8kI79j6g.webp 170w, /blog/images/2025-05-26.memtrace-internship/memtrace-viewer-340w~2Mi7QL9cTT35CpNLJnaXgQ.webp 340w, /blog/images/2025-05-26.memtrace-internship/memtrace-viewer-680w~1Qbmi5ujo2_RCvLlKp1i2Q.webp 680w, /blog/images/2025-05-26.memtrace-internship/memtrace-viewer-1360w~0vRDcnfMCo67E2WX6yBDGg.webp 1360w" alt=""></p>
<p>For Kashish's internship we thought about how to support other kinds of visualisations for memory profiling data. For example, Go uses a directed graph visualisation in <a href="https://go.dev/blog/pprof">pprof</a> that would be a <a href="https://signalsandthreads.com/performance-engineering-on-hard-mode/">good alternative to FlameGraphs</a>. FlameGraphs are excellent for visualising data. However, they lack a useful property called join points, which are points where stack traces start differently and then reach the same important function. Using a graph representation highlights these points in a way that FlameGraphs cannot.</p>
<h2>File Formats</h2>
<p>A picture is worth a thousand words, and this is never more appropriate than when trying to understand a bunch of numbers collected from a complex system like a garbage collector (GC). We had two realisations in approaching this problem: one, that we could reuse the work done by others in visualising it, and second, that there are common tracing formats already used by other languages that we could reuse to unlock more visualisation options. For example, Memtrace used a CTF file format that looked like it could be converted to the protocol buffers (protobuf) based format used by <code>pprof</code>.</p>
<p>The first step towards converting formats was to understand the protobuf-based format. Looking at both the <a href="https://github.com/google/pprof/tree/main/proto/README.md">README.md</a> and the <a href="https://github.com/google/pprof/blob/main/proto/profile.proto"><code>profile.proto</code></a> file gave an initial idea of the data types we needed. The pprof format is divided into three main parts: a <em>Profile</em> with general information, <em>Samples</em> recording values encountered in the execution of some program, and <em>Locations</em> identifying places within a program where samples are generated. Overall, the format is quite flexible and covers things like time profiling as well as memory profiling, which we're interested in.</p>
<p>Kashish looked at the pprof files generated from Go and Rust when doing memory profiling to see how they formatted their <em>Samples</em>. With this information, she started writing a tool to convert CTF traces into pprof traces. Starting with the <code>profile.proto</code>, she used <a href="https://ocaml.org/p/pbrt/latest">pbrt</a> and <code>ocaml-protoc</code> to generate the code for reading and writing the protobuf format; she then worked through the details of converting between the two formats. The end result is a cli tool for converting CTF files.</p>
<p>These files can be visualised using Go lang's pprof tool by running <code>pprof -http localhost:8080 &lt;proto_file&gt;</code>. For example:</p>
<p><img src="https://tarides.com/blog/images/2025-05-26.memtrace-internship/solver-graph-1360w~duyxE4WBxcD0A8A4g5blIA.webp" sizes="(min-width: 1360px) 1360px, (min-width: 680px) 680px, 100vw" srcset="/blog/images/2025-05-26.memtrace-internship/solver-graph-170w~PB5MLAyrip9ssVaupcvnDQ.webp 170w, /blog/images/2025-05-26.memtrace-internship/solver-graph-340w~Ljn2RvoGmKy03BXCIh27YA.webp 340w, /blog/images/2025-05-26.memtrace-internship/solver-graph-680w~5iaiWeCR2dl2alMmlmeLbw.webp 680w, /blog/images/2025-05-26.memtrace-internship/solver-graph-1360w~duyxE4WBxcD0A8A4g5blIA.webp 1360w" alt=""></p>
<p>The picture is zoomed in on the <code>opamVersionCompare</code> function, which represents 33% of the allocations in this solver-service program.</p>
<p>From the top left menu, you can choose <em>Sample</em> to view the graph by the ‘number of samples’, i.e., the number of times a particular stack trace occurs in our profile or ‘alloc size’, i.e., the amount of memory allocated by each stack frame.</p>
<p>You can also use <em>Peek</em> to see a breakdown of allocations sorted by space allocated or objects allocated. In GC parlance, an <em>object</em> is a dynamically allocated piece of memory that contains an OCaml value. This visualisation can highlight the top allocating locations in an OCaml program. This first image shows the top allocating functions based on the memory size of their allocations and highlights code in OpamFormat parsing that is worth investigating.</p>
<p><img src="https://tarides.com/blog/images/2025-05-26.memtrace-internship/solver-peek-alloc-space-1360w~RePruauCqce_0d520F6OpA.webp" sizes="(min-width: 1360px) 1360px, (min-width: 680px) 680px, 100vw" srcset="/blog/images/2025-05-26.memtrace-internship/solver-peek-alloc-space-170w~02PHSvfUCNZYAgdjawzCCA.webp 170w, /blog/images/2025-05-26.memtrace-internship/solver-peek-alloc-space-340w~aPgcYTRRdxrq6ZHSHBAr1Q.webp 340w, /blog/images/2025-05-26.memtrace-internship/solver-peek-alloc-space-680w~qIwtjKtypAd5NSpFwYmf7g.webp 680w, /blog/images/2025-05-26.memtrace-internship/solver-peek-alloc-space-1360w~RePruauCqce_0d520F6OpA.webp 1360w" alt=""></p>
<p>This second image shows the top object allocating functions unrelated to the amount of memory being allocated, which can highlight places that allocate many small pieces of memory and often go unnoticed. Note this again highlights the <code>opamVersionCompare</code> function.
<img src="https://tarides.com/blog/images/2025-05-26.memtrace-internship/solver-peek-alloc-objects-1360w~qmwHt9IkEg3EZT6kVe7kGQ.webp" sizes="(min-width: 1360px) 1360px, (min-width: 680px) 680px, 100vw" srcset="/blog/images/2025-05-26.memtrace-internship/solver-peek-alloc-objects-170w~XHJuSKgs3n4TPV3yJqUL8Q.webp 170w, /blog/images/2025-05-26.memtrace-internship/solver-peek-alloc-objects-340w~HvdoWHAVMc5IT66_6A2PKA.webp 340w, /blog/images/2025-05-26.memtrace-internship/solver-peek-alloc-objects-680w~EidLdlx8Hi1TgotMQ6i1jw.webp 680w, /blog/images/2025-05-26.memtrace-internship/solver-peek-alloc-objects-1360w~qmwHt9IkEg3EZT6kVe7kGQ.webp 1360w" alt=""></p>
<h2>A Library for Mappings: Blind Alleys</h2>
<p>The <code>pprof</code> format contains a field called <em>Mappings</em>, which uses information about the executable binary and the virtual addresses of functions or <em>Locations</em> in our stack traces. We thought we needed to get the virtual memory address for symbols to include as part of the stack traces in the profile. This would allow users to map addresses back to locations in the source code via the addresses in the executable.</p>
<p>However, these virtual addresses are not known until runtime, so we needed to get the virtual memory maps for the running process. On Linux, this information was available in the proc filesystem as <code>/proc/&lt;pid&gt;/maps</code> and simply required parsing out the information into a usable type. Then, we mapped the virtual addresses to a segment and back to locations in the original binary.</p>
<p>On MacOS, things are much more exciting and tricky. On the surface, macOS is a Unix operating system based on a FreeBSD userspace; however, under this facade is another operating system called <a href="https://en.m.wikipedia.org/wiki/Mach_(kernel)">Mach</a>, which is actually responsible for many aspects of the system, including how virtual memory maps for a process are represented. So, what we needed to do was write some low-level OCaml using c-types to call the right C functions to retrieve the information we needed. How that works deserves its own blog post, but you can read the code at <a href="https://github.com/tmcgilchrist/mach/">tmcgilchrist/mach</a>.</p>
<p>Later on, we realised that pprof traces could work in two ways; with memory addresses for compiled languages like C++ or Go or with symbolised locations for interpreted or JIT'd languages like Java or Python. The documentation calls these <em>Unsymbolized</em> profiles and <em>Symbolized</em> profiles respectively. OCaml will produce <em>Symbolized</em> profiles by default as Statmemprof supplies the location information for symbols. In future, <em>Unsymbolized</em> profiles could be supported, and even information like demangled names and source file locations could be included.</p>
<h2>Writing <code>pprof</code> Directly</h2>
<p>With the conversion code written and confident in our understanding of the file format, the next task was to write protobuf files directly from memtrace using the callback API provided by <code>Gc.Memprof.start</code> and creating a <code>Gc.Memprof.tracker</code> record. The resulting code was similar to the conversion code; however, there are some interesting points of difference for protobuf traces.</p>
<p>Protobuf traces tend to be larger than the equivalent CTF traces. This is because memtrace <a href="https://github.com/janestreet/memtrace/blob/master/docs/internal.md">optimises</a> the data written to a trace. The most important optimisation is the way it stores callstacks, as they are the single biggest piece of information stored. Consecutive backtraces usually only differ by the last few entries, so instead of storing the entire callstack each time, they store a “common prefix”, i.e., the number of entries that are the same as the callstack of the previous sample. Then, the reader can obtain the entire callstack by combining the “common prefix” entries with the new, unique entries.</p>
<p>With our restriction to use <em>pprof</em> for visualisations, we needed to use the pprof format as defined, and the pprof format does not support common prefixes. Meaning we could not implement common prefixes in our writer. In the future, it could be possible to write our own <code>protobuf</code> decoder that supports this feature.</p>
<p>To produce smaller trace files, <code>pprof</code> compresses its <code>protobuf</code> files using <code>gzip</code>, which significantly reduces their file size, making them much smaller than CTF files. To similarly reduce memory overhead in the <code>protobuf</code> writer, one option is to integrate an OCaml compression library such as <a href="https://github.com/xavierleroy/camlzip">camlzip</a> to compress the output on the fly as data is written. Naturally, this introduces a trade-off: lower memory usage at the cost of increased CPU time. For example, when profiling a sample program, the CTF file is 25Mb versus 421Mb for protobuf, which reduces to 8.3Mb when gzipped.</p>
<p>The Go and OCaml Garbage Collectors differ in important ways that impact the information collected in trace files. Since the premise of this work is reusing the Go tooling and visualisations, it is useful to understand what kind of Garbage Collector Go uses.</p>
<p>Go uses a Tracing Garbage Collector with the following properties:</p>
<ul>
<li>Hybrid stop-the-world/concurrent collector</li>
<li>Stop-the-world limited by a deadline (10 ms)</li>
<li>Concurrent collector running in parallel on CPU cores</li>
<li>Tri-colour mark-and-sweep algorithm</li>
<li>Non-generational</li>
<li>Non-compacting</li>
</ul>
<p>Of these the most important property is Go's GC isn't generational, while OCaml's is a generational GC. Memtrace tracks deallocation and promotion events between the generations. Currently, we're not tracking these events as pprof was built for Go programs and doesn't handle this information. The next obvious step would be writing out these events and building the visualisations to handle them.</p>
<h2>Collateral Fixes</h2>
<p>In the process of writing tests for the conversion tool, Kashish also discovered some failing tests in the OCaml 5 version of Memtrace caused by the way the <code>Gc.Memprof</code> API interacts with threads and the new domains introduced in OCaml 5. They were fixed <a href="https://github.com/tmcgilchrist/memtrace/pull/2">in this PR</a> and will be included in the OCaml 5.3 support <a href="https://github.com/janestreet/memtrace/pull/22">PR</a>.</p>
<h2>Until Next Time</h2>
<p>The goal of the internship was to improve visualisation options for memory profiling in OCaml by investigating different profiling file formats and then build tooling to generate (or convert) to these formats. Pprof is a protocol buffers-based format used by Go, Rust, and Java to capture profiling information. Kashish built tooling for converting CTF trace files to protobuf format and writing protobuf format directly from memtrace, both of which allow users to visualise memory profiles using a directed graph format originally used by pprof.</p>
<p>In future, it would be interesting for the OCaml community to build on this work by:</p>
<ul>
<li>Extending protobuf format to record all OCaml GC events.</li>
<li>Updating <em>memtrace viewer</em> to consume pprof format directly.</li>
<li>Producing <em>Unsymbolized</em> profiles from stripped binaries (i.e. without symbol information and just addresses). Reconstituting symbolised information afterwards, similar to C++ or Go.</li>
<li>Supporting encoding and decoding common prefix stack traces.</li>
<li>Adding different kinds of visualisations like treemaps, force directed graphs, or circle pack layout</li>
</ul>
<p>We would welcome contributions in these areas. Get in touch if anything there looks interesting or useful.</p>
<p>You can connect with us on <a href="https://bsky.app/profile/tarides.com">Bluesky</a>, <a href="https://mastodon.social/@tarides">Mastodon</a>, <a href="https://www.threads.net/@taridesltd">Threads</a>, and <a href="https://www.linkedin.com/company/tarides">LinkedIn</a> or sign up for our mailing list to stay updated on our latest projects. We look forward to hearing from you!</p>

