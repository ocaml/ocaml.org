---
title: 'Deep Dive: Optimising Multicore OCaml for Windows'
description: "We love hosting internships. It is rewarding to potentially facilitate
  someone\u2019s first foray into the OCaml ecosystem, helping them\u2026"
url: https://tarides.com/blog/2024-07-10-deep-dive-optimising-multicore-ocaml-for-windows
date: 2024-07-10T00:00:00-00:00
preview_image: https://tarides.com/static/18316ffead39c18231bc3dd3899eed4f/6b50e/racecar.jpg
authors:
- Tarides
source:
---

<p>We love hosting internships. It is rewarding to potentially facilitate someone&rsquo;s first foray into the OCaml ecosystem, helping them establish a hopefully life-long foothold in the world of open-source programming. It is also a great opportunity to get new perspectives on existing issues. Fresh eyes can reinvigorate topics, highlighting different pain points and new solutions which benefit the entire community.</p>
<p>Sometimes, we also find ourselves just trying to keep up with our interns as they take off like rocket ships! Recently, we mentored a student who did just that. The initial goal of the internship was to investigate strange performance drops in the OCaml runtime that arose after the introduction of multicore support. These performance drops were most keenly felt on Windows machines, and the initial internship specification emphasised the need to improve the developer experience on that operating system.</p>
<p>Our intern <a href="https://github.com/eutro">@eutro</a> went above and beyond anything we could have expected and tackled the project thoroughly and ambitiously. In this post, I will attempt to give you a comprehensive overview of this intricate project and the problems it tackled.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#get-busy-waiting" aria-label="get busy waiting permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Get Busy Waiting?</h2>
<p>Before OCaml 5, only one thread would run at any given time. Users never had to worry about multiple threads trying to use a shared resource like the Garbage Collector (GC). In OCaml 5, however, the process is divided into several 'threads'<sup><a href="https://tarides.com/feed.xml#fn-1" class="footnote-ref">1</a></sup>, and multiple threads regularly try to run parts of the GC simultaneously. The minor GC uses a Stop The World (STW) function to run in parallel on all threads, whereas the major GC&rsquo;s work is split into slices. These may happen in parallel between threads and while the user&rsquo;s program (also called the &lsquo;mutator&rsquo;) is making changes. This is one example of when a mechanism is needed to protect multiple threads from making changes that contradict each other and result in unexpected behaviours.</p>
<p>Locks are the traditional way of doing this, whereby other activity is halted (or locked) while one activity finishes. However, in multicore programming, this method would be incredibly inefficient since there can be many activities in progress simultaneously. In this case, we would need to introduce so many locks for the different parts of memory that doing so would cause memory and OS resource problems!</p>
<p>The approach we use for OCaml 5 combines a <a href="https://en.wikipedia.org/wiki/Compare-and-swap">Compare And Swap</a> (CAS) operation with <a href="https://en.wikipedia.org/wiki/Busy_waiting">Busy-Wait</a> loops. A CAS operation ensures that if two threads try to modify the same area of memory, only one will succeed. The one that fails will know it has failed and can then enter a period of Busy-Waiting (called <code>SPIN_WAIT</code> in the code). Busy-wait loops (also referred to as spins) describe a process that repeatedly ('busily') checks whether a condition is true. The process or task is only resumed once that condition is met.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#sleeping-beauty" aria-label="sleeping beauty permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sleeping Beauty</h2>
<p>Busy-wait loops are used successfully in OCaml for many purposes but have been optimised. They are mostly appropriate in cases where we think that the required condition will be met quickly or in a reasonable period of time. If that&rsquo;s not the case, then theoretically, the thread that is waiting will just keep spinning. If one allows busy-wait loops to spin indefinitely, they waste a lot of power and CPU and can actually prevent the condition they are waiting for from being met. To avoid that happening, we can use a <code>sleep</code> function.</p>
<p>In order to implement spinning without wasting power, the loop checks the condition repeatedly, but after a while, it starts 'sleeping' between checks. Suppose a thread is waiting for condition <code>C</code> to come true, and it uses a Busy-Wait loop to check for this. The program spins a number of times, checking the condition, and then waits or goes to &lsquo;sleep&rsquo; for a set amount of time &ndash; then it &lsquo;wakes up&rsquo; and checks once more before (if it has to) going back to &lsquo;sleep&lsquo; again. The period of &lsquo;sleep&rsquo; increases each time. This cycle repeats itself until the condition <code>C</code> finally comes true.</p>
<p>This was how the process was <em>supposed</em> to work, yet, for some unknown reason, certain processes would occasionally take much longer than expected. The performance drop was worst on Windows machines.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#testing-1-2-3-testing-1-2-3" aria-label="testing 1 2 3 testing 1 2 3 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testing 1-2-3, Testing 1-2-3,</h2>
<p>The first order of business was to conduct a series of tests on the runtime. Not only to discover the possible cause of the performance drops but also to establish a baseline of performance against which to measure any changes (and hopefully improvements!).</p>
<p>We knew that there was a performance problem and that it was particularly painful on Windows, but we didn&rsquo;t know why. Even if we had a hunch as to what might be causing it, it was crucial to build up a realistic image of what was happening before we attempted a fix.</p>
<p>@eutro began this process by identifying where Busy-Wait loops were spinning in the runtime and for how long. She also wanted to know if there were places in the runtime where processes would get &lsquo;stuck&rsquo; in Busy-Wait loops and not move on, and if so, where and why.</p>
<p>She used the <a href="https://github.com/ocaml/ocaml/tree/trunk/testsuite/tests">OCaml testsuite</a> and measured how many <code>SPIN_WAIT</code> macros resolved successfully without needing to sleep and which ones did not. She discovered that in most cases, the spinning had the desired effect, and the process could continue after a reasonable amount of time when the condition it was waiting for was met. The garbage collector was also not experiencing any significant performance drops, so it could not be the cause of the problems on Windows. Instead, what she realised was that on Windows, <code>sleeps</code> cannot be shorter than one millisecond, and so the first sleeps that occur end up being much too long. This causes extended and unnecessary delays for processes running on Windows. Equipped with this realisation, @eutro got started on a solution. One that would be most helpful on Windows but still benefit users on other operating systems.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#barriers-and-futexes-oh-my" aria-label="barriers and futexes oh my permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Barriers and Futexes, Oh My!</h2>
<p>There are a few ways a thread in OCaml can wait for a condition:</p>
<ul>
<li>First, we may be able to proceed very soon (nanoseconds), in which case we will spin until we can proceed.</li>
<li>Then, if spinning doesn&rsquo;t let us proceed, we sleep a few times until the condition comes true. In most cases (read: not on Windows), the first few sleeps are still very quick, and we can proceed soon once the condition is met.</li>
<li>An alternative to sleeping &lsquo;blindly&rsquo; like this is to tell the OS specifically <em>what</em> we are waiting for so that we can be woken up only when we know the condition is true. You can think of this as taking a ticket and waiting for your number to be called rather than repeatedly asking if you can be seen.</li>
</ul>
<p>So what has changed? As things stood, only steps one and two were available, a series of increasingly long sleeps interleaved with checks. So you would spin <em>n</em> times, then sleep for 10&micro;s (&lsquo;&micro;s&rsquo; is short for microseconds), then you check the condition once more and might sleep for 20&micro;s, then 35&micro;s, and so on. The point is that the time spent sleeping kept gradually increasing.</p>
<p>However, as @eutro discovered, in many cases, the process took far too long to resume, even after the condition had come true. By the time they woke up from sleeping, they could have already proceeded if they had just &lsquo;taken a ticket&rsquo; earlier and waited until they were notified. To improve performance, instead of repeatedly sleeping for longer increments, we use specialised &lsquo;barriers&rsquo; to wait <em>until</em> we can proceed.</p>
<p>To solve the Windows problem, we now use the <code>SPIN_WAIT</code> function only in cases where we don&rsquo;t expect to ever need to sleep. In cases where that first sleep would cause significant delay, we introduce a new <code>SPIN_WAIT_NTIMES</code> function, which lets the process spin for a set number of times before being combined with a barrier. @eutro used her previous benchmarks to determine which occasions could keep the <code>SPIN_WAIT</code> cycle as-is and which occasions required the new <code>SPIN_WAIT_NTIMES</code> combined with a barrier.</p>
<p>But things didn&rsquo;t stop there! @eutro could also optimise the type of barrier. Traditionally, we use condition variables to wake up threads waiting on a condition. However, they are unnecessarily resource-intensive as they require extra memory, and since woken threads must acquire (and release) a lock before they continue. A <em>futex</em> is a lower-level synchronisation primitive that can similarly be used to wake up threads but without the added complexity of a condition variable.</p>
<p>@eutro added the use of futexes to the operating systems that permitted her to do so. Notably, macOS does <em>not</em> allow non-OS programs to use futexes so we fall back to using &quot;condition variables&quot; there.</p>
<p>By introducing the use of <code>SPIN_WAIT_NTIMES</code>, barriers, and futexes, @eutro implemented a number of optimisations that were applicable not only on Windows but on several operating systems. These optimisations save users time and processing power.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#how-much-do-you-benchmark" aria-label="how much do you benchmark permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How Much do You Bench(mark)?</h2>
<p>During the course of implementing these changes, @eutro did a lot of tests. It was important to be thorough in order to ensure that her changes didn&rsquo;t have unintended consequences. It is incredibly difficult to reason about how programs will react to a specific alteration, as there are many things happening in the runtime and several ways that programs can interact.</p>
<p>She used the OCaml test suite again, this time to help her check that the OCaml runtime and other OCaml programs functioned correctly. Having verified that they were, @eutro also ran several benchmarks to check that she hadn&rsquo;t actually made anything slower. For this, she used the <a href="https://github.com/ocaml-bench/sandmark">Sandmark test suite</a>.</p>
<p>I recommend checking out the tests and benchmarks for yourself <a href="https://github.com/ocaml/ocaml/pull/12579">in the Pull Request</a>. The PR also gives a more in-depth technical overview of the changes to the Busy-Waiting loops.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#you-can-join-us-too" aria-label="you can join us too permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>You Can Join Us Too!</h2>
<p>It is great to see what someone with a passion for OCaml can bring to the system as a whole. I think it illustrates the benefits of open-source software development: when we invite fresh observations and suggestions, we create a community that supports innovation and collaboration. We are impressed with the hard work @eutro put into solving the complicated problem before her. She went above and beyond what we thought possible in such a short amount of time!</p>
<p>Would you like to complete an internship with us? We welcome people of varying experience levels &ndash; some interns have made open-source contributions before and are familiar with functional programming, and some of our interns have no functional programming experience at all! If you&rsquo;re interested in developing your skills in a supportive environment, keep an eye on our <a href="https://tarides.com/careers/">careers page</a>, where we post about any available internships. We also regularly communicate about available internships on <a href="https://twitter.com/tarides_">X</a> (formerly known as Twitter). We hope to hear from you!</p>
<blockquote>
<p>Tarides champions open-source development. We create and maintain key features of the OCaml language in collaboration with the OCaml community. To learn more about how you can support our open-source work, discover our <a href="https://github.com/sponsors/tarides">page on GitHub</a>.</p>
</blockquote>
<blockquote>
<p>We are always happy to discuss commercial opportunities around OCaml. We provide core services, including training, tailor-made tools, and secure solutions. <a href="https://tarides.com/contact/">Contact us today</a> to learn more about how Tarides can help your teams realise their vision.</p>
</blockquote>
<div class="footnotes">
<hr/>
<ol>
<li>We are aware of the distinction between &lsquo;threads&rsquo; and &lsquo;domains&rsquo; in OCaml. We chose to use the former here, mainly to keep the content accessible for people who are less familiar with the subtleties of OCaml.<a href="https://tarides.com/feed.xml#fnref-1" class="footnote-backref">&#8617;</a><a href="https://tarides.com/feed.xml#fnref-1" class="footnote-backref">&#8617;</a></li>
</ol>
</div>
