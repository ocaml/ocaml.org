---
title: 'The Journey to OCaml Multicore: Bringing Big Ideas to Life'
description: "Continuing our blog series on Multicore OCaml, this blog provides an
  overview of the road to OCaml Multicore. If you want to know how you\u2026"
url: https://tarides.com/blog/2023-03-02-the-journey-to-ocaml-multicore-bringing-big-ideas-to-life
date: 2023-03-02T00:00:00-00:00
preview_image: https://tarides.com/static/caf16b04b6417354dc02755abfc245ca/2070e/jack-anstey-zS4lUqLEiNA-unsplash.jpg
authors:
- Tarides
source:
---

<p>Continuing our blog series on <a href="https://tarides.com/blog/2022-12-19-ocaml-5-with-multicore-support-is-here">Multicore OCaml</a>, this blog provides an overview of the road to OCaml Multicore. If you want to know how you can use OCaml 5 in your own projects, please <a href="https://tarides.com/company">contact us</a> for more information. We also recommend watching KC Sivaramakrishnan's ICFP 22' talk <a href="https://www.youtube.com/watch?v=zJ4G0TKwzVc">Retrofitting Concurrency - Lessons from the Engine Room</a></p>
<hr/>
<p>The journey to <a href="https://github.com/ocaml-multicore/ocaml-multicore/wiki">Multicore OCaml</a> is a journey from cutting-edge theory to real-life code. It&rsquo;s the story of an idea that grew from a small side-project into a multinational effort that brought a long-awaited update to OCaml. Along the road, the Multicore OCaml team faced many different challenges, leading them to re-evaluate their priorities and approach tasks differently.</p>
<p>As part of the Multicore Project since December 2014, KC Sivaramakrishnan is in a good position to describe the process from the initial days of experimentation right up until launch. He has unique insight into the decisions, challenges, and successes that the team experienced as they worked to turn innovative ideas into tangible results.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#the-journey-begins" aria-label="the journey begins permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Journey Begins</h2>
<p>In 2013, the world had survived the 21st of December 2012, Flappy Bird was popular, and everyone was doing the Harlem shake. At the University of Cambridge, Professor Anil Madhavapeddy launched the Multicore OCaml project as part of the <a href="https://ocamllabs.io/">OCaml Labs</a> initiative alongside Leo White, Jeremy Yallop, and Phillipe Wang. They were eventually joined by Stephen Dolan, the then PhD student working on combining <a href="https://www.bcs.org/events/awards-and-competitions/distinguished-dissertations/previous-winners/2017-competition/">ML-style parameteric polymorphism with subtyping</a>.</p>
<p>In 2014 KC, who had just finished his PhD in the US, joined the team. His PhD had focused on making a multicore version of MLton Standard ML compiler, which made him an asset to the growing team that would see the Multicore OCaml Project through to completion. Together they collaborated on a project that would see many partial victories and setbacks, before ultimately releasing OCaml 5.0 to the public in December 2022.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#timeline" aria-label="timeline permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Timeline</h2>
<p>In the years since the project started, there have been several developments and incremental successes. Below is an overview of the milestones along the road to Multicore OCaml:</p>
<p><span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; ">
      <a href="https://tarides.com/static/7a1079030724de99ac8bce15ae51a0e3/9c618/Multicore_timeline_new-01.jpg" class="gatsby-resp-image-link" style="display: block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom: 133.52941176470588%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAECAwX/xAAWAQEBAQAAAAAAAAAAAAAAAAABAgD/2gAMAwEAAhADEAAAAe3MhOgijJLVUSY//8QAGxAAAgMAAwAAAAAAAAAAAAAAAAECETEQIUH/2gAIAQEAAQUCZHFxdKOJmlnsV29//8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFxEBAAMAAAAAAAAAAAAAAAAAAQIRIP/aAAgBAgEBPwFiLeP/xAAYEAACAwAAAAAAAAAAAAAAAAABIBARQf/aAAgBAQAGPwJMk0v/xAAbEAACAwEBAQAAAAAAAAAAAAAAAREhMUFhUf/aAAgBAQABPyHEiRLDGmpul0fhEmrq/B/w0mhRRCsKhXBLH//aAAwDAQACAAMAAAAQ29AB/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARMf/aAAgBAwEBPxA5kisWt//EABgRAQEBAQEAAAAAAAAAAAAAAAEAIREx/9oACAECAQE/EAC9IzJuF//EABwQAQEBAQADAQEAAAAAAAAAAAERIQAxQVGBof/aAAgBAQABPxCRpSH3ikwrj74TyO/byjxDS+zhjGCzyn52UA0SM4i0A4jpwweWDj/OmG33vJKNkveKNrinMFDv/9k='); background-size: cover; display: block;"></span>
  <img src="https://tarides.com/static/7a1079030724de99ac8bce15ae51a0e3/7bf67/Multicore_timeline_new-01.jpg" class="gatsby-resp-image-image" alt="Isabella Leandersson's Graphic" title="" srcset="/static/7a1079030724de99ac8bce15ae51a0e3/651be/Multicore_timeline_new-01.jpg 170w,
/static/7a1079030724de99ac8bce15ae51a0e3/d30a3/Multicore_timeline_new-01.jpg 340w,
/static/7a1079030724de99ac8bce15ae51a0e3/7bf67/Multicore_timeline_new-01.jpg 680w,
/static/7a1079030724de99ac8bce15ae51a0e3/990cb/Multicore_timeline_new-01.jpg 1020w,
/static/7a1079030724de99ac8bce15ae51a0e3/c44b8/Multicore_timeline_new-01.jpg 1360w,
/static/7a1079030724de99ac8bce15ae51a0e3/9c618/Multicore_timeline_new-01.jpg 10800w" sizes="(max-width: 680px) 100vw, 680px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p><strong>2013</strong></p>
<ul>
<li>Multicore OCaml project was started by Prof Anil Madhavapeddy in the <a href="https://ocamllabs.io/">OCaml Labs</a> initiative at the University of Cambridge Computer Lab with Leo White, Jeremy Yallop, and Phillipe Wang. The team was later joined by the then PhD student Stephen Dolan, who was working on combining <a href="https://www.bcs.org/events/awards-and-competitions/distinguished-dissertations/previous-winners/2017-competition/">ML-style parameteric polymorphism with subtyping</a>.</li>
</ul>
<p><strong>2014</strong></p>
<ul>
<li>March: Stephen Dolan, Leo White, and Anil Madhavapeddy started hacking on Multicore OCaml</li>
<li>March: Earliest <a href="https://github.com/ocaml/ocaml/commit/a56e4530b5b173e8de28eead196d6878bc021c55">commit</a> that can be directly attributed to Multicore OCaml that is in the OCaml commit history. The commit removes most of the out-of-heap pointers the interpreter uses by replacing them with stack offsets.</li>
<li>September: A status update on Multicore OCaml was presented in the OCaml workshop 2014, you can read the <a href="https://web.archive.org/web/20160414164304/https://ocaml.org/meetings/ocaml/2014/ocaml2014_1.pdf">associated paper</a> by Stephen Dolan, Leo White, and Anil Madhavapeddy.</li>
</ul>
<p><strong>2015</strong></p>
<ul>
<li>First 6 months: An initial implementation of effect handlers was completed. The inspiration behind this idea came from the <a href="https://www.eff-lang.org">Eff language</a>.</li>
<li>September: Effect handlers in OCaml were presented at the OCaml workshop 2015. You can read more about it in this <a href="https://kcsrk.info/ocaml/multicore/2015/05/20/effects-multicore">blog post</a>.</li>
</ul>
<p><strong>2016</strong></p>
<ul>
<li>May: <a href="https://www.dagstuhl.de/en/seminars/seminar-calendar/seminar-details/16112">Dagstuhl Seminar 16112</a>: &ldquo;From Theory to Practice of Algebraic Effects and Handlers.&rdquo; Effect handlers in OCaml was presented and refined based on expert interactions.</li>
<li>ML workshop: Daniel Hillestr&ouml;m, Sam Lindley, KC Sivaramakrishnan <a href="https://kcsrk.info/publications">&quot;Compiling Links Effect Handlers to the OCaml Backend&quot;</a>. Daniel Hillerstrom developed a Multicore OCaml backend for Links language compiling Links effect handlers to OCaml effect handlers.</li>
<li>ML workshop: Oleg Kiselyov and KC Sivaramakrishnan <a href="https://kcsrk.info/papers/eff_ocaml_ml16.pdf">&quot;Eff Directly in OCaml&quot;</a>. Showed how to get the expressive power of Eff language directly using features from the OCaml language + OCaml effect handlers.</li>
<li>OCaml workshop: KC Sivaramakrishnan and Th&eacute;o Laurent <a href="https://kcsrk.info/papers/reagents_ocaml16.pdf">&quot;Lock-Free Programming for the Masses&quot;</a>. Presented the implementation of Reagents in OCaml, a composable lock-free programming library.</li>
</ul>
<p><strong>2017</strong></p>
<ul>
<li>Papers published at the ML &amp; OCaml Workshop: Stephen Dolan, Spiros Eliopoulos, Daniel Hillerstr&ouml;m, Anil Madhavapeddy, KC Sivaramakrishnan, and Leo White <a href="https://icfp17.sigplan.org/details/mlfamilyworkshop-2017-papers/2/Effectively-tackling-the-awkward-squad">&quot;Effectively Tackling the Awkward Squad&quot;</a>. The work outlined in this paper showed how effect handlers can simplify concurrent systems programming. These ideas were then incorporated in the development of <a href="https://github.com/ocaml-multicore/eio">Eio</a>.</li>
<li>Stephen Dolan and KC Sivaramakrishnan - <a href="https://icfp17.sigplan.org/details/ocaml-2017-talks/19/A-memory-model-for-multicore-OCaml">&quot;A Memory Model for Multicore OCaml&quot;</a>. The paper proposed a relaxed memory model for OCaml, broadly following the design of axiomatic memory models for languages such as C++ and Java, but with a number of differences to provide stronger guarantees and easier reasoning to the programmer, at the expense of not admitting every possible optimisation. This work eventually lead to the <a href="https://v2.ocaml.org/releases/5.0/htmlman/memorymodel.html">relaxed memory model used in OCaml 5</a>.</li>
</ul>
<p><strong>2018</strong></p>
<ul>
<li>Stephen Dolan, KC Sivaramakrishnan, Spiros Eliopoulos, Daniel Hillerstr&ouml;m, Anil Madhavapeddy, and Leo White presented a forward looking paper on &quot;<a href="https://kcsrk.info/papers/system_effects_feb_18.pdf">Concurrent Systems Programming with Effect Handlers&quot;</a> at the Trends in Functional Programming conference. This is the full version of the 2017 ML Workshop paper.</li>
<li>Stephen Dolan, KC Sivaramakrishnan, and Anil Madhavapeddy, published a paper on the relaxed memory model for OCaml at PLDI, <a href="https://kcsrk.info/papers/pldi18-memory.pdf">&quot;Bounding Data Races in Space and Time&quot;</a>. This is the full version of the memory model work presented at the 2017 OCaml Workshop.</li>
<li>The team worked on simplifying and speeding up the implementation of effect handlers.</li>
</ul>
<p><strong>2019</strong></p>
<ul>
<li>Sadiq Jaffer and Tom Kelly implemented a new garbage collector for the minor heap (parallel stop-the-world minor collector), which ensures that programs using C FFI in OCaml remain backwards compatible.</li>
<li>The <a href="https://github.com/ocaml-bench/sandmark/">Sandmark</a> benchmark suite for rigorously benchmarking OCaml programs was developed and deployed. These days the performance of OCaml compiler is tracked continuously using the <a href="https://sandmark.tarides.com">Sandmark nightly continuous benchmarking service</a>.</li>
</ul>
<p><strong>2020</strong></p>
<ul>
<li>The team decided to switch to the parallel stop-the-world minor collector (ParMinor) as default and drop the support for the concurrent minor collector (ConcMinor). ParMinor GC avoided a breaking change in the C FFI introduced by the ConcMinor GC. One concern is that the stop-the-world aspect in ParMinor would be a scalability bottleneck at large core counts. Our performance evaluation on the Sandmark suite showed that the impact of ParMinor is minimal even at large core counts (120+).</li>
<li>KC Sivaramakrishnan, Stephen Dolan, Leo White, Sadiq Jaffer, Tom Kelly, Anmol Sahoo, Sudha Parimala, Atul Dhiman, and Anil Madhavapeddy presented <a href="https://core.ac.uk/download/pdf/328720849.pdf">&quot;Retrofitting Parallelism onto OCaml&quot;</a> at ICFP 2020. The paper describes the design choices for multicore support in OCaml, the design of the ConcMinor and ParMinor GCs, detailed performance evaluation, and justifies our choice to switch to ParMinor as default. It won the distinguished paper award at ICFP.</li>
<li>From 2020 through 2021, the team focused on achieving feature parity with sequential OCaml (systhreads, GC performance, DWARF support, <a href="http://check.ocamllabs.io/">opam health check</a>, etc.)</li>
</ul>
<p><strong>2021</strong></p>
<ul>
<li>KC Sivaramakrishnan, Stephen Dolan, Leo White, Sadiq Jaffer, Tom Kelly, and Anil Madhavapeddy published <a href="https://kcsrk.info/papers/drafts/retro-concurrency.pdf">&quot;Retrofitting Effect Handlers onto OCaml&quot;</a> at PLDI 2021. The paper describes the design choices for the concurrency substrate in OCaml 5 and how effect handlers are a good fit for our needs.</li>
<li>Later half of 2021, OCaml core developers began reviewing code for Multicore OCaml, including the new concurrency and parallelism features, see <a href="https://github.com/ocaml-multicore/docs/blob/main/ocaml_5_upstreaming_proposal.md">this document</a> for more information.</li>
</ul>
<p><strong>2022</strong></p>
<ul>
<li>Early 2022, the <a href="https://github.com/ocaml/ocaml/pull/10831">Multicore PR</a> was merged!</li>
<li>Significant efforts were made by core OCaml developers to implement new features, review them, and ready the compiler for release. Without their hard work and dedication, the would be no OCaml Multicore nor OCaml 5.0.</li>
<li>Memory model successfully implemented</li>
<li>RISC-V backend and ARM64 backend achieved</li>
<li>December 16th, 2022: OCaml 5.0 is released!</li>
</ul>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#why-multicore-ocaml" aria-label="why multicore ocaml permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why Multicore OCaml?</h2>
<p>The number of cores on the machines that we use have been <a href="https://www.techspot.com/article/2363-multi-core-cpu/">steadily increasing for years</a>. Almost every computer now has several cores available to the user, and for a programming language to use them effectively it must support shared-memory parallel programming. If it does not, the user is forced to execute everything sequentially using only one core, or use multi-process programming, which is hard to use and in many cases less efficient than shared-memory parallel programming.</p>
<p>There are two main features coming with OCaml 5: <strong>Parallelism</strong> and <strong>Concurrency.</strong> Parallelism is about performance; it&rsquo;s the idea that if you have an <em>n</em> amount of cores, you can make your program go faster by <em>n</em> amounts of time. The effects of parallelism will be most keenly felt in how fast your programs run, giving you as a user a significant performance boost.</p>
<p>On a bigger scale, parallel programming is significant for projects that need to complete resource intensive tasks quickly, like <a href="https://tarides.com/blog/2022-12-20-how-nomadic-labs-used-multicore-processing-to-create-a-faster-blockchain">theorem provers</a> for example. With multicore support for OCaml, developers can take advantage of features like type and memory-safety with unprecedented levels of performance.</p>
<p>Concurrency, on the other hand, is a programming abstraction. It is a way to tell your program that you want to execute several functions, each of which may potentially block for a short time while waiting for some external event. The programming language may choose either to execute such functions sequentially, one after the other, on a single core, interleaving their execution when a function gets blocked, or choose to execute them in parallel on several cores at once. Concurrency is useful, for example, when writing a web server that must handle several concurrent requests. The program may handle several such requests at the same time, but not necessarily need to use multiple cores to handle them. With OCaml 5, writing concurrent code is made a lot easier.</p>
<p>Previously, concurrent OCaml code would have to be written in a specific tool, Async or Lwt, that the developer would have to learn separately. However, these tools don&rsquo;t currently allow for asynchronous and synchronous code to interact with each other. In a <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">blog post from 2015,</a>, Bob Nystrom goes describes this process in what he calls the &lsquo;Functional Colouring Problem&rsquo;. OCaml 5 brings in support for concurrency through <a href="https://kcsrk.info/webman/manual/effects.html">effect handlers</a> and the new Input/Output library <a href="https://github.com/ocaml-multicore/eio">Eio</a>, which lets developers compose asynchronous and synchronous code together. It&rsquo;s also easy to learn and use since it behaves like normal OCaml code, <a href="https://tarides.com/blog/2022-10-19-porting-charrua-unix-and-rawlink-to-eio">simplifying the developer workflow</a>.</p>
<p>For those who still prefer to use Lwt or Async, OCaml 5 doesn&rsquo;t preclude them from doing so. Should they one day want to switch from using either tool to using Eio, changing their code to be compatible with Eio is simple and user-friendly. Whilst they will still need to rewrite their applications to use the primitives provided by Eio, to do so is straight-forward and can be made incremental thanks to the Lwt- and Async-Eio bridges.</p>
<p>The team of people who worked on OCaml 5 knew from the start that bringing multicore support to OCaml would improve the lives of its users. It would make programs that run in OCaml <a href="https://medium.com/geekculture/what-makes-a-cpu-fast-344517cf91f9">faster and more efficient</a>,  as well as help developers be more productive.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#the-academic-and-the-engineer" aria-label="the academic and the engineer permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Academic and the Engineer</h2>
<p>When academics are on the cutting edge of science, they're essentially creating a new area of research as they go. This leads to a natural lag time between innovation and the creation of academic papers revieweing the process. For example, KC explains that &ldquo;The first <a href="https://kcsrk.info/ocaml/multicore/2015/05/20/effects-multicore/">talk on effect handlers was in 2015</a>, but the first <a href="https://anil.recoil.org/papers/2021-pldi-retroeff.pdf">proper paper on effect handlers</a> was just published in 2021.&rdquo;</p>
<p>Refererring to the time between experimentation and finished product, KC goes on to say: &ldquo;Personally, it has been challenging to take part in building these systems, because 95% of the work is not very visible but you have to create that 95% in order to talk about the 5%.&rdquo;</p>
<p>Since the road to get here has been so long, it feels all the more exhilarating that release day has finally arrived.</p>
<blockquote>
<p>&ldquo;It&rsquo;s incredible that we are at the stage where we&rsquo;re able to take cutting-edge research and put it into practice. In the last few years, we&rsquo;ve expanded from academic research to producing robust code that can be upstreamed.&rdquo;</p>
</blockquote>
<p>This is great news for the whole community, as it demonstrates OCaml&rsquo;s potential to turn research into real products. The team behind the multicore effort&rsquo;s goals were to modernise OCaml and make it faster and more efficient for everyone. The realisation of that goal took years of experimentation, optimisation, and groundbreaking research.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#first-major-challenge-its-all-about-garbage" aria-label="first major challenge its all about garbage permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>First Major Challenge: It&rsquo;s All About Garbage</h2>
<p>The first major challenge facing the Multicore team was OCaml&rsquo;s garbage collector. In OCaml, there are two programs working together on the heap, the language and the garbage collector. If the language supports parallelism but the garbage collector does not, the language would run fast just to be slowed down by the garbage collector.</p>
<p>To avoid this problem, the team made the garbage collector support parallelism to give users a uniformly smooth experience. &ldquo;Garbage collectors balance memory usage at the cost of time, so you can either have it use a small amount of memory but take a long time, or be fast but use a lot of memory,&rdquo; KC comments.</p>
<p>With different variables to optimise for, the team had to make some crucial decisions. OCaml already had a user base with certain expectations. They had to ensure that their changes did not remove features that users had come to expect. For example, OCaml is a <a href="https://ocaml.org/about">robust and predictable language</a>, and they needed to replace the garbage collector without sacrificing on that predictability. They also didn&rsquo;t want to settle for worse results in terms of performance.</p>
<p>Working on the new garbage collector, the team built an initial version that performed very well. However, they soon discovered that in order for the garbage collector to work, it would break the existing Application Programming Interface (API) interacting with C code.</p>
<blockquote>
<p>&ldquo;That was our dilemma: we had a nice, fast, garbage collector, but it would break people&rsquo;s code.&rdquo;</p>
</blockquote>
<p>A broken API would have been bad news for anyone, but it would especially affect any existing projects that relied heavily on C code (like Coq), as well as many industrial users who would have had to change millions of lines of code. The team worried that this would create a fork in the community, between those who would find it worth the upgrade and those who would not.</p>
<p>This was a big lesson for the team: user friendliness is incredibly important when introducing new technologies, and a big part of user friendliness is backwards compatibility. With this in mind, they set out to redesign the garbage collector. Although they were initially resigned to sacrifice some performance for the sake of compatibility, they ended up with a final product that not only did not break any code, but also didn&rsquo;t see significant performance losses! They <a href="https://icfp20.sigplan.org/details/icfp-2020-papers/21/Retrofitting-Parallelism-onto-OCaml">presented their findings</a>  at ICFP 2020 and won the distinguished paper award.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#second-major-challenge-memory-model-what-memory-model" aria-label="second major challenge memory model what memory model permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Second Major Challenge: Memory Model, What Memory Model?</h2>
<p>The second challenge came as a result of the very way computers are constructed. Unsurprisingly, the hardware that actually executes your code predates the multicore era. Consequently, the hardware and compilers running the code are designed to make optimisations based on the assumption that you&rsquo;re running a single-threaded (so not multicore) program.</p>
<p>As you might imagine, several of these optimisations conflict with more modern, multicore aspects of code. In order for multicore code to run successfully in the face of these optimisations, useful abstractions are needed to determine what is safe and how parallel code is expected to run. These abstractions are called <a href="http://canonical.org/~kragen/memory-models/">memory models</a>, and they are necessary for hardware made for single-threaded programs to run multi-threaded code.</p>
<p>Memory models are very complex and have to balance simplicity with performance. The more straight-forward the model, the greater the risk that it can&rsquo;t account for all possibilities, and therefore cause bugs. Conversely, if the memory model is complex enough to maximise performance, it will be hard for people to understand and use.</p>
<p>For the Multicore OCaml Project, the team decided to take inspiration from the memory models of <a href="https://cplusplus.com">C++</a> and <a href="https://www.java.com/en/">Java</a>, which choose to prioritise performance. However, they still wanted to make a memory model that was straightforward and intuitive. &ldquo;OCaml is used to prove other languages, and if the memory model is too complicated, it becomes hard to verify other parallel programs,&rdquo; KC explains.</p>
<p>By sacrificing a small amount of performance (around 3%), the team managed to create an <a href="https://kcsrk.info/webman/manual/memorymodel.html">OCaml memory model</a> that was both high-performing and easy-to-use. The paper detailing the process is called <a href="https://kcsrk.info/papers/pldi18-memory.pdf"><em>Bounding Data Races in Space and Time</em></a>.</p>
<p>In two of the big technological challenges that faced the team, a clear focus on user experience emerged. As a language with deep roots in academia, at times rumoured to be &lsquo;difficult,&rsquo; focusing on improving user experience is an important part of making OCaml a language for everyone.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#the-people-behind-the-project" aria-label="the people behind the project permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The People Behind the Project</h2>
<p>Behind every project is a group of hardworking people. Stephen Dolan, Leo White, and Anil Madhavapeddy started the Multicore project back in 2014. Until 2018, KC, Stephen, and Leo were doing most of the hacking. After 2018, the team saw enormous growth with Sadiq Jaffer and Tom Kelly working together on the garbage collector. Today, there are around ten people hacking on Multicore OCaml at any given time, all working hard to ensure that OCaml 5 is a success.</p>
<p>The open-source community has also provided continuous, valuable feedback as work on Multicore OCaml has progressed. Every person who participates by sharing their opinions and experience helps the project more forward. Many core OCaml developers worked tirelessly to get OCaml 5.0 release ready. In particular we should highlight the support of Xavier Leroy, who spent a considerable amount of time and effort implementing changes to important pieces in the runtime to make them multicore compatible (such as closure representation, bytecode interpreter, etc.), as well as Gabriel Scherer for his enthusiastic support of Multicore features and the willingness to do an enormous amount of crucial work like reviewing a large number of Multicore PRs and additional features. The academic community has also actively utilised Multicore OCaml to push the boundaries of what is possible with effect handlers, and provided useful feedback and bug reports.</p>
<p>On the commercial side, Tezos has significantly helped the team test OCaml 5 by using multicore features for their tools <a href="https://tarides.com/blog/2022-12-20-how-nomadic-labs-used-multicore-processing-to-create-a-faster-blockchain">PLONK prover</a>. They&rsquo;ve made good progress using OCaml 5 and have been extremely helpful by reporting on bugs and their experience.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#sandmark" aria-label="sandmark permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sandmark</h2>
<p>Over the course of OCaml Multicore&rsquo;s implementation, new tools have been developed to facilitate its creation. These tools are useful in and of themselves, and can be used in other projects. One tool born out of the OCaml Multicore push is the benchmarking suite <a href="https://github.com/ocaml-bench/sandmark">Sandmark</a>.</p>
<p>When Sadiq and Tom were working on the garbage collector, they had to understand how the change to a parallel garbage collector would affect non-parallel, sequential programs. To this end, they created Sandmark to benchmark different iterations.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#where-do-we-go-from-here" aria-label="where do we go from here permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Where Do We Go from Here?</h2>
<p>OCaml 5 is just the beginning, and from its release springs countless more opportunities. Several teams across the community are innovating on new features for OCaml. These features are at various levels of maturity and development, with small groups of developers testing some of them, whilst others are more or less in the ideation phase. Some of these features in development are listed below, but this is by no means an exhaustive list:</p>
<ul>
<li>Effects system: At the moment, there is no support from the OCaml type system to ensure that effect handlers are handled properly. An effect system is an extension of the type system that keeps track of which effects can be performed by an expression or a function, ensuring that effects are only performed in a context where a corresponding effect handler is set up to deal with them. In a language as well-established and large as OCaml, implementing new features comes with significant considerations. Backwards compatibility is a must, and the new system must work with the polymorphism, modularity, and generativity features already in place. For an early exploration of typed effect handlers in OCaml, check out <a href="https://www.janestreet.com/tech-talks/effective-programming/">Leo White's talk</a> from 2018.</li>
<li>JavaScript: OCaml has a very nice compiler to <a href="https://www.javascript.com">JavaScript</a>, but it couldn't compile effect handlers to JavaScript. Indeed, JavaScript does not provide a corresponding feature. A standard way to translate effect handlers is to transform the code into the so-called continuation-passing style (CPS). Functions require an extra argument: a one-argument continuation function. Instead of returning a result value, they call the continuation with this value. By making continuations explicit, one can then explicitly manipulate the control flow of the program, which makes it possible to support effect handlers. Js_of_ocaml has been recently modified to support effect handlers using this approach. This <a href="https://github.com/ocsigen/js_of_ocaml/pull/1340">preliminary implementation</a> has been released in <a href="https://discuss.ocaml.org/t/ann-js-of-ocaml-5-0/11008">Js_of_ocaml 5.0</a>. It has provided their team with a good understanding of how effect handlers work and what technical difficulties exist when supporting them in a compiler targeting JavaScript. However, CPS transformation comes with an important negative impact on performance. The team then implemented a <a href="https://github.com/ocsigen/js_of_ocaml/pull/1384">partial CPS transform</a> that removed some of the overheads with the CPS transformation. There are still some overheads due to CPS conversion that can be eliminated with smarter analysis and transformation. The team is considering trying alternative compilation techniques to support effect handlers. For example, there are implementation strategies that should have low overhead as long as no effect is performed at the cost of making effect handling slower. However, this might make the generated code much larger. The CPS-based implementation provides them with a point of comparison for undertaking this work.</li>
<li><a href="https://github.com/ocaml-flambda/ocaml-jst/tree/main/jane/doc">Local Allocations</a>: implemented by Stephen Dolan and Leo White: This feature adds support for stack-allocated blocks. It enforces memory safety by requiring that heap-allocated blocks never point to stack-allocated blocks, and stack-allocated blocks never point to shorter-lived stack-allocated blocks. This is a big addition to OCaml&rsquo;s type system and is still under development.</li>
<li>Unboxed Types: Currently in OCaml, all fields of a structure store values in a single-machine word. This word is further restricted by having to either point to a garbage-collected memory or be tagged to denote that the garbage collector should skip it.  Unboxed types relax this restriction, allowing a field to hold values smaller or larger than a word. This can be used to save memory and to improve performances by avoiding some pointer dereferencing. To find out more, read the <a href="https://github.com/ocaml/RFCs/pull/34">proposal on unboxed types</a> on GitHub.</li>
</ul>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#the-legacy" aria-label="the legacy permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Legacy</h2>
<p>The Multicore OCaml project has been full of challenges, successes, and surprises. Along the way, the team has developed and grown, learning important lessons and adapted their approach to best suit the needs of all OCaml users.</p>
<p>Making the leap from research to product is a complex process that takes time to execute properly. In computer science, it can take decades to get right. It&rsquo;s a massive achievement to get a revolutionary update like OCaml Multicore from concept to finished product in less than 8 years.</p>
<p>It&rsquo;s also an update suitable for everyone. Users who don&rsquo;t have a need for multicore features can carry on using OCaml like they always have, benefitting from other OCaml 5 features without having to change a line of code. On the other hand, the significant number of people who have long awaited the update can now benefit from having OCaml and all its strengths on multiple cores.</p>
<p>The story of OCaml Multicore is one of hard work and a dedication to learning. It speaks to anyone with a passion project that seems too innovative or experimental to succeed. With a strong team and a flexible, problem-solving approach, theory can quickly become reality.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#acknowledgements" aria-label="acknowledgements permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Acknowledgements</h2>
<p>A big thank you to KC Sivaramakrishnan, without whom this article would not be possible. Further thanks goes to Jer&ocirc;me Vouillon and Leo White for their expertise and contributions to the &lsquo;where do we go from here&rsquo; section of the article.</p>
<blockquote>
<p><a href="https://tarides.com/company">Contact Tarides</a> to see how OCaml can benefit your business and/or for support while learning OCaml. Follow us on <a href="https://twitter.com/tarides_">Twitter</a> and <a href="https://www.linkedin.com/company/tarides/">LinkedIn</a> to ensure you never miss a post, and join the OCaml discussion on <a href="https://discuss.ocaml.org/">Discuss</a>!</p>
</blockquote>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#sources-and-further-reading" aria-label="sources and further reading permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sources and Further Reading</h2>
<ul>
<li>
<p>A collection of libraries, experiments, and ideas relating to OCaml 5: <a href="https://github.com/ocaml-multicore/awesome-multicore-ocaml">https://github.com/ocaml-multicore/awesome-multicore-ocaml</a></p>
</li>
<li>
<p>A wiki for Multicore OCaml. Note that it's not currently being maintained, so whilst it has much useful information, some migh be outdated: <a href="https://github.com/ocaml-multicore/ocaml-multicore/wiki">https://github.com/ocaml-multicore/ocaml-multicore/wiki</a></p>
</li>
<li>
<p>Information on Effect Handlers: <a href="https://kcsrk.info/webman/manual/effects.html">https://kcsrk.info/webman/manual/effects.html</a></p>
</li>
<li>
<p>Information on Parallelism: <a href="https://kcsrk.info/webman/manual/parallelism.html">https://kcsrk.info/webman/manual/parallelism.html</a></p>
</li>
<li>
<p>Information on Memory Models: <a href="https://kcsrk.info/webman/manual/memorymodel.html">https://kcsrk.info/webman/manual/memorymodel.html</a></p>
</li>
<li>
<p>Academic publications pertaining to OCaml Multicore: <a href="https://github.com/ocaml-multicore/awesome-multicore-ocaml#papers">https://github.com/ocaml-multicore/awesome-multicore-ocaml#papers</a></p>
</li>
<li>
<p>OCaml&rsquo;s home on the web: <a href="https://ocaml.org">https://ocaml.org</a></p>
</li>
</ul>
