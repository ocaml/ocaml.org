---
title: Making OCaml 5 Succeed for Developers and Organisations
description: "OCaml recently won the ACM SIGPLAN PL Software Award. The award recognises
  a software system that has had a significant impact on\u2026"
url: https://tarides.com/blog/2023-07-07-making-ocaml-5-succeed-for-developers-and-organisations
date: 2023-07-07T00:00:00-00:00
preview_image: https://tarides.com/static/71303e9b0247fa3f8902a886efde6bfc/0132d/ocaml_caravan.jpg
authors:
- Tarides
source:
---

<p>OCaml recently won the <a href="https://tarides.com/blog/2023-06-20-ocaml-receives-the-acm-programming-languages-software-award/">ACM SIGPLAN PL Software Award</a>. The award recognises a software system that has had a significant impact on programming language implementation, research, and tools. It is especially notable that <a href="https://twitter.com/kc_srk/status/1670849062684467202/photo/3">4 out of the 14</a> named OCaml compiler developers are affiliated with Tarides: Anil, David, J&eacute;r&ocirc;me, and me. In this post, I discuss the wider effort afoot at Tarides in order to make OCaml 5, the latest release of the OCaml programming language, succeed for developers. I should note that I shall specifically focus on the new OCaml 5 features and omit important developments such as Tarides' work on the OCaml platform, which is discussed <a href="https://discuss.ocaml.org/t/a-roadmap-for-the-ocaml-platform-seeking-your-feedback/12238">elsewhere</a>.</p>
<p>I started hacking on OCaml when I joined Anil, Stephen, and Leo (who are also named in this award) at OCaml Labs in the University of Cambridge in 2014 to work on the Multicore OCaml project. The aim of the Multicore OCaml project was to add native support for concurrency and parallelism to the OCaml programming language. Multicore OCaml compiler was maintained as a fork of the OCaml compiler for many years before it merged with the mainline OCaml compiler in <a href="https://github.com/ocaml/ocaml/pull/10831">January 2022</a>. After almost a year of work stabilising the features, OCaml 5.0 was finally released in <a href="https://discuss.ocaml.org/t/ocaml-5-0-0-is-out/10974">December 2022</a>, nearly 8 years after the first commit.</p>
<p>Has the Multicore OCaml project succeeded with the release of OCaml 5.0? The short answer is <em><strong>No</strong></em>. There is a long road to making OCaml 5 succeed for the developers. The goal of making OCaml 5 succeed for the developers is a two-step process:</p>
<ol>
<li>Help developers transition existing programs to OCaml 5</li>
<li>Help developers take advantage of new concurrency and parallelism features in OCaml 5</li>
</ol>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#transitioning-developers-to-ocaml-5" aria-label="transitioning developers to ocaml 5 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transitioning developers to OCaml 5</h2>
<p>Even with the arrival of OCaml 5, most OCaml programs will remain sequential forever. It is important that developers can successfully transition their OCaml projects over to OCaml 5, even if they don't plan to use the new features. We have carefully designed OCaml 5 such that the breaking changes are minimized. In particular, we eschewed a potentially more scalable GC design since it broke the C FFI compatibility (see section 7 &quot;Discussion&quot; in the <a href="https://kcsrk.info/papers/retro-parallel_icfp_20.pdf">ICFP 2020 paper</a> on the new GC design). The only breaking changes in OCaml 5 were the removal of the support for naked pointers and the unrelated removal of deprecated functions from the standard library. We released a <a href="https://discuss.ocaml.org/t/ann-a-dynamic-checker-for-detecting-naked-pointers/5805">dynamic detector for naked pointers</a> to help developers find and remove naked pointers from their codebase.</p>
<h3 style="position:relative;"><a href="https://tarides.com/feed.xml#restoring-unimplemented-features" aria-label="restoring unimplemented features permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Restoring Unimplemented Features</h3>
<p>OCaml 5.0 was an experimental release with many features unimplemented. In particular, OCaml 5.0 only supported the <a href="https://github.com/ocaml/ocaml/pull/10831">x86</a> and <a href="https://github.com/ocaml/ocaml/pull/10972">ARM</a> backends. With impressive efforts from the community, the OCaml maintainers have <strong>restored support for All Tier 1 platforms</strong> including <a href="https://github.com/ocaml/ocaml/pull/11418">RISC-V</a>, <a href="https://github.com/ocaml/ocaml/pull/11712">s390x</a> and <a href="https://github.com/ocaml/ocaml/pull/12276">Power</a>. Tarides helped implement or review the support for all of these backends. Tarides engineers also restored other important features such as <a href="https://github.com/ocaml/ocaml/pull/11827">GC mark loop pre-fetching</a> and <a href="https://github.com/ocaml/ocaml/pull/11144">frame-pointer support for x86 backend</a>. These features will be in OCaml 5.1.</p>
<p>We have also been working on restoring other big-ticket items such as compaction and <code>statmemprof</code> which were not implemented for OCaml 5.0. In OCaml, compaction is the only time when the runtime releases memory allocated for the heap back to the operating system. Many long-running programs have an initialisation phase where they use a lot of memory followed by a steady state phase where they operate for a long time with less memory. It is a common practice to call <code>Gc.compact()</code> after the initialisation phase so that the steady-state memory usage of the program remains low. Without compaction, the steady state will also use as much memory as the peak memory usage. This problem was <a href="https://discuss.ocaml.org/t/ocaml-5-gc-releasing-memory-back-to-the-os/11293">reported</a> by the <a href="https://fbinfer.com/">Infer</a> team at Meta (who were otherwise able to switch to OCaml 5 easily, thanks to our focus on backwards compatibility).</p>
<p>Tarides engineers have <a href="https://github.com/ocaml/ocaml/pull/12193">opened a PR</a> for restoring compaction. The compaction feature is slated to be restored in OCaml 5.2. We have also been working on restoring <code>statmemprof</code>, the statistical memory profiler for OCaml. We are hoping to have a PR ready for this in the coming weeks.</p>
<h3 style="position:relative;"><a href="https://tarides.com/feed.xml#fixing-performance-regressions" aria-label="fixing performance regressions permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fixing Performance Regressions</h3>
<p>OCaml 5 is a major rewrite of the runtime system and comes with a completely new allocator and a garbage collector (GC). As a result, some large OCaml projects such as <a href="https://github.com/ocaml/ocaml/issues/11662">Frama-C</a>, <a href="https://github.com/ocaml/ocaml/issues/11913">Pyre</a>, <a href="https://github.com/EasyCrypt/easycrypt/issues/390">EasyCrypt</a>, and <a href="https://discuss.ocaml.org/t/ocaml-5-gc-releasing-memory-back-to-the-os/11293/16">Infer</a> have reported performance regressions. We have been steadily fixing these issues and have not encountered any serious challenges here. Many of the fixes have been incorporated into 5.1, and we expect more performance fixes to land in 5.2. The very fact that large open-source projects can build and test their code on OCaml 5 is itself a testament to our careful backwards-compatible implementation of OCaml 5.</p>
<h4 style="position:relative;"><a href="https://tarides.com/feed.xml#allocator-performance" aria-label="allocator performance permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Allocator Performance</h4>
<p>A potential source of performance regressions is the allocator. OCaml 5 uses a new parallelism-aware allocator written from scratch and different from the well-performing best-fit allocator available in OCaml since 4.10. Major industrial users of OCaml have <a href="https://blog.janestreet.com/memory-allocator-showdown/">reported</a> that best-fit performs better than the earlier first-fit and next-fit allocators. In our benchmarking efforts, we observed that OCaml 5 allocator performs as well as the best-fit allocator, as both allocators utilise size-segmented pages for the allocator. But <a href="https://github.com/ocaml-bench/sandmark/tree/main/benchmarks">our benchmarks</a> are admittedly much smaller than industrial OCaml workloads.</p>
<p>In order to derisk the transition to OCaml 5, we have <a href="https://github.com/sadiqj/ocaml/tree/backport_alloc">backported</a> the OCaml 5 allocator to OCaml 4 compiler. The backported allocator helps industrial users run their workloads in OCaml 4 with only the allocator changed, which helps identify any regressions. We are working with one of our customers to test the backported allocator on their internal workloads. We hope to identify regressions that only show up at scale and fix them for everyone using OCaml 5.</p>
<h3 style="position:relative;"><a href="https://tarides.com/feed.xml#continuously-benchmarking-compiler-quality" aria-label="continuously benchmarking compiler quality permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Continuously Benchmarking Compiler Quality</h3>
<p>One of the goals of OCaml 5 is that, for sequential programs, the performance of those programs running on OCaml 5 is no worse than running on OCaml 4. Not only can the developers compile and run their existing sequential code in OCaml 5, but the expectation is that the performance is also similar.
To this end, we have been doing nightly benchmarking of compiled code using <a href="https://sandmark.tarides.com/">Sandmark</a>, a benchmarking service consisting of real-world, open-source OCaml programs. Sandmark monitors a multitude of performance parameters related to running time, memory usage, and GC latency.</p>
<p>The benchmarks and the related repository of OCaml packages are constructed in such a way that they can build with both OCaml 4 and OCaml 5. This lets the compiler developers quickly identify any regressions that may be introduced in OCaml 5 with respect to the <em>same code</em> compiled under OCaml 4. Tarides is working to turn this into a GitHub bot that will make it easier for compiler developers to trigger benchmarking runs on development branches.</p>
<h3 style="position:relative;"><a href="https://tarides.com/feed.xml#better-observability" aria-label="better observability permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Better Observability</h3>
<p>Another strong reason to move to OCaml 5 from OCaml 4, even if you plan to remain sequential, is the better observability tools that come with OCaml 5. Starting from OCaml 5, the compiler supports a new feature named <a href="https://v2.ocaml.org/manual/runtime-tracing.html"><em>runtime events</em></a>, which brings deep introspection capabilities for OCaml programs running in production. Runtime events add a series of probes to the OCaml program that emits data at specific events. This lets the <em>consumers</em> of these events produce interesting insights into the running programs. For example, <a href="https://github.com/tarides/runtime_events_tools/tree/main#olly">Olly</a> is a consumer that reports GC statistics including latency distribution. Olly can also produce traces of OCaml program runs visualising the GC behaviours.</p>
<p>An important aspect of runtime events is that the cost of the probes in the fast path (when the probes are not emitting data) is so low that it is available for every OCaml 5 program. In particular, you do not need to recompile your programs with special options to enable event collection. Hence, every OCaml 5 program can be introspected at runtime for interesting events using Olly.</p>
<p>By default, the only probes available are to do with GC events. OCaml 5.1 also brings in support for <a href="https://github.com/ocaml/ocaml/pull/11474"><em>Custom events</em></a>, where the user can describe new probes. It unlocks exciting possibilities for application-specific introspection. For example, <a href="https://github.com/tarides/meio">Meio</a> is a command-line tool that lets the user monitor the status of their application built using <a href="https://github.com/ocaml-multicore/eio">Eio</a>, a new concurrency library built using OCaml 5 features, at a per fiber (lightweight task) granularity.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#taking-advantage-of-ocaml-5-features" aria-label="taking advantage of ocaml 5 features permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Taking Advantage of OCaml 5 Features</h2>
<p>We anticipate two kinds of developers to take advantage of OCaml 5:</p>
<ol>
<li>Those who want to use the new features in their existing code.</li>
<li>Those who want to write new code using the new features.</li>
</ol>
<p>There is an increase of positive noise around OCaml recently, which may attract new developers and organisations to OCaml. However, given the millions of lines of existing OCaml code, our aim is to tackle (1) first. We hope that the experience of helping (1) succeed will inform what we should focus on for (2).</p>
<h3 style="position:relative;"><a href="https://tarides.com/feed.xml#primitive-features" aria-label="primitive features permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Primitive Features</h3>
<p>It is important at this point to note that OCaml 5 brings in distinct features for native concurrency and parallelism support in OCaml. For concurrency, OCaml 5 adds <em>effect handlers</em>, and for parallelism, it adds <em>domains</em> to the language. These features are spartan by design, and our aim is to build expressive libraries on top of these features, which will live outside the compiler distribution. The OCaml manual pages on <a href="https://v2.ocaml.org/manual/effects.html">effect handlers</a> and <a href="https://v2.ocaml.org/manual/parallelism.html">parallelism</a> give a good overview of these primitive features. I also discuss the approach we've taken in retrofitting concurrency to OCaml in the <a href="https://icfp22.sigplan.org/details/icfp-2022-papers/48/Retrofitting-Concurrency-Lessons-from-the-Engine-Room">ICFP 2022 Keynote</a>.</p>
<h3 style="position:relative;"><a href="https://tarides.com/feed.xml#concurrency-libraries" aria-label="concurrency libraries permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Concurrency Libraries</h3>
<h4 style="position:relative;"><a href="https://tarides.com/feed.xml#eio----io-library" aria-label="eio    io library permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Eio -- I/O Library</h4>
<p>For asynchronous, non-blocking I/O, OCaml 4 has two industrial-strength libraries such as Lwt and Async. These libraries simulate concurrency using a monad. They are both very successful, and OCaml code that does asynchronous I/O uses one of these libraries. These libraries do have some downsides in that, due to the use of a monad, they don't produce useful backtraces, and OCaml's built-in exceptions cannot be used. The separation of synchronous and asynchronous code (function colours) and the lack of easy-to-use, higher-kinded polymorphism in OCaml means that one ends up with two versions of useful functions: one for monadic code and another for non-monadic code. This leads to code duplication such as the need to have a separate <a href="https://ocsigen.org/lwt/latest/api/Lwt_list">Lwt's list module</a>. These libraries can continue to be used in OCaml 5, but given that these libraries are not parallelism-safe, one cannot write parallel code that takes advantage of them out of the box.</p>
<p><a href="https://github.com/ocaml-multicore/eio">Eio</a> is a new direct-style I/O library built using effect handlers. It avoids function colouring by using native stacks provided by effect handlers, unlike Lwt and Async which simulate it using a monad. Thanks to this, Eio produces faster code, supports built-in exceptions, produces good backtraces, and avoids code duplication. Eio also is built to be parallelism-safe. Eio provides a generic cross-platform API that can utilise optimised backends on different platforms such as <a href="https://en.wikipedia.org/wiki/Io_uring">io_uring on Linux</a>.</p>
<p>One particular aspect that I would like to highlight is that Eio provides bridges for Async and Lwt so that existing code can be <em>incrementally</em> translated to Eio. This aspect is crucial for adoption, as we believe that it is impractical to translate a large Lwt or Async codebase over to Eio in one go. Tarides is currently working towards the goal of <a href="https://github.com/ocaml-multicore/eio/issues/388">Eio 1.0</a>, which we expect to be released by Q3 2023. If you are interested in using Eio, Tarides engineers are running <a href="https://icfp23.sigplan.org/details/icfp-2023-tutorials/4/Porting-Lwt-applications-to-OCaml-5-and-Eio">a hands-on tutorial</a> on porting Lwt applications over to Eio at ICFP 2023.</p>
<h4 style="position:relative;"><a href="https://tarides.com/feed.xml#saturn----parallel-data-structures" aria-label="saturn    parallel data structures permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Saturn -- Parallel Data Structures</h4>
<p>An essential component in the parallel programming toolkit is a library of parallel data structures. A sequential stack or queue data structure is fairly uncontroversial, and it is common to have only a single stack or queue implementation in the language. Indeed, we have a single <a href="https://v2.ocaml.org/api/Stack.html">stack</a> and a single <a href="https://v2.ocaml.org/api/Queue.html">queue</a> data structure in the OCaml standard library. The addition of parallelism brings an explosion of possibilities and challenges:</p>
<ul>
<li><strong>Correctness</strong> -- the addition of concurrency makes it much harder to reason about the correctness of the data structures.</li>
<li><strong>Specialisation</strong> -- the performance of the data structure varies widely based on the number of parallel threads accessing the data structure. Hence, it is common to have specialised data structures that are optimised for a limited number of threads and capacity, such as single or multiple producers and consumers to bounded or unbounded queues.</li>
<li><strong>Progress</strong> -- Should a pop operation on an empty queue block the caller or should it return immediately with a <code>None</code>? Both options are useful in different circumstances, but supporting one or the other will mean very different tradeoffs and hence, different implementations. Moreover, the non-blocking options are <a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm">further classified</a> in literature based on the progress in the presence of concurrent operations.</li>
<li><strong>Composability</strong> -- In a typical parallel data structure each of the individual operations such as a push or a pop is atomic. What if our application demands that multiple operations be performed atomically? Putting a lock around the entire thing does not often work since it affects performance non-trivially and introduces correctness issues such as deadlocks. There are other mechanisms for well-behaved composition such as software transactional memory.</li>
</ul>
<p>In other languages, this explosion in the state space often leads to a multitude of concurrency libraries, with overlapping features and different trade-offs, often not clearly labelled. Developers frequently face a challenge choosing the right library with the right trade-off. The correctness of the implementations is also often unclear.</p>
<p>At Tarides, we have been working towards <a href="https://github.com/ocaml-multicore/lockfree/pull/67">Saturn</a>, a library that brings together all of our efforts at building parallelism-safe libraries. Saturn will consist of lock-free and lock-based, blocking and non-blocking, composable and non-composable parallel data structures under one roof. Each of the different data structures will have a default version that is good enough to be used for parallelism and will have well-documented variants with clearly labelled tradeoffs.</p>
<p>Our composable atomic data structures are built over the <a href="https://github.com/ocaml-multicore/kcas">kcas</a> library which provides a software transactional memory (STM) on top of lock-free multi-word compare-and-swap (MCAS) primitive. While the kcas library implements MCAS in software efficiently, with the arrival of <a href="https://github.com/ocaml/ocaml/pull/12276">Power backend in OCaml 5</a>, we plan to explore the promise to utilise <a href="https://research.ibm.com/publications/transactional-memory-support-in-the-ibm-power8-processor">hardware transactions</a> for MCAS.</p>
<p>To ensure correctness, Saturn data structures are model-checked using <a href="https://github.com/ocaml-multicore/dscheck">dscheck</a>, an experimental model checker for OCaml that cleverly exploits effect handlers to mock and control parallel scheduling. We also plan to <a href="https://autumn.ocamllabs.io/">continuously benchmark</a> the data structure to monitor any performance regressions. We expect Saturn to be released in Q3 2023.</p>
<h4 style="position:relative;"><a href="https://tarides.com/feed.xml#domain-local-await" aria-label="domain local await permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Domain-Local Await</h4>
<p>With OCaml 5, there are several notions of concurrency:</p>
<ul>
<li>Domains -- OS threads potentially running in parallel on different cores</li>
<li>Systhreads -- OS threads on a given domain that timeshare a domain</li>
<li>Fibers -- Lightweight, language-level threads implemented by the concurrency library. Each concurrency library may have its own scheduler.</li>
</ul>
<p>This makes the task of writing blocking data structures, such as blocking channels, challenging because the blocking mechanism is specific to each notion of concurrency. Ideally, we would like to write blocking data structures that are parametric over the blocking mechanism so that we can describe blocking channels once and for all of the different notions of concurrency.</p>
<p>To this end, Tarides has been developing <a href="https://github.com/ocaml-multicore/domain-local-await">domain-local await</a> (DLA), a scheduler-independent mechanism for blocking. The goal is that concurrency libraries provide the implementation of the DLA interface, and with this, they can use blocking data structures from Saturn. For example, with the <a href="https://github.com/ocaml-multicore/eio/pull/494">implementation of a DLA interface in Eio</a>, it is able to utilise <a href="https://github.com/ocaml-multicore/kcas/pull/32">blocking transactions in kcas</a>. By separating out the blocking mechanism from the blocking data structures, different concurrency libraries such as <code>eio</code> and <a href="https://github.com/ocaml-multicore/domainslib"><code>domainslib</code></a> may communicate easily. At Tarides, we are exploring other scheduler-independent mechanisms for <a href="https://github.com/ocaml-multicore/domain-local-timeout"><code>timeout</code></a> and <a href="https://github.com/polytypic/io"><code>io</code></a>.</p>
<h3 style="position:relative;"><a href="https://tarides.com/feed.xml#multicore-testing-tools" aria-label="multicore testing tools permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multicore Testing Tools</h3>
<p>The task of moving a large OCaml codebase to take advantage of new OCaml 5 features may seem daunting. It is likely that none of the existing code was written with concurrency and parallelism in mind. Tarides has been working to empower software engineers with multicore testing tools in order to ease the process of using the new OCaml 5 features.</p>
<h4 style="position:relative;"><a href="https://tarides.com/feed.xml#thread-sanitizer" aria-label="thread sanitizer permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Thread Sanitizer</h4>
<p>When parallelism is introduced in a code base, there is the risk of introducing <em>data races</em>. A data race is said to occur when there are two accesses to a memory location, with at least one of them being a write, and there is no synchronisation between the accesses. For example, the following program:</p>
<div class="gatsby-highlight" data-language="ocaml="><pre class="language-ocaml="><code class="language-ocaml=">let r = ref 0
let d = Domain.spawn (fun _ -&gt; r := 1)
let v = !r</code></pre></div>
<p>has a data race, since the main domain and the newly spawned domain <code>d</code> race to access the reference <code>r</code>, and there is no synchronisation between the accesses.</p>
<p>As a pragmatic language, OCaml encourages the use of mutable state with primitive operations such as reference cells, mutable record fields, arrays, and standard library data structures such as hash tables, stacks, and queues with in-place modification. Thus, it is likely that the addition of parallelism to an OCaml code base will introduce data races.</p>
<p>In C++, the behaviour of a program with data races is undefined. In OCaml, the situation is much better. OCaml programs with data races have <a href="https://v2.ocaml.org/manual/memorymodel.html">well-defined semantics</a>. In particular, a program with data races will not violate type safety and will not crash. That said, the programs with data races may produce behaviours that cannot be explained only by the interleaving of operations from different threads. Hence, it is important that data races are detected and removed from the code base.</p>
<p>To this end, Tarides has developed Thread Sanitizer (TSan) support for OCaml. TSan is an approach <a href="https://dl.acm.org/doi/10.1145/1791194.1791203">developed by Google</a> to locate data races originally for C++ code bases. It works by instrumenting executables to keep a history of previous memory accesses (at a certain performance cost) in order to detect data races, even when they have no visible effect on the execution. TSan instrumentation has been implemented in various compilers (GCC, Clang, as well as the Go and Swift compilers) and has proved very effective in detecting hundreds of concurrency bugs in large projects. Executables instrumented with TSan report data races <em>without false positives</em>. However, data races in code paths that are not visited will not be detected.</p>
<p>Tarides engineers have used TSan successfully to port large non-trivial code bases such as the work-in-prograss port of <a href="https://github.com/mirage/irmin">Irmin</a> to Multicore. The response from the developers using TSan has been overwhelmingly positive. A particularly attractive feature of TSan in OCaml is the ease of use. The developer merely needs to install a different compiler switch with TSan enabled, and without any additional work, TSan reports data races with accurate backtraces for the conflicting accesses. A <a href="https://github.com/ocaml/ocaml/pull/12114">PR</a> for adding TSan support for OCaml is currently open. TSan support for OCaml is likely to appear in OCaml 5.2.</p>
<h4 style="position:relative;"><a href="https://tarides.com/feed.xml#property-based-testing" aria-label="property based testing permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Property-Based Testing</h4>
<p>Data races are just one of the hazards of parallel programming. Even without data races, the program may produce different results across several runs due to non-determinism. How can the developers gain more confidence about the correctness of their implementations? To this end, we have been developing two property-based testing libraries namely <a href="https://github.com/ocaml-multicore/multicoretests">Lin and STM</a>.</p>
<p>In property-based testing, the programmer provides a specification about the program that should remain true and the system tests that the properties hold under a large number of different executions, typically randomly generated inputs. In the case of Lin and STM, the program is tested under different interleavings of domains. Lin tests whether the results obtained under parallel execution correspond to the same operations applied one after the other in a sequential execution. STM take a pure model description and compares the results to the actual results seen in a parallel execution.</p>
<p>Both libraries have been <a href="https://github.com/ocaml-multicore/multicoretests#issues">extremely effective</a> in identifying issues in the standard library under parallel execution. The OCaml standard library was implemented without parallel execution in mind. While much of the standard library is not parallelism-safe, we do not expect parallel access to the standard library to crash. Lin and STM have been particularly successful in identifying crashes. We believe that Lin and STM will help OCaml 5 developers gain more confidence that their code is correct under parallel execution.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#call-for-action" aria-label="call for action permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Call for Action</h2>
<p>If you have an existing OCaml code base, please try OCaml 5 today. If you find regressions, please file an issue on the <a href="https://github.com/ocaml/ocaml/issues/">OCaml GitHub repo</a>. If you are considering utilising the new OCaml 5 features, please give the concurrency libraries and the tools a go. We would love to hear whether the libraries and tools work for you. File issues in corresponding repos if you find anything that is amiss. If you are looking for commercial support on any of these topics, do not hesitate to <a href="https://tarides.com/company/">contact us</a>.</p>
<p>All of the work discussed in this post are open-source. If you wish to contribute to these efforts, please look for the &quot;good first issue&quot; tag in any of these repos. If you are looking to learn, please head over to the <a href="https://ocaml.org/community">community section</a> to ask us questions and share and discuss OCaml-related topics.</p>
<p>Happy hacking!</p>
