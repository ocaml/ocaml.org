---
title: 'How TSan Makes OCaml Better: Data Races Caught and Fixed'
description: "Parallel programming opens up brand-new possibilities. Using multiple
  cores means that users can benefit from powerful OCaml features (like\u2026"
url: https://tarides.com/blog/2024-08-21-how-tsan-makes-ocaml-better-data-races-caught-and-fixed
date: 2024-08-21T00:00:00-00:00
preview_image: https://tarides.com/static/d94062a4cb43502f6ca9bc8f4f151e21/0132d/toolswall.jpg
authors:
- Tarides
source:
---

<p>Parallel programming opens up brand-new possibilities. Using multiple cores means that users can benefit from powerful OCaml features (like formal proofs and high security) while enjoying greater performance, enabling them to <a href="https://tarides.com/blog/2022-12-20-how-nomadic-labs-used-multicore-processing-to-create-a-faster-blockchain/">improve their services or projects</a>.</p>
<p>However, introducing such a significant change to the OCaml ecosystem would not be practical without providing tools that help users ensure memory safety in parallel programming. This is where <a href="https://tarides.com/blog/2024-04-24-under-the-hood-developing-multicore-property-based-tests-for-ocaml-5/">multicore tests</a> come in, as does ThreadSanitizer (TSan) support for OCaml. We have published two previous posts on TSan, <a href="https://tarides.com/blog/2023-10-18-off-to-the-races-using-threadsanitizer-in-ocaml/">an overview of the tool</a> and an <a href="https://tarides.com/blog/2024-01-17-what-are-data-races-and-do-they-threaten-your-business/">introduction to the danger of data races in general</a>. This post will give you a behind-the-scenes look at how we have used TSan to find and fix races in the OCaml runtime. Official support for TSan arrived with OCaml 5.2, but as you can tell <a href="https://github.com/ocaml/ocaml/tree/trunk/testsuite/tests/tsan">from the repository</a>, we have been using TSan internally for a while now.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#catching-races-in-ocaml" aria-label="catching races in ocaml permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Catching Races in OCaml</h2>
<p>As a result of TSan coming with the <a href="https://tarides.com/blog/2024-05-15-the-ocaml-5-2-release-features-and-fixes/">OCaml 5.2 update</a>, several bug fixes in the same update addressed data races. A data race occurs when two accesses are made to the same memory location; at least one is a <code>write</code>, and no order is enforced between them. Data race bugs can be hard to spot, but since they can result in unexpected behaviours, they are a high-priority item to fix.</p>
<p>It is important to note that not all data races are equal. In OCaml, the memory model guarantees that memory safety is preserved even when data races occur. This makes data races in OCaml much 'safer' than in many other languages, where races can impact memory safety. OCaml programs also require support from the OCaml runtime which provides low-level operations such as memory allocation and garbage collection. The OCaml runtime is written in C and must be data race-free according to the C memory model since a data race in the runtime would impact the validity of the whole program. While TSan has been integrated to detect data races in OCaml code, it has also proven invaluable in detecting errors in OCaml's runtime, many of which were subsequently fixed in 5.2.</p>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#what-has-tsan-caught-so-far" aria-label="what has tsan caught so far permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What has TSan Caught so Far?</h2>
<p>Ecosystem contributors make continuous efforts towards maintenance, and as part of this work, use TSan to check the OCaml runtime. To further simplify TSan usage we have added a TSan Continuous Integration (CI) run that executes the OCaml test suite in a TSan-enabled switch, automatically detecting inadvertently introduced data races in the runtime. This has allowed us to catch and fix several data races.
Some of these include:</p>
<ul>
<li>
<p><strong>Fixing a Race in the Minor GC:</strong> PRs <a href="https://github.com/ocaml/ocaml/pull/12595">#12595</a> describes a race condition occurring when <code>caml_collect_gc_stats_sample</code> made calls to <code>domain_terminate</code>, and <a href="https://github.com/ocaml/ocaml/pull/12597">#12597</a> outlines the fix implemented in 5.2. In this data race, the internal garbage collector data could cause the program to report incorrect garbage collection statistics.</p>
</li>
<li>
<p><strong>Data Race Between Marking and Sweeping Garbage Collector Phases:</strong> PR <a href="https://github.com/ocaml/ocaml/pull/12934">#12934</a> fixes a <a href="https://github.com/ocaml/ocaml/issues/12916">race between marking and sweeping functions</a> caught by TSan. When the garbage collector marks a value for collection, sweeping code (a later phase of the GC, effectively marking unreachable values as free space) in another thread may read the value simultaneously. This is normal behaviour, but the memory read was not marked as an atomic operation as it should have been, introducing a risk of undefined behaviour.</p>
</li>
<li>
<p><strong>Data Race on Global Pools Arrays:</strong> PR <a href="https://github.com/ocaml/ocaml/pull/12755">#12755</a> addresses races on <code>global_avail_pools</code> and <code>global_full_pools</code> members of the <code>struct pool_freelist</code> in <code>shared_heap.c</code>.<br>
For performance reasons, OCaml's runtime allocates major heap memory in chunks stored in pools that can be recycled across domains. While the algorithm for accessing them in parallel was correct, atomic qualifiers and explicitly qualified memory operations were missing, causing TSan to report unsynchronised memory accesses. The PR adds the necessary qualifiers.</p>
</li>
<li>
<p><strong>Data Races in <code>minor_gc.c</code>:</strong> This <a href="https://github.com/ocaml/ocaml/pull/12737">PR #12737</a> fixes two races. One in the minor GC occurring when promoting values in the remembered set, and one in the <code>Dynlink</code> library happening due to an incorrect C function trying to access an OCaml value even when the garbage collector might be running.</p>
</li>
<li>
<p><strong>Data Race fix for #12799:</strong> PR <a href="https://github.com/ocaml/ocaml/pull/12851">#12851</a> fixes a bug described in issue <a href="https://github.com/ocaml/ocaml/issues/12799">#12799</a>. When a <a href="https://v2.ocaml.org/manual/parallelism.html#s:par_domains">domain</a> terminates, it emits a <a href="https://ocaml.org/manual/5.1/runtime.html">runtime event</a> â€“ a piece of information that can be monitored using a dedicated API to debug or profile the performance of OCaml programs. However, under certain circumstances, the emission of this event could race with the shutdown of the runtime events system itself, possibly leading to incorrect information being emitted or, worse, memory corruption. Proper synchronisation has been implemented to ensure this doesn't happen.</p>
</li>
<li>
<p><strong>Data Race When Using the Debug Runtime:</strong> PR <a href="https://github.com/ocaml/ocaml/pull/12969">#12969</a> resolves a data race involving <code>caml_scan_stack</code> and <code>caml_free_stack</code>. It was possible for two <a href="https://ocaml.org/manual/5.1/parallelism.html#s:par_domains">domains</a> to perform a garbage collector marking on the same <a href="https://ocaml.org/manual/5.1/effects.html#s:effects-fibers">fibre</a>, and in very rare cases when that fibre was terminating. This caused TSan to report a data race. While the code was correct in practice, we fixed the access to make it correct according to the C11 memory model, thus avoiding undefined behaviour.</p>
</li>
</ul>
<h2 style="position:relative;"><a href="https://tarides.com/feed.xml#until-next-time" aria-label="until next time permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Until Next Time!</h2>
<p>Seeing a tool we have developed so quickly benefit the larger ecosystem is excellent. TSan helps developers test their parallel programs for potential risks they would have difficulty discovering. We look forward to seeing users put TSan to the test and share the results!</p>
<p>The OCaml community welcomes contributions and feedback and invites users to share any issues in the <a href="https://github.com/ocaml/ocaml">OCaml GitHub repo</a>. The discussion forum <a href="https://discuss.ocaml.org/">OCaml Discuss</a> is another place to share your thoughts and get input from others in the community.</p>
<p>Would you like to stay up-to-date with us? Follow us on <a href="https://twitter.com/tarides_">X</a> (formerly known as Twitter) and <a href="https://www.linkedin.com/company/tarides">LinkedIn</a> to see regular posts on our projects, announcements, tutorials, and more.</p>
<blockquote>
<p>Tarides champions open-source development. We create and maintain key features of the OCaml language in collaboration with the OCaml community. To learn more about how you can support our open-source work, discover our <a href="https://github.com/sponsors/tarides">page on GitHub</a>.</p>
</blockquote>
<blockquote>
<p>We are always happy to discuss commercial opportunities around OCaml. We provide core services, including training, tailor-made tools, and secure solutions. <a href="https://tarides.com/contact/">Contact us today</a> to learn more about how Tarides can help your teams realise</p>
</blockquote>
