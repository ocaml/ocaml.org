---
title: Benchmarking and QuickChecking readInt.
description:
url: http://www.mega-nerd.com/erikd/Blog/CodeHacking/Haskell/read_int.html
date: 2012-01-24T00:52:00-00:00
preview_image:
featured:
authors:
- mega-nerd
---



<p>
I'm currently working on converting my
	<a href="http://hackage.haskell.org/package/http-proxy/">
	http-proxy</a>
library from using the
	<a href="http://hackage.haskell.org/package/enumerator">
	Data.Enumerator</a>
package to
	<a href="http://hackage.haskell.org/package/conduit/">
	Data.Conduit</a>
(explanation of why in my
	<a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Haskell/telnet-conduit.html">
	last blog post</a>).
</p>

<p>
During this conversion, I have been studying the sources of the
	<a href="http://hackage.haskell.org/package/warp/">
	Warp</a>
web server because my http-proxy was originally derived from the Enumerator
version of Warp.
While digging through the Warp code I found the following code (and comment)
which is used to parse the number provided in the <tt>Content-Length</tt> field
of a HTTP header:
</p>

<pre class="code">

  -- Note: This function produces garbage on invalid input. But serving an
  -- invalid content-length is a bad idea, mkay?
  readInt :: S.ByteString -&gt; Integer
  readInt = S.foldl' (\x w -&gt; x * 10 + fromIntegral w - 48) 0

</pre>

<p>
The comment clearly states that that this function can produce garbage,
specifically if the string contains anything other than ASCII digits.
The comment is also correct that an invalid <tt>Content-Length</tt> is a bad
idea.
However, on seeing the above code, and remembering something I had seen recently
in the standard library, I naively sent the
	<a href="https://github.com/yesodweb/wai/">
	Yesod project</a>
a patch replacing the above code with a version that uses the <tt>readDec</tt>
function from the <tt>Numeric</tt> module:
</p>

<pre class="code">

  import Data.ByteString (ByteString)
  import qualified Data.ByteString.Char8 as B
  import qualified Numeric as N

  readInt :: ByteString -&gt; Integer
  readInt s =
      case N.readDec (B.unpack s) of
          [] -&gt; 0
          (x, _):_ -&gt; x

</pre>

<p>
About 3-4 hours after I submitted the patch I got an email from
	<a href="http://www.snoyman.com/">
	Michael Snoyman</a>
saying that parsing the <tt>Content-Length</tt> field is a hot spot for the
performance of Warp and that I should benchmark it against the code I'm
replacing to make sure there is no unacceptable performance penalty.
</p>

<p>
That's when I decided it was time to check out Bryan O'Sullivan's
	<a href="http://hackage.haskell.org/package/criterion/">
	Criterion</a>
bench-marking library.
A quick read of the docs and bit of messing around and I was able to prove to
myself that using <tt>readDec</tt> was indeed much slower than the code I wanted
to replace.
</p>

<p>
The initial disappointment of finding that a more correct implementation was
significantly slower than the less correct version quickly turned to joy as I
experimented with a couple of other implementations and eventually settled on
this:
</p>


<pre class="code">

  import Data.ByteString (ByteString)
  import qualified Data.ByteString.Char8 as B
  import qualified Data.Char as C

  readIntTC :: Integral a =&gt; ByteString -&gt; a
  readIntTC bs = fromIntegral
          $ B.foldl' (\i c -&gt; i * 10 + C.digitToInt c) 0
          $ B.takeWhile C.isDigit bs

</pre>

<p>
By using the <tt>Integral</tt> type class, this function converts the given
<tt>ByteString</tt> to any integer type (ie any type belonging to the
<tt>Integral</tt> type class).
When used, this function will be specialized by the Haskell compiler at the
call site to to produce code to read string values into <tt>Int</tt>s,
<tt>Int64</tt>s or anything else that is a member of the <tt>Integral</tt>
type class.
</p>

<p>
For a final sanity check I decided to use
	<a href="http://hackage.haskell.org/package/QuickCheck">
	QuickCheck</a>
to make sure that the various versions of the generic function were correct for
values of the type they returned.
To do that I wrote a very simple QuickCheck property as follows:
</p>


<pre class="code">

  prop_read_show_idempotent :: Integral a =&gt; (ByteString -&gt; a) -&gt; a -&gt; Bool
  prop_read_show_idempotent freader x =
      let posx = abs x
      in posx == freader (B.pack $ show posx)

</pre>

<p>
This QuickCheck property takes the function under test <tt>freader</tt> and
QuickCheck will then provide it values of the correct type.
Since the function under test is designed to read <tt>Content-Length</tt> values
which are always positive, we only test using the absolute value of the value
randomly generated by QuickCheck.
</p>


<p>
The complete test program can be found on Github
	<a href="https://gist.github.com/1662654">
	in this Gist</a>
and can be compiled and run as:
</p>

<pre class="code">

  ghc -Wall -O3 --make readInt.hs -o readInt &amp;&amp; ./readInt

</pre>

<p>
When run, the output of the program looks like this:
</p>

<pre class="code">

  Quickcheck tests.
  +++ OK, passed 100 tests.
  +++ OK, passed 100 tests.
  +++ OK, passed 100 tests.
  Criterion tests.
  warming up
  estimating clock resolution...
  mean is 3.109095 us (320001 iterations)
  found 27331 outliers among 319999 samples (8.5%)
    4477 (1.4%) low severe
    22854 (7.1%) high severe
  estimating cost of a clock call...
  mean is 719.4627 ns (22 iterations)

  benchmarking readIntOrig
  mean: 4.653041 us, lb 4.645949 us, ub 4.663823 us, ci 0.950
  std dev: 43.94805 ns, lb 31.52653 ns, ub 73.82125 ns, ci 0.950

  benchmarking readDec
  mean: 13.12692 us, lb 13.10881 us, ub 13.14411 us, ci 0.950
  std dev: 90.63362 ns, lb 77.52619 ns, ub 112.4304 ns, ci 0.950

  benchmarking readRaw
  mean: 591.8697 ns, lb 590.9466 ns, ub 594.1634 ns, ci 0.950
  std dev: 6.995869 ns, lb 3.557109 ns, ub 14.54708 ns, ci 0.950

  benchmarking readInt
  mean: 388.3835 ns, lb 387.9500 ns, ub 388.8342 ns, ci 0.950
  std dev: 2.261711 ns, lb 2.003214 ns, ub 2.585137 ns, ci 0.950

  benchmarking readInt64
  mean: 389.4380 ns, lb 388.9864 ns, ub 389.9312 ns, ci 0.950
  std dev: 2.399116 ns, lb 2.090363 ns, ub 2.865227 ns, ci 0.950

  benchmarking readInteger
  mean: 389.3450 ns, lb 388.8463 ns, ub 389.8626 ns, ci 0.950
  std dev: 2.599062 ns, lb 2.302428 ns, ub 2.963600 ns, ci 0.950

</pre>

<p>
At the top of the output is proof that all three specializations of the generic
function <tt>readIntTC</tt> satisfy the QuickCheck property.
From the Criterion output its pretty obvious that the <tt>Numeric.readDec</tt>
version is about 3 times slower that the original function.
More importantly, all three version of this generic function are an order of
magnitude faster than the original.
</p>

<p>
That's a win!
I will be submitting my new function for inclusion in Warp.
</p>


<p>
<b>Update : 14:13</b>
</p>

<p>
At around the same time I submitted my latest version for <tt>readInt</tt>
Vincent Hanquez
	<a href="https://github.com/yesodweb/wai/pull/34#issuecomment-3626110">
	posted a comment on the Github issue</a>
suggesting I look at the
	<a href="http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/syntax-extns.html#magic-hash">
	GHC MagicHash extension</a>
and pointed me to
	<a href="http://tab.snarc.org/posts/haskell/2011-11-15-lookup-tables.html">
	an example</a>.
</p>

<p>
Sure enough, using the MagicHash technique resulted in something significantly
faster again.
</p>

<p>
<b>Update #2 : 2012-01-29 19:46</b>
</p>

<p>
In version 0.3.0 and later of the
	<a href="http://hackage.haskell.org/package/bytestring-lexing">
	bytestring-lexing</a>
package there is a function <tt>readDecimal</tt> that is even faster than the
MagiHash version.
</p>


