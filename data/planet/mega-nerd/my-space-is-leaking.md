---
title: My Space is Leaking.
description:
url: http://www.mega-nerd.com/erikd/Blog/CodeHacking/Haskell/my_space_is_leaking.html
date: 2012-12-22T05:42:00-00:00
preview_image:
authors:
- Erik de Castro Lopo
source:
---



<p>
Over the last couple of days I wrote a small Haskell program to read a large CSV
file (75Meg, approx. 1000 columns and 50000 rows) and calculate some statistics.
Since I would have to do this for much larger files as well, I decided to use
the
	<a href="http://hackage.haskell.org/package/csv-conduit/">
	csv-conduit</a>
library to read the data and use a function passed to <tt>Data.Conduit</tt>'s
	<a href="http://hackage.haskell.org/packages/archive/conduit/latest/doc/html/Data-Conduit-Util.html#v:sinkState">
	sinkState</a>
to calculate the statistics.
</p>

<p>
The code was pretty easy to put together, and only came to about 100 lines of
code.
Unfortunately, when I ran the program, it tried to consume all 8Gig of memory
on my laptop and when I actually let it run to completion, it took over an hour
to produce useful output.
</p>

<p>
A bit of quick profiling showed that the problem was with the state used to hold
the statistics.
The state itself wasn't huge, but Haskell's lazy evaluation meant there were a
huge number of thunks (pending calculations) piling up.
</p>

	<blockquote>
	Aside : Haskell does lazy (more correctly called non-strict) evaluation by
	default.
	This means that values are calculated when they are needed rather than when
	the program hits that point in the code.
	For instance if a value is generated by calling a pure function, the GHC runtime
	will forgo actually calling the function and replace the value with a thunk
	containing the function and it's input parameters.
	Later, when the value is actually needed, the runtime will call the function
	stored in the thunk.
	</blockquote>

<p>
My first attempt to fix this problem was to add some strictness annotations to
my data types, but that didn't seem to help.
I then looked at the
	<a href="http://hackage.haskell.org/package/deepseq/">
	deepseq</a>
package and tried adding the
	<a href="http://hackage.haskell.org/packages/archive/deepseq/1.3.0.1/doc/html/Control-DeepSeq.html#v:-36--33--33-">
	<tt>$!!</tt></a>
operator in a few places.
This resulted in a compile error complaining about my data structures not having
an
	<a href="http://hackage.haskell.org/packages/archive/deepseq/1.3.0.1/doc/html/Control-DeepSeq.html#t:NFData">
	NFData</a>
instance.
A bit of googling for &quot;custom NFData instance&quot; showed up the
	<a href="http://hackage.haskell.org/package/deepseq-th/">
	deepseq-th</a>
package which uses Template Haskell to generate NFData instances.
</p>

	<blockquote>
	Aside : For a value to be an instance of the NFData typeclass means that
	it can be fully evaluated, ie a thunk to calculate a value of this type can
	be forced by deepseq to replace the thunk with the value.
	</blockquote>

<p>
About 10 minutes later I had my code working again, but now it processed the same
file in a little over 2 minutes and used less than 0.1% of the 8Gig it was using
previously.
</p>

<p>
I was happy with this.
So happy that I decided to thank the author of deepseq-th, Herbert Valerio Riedel
(hvr) on the #haskell IRC channel.
Herbert was pleased to hear of my success, but suggested that instead of
deepseq-th I try using
	<a href="http://hackage.haskell.org/package/deepseq-generics/">
	deepseq-generics</a>.
Someone else on the channel suggested that this might be slower, but Herbert
said that he had not found that to be the case.
Switching from one to the other was trivially easy and pleasingly enough the
generics version ran just as fast.
</p>

<p>
That's when Jos&Atilde;&copy; Pedro Magalh&Atilde;&pound;es (dreixel in #haskell) said that he had a draft
paper
	<a href="http://dreixel.net/research/pdf/ogpi_draft.pdf">
	&quot;Optimisation of Generic Programs through Inlining&quot;</a>
explaining how and why this generic implementation is just as fast as the
Template Haskell version.
Basically it boils down to the compiler having all the information it needs at
compile time to inline and specialize the code to be just as fast as hand written
code.
</p>

<p>
Reflections:
</p>

<ol>
	<li>Streaming I/O libraries like Data.Conduit (there's more than one) do
		give guarantees about space usage so that when you get a space leak the
		I/O is probably not the first place to look.
		</li>
	<li>For small programs its relatively easy to reason about where the space
		leak is happening.
		</li>
	<li>For a relatively experienced Haskeller, following the bread crumbs to
		a working solution is relatively easy.
		</li>
	<li>Code that uses a struct to accumulate state is a common contributor to
		space leaks.
		</li>
	<li>Interacting with the Haskell community can often get a better result
		than the first thing you find (eg deepseq-generics instead of deepseq-th).
		</li>
	<li>Generics can be just as fast as Template Haskell generated code.
		</li>
</ol>


