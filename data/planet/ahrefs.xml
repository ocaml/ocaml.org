<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://medium.com/feed/ahrefs/tagged/ocaml</id><title type="text">ahrefs</title><updated>2023-06-30T05:47:23-00:00</updated><entry><link href="https://tech.ahrefs.com/emelletv-talking-with-louis-roche%CC%81-about-ocaml-and-ahrefs-7767afbfbdb9?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;iframe src=&quot;https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fo2u9irv1tnE%3Fstart%3D9%26feature%3Doembed%26start%3D9&amp;amp;display_name=YouTube&amp;amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Do2u9irv1tnE&amp;amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2Fo2u9irv1tnE%2Fhqdefault.jpg&amp;amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;amp;type=text%2Fhtml&amp;amp;schema=youtube&quot; width=&quot;854&quot; height=&quot;480&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;a href=&quot;https://medium.com/media/aef5aa9cb9b71aaafb0a07cb48cb312d/href&quot;&gt;https://medium.com/media/aef5aa9cb9b71aaafb0a07cb48cb312d/href&lt;/a&gt;&lt;/iframe&gt;&lt;h3&gt;Transcript&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;David: [00:00:00]&lt;/strong&gt; Hello, my name is David. I run &lt;a href=&quot;https://emelle.tv/&quot;&gt;EmelleTV&lt;/a&gt;. It&amp;rsquo;s a talk show about OCaml, ReScript, and Reason. I often bring guests from the community to talk about them and meet them and asking a lot of questions about the language or what they&amp;rsquo;re working on, and of course having fun with Hindley&amp;ndash;Milner type system. That&amp;rsquo;s part of the show. I work for Ahrefs, it&amp;rsquo;s actually this&amp;nbsp;company.&lt;/p&gt;&lt;p&gt;Today I&amp;rsquo;m interviewing a coworker, so it&amp;rsquo;s going to be a little bit a branded stream. Hope you understand. It&amp;rsquo;s a lovely company. Apply if you&amp;rsquo;re looking for a job to work on OCaml or Reason. Aside from that, I maintain styled-ppx and implementation of React on server, but that&amp;rsquo;s just enough about me, and I&amp;rsquo;m going to introduce our guest, Louis. Hello, Louis. How are&amp;nbsp;you?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:00:59]&lt;/strong&gt; Good, and&amp;nbsp;you?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:01:01]&lt;/strong&gt; Good. Very good. You obviously work at Ahrefs. At what team do you&amp;nbsp;work?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:01:10]&lt;/strong&gt; This is recently changing, but I have been in the back-end forever, since like seven years ago and I still have some of the projects that I had when I joined. This was stable. I&amp;rsquo;m in this new team called middle-end. Ahrefs is not very good with naming. We say that it&amp;rsquo;s the hardest thing in computer science. We have front-end that is actually full stack, then we have a back-end, which is more like data, and now we have middle-end, which is somewhere in the middle. I&amp;rsquo;m supposed to lead this new middle-end team.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:01:48]&lt;/strong&gt; Nice.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:01:49]&lt;/strong&gt; We&amp;rsquo;ll see how it&amp;nbsp;goes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:01:49]&lt;/strong&gt; Nice. Today I think we&amp;rsquo;re going to answer a few questions about Ahrefs, I think has been a mysterious company, if you look at it from the outside. When I joined, I think you helped me understand a lot of things that I didn&amp;rsquo;t know about Ahrefs. I might just fire the same questions that I did, just recorded so everybody can understand them. Aside from from Ahrefs, who are you and can you present a little about yourself?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:02:21]&lt;/strong&gt; This is a tough question. Who am I? I grew up in France. I&amp;rsquo;m French, still I&amp;rsquo;m French, but I&amp;rsquo;ve been living in Singapore for seven years, with Ahrefs for seven years. I&amp;rsquo;ve been working in OCaml my whole life basically because my first job was in OCaml, and Ahrefs which is my second job, is in OCaml too. I cannot say that it&amp;rsquo;s better than the rest because I never tried the rest. I&amp;rsquo;ve been involved with OCaml, like the OCaml meetup in Paris for some&amp;nbsp;time.&lt;/p&gt;&lt;p&gt;I&amp;rsquo;m on the online community. I&amp;rsquo;m part of the OCaml Code of Conduct committee, which is an effort that was started last year, I think. So far we don&amp;rsquo;t have a lot of work, so that&amp;rsquo;s good. I&amp;rsquo;m one of five doing this. Then outside of that, I&amp;rsquo;m a pretty normal person. I&amp;rsquo;m 31 years old, and that&amp;rsquo;s about it, I would&amp;nbsp;say.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:03:35]&lt;/strong&gt; That&amp;rsquo;s the whole idea. You have been been writing OCaml for a long, long time. That&amp;rsquo;s fair to&amp;nbsp;say.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:03:40]&lt;/strong&gt; I&amp;rsquo;ve been writing OCaml since I&amp;rsquo;m 16 or 17 was when I wrote my first line, like 14 years ago, something like this. There was no Merlin at the&amp;nbsp;time.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:03:52]&lt;/strong&gt; There was no LSP. The first question is, 15 years, this is a long time, but how do you see the evolution of entire language? Would you split it in chunks? How have you seen the progress of the language?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:04:08]&lt;/strong&gt; It&amp;rsquo;s hard to say. When I joined the OCaml world, it was because of people who nowadays are fairly important like Gabriel Scherer, who&amp;rsquo;s working in Inria, I think, but he&amp;rsquo;s one of the main maintainer for OCaml. He was in this French forum, pushing very hard people to try OCaml and I got convinced. I started just writing a few lines here and there, and then I just stick to that for a long time. I&amp;rsquo;ve been mostly a user like this. My usage has extended over time, but I&amp;rsquo;ve never been called a contributor. My point of view is more as a&amp;nbsp;user.&lt;/p&gt;&lt;p&gt;The biggest difference is the size of the community, I would say. It&amp;rsquo;s much more dynamic than it used to be. We used to install packages like OCaml libraries, using Debian packages. It was apt install something. There was no opam, there was no Merlin, there was no vscode,&amp;nbsp;right?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:05:25]&lt;/strong&gt; Right.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:05:25]&lt;/strong&gt; LSP didn&amp;rsquo;t exist, so way less library. I think you can see today how it was in the past because you can see, we have 10 different libraries to do HTTP 1.1. We have 10 different standard libraries, and it&amp;rsquo;s legacy of what OCaml was in the past. We used to have all those smart people, but they had no way to collaborate. There was no opam, there was no way to share your work. Everyone was smart enough to rewrite&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:06:04]&lt;/strong&gt; Build your own library for&amp;nbsp;http.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:06:05]&lt;/strong&gt; Yes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:06:06]&lt;/strong&gt; Right. That&amp;rsquo;s always interesting for me, how OCaml got so many different things that are hard to create, like standard libraries. I think recently, Containers reached 10 years, so it&amp;rsquo;s like what? [chuckles] It doesn&amp;rsquo;t make much sense. If you look at now, it doesn&amp;rsquo;t make much sense, but if you look at historically, it does make&amp;nbsp;sense.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:06:35]&lt;/strong&gt; When you have no choice, you do it. You don&amp;rsquo;t know that it&amp;rsquo;s harder, you just see &amp;ldquo;Oh, I can do it,&amp;rdquo; and you do&amp;nbsp;it.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:06:42]&lt;/strong&gt; Yes. You need to think it&amp;rsquo;s easy. You need to start a standard library or http library saying, &amp;ldquo;Oh, it&amp;rsquo;s easy.&amp;rdquo; Then, you start a little bit, and eventually, you create something. Last week&amp;#8202;&amp;mdash;&amp;#8202;Oh, sorry, go&amp;nbsp;on.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:06:57]&lt;/strong&gt; No, go&amp;nbsp;ahead.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:06:59]&lt;/strong&gt; Last week, I tweeted that OCaml suffers a lot from the Python Paradox. The Python Paradox, I think somebody write it, I think it was, I don&amp;rsquo;t remember the name of the guy, but somebody write it in 2004, that when you use Python for a company, and you get the smartest people that they want to innovate, and you have the pioneers of the language. Then, by default, you try to hire people that are in love with software, so eventually, they create good software or they are willing to suffer from getting out of the comfort zone and create software. I believe the combination is the same spot. Can you see, is that true? Do you&amp;nbsp;agree?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:07:49]&lt;/strong&gt; I don&amp;rsquo;t know if that&amp;rsquo;s true. Partially, it&amp;rsquo;s a strategy of Ahrefs, so I have to say it&amp;rsquo;s&amp;nbsp;true.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:07:55]&lt;/strong&gt; [laughs]&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:07:58]&lt;/strong&gt; Yes, I think it&amp;rsquo;s partially true, but it&amp;rsquo;s not completely correct. For OCaml, at least it&amp;rsquo;s a bit different from Python, because OCaml has this strong academic influence, so a lot of people are actually researcher. There is a big benefit that they have, not free time, but they manage their time, they manage what they work on, and they decide what is important. They got all this time to actually write this complicated code many times because actually, it&amp;rsquo;s part of their job to just redo the same thing in better ways. It&amp;rsquo;s normal you have to explore a&amp;nbsp;subject.&lt;/p&gt;&lt;p&gt;It&amp;rsquo;s okay to do it multiple times. It&amp;rsquo;s a combination of those people are working in the right place, they have the right time, and they have the correct background. A lot of people were working on subjects that allowed them to do it. Some, it&amp;rsquo;s because they were very strong in writing languages. Some, it&amp;rsquo;s because they have this strong Unix background, I would&amp;nbsp;say.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:09:05]&lt;/strong&gt; Right. It&amp;rsquo;s very unixy. The start of OCaml is very unixy. That&amp;rsquo;s&amp;nbsp;true.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:09:14]&lt;/strong&gt; Xavier Leroy wrote LinuxThreads, I think that was used in Linux forever, so there is this background. Probably, it&amp;rsquo;s a bit different in Python because it grew more in the industry rather than in an academic setup. For sure, if you try to target people who live in a niche, you find people with a different interest from the main programming community, I would say. At the same time, I think some of the best meetup or conference I&amp;rsquo;ve been to were Java&amp;nbsp;meetup.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:09:59]&lt;/strong&gt; All&amp;nbsp;right.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:10:00]&lt;/strong&gt; They know that their language is boring. The language is the same since 20 years or 30 years. There are some changes but they don&amp;rsquo;t really care about the language too much. It&amp;rsquo;s a huge, huge community. Basically, everything already exists. There is no big bragging, everyone can do everything. There are 10 versions of everything, whatever. The benefit is that they are super open-minded.&lt;/p&gt;&lt;p&gt;Oh, something is new. Something is different. Okay. Let&amp;rsquo;s see that. You go to that meetup and they will not talk only about all the fancy new feature in Java. It&amp;rsquo;s like, &amp;ldquo;Oh, I saw this new git tool. Oh, it&amp;rsquo;s funny. Okay, let&amp;rsquo;s try to use this.&amp;rdquo; A new way to do web development. Okay, let&amp;rsquo;s study the subject. It&amp;rsquo;s not about Java itself because the language is not interesting enough. It&amp;rsquo;s about other programming stuff. It&amp;rsquo;s very fun to&amp;nbsp;attend.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:11:03]&lt;/strong&gt; That&amp;rsquo;s a good one. Actually, many people that now are starting to hear OCaml for the first time, after they leave or they got disappointed with the Rust policy drama. These people cannot get into OCaml because some influencer wanted to bash on Rust. They started exploring all the languages and of course Ocaml was one of those. Aside from Zed or whatever you compare it with, low level programming languages. Do you see those influencers move people to actually try the language and deploy it into users and doing serious stuff, or it&amp;rsquo;s more like vain marketing?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:11:56]&lt;/strong&gt; I&amp;rsquo;m not a big Twitch person. I don&amp;rsquo;t know [crosstalk] modern influencers.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:12:02]&lt;/strong&gt; That&amp;rsquo;s&amp;nbsp;true.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:12:03]&lt;/strong&gt; I think it exists in two forms. In the past it existed in two forms. You had influencers, you had Rob Pike and- who&amp;rsquo;s the other person? The two person who are behind Go. They do not make a good language but they are influencers. They were like, &amp;ldquo;Oh, yes. We did UTF-8 and a Plan 9 in the past and we work at Google. Oh, it&amp;rsquo;s going to be amazing.&amp;rdquo; No, it&amp;rsquo;s a crappy language, but they are influencers. They move&amp;nbsp;people.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:12:32]&lt;/strong&gt; [laughs] Okay. Would you say that Go is&amp;nbsp;crap?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:12:38]&lt;/strong&gt; Go is a language. I haven&amp;rsquo;t used Go 2 extensively.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:12:42]&lt;/strong&gt; This is recorded. This is not a beer in Singapore. This is recorded. You can obviously bash go, that&amp;rsquo;s part of the&amp;nbsp;game.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:12:50]&lt;/strong&gt; Let&amp;rsquo;s say Go is not the most modern language there&amp;nbsp;is.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:12:54]&lt;/strong&gt; Right. Thank you. This is just for the headline. We don&amp;rsquo;t want the headlines- because Ahrefs is going to be like&amp;#8202;&amp;mdash;&amp;#8202;No, I&amp;rsquo;m joking. [crosstalk] Yes, go on.&amp;nbsp;Sorry.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:13:10]&lt;/strong&gt; On the same topic of influencer, we saw it with Reason. When the Reason comes, it&amp;rsquo;s not just a random person creating Reason. It&amp;rsquo;s Jordan and he comes with a React background, and he comes with followers. He is not doing videos online but it&amp;rsquo;s the same idea. I think yes, it has definitely an influence and OCaml grew a lot when Reason&amp;nbsp;started.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:13:38]&lt;/strong&gt; Yes, that&amp;rsquo;s&amp;nbsp;true.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:13:39]&lt;/strong&gt; I definitely think it has an influence.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:13:43]&lt;/strong&gt; That&amp;rsquo;s true. From the community, how have you seen the Reason creation and adoption from your point of view? You can bash Reason if you&amp;nbsp;want.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;[00:13:43]&lt;/strong&gt; [crosstalk]&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:13:56]&lt;/strong&gt; At that time I think the OCaml community was one IRC channel. It was a bit different from now. I think what I was not super convinced by when Reason to syntax arrived, I think the original claim by Jordan was he&amp;rsquo;s making a better syntax. I was not super convinced that the syntax was better. It was developed independently from&amp;nbsp;OCaml.&lt;/p&gt;&lt;p&gt;By experience I already knew at the time that if you start to fork or develop on your side and don&amp;rsquo;t integrate fairly quickly with upstream it&amp;rsquo;s actually never going to be integrated with upstream.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:14:53]&lt;/strong&gt; Right.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:14:54]&lt;/strong&gt; I don&amp;rsquo;t know why exactly, but it has happened a few times. Then there is a question of bucklescript because if you write Reason it&amp;rsquo;s two sides. There is a syntax which I only partially understood too because I was not a web developer, I&amp;rsquo;m still not a web developer. I did not know about JSX. I did not know how powerful it was and I think React was not as big at the time too, but I think JSX is a nice idea and there are a lot of things in the syntax that are nice, like parentheses around arguments is a problem but it has some benefits, too.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:15:42]&lt;/strong&gt; Yes, I think some trade-offs from OCaml, or at least some edge cases from the syntax from OCaml got resolved in Reason just by adding more- like the parentheses or the braces or the semicolons. But yes, the others are, can remove some problems from the syntax. Not problems, but just the edge cases from the cleanness for&amp;nbsp;OCaml.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:16:10]&lt;/strong&gt; Yes. Even sometimes it&amp;rsquo;s not edge case but it&amp;rsquo;s nice to see very clearly for example, when you apply a function, where are the arguments? Where it starts where it ends? There are benefits, obviously, like the OCaml syntax or Haskell syntax is lighter, we will say, have some benefits. The other one is nice,&amp;nbsp;too.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:16:36]&lt;/strong&gt; Yes, definitely and you mentioned BuckleScript?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:16:40]&lt;/strong&gt; Yes. BuckleScript, they didn&amp;rsquo;t have&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:16:42]&lt;/strong&gt; That was not so well received.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:16:47]&lt;/strong&gt; Yes, I think because there was Js_of_ocaml idea. There was js_of_ocaml and so again, it was like yes, I do something different and- I think Bob developed it fully inside Bloomberg at the time. Basically, he came out and he had, &amp;ldquo;Oh, yes, I have a new project and it&amp;rsquo;s working already.&amp;rdquo; He didn&amp;rsquo;t start to develop it in public. The community was much smaller, too so every time you split efforts like this, it&amp;rsquo;s kind of costly. People will say, &amp;ldquo;Yes, we will try to collaborate. We&amp;rsquo;ll try to make the two projects work together,&amp;rdquo; or whatever and it never works. Never works. I don&amp;rsquo;t think I understood all the trade-off. I&amp;rsquo;m happy that I invited Bob to the OCaml meetup in Paris which retrospectively, it was a good thing to&amp;nbsp;do.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:17:50]&lt;/strong&gt; Yes, for the record, Louis was running the OCaml Paris Meetup, I think. Yes, go on with the&amp;nbsp;story.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:18:00]&lt;/strong&gt; Yes, so when I moved to Singapore, I still organized one meetup, even though I was in Singapore and I invited Bob to present BuckleScript. At the time, it was a bit controversial, because many people were a bit unhappy with what he was doing, but I&amp;rsquo;m happy that I did it. I didn&amp;rsquo;t understood what I was doing exactly but at the end, I think it was the right thing to do. Even if the project died later on, you have to give such projects a&amp;nbsp;chance.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:18:35]&lt;/strong&gt; Yes, I think I wouldn&amp;rsquo;t say that BuckleScript died. It&amp;rsquo;s more like BuckleScript has been working for seven years, I&amp;nbsp;think.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:18:42]&lt;/strong&gt; Yes, no, even if it was a failure, which it was not, but maybe like six months later, it could have died and disappeared. Yes, I think when people have a drastically different approach, usually they have a reason. It&amp;rsquo;s worth listening. A lot of what Bob defended, I&amp;rsquo;m not sure I completely agree with it. He wants a very stable compiler, for example. He said, in Bloomberg, they are using GCC 3 or 4, I don&amp;rsquo;t remember, since&amp;nbsp;forever.&lt;/p&gt;&lt;p&gt;So they don&amp;rsquo;t need to upgrade the compiler, the GCC compiler, for example. He thought the same idea can apply to OCaml, we don&amp;rsquo;t need to follow the upstream compiler all the&amp;nbsp;time.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:19:27]&lt;/strong&gt; Right.&amp;nbsp;Yes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:19:29]&lt;/strong&gt; Most companies actually they don&amp;rsquo;t want to change compiler version. They want something stable. They want no surprise, which has some value, or the stability has some&amp;nbsp;value.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:19:40]&lt;/strong&gt; Yes, that&amp;rsquo;s true but I think when he mentioned about the compatibility with the compiler, I think it&amp;rsquo;s mostly OCaml has been very stable since, what 6, 7 years ago, I think. I think there were some small changes or some addition features, but nothing really break, but mostly the syntax. Then he complained about the parsing, like the AST modifications, those were present, those were changing between versions. He wanted to not- because BuckleScript is a fork of the common compiler and embedded into ReScript&amp;nbsp;now.&lt;/p&gt;&lt;p&gt;Yes, he was complaining about the AST transformations because every version changes a lot. There are migrations. You could write some logic to migrate from one to another. It&amp;rsquo;s painful if you maintain a fork of this, you might suffer a lot from updating from one compiler to&amp;nbsp;another.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:20:41]&lt;/strong&gt; Yes, and I think for him, even as an end user, the stability has some value. It&amp;rsquo;s interesting for him to have a stable compiler and even for his target, the people he&amp;rsquo;s targeting, the stability has some value&amp;nbsp;too.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:21:00]&lt;/strong&gt; After you mentioned that people were installing or sharing libraries through Debian packages, which maybe- I&amp;rsquo;m as old as you, but maybe I&amp;rsquo;m too young to see how those package managers could work with apt get. What&amp;rsquo;s the position of the tooling? Right now I think we are in a state where we have two bigger players such as opam and dune, as Package Manager and Build Infrastructure, we&amp;rsquo;d call it, I don&amp;rsquo;t know. Now dune is exploring installing packages. How do you see the tooling these recent&amp;nbsp;years?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:21:48]&lt;/strong&gt; It&amp;rsquo;s amazing. It&amp;rsquo;s completely incredible. Then people will have different opinions on is opam perfect or whatever. If you compare to what it was before, it&amp;rsquo;s incredible. I think even if you compare to other languages, it&amp;rsquo;s a fairly solid experience now. Opam is working well. You just need to learn the UI, but it&amp;rsquo;s working fairly well. Dune is relatively fast, easy to use. The LSP is pretty magical. Merlin is a very solid tool. It was one of the first, I think I would say, like a small language with a tool as powerful as&amp;nbsp;Merlin.&lt;/p&gt;&lt;p&gt;It&amp;rsquo;s not only powerful, it&amp;rsquo;s avantgarde. It understood already that you had to be able to do error recovery and that you had to change the way you parse files to be able to work with something that is half&amp;nbsp;broken.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:22:57]&lt;/strong&gt; Yes, that&amp;rsquo;s&amp;nbsp;true.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:23:00]&lt;/strong&gt; The people behind Merlin are super smart. In a way, it&amp;rsquo;s not a surprise.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:23:05]&lt;/strong&gt; Right. You actually contributed to the LSP and dune, to both projects, I saw your contributions.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:23:13]&lt;/strong&gt; Yes, I have commits on many small- it&amp;rsquo;s mostly small contributions, but I have commit on everything, I think at some&amp;nbsp;point.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:23:19]&lt;/strong&gt; Right.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:23:21]&lt;/strong&gt; LSP, I participated in putting some ppx deriving stuff and I wrote a bunch of commands. I implemented some Merlin behavior inside LSP. If you hover multiple times on the same value, the type will be more and more verbose. I took this behavior back to LSP. Dune I have mostly bug fixes, probably small documentation, nothing&amp;nbsp;big.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:23:58]&lt;/strong&gt; One of the things that you mentioned as well, I think we talked about this before. When OCaml was very young, all features that got added into the language were PhD projects, where it&amp;rsquo;s a student that is very passionate or maybe just his guidance is OCaml fan, he just explored with a language in the theory on academia. Then he worked on a paper and eventually it gets released as part of the language. That was the times where maybe Jane Street not even started using OCaml seriously. Do you see that now? Do you see that those features or academic features got into language? Do you think it&amp;rsquo;s a weird mix now or they compose well together? How do you see language after these contributions?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:25:04]&lt;/strong&gt; I was looking today at the OCaml change log because I was wondering when was the release of OCaml 4, and that was 11 years ago because OCaml 4 is- before to OCaml Multicore is the last time there was a big change which was GADT. In the meantime there was mostly small changes. I don&amp;rsquo;t think the language changed much. If we look what were the big features we could say like the objects in OCaml, GADT, OCaml Multicore.&lt;/p&gt;&lt;p&gt;They all were developed by people in a research setup and somehow it seems to work. I&amp;rsquo;m not a maintainer on OCaml. I think it works also because they don&amp;rsquo;t have a lot of energy to integrate a lot of new features, they are very, very picky on what they actually accept in the compiler. Only the most solid implementations will get&amp;nbsp;in.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:26:36]&lt;/strong&gt; Yes, that&amp;rsquo;s true. I think the quality is something that everything core team members says all the time that all these things would be amazing to do but our quality bar is very high. Yes, you need to work on it much more to let us just even look at it. Yes, that&amp;rsquo;s&amp;nbsp;true.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:26:54]&lt;/strong&gt; Then there are things that do not compose super, super well. There are part of the module language and part of the object language that do not compose very well. You can make the compiler more or less blow up or the compilation time will become crazy. Actually, those are parts that I don&amp;rsquo;t know very well. I very seldom combine first-class modules and&amp;nbsp;objects.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:27:21]&lt;/strong&gt; Objects, yes. That&amp;rsquo;s something I haven&amp;rsquo;t done yet. I think the only experience with that combination might be ppxlib maybe, because you have the traversers. Yes, you use them. You instantiate the traverser. You don&amp;rsquo;t do anything with internal states of anything. Good point. One thing that maybe it&amp;rsquo;s worth saying is that right now you work at Ahrefs for seven&amp;nbsp;years.&lt;/p&gt;&lt;p&gt;At the beginning when Ahrefs pick OCaml or Igor, our CTO came with OCaml in the back, there were not many companies working on- using it, using OCaml. Now we have Tezos, Tarides, Ahrefs of course, LexiFi, Bloomberg, BeSport. Many companies that have- even some of them have their own forks of OCaml that they are experimenting and deploying it or whatever. Seven years ago, do you think it&amp;rsquo;s a risky decision? The second question is how can you convince your boss about using&amp;nbsp;OCaml?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:28:35]&lt;/strong&gt; For sure, I think picking OCaml at the time was a risky choice because who do you hire? It&amp;rsquo;s like there were five OCaml developers. In Paris, you can find people. In Paris, you can find students. You go to the OCaml meetup and socialize and you can more or less build a company, which is what the previous company I was in called Cryptosense was doing. This is how BeSport came to life. BeSport just picked a few people around Vincent Balat and then you meet people. You steal one or two person from the OCaml meetup and you tell them, &amp;ldquo;Oh, join my company,&amp;rdquo; and now you have enough people to push a project forward. How do you do this from another country? Even today, I think it&amp;rsquo;s not an easy&amp;nbsp;choice.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:29:35]&lt;/strong&gt; Somehow risky, yes. That&amp;rsquo;s&amp;nbsp;true.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:29:38]&lt;/strong&gt; Today, you can hire, but even if you have, I don&amp;rsquo;t know, 2,000 packages on opam, the tooling is still- the libraries are not, there are not libraries for everything like you have in some other languages.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:30:00]&lt;/strong&gt; Right. It&amp;rsquo;s big enough, but it&amp;rsquo;s not populated with everything.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:30:07]&lt;/strong&gt; I don&amp;rsquo;t know if we have full support of GRPC. I&amp;rsquo;m not sure that we have complete support of http2 or 3. It&amp;rsquo;s not that small, but many things like this. I would say, today I would say it&amp;rsquo;s a risk. How would I convince my boss to move to OCaml? I would&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:30:34]&lt;/strong&gt; Would you do it? Maybe you would not do it. Maybe you say, &amp;ldquo;It&amp;rsquo;s fine, we can do with whatever,&amp;rdquo; with Java you said that you enjoy the Java meetup, then you join your company writing Java. Would you be happy writing Java? Would you be fine? Or you would say &amp;ldquo;Oh, OCaml here makes sense, let&amp;rsquo;s try to change it.&amp;rdquo; How would you do&amp;nbsp;it?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:30:57]&lt;/strong&gt; I think if I was in a small company, it would definitely make sense to use OCaml. It&amp;rsquo;s interesting because in a small company you could say all the Java tooling has more value than in a big company, but at the same time you have less hands. You need to be more productive per person and you have less time for maintenance, and those are two things for which OCaml is very strong. You can write few lines of code that do many things, so it&amp;rsquo;s very expressive. At the same time, it&amp;rsquo;s solid enough that when you write your code, you can launch it in prod and you can leave it there for some time and hopefully nothing&amp;nbsp;breaks.&lt;/p&gt;&lt;p&gt;The language is stable, the compiler is stable, so there will be no big surprises. I think that&amp;rsquo;s very valuable, and then you compare, what are the alternatives today? Rust is incredibly hard. It&amp;rsquo;s very, very hard language to use. You can do fancy stuff, you have incredible community but it&amp;rsquo;s a super hard language to use. You have what, Python, but then you are losing all the type safety. You have Go, which is a bit in between those. You have a fast Python I would say. Then you have Java. Java which has a huge community, and is a fast language.&lt;/p&gt;&lt;p&gt;In a way I think OCaml is closer to Java. It&amp;rsquo;s one easy language to use, solid, no surprises. The feature set is not incredible but it&amp;rsquo;s working well enough and you can do more or less what you want with it. You can do work in the back end, work in the front end, it&amp;rsquo;s approachable. To me it&amp;rsquo;s a replacement to Java. It&amp;rsquo;s a light&amp;nbsp;Java.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:33:04]&lt;/strong&gt; I&amp;rsquo;m mostly front-end. Now I&amp;rsquo;m doing some back-end stuff but I mostly am experienced from front-end. You are experienced from back-end of course and when I&amp;rsquo;m talking to back-end persons from OCaml, every time I talk with a back-end person who only writes OCaml they mention then the runtime. From the front-end, it&amp;rsquo;s a problem that I have never, ever thought. I know that the problem exists because I studied computer science and all these things, but it&amp;rsquo;s something that in the front-end I never think about&amp;nbsp;it.&lt;/p&gt;&lt;p&gt;How could you describe to me that- I know a little bit about the memory presentation and about the stack, the heap, how memory works, even the O(n) notation, O big notation. How can you describe the runtime of OCaml, from someone who doesn&amp;rsquo;t know much about runtimes, so has nothing else to compare, rather than notes, for example. That&amp;rsquo;s my experience.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:34:08]&lt;/strong&gt; Yes, I&amp;rsquo;m not an expert either, but it&amp;rsquo;s an interesting point, actually, because if you go on, for example, the real-world OCaml, there is a whole chapter on the runtime. I think it&amp;rsquo;s important for the OCaml people because of their background. We have those unixy people, so they have experience with C before and because in C you need to know what is a representation in memory of everything you manipulate, they took that from C and bring it to OCaml. Those people, they like to know, when I have an integer, it&amp;rsquo;s going to be nowadays, 64&amp;nbsp;bits.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:34:56]&lt;/strong&gt; 63 right? That&amp;rsquo;s the&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:34:59]&lt;/strong&gt; Yes, one bits for the right GC, and then we have 63 bits for the&amp;nbsp;value.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:35:05]&lt;/strong&gt; Right. Yes, people love the runtime. I think it&amp;rsquo;s like those things when&amp;#8202;&amp;mdash;&amp;#8202;You guys started talking about the front-end. For me, I love CSS. I can talk all the time about CSS, but if you never have experience with a language or with designing the UI, CSS means nothing. You understand what they are saying because the thing makes sense, but semantically it doesn&amp;rsquo;t. When you talk about the run time at the beginning, for me it felt like I have never, ever thought of&amp;nbsp;this.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:35:41]&lt;/strong&gt; I guess it&amp;rsquo;s two sides. There is the technical side, how it&amp;rsquo;s actually implemented that when you allocate a value, where do you put it in memory? What is the representation of that value in memory? For example, we said that the int are 63 bits actually, that when you allocate the value, you allocate by words in OCaml. You have one word, for example, if you allocate the values that is on the heap, you have potentially two words. You have one word, which is a pointer to the actual value, and then the values, which is like a number of words afterwards.&lt;/p&gt;&lt;p&gt;You have the GC, so when is it triggered? Actually, the GC can be running every time you can allocate a value which means that you can write code that will not trigger the GC. It means you can write code that is very fast because there will be no interruption, and I think that&amp;rsquo;s critical for companies like Jane Street. Then yes, the other side is the runtime from a user perspective. I see it two way. I see one way that it&amp;rsquo;s like no one knows about the runtime because it&amp;rsquo;s very, very simple in OCaml. You don&amp;rsquo;t need to deal with the runtime very&amp;nbsp;often.&lt;/p&gt;&lt;p&gt;You just know that you pass values by reference, so you don&amp;rsquo;t make many copies, and then the GC is fairly fast and will not stop for too long. That&amp;rsquo;s probably what 99% of the normal OCaml people know about the runtime. Then an interesting fact that comes with that is that the OCaml compiler is bad by modern standards, that it&amp;rsquo;s not doing any kind of optimization or very little optimization, yet the native code is fairly fast. The native code that is generated for an OCaml program is fairly fast. I think if you look at the benchmark it&amp;rsquo;s not too far away from C++, which is surprising, and it means that the language is pushing you to write code that by default is fairly efficient.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:38:06]&lt;/strong&gt; That&amp;rsquo;s exactly my experience.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:38:09]&lt;/strong&gt; The types that are offered and the functions, the APIs that are offered, somehow allow you to write code that is not too, too bad. I think it&amp;rsquo;s a miracle, but it&amp;rsquo;s an interesting one.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:38:23]&lt;/strong&gt; Yes, that&amp;rsquo;s exactly my experience. At Ahrefs, the formula of the Coca-Cola of Ahrefs is like the crawler, the thing that navigates the internet and saves data. After that, we have storage and all of these pieces that are complex. What can you explain about the secret sauce of Ahrefs? What are they from the outside? Many people would never, ever write a crawler or a very dummy one, but for one that indexes 9 billion pages, 1 trillion? I don&amp;rsquo;t know the numbers but insane amount of numbers. What can you&amp;nbsp;explain?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:39:10]&lt;/strong&gt; I guess the first question is what is a&amp;nbsp;crawler?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:39:13]&lt;/strong&gt; Yes, yes, because you read the webpage, you scrap a webpage, that&amp;rsquo;s fairly simple. You can do it in any language, but then what do you extract about this page, and more importantly, how you navigate to the next one. I think that these are the two main questions.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:39:35]&lt;/strong&gt; What you extract, depends. Ahrefs, we care about the links. What is Ahrefs building is more or less a map of the internet. The crawler is running all the time. It&amp;rsquo;s downloading, I don&amp;rsquo;t know, like 4 million pages per minute or something like this. There is a counter. Every minute we crawl 5 million pages. We have been talking for 40 minutes. You can count how many pages we have downloaded in a period of time. We download those pages and then we extract the links. That is the main information we care about. This is not the only information.&lt;/p&gt;&lt;p&gt;First is how do you parse HTML and how broken is HTML on the internet? This is horrible. The internet is broken. You have to extract all the links in a page and then you have to store all those links. When you store links, because&amp;#8202;&amp;mdash;&amp;#8202;What is a crawler exactly? Where does it start and where does it end? Is it only the part that is downloading the html? Or is it actually the parsing too, and it&amp;rsquo;s influencing how you are storing your data, because&amp;#8202;&amp;mdash;&amp;#8202;Let&amp;rsquo;s say you download a page and you have a 100 links in it, you do at least two things with those 100 links that you want to reuse them in your scheduler to decide what do I crawl&amp;nbsp;next.&lt;/p&gt;&lt;p&gt;You also want to update counters, because you want to update your map of the internet. You downloaded a page, you know that there are links and you want to update the map. How do you update the map, because you have a 100 new links? What do you do? You update a 100 small counters, a 100 small integers. Then can you do it 5 million times per minute? Then can you do it in many direction, because it&amp;rsquo;s a&amp;nbsp;graph.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:41:48]&lt;/strong&gt; You would loop. If you don&amp;rsquo;t do it properly, you would loop&amp;nbsp;forever.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:41:55]&lt;/strong&gt; You have links between pages, but then you want to also count links between domains and you want to count the links inside the domain. Then how do you decide it&amp;rsquo;s an interesting link or not? Then when you index a link, what do you index? You need to index the link itself, but you want to index the text that is attached to the link, maybe the paragraph that is around that specific link. You could look where it is in the page. Is it visible or not? You have&amp;#8202;&amp;mdash;&amp;#8202;It&amp;rsquo;s an open question.&lt;/p&gt;&lt;p&gt;That&amp;rsquo;s an interesting question, because there is no one that can say, &amp;ldquo;I&amp;rsquo;m doing a crawler and this is the right way to do it.&amp;rdquo; Even big companies like Google, they make tradeoffs. They decide, &amp;ldquo;We do it in one way.&amp;rdquo; Then they gather information they can gather. They cannot download every page on the internet all the time. They cannot download and process stuff fast enough. There is more content that is created than content that can be downloaded.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:43:00]&lt;/strong&gt; It&amp;rsquo;s interesting, because if you think about fixing a bug on the crawler, it&amp;rsquo;s usually when you have a database, you can run migrations or you can get out data. You can store data broken or whatever. You can fix it. If you have the history of internet, that&amp;rsquo;s another source of data. It is life. I don&amp;rsquo;t know the right metaphor, but it&amp;rsquo;s&amp;#8202;&amp;mdash;&amp;#8202;If you have to fix a bug on the crawler, that means that you stored information wrongly. That can affect the next version of your map, because it&amp;rsquo;s not only a map, it&amp;rsquo;s a map and a timeline. You can just look it up. It&amp;rsquo;s an archive as well. I think internet archives, they don&amp;rsquo;t have a crawler. I think they don&amp;rsquo;t have a&amp;nbsp;crawler.&lt;/p&gt;&lt;p&gt;It&amp;rsquo;s the idea of&amp;#8202;&amp;mdash;&amp;#8202;You can improve the crawler. Something that you didn&amp;rsquo;t look before, now you are going to look it up now. I don&amp;rsquo;t know, when&amp;#8202;&amp;mdash;&amp;#8202;I think at some point we&amp;#8202;&amp;mdash;&amp;#8202;At the beginning, either we started indexing, I think videos was&amp;#8202;&amp;mdash;&amp;#8202;I don&amp;rsquo;t remember. Some media, I don&amp;rsquo;t know. That, of course, blowed up immensely, everything- they complicated everything.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:44:14]&lt;/strong&gt; Yes. That&amp;rsquo;s an interesting question. Actually, Because, it is right that your database is very big so you cannot just migrate stuff. The big data page says we have 170 trillion rows in the database, so we cannot just push this to somewhere else.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:44:35]&lt;/strong&gt; First of all, what technology is that running&amp;nbsp;on?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:44:40]&lt;/strong&gt; I think that&amp;rsquo;s a combination of different technologies. That will be a ClickHouse and then some internal database. Custom&amp;nbsp;stuff.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:44:52]&lt;/strong&gt; At Ahrefs, correct me if I&amp;rsquo;m wrong, we like to build our own things mostly. When I have it in other companies, you would use Sentry for reporting, or you would use PagerDuty for live crashing, or you would use whatever tool that you- or a web server, like a framework that runs your server. I think we implemented all of this by ourselves. That sounds both crazy from the outside, but when you join Ahrefs, if you ever join the company, you understand perfectly why has it been done like that. Yes, we have our own database. It&amp;rsquo;s&amp;nbsp;scary.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:45:41]&lt;/strong&gt; It&amp;rsquo;s not completely our own database, it&amp;rsquo;s more like a wrapper around existing database. It&amp;rsquo;s partially because we have no choice. The problem is large enough that you don&amp;rsquo;t have a ready made solution. Google was like this for a very long time. They had MySQL, I think that they used very extensively MySQL and it&amp;rsquo;s just that they used it in a way that was working for them. They don&amp;rsquo;t have a giant MySQL database, but probably they just sharded the&amp;nbsp;problem.&lt;/p&gt;&lt;p&gt;They have one small database per server and they have a smart way to send the tasks to the right server to retrieve the data they want. Because you have to build on top of something, we are a small company. The total number of employees, I don&amp;rsquo;t know, it&amp;rsquo;s 100 plus now, but the back-end team is still 15 people or something like this. We don&amp;rsquo;t have too many&amp;nbsp;hands.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:46:43]&lt;/strong&gt; Yes. That&amp;rsquo;s&amp;nbsp;insane.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:46:47]&lt;/strong&gt; You ask what you do when there is a bug in the crawler and it affects how you conceive the programs because you know that something will run forever. The strategy becomes, I don&amp;rsquo;t want to fix bug by hands. It&amp;rsquo;s, you have an auto healing index. You crawl a page for the first time, and let&amp;rsquo;s say you make a mistake. The number of links you counted is off by one. You know it was like this for three days because you deployed, it was broken. Three days later, you notice it, and you cannot go back in time. It&amp;rsquo;s already too&amp;nbsp;late.&lt;/p&gt;&lt;p&gt;Instead, what you do is that you fix your crawler. The way you store the data, you make sure that the next time you crawl the page, it overrides the previous version with something that is correct now. You have to have those auto healing processes, and you cannot attend to every small detail by hand, and the full rebuild of the index will be the last resort. Only if you have absolutely &amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:48:01]&lt;/strong&gt; Did that ever&amp;nbsp;happen?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:48:06]&lt;/strong&gt; It partially happened. Not everything, but there are things that were rebuilt once in a while. We were storing two things because we download pages, we download the HTML that we store, and then we have two counters. We have the counters we extract from the page. Let&amp;rsquo;s say you have one link that you see twice in a page. You have this link and the number two attached to it, and then you have diff. You store diff, let&amp;rsquo;s say, because you downloaded that page that belongs to the domain ahrefs.com. Now you see that that specific URL, for example, has three links that were not present&amp;nbsp;before.&lt;/p&gt;&lt;p&gt;You store somewhere plus three, and later on you will aggregate all those plus three, plus one, minus one together. There are two different things. You have the absolute numbers and then you have those diffs. Once in a while, we have a bug that we didn&amp;rsquo;t compute the diff correctly. Then we will rebuild the diff from scratch. We will go back to those absolute numbers, process them altogether and then restore it. Then when it happens, it can take a month, but it hasn&amp;rsquo;t been done in a long time. It&amp;rsquo;s a long&amp;nbsp;process.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:49:28]&lt;/strong&gt; Right. That&amp;rsquo;s interesting.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:49:32]&lt;/strong&gt; This is where OCaml is shining, too, because it&amp;rsquo;s very easy to have multiple versions of the same type, for example. If you store data, with a version number in the database, you have a&amp;nbsp;variant.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:49:48]&lt;/strong&gt; Yes, you treat it differently or?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:49:50]&lt;/strong&gt; It&amp;rsquo;s fairly automatic and-&amp;nbsp;yes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:49:59]&lt;/strong&gt; Yes, as well we have diffing on HTML. One of the big features that we did, I think that was last year, that we have diffing for the content of the page, or the diffing of links, we have as well diffing of content. That&amp;rsquo;s very&amp;nbsp;good.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:50:18]&lt;/strong&gt; We have a lot of small funny features. We are one of the first company after Google, obviously, to render pages at scale. We have hundreds of servers running chrome, and as much as possible, when we download the HTML of a page, which is the raw HTML, then we will put it in Chrome, let it run for a while and then get the rendered version of that. Which is incredibly expensive time-wise, because it&amp;rsquo;s much harder work than just downloading the HTML. We couldn&amp;rsquo;t do this if there was no project like Chrome that would be open source and usable for free. We are standing on the shoulders of giants for&amp;nbsp;this.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:51:08]&lt;/strong&gt; Imagine trying to create a web engine just to see a page from the server. That&amp;rsquo;s very good. What&amp;rsquo;s the favorite part of working at&amp;nbsp;Ahrefs?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:51:26]&lt;/strong&gt; To me, is the people. I&amp;rsquo;m not a SEO expert, and I&amp;rsquo;m not a SEO fan either. I didn&amp;rsquo;t join Ahrefs because I love to study the internet, that was not my goal, and I&amp;rsquo;m not a marketing person, so I don&amp;rsquo;t have a big use for SEO by myself. At first when I joined, the technical challenge was fun, but nowadays to me, the value is more the people. You get to meet smart people who work on complicated projects. I spend a lot of time dealing with interns, for example, which is super gratifying, I feel. I try to spend a good amount of time sharing with other people, working on the tooling or stuff like this. I really like that part, you can see the influence you have on other people when you make their life&amp;nbsp;easier.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:52:32]&lt;/strong&gt; That&amp;rsquo;s good. What&amp;rsquo;s your favorite part of&amp;nbsp;OCaml?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:52:37]&lt;/strong&gt; Of&amp;nbsp;OCaml?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:52:38]&lt;/strong&gt; Yes. You can say the&amp;nbsp;people.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:52:41]&lt;/strong&gt; When it compiles, it works. That&amp;rsquo;s the key point. Unlike Go, we have some&amp;nbsp;types.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;[00:52:41]&lt;/strong&gt; [laughter]&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:52:59]&lt;/strong&gt; If we are a bit serious, maybe not the language itself, but the LSP is super, super good nowadays. It&amp;rsquo;s definitely a very good experience. We have to thank Tarides for all the work they are doing on the tooling over the past three years now, because it&amp;rsquo;s&amp;nbsp;crazy.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:53:21]&lt;/strong&gt; I think Tarides is carrying most of the boring work. Not boring work, but work that is always hidden. That you don&amp;rsquo;t get any fame, but you will only get the trash. When the toolings don&amp;rsquo;t work, you complain, and when tooling works, you just don&amp;rsquo;t celebrate it. Tarides is behind, for sure. You have been going to ICFP, ICFP is international conference for functional programming, for quite some time. One of the verticals, or one of the parts of ICFP is&amp;nbsp;OCaml.&lt;/p&gt;&lt;p&gt;Last year we outgrow our neighbors, our language neighbors, I think it was Scala, maybe, Haskell. I think we outgrow them. What do you think about the conference?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:54:20]&lt;/strong&gt; Same thing, it&amp;rsquo;s amazing to go there and meet the people actually, because ICFP, it has multiple parts. The main track is a bit more academic. Even though some people who work at Ahrefs, they published there, but they were students when they did it. It&amp;rsquo;s a bit more academic. Then you have all the workshops that are a bit more approachable, at least for me, but you spend one week with smart people who are very excited by what they&amp;rsquo;re doing. This is the amazing part. Once a year, everyone is super happy to meet each other. This is very much a good experience, but it&amp;rsquo;s- about conferences, I think the ReasonML ones were very, very nice&amp;nbsp;too.&lt;/p&gt;&lt;p&gt;Again, I&amp;rsquo;m a back-end person, but it was super cool to attend a conference on a different topic where people have different interests, and it was the early days of the language for people who were super interesting, the people who attended were curious and wanted to see something new. They had different ideas. I think that was super&amp;nbsp;good.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:55:36]&lt;/strong&gt; Yes, those conferences were very good. I haven&amp;rsquo;t attended any, actually, but yes, I heard Javi saying amazing things about them. Almost everybody who attended said good things. Why there&amp;rsquo;s no OCaml conference?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:56:00]&lt;/strong&gt; This is a multifold answer, because it&amp;rsquo;s actually a question that was asked. There is this, how is it called, the OCaml Software Foundation, because if we can explain how OCaml, the management of OCaml is that&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:56:23]&lt;/strong&gt; Please do. As core contributor of the code of conduct, please&amp;nbsp;do.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:56:27]&lt;/strong&gt; There is the core group of contributors for the language, and out of that before there was something called the OCaml Consortium, I think, where companies could pay few thousand USD a year and it will give them a license to use OCaml not as an open source project. You could get the compiler and do changes on it and you didn&amp;rsquo;t have to publish the changes again. It was also a way to just sponsor the OCaml development. They took it to a different level. They created this OCaml Software Foundation that is pushing some efforts around&amp;nbsp;OCaml.&lt;/p&gt;&lt;p&gt;One question was, do we want to have an OCaml conference or do we want to have OCaml- maybe not conference, but smaller events but that could happen more often. Where will we put those events in the world? You need people with time, you need people with money, and you need to find the right place for the right people to attend. I think no one has all those resources, including the mental space to build fancy ideas on what to put in a conference. I cannot provide a definitive answer because I&amp;rsquo;m not the one deciding on all those things, but I think it&amp;rsquo;s a combination of all those that makes the ICFP the place to&amp;nbsp;be.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:58:05]&lt;/strong&gt; Right, because this year is on Seattle. Every year it changes the location.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:58:13]&lt;/strong&gt; Yes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:58:16]&lt;/strong&gt; Last year we released we- I didn&amp;rsquo;t but yes, OCaml released multicore and effects or handling effects. We chatted a bit, a lot at work about this, and I think you said multicore was not something that needs to happen, but you are not very excited. On the contrary, you said the effects are a big deal. Thinking about the person that doesn&amp;rsquo;t know a bunch about what effects are, could you do a short summary and then explain why those are exciting?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:59:01]&lt;/strong&gt; I&amp;rsquo;m not a specialist with effects either but to me, a parallel will be to talk about Rust. In Rust, you have those ways to, how is it called? Borrow checker. You have a way to know to who one value belongs. It heavily affects how you are writing code because then you need to architecture your code in a way that is safe. Do you know that, for example, that value can only be used by one bit of code at a&amp;nbsp;time?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [00:59:45]&lt;/strong&gt; Right. Otherwise, you would have crazy bugs. Data corruption&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [00:59:56]&lt;/strong&gt; That would be C. Rust came in and was provided this safety. That&amp;rsquo;s a bit the same idea in OCaml. It&amp;rsquo;s like you come with effects and I think it has many usages that I do not completely understand, but some of them allow us to change the way we do concurrent or parallel computations, and it makes it safe. Like the borrow checker makes the Rust code safe. This is definitely affecting the way you write code because now you have one more tool to express your ideas. I think this is definitely changing the way the language will be&amp;nbsp;used.&lt;/p&gt;&lt;p&gt;While the multicore, it&amp;rsquo;s just in the background, it is happening, but this is not the tool. This is just a mean, so it&amp;rsquo;s like, how do we do fast computation? Do we need to split stuff on different cores and how do you do it? Either you fork or you do multicore. In a way, it could be completely hidden behind a magic API and I will not know if it&amp;rsquo;s fork or multicore, and it&amp;rsquo;ll be fine to me as a user. If you have something like the borrow checker in Rust, this is actually a language feature, and this is something I see day to day and it is affecting how I can think and what I can&amp;nbsp;express.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:01:36]&lt;/strong&gt; Right. I see, I see. Yes, because right now one of the features that Jane Street, the famous company that does the Wall Street and whatnot and pushes OCaml for the next level, they have a team working on the OCaml compiler, and one of the big fears that they want to work on, I think, they call it locality or local, global variables. Would that express, I have no idea about those rather than watching Stephen Dolan at the presentation on last ICFP, but would that allow some of the users of OCaml that they do care about the memory layout or the owner of the variables to express those different changes regarding using multicore?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:02:34]&lt;/strong&gt; I don&amp;rsquo;t know exactly&amp;#8202;&amp;mdash;&amp;#8202;My own&amp;#8202;&amp;mdash;&amp;#8202;I mean, I have a light understanding of that. To me, I think it would be interesting even if there was no multicore, the stuff they&amp;rsquo;re doing local/global because we already had concurrency with lwt or stuff like this. It has benefits because you control your allocations too. You can decide what is allocated on the stack versus what is allocated on the heap. It can have big performance implication.&lt;/p&gt;&lt;p&gt;This is an exciting feature, but this is maybe where you see my C background that when I was in uni, the first year was just writing some C code and we had to rewrite Bash. We had our own version of Bash. We spent two months writing in Bash or stuff like this. We had to deal with many of the small like&amp;#8202;&amp;mdash;&amp;#8202;You are launching a bunch of processes together and you have to manage your memory or whatever, or we had to rewrite malloc, so we&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:03:53]&lt;/strong&gt; Okay.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:03:56]&lt;/strong&gt; I know little bits about memory management and how to deal with pointers because I did those projects in the past. These local, global things seems appealing, but at the same time, it&amp;rsquo;s probably not critical. It&amp;rsquo;s not going to change the vast majority of the code that is written in general. All my small personal projects or even most of the code that is running at Ahrefs, performance is not key. I care more about the fact that the code is readable and stable rather than performance, I would&amp;nbsp;say.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:04:42]&lt;/strong&gt; Yes. Only in somewhere else. Yes, I see your point. Usually, code, for example, just like a web API were way, way fast enough. There&amp;rsquo;s no point to optimize the endpoints. Most of our endpoints I think we have 500 endpoints. That&amp;rsquo;s optimizing one by one or optimizing 10% of them, they would not change absolutely anything.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:05:10]&lt;/strong&gt; We spend so much time doing queries to different databases or http query to gather whatever we need to gather before to answer a request. This is so expensive compared to what we do most of the&amp;nbsp;time.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:05:28]&lt;/strong&gt; Right. That&amp;rsquo;s true. That&amp;rsquo;s true. Why do you think Ahrefs is such a different company? When I have experience with the&amp;#8202;&amp;mdash;&amp;#8202;It&amp;rsquo;s because of the culture maybe? Here we don&amp;rsquo;t have real management, we don&amp;rsquo;t have product owner. We don&amp;rsquo;t have many things that when you come from working on the SaaS companies that are from the culture of US maybe, or some Europe companies. In Ahrefs we don&amp;rsquo;t have anything like that. Can you say that it&amp;rsquo;s good or bad and&amp;nbsp;why?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:06:07]&lt;/strong&gt; It&amp;rsquo;s good and bad. There are definitely some downsides. Why it&amp;rsquo;s like this, is also because the company is young and small too. It&amp;rsquo;s what? 10 years old so it takes time. Every time you want to make a change company-wide, it probably takes two years to actually make change&amp;nbsp;happen.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:06:33]&lt;/strong&gt; Okay.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:06:35]&lt;/strong&gt; This is not the only company with a structure that is not well&amp;nbsp;defined.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:06:44]&lt;/strong&gt; Right.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:06:44]&lt;/strong&gt; What happens is that there is a structure, it&amp;rsquo;s just people don&amp;rsquo;t have the title because actually when you have been in the company for a long time, you own some bits of codes and there are people who are expert on the subject. Then there are people that you trust for something and people that you trust for something else. Even though there is no direct management, there are people taking decisions, so who is taking the decision, right?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:07:16]&lt;/strong&gt; Right.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:07:17]&lt;/strong&gt; It&amp;rsquo;s good to be flexible and it allows more or less anyone at some point to take a decision if they want to and if they dare to. The downside is that sometimes you don&amp;rsquo;t know if you can take the decision or not, and you don&amp;rsquo;t know who you should talk to and then there are some hidden politics because some products, some features there, they belong to someone. You don&amp;rsquo;t want to offend that person so you can&amp;rsquo;t go and touch this or stuff like&amp;nbsp;this.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:07:51]&lt;/strong&gt; Well, I need to interrupt here. I think you have been way too long at Ahrefs to realize what politics&amp;#8202;&amp;mdash;&amp;#8202;What it means because in Ahrefs there&amp;rsquo;s literally zero politics or not politics, but battles or discussions for the sake of discussion, it&amp;rsquo;s nearly zero. I think that&amp;rsquo;s one of the things that at the beginning of like, are we not talking about this and somebody said no need to. It&amp;rsquo;s the culture of getting very direct and very technical focus.&lt;/p&gt;&lt;p&gt;I think when you work in a company that you can be weeks without knowing what to do or just months working on so many processes that are close to useless from your point of view or maybe very beneficial from an individual contributor, you feel like you are losing your time. In Ahrefs I don&amp;rsquo;t think I have been noticing a layer I thought I&amp;rsquo;m losing time because of the company it&amp;rsquo;s the other way around. Oh, my peer is asking me to implement something that needs to be done and I haven&amp;rsquo;t finished yet. That&amp;rsquo;s more the feeling of the work,&amp;nbsp;right?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:09:09]&lt;/strong&gt; I guess it&amp;rsquo;s not politics looking for power because there is no power to&amp;nbsp;gain.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:09:16]&lt;/strong&gt; Exactly.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:09:17]&lt;/strong&gt; What do you want to own? There is nothing to own. You can try, but there is nothing to win at the&amp;nbsp;end.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:09:26]&lt;/strong&gt; Getting to the last questions now, but have you been following a little what Javi and Antonio and a little bit of myself having worked in Melange. What&amp;rsquo;s your opinion about&amp;nbsp;Melange?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:09:43]&lt;/strong&gt; I know what Melange&amp;nbsp;is.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:09:46]&lt;/strong&gt; Definitely.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:09:47]&lt;/strong&gt; Okay. What do I think about Melange? Again, it&amp;rsquo;s a question that is hiding other questions. Let&amp;rsquo;s say technically, for example, this is pretty impressive. What the four of you have been able to do in a few months is amazing. Because just to give some context, it&amp;rsquo;s like moving&amp;#8202;&amp;mdash;&amp;#8202;Okay, Melange was not super, super alive, six months ago. The project was moving but slowly. There was no Dune support, there was not much stuff happening. Then six months later, you have the whole Ahrefs front-end, which is like, hundreds of thousands of lines of code that are written by what? 30 people maybe&amp;nbsp;now.&lt;/p&gt;&lt;p&gt;It&amp;rsquo;s completely moved to Melange. This is amazing. I&amp;rsquo;m able to compile all this code in one comment. I go in the repo, I do &amp;ldquo;make dev&amp;rdquo; and everything works.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:10:56]&lt;/strong&gt; These and many more advances, but yes, that&amp;rsquo;s the part that it&amp;rsquo;s&amp;nbsp;funny.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:11:04]&lt;/strong&gt; Yes, it&amp;rsquo;s amazing. It automatically works and it didn&amp;rsquo;t break the experience of anyone so it&amp;rsquo;s compatible with what was bucklescript or rescript beforehand. It&amp;rsquo;s compatible with native code at the same time. It&amp;rsquo;s amazing. What do I think about the project? Another side of the question will be, was it the right thing to do to fork rescript? Or, is it the right way to do it? Is it good to have a fork of the compiler inside of Melange to achieve that project? I don&amp;rsquo;t have a strong opinion on&amp;nbsp;it.&lt;/p&gt;&lt;p&gt;I don&amp;rsquo;t have enough experience. After all those years of seeing Reason and Bucklescript evolving, I believe that the experience of the end user, so the developer that is using these tools, is more important than the technical implementation. Is it the best way to do it? I don&amp;rsquo;t know. Does it give a good end user experience? Yes, then that was the right thing to&amp;nbsp;do.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:12:21]&lt;/strong&gt; On those tools, you would always prioritize the developer experience, rather than technical merits? How would you choose&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:12:33]&lt;/strong&gt; As a user or as a developer of those&amp;nbsp;tools?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:12:36]&lt;/strong&gt; As a developer of those&amp;nbsp;tools.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:12:39]&lt;/strong&gt; As a developer of those tools, given the target, given what I see of how you build a community and it&amp;rsquo;s like the early days of Melange, I would prioritize user experience. I think, for example, all the efforts that have been put into making Dune work, I think the target was the user experience at the end. Because we couldn&amp;rsquo;t make it work another way. If we didn&amp;rsquo;t have this, I&amp;rsquo;m not sure that we would have moved to Melange, for&amp;nbsp;example.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:13:19]&lt;/strong&gt; I&amp;nbsp;see.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:13:20]&lt;/strong&gt; What&amp;rsquo;s the downside was that for example, this is not the fastest implementation there is. I think there is some many different calls to this Melange compiler that are not the fastest way to do it, but the UI is good so we still use&amp;nbsp;it.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:13:44]&lt;/strong&gt; What I would like to feature, knowing that at the start Bucklescript got born, even though they were like js_of_ocaml. Now, I think, eight or nine years past, Rescript got its own path, but then Melange is trying to again, be part of the OCaml to Javascript compilation, or Reason to Javascript compilation. How do you see the future? Because eventually, nobody wants to have two ways to Javascript.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:14:16]&lt;/strong&gt; I&amp;rsquo;m not sure that&amp;rsquo;s true. Why would people not want many ways to do the same thing? It&amp;rsquo;s like if you look at other languages, actually, many of them have different ways to do the same thing. Why not OCaml? As long as the projects don&amp;rsquo;t die, it&amp;rsquo;s not like Melange is attacking jsoo or jsoo is attacking Melange. It&amp;rsquo;s like, people don&amp;rsquo;t hate each other. They are not fighting for users; I think the targets are a bit different.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:14:53]&lt;/strong&gt; You would want different ways of combining to Javascript? Because the sane competition? That&amp;rsquo;s&amp;nbsp;true-&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:15:03]&lt;/strong&gt; To me it&amp;rsquo;s not the sane competition. It&amp;rsquo;s more that I think it targets different audience. It tries to do different things. One example will be during one of the Reason conferences, we wanted to do a workshop and we wanted to show atdgen which is a tool we&amp;rsquo;re using a Ahrefs lots to parse and write JSON. It&amp;rsquo;s protobuf but for&amp;nbsp;JSON.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:15:34]&lt;/strong&gt; Yes, it would give us type safety from front end all the way down. Sorry, backend all the way&amp;nbsp;down.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:15:43]&lt;/strong&gt; Yes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:15:43]&lt;/strong&gt; Sorry, go&amp;nbsp;on.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:15:46]&lt;/strong&gt; You have as with protobuf or with Graphql too you have a definition, you have a file with type definitions and from the definition you derive OCaml code or Python code or TypeScript code. It supports multiple languages. To do so you need an atdgen binary. In the Reason conference, you have people using Linux, Windows, Mac, different version, whatever so how do you give a binary that everyone can use? In two minutes, I just went into the atdgen repo and I enabled js_of_ocaml compilation inside Dune and now my binary is actually JS file that I can run in node&amp;nbsp;JS.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:16:34]&lt;/strong&gt; Right.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:16:35]&lt;/strong&gt; I don&amp;rsquo;t think that Melange aims to do that. Because then&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:16:41]&lt;/strong&gt; I think that&amp;rsquo;s the magic. Yes, I&amp;nbsp;agree.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:16:44]&lt;/strong&gt; In Melange you will have one file per module or something like this, which means I will need to run through webpack or something like this later&amp;nbsp;on.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:16:51]&lt;/strong&gt; Yes, you could but you would face a few problems. Marshall for example, that it&amp;rsquo;s the encoding/decoding on bytes, that doesn&amp;rsquo;t work in&amp;nbsp;Melange.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:17:01]&lt;/strong&gt; Well, it doesn&amp;rsquo;t work in js_of_ocaml I think&amp;nbsp;too.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:17:05]&lt;/strong&gt; Yes, but I think you can stub it, right? I think you can&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:17:10]&lt;/strong&gt; But I would say most of the time actually you don&amp;rsquo;t care because it&amp;rsquo;s corner cases, it&amp;rsquo;s just that the UI they provide is good enough for OCaml people and Melange, it provides the nice, what? FFI, for example, to interact with the JavaScript code. The way it outputs code is closer to the JavaScript way too; I would say so it&amp;rsquo;s easier to make webpack or other tools like this work&amp;nbsp;together&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:17:39]&lt;/strong&gt; Yes, I agree that those are different targets. It just my point of view was more like, okay, js_of_ocaml the crazy thing is that you have entire project in OCaml. You add one line say in Dune compile to node JS please and then you have a single file that is compiled to JavaScript. That&amp;rsquo;s insane so if you have, for example, a compiler written in Menhir it&amp;rsquo;s a language to write compilers in OCaml, you can compile it to JavaScript in one line or any library, even drivers, even anything that you can imagine. That&amp;rsquo;s the valuable position or thing that gets people to try js_of_ocaml very fast. But on the contrary, the documentation is very&amp;nbsp;bad.&lt;/p&gt;&lt;p&gt;It&amp;rsquo;s the classic OCaml project that you need to understand 50% of the project to even start it so that&amp;rsquo;s like&amp;#8202;&amp;mdash;&amp;#8202;For people like me, I invest a lot of time trying js_of_ocaml and even try to write bindings to React and succeed but I did not succeed convincing people in Ahrefs, front end of Ahrefs to try js_of_ocaml. For me, that was the&amp;#8202;&amp;mdash;&amp;#8202;That technology is not good enough for prime time or not good enough to convince my team, then yes, there&amp;rsquo;s no way to convince any&amp;nbsp;other.&lt;/p&gt;&lt;p&gt;On the opposite, Melange fits together the low barrier to try and good documentation and at some point, it gets complex but the ease of experience I think it&amp;rsquo;s much better. But yes, you don&amp;rsquo;t have a one line&amp;#8202;&amp;mdash;&amp;#8202;You need to meddle it a bit on building the integration with your front end or your pipeline but yes, once it is done, it works. But yes, you would never do that with atd. The experience in atdgen that&amp;rsquo;s not going to happen in&amp;nbsp;Melange.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:19:41]&lt;/strong&gt; It&amp;rsquo;s funny how you say it and it&amp;rsquo;s true that it&amp;rsquo;s easier. Many things in Melange are easier to experiment with and at the same time it&amp;rsquo;s more complicated. For example, in js_of_ocaml you have a clear separation between OCaml types and JavaScript types. String that is an OCaml string is a different type from JavaScript string.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:20:10]&lt;/strong&gt; You have like a wrapper,&amp;nbsp;right?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:20:12]&lt;/strong&gt; It&amp;rsquo;s very explicit and it&amp;rsquo;s good for the OCaml person because then you know when this is a part of the language you are comfortable with and then when it starts with JS, it&amp;rsquo;s okay, be careful because you don&amp;rsquo;t know what you are doing. This is easy and in js_of_ocaml. Because it&amp;rsquo;s very easy. You see JS dot and then you know now I have a JavaScript value. In Melange it&amp;rsquo;s your string is what? And you have to deal with the encoding. What is the actual encoding of a string in&amp;nbsp;Ocaml?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:20:57]&lt;/strong&gt; Do you remember that I said that every time that I&amp;rsquo;ll talk with a backend person, they always mention the runtime. Exactly that moment. You always think about the&amp;nbsp;runtime.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:21:06]&lt;/strong&gt; Actually, I&amp;rsquo;m not&amp;nbsp;sure.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:21:08]&lt;/strong&gt; It&amp;rsquo;s not the runtime itself, but the encoding. In Melange for example, of course, all the types not of course, but all the types that you have in language are the same representation as a JavaScript value. For example, a string is in a string, integration is a number, float is a number and so on and so forth. Variant is an object; a record is an object. Melange maps perfectly or as good as possible to JavaScript values. It&amp;rsquo;s cool that you said that when every time that you work with js_of_ocaml, once you see JS dot, whatever this is the namespace and you know that you&amp;rsquo;re treating with things that come from the&amp;nbsp;client.&lt;/p&gt;&lt;p&gt;For example, that&amp;rsquo;s a barrier for people that tried rescript or tried Melange in the first place because they don&amp;rsquo;t understand why do I need a wrapper? Why do we need a generic for at type that already have? Because it&amp;rsquo;s the mentality of why do I need to care about the&amp;nbsp;runtime?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:22:17]&lt;/strong&gt; Yes, basically you pay a cost but at a different time, like in js_of_ocaml, you pay the cost very early because as soon as you write code you need to make the difference between the two words. In Melange you will only pay the cost if you write FFI and you need to care about the representation. It&amp;rsquo;s if there is a string with something weird in it, you don&amp;rsquo;t know the encoding of the string, for example, then you need to be&amp;nbsp;careful.&lt;/p&gt;&lt;p&gt;The experience by default is much easier. It&amp;rsquo;s just that when you are dealing with the boundaries then things can be a bit more implicit and probably you need to know the language better to do things the right way. It&amp;rsquo;s easier and it&amp;rsquo;s actually more complicated in some&amp;nbsp;bits.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:23:08]&lt;/strong&gt; Yes, I think if you look now, js_of_ocaml and Melange are very drawn line. You can draw a line between the tradeoffs. One side is very clear, one side is very clear. Now, I would say that I&amp;rsquo;m comfortable saying that both are balanced for the users, even rescript now. For me now, I have a feeling the three of projects are in the right column. You can classify them perfectly now. If you get into, &amp;ldquo;Oh, I want to try this ML or like OCaml, whatever language as a whole,&amp;rdquo; you can choose&amp;#8202;&amp;mdash;&amp;#8202;Based on your team or your decision. You can choose clearly one&amp;nbsp;another.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:23:57]&lt;/strong&gt; Yes. Actually, you said you couldn&amp;rsquo;t sell js_of_ocaml to Ahrefs, but we can probably talk a bit about what was the discussion, what happened, because Javi and you, you actually tried to do something so that it could happen. You work on the React bindings and then you try to show that it could work. In a way, I think that js_of_ocaml, it could fit what we do because we don&amp;rsquo;t depend on a lot of external code. One very interesting thing in Melange is that the FFI is very good. It&amp;rsquo;s easy, convenient, to interface with other existing JavaScript libraries.&lt;/p&gt;&lt;p&gt;In Ahrefs, we have bindings to what, React, and then maybe one or two library to deal with the timestamps and charts. We don&amp;rsquo;t have millions of bindings. We have maybe five big libraries we have bindings for, and then a bunch of smaller stuff. We don&amp;rsquo;t bind to so many things and we don&amp;rsquo;t need FFI that is amazing. It&amp;rsquo;s not a priority. js_of_ocaml could have&amp;nbsp;worked.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:25:14]&lt;/strong&gt; Could have worked. I&amp;nbsp;agree.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:25:16]&lt;/strong&gt; The fact that even in this perfect setup for js_of_ocaml it fails is interesting. You find the right company with many OCaml people, many people who understand js_of_ocaml, and you don&amp;rsquo;t need one of the best features of Melange and still, this is not actually the tool that won at the&amp;nbsp;end.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:25:42]&lt;/strong&gt; Yes, that&amp;rsquo;s true. The experience, I think that&amp;rsquo;s exactly what you said, it could work, theoretically if you look at the direct from the outside or even if you look at far from the front end, it makes a lot of sense. Once we were working on this, I was working on this middle-end team, before it was not called middle-end. I was working on the middle-end, and most of my assumptions were like, &amp;ldquo;It&amp;rsquo;s going to work perfectly.&amp;rdquo;&lt;/p&gt;&lt;p&gt;Because of what you said, right? Then when we try to&amp;#8202;&amp;mdash;&amp;#8202;How can we write React, we are married to React. I think we like the model of components. We like the model of data; we like the composition. We&amp;rsquo;re not going to change React. Let&amp;rsquo;s bind it to React, so we create the same PPX and the same library to React. I think that was how Javi started and then we end up finishing.&lt;/p&gt;&lt;p&gt;did the emotion binding, so I know the CSS, everything worked and we felt like js_of_ocaml was very mature, but there were a few problems that you could not solve easily at the time. At the time js_of_ocaml didn&amp;rsquo;t have Unicode support. Now they have some Unicode support or the parsing, I haven&amp;rsquo;t followed that closely, but you would need another library to run to get the Unicode support that in Melange or Bucklescript at the time was natively. That was an issue. The other issue or biggest issue that you can&amp;rsquo;t bypass is that js_of_ocaml, you compile it in one file, one gigantic&amp;nbsp;file.&lt;/p&gt;&lt;p&gt;Incremental migrations were very hard or very difficult to iterate over time. You could migrate parts of the app, but then you would need to compile everything in both, have two duplicated apps. It was definitely not&amp;#8202;&amp;mdash;&amp;#8202;The migration plan was impossible. We could try. I think we tried in one of the small apps, I think we could try wordcount, is one of the verticals we have at Ahrefs, with js_of_ocaml, and once we were trying those, we find the wrapper, it was very hard to&amp;nbsp;sell.&lt;/p&gt;&lt;p&gt;The wrapper is like the Js.t that we call it in Recript, in js_of_ocaml I think it&amp;rsquo;s JS.object. It&amp;rsquo;s unsafe. You have JS.unsafe. There are many, yes, many constructions you can track with JavaScript differently from what we do with the bindings. That part was&amp;#8202;&amp;mdash;&amp;#8202;With these three things that I said Rusty, which is one of let&amp;rsquo;s say the only Tech Lead at Ahrefs, like the only person that&amp;#8202;&amp;mdash;&amp;#8202;He&amp;rsquo;s the CTO in the frontend, how I call&amp;nbsp;it.&lt;/p&gt;&lt;p&gt;He was the person who we would need to convince to migrate to the frontend. He was definitely not on board with the idea. I think that&amp;rsquo;s the main reason. He would chat with our people and people would say, &amp;ldquo;Yes, fine, if Javi and David are happy, then we are all happy,&amp;rdquo; but even though we migrate one small app, the experience was worse. The user experience of iterating over React components was worse or even the data was worse because you had this&amp;nbsp;wrapper.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:29:23]&lt;/strong&gt; There were too honest in the way they named functions in the API. For example, all those unsafe functions, they exist in every FFI, it&amp;rsquo;s just not called unsafe, but because it&amp;rsquo;s called unsafe, people are like, &amp;ldquo;They&amp;rsquo;re not going to use this, you are not supposed to use it.&amp;rdquo; Yes, you&amp;rsquo;re supposed to use it. Just be careful when you do&amp;nbsp;it.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:29:47]&lt;/strong&gt; I think you explain to me that anecdote, is that somebody asked Xavier Leroy the creator, the author of OCaml, they ask, &amp;ldquo;What do you think about Objec.magic?&amp;rdquo; Right? Object.magic is the method of OCaml that you can, like unsafe, coerce any variable, right? You can light the typechecker and say, &amp;ldquo;Trust me, this is whatever, an array and it&amp;rsquo;s a list or whatever&amp;rdquo;. His answer was, it is like when you are working in the street, would you inject&amp;#8202;&amp;mdash;&amp;#8202;How is that called? I don&amp;rsquo;t remember the thing, but would you become a&amp;nbsp;junkie?&lt;/p&gt;&lt;p&gt;You get a syringe, I don&amp;rsquo;t know how to say in English, but would you inject some random thing on the street? That&amp;rsquo;s not part of the language. I think you&amp;rsquo;re explained me the anecdote, or maybe it&amp;rsquo;s Javi, How do you see the purity of OCaml? Do you think that the OCaml is very pure or has some pragmatism on safety? Because of course it&amp;rsquo;s type safe, of course, the compiler when it compiles it works, but you can bypass it from time to time. What&amp;rsquo;s your&amp;nbsp;opinion?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:31:10]&lt;/strong&gt; I don&amp;rsquo;t think it&amp;rsquo;s pure in any way, shape, or&amp;nbsp;form.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:31:17]&lt;/strong&gt; You can write pure code,&amp;nbsp;right?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:31:20]&lt;/strong&gt; Yes. You can write pure code. But for example, you have exceptions that are very pregnant, that are everywhere and you don&amp;rsquo;t have any way to know if a function can raise an exception or&amp;nbsp;not.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:31:37]&lt;/strong&gt; Right.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:31:38]&lt;/strong&gt; Okay, it depends what program you write, but basic things, you run your program, like a CLI that is running&amp;#8202;&amp;mdash;&amp;#8202;I don&amp;rsquo;t know, downloading something and you press control C like you want to stop your program. There is&amp;#8202;&amp;mdash;&amp;#8202;It&amp;rsquo;s a signal, and in OCaml it&amp;rsquo;ll raise an exception that you need to&amp;#8202;&amp;mdash;&amp;#8202;You can catch and you can do something with it, right? At any point in time, the user of your CLI can come and interrupt the program, right? Which means at any point in your program, you need to be able to deal with this interruption.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:32:18]&lt;/strong&gt; Right.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:32:19]&lt;/strong&gt; It&amp;rsquo;s like as soon as you have these where is the purity, what is&amp;#8202;&amp;mdash;&amp;#8202;You have no good way to protect yourself against all these issues. At the same time, I&amp;rsquo;m probably biased because I have been using the language for long. It provides you what is good enough. There was some improvements because, I don&amp;rsquo;t know if you remember, but at some point, the strings were mutable in&amp;nbsp;OCaml.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:32:51]&lt;/strong&gt; Yes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:32:53]&lt;/strong&gt; By defaults, the strings were actually what is called Bytes nowadays. It has been a big change. People had to fight to turn Bytes into string, because it was breaking code, obviously. There was more mutability. It was not as pure as it is nowadays, I would say that the balance is not too bad. Could it be more? Probably. There are some things that we can&amp;rsquo;t really express in OCaml, like ownership of a&amp;nbsp;value.&lt;/p&gt;&lt;p&gt;Like you open connection to a database, you have a handler or something like this that you want to use only at one point in time and you don&amp;rsquo;t want to share. You have no way to express it. Then you can&amp;rsquo;t really protect yourself against the steal. The code can take that value, put it in a global reference, and it can be suddenly reused elsewhere. This is where, for example, the local/global stuff&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:34:06]&lt;/strong&gt; Yes, solve exactly that&amp;nbsp;issue.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:34:09]&lt;/strong&gt; Yes. This kind of issue. Is it a problem? Yes. Is it a problem that we face at work? Yes. For example, we see like&amp;#8202;&amp;mdash;&amp;#8202;We have one problem where people can open the connection to a DB using one of those&amp;#8202;&amp;mdash;&amp;#8202;A common pattern in the ocaml to do like &amp;ldquo;with_db&amp;rdquo; for example. Then you pass a continuation, you pass a function, and then this with_db function will create a DB handler and pass it to your function later&amp;nbsp;on.&lt;/p&gt;&lt;p&gt;Inside your function, you can do one more with_db. This is something that you probably want to forbid because you don&amp;rsquo;t want to open connections after connection after connection when there is already one available.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:34:57]&lt;/strong&gt; Right.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:35:00]&lt;/strong&gt; For now, how do you fix this? This is an actual problem and you have no good solution. But maybe you write different code than I do. You write code that is in the browser or just behind the browser so maybe you have different views. You have to deal with more mutability than I do, for example the whole DOM, before React. Yes, but before React no one assumed that anything was immutable in a browser. Everything could be changed at any point in&amp;nbsp;time.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:35:43]&lt;/strong&gt; Yes. That&amp;rsquo;s why in the browser many APIs were pushing for observables, right? You accept mutability into all your values and then you say any value can change in any time and you need to subscribe to&amp;#8202;&amp;mdash;&amp;#8202;Listen to the changes or not and that&amp;rsquo;s the trend of&amp;#8202;&amp;mdash;&amp;#8202;I think that was one of the biggest inclusions of ES4 that didn&amp;rsquo;t get published and they tried with ES5 and they didn&amp;rsquo;t get to the language neither that are like these observables concept. I think they come from React JS and they come from reactive programming from, I don&amp;rsquo;t know, 30 years ago where sometimes reactive is very useful. Before React, I would say that not many people did&amp;#8202;&amp;mdash;&amp;#8202;The immutability was not part of their fashion of writing&amp;nbsp;code.&lt;/p&gt;&lt;p&gt;We are very far from those problems. We do immutability in a few places, for example, we have a global theme, a CSS theme, right? You can have a dark or light theme. We interact with the browser directly. We opt out from React to do that because the performance is better. You can load that at the beginning, you can then allow React later. But the way it&amp;rsquo;s just very self-contained, right? You will never want to write your data reactive.&lt;/p&gt;&lt;p&gt;Maybe you want, but for example, for Ahrefs it doesn&amp;rsquo;t make any sense because our data is you have tabular data that never changes on your session, right? It&amp;rsquo;s not live data. It&amp;rsquo;s like you open a report and the report is the moment time that you request. There&amp;rsquo;s no live thing. Nothing is very reactive in nature so yes, for us it&amp;rsquo;s just like a perfect&amp;nbsp;sense.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:37:41]&lt;/strong&gt; You would be happy with more&amp;nbsp;purity?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:37:45]&lt;/strong&gt; Would we be happy with more purity? No, I think&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:37:49]&lt;/strong&gt; Would you wish to have a language that is closer to Haskell that is like&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:37:54]&lt;/strong&gt; No, I don&amp;rsquo;t think so. I think no, because purity makes&amp;#8202;&amp;mdash;&amp;#8202;Purity in some places makes your life so much better, right? But often you want the tools to be pure so like libraries that you create or you consume need to be pure but your application needs to do all sort of things, right? Your application or when you are a product engineer, you want to just ship fast and if something gets you in your way and you store it globally and deal with it later or store it globally and be safe and then forget about&amp;nbsp;it.&lt;/p&gt;&lt;p&gt;You need to do things perfectly and draw the line and architect things that slows you down insanely. I think the line&amp;#8202;&amp;mdash;&amp;#8202;OCaml is very well position where you can opt out, do your life easy and then move back and run fast. But yes, my tools to be pure or libraries that I&amp;rsquo;m using or even&amp;#8202;&amp;mdash;&amp;#8202;I know I&amp;rsquo;m working on styled-ppx so making types safe, like your styles. I think that&amp;rsquo;s something that I&amp;rsquo;ve been pushing but yes, you want that tool to be type&amp;nbsp;safe.&lt;/p&gt;&lt;p&gt;You don&amp;rsquo;t want to do all your things on your app perfectly, to demand it perfectly mostly because on the web, everything is changing all the time. On the backend it&amp;rsquo;s a little bit different but on the web, iterations are just much more common than in the&amp;nbsp;backend&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:39:31]&lt;/strong&gt; I find it interesting that everyone is pushing for immutable stuff. At least my impression is that in the front end React maybe didn&amp;rsquo;t create this trend but made it popular. My understanding is that you deal with the DOM as an immutable object. You never manipulate the DOM directly anymore. You do it through React. You have an immutable object, more or less, which goes against many things that happened, historically in a browser, the way the DOM is implemented is completely not like this. It has some interesting benefits.&lt;/p&gt;&lt;p&gt;You can have any extension in your browser that are changing part of your page. I&amp;rsquo;m using one daily. I&amp;rsquo;m using Dashlane to store my passwords. It does stuff for&amp;#8202;&amp;mdash;&amp;#8202;If there is an input field, it&amp;rsquo;s creating a popup and I can click, input my password in that specific&amp;nbsp;field.&lt;/p&gt;&lt;p&gt;To do this, it has to inject HTML in the page actually. But it breaks. Some apps are crashing because of this. Some apps, some websites, they&amp;rsquo;re not crashing. They will just see that there is a change coming from my extension and they will just discard it and rerender without my&amp;nbsp;stuff.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;I&lt;/strong&gt;t goes against many things that happened for 20 years, more or less. You have to make both of those worlds still somehow work together.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:41:18]&lt;/strong&gt; I think React did&amp;#8202;&amp;mdash;&amp;#8202;I think not even React, Meta did that all the time. They pushed for a solution that is way better in some areas but destroys previous effort insanely. For example, with GraphQL, I think it&amp;rsquo;s happened the same. They say, &amp;ldquo;You&amp;rsquo;re going to have one endpoint. It&amp;rsquo;s going to be through POST.&amp;rdquo; You would call this endpoint all the time, which goes against completely about REST what we were doing&amp;nbsp;before.&lt;/p&gt;&lt;p&gt;Of course, with all the tradeoffs, if you go 10 times&amp;#8202;&amp;mdash;&amp;#8202;10 years back and you say to a person, &amp;ldquo;No, we call all the time same endpoint.&amp;rdquo; You will say, &amp;ldquo;You guys are&amp;nbsp;stupid.&amp;rdquo;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:41:58]&lt;/strong&gt; RESTful was a&amp;nbsp;trend.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:42:00]&lt;/strong&gt; Exactly. The RESTful, you will need to add the link to go to the next resource. Of course, all the people would scream at you. Similarly, it happens now with server components. I don&amp;rsquo;t know if you are following the thing. Again, they are pushing for a new concept that they have mined in their business and works well. The rest of the people are like, &amp;ldquo;No, that&amp;rsquo;s just insanity.&amp;rdquo; I think React, the first concept is you&amp;#8202;&amp;mdash;&amp;#8202;The insert and update are the same operations.&lt;/p&gt;&lt;p&gt;There&amp;rsquo;s no create the DOM and then update the DOM. It&amp;rsquo;s always like, &amp;ldquo;Do the thing.&amp;rdquo; It&amp;rsquo;s just rerender. Just because they push for that approach and they delay, of course, the first load is going to be slower. You don&amp;rsquo;t have serialization. Then later updates are going to be&amp;nbsp;faster.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:42:58]&lt;/strong&gt; Actually, even the later update are slower, because you need React to do this diff between the two version and to only update the relevant part of the DOM. React is doing what the browser was actually doing. You are duplicating the work and you are doing it in JavaScript, which is slow. The browser was doing it in a very optimized C++&amp;nbsp;code&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:43:26]&lt;/strong&gt; Fair point, but the DOM is fast enough. I think I read a lot of articles about anti-React that the DOM is fast enough. I think that&amp;rsquo;s&amp;#8202;&amp;mdash;&amp;#8202;These benchmarks are nonsense. Those benchmarks&amp;#8202;&amp;mdash;&amp;#8202;Even the benchmarks that&amp;#8202;&amp;mdash;&amp;#8202;I would call it micro-benchmarks. Even microbench like&amp;#8202;&amp;mdash;&amp;#8202;I don&amp;rsquo;t know, work faster, implement some charting library mutable to DOM and using whatever, Vanilla JavaScript or using React. Of course, you can outperform React but at what&amp;nbsp;cost.&lt;/p&gt;&lt;p&gt;The cost of creating two charts, two components of a chart, the API nicely, blah blah blah blah rather than mutating the DOM all the time. That&amp;rsquo;s super expensive. When you&amp;rsquo;re working, for example, for Ahrefs, I think we have&amp;#8202;&amp;mdash;&amp;#8202;I don&amp;rsquo;t know, 2 million lines of code in reason. I don&amp;rsquo;t know, 5,000 components. Some insane amount of number of components. If you do that in mutable or maybe not mutable but maybe just going to DOM and listening to DOM and hoping that everybody is a good citizen. It&amp;rsquo;s just you would slow down development so hard that it doesn&amp;rsquo;t make any&amp;nbsp;sense.&lt;/p&gt;&lt;p&gt;I think React draw this line where virtual DOM is like if you know how to create the structures, know how to trigger the renders, I think can be as good as the DOM, of course. In general terms, I think it&amp;rsquo;s good enough. I think the balance is very OCamly. [laughs] You know that Jordan was behind, when&amp;#8202;&amp;mdash;&amp;#8202;Jordan is an OCamler that knows this balance, that&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:45:23]&lt;/strong&gt; It&amp;rsquo;s funny, because you could say that for example Facebook has enough resources to make it work, right? They could have decided it is going to be a more troublesome for our developers, but we are going to offer a faster experience for the customers, the people actually visiting the website. But even them with their infinite resources, they decided to go in a different direction. Is it because it&amp;rsquo;s a tech company? I feel that some big tech company, they run the way they do, because they are led by technical people, so they can make technical choices instead of business choices sometimes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:46:08]&lt;/strong&gt; React is that, exactly that case. I think I saw the documentary about React, and it&amp;rsquo;s more the idea just spreaded everywhere. I think they have that competing library; I don&amp;rsquo;t know how, I think it&amp;rsquo;s called Jacks or something. I don&amp;rsquo;t the name, but they have a competing library that was written with PHP and XML, and the whole stack on meta back in the days. The idea of React spreads everywhere. The point that you made before of developer experience leads everything in the early days. I think that it just applied exponentially, because at some point they released publicly, everybody hated JSX. Then after one year it was the most famous library used. Then from now on, the monopoly went for, I don&amp;rsquo;t know, six, four years, I don&amp;rsquo;t know. So many years that now everybody has the component model, the hooks, the state. It spread the idea everywhere. It&amp;rsquo;s interesting, but I think it&amp;rsquo;s just like &lt;strong&gt;[unintelligible 01:47:11]&lt;/strong&gt;&amp;nbsp;,&amp;nbsp;so.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:47:13]&lt;/strong&gt; How smart do you need to be to Jordan and be correct about React was the right thing to do, and to do it properly, and then Reason was the right thing to do, and to do it properly?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:47:25]&lt;/strong&gt; How smart need to do. I don&amp;rsquo;t know. Uncountable, I would say. Hard to quantify smartness. It&amp;rsquo;s hard to quantify smartness, but I think it&amp;rsquo;s even harder when you look at what Jordan has been doing. I think Jordan is the kind of person when you speak with him, he talks, or he says things that doesn&amp;rsquo;t make sense at the beginning. It&amp;rsquo;s his way of thinking. He&amp;rsquo;s thinking three, five years ahead, and when he explains the idea to you, you are like, &amp;ldquo;I got the sense that I didn&amp;rsquo;t understand anything.&amp;rdquo; After a few months you start saying, &amp;ldquo;Oh, right, it made sense.&amp;rdquo; I think everybody on the React team only says how brilliant Jordan is. So,&amp;nbsp;yes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:48:18]&lt;/strong&gt; It&amp;rsquo;s interesting that you interviewed Rudi, the author of Dune, and he said that even him, for example, originally when he saw the Reason syntax, he was like, &amp;ldquo;meh,&amp;rdquo; like, &amp;ldquo;What is this thing?&amp;rdquo; Like, &amp;ldquo;Yet again?&amp;rdquo; He say, &amp;ldquo;Yes, at the end it was right to make it more approachable.&amp;rdquo; This was from a user experience perspective. It&amp;rsquo;s a clear&amp;nbsp;benefit.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:48:44]&lt;/strong&gt; Yes. I love that interview, because Rudi said exactly that, like, &amp;ldquo;Oh, at the beginning Reason felt like a toy, but then we were doing tooling for OCaml, and the language and a lot of work on the actual language. Reason was the thing that bring more people on OCaml, than we never, ever did. Even though it&amp;rsquo;s not a competing language, even though the person that created has so much power into the frontend people, even that the number of people that got into OCaml community, it was bigger than any other effort that we made. [laughs] Which for me is super funny at the end of the day, because most of us came from the JavaScript and end up doing OCaml and mixing everything. That was the&amp;nbsp;idea.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:49:40]&lt;/strong&gt; It&amp;rsquo;s funny how you need a little bit of luck for all those things to work. You need, for example, Rudi to decide early on, &amp;ldquo;Okay, I don&amp;rsquo;t really trust this thing, but I still I&amp;rsquo;m a good citizen, so I will add the support inside&amp;nbsp;Dune&amp;rdquo;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:49:56]&lt;/strong&gt; Yes. That&amp;rsquo;s very&amp;nbsp;noble.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:49:58]&lt;/strong&gt; It&amp;rsquo;s like if you don&amp;rsquo;t have those people who are able to compute this is maybe good or maybe bad, and are able to balance their opinion, versus the community thing. They have to do it early enough, at the right time. It&amp;rsquo;s interesting that somehow&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:50:24]&lt;/strong&gt; Of course, not what everything Jordan says is correct, I think in the sense of, of course, he created stuff that was definitely not on shape or not on the area of success of React, of course. I think he created React and then React native. Of course, they both are insanely successful. Reason I would call it successful as well, but actually, push the idea of Esy. Esy is the package manager that is still somehow used, and some people love it. Even myself, I have a lot of respect for Esy, and use it from time to time. That you can consume JavaScript libraries, npm packages as well as OPAM packages.&lt;/p&gt;&lt;p&gt;This project has been suffering for long, that it&amp;rsquo;s definitely not the right solution, or at least, it didn&amp;rsquo;t create these ideas, this sudden idea to the rest of people to continue pushing for&amp;nbsp;it.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:51:27]&lt;/strong&gt; This is one of those tools where I think the technical implementation was good, but the UI was not great. The output is just not nice, for example. You run it, and then it displays&amp;nbsp;some-&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:51:44]&lt;/strong&gt; You mean, the actual UI, the&amp;nbsp;CLI?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:51:46]&lt;/strong&gt; Yes, because opam, which is not the most fancy tool ever, but still when you opam install, it has some colors. It doesn&amp;rsquo;t display one line production. It&amp;rsquo;s some kind of somehow clean output that Esy doesn&amp;rsquo;t have. You had to learn this weird JSON syntax to put your package, and it outputs ugly text after that. The idea was very good, but the UI was not completely working.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:52:24]&lt;/strong&gt; I think Esy has some, people call it state-of-the-art ideas, the end goal of our package manager, what do you want to do, or we want to use. The efforts of maintaining the overrides or being on top of all the libraries or even compiles Esy, there&amp;rsquo;s a lot of maintenance that needs to get done. At some point, we have a team of, I think, six, seven persons working on it, and that experience was very good, but from when Reason got a little bit lost, this team, those people&amp;nbsp;&amp;mdash;&lt;/p&gt;&lt;p&gt;Of course, when the blockchain companies started hiring all of them to work for Web3 and paying them insanely amount of money, then the project got a little bit carried over, got a little bit less maintenance then is likely in a stale mode that you can use, but you could get not as good as&amp;nbsp;opam.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:53:35]&lt;/strong&gt; This exactly why there is no Rust code inside Ahrefs, because all the developers got stolen by the blockchain companies.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:53:45]&lt;/strong&gt; That&amp;rsquo;s fair. That&amp;rsquo;s fair. I think, Louis, we are running out of time. For me is daytime, I can do stuff, but for you is definitely night time. I can work, talk with you for hours and hours, but I think the show is reaching to a point to finish. It was a pleasure to have you, of&amp;nbsp;course.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:54:07]&lt;/strong&gt; It&amp;rsquo;s a pleasure.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:54:09]&lt;/strong&gt; If somebody attends to ICFP, please go to Louis, I think he&amp;rsquo;s the party manager, and as well, a person very interesting to talk to. Please, bother him. I think he&amp;rsquo;ll be in Seattle on September.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:54:26]&lt;/strong&gt; Yes, Seattle, September 4th to 9th, I think, something like that. It will be online too, this year. I think it will be online and for free. All the talks, at least all the ML, or maybe not ML, but the OCaml workshop will be online of free. There is no need to travel all the way to Seattle to see the talks, at least to see the OCaml workshop.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:54:52]&lt;/strong&gt; Makes sense. In this era of internet, I think that makes sense. Cool. Thanks everybody for being here. You&amp;rsquo;re having a little bit late day, but that was perfect. Thanks, Louis, to spend time with&amp;nbsp;us.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Louis: [01:55:07]&lt;/strong&gt; Thank for having me. That was&amp;nbsp;fun.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;David: [01:55:10]&lt;/strong&gt; See you&amp;nbsp;guys.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;[01:55:13] [END OF&amp;nbsp;AUDIO]&lt;/strong&gt;&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=7767afbfbdb9&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/emelletv-talking-with-louis-roche%CC%81-about-ocaml-and-ahrefs-7767afbfbdb9&quot;&gt;EmelleTV: Talking with Louis Roche&amp;#769; about OCaml and Ahrefs&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/emelletv-talking-with-louis-roche%CC%81-about-ocaml-and-ahrefs-7767afbfbdb9?source=rss----303662d88bae--ocaml</id><title type="text">EmelleTV: Talking with Louis Roche about OCaml and Ahrefs</title><updated>2023-06-29T14:32:40-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/ahrefs-is-now-built-with-melange-b14f5ec56df4?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;h3&gt;OCaml, all the way&amp;nbsp;down&lt;/h3&gt;&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/0*cGDQZKJ2bKMARpj9&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/ja/@lg17?utm_source=medium&amp;amp;utm_medium=referral&quot;&gt;Lance Grandahl&lt;/a&gt; on&amp;nbsp;&lt;a href=&quot;https://unsplash.com?utm_source=medium&amp;amp;utm_medium=referral&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;Some history&lt;/h4&gt;&lt;p&gt;In 2021, we decided to evaluate &lt;a href=&quot;https://github.com/melange-re/melange&quot;&gt;Melange&lt;/a&gt; as an alternative to &lt;a href=&quot;http://rescript-lang.org/&quot;&gt;ReScript&lt;/a&gt; for compiling Ahrefs&amp;rsquo; frontend codebase. We wrote about the reasons that led us there, as well as the limitations we encountered at the time, in &lt;a href=&quot;https://tech.ahrefs.com/building-ahrefs-codebase-with-melange-9f881f6d022b&quot;&gt;a previous&amp;nbsp;article&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;After this experiment, discussions continued inside the team. Switching to a different compiler, which was in a very early stage, involved quite some risk. But so did the continued use of ReScript, which seemed to be diverging further and further away from&amp;nbsp;OCaml.&lt;/p&gt;&lt;p&gt;Finally, in September 2022 (during &lt;a href=&quot;https://icfp22.sigplan.org/&quot;&gt;ICFP in Ljubljana&lt;/a&gt;), we decided to bite the bullet and kicked off a project to deepen the integration between &lt;a href=&quot;http://dune.build/&quot;&gt;Dune&lt;/a&gt; (OCaml&amp;rsquo;s most used build system) and Melange. This better integration was the key to solve two of the three limitations we had encountered during our initial exploration of&amp;nbsp;Melange:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Build speed would increase due to less work needed to parse dune files, and more efficient rules planning and execution.&lt;/li&gt;&lt;li&gt;Developer ergonomics would get better, as Melange would become a first-class citizen in Dune, with concepts like Dune &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#library&quot;&gt;libraries&lt;/a&gt; and other stanzas becoming available to Melange&amp;nbsp;users.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ahrefs&amp;rsquo; leadership backed the project and agreed to financially support the development of this tighter integration. With this support, we set about building a team that included Rudi Grinberg, who maintains Dune as part of its development team, and Antonio Monteiro, who created Melange and is also part of the Dune development team.&lt;/p&gt;&lt;h4&gt;Heads down&lt;/h4&gt;&lt;p&gt;During the following months, we focused on two tasks, iterating over multiple cycles where the progress on one task would inform the next steps to take for the&amp;nbsp;other:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Evolve Dune to add stanzas, fields, and documentation to support Melange projects.&lt;/li&gt;&lt;li&gt;Migrate Ahrefs&amp;rsquo; frontend codebase to use the Melange compiler and Dune, adapt third-party libraries and bindings to Melange, and polish the editor integration, build scripts, and other aspects of the development experience.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;We believe that tackling these two tasks in parallel led us to better results, compared to a more waterfall-based approach. As we applied the changes over Ahrefs&amp;rsquo; large-ish frontend codebase&amp;#8202;&amp;mdash;&amp;#8202;it will soon reach 5000 modules&amp;#8202;&amp;mdash;&amp;#8202;we kept finding and fixing bugs, improving the ergonomics of the Dune and Melange integration, and in general making the solution more robust, real-world ready, and developer-friendly.&lt;/p&gt;&lt;p&gt;Another upside of the way the project was implemented is that we developed it initially in stealth mode, keeping it quite private. By working on it within a tight-knit team, before making a public release, we could make progress faster. We believe that this approach saved future Melange users a lot of churn and burn caused by the multiple changes in Dune stanza options, Melange flags, and other configurations we changed along the way, as we learned more about this integration.&lt;/p&gt;&lt;h4&gt;Migration strategies&lt;/h4&gt;&lt;p&gt;Initially, our plan was to progressively migrate Ahrefs&amp;rsquo; code to Melange. As the frontend codebase is divided into different tools, each being self-contained, we thought we could introduce Melange to build one tool, then another tool, gradually migrating them one by&amp;nbsp;one.&lt;/p&gt;&lt;p&gt;However, this approach turned out to be too complex because configuring a development environment that works on both Melange and ReScript is challenging. As developers could be working on multiple tools during the same week, or even within the same day, we realized that it was unfeasible to reconfigure the environment every time a developer switched from a tool built with Melange to a tool built with ReScript.&lt;/p&gt;&lt;p&gt;Therefore, we changed our minds and opted for a one-shot migration. We would ensure that CI, development, and staging environments were working with Melange and Dune. And we would do this on separate branches, while still using ReScript on our main branch CI and development scripts. Once we were confident everything was building and functioning correctly with Melange, we switched all CI and development scripts to use the Melange and Dune commands. We tried to keep the PR that applied this switch as small as possible, with just a few hundreds of lines of changes so that we could switch back to ReScript if needed. In fact, after a first attempt in March, we had to switch back to ReScript due to some issues on the developer experience side, related to build performance and ergonomics, which took a few more weeks to&amp;nbsp;solve.&lt;/p&gt;&lt;p&gt;In terms of package management and third-party Melange dependencies, we followed a more gradual approach. Dune is quite flexible when it comes to &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#vendored-dirs&quot;&gt;vendoring&lt;/a&gt;, so in the initial phase, we downloaded Melange libraries with npm, and had Dune include them in the project as if they were local sources. Now we have started migrating some of these libraries so that we can consume them using opam, the OCaml package manager. This will involve first publishing them in our private opam mirror, but the plan is to have them published in the &lt;a href=&quot;https://ocaml.org/packages&quot;&gt;public opam repository&lt;/a&gt; in the future so that other Melange developers can also use&amp;nbsp;them.&lt;/p&gt;&lt;h4&gt;Timings&lt;/h4&gt;&lt;p&gt;You may be curious about the performance differences between the previous and current approaches. Measuring performance is tricky, but we attempted to measure a few different scenarios with both setups. The results can be seen&amp;nbsp;below.&lt;/p&gt;&lt;p&gt;Keep in mind that Ahrefs frontend setup has specific characteristics, which affect the performance measurements:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Before migration: Dune generated ml files from atd files, then ReScript build tool bsb built all hand-written source files plus the ones generated from atd&amp;nbsp;files.&lt;/li&gt;&lt;li&gt;After migration: everything is built with Dune and&amp;nbsp;Melange.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;All measurements were taken on a node with 2x AMD EPYC 7742 cpu @3.2 GHz (nproc=256), 1TB RAM, Debian 11 x86_64 GNU/Linux. The build target is always the entire Ahrefs frontend codebase.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Cold build:&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Before: real 0m28.232s, user 9m23.883s, sys 13m33.939s&lt;/li&gt;&lt;li&gt;After: real 1m14.208s, user 10m33.708s, sys 5m45.644s&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Warm build&lt;/strong&gt;, noop (no file is&amp;nbsp;built):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Before: real 0m14.687s, user 3m17.058s, sys 3m57.903s&lt;/li&gt;&lt;li&gt;After: real 0m21.895s, user 0m20.528s, sys&amp;nbsp;0m1.372s&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Watch mode, modifying an &amp;ldquo;edge&amp;rdquo; file&lt;/strong&gt; with almost no reverse dependencies:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Before: 1002ms&lt;/li&gt;&lt;li&gt;After: 1576ms&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Watch mode, modifying an &amp;ldquo;inner&amp;rdquo; file&lt;/strong&gt; belonging to a library, with many reverse dependencies:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Before: 7032ms&lt;/li&gt;&lt;li&gt;After: 15394ms&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In general, Melange and Dune are slower than ReScript for cold builds in our setup. However, the differences are smaller for warm builds. For watch mode, the difference gets reduced when modifying edge&amp;nbsp;files.&lt;/p&gt;&lt;p&gt;There is room for improvement in the way the Melange and Dune rules are arranged so that cold builds can get faster. For example, delaying some &lt;a href=&quot;https://github.com/melange-re/melange/issues/464&quot;&gt;optimizations in Melange&lt;/a&gt; might allow to parallelize more&amp;nbsp;work.&lt;/p&gt;&lt;h4&gt;Conclusions&lt;/h4&gt;&lt;p&gt;The results so far are quite encouraging. These are some of the things that are possible thanks to the deeper integration between Dune and Melange, and its application within the Ahrefs codebase:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The same OCaml compiler is used on both frontend and backend codebases.&lt;/li&gt;&lt;li&gt;Access to all the bug fixes, error improvements, and new features that the OCaml compiler team added between versions 4.06 and 4.14 of the compiler.&lt;/li&gt;&lt;li&gt;A shared developer environment across teams, including editor extensions, OCaml LSP server, etc. No more need to maintain a different set of tooling for backend and frontend.&lt;/li&gt;&lt;li&gt;Removal of hand-written CI checks that were ensuring different tools in the frontend codebase would not access components from other tools. This is now solved by Dune libraries, and the OCaml compiler will complain if logical units try to reach outside their&amp;nbsp;bounds.&lt;/li&gt;&lt;li&gt;Frontend and backend shared dependencies, such as &lt;a href=&quot;https://github.com/anuragsoni/routes/&quot;&gt;anuragsoni/routes&lt;/a&gt;, can now be defined in a single place: an opam&amp;nbsp;file.&lt;/li&gt;&lt;li&gt;Faster rebuilds and better watch mode, as Dune now controls all the build artifacts. Previously, Dune and ReScript were sharing responsibilities, which was leading to unnecessary rebuilds of some artifacts. Or alternatively, rebuilds were not starting when required due to the build system not tracking changes in some subsets of the&amp;nbsp;sources.&lt;/li&gt;&lt;li&gt;Easier &lt;a href=&quot;https://ocaml.org/docs/metaprogramming&quot;&gt;PPX&lt;/a&gt; maintenance, as there is no longer a need to publish pre-built versions of these&amp;nbsp;tools.&lt;/li&gt;&lt;li&gt;Melange allows to run all ppxs &lt;a href=&quot;https://github.com/melange-re/melange/pull/171&quot;&gt;from a single executable file&lt;/a&gt;, which has some nice performance benefits.&lt;/li&gt;&lt;li&gt;All the other advantages of using Dune: virtual libraries, watch mode, leverage integrations with tools like&amp;nbsp;odoc&amp;hellip;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;What&amp;rsquo;s next?&lt;/h4&gt;&lt;p&gt;We are excited about this project becoming a reality, and we believe that the deeper integration between OCaml and Melange through Dune, together with Melange&amp;rsquo;s ergonomic integration with the JavaScript ecosystem through its bindings, can enable projects that were previously impossible to imagine. For example, full-stack React by hydrating components that are rendered &lt;a href=&quot;https://github.com/ml-in-barcelona/server-reason-react/&quot;&gt;server-side using native&amp;nbsp;OCaml&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Now, we have to make it easier for other people who are willing to try and use Melange and Dune. So our focus is shifting to documenting how Melange&amp;nbsp;works.&lt;/p&gt;&lt;p&gt;There is a section for Melange in the Dune manual that will be included in the next stable release, and that can be consulted today in the latest branch: &lt;a href=&quot;https://dune.readthedocs.io/en/latest/melange.html&quot;&gt;https://dune.readthedocs.io/en/latest/melange.html&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The next step will be to design and create a site where everyone can read and learn about what is needed to create and maintain a project using Melange and Dune. This site will include a playground, in the spirit of the &lt;a href=&quot;https://reasonml.github.io/en/try&quot;&gt;ReasonML one&lt;/a&gt;, so that we can share snippets, see the resulting JavaScript compilation output, and iterate on ideas together.&lt;/p&gt;&lt;p&gt;Besides the above, we have plenty of other things we will be working on in the next months. We will share more information about the roadmap as soon as Dune 3.8 and its respective Melange version are published in the main public opam repository, which should happen in the next&amp;nbsp;weeks.&lt;/p&gt;&lt;h4&gt;How to contribute?&lt;/h4&gt;&lt;p&gt;If you want to be a part of this, or you want to write or port your libraries to Melange, the best way to do so is by reaching out on the &lt;a href=&quot;https://discord.gg/reasonml&quot;&gt;ReasonML Discord&lt;/a&gt;. There is a #melange dedicated channel where one can get help and advice on how to get&amp;nbsp;started.&lt;/p&gt;&lt;p&gt;Otherwise, if you are missing features, find bugs, or run into confusing errors, please open an issue &lt;a href=&quot;https://github.com/melange-re/melange&quot;&gt;in the Melange public&amp;nbsp;repo&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;We hope you share our excitement about this update. Our journey to integrate our frontend stack more naturally within the incredible language and ecosystem of OCaml will be well-documented. Stay tuned for further updates in the&amp;nbsp;future!&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=b14f5ec56df4&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/ahrefs-is-now-built-with-melange-b14f5ec56df4&quot;&gt;Ahrefs is now built with Melange&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/ahrefs-is-now-built-with-melange-b14f5ec56df4?source=rss----303662d88bae--ocaml</id><title type="text">Ahrefs is now built with Melange</title><updated>2023-05-03T19:06:58-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/how-to-get-started-with-ocaml-in-2022-2f22b578b984?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;h3&gt;Intro&lt;/h3&gt;&lt;p&gt;There has never been a better time to learn OCaml, one of the premier statically-typed functional programming languages used in industry. We at Ahrefs have used it on our backend since the early days of the company, and &lt;a href=&quot;https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b&quot;&gt;since 2018 have even used it extensively for our frontend code&lt;/a&gt;. Today we&amp;rsquo;re very excited to share with you our favorite recommendations for getting started with&amp;nbsp;OCaml!&lt;/p&gt;&lt;h3&gt;Best resources for learning&amp;nbsp;OCaml&lt;/h3&gt;&lt;p&gt;If you have little functional programming experience or are even a beginner to programming, the place to start is &lt;a href=&quot;https://ocaml-book.com/&quot;&gt;OCaml from the Very Beginning&lt;/a&gt;, a book that is now free thanks to generous funding from the &lt;a href=&quot;https://ocaml-sf.org/&quot;&gt;OCaml Software Foundation&lt;/a&gt; (which Ahrefs is a sponsor of). The book can be viewed directly from its website and can also be downloaded as a PDF. While advertised as being approachable even to new programmers, this doesn&amp;rsquo;t quite seem to be true, at least based on feedback we&amp;rsquo;ve received. The text itself introduces concepts in a structured way, but the exercises require a little background in programming to complete. Such background info can be obtained by watching the opening videos in &lt;a href=&quot;https://www.youtube.com/playlist?list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&quot;&gt;this series of lectures&lt;/a&gt; from Cornell&amp;rsquo;s OCaml programming course. Speaking of the Cornell course, their official online textbook &lt;a href=&quot;https://cs3110.github.io/textbook/cover.html&quot;&gt;OCaml Programming: Correct + Efficient + Beautiful&lt;/a&gt; is an excellent resource for learners with some programming experience under their belt (specifically, you should have written some code using a mainstream imperative language like Python or&amp;nbsp;Java).&lt;/p&gt;&lt;h3&gt;How to install&amp;nbsp;OCaml&lt;/h3&gt;&lt;p&gt;The &lt;a href=&quot;https://ocaml.org/docs/up-and-running&quot;&gt;official installation instructions&lt;/a&gt; are entirely adequate. It shows you how to install the compiler and some useful dev tools like dune (build system), utop (interactive read-eval-print loop), and ocaml-lsp-server (useful for editor integration).&lt;/p&gt;&lt;p&gt;Actually, if you are working through &lt;a href=&quot;https://ocaml-book.com/&quot;&gt;OCaml from the Very Beginning&lt;/a&gt;, you do not need to install OCaml during the first several chapters, as you can execute code snippets directly on the &lt;a href=&quot;https://try.ocamlpro.com/&quot;&gt;Try OCaml&lt;/a&gt; page, or create a notebook at &lt;a href=&quot;https://sketch.sh/&quot;&gt;Sketch.sh&lt;/a&gt;, an interactive OCaml notebook site maintained by Ahrefs through our monthly Open Source Friday&amp;nbsp;program.&lt;/p&gt;&lt;h3&gt;Editor support&lt;/h3&gt;&lt;p&gt;For most beginners to the language, we recommend the &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform&quot;&gt;official OCaml Platform Visual Studio Code extension&lt;/a&gt;. The official OCaml installation guide has a &lt;a href=&quot;https://ocaml.org/docs/up-and-running#editor-support-for-ocaml&quot;&gt;good section on setting it up&lt;/a&gt;. There is also great support for users of &lt;a href=&quot;https://github.com/ocaml/tuareg&quot;&gt;emacs&lt;/a&gt; and&amp;nbsp;&lt;a href=&quot;https://github.com/ocaml/vim-ocaml&quot;&gt;vim&lt;/a&gt;.&lt;/p&gt;&lt;h3&gt;Tips&lt;/h3&gt;&lt;p&gt;Even early on, it&amp;rsquo;s a good idea to start saving your code into&amp;nbsp;.ml files and learning how to run it. The easiest way to run a simple program is to start up utop and inside of it run #use &amp;quot;name_of_your_program.ml&amp;quot; as &lt;a href=&quot;https://ocaml.org/docs/first-hour#running-ocaml-programs&quot;&gt;described here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;When creating a new notebook in &lt;a href=&quot;https://sketch.sh/&quot;&gt;Sketch.sh&lt;/a&gt;, the default syntax is ReasonML (it&amp;rsquo;s not a different language, just &lt;a href=&quot;https://en.wikipedia.org/wiki/Reason_(programming_language)&quot;&gt;an alternate syntax that more resembles JavaScript&lt;/a&gt;). Click on ML in the top left corner to switch to the original OCaml&amp;nbsp;syntax.&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/0*EgPCQlLR4C54N3Ge&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;Conclusion&lt;/h3&gt;&lt;p&gt;OCaml originated from French academia more than 25 years ago, and from there spread to elite universities and forward-thinking companies around the world. Now the OCaml community has produced high quality learning material that is both free and easy to access. So take the initiative and learn you some&amp;nbsp;OCaml!&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=2f22b578b984&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/how-to-get-started-with-ocaml-in-2022-2f22b578b984&quot;&gt;How to get started with OCaml in 2022&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/how-to-get-started-with-ocaml-in-2022-2f22b578b984?source=rss----303662d88bae--ocaml</id><title type="text">How to get started with OCaml in 2022</title><updated>2022-10-31T16:13:10-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/monorobot-a-slack-bot-for-monorepos-374260e2ca43?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;h3&gt;Monorobot: a notification bot for monorepos&lt;/h3&gt;&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/1*BQNCNLNPxGV3eXajYe6y2g.png&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;Monorobot enables configurable directory tree notifications for your monorepo.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;A few years ago, we decided to move most of our code into a monorepo. Many &lt;a href=&quot;https://danluu.com/monorepo/&quot;&gt;advocates&lt;/a&gt; have highlighted its upsides, which include better cross-project coordination and simpler dependency management.&lt;/p&gt;&lt;p&gt;But one problem remained: &lt;strong&gt;none of the available GitHub integrations for Slack work nicely with monorepos&lt;/strong&gt;. Slack is vital for day to day communication among Ahrefs&amp;rsquo; globally distributed team, so a Slack integration was a must-have feature. We needed a service that could map activity from our various subprojects to their corresponding Slack channels&amp;#8202;&amp;mdash;&amp;#8202;something existing solutions didn&amp;rsquo;t&amp;nbsp;offer.&lt;/p&gt;&lt;p&gt;That&amp;rsquo;s why we built our own integration: &lt;strong&gt;Monorobot&lt;/strong&gt;, a notification bot for monorepos. We&amp;rsquo;ve improved it iteratively since the monorepo transition, incorporating real time feedback from our engineers over time. Today, Monorobot is an active member of Ahrefs&amp;rsquo; Slack workspace, dutifully routing GitHub activity notifications to different channels based on the relevance of each activity.&lt;/p&gt;&lt;p&gt;And now we&amp;rsquo;re &lt;a href=&quot;https://github.com/ahrefs/monorobot&quot;&gt;open-sourcing Monorobot&lt;/a&gt;, for anybody to use in their monorepo setup! The package is available via&amp;nbsp;&lt;a href=&quot;https://opam.ocaml.org/packages/monorobot/&quot;&gt;OPAM&lt;/a&gt;:&lt;/p&gt;&lt;pre&gt;opam install monorobot&lt;/pre&gt;&lt;p&gt;Read on for more details about the motivation, an overview of the main features, and what&amp;rsquo;s in the pipeline.&lt;/p&gt;&lt;h3&gt;Existing Slack integrations lack monorepo&amp;nbsp;support&lt;/h3&gt;&lt;p&gt;Within a monorepo, multiple projects have their code located in separate, nested directories. Correspondingly, each project&amp;rsquo;s Slack channel is only interested in activity from that part of the overall repository. The issue with most GitHub-to-Slack integrations is that once you subscribe a Slack channel to a GitHub repository, the channel receives &lt;em&gt;all&lt;/em&gt; activity from that repository.&lt;/p&gt;&lt;p&gt;Suppose we operate various camel-related services, and we&amp;rsquo;re planning to launch a new camel ride-sharing app called Camel Ride. The directory structure could look like&amp;nbsp;this:&lt;/p&gt;&lt;pre&gt;monorepo/&lt;br/&gt;| frontend/&lt;br/&gt;| | camelride_ui/&lt;br/&gt;| | | mobile/&lt;br/&gt;| | | web/&lt;br/&gt;| | cameldance/&lt;br/&gt;| backend/&lt;br/&gt;| | camelride/&lt;br/&gt;| | | routing/&lt;br/&gt;| | | pricing/&lt;br/&gt;| | camelfood/&lt;/pre&gt;&lt;p&gt;As you can see, both the frontend/ and backend/ directories contain code for our fictitious ride-sharing service, along with code from other projects.&lt;/p&gt;&lt;p&gt;If we were to connect the &lt;a href=&quot;https://slack.com/help/articles/232289568-GitHub-for-Slack&quot;&gt;GitHub for Slack&lt;/a&gt; integration to this repository, notifications for activity from all projects would be sent to the same channel. Even if I were only interested in activity from the Camel Ride project, I&amp;rsquo;d need to sift through notifications from the other, unrelated projects. Imagine the volume of notifications this would create for a larger monorepo with dozens of projects. What a&amp;nbsp;mess!&lt;/p&gt;&lt;h3&gt;Enter Monorobot&lt;/h3&gt;&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/1*ZHkBDdpNcMMw29BmHirM_A.png&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;Monorobot, hard at&amp;nbsp;work.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Monorobot enables more granular control over where notifications from the same repository get routed, depending on the type of activity. This routing behavior can be defined in a configuration file named&amp;nbsp;.monorobot.json, which should be committed to the root of the monorepo. Once you create a &lt;a href=&quot;https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks&quot;&gt;GitHub webhook&lt;/a&gt; from the repository to a running instance of Monorobot, it will use the configuration file to route notifications to relevant channels based on the webhook event&amp;nbsp;payload:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;For pushed commits, it checks the path prefixes of the files modified in the&amp;nbsp;commits.&lt;/li&gt;&lt;li&gt;For activity related to PRs and issues, it checks their&amp;nbsp;labels.&lt;/li&gt;&lt;li&gt;For status updates on pushed commits (e.g., CI builds), it uses the same path prefix logic as pushed&amp;nbsp;commits.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Additionally, Monorobot supports unfurling GitHub links shared in&amp;nbsp;Slack.&lt;/p&gt;&lt;h4&gt;Path prefix routing for commit push notifications&lt;/h4&gt;&lt;p&gt;Continuing with our example, suppose we want to route all commit activity related to the Camel Ride project to a Slack channel called &lt;em&gt;#camelride&lt;/em&gt;. Our configuration file might look like&amp;nbsp;this:&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  ...,&lt;br/&gt;  &amp;quot;prefix_rules&amp;quot;: {&lt;br/&gt;    &amp;quot;rules&amp;quot;: [&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;match&amp;quot;: [&lt;br/&gt;          &amp;quot;frontend/camelride_ui/&amp;quot;,&lt;br/&gt;          &amp;quot;backend/camelride/&amp;quot;&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;ignore&amp;quot;: [&lt;br/&gt;          &amp;quot;frontend/camelride_ui/images&amp;quot;,&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;channel&amp;quot;: &amp;quot;camelride&amp;quot;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  }&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;Each rule &amp;ldquo;matches&amp;rdquo; a file path to a channel. Whenever someone pushes a commit touching files with either of these prefixes, the &lt;em&gt;#camelride&lt;/em&gt; channel will be notified. All other commits will be&amp;nbsp;ignored.&lt;/p&gt;&lt;p&gt;If a file prefix appears in a rule&amp;rsquo;s optional ignore field, the rule won't be matched even if the prefix is is also in the match field. In the above snippet, the Camel Ride frontend team has decided to silence notifications for activity in the images/ subdirectory.&lt;/p&gt;&lt;p&gt;Now, let&amp;rsquo;s say the project&amp;rsquo;s price optimization team is growing, and they&amp;rsquo;ve decided to create their own separate Slack channel called &lt;em&gt;#camelride-pricing&lt;/em&gt;. We can simply commit an update to the&amp;nbsp;.monorobot.json file, and Monorobot will detect the configuration change:&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  ...,&lt;br/&gt;  &amp;quot;prefix_rules&amp;quot;: {&lt;br/&gt;    &amp;quot;rules&amp;quot;: [&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;match&amp;quot;: [&lt;br/&gt;          &amp;quot;frontend/camelride_ui/&amp;quot;,&lt;br/&gt;          &amp;quot;backend/camelride/&amp;quot;&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;ignore&amp;quot;: [&lt;br/&gt;          &amp;quot;frontend/camelride_ui/images&amp;quot;,&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;channel&amp;quot;: &amp;quot;camelride&amp;quot;&lt;br/&gt;      },&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;match&amp;quot;: [&lt;br/&gt;          &amp;quot;backend/camelride/pricing/&amp;quot;&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;channel&amp;quot;: &amp;quot;camelride-pricing&amp;quot;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  }&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;Since Monorobot will match the rule with the longest matched prefix, only commits related to the price optimization aspect of Camel Ride will notify &lt;em&gt;#camelride-pricing&lt;/em&gt;, and all other general Camel Ride commits will notify &lt;em&gt;#camelride&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;There are additional configuration options for prefix rules (and for label rules discussed in the next section) that aren&amp;rsquo;t mentioned here. Visit the &lt;a href=&quot;https://github.com/ahrefs/monorobot&quot;&gt;repository&lt;/a&gt; for the full&amp;nbsp;details.&lt;/p&gt;&lt;h4&gt;Label-based routing for PRs and issue notifications&lt;/h4&gt;&lt;p&gt;For activity related to pull requests and issues (opening, closing, merging, commenting, and reviewing), Monorobot uses labels to determine routing. The format is largely the same as for path prefix&amp;nbsp;routing:&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  ...,&lt;br/&gt;  &amp;quot;label_rules&amp;quot;: {&lt;br/&gt;    &amp;quot;default_channel&amp;quot;: &amp;quot;notifications&amp;quot;,&lt;br/&gt;    &amp;quot;rules&amp;quot;: [&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;match&amp;quot;: [&lt;br/&gt;          &amp;quot;Camel Ride&amp;quot;&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;channel&amp;quot;: &amp;quot;camelride&amp;quot;&lt;br/&gt;      },&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;match&amp;quot;: [&lt;br/&gt;          &amp;quot;Price Optimization&amp;quot;&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;channel&amp;quot;: &amp;quot;camelride-pricing&amp;quot;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  }&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;Here, all PRs and issues with the &amp;ldquo;Camel Ride&amp;rdquo; label will have activity sent to &lt;em&gt;#camelride&lt;/em&gt;; those with the &amp;ldquo;Price Optimization&amp;rdquo; label to &lt;em&gt;#camelride-pricing&lt;/em&gt;; and those with both labels to both channels.&lt;/p&gt;&lt;p&gt;The default_channel field provides an option to fall back on a channel if no rule is matched; this option is available for prefix rules as&amp;nbsp;well.&lt;/p&gt;&lt;h4&gt;Status notifications&lt;/h4&gt;&lt;p&gt;Monorobot also supports build status notifications for CI pipelines. When it receives a status update for a pushed commit, it routes it to the relevant channel(s) by applying the prefix rules to the commit associated with the build. Further filtering based on status (e.g., ignoring canceled builds, and only notifying for a successful build when preceded by a failed one) is also possible.&lt;/p&gt;&lt;h4&gt;Link unfurling&lt;/h4&gt;&lt;p&gt;Finally, Monorobot can unfurl links to GitHub repositories shared on Slack (including private ones, if a personal access token is provided). This applies to commit, issue, and pull request&amp;nbsp;URLs.&lt;/p&gt;&lt;h3&gt;What&amp;rsquo;s next&lt;/h3&gt;&lt;p&gt;Monorobot is actively used at Ahrefs today, but there are lots of promising future directions it could take. Here, we list a&amp;nbsp;few.&lt;/p&gt;&lt;h4&gt;Unifying GitHub and Slack identities&lt;/h4&gt;&lt;p&gt;It would be useful to allow GitHub user IDs to be mapped to Slack ones. This would enable more personalized features for Monorobot, such as direct messaging a user when their review is requested or when a CI build fails on a feature branch they authored.&lt;/p&gt;&lt;h4&gt;Consolidating notifications&lt;/h4&gt;&lt;p&gt;Sometimes, a collection of multiple GitHub webhook events makes sense to be grouped and delivered as a single Slack notification. For example, pull request reviews generate discrete webhook events for each review comment, but it would make more sense to pool them together, so as not to spam a channel with many notifications.&lt;/p&gt;&lt;h4&gt;Better status notifications&lt;/h4&gt;&lt;p&gt;A CI build failure can have multiple potential causes:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;A bad&amp;nbsp;commit&lt;/li&gt;&lt;li&gt;A previous bad commit that has yet to be&amp;nbsp;fixed&lt;/li&gt;&lt;li&gt;An issue with the pipeline itself (this is out of scope for Monorobot)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;It can be quite tricky to discern between the first two causes from the GitHub webhook event alone. Cause 1 is handled well by our current approach of using path prefix routing on the commit associated with the build. But with cause 2, that same approach doesn&amp;rsquo;t always send the build failure notification to the channel where it is actually relevant. In that case, the originator of the initial bad commit won&amp;rsquo;t be nagged about all subsequent failures, and Slack channels with no relevance to the cause of failure will get polluted with unnecessary notifications.&lt;/p&gt;&lt;p&gt;How can we best determine whether a status notification is &amp;ldquo;relevant&amp;rdquo; to a Slack channel? This is still an open question, but one possible direction is to track build state per &lt;em&gt;build step&lt;/em&gt; rather than per &lt;em&gt;status&lt;/em&gt;, and route notifications based on that. For example, if an overall build fails due to a backend build step failure, then it could be sent to a channel where the frontend team won&amp;rsquo;t be notified.&lt;/p&gt;&lt;h3&gt;Wrapping up&lt;/h3&gt;&lt;p&gt;The overall goal of Monorobot is to make Slack notifications more &lt;em&gt;relevant&lt;/em&gt; for all teams in a large &lt;em&gt;monorepo environment&lt;/em&gt;, using the information available from GitHub webhook events. We&amp;rsquo;ve had fairly positive results with our own internal usage, and now we hope others find it useful as&amp;nbsp;well.&lt;/p&gt;&lt;p&gt;Monorobot is written in OCaml. &lt;a href=&quot;https://github.com/ahrefs/monorobot&quot;&gt;We welcome your feedback and contributions on&amp;nbsp;GitHub!&lt;/a&gt;&lt;/p&gt;&lt;p&gt;P.S. If anyone does make an actual ride sharing service for camels, do let us&amp;nbsp;know&amp;hellip;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thanks to Feihong, Igor, and Louis for feedback on this&amp;nbsp;post.&lt;/em&gt;&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=374260e2ca43&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/monorobot-a-slack-bot-for-monorepos-374260e2ca43&quot;&gt;Monorobot: a Slack bot for monorepos&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/monorobot-a-slack-bot-for-monorepos-374260e2ca43?source=rss----303662d88bae--ocaml</id><title type="text">Monorobot: a Slack bot for monorepos</title><updated>2021-12-09T15:19:04-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/building-ahrefs-codebase-with-melange-9f881f6d022b?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/1*tYLUO4FDmJ6bzlsPp14LdQ.jpeg&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@madebyjens?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Jens Lelie&lt;/a&gt; on&amp;nbsp;&lt;a href=&quot;https://unsplash.com/s/photos/fork-road?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;At Ahrefs, we have been using BuckleScript and ReasonML in production &lt;a href=&quot;https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b&quot;&gt;for more than two years&lt;/a&gt;. We already have a codebase of tens of thousands of lines of code, with several web applications that are data intensive and communicate with backend services written in &lt;a href=&quot;http://ocaml.org/&quot;&gt;OCaml&lt;/a&gt;, using tools like&amp;nbsp;&lt;a href=&quot;https://github.com/ahrefs/atd&quot;&gt;atd&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Given our investment in these technologies, we have been following closely the recent changes in &lt;a href=&quot;https://rescript-lang.org/&quot;&gt;ReScript&lt;/a&gt;, with its rebrand and renaming, and the split with the ReasonML project, explained in the project &lt;a href=&quot;https://rescript-lang.org/blog/bucklescript-is-rebranding&quot;&gt;blog&amp;nbsp;post&lt;/a&gt;.&lt;/p&gt;&lt;h3&gt;ReScript: becoming its own&amp;nbsp;language&lt;/h3&gt;&lt;p&gt;We are excited about the way ReScript is unifying the experience and making it easier for developers who are getting started to find documentation in a single place, as well as continuing its strong focus on performance and readable JavaScript output.&lt;/p&gt;&lt;p&gt;On the other hand, we are trying to figure out the implications of this change in the mid- and long-term, especially regarding the integration with the OCaml ecosystem. And more importantly, what this evolution will mean for production users like us who rely on this integration.&lt;/p&gt;&lt;p&gt;ReScript integration with OCaml has historically been seamless, as BuckleScript started originally as a &lt;a href=&quot;https://www.reddit.com/r/ocaml/comments/4enok3/bloombergbucklescript_a_back_end_for_the_ocaml/&quot;&gt;new backend for the OCaml compiler&lt;/a&gt;. However, in recent months, there have been several hints that ReScript wants to evolve towards becoming its own language:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;It has now &lt;a href=&quot;https://github.com/rescript-lang/syntax&quot;&gt;its own parser&lt;/a&gt;, incompatible with OCaml native applications&lt;/li&gt;&lt;li&gt;Official repository guidelines for technical writing mentions explicitly that &lt;a href=&quot;https://github.com/rescript-association/rescript-lang.org/blob/master/CONTRIBUTING.md#technical-writing-documentation&quot;&gt;no reference to OCaml&lt;/a&gt; should appear in&amp;nbsp;docs&lt;/li&gt;&lt;li&gt;Upgrades to the latest version of OCaml compiler, which &lt;a href=&quot;https://web.archive.org/web/20210208054855if_/https://github.com/rescript-lang/rescript-compiler/wiki&quot;&gt;used to be part of the roadmap&lt;/a&gt;, have been &lt;a href=&quot;https://forum.rescript-lang.org/t/some-thoughts-on-community-building/1474&quot;&gt;deprioritized&lt;/a&gt; recently.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;So, even if officially ReScript has not announced that they will break backwards compatibility with OCaml, just the fact that it is sticking with an old version of the OCaml compiler poses some challenges for us in terms of tooling. The uncertainty about the future and the pace of changes add some risk to the high-level goals we have for our teams and codebase: we would like to share &lt;em&gt;more&lt;/em&gt; code between frontend and backend, not&amp;nbsp;less.&lt;/p&gt;&lt;h3&gt;Melange: a fork of ReScript, focused on OCaml compatibility&lt;/h3&gt;&lt;p&gt;When Ant&amp;oacute;nio Monteiro &lt;a href=&quot;https://anmonteiro.com/2021/03/on-ocaml-and-the-js-platform/&quot;&gt;announced Melange&lt;/a&gt;, a fork of ReScript but with a strong focus on keeping compatibility with OCaml, we decided to try it out and see how it could work for&amp;nbsp;us.&lt;/p&gt;&lt;p&gt;Ultimately, the experiment was successful. We managed to build all our frontend applications with Melange, while keeping the existing bundling setup, which currently uses&amp;nbsp;Webpack.&lt;/p&gt;&lt;p&gt;Throughout this process, we had to modify some parts of the code. We will now go through the most relevant parts of the&amp;nbsp;process:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Upgrade to OCaml 4.12: the most relevant part was the deprecation of Pervasives module to use&amp;nbsp;Stdlib.&lt;/li&gt;&lt;li&gt;Use ppxlib in our ppxs: we had to upgrade the two ppxs that we use in the frontend codebase to the latest compiler version, &lt;a href=&quot;https://github.com/ahrefs/bs-emotion/compare/master...jchavarri:ocaml4.12-ppxlib&quot;&gt;bs-emotion-ppx&lt;/a&gt; and an in-house &lt;a href=&quot;https://github.com/ahrefs/bs-react-intl-ppx&quot;&gt;ppx for internationalization&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Configure esy: we were already using esy to bring the editor tooling into scope of the developer environment, so we just had to make sure melange would also be included in the json configuration.&lt;/li&gt;&lt;li&gt;Upgrade to Reason 3.7.0: a quite simple change too, as the whole process is automated by using refmt. As a side note, we ran into &lt;a href=&quot;https://github.com/reasonml/reason/issues/2636&quot;&gt;a small bug&lt;/a&gt; with some type annotations, that we were able to work&amp;nbsp;around.&lt;/li&gt;&lt;li&gt;&amp;ldquo;Lift&amp;rdquo; dune workspace to the root of our monorepo: this is probably the most intrusive change. Because we have shared code between backend and frontend, and Dune needs to have access to all sources under its workspace, we had to &amp;ldquo;lift&amp;rdquo; the Dune workspace from the backend directory to the root of monorepo.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;The good&lt;/h3&gt;&lt;p&gt;This experiment allowed us to experience what a project like Melange could offer for our use case. Here are some of the things we might be able to leverage in a codebase built with&amp;nbsp;Melange:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Recent version of the OCaml compiler: at some point, we could pin compiler version between backend and frontend teams, making upgrades more straightforward as they would happen atomically.&lt;/li&gt;&lt;li&gt;Shared editor tooling: the official OCaml &lt;a href=&quot;https://github.com/ocamllabs/vscode-ocaml-platform&quot;&gt;vscode extension&lt;/a&gt; works great with Melange, as well as any other OCaml editor integration. Having backend and frontend teams use similar editor setup removes a lot of maintenance work for&amp;nbsp;us.&lt;/li&gt;&lt;li&gt;Consuming ppxs from source: Melange allows to consume ppxs from source, which also removes issues with pre-compiled ppxs (like this issue with the recent &lt;a href=&quot;https://github.com/ahrefs/bs-emotion/issues/53&quot;&gt;M1&amp;nbsp;Macs&lt;/a&gt;).&lt;/li&gt;&lt;li&gt;Melange allows to run all ppxs &lt;a href=&quot;https://github.com/melange-re/melange/pull/171&quot;&gt;from a single executable file&lt;/a&gt;, which has some nice performance benefits.&lt;/li&gt;&lt;li&gt;Use Dune for atd files generators: ReScript &amp;ldquo;generators&amp;rdquo; are unfortunately &lt;a href=&quot;https://web.archive.org/web/20200710044513if_/https://reasonml.org/docs/reason-compiler/latest/build-advanced&quot;&gt;not documented anymore&lt;/a&gt;, but we use them extensively for atd file generation. Being able to share Dune rules in backend and frontend would make our build setup&amp;nbsp;easier.&lt;/li&gt;&lt;li&gt;Access to OCaml documentation tooling: Melange allows to leverage existing tooling for generating documentation, like&amp;nbsp;&lt;a href=&quot;https://github.com/ocaml/odoc/&quot;&gt;odoc&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Async syntax: the latest Reason version &lt;a href=&quot;https://github.com/reasonml/reason/pull/2487&quot;&gt;supports &amp;ldquo;let op&amp;rdquo; syntax&lt;/a&gt;, which is handy for client-side code.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;The bad&lt;/h3&gt;&lt;p&gt;While there are many things that are exciting about Melange, there are some other parts that can be improved.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Build performance: We already knew that performance would be far worse than ReScript, as Melange uses Dune in a way that it was not designed for. In our tests, builds with Melange are roughly 1 order of magnitude slower than ReScript&amp;nbsp;ones.&lt;/li&gt;&lt;li&gt;First-class Dune support: if there was a deeper integration between Dune and Melange, we could explore features like shared libraries or shared rules between backend and frontend. As of today, Dune has no knowledge about Melange environment, so it can perform basic rules execution, but there is no access to high level stanzas like library in&amp;nbsp;Melange.&lt;/li&gt;&lt;li&gt;Two-headed goal: finally, we see a more strategic risk in Melange proposition. Right now it has two goals: keep compatibility with both ReScript and OCaml. But we don&amp;rsquo;t know how long these goals will be feasible. If at some point ReScript decides to move away from the OCaml compiler fully, then Melange users would not be able to consume any updates to the ReScript ecosystem anymore.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Alright, but are you migrating to Melange or ReScript?&lt;/h3&gt;&lt;p&gt;With all the information available, the answer is: we don&amp;rsquo;t know yet. &amp;#128516; We want to keep exploring all the available options and have as much information as possible before committing further. So for now, we are upgrading the codebase to recent versions of ReScript, but we are holding up on features that only work one way. For example, we have not migrated our codebase to the ReScript syntax yet, as &lt;a href=&quot;https://github.com/rescript-lang/syntax/issues/405&quot;&gt;there is no way to translate back to Reason&amp;nbsp;syntax&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;In the meantime, we will keep exploring how far the limitations of Melange can be mitigated. To be continued! &amp;#128640;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thanks to Igor and Feihong for reviewing and improving earlier versions of this&amp;nbsp;post.&lt;/em&gt;&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=9f881f6d022b&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/building-ahrefs-codebase-with-melange-9f881f6d022b&quot;&gt;Building Ahrefs codebase with Melange&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/building-ahrefs-codebase-with-melange-9f881f6d022b?source=rss----303662d88bae--ocaml</id><title type="text">Building Ahrefs codebase with Melange</title><updated>2021-05-18T15:24:20-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/1*Nl5vYk_k-mC4j32XEjryHQ.jpeg&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@willianjusten&quot;&gt;https://unsplash.com/@willianjusten&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;The first &lt;a href=&quot;https://reasonml.org/&quot;&gt;Reason&lt;/a&gt; application at &lt;a href=&quot;https://ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; went online on January 31, 2019. Since then, many more applications have been either rewritten in Reason, are being slowly migrated from React to ReasonReact, or are conceived from the start as Reason projects. It is safe to say that the bet placed on Reason paid off big time. We will never go back to doing pure JavaScript again, with the possible exception of simple backend&amp;nbsp;scripts.&lt;/p&gt;&lt;p&gt;In the past few years, it&amp;rsquo;s come to light that there are a number of other &lt;a href=&quot;https://www.messenger.com/&quot;&gt;large&lt;/a&gt; &lt;a href=&quot;https://www.onegraph.com/&quot;&gt;Reason&lt;/a&gt;/&lt;a href=&quot;https://darklang.com/&quot;&gt;BuckleScript&lt;/a&gt; &lt;a href=&quot;https://onivim.io/&quot;&gt;codebases&lt;/a&gt; in the wild, but there still isn&amp;rsquo;t a ton of information out there about what it&amp;rsquo;s really like to work with Reason in production. To help remedy that, we thought it would be instructive to ask each of our frontend team members what their Reason journey has been like so&amp;nbsp;far.&lt;/p&gt;&lt;p&gt;We gave them the following questions as starting points (but they were free to talk about anything they&amp;nbsp;wanted):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;How does Reason compare to other languages you&amp;rsquo;ve used in the&amp;nbsp;past?&lt;/li&gt;&lt;li&gt;What&amp;rsquo;s your favorite thing about&amp;nbsp;Reason?&lt;/li&gt;&lt;li&gt;What&amp;rsquo;s your least favorite thing about&amp;nbsp;Reason?&lt;/li&gt;&lt;li&gt;How does ReasonReact compare to other frameworks you&amp;rsquo;ve&amp;nbsp;used?&lt;/li&gt;&lt;li&gt;Was it easy to pick up Reason? Why or why&amp;nbsp;not?&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Javi&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;How does Reason compare to other languages you&amp;rsquo;ve used in the&amp;nbsp;past?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In the past I worked with languages like Java, C, or less known like Pascal or Prolog. But the languages I&amp;rsquo;ve spent more time with are Objective-C and JavaScript. The main difference between all those languages and Reason is the exhaustiveness that you get from OCaml type checker. This is maybe awkward, but it feels like you stop coding alone and suddenly you have a sidekick always sitting next to you, that is helping you notice the things you forgot about, or found new code that is not consistent with code you or someone else wrote&amp;nbsp;before.&lt;/p&gt;&lt;p&gt;In a world that is moving towards remote work, where many of us spend hours every day coding physically far from our colleagues, it makes the experience much more delightful. Plus, it allows for teams working on different time zones to keep a healthier work-life balance, because there is less need to have synchronous communication than with more dynamic languages, as more assumptions and design decisions are &amp;ldquo;embedded&amp;rdquo; into the&amp;nbsp;code.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;What&amp;rsquo;s your favorite thing about&amp;nbsp;Reason?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Can I pick two things? It&amp;rsquo;s hard to choose only&amp;nbsp;one.&lt;/p&gt;&lt;p&gt;The first one is the exhaustiveness and quality of the type checker, as mentioned above. Sometimes it takes a bit longer to build a feature than what it would in other languages, until the types are figured out. But this is largely compensated by the confidence one has when shipping code to production, or diving into large refactors.&lt;/p&gt;&lt;p&gt;The second one is the speed of the BuckleScript build system, which is built on top of &lt;a href=&quot;https://ninja-build.org/&quot;&gt;ninja&lt;/a&gt;. I had never worked with such fast build system. As an example, we have recently started to use remote machines to develop at Ahrefs. In one of these machines that has 72 cores, BuckleScript takes roughly 3 seconds to clean build &lt;em&gt;all&lt;/em&gt; our Reason code: application, libs, decoders&amp;hellip; everything. Many tens of thousand lines of code! We thought there were something wrong, but we realized the compiler is just So Blazing&amp;nbsp;Fast&amp;trade;&amp;#65039;.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;What&amp;rsquo;s your least favorite thing about&amp;nbsp;Reason?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I guess we&amp;rsquo;re going through a necessary stage until things stabilize in the future, but there is a lot of fragmentation at the moment between &amp;ldquo;Reason native&amp;rdquo;, which tries to stay closer to OCaml, and &amp;ldquo;Reason web&amp;rdquo;, which has a goal to become friendlier for JavaScript developers.&lt;/p&gt;&lt;p&gt;I am excited to see what &lt;a href=&quot;https://reasonml.org/blog/bucklescript-8-1-new-syntax&quot;&gt;BuckleScript new syntax&lt;/a&gt; will lead to, but I would also love to see a &amp;ldquo;universal&amp;rdquo; solution that works for the main use cases out of the box, becoming sort of Rails for Ocaml or Reason. &lt;a href=&quot;https://github.com/oxidizing/sihl/&quot;&gt;sihl&lt;/a&gt; is a project that seems to go in that direction and looks very promising.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;How does ReasonReact compare to other frameworks you&amp;rsquo;ve&amp;nbsp;used?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I consider ReasonReact mostly like React + types on top, because the bindings layer is very thin. The thing that I like most about React is that it follows the Unix philosophy: it does one thing and it does it really well. Maybe we have forgotten already today, but having to maintain and mutate UI based on data updates was one of the main sources of bugs in the past. The other nice thing is that there is so much good content about it: blog posts, documentation, etc.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Was it easy to pick up Reason? Why or why&amp;nbsp;not?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;It took some time, as with any other language. We have things like syntax or semantics much more ingrained into our brains than we think, so there is always some &amp;ldquo;rewiring&amp;rdquo; time that is needed to learn a new language, even if Reason makes an effort to stay close to JavaScript syntax. The most challenging part was probably the bindings one, because coming from JavaScript, there are no previous knowledge that one can use as foundation to build upon, it&amp;rsquo;s all &amp;ldquo;new knowledge&amp;rdquo;. glennsl &lt;a href=&quot;https://github.com/glennsl/bucklescript-ffi-cheatsheet&quot;&gt;BuckleScript ffi cheatsheet&lt;/a&gt; was a huge help for&amp;nbsp;me.&lt;/p&gt;&lt;h4&gt;Ze&lt;/h4&gt;&lt;p&gt;I really like working with Reason, and have wanted to do so for a while. I was quite happy to see that working with it matched my expectations.&lt;/p&gt;&lt;p&gt;You get so much support from the type system, and still have a lot of flexibility to represent your domain model. Coming from other languages or paradigms, you don&amp;rsquo;t feel limited at all in what you can&amp;nbsp;achieve.&lt;/p&gt;&lt;p&gt;The language has such a strong type system that you feel much more comfortable with your&amp;nbsp;coding.&lt;/p&gt;&lt;p&gt;The OCaml type system is there to make sure you code with assurance. This is especially true when refactoring code. You can be sure that everything will work fine after it compiles. If it compiles, it works&amp;nbsp;:)&lt;/p&gt;&lt;p&gt;It&amp;rsquo;s also very helpful when working on a monorepo. You don&amp;rsquo;t have to keep reading the source code of everything you use to make sure you don&amp;rsquo;t have types mistakes. Changes in code in one lib reflect immediately in all the others. This makes the feedback loop much shorter and&amp;nbsp;safer.&lt;/p&gt;&lt;p&gt;The editors integrations with the type system are quite good and help a lot to write code better and&amp;nbsp;faster.&lt;/p&gt;&lt;p&gt;Also, compilation times are super&amp;nbsp;fast.&lt;/p&gt;&lt;p&gt;Last, but not least, ReasonReact is, for me, the hidden gem of ReasonML. The newcomers that have some difficulty with the language should start with it. IMHO, ReasonReact is simpler and has a better developer experience than React itself. It should be the gateway drug frontend developers need to get started with Reason/OCaml &amp;#128516;&lt;/p&gt;&lt;h4&gt;Liubomyr&lt;/h4&gt;&lt;p&gt;To me, all those language features boil down to one essential thing, and it&amp;rsquo;s the easiness of refactoring. New business requirements popups all the time, and often your initial code assumptions are no longer correct. It was such a pain to modify code in a large JS codebase, as you never know how many things you potentially break in the process. With Reason, it has never been easier. If you need to change your data shape or some component API, you just do it, and from there, the compiler will guide you through all the places you broke, and help to fix&amp;nbsp;those.&lt;/p&gt;&lt;p&gt;Coming from the JS world, it feels like the initial development is slower, because of the learning curve, missing bindings, less StackOverflow answers, but in the end, you are getting a stable software which is way easier to maintain and add features&amp;nbsp;to.&lt;/p&gt;&lt;h4&gt;Egor&lt;/h4&gt;&lt;p&gt;I switched to Reason when I joined Ahrefs team about a year ago, before that I worked mostly with Ruby language.&lt;/p&gt;&lt;p&gt;The first thing that impressed me in ReasonML was code refactoring. Refactoring in language with a strong type system, like ReasonML and OCaml, is much easier than what I am used to. If your program compiles after your refactoring&amp;#8202;&amp;mdash;&amp;#8202;most likely you did everything right, if it doesn&amp;rsquo;t compile&amp;#8202;&amp;mdash;&amp;#8202;you can immediately see what you forgot to change. This can be achieved in languages with a dynamic type system only with a huge amount of code tests (supporting big test suite is a time consuming process as well as code support).&lt;/p&gt;&lt;p&gt;The other thing that I really like about ReasonML codebase&amp;#8202;&amp;mdash;&amp;#8202;how readable it is. When you just enter into ReasonML world&amp;#8202;&amp;mdash;&amp;#8202;some things can be unfriendly from the first sight, for example, immutable let bindings, but in the end, you realize that these language decisions help you to write cleaner and simpler&amp;nbsp;code.&lt;/p&gt;&lt;h4&gt;Seif&lt;/h4&gt;&lt;p&gt;The programming language I used the most in the past is JavaScript. I switched to Reason when I joined Ahrefs a few months ago. From the start, I worked mainly on the code shared by the majority of the tools and I don&amp;rsquo;t think I would have had the same confidence making changes if I was doing it with JavaScript. I love JavaScript&amp;rsquo;s developer experience and accessibility. Reason provided me predictability without hurting these very same things I like about JavaScript.&lt;/p&gt;&lt;h4&gt;Bryan&lt;/h4&gt;&lt;p&gt;Reason (and OCaml) is, by far, one of the easiest languages to work with. Easy in the sense that the compiler helps eliminate an entire class of errors so you don&amp;rsquo;t have to worry about them. Additionally, in most other web-centric languages, it&amp;rsquo;s a pain to add features to existing code that you&amp;rsquo;ve not touched for a long time. With strong static typing, I can usually add the feature I want in either the backend or frontend, and then let the compiler tell me what needs to be&amp;nbsp;updated.&lt;/p&gt;&lt;p&gt;Pattern-matching is one of my favourite features in Reason. To me, it makes more sense to be able to explicitly specify conditions that I&amp;rsquo;m interested in a clear and concise manner, and let the compiler tell me if I missed out a particular condition. Records go hand-in-hand with this. As software programs are made up of data and instructions, records are the perfect data containers. They are quick to define and query, focusing on data rather than behaviour (think classes and instance methods).&lt;/p&gt;&lt;p&gt;It definitely took a while to pick up Reason mainly because it takes time to become familiar with idiomatic OCaml. But once I crested that learning curve, everything just made sense and all the features of the language that made Reason seemingly difficult to learn&amp;#8202;&amp;mdash;&amp;#8202;strong typing, the functional paradigm, etc, became assistants that helped me to write better&amp;nbsp;code.&lt;/p&gt;&lt;h4&gt;Feihong&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://reasonml.github.io/reason-react/en/&quot;&gt;ReasonReact&lt;/a&gt; is a great library for making complex UIs in a large codebase because you get the familiarity of React coupled with the type safety of OCaml. Having two well-established technologies in its foundation is a big advantage that ReasonReact has over other functional UI libraries/frameworks in the transpile-to-JS universe. I didn&amp;rsquo;t have any professional OCaml experience before joining, yet the ramp up was made much easier by my existing knowledge of React and the (somewhat superficial) similarity of the Reason syntax to JS. Oftentimes it was possible to correctly guess the intent of existing Reason code without knowing all the syntax, because most React concepts carry over pretty directly. And even though the documentation is incomplete and not perfect, it&amp;rsquo;s quite usable already and among conceptually-similar frameworks is second only to the Elm documentation.&lt;/p&gt;&lt;p&gt;The compiler errors were difficult to get used to at first. The compiler is fairly good at pointing out the location of the error, but not necessarily as good at explaining the nature or cause of the error. As such, having a REPL would be extremely useful. Actually, OCaml does have its own REPL, but BuckleScript (the compiler used by Reason to translate OCaml to JS) does not at the moment. Nonetheless, the &lt;a href=&quot;https://reasonml.github.io/en/try&quot;&gt;Try Reason&lt;/a&gt; page is a really good tool to try out small snippets of code and is extremely useful while learning the language (we will still occasionally post Try Reason links in our slack channel).&lt;/p&gt;&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;The reality is that Ahrefs has always been an OCaml shop, but in the past OCaml was only used to build the backend. Now that we are also using it on the frontend, we get the benefits that our backend colleagues have enjoyed for many years: the expressiveness afforded by pattern matching, the ease of refactoring in large codebases, the stability of a mature programming language, and the confidence of &amp;ldquo;if it compiles, it works&amp;rdquo;. To make a shoddy nautical analogy, it is as if we had built a wooden ship powered by a turbo engine. But now the wooden parts are being replaced with steel and plastic, bringing the exterior of the ship up to modern standards as well. As a result, the ship runs faster and more reliably, making the passengers (our users) more satisfied. Also, pirates (bugs) have a harder time hijacking the ship because it&amp;rsquo;s sturdier and defended by well-disciplined camels. Because the ship keeps getting more and more passengers who want to experience a delightful ride and take pictures with enigmatic camels, we require a constant influx of willing and able boat engineers (who aren&amp;rsquo;t allergic to camels) to extend and maintain the ship. (Yes, that means that &lt;a href=&quot;https://ahrefs.com/jobs&quot;&gt;we are hiring&lt;/a&gt;&amp;#65039;.)&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thanks to Raman and Louis for fact checking this&amp;nbsp;post.&lt;/em&gt;&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=2250cf5ba63b&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b&quot;&gt;One and a half years of ReasonML in production&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b?source=rss----303662d88bae--ocaml</id><title type="text">One and a half years of ReasonML in production</title><updated>2020-07-26T15:19:31-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/how-to-write-a-library-for-bucklescript-and-native-22f45e5e946d?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;p&gt;&lt;em&gt;Written with &lt;/em&gt;&lt;a href=&quot;https://twitter.com/javierwchavarri&quot;&gt;&lt;em&gt;Javier Ch&amp;aacute;varri&lt;/em&gt;&lt;/a&gt;&lt;em&gt; and &lt;/em&gt;&lt;a href=&quot;https://github.com/feihong/&quot;&gt;&lt;em&gt;Feihong&amp;nbsp;Hsu&lt;/em&gt;&lt;/a&gt;&lt;em&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;The first &lt;a href=&quot;https://www.reason-conf.us/&quot;&gt;Reason Conf US&lt;/a&gt; just ended. Many talks mentioned native compilation. Sharing code between BuckleScript and native artifacts is a use case which is more and more common. This blog post is an introduction on how to set up a library available for both worlds, sharing as much code as possible.&lt;/p&gt;&lt;h3&gt;The goal&lt;/h3&gt;&lt;p&gt;What we try to produce is a library with an identical interface for BuckleScript and native. But without duplicating code. It should also be possible to have some parts of the library that are a different implementation depending on the target, as we want to be able to leverage existing libraries that are working only in one of the&amp;nbsp;worlds.&lt;/p&gt;&lt;h3&gt;The build&amp;nbsp;systems&lt;/h3&gt;&lt;p&gt;For BuckleScript, there is only one build system: bsb. It is driven by a bsconfig.json file. And is installed as part of the bs-platform.&lt;/p&gt;&lt;p&gt;On the native side, there are a lot of different build systems that are available. But recently one of them became a de facto standard: dune. It works with a very minimal amount of configuration. And it supports the reason syntax by&amp;nbsp;default.&lt;/p&gt;&lt;p&gt;These two tools are working in a way which is pretty similar. They share a lot of concepts. And it is easy to set them up so that both are working in the same codebase.&lt;/p&gt;&lt;p&gt;The main similarities that interest us&amp;nbsp;are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The ability to work on specific source directories&lt;/li&gt;&lt;li&gt;Namespacing in bsb and wrapping in dune are both putting all the&lt;br/&gt;files of the library under a single module&amp;nbsp;name&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;The source code file&amp;nbsp;tree&lt;/h3&gt;&lt;p&gt;The code of the library is split into 3 directories.&lt;/p&gt;&lt;pre&gt;&amp;#9500;&amp;#9472;&amp;#9472; js/&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; native/&lt;br/&gt;&amp;#9492;&amp;#9472;&amp;#9472; shared/&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;shared is meant to host most of the code and all the code in this directory will be compiled in both&amp;nbsp;modes.&lt;/li&gt;&lt;li&gt;js contains the parts that are specific to BuckleScript.&lt;/li&gt;&lt;li&gt;native contains the parts that are specific to native&amp;nbsp;OCaml.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Set up the build&amp;nbsp;systems&lt;/h3&gt;&lt;p&gt;Once we have our basic skeleton for the library, it is time to set up the build systems. We want to have two configurations as similar as possible to make them easier to understand. Once we are done, the tree will look like&amp;nbsp;this:&lt;/p&gt;&lt;pre&gt;&amp;#9500;&amp;#9472;&amp;#9472; bsconfig.json&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; dune&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; dune-project&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; js/&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; native/&lt;br/&gt;&amp;#9492;&amp;#9472;&amp;#9472; shared/&lt;/pre&gt;&lt;h4&gt;BuckleScript&lt;/h4&gt;&lt;p&gt;At the root of the library we need a bsconfig.json file to drive&lt;br/&gt;bsb. The documentation is available at &lt;a href=&quot;https://bucklescript.github.io/docs/en/build-configuration%5D(https://bucklescript.github.io/docs/en/build-configuration).&quot;&gt;https://bucklescript.github.io/docs/en/build-configuration&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The main part for us is sources. We will use it to tell bsb to look at the js and shared folders. We also want to set namespace to true, which will wrap all your project&amp;rsquo;s files under a common module&amp;nbsp;name.&lt;/p&gt;&lt;pre&gt;  &amp;quot;namespace&amp;quot;: true,&lt;br/&gt;  &amp;quot;sources&amp;quot;: [&lt;br/&gt;    {&lt;br/&gt;      &amp;quot;dir&amp;quot;: &amp;quot;js&amp;quot;,&lt;br/&gt;      &amp;quot;subdirs&amp;quot;: true&lt;br/&gt;    }, {&lt;br/&gt;      &amp;quot;dir&amp;quot;: &amp;quot;shared&amp;quot;,&lt;br/&gt;      &amp;quot;subdirs&amp;quot;: true&lt;br/&gt;    }&lt;br/&gt;  ],&lt;/pre&gt;&lt;p&gt;The rest of the file is as&amp;nbsp;usual.&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  &amp;quot;name&amp;quot;: &amp;quot;sharedlib&amp;quot;,&lt;br/&gt;  &amp;quot;namespace&amp;quot;: true,&lt;br/&gt;  &amp;quot;sources&amp;quot;: [&lt;br/&gt;    {&lt;br/&gt;      &amp;quot;dir&amp;quot;: &amp;quot;js&amp;quot;,&lt;br/&gt;      &amp;quot;subdirs&amp;quot;: true&lt;br/&gt;    }, {&lt;br/&gt;      &amp;quot;dir&amp;quot;: &amp;quot;shared&amp;quot;,&lt;br/&gt;      &amp;quot;subdirs&amp;quot;: true&lt;br/&gt;    }&lt;br/&gt;  ],&lt;br/&gt;  &amp;quot;package-specs&amp;quot;: {&lt;br/&gt;    &amp;quot;module&amp;quot;: &amp;quot;es6&amp;quot;,&lt;br/&gt;    &amp;quot;in-source&amp;quot;: true&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;refmt&amp;quot;: 3,&lt;br/&gt;  &amp;quot;suffix&amp;quot;: &amp;quot;.bs.js&amp;quot;,&lt;br/&gt;  &amp;quot;generate-merlin&amp;quot;: true,&lt;br/&gt;}&lt;/pre&gt;&lt;h4&gt;Dune&lt;/h4&gt;&lt;p&gt;We must also add a dune file to the root of the library. For dune, we have different options&amp;#8202;&amp;mdash;&amp;#8202;it is possible to ignore the js directory but read everything else. Or to check only shared and native. To make the configuration similar to BuckleScript, we will go with the second solution.&lt;/p&gt;&lt;p&gt;The dune directive to do that is dirs. By defaults it tells dune to explore every directory except the ones hidden (starting with a dot) or starting with an underscore. &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#dirs-since-1-6&quot;&gt;More details in dune&amp;rsquo;s documentation&lt;/a&gt;. To make it do what we want, the configuration should&amp;nbsp;be:&lt;/p&gt;&lt;pre&gt;(dirs shared native)&lt;/pre&gt;&lt;p&gt;We also use another option of dune to tell it to include the content of those two directories as if it was at the root of the project. Without this stanza, dune would only use the source files at the root of the project and ignore everything in the sub directories.&lt;/p&gt;&lt;pre&gt;(include_subdirs unqualified)&lt;/pre&gt;&lt;p&gt;Then we need the usual library stanza to give a name to our library, state the dependencies, compilation flags, etc. In our simple case, the only information needed is the name. We can explicitly set wrapped to true, but this is already the default behavior. The &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#library&quot;&gt;documentation for the whole library stanza&lt;/a&gt; describes how to specify more&amp;nbsp;details.&lt;/p&gt;&lt;p&gt;The final dune file looks like&amp;nbsp;this:&lt;/p&gt;&lt;pre&gt;(dirs shared native)&lt;br/&gt; (include_subdirs unqualified)&lt;br/&gt; (library&lt;br/&gt;  (name sharedlib))&lt;/pre&gt;&lt;p&gt;We also want a basic dune-project. If we don&amp;rsquo;t write it by hand, dune will generate it for us. I am using version 1.10 as an example. But it can be changed to whatever version suits your&amp;nbsp;project.&lt;/p&gt;&lt;pre&gt;(lang dune 1.10)&lt;/pre&gt;&lt;h3&gt;Compilation&lt;/h3&gt;&lt;p&gt;With the setup described above, the compilation for BuckleScript and native is the same as in a setup with only one or the&amp;nbsp;other.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;bsb -make-world for BuckleScript&lt;/li&gt;&lt;li&gt;dune build @all for&amp;nbsp;dune&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The call to bsb is usally put in package.json in the scripts part, so that the usual yarn build can be used. For native, it depends if you rely on esy or&amp;nbsp;opam.&lt;/p&gt;&lt;h3&gt;How to consume the&amp;nbsp;library&lt;/h3&gt;&lt;p&gt;This is exactly the same setup that would be used in a pure BuckleScript or pure native&amp;nbsp;library.&lt;/p&gt;&lt;p&gt;To use your library in BuckleScript:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Add the name and version to package.json&lt;/li&gt;&lt;li&gt;Add the name to bsbconfig.json of consuming library/app&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;To use your library in native OCaml, add the name of your library to the libraries part an executable or library stanza,&amp;nbsp;e.g.&lt;/p&gt;&lt;pre&gt;(executable&lt;br/&gt; (name main)&lt;br/&gt; (libraries sharedlib))&lt;/pre&gt;&lt;h3&gt;Module naming&lt;/h3&gt;&lt;p&gt;If you want your module name to contain capital letters in the middle (e.g. TeenageMutantNinjaTurtles), then be aware that &lt;a href=&quot;https://bucklescript.github.io/docs/en/build-configuration.html#name-namespace&quot;&gt;name munging&lt;/a&gt; works differently between bsbconfig.json and dune. For example, if you want to refer to your module as CoolSharedLib in your code, then the name in bsbconfig.json must be cool-shared-lib, and in dune it must be coolSharedLib.&lt;/p&gt;&lt;h3&gt;Platform specific&amp;nbsp;code&lt;/h3&gt;&lt;p&gt;The whole library does not have to be exactly the same in the two platform. It is possible to add modules that are available only in one mode. Or to have modules with a different interface.&lt;/p&gt;&lt;p&gt;For example, by adding a file Foo.re in js but not in native, the library now has a module Foo available when compiled to javascript. But only when compiled to javascript.&lt;/p&gt;&lt;h3&gt;Downsides&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Both bsb and dune generate&amp;nbsp;.merlin files when they compile our library. They override each other. It might be troublesome if the version of ocaml used for native code is not 4.02.3. Simply recompile the library for your platform to solve the&amp;nbsp;problem.&lt;/li&gt;&lt;li&gt;Out of the box, this approach doesn&amp;rsquo;t really allow us to share interface files between both platforms: native and BuckleScript. One workaround for that, if we wanted to share some module Foo, is to:&lt;br/&gt;1. add Foo.mli or Foo.rei file in shared&lt;br/&gt;2. add include FooImplementation in Foo.ml&lt;br/&gt;3. add FooImplementation in both native and js&amp;nbsp;folder&lt;/li&gt;&lt;li&gt;It&amp;rsquo;s not possible to be platform specific for just a few lines of code (e.g. if IS_NATIVE foo else bar), the minimal per-platform unit is a file/module.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Example project&lt;/h3&gt;&lt;p&gt;We have set up a simple library to showcase what a repository looks like once the whole configuration is in place. It is &lt;a href=&quot;https://github.com/ahrefs/hello-native-bucklescript&quot;&gt;available on&amp;nbsp;github&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;For now the repository contains only a library. But with this setup, it is actually possible to build an executable too. It is also possible to enrich it, for example by adding &lt;a href=&quot;https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081&quot;&gt;atdgen to communicate between both sides of the&amp;nbsp;library&lt;/a&gt;.&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=22f45e5e946d&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/how-to-write-a-library-for-bucklescript-and-native-22f45e5e946d&quot;&gt;How to write a library for BuckleScript and Native&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/how-to-write-a-library-for-bucklescript-and-native-22f45e5e946d?source=rss----303662d88bae--ocaml</id><title type="text">How to write a library for BuckleScript and Native</title><updated>2019-10-22T10:09:09-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/mjambon/atd&quot;&gt;atdgen&lt;/a&gt; is a project to create types and data structures that can be serialized to JSON. It is very convenient when communicating between multiple processes, creating a REST API or consuming JSON objects from other tools. It can be compared to &lt;a href=&quot;https://json-schema.org/&quot;&gt;JSON schema&lt;/a&gt; or &lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;Protocol Buffers&lt;/a&gt;, but with richer types and more features.&lt;/p&gt;&lt;p&gt;The idea is to write a list of types in a specification file, an&amp;nbsp;.atd file. Then running atdgen, it is possible to generate OCaml or Java code to serialize/deserialize values of those types to/from corresponding json.&lt;/p&gt;&lt;p&gt;Until very recently, atdgen could generate code only for native OCaml. But &lt;a href=&quot;https://github.com/mjambon/atd/pull/44&quot;&gt;the support of bucklescript has been merged&lt;/a&gt;! atdgen the cli tool is still a native OCaml binary. But it can output some OCaml code that can be compiled using &lt;a href=&quot;https://bucklescript.github.io/&quot;&gt;bucklescript&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The work to implement this new feature of atdgen has been funded by &lt;a href=&quot;https://ahrefs.com/&quot;&gt;Ahrefs&lt;/a&gt;. We highly appreciate open source tools. And as much as possible, we prefer to contribute to existing open source projects rather than to re-invent the wheel internally.&lt;/p&gt;&lt;h3&gt;Installation&lt;/h3&gt;&lt;p&gt;To install atdgen we first need to install &lt;a href=&quot;https://opam.ocaml.org&quot;&gt;opam&lt;/a&gt; (OCaml package manager), as atdgen doesn&amp;rsquo;t provide ready to use binaries and is only distributed as source package via opam. The procedure is simple and documented here: &lt;a href=&quot;https://opam.ocaml.org/doc/2.0/Install.html&quot;&gt;https://opam.ocaml.org/doc/2.0/Install.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Then we need to initialize opam and create a switch. Any version of ocaml greater or equal to 4.03.0 should be&amp;nbsp;fine.&lt;/p&gt;&lt;pre&gt;opam init -a&lt;br/&gt;opam switch create . 4.07.1 -y&lt;/pre&gt;&lt;p&gt;Once it is done, we have to install the development version of atdgen. The support of bucklescript is not officially released.&lt;/p&gt;&lt;pre&gt;opam pin add atd --dev-repo   &lt;br/&gt;opam pin add atdgen --dev-repo&lt;/pre&gt;&lt;p&gt;Make sure that atdgen is available.&lt;/p&gt;&lt;pre&gt;$ which atdgen                 &lt;br/&gt;(current $PWD)/_opam/bin/atdgen&lt;/pre&gt;&lt;p&gt;Of course, we need bucklescript.&lt;/p&gt;&lt;pre&gt;yarn init                 &lt;br/&gt;yarn add bs-platform --dev&lt;/pre&gt;&lt;p&gt;We also need the bucklescript runtime for atdgen, as it is not currently provided by atdgen itself. So we have written and open-sourced our version of the runtime&amp;nbsp;: &lt;a href=&quot;https://github.com/ahrefs/bs-atdgen-codec-runtime&quot;&gt;https://github.com/ahrefs/bs-atdgen-codec-runtime&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This runtime is responsible for the conversion between JSON values and OCaml values. The JSON values are based on the standard &lt;a href=&quot;https://bucklescript.github.io/bucklescript/api/Js.Json.html#TYPEt&quot;&gt;Js.Json.t type&lt;/a&gt; provided by bucklescript to be sure that it is easy to interoperate with the rest of the ecosystem.&lt;/p&gt;&lt;p&gt;It is published on npm for easy integration in bucklescript projects.&lt;/p&gt;&lt;pre&gt;yarn add @ahrefs/bs-atdgen-codec-runtime&lt;/pre&gt;&lt;h3&gt;Project configuration&lt;/h3&gt;&lt;p&gt;After the previous section, package.json should be almost ready. We can add a few scripts to make it more convenient to compile the project. Here is how it should look once completed.&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  &amp;quot;name&amp;quot;: &amp;quot;demo-bs-atdgen&amp;quot;,&lt;br/&gt;  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,&lt;br/&gt;  &amp;quot;description&amp;quot;: &amp;quot;demo of atdgen with bucklescript&amp;quot;,&lt;br/&gt;  &amp;quot;scripts&amp;quot;: {&lt;br/&gt;    &amp;quot;clean&amp;quot;: &amp;quot;bsb -clean-world&amp;quot;,&lt;br/&gt;    &amp;quot;build&amp;quot;: &amp;quot;bsb -make-world&amp;quot;,&lt;br/&gt;    &amp;quot;watch&amp;quot;: &amp;quot;bsb -make-world -w&amp;quot;,&lt;br/&gt;    &amp;quot;atdgen&amp;quot;: &amp;quot;atdgen -t meetup.atd &amp;amp;&amp;amp; atdgen -bs meetup.atd&amp;quot;&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;devDependencies&amp;quot;: {&lt;br/&gt;    &amp;quot;bs-platform&amp;quot;: &amp;quot;^4.0.5&amp;quot;&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;peerDependencies&amp;quot;: {&lt;br/&gt;    &amp;quot;bs-platform&amp;quot;: &amp;quot;^4.0.5&amp;quot;&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;dependencies&amp;quot;: {&lt;br/&gt;    &amp;quot;&lt;a href=&quot;http://twitter.com/ahrefs/bs-atdgen-codec-runtime&quot;&gt;@ahrefs/bs-atdgen-codec-runtime&lt;/a&gt;&amp;quot;: &amp;quot;^1.0.4&amp;quot;&lt;br/&gt;  }&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;The bucklescript configuration is very simple. We use the basic configuration that can be found in any bucklescript project. Except that we need to add one dependency to bsconfig.json:&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  &amp;quot;name&amp;quot;: &amp;quot;demo-bs-atdgen&amp;quot;,&lt;br/&gt;  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,&lt;br/&gt;  &amp;quot;sources&amp;quot;: {&lt;br/&gt;    &amp;quot;dir&amp;quot;: &amp;quot;src&amp;quot;,&lt;br/&gt;    &amp;quot;subdirs&amp;quot;: true&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;package-specs&amp;quot;: {&lt;br/&gt;    &amp;quot;module&amp;quot;: &amp;quot;commonjs&amp;quot;,&lt;br/&gt;    &amp;quot;in-source&amp;quot;: true&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;suffix&amp;quot;: &amp;quot;.bs.js&amp;quot;,&lt;br/&gt;  &amp;quot;bs-dependencies&amp;quot;: [&lt;br/&gt;    &amp;quot;&lt;a href=&quot;http://twitter.com/ahrefs/bs-atdgen-codec-runtime&quot;&gt;@ahrefs/bs-atdgen-codec-runtime&lt;/a&gt;&amp;quot;&lt;br/&gt;  ],&lt;br/&gt;  &amp;quot;warnings&amp;quot;: {&lt;br/&gt;    &amp;quot;error&amp;quot;: &amp;quot;+101&amp;quot;&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;generate-merlin&amp;quot;: true,&lt;br/&gt;  &amp;quot;namespace&amp;quot;: true,&lt;br/&gt;  &amp;quot;refmt&amp;quot;: 3&lt;br/&gt;}&lt;/pre&gt;&lt;h3&gt;First ATD definitions&lt;/h3&gt;&lt;p&gt;It is time to create a first&amp;nbsp;.atd file, containing our types. This part is also documented on &lt;a href=&quot;https://atd.readthedocs.io/en/latest/tutorial.html#getting-started&quot;&gt;https://atd.readthedocs.io/en/latest/tutorial.html#getting-started&lt;/a&gt;&lt;/p&gt;&lt;p&gt;For this example, I decided to go with a meetup event. Put the type definitions in src/meetup.atd.&lt;/p&gt;&lt;pre&gt;(* This is a comment. Same syntax as in ocaml. *)&lt;/pre&gt;&lt;pre&gt;type access = [ Private | Public ]&lt;/pre&gt;&lt;pre&gt;(* the date will be a float in the json and a Js.Date.t in ocaml *)&lt;br/&gt;type date = float wrap &amp;lt;ocaml module=&amp;quot;Js.Date&amp;quot; wrap=&amp;quot;Js.Date.fromFloat&amp;quot; unwrap=&amp;quot;Js.Date.valueOf&amp;quot;&amp;gt;&lt;/pre&gt;&lt;pre&gt;(* Some people don't want to provide a phone number, make it optional *)&lt;br/&gt;type person = {&lt;br/&gt;  name: string;&lt;br/&gt;  email: string;&lt;br/&gt;  ?phone: string nullable;&lt;br/&gt;}&lt;/pre&gt;&lt;pre&gt;type event = {&lt;br/&gt;  access: access;&lt;br/&gt;  name: string;&lt;br/&gt;  host: person;&lt;br/&gt;  date: date;&lt;br/&gt;  guests: person list;&lt;br/&gt;}&lt;/pre&gt;&lt;pre&gt;type events = event list&lt;/pre&gt;&lt;p&gt;We use the atdgen binary (compiled previously) to generate the ocaml types and the code to serialize/deserialize those&amp;nbsp;types.&lt;/p&gt;&lt;pre&gt;atdgen -t meetup.atd # generates an ocaml file containing the types&lt;br/&gt;atdgen -bs meetup.atd # generates the code to (de)serialize&lt;/pre&gt;&lt;p&gt;The generated files&amp;nbsp;are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;meetup_t.ml(i) which contain the ocaml types corresponding to our ATD definitions.&lt;/li&gt;&lt;li&gt;meetup_bs.ml(i) which contain the ocaml code to transform from and to json&amp;nbsp;values.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;At this point we can compile our&amp;nbsp;project.&lt;/p&gt;&lt;pre&gt;yarn build&lt;/pre&gt;&lt;p&gt;If everything worked properly, we now have two&amp;nbsp;.bs.js files in the src directory.&lt;/p&gt;&lt;pre&gt;$ tree src&lt;br/&gt;src&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup.atd&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup_bs.bs.js&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup_bs.ml&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup_bs.mli&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup_t.bs.js&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup_t.ml&lt;br/&gt;&amp;#9492;&amp;#9472;&amp;#9472; meetup_t.mli&lt;/pre&gt;&lt;pre&gt;0 directories, 7 files&lt;/pre&gt;&lt;p&gt;At this point, we can create new OCaml/Reason files in the src directory and use all the code atdgen generated for us. Two examples to illustrate that.&lt;/p&gt;&lt;h3&gt;Query a REST&amp;nbsp;API&lt;/h3&gt;&lt;p&gt;A common usage of atdgen is to decode the JSON returned by a REST API. Here is a short example, using the reason syntax and bs-fetch.&lt;/p&gt;&lt;pre&gt;let get = (url, decode) =&amp;gt;&lt;br/&gt;  Js.Promise.(&lt;br/&gt;    Fetch.fetchWithInit(&lt;br/&gt;      url,&lt;br/&gt;      Fetch.RequestInit.make(~method_=Get, ()),&lt;br/&gt;    )&lt;br/&gt;    |&amp;gt; then_(Fetch.Response.json)&lt;br/&gt;    |&amp;gt; then_(json =&amp;gt; json |&amp;gt; decode |&amp;gt; resolve)&lt;br/&gt;  );&lt;/pre&gt;&lt;pre&gt;let v: Meetup_t.events =&lt;br/&gt;  get(&lt;br/&gt;    &amp;quot;&lt;a href=&quot;http://localhost:8000/events&quot;&gt;http://localhost:8000/events&lt;/a&gt;&amp;quot;,&lt;br/&gt;    Atdgen_codec_runtime.Decode.decode(Meetup_bs.read_events),&lt;br/&gt;  );&lt;/pre&gt;&lt;h3&gt;Read and write a JSON&amp;nbsp;file&lt;/h3&gt;&lt;p&gt;Atdgen for bucklescript doesn&amp;rsquo;t take care of converting a string to a JSON object. Which allows us to use the performant json parser included in nodejs or the&amp;nbsp;browser.&lt;/p&gt;&lt;pre&gt;let read_events filename =&lt;br/&gt;  (* Read and parse the json file from disk, this doesn't involve atdgen. *)&lt;br/&gt;  let json =&lt;br/&gt;    Node_fs.readFileAsUtf8Sync filename&lt;br/&gt;    |&amp;gt; Js.Json.parseExn&lt;br/&gt;  in&lt;br/&gt;  (* Turn it into a proper record. The annotation is of course optional. *)&lt;br/&gt;  let events: Meetup_t.events =&lt;br/&gt;    Atdgen_codec_runtime.Decode.decode Meetup_bs.read_events json&lt;br/&gt;  in&lt;br/&gt;  events&lt;/pre&gt;&lt;p&gt;The reverse operation, converting a record to a JSON object and writing it in a file is also straightforward.&lt;/p&gt;&lt;pre&gt;let write_events filename events =&lt;br/&gt;  Atdgen_codec_runtime.Encode.encode Meetup_bs.write_events events (* turn a list of records into json *)&lt;br/&gt;  |. Js.Json.stringifyWithSpace 2   (* convert the json to a pretty string *)&lt;br/&gt;  |&amp;gt; Node_fs.writeFileAsUtf8Sync filename  (* write the json in our file *)&lt;/pre&gt;&lt;h3&gt;Full example&lt;/h3&gt;&lt;p&gt;Now that we have our functions to read and write events, we can build a small cli to pretty print the list of events and add new&amp;nbsp;events.&lt;/p&gt;&lt;p&gt;The source code of the full example is available &lt;a href=&quot;https://github.com/ahrefs/bs-atdgen-codec-runtime/tree/master/example&quot;&gt;on&amp;nbsp;github&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;You can run it like&amp;nbsp;this:&lt;/p&gt;&lt;pre&gt;$ echo &amp;quot;[]&amp;quot; &amp;gt; events.json&lt;br/&gt;$ nodejs src/cli.bs.js add louis &lt;a href=&quot;mailto:louis@nospam.com&quot;&gt;louis@nospam.com&lt;/a&gt;&lt;br/&gt;$ nodejs src/cli.bs.js add bob &lt;a href=&quot;mailto:bob@nospam.com&quot;&gt;bob@nospam.com&lt;/a&gt;&lt;br/&gt;$ nodejs src/cli.bs.js print&lt;br/&gt;=== OCaml/Reason Meetup! summary ===&lt;br/&gt;date: Tue, 11 Sep 2018 15:04:16 GMT&lt;br/&gt;access: public&lt;br/&gt;host: bob &amp;lt;&lt;a href=&quot;mailto:bob@nospam.com&quot;&gt;bob@nospam.com&lt;/a&gt;&amp;gt;&lt;br/&gt;guests: 1&lt;br/&gt;=== OCaml/Reason Meetup! summary ===&lt;br/&gt;date: Tue, 11 Sep 2018 15:04:13 GMT&lt;br/&gt;access: public&lt;br/&gt;host: louis &amp;lt;&lt;a href=&quot;mailto:louis@nospam.com&quot;&gt;louis@nospam.com&lt;/a&gt;&amp;gt;&lt;br/&gt;guests: 1&lt;br/&gt;$ cat events.json&lt;br/&gt;[&lt;br/&gt;  {&lt;br/&gt;    &amp;quot;guests&amp;quot;: [&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;email&amp;quot;: &amp;quot;&lt;a href=&quot;mailto:bob@nospam.com&quot;&gt;bob@nospam.com&lt;/a&gt;&amp;quot;,&lt;br/&gt;        &amp;quot;name&amp;quot;: &amp;quot;bob&amp;quot;&lt;br/&gt;      }&lt;br/&gt;    ],&lt;br/&gt;    &amp;quot;date&amp;quot;: 1536678256177,&lt;br/&gt;    &amp;quot;host&amp;quot;: {&lt;br/&gt;      &amp;quot;email&amp;quot;: &amp;quot;&lt;a href=&quot;mailto:bob@nospam.com&quot;&gt;bob@nospam.com&lt;/a&gt;&amp;quot;,&lt;br/&gt;      &amp;quot;name&amp;quot;: &amp;quot;bob&amp;quot;&lt;br/&gt;    },&lt;br/&gt;    &amp;quot;name&amp;quot;: &amp;quot;OCaml/Reason Meetup!&amp;quot;,&lt;br/&gt;    &amp;quot;access&amp;quot;: &amp;quot;Public&amp;quot;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &amp;quot;guests&amp;quot;: [&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;email&amp;quot;: &amp;quot;&lt;a href=&quot;mailto:louis@nospam.com&quot;&gt;louis@nospam.com&lt;/a&gt;&amp;quot;,&lt;br/&gt;        &amp;quot;name&amp;quot;: &amp;quot;louis&amp;quot;&lt;br/&gt;      }&lt;br/&gt;    ],&lt;br/&gt;    &amp;quot;date&amp;quot;: 1536678253790,&lt;br/&gt;    &amp;quot;host&amp;quot;: {&lt;br/&gt;      &amp;quot;email&amp;quot;: &amp;quot;&lt;a href=&quot;mailto:louis@nospam.com&quot;&gt;louis@nospam.com&lt;/a&gt;&amp;quot;,&lt;br/&gt;      &amp;quot;name&amp;quot;: &amp;quot;louis&amp;quot;&lt;br/&gt;    },&lt;br/&gt;    &amp;quot;name&amp;quot;: &amp;quot;OCaml/Reason Meetup!&amp;quot;,&lt;br/&gt;    &amp;quot;access&amp;quot;: &amp;quot;Public&amp;quot;&lt;br/&gt;  }&lt;br/&gt;]&lt;/pre&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=1f3a14004081&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081&quot;&gt;Getting started with atdgen and bucklescript&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081?source=rss----303662d88bae--ocaml</id><title type="text">Getting started with atdgen and bucklescript</title><updated>2018-09-12T02:53:58-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/skylake-bug-a-detective-story-ab1ad2beddcd?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;blockquote&gt;It was a dark and stormy night; the skylake CPU buzzed with excitement, and then, suddenly, the hyperthreads started to lock&amp;nbsp;up..&lt;/blockquote&gt;&lt;p&gt;Or something like&amp;nbsp;that.&lt;/p&gt;&lt;p&gt;This week a new erratum for the Intel Skylake and Kabylake processors families was brought to public attention on &lt;a href=&quot;https://lists.debian.org/debian-devel/2017/06/msg00308.html&quot;&gt;the Debian mailing list&lt;/a&gt;, and then on &lt;a href=&quot;https://news.ycombinator.com/item?id=14630183&quot;&gt;various&lt;/a&gt; &lt;a href=&quot;https://www.reddit.com/r/programming/comments/6jfgfp/warning_intel_skylakekaby_lake_processors_broken/&quot;&gt;social media&lt;/a&gt; and &lt;a href=&quot;http://www.theregister.co.uk/2017/06/25/intel_skylake_kaby_lake_hyperthreading/&quot;&gt;news&amp;nbsp;outlets&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;We have been investigating this issue since January with the core &lt;a href=&quot;http://ocaml.org&quot;&gt;OCaml&lt;/a&gt; team, as we were struggling with a mysterious bug affecting our developers machines, and ultimately our production system, resulting in a corruption of important data in our databases.&lt;/p&gt;&lt;p&gt;At &lt;a href=&quot;https://ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt;, we operate a fleet of thousands of servers, running a wide variety of services (huge web crawler among others). At this scale, dealing with unexpected application behaviors is common. While we try to reduce the probability of the software not functioning as expected, bugs are sadly a real part of our everyday life. Even though we can assume the underlying hardware running any infrastructure can be thought of as more reliable and less prone to bugs than software components, issues can still arise in unexpected ways. When the number of servers increases, it is not unusual to observe faults in the hardware preventing the system from functioning as specified.&lt;/p&gt;&lt;p&gt;It is certainly not frequent to encounter such problems in CPUs but reading through &lt;a href=&quot;https://www3.intel.com/content/dam/www/public/us/en/documents/specification-updates/desktop-6th-gen-core-family-spec-update.pdf&quot;&gt;the list of errata published by any manufacturer,&lt;/a&gt; each CPU model contains a fair amount of bugs. This story is about the bug in the microcode of Skylake processor leading to incorrect code execution under certain conditions. This is certainly scary at first sight: how can we trust our system if we cannot trust its main component&amp;nbsp;? Yet, like software bugs, processor defects can be identified, contained, and we can take actions to prevent them from impacting the operation of the infrastructure.&lt;/p&gt;&lt;p&gt;We do not know the full implications of this particular bug, especially security implications in case of untrusted code execution. But we&amp;rsquo;d like to tell the story of this erratum from our point of view, to provide some context, and show that dealing with it was not much different than dealing with any usual software flaw. While this post aims to cover our own perspective on this adventure, we would like to thank Mark Shinwell, Xavier Leroy, Fr&amp;eacute;d&amp;eacute;ric Bour, everyone involved in the &lt;a href=&quot;https://caml.inria.fr/mantis/view.php?id=7452&quot;&gt;Mantis issue&lt;/a&gt; and the OCaml IRC channel for their help and time spent investigating with us. Update: Xavier Leroy told his own side of the story in another &lt;a href=&quot;http://gallium.inria.fr/blog/intel-skylake-bug/&quot;&gt;blog&amp;nbsp;post.&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Setting the&amp;nbsp;scene&lt;/h3&gt;&lt;p&gt;Our story starts in late 2016 after some of our backend developers received new laptops to work on. After a few days Enguerrand Decorne noticed unusual crashes during compilation of our OCaml codebase.&lt;/p&gt;&lt;p&gt;This issue, considered mildly annoying at first, seemed to affect only Enguerrand&amp;rsquo;s machine. For a few days no other machine would exhibit the same behavior, so we figured this was a fault specific to his system configuration.&lt;/p&gt;&lt;p&gt;However, concerns were subsequently raised after witnessing the generation of invalid machine code and later on, after the deployment of a service on one of our new clusters composed of Skylake Xeon processors, leading to the insertion of corrupted data into our storage system. The priority raised from the annoying level, to potentially critical. Other developers started working together to obtain more information and assess the impact on our infrastructure. Soon after we were able to reproduce the issue on several machines.&lt;/p&gt;&lt;p&gt;The remainder of this post is a technical description of the steps taken to ensure that our systems were operating safely. It is intended to show that such low level CPU issues is not necessarily fatal&amp;#8202;&amp;mdash;&amp;#8202;in less than two weeks, with the great help of core OCaml developers, we identified the conditions of the crash and set up a workaround.&lt;/p&gt;&lt;h3&gt;Tracking down crashes in&amp;nbsp;OCaml&lt;/h3&gt;&lt;p&gt;Most of our backend code is written in &lt;a href=&quot;https://ocaml.org&quot;&gt;OCaml&lt;/a&gt;, a high level and expressive language supporting functional programming style (among others), which allows us to develop robust systems with ease, thanks to its strong type system and mature&amp;nbsp;legacy.&lt;/p&gt;&lt;p&gt;The compiler segfaults were definitely a surprise, since this shouldn&amp;rsquo;t happen for any program written in OCaml, as type system and other features (such as automatic bounds-checking) usually guard us from such errors. However, stack overflows can be possible sources of segfault (when a non-optimal recursion is running too deep), so our first intuition was to increase the stack size when running the compiler. This didn&amp;rsquo;t change anything, and the reported fault address wasn&amp;rsquo;t anywhere near the stack address&amp;nbsp;bound.&lt;/p&gt;&lt;p&gt;Before witnessing the crash on other machines, we suspected a failure in the virtualization software used by our two developers that were able to reproduce the crash, who use VMware as a part of their development workflow. We tried early on to switch to Virtualbox, but the migration proved itself fruitless as the crashes kept appearing. After a short while we began encountering the same issue on physical machines, so we ruled out a possible virtualization software&amp;nbsp;bug.&lt;/p&gt;&lt;p&gt;The usual debugging process for crashing OCaml code didn&amp;rsquo;t prove effective&amp;#8202;&amp;mdash;&amp;#8202;we needed to narrow down our approach.&lt;/p&gt;&lt;p&gt;OCaml ships with &lt;a href=&quot;https://realworldocaml.org/v1/en/html/the-compiler-backend-byte-code-and-native-code.html&quot;&gt;two backend implementations&lt;/a&gt;: a bytecode interpreter and a native compiler. We were able to reproduce the issue using both a native compiler and a compiler running on the bytecode interpreter. Consequently, this ruled out a miscompilation coming from the code &lt;em&gt;emitted&lt;/em&gt; by the compiler, the OCaml runtime &lt;em&gt;itself&lt;/em&gt; was misbehaving.&lt;/p&gt;&lt;p&gt;The runtime code is written in C, and implements low level functionalities, including the garbage collector used by both backends. After rebuilding the runtime with debug symbols, we were able to retrieve a proper stack trace and core dump. The stack trace pointed to the garbage collector&amp;rsquo;s mark phase. OCaml&amp;rsquo;s GC is a classic generational mark and sweep collector. The mark phase walks the heap starting from pointers on the stack and other registered root values, and marks every reachable block of&amp;nbsp;memory.&lt;/p&gt;&lt;p&gt;Further inspection with &lt;strong&gt;&lt;em&gt;gdb&lt;/em&gt;&lt;/strong&gt; of the frame and address of crash revealed that the marking code encountered a corrupted block header with invalid size information, causing what looked like a buffer overrun error. Each memory block allocated in OCaml heap begins with a header word, storing metadata used by the GC, including a tag describing the kind of value present in this memory block. The header contains the size of the block, and the crash happened when the mark code was attempting to scan an array which was supposed to be more than 1TB&amp;nbsp;large.&lt;/p&gt;&lt;p&gt;This was obviously not the cause of the problem but rather the consequence: something corrupted the header word after this block had been properly allocated, postponing the crash until the next GC cycle. It was the right time to escalate &lt;a href=&quot;https://caml.inria.fr/mantis/view.php?id=7452&quot;&gt;the issue to the OCaml bugtracker&lt;/a&gt;, after isolating a proper test case to reproduce the&amp;nbsp;issue.&lt;/p&gt;&lt;h3&gt;A set of strange&amp;nbsp;leads&lt;/h3&gt;&lt;p&gt;Escalating the issue to Mantis made us to take a step back and gather our findings, and we quickly got great feedback from the OCaml core&amp;nbsp;team.&lt;/p&gt;&lt;p&gt;At this point, what does the problem look&amp;nbsp;like?&lt;/p&gt;&lt;p&gt;We only had sparse information, but &lt;strong&gt;&lt;em&gt;dmesg&lt;/em&gt;&lt;/strong&gt; gave us interesting data point. When a page fault occurs and the kernel detects an incorrect memory access, it logs a line in kernel log buffer containing the fault address, the instruction pointer and stack&amp;nbsp;pointer.&lt;/p&gt;&lt;p&gt;[22985.879907] ocamlopt.opt[48221]: segfault at af8 ip 00005564455169bd sp 00007ffc9f36b130 error 4 in ocamlopt.opt[556445006000+613000]&lt;/p&gt;&lt;p&gt;Next to the 3 addresses, already available in the coredumps, an error code is reported. This number in decimal form is actually a bitset, and the flags are documented in the Linux kernel sources in &lt;a href=&quot;https://github.com/torvalds/linux/blob/v4.11/arch/x86/mm/fault.c#L41&quot;&gt;arch/x86/mm/fault.c&lt;/a&gt;. Error 4 can thus be read as a read access page fault from user mode, trying to read memory which had not been previously mmap&amp;rsquo;ed.&lt;/p&gt;&lt;p&gt;Error codes reported following our crashes involved protection faults or access to unmapped addresses, which corroborated our earlier buffer overrun hypothesis. More interestingly we witnessed a crash with the PF_RSVD flag enabled. This left us puzzled, none of us had ever seen such fault before. Apparently it indicates that the the page table was somehow corrupted, with some entries having non-zero bits reserved by the x86 architecture specification.&lt;/p&gt;&lt;p&gt;It was scary that the corruption would escape the process address space, and to our limited knowledge, it could only have been caused by kernel issue or potentially hardware issues, like memory errors. Yet we were able to reproduce this on several machines with different kernel version, and different hardware. We blamed virtual machines earlier but this theory was debunked already. We still have no explanation at this time, and pursuit on this front would require intimate knowledge of virtual memory implementations that we didn&amp;rsquo;t&amp;nbsp;have.&lt;/p&gt;&lt;p&gt;One developer wasn&amp;rsquo;t able to reproduce the problem at all on his machine after hours of testing, but something was fishy: it didn&amp;rsquo;t sound right that an OCaml runtime bug would be able to modify the page table. Maybe it was some corner case with reserved addresses, but this something was beyond our reach here. Out of ideas, it was time to get some assistance from tools intended to track memory corruptions, like &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizer&quot;&gt;asan and&amp;nbsp;ubsan&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Running &lt;strong&gt;&lt;em&gt;Asan&lt;/em&gt;&lt;/strong&gt; didn&amp;rsquo;t yield any meaningful results. &lt;strong&gt;&lt;em&gt;Valgrind&lt;/em&gt;&lt;/strong&gt; was later tried, following advises from the OCaml team, but every tools were preventing the crash. Quickly reproducing the bug for testing required running code in a loop, keeping the CPU and memory fully&amp;nbsp;busy.&lt;/p&gt;&lt;p&gt;This was harder to do on developers machines, due to limited resources and other processes running, and Address Sanitizer would only increase the resources usage. Dedicating a powerful server would make further investigations more comfortable, and increase the likeliness of reproducing with instrumented code.&lt;/p&gt;&lt;p&gt;But with great surprise, it was not possible to reproduce the problem on a server machine, with and without instrumented code. This is when we realised that all the machines exhibiting the crashes were running a processor of the Intel Skylake processors family, while the server and other developer machines had CPUs from the Broadwell family.&lt;/p&gt;&lt;h3&gt;The hardware, an unusual&amp;nbsp;suspect&lt;/h3&gt;&lt;p&gt;In the meantime several core OCaml developers had been closely investigating the issue and started auditing recent changes in the runtime, and identified a few suspicious changes and known&amp;nbsp;bugs.&lt;/p&gt;&lt;p&gt;Certainly they were more qualified for this task, but it acted as an incentive to examine the history of this bug from our angle. At first, we had assumed that the bug was specific to the new laptop with virtual machines. This could not explain why the crash never manifested on older workstations equipped with Skylake processors. Several other developers had been using them for a few months, and only noticed the crash after awareness of the issue had been raised by Enguerrand.&lt;/p&gt;&lt;p&gt;What had changed, besides Skylake? Only a few week before, an internal migration from OCaml version 4.02.3 to 4.03.0 was rolled out in our codebase. Intrigued, we went ahead and tested OCaml 4.02.3 again, which showed no memory corruptions after several tests. It was time to browse the &lt;a href=&quot;https://raw.githubusercontent.com/ocaml/ocaml/trunk/Changes&quot;&gt;OCaml changelog&lt;/a&gt; for runtime related entries. The search stopped quickly on a promising item in the list: the OCaml C runtime build optimisation level had been increased to -O2 from&amp;nbsp;-O1.&lt;/p&gt;&lt;p&gt;Could the optimizations dig out an undefined behavior in C code, leading to bad assumptions in the GC code corrupting the heap&amp;nbsp;? Rebuilding the runtime with -O1did not corrupt memory, so the source of the corruption was in the runtime &lt;em&gt;and&lt;/em&gt; was triggered by some gcc specific optimization pass. This sounded like undefined behavior, although the information we had led us to some hardware&amp;nbsp;bug.&lt;/p&gt;&lt;p&gt;The next day, Xavier Leroy commented on the bugreport reporting that the crash had been observed in the past. Another industrial OCaml user was affected, and they had discovered HyperThreading was part of the necessary conditions. After running the test case for several hours on several machines with HT disabled in the UEFI setup, it was clear we were facing a similar situation. This led to the hypothesis of a hardware&amp;nbsp;bug:&lt;/p&gt;&lt;blockquote&gt;&lt;em&gt;Is it crazy to imagine that gcc -O2 on the OCaml 4.03 runtime produces a specific instruction sequence that causes hardware issues in (some steppings of) Skylake processors with hyperthreading? Perhaps it is&amp;nbsp;crazy.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;This possibility had struck us too, motivated by the HyperThreading, the page table corruption and the Skylake specific set of conditions.&lt;/p&gt;&lt;p&gt;This issue had certainly a strange profile. But nobody was ready to fully embrace the cpu bug hypothesis yet. We convinced ourselves that disabling HT could affect cache pressure and unfold some undefined behaviours.&lt;/p&gt;&lt;p&gt;HT could also explain the non-determinism, since cache pressure would depend on timings and scheduling. None of us had sufficient experience in this area to assess the strength of such hypothesis, and we did not quite buy it on a single threaded OCaml program. Our debugging motto claims that &amp;ldquo;assumptions are not&amp;nbsp;facts&amp;rdquo;.&lt;/p&gt;&lt;p&gt;It was time to browse Intel errata list and attempt to update the CPU microcode. Although, the errata descriptions are formulated in vague terms, none of the issues disclosed at this time were looking similar to the situation under investigation. Unfortunately, CPUs microcode had no fix waiting for us either. OCaml developers investigated the errata list from their side but the lack of detailed information turned this into a fruitless and complex&amp;nbsp;task.&lt;/p&gt;&lt;p&gt;In the absence of better alternative, we focused our work on pinpointing the exact source of the crash as if it was a software bug, in the hope of either finding a code issue or ruling out this hypothesis while getting more detailed data. We needed a way to identify the problematic code and find a workaround. From our side, it was not only a matter of finding whether or not there was a bug in OCaml code, but more crucially we needed a guarantee on the quality of our generated code running critical services in production.&lt;/p&gt;&lt;h3&gt;Identifying the offending code&lt;/h3&gt;&lt;p&gt;The other OCaml user affected by this issue reported that they had solved the problem by switching to another C compiler. Building the runtime with clang instead of GCC would prevent the GC from crashing. They also suggested to obtain a diff of the generated assembly. Indeed, once built with clang, the runtime would not crash. But clang generates widely different assembly from GCC and we did not have the resources to analyse several hundred thousand lines of&amp;nbsp;changes.&lt;/p&gt;&lt;p&gt;If we could isolate the problematic C code, comparing the generated code would be easier. The problem had the form of a well known&amp;nbsp;nail:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Around 50 C files composing the OCaml&amp;nbsp;runtime,&lt;/li&gt;&lt;li&gt;There is a good state (when built with gcc&amp;nbsp;-O1)&lt;/li&gt;&lt;li&gt;And a bad state (when built with gcc&amp;nbsp;-O2)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This nail comes with a precious hammer: bisection.&lt;/p&gt;&lt;p&gt;The bisection approach had a downside in this occasion. Any state can be labeled bad with certainty as soon as the test crashes, but we would need to wait several hours to be confident enough to trust a non crashing test as good data-point. The reproducibility was not always consistent and a non-crashing state could be a false negative still waiting to trigger the conditions leading to the crash. A reduction of search space was necessary.&lt;/p&gt;&lt;p&gt;All the coredumps we had showed that the fault was caused by a corrupted heap block header, and our testcase involved the compiler. The OCaml compiler is not 100% deterministic, and IO/s primitives and unix environment in the runtime can affect timings and allocation patterns. But it sounded sensible to assume that the code corrupting a heap header block was also the code reading and writing those blocks: the major&amp;nbsp;GC.&lt;/p&gt;&lt;p&gt;This hypothesis made bisecting fast: the first file we tried, &lt;strong&gt;&lt;em&gt;major_gc.c&lt;/em&gt;&lt;/strong&gt;, turned out to be the one. To make sure it was not a subtle issue in linker, reordering symbols or code blocks, we tried a few others files and confirmed changing the optimization level of some other files alone made no difference.&lt;/p&gt;&lt;p&gt;But the generated code difference was still way too large. Bringing this topic up on the &lt;a href=&quot;http://webchat.freenode.net/?channels=#ocaml&quot;&gt;OCaml IRC&lt;/a&gt; discussion channel led to some useful inputs. We were taught that gcc supports an attribute to enable specific optimizations at the function level, using __attribute__((optimize(&amp;quot;options,...&amp;quot;))). Following the same strategy, it was easy to trace the source of the malfunctioning code to the &lt;strong&gt;&lt;em&gt;sweep_slice&lt;/em&gt;&lt;/strong&gt; function, which implements the sweeping phase of the classic mark and sweep garbage collector for the old generation.&lt;/p&gt;&lt;p&gt;Ignoring the subtle details of incremental GC, the &lt;strong&gt;&lt;em&gt;sweep_slice&lt;/em&gt;&lt;/strong&gt; function is the last pass of a normal major collection cycle. It is responsible for scanning all blocks in the major heap, and reclaiming unreachable blocks to the list of unallocated space.&lt;/p&gt;&lt;p&gt;The bulk of this function is a switch taking action for each block depending on its status&amp;nbsp;:&lt;/p&gt;&lt;iframe src=&quot;&quot; width=&quot;0&quot; height=&quot;0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;a href=&quot;https://medium.com/media/cfbc19fddccc5f2c1a76fcc802fae049/href&quot;&gt;https://medium.com/media/cfbc19fddccc5f2c1a76fcc802fae049/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;This finding felt consistent with the information at hand. When the block is reachable, the color (describing the reachability status of the block) is reset. If the block became unreachable (&lt;em&gt;while color&lt;/em&gt;) - it is reclaimed. In both cases, the block header is modified.&lt;/p&gt;&lt;p&gt;Getting back to the assembly&amp;nbsp;diff.&lt;/p&gt;&lt;p&gt;Nobody in the team knows a great deal about assembly and we only have a really basic understanding of most of the instructions used in both versions. It quickly became obvious that the noise level in this diff, with thousands of lines of changed, was still too high for us to spot anything related to the problem. This problem was getting far beyond the common knowledge of everyone in the&amp;nbsp;team.&lt;/p&gt;&lt;p&gt;But this was still sounding like your day to day bug tracking process. The less you know, the more careful you need to be, tackling the problem step by step. We stuck to what approach had served us well until now: bisecting.&lt;/p&gt;&lt;p&gt;We went through the list of optimisation passes enabled by GCC at -O2. This is a fair amount of optimisation passes and it would have been too time consuming to try them one by one, given the time needed to trigger the crash. Yet we had a hint: a memory corruption was happening semi randomly in the garbage collector. We were also keeping the undefined behaviour bug as a potential explanation. It was likely a pass which would change the structure of the code, reordering blocks and changing conditions.&lt;/p&gt;&lt;p&gt;After reading the description of all switches in the detailed gcc manual, the -ftree-* pass family looked promising. This set of transformations works on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single_assignment_form&quot;&gt;SSA form&lt;/a&gt; internal representation, a widespread intermediate language representation which has the benefit of being easy to read. They seem to make a huge impact on the generated assembly code, moving code blocks around and making assumptions on code invariants in order to move around, simplify or eliminate conditional checks altogether.&lt;/p&gt;&lt;p&gt;By looking at output of those passes on the related source code, we narrowed down the list of transformations to a couple of interesting passes, one of them being -ftree-vrp, which stands for Value Range Propagation. This pass computes bounds for each name binding and propagates proofs that a value must lie in a given&amp;nbsp;range.&lt;/p&gt;&lt;p&gt;It turned out most of the other passes depended on it for further optimisations. Even though the issue ended up not being a bad assumptions in the range values, checking this pass proved to be worthwhile: enabling -ftree-vrp on &lt;strong&gt;&lt;em&gt;sweep_slice&lt;/em&gt;&lt;/strong&gt; function while every thing else was built with -O1 was enough to trigger a&amp;nbsp;crash.&lt;/p&gt;&lt;p&gt;GCC provides very good diagnostics output, and after reading the manual we found the -fdump-tree-* switch to dump the SSA form before and after specific pass. The output is designed to be read by a human and provides meaningful naming, with source code locations, alongside the ranges propagated by the VRP pass. We spent some time studying the output and matched the difference in SSA tree between the crashing and not crashing&amp;nbsp;code.&lt;/p&gt;&lt;p&gt;Examining the bounds and invariants derived by gcc, it was clear that no wrong hypothesis was&amp;nbsp;stated.&lt;/p&gt;&lt;iframe src=&quot;&quot; width=&quot;0&quot; height=&quot;0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;a href=&quot;https://medium.com/media/a5a311d0b5a4f890f9541f0aed91e73e/href&quot;&gt;https://medium.com/media/a5a311d0b5a4f890f9541f0aed91e73e/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;The only meaningful observable change involves the suppression of rechecking the loop condition in the else branch of the &lt;strong&gt;&lt;em&gt;sweep_slice&lt;/em&gt;&lt;/strong&gt; function, after Value Range Propagation proved that the condition was invariant in this&amp;nbsp;branch.&lt;/p&gt;&lt;p&gt;Often, reading the code carefully is the fastest way to find a bug. But after spending hours staring at the major GC code, it was clear enough that this check removal should not cause any semantic&amp;nbsp;changes.&lt;/p&gt;&lt;p&gt;In this process, we identified a suspicious bit of code, where a signed long variable was promoted to unsigned according to C standard rules, which was changing the bounds derived by gcc, assuming it was always positive. But after some thinking we realised it made no difference at assembly level and although wrong, this assumption was not used anywhere.&lt;/p&gt;&lt;p&gt;We were now ready to rule out the possibility of a bug in OCaml runtime. It was still possible that GCC backend had a bug and was miscompiling this particular shape of code. And we were back at the assembly level again. After writing some awk formatting script to cleanup assembly and minimise noise in the diff (by renaming labels, detecting spurious code move, etc), and preventing inlining, we found a minimal assembly patch causing the&amp;nbsp;crash.&lt;/p&gt;&lt;p&gt;There were only cosmetic differences. The test removal was propagated down to assembly and caused gcc to reorganise the layout of each switch case&amp;nbsp;block.&lt;/p&gt;&lt;iframe src=&quot;&quot; width=&quot;0&quot; height=&quot;0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;a href=&quot;https://medium.com/media/532ab4896b11177a96203fd0c81eaa58/href&quot;&gt;https://medium.com/media/532ab4896b11177a96203fd0c81eaa58/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;Among those minor differences and changes of layout, we noticed a particular change which impacted exactly the reachable block header updated which could have caused header corruption. In the unoptimised version, the updating code looked like&amp;nbsp;this:&lt;/p&gt;&lt;iframe src=&quot;&quot; width=&quot;0&quot; height=&quot;0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;a href=&quot;https://medium.com/media/38ca30a1decf86233084721c3803b1c4/href&quot;&gt;https://medium.com/media/38ca30a1decf86233084721c3803b1c4/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;For some reason, the block pointer was spilled to the&amp;nbsp;stack.&lt;/p&gt;&lt;p&gt;Perhaps naively, and because we had earlier emitted the hypothesis of HT impacting cache pressure, we spent a few hours staring at this code and check if we were missing something subtle which could affect the control flow of the whole function and the stack location from which it was reloaded could be corrupted.&lt;/p&gt;&lt;p&gt;Despite our lack of assembly knowledge, after spending several hours reading this tiny change, we got convinced that it made strictly no semantic difference. Reading the x86 manual carefully didn&amp;rsquo;t give any hint on any subtle behavior which would trigger. Executing any of those two sequence of instruction should give the exact same&amp;nbsp;output.&lt;/p&gt;&lt;h3&gt;Mitigating the&amp;nbsp;issue&lt;/h3&gt;&lt;p&gt;We were now quite certain it was a CPU&amp;nbsp;bug.&lt;/p&gt;&lt;p&gt;The OCaml developers had reached the same conclusion, and were working on escalating the issue to Intel. After internal discussions we decided to keep this bug as low profile as possible since we were unsure about potential security implications, especially for JIT implementations.&lt;/p&gt;&lt;p&gt;Even if we had no confirmation at this point nor any explanations of the cause of this bug, which was beyond our reach, we could take&amp;nbsp;actions.&lt;/p&gt;&lt;p&gt;The first step was to decide against getting any new Skylake based servers until further announcement. We were left with several Skylake machines but we refrained from deploying any OCaml code on them. OCaml comes with a great package manager, &lt;a href=&quot;https://opam.ocaml.org/&quot;&gt;opam&lt;/a&gt;, which supports compiler switches. Switches allow to set up a clean and distinct environment with specific packages and compiler configuration.&lt;/p&gt;&lt;p&gt;We patched our internal opam repository to distribute unoptimised runtime to all developers and moved forward, waiting for further announcements.&lt;/p&gt;&lt;p&gt;This situation made us realise that microcode requires constant updates, just like any other software in the stack. We raised awareness on this topic in our devops team, and they took measure to ensure we could roll out updates to prod&amp;nbsp;easily.&lt;/p&gt;&lt;h3&gt;Happy end&lt;/h3&gt;&lt;p&gt;In late May, devops team noticed a &lt;a href=&quot;http://metadata.ftp-master.debian.org/changelogs/non-free/i/intel-microcode/intel-microcode_3.20170511.1_changelog&quot;&gt;debian package update for intel-microcode&lt;/a&gt; containing the following change:&lt;/p&gt;&lt;pre&gt;Likely fix nightmare-level Skylake erratum SKL150. Fortunately,&lt;br/&gt;either this erratum is very-low-hitting, or gcc/clang/icc/msvc&lt;br/&gt;won&amp;rsquo;t usually issue the affected opcode pattern and it ends up&lt;br/&gt;being rare.&lt;br/&gt;SKL150 &amp;mdash; Short loops using both the AH/BH/CH/DH registers and&lt;br/&gt;the corresponding wide register *may* result in unpredictable&lt;br/&gt;system behavior. Requires both logical processors of the same&lt;br/&gt;core (i.e. sibling hyperthreads) to be active to trigger, as&lt;br/&gt;well as a &amp;ldquo;complex set of micro-architectural conditions&amp;rdquo;&lt;/pre&gt;&lt;p&gt;The erratum description immediately rang a bell as it matched the diff in the assembly we had observed. We tested the microcode update and confirmed it fixed the corruption.&lt;/p&gt;&lt;p&gt;Finally, our Skylake CPUs were feeling safe and OCaml compiler was&amp;nbsp;happy.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://ahrefs.com&quot;&gt;&lt;em&gt;Ahrefs&lt;/em&gt;&lt;/a&gt;&lt;em&gt; runs an internet-scale bot that crawls the whole Web 24/7. Our backend system is powered by a custom petabyte-scale distributed key-value storage implemented in OCaml (and some C++ and Rust). We are a small team and strongly believe in better technology leading to better solutions for real-world problems. We worship functional languages and static typing, extensively employ code generation and meta-programming, value code clarity and predictability, and are constantly seeking to automate repetitive tasks and eliminate boilerplate. And we are&amp;nbsp;&lt;/em&gt;&lt;a href=&quot;https://ahrefs.com/jobs&quot;&gt;&lt;em&gt;hiring&lt;/em&gt;&lt;/a&gt;&lt;em&gt;!&lt;/em&gt;&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=ab1ad2beddcd&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/skylake-bug-a-detective-story-ab1ad2beddcd&quot;&gt;Skylake bug: a detective story&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/skylake-bug-a-detective-story-ab1ad2beddcd?source=rss----303662d88bae--ocaml</id><title type="text">Skylake bug: a detective story</title><updated>2017-06-28T18:34:51-00:00</updated><author><name>ahrefs</name></author></entry></feed>