<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://medium.com/feed/ahrefs/tagged/ocaml</id><title type="text">ahrefs</title><updated>2023-06-07T05:45:49-00:00</updated><entry><link href="https://tech.ahrefs.com/ahrefs-is-now-built-with-melange-b14f5ec56df4?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;h3&gt;OCaml, all the way&amp;nbsp;down&lt;/h3&gt;&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/0*cGDQZKJ2bKMARpj9&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/ja/@lg17?utm_source=medium&amp;amp;utm_medium=referral&quot;&gt;Lance Grandahl&lt;/a&gt; on&amp;nbsp;&lt;a href=&quot;https://unsplash.com?utm_source=medium&amp;amp;utm_medium=referral&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;Some history&lt;/h4&gt;&lt;p&gt;In 2021, we decided to evaluate &lt;a href=&quot;https://github.com/melange-re/melange&quot;&gt;Melange&lt;/a&gt; as an alternative to &lt;a href=&quot;http://rescript-lang.org/&quot;&gt;ReScript&lt;/a&gt; for compiling Ahrefs&amp;rsquo; frontend codebase. We wrote about the reasons that led us there, as well as the limitations we encountered at the time, in &lt;a href=&quot;https://tech.ahrefs.com/building-ahrefs-codebase-with-melange-9f881f6d022b&quot;&gt;a previous&amp;nbsp;article&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;After this experiment, discussions continued inside the team. Switching to a different compiler, which was in a very early stage, involved quite some risk. But so did the continued use of ReScript, which seemed to be diverging further and further away from&amp;nbsp;OCaml.&lt;/p&gt;&lt;p&gt;Finally, in September 2022 (during &lt;a href=&quot;https://icfp22.sigplan.org/&quot;&gt;ICFP in Ljubljana&lt;/a&gt;), we decided to bite the bullet and kicked off a project to deepen the integration between &lt;a href=&quot;http://dune.build/&quot;&gt;Dune&lt;/a&gt; (OCaml&amp;rsquo;s most used build system) and Melange. This better integration was the key to solve two of the three limitations we had encountered during our initial exploration of&amp;nbsp;Melange:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Build speed would increase due to less work needed to parse dune files, and more efficient rules planning and execution.&lt;/li&gt;&lt;li&gt;Developer ergonomics would get better, as Melange would become a first-class citizen in Dune, with concepts like Dune &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#library&quot;&gt;libraries&lt;/a&gt; and other stanzas becoming available to Melange&amp;nbsp;users.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ahrefs&amp;rsquo; leadership backed the project and agreed to financially support the development of this tighter integration. With this support, we set about building a team that included Rudi Grinberg, who maintains Dune as part of its development team, and Antonio Monteiro, who created Melange and is also part of the Dune development team.&lt;/p&gt;&lt;h4&gt;Heads down&lt;/h4&gt;&lt;p&gt;During the following months, we focused on two tasks, iterating over multiple cycles where the progress on one task would inform the next steps to take for the&amp;nbsp;other:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Evolve Dune to add stanzas, fields, and documentation to support Melange projects.&lt;/li&gt;&lt;li&gt;Migrate Ahrefs&amp;rsquo; frontend codebase to use the Melange compiler and Dune, adapt third-party libraries and bindings to Melange, and polish the editor integration, build scripts, and other aspects of the development experience.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;We believe that tackling these two tasks in parallel led us to better results, compared to a more waterfall-based approach. As we applied the changes over Ahrefs&amp;rsquo; large-ish frontend codebase&amp;#8202;&amp;mdash;&amp;#8202;it will soon reach 5000 modules&amp;#8202;&amp;mdash;&amp;#8202;we kept finding and fixing bugs, improving the ergonomics of the Dune and Melange integration, and in general making the solution more robust, real-world ready, and developer-friendly.&lt;/p&gt;&lt;p&gt;Another upside of the way the project was implemented is that we developed it initially in stealth mode, keeping it quite private. By working on it within a tight-knit team, before making a public release, we could make progress faster. We believe that this approach saved future Melange users a lot of churn and burn caused by the multiple changes in Dune stanza options, Melange flags, and other configurations we changed along the way, as we learned more about this integration.&lt;/p&gt;&lt;h4&gt;Migration strategies&lt;/h4&gt;&lt;p&gt;Initially, our plan was to progressively migrate Ahrefs&amp;rsquo; code to Melange. As the frontend codebase is divided into different tools, each being self-contained, we thought we could introduce Melange to build one tool, then another tool, gradually migrating them one by&amp;nbsp;one.&lt;/p&gt;&lt;p&gt;However, this approach turned out to be too complex because configuring a development environment that works on both Melange and ReScript is challenging. As developers could be working on multiple tools during the same week, or even within the same day, we realized that it was unfeasible to reconfigure the environment every time a developer switched from a tool built with Melange to a tool built with ReScript.&lt;/p&gt;&lt;p&gt;Therefore, we changed our minds and opted for a one-shot migration. We would ensure that CI, development, and staging environments were working with Melange and Dune. And we would do this on separate branches, while still using ReScript on our main branch CI and development scripts. Once we were confident everything was building and functioning correctly with Melange, we switched all CI and development scripts to use the Melange and Dune commands. We tried to keep the PR that applied this switch as small as possible, with just a few hundreds of lines of changes so that we could switch back to ReScript if needed. In fact, after a first attempt in March, we had to switch back to ReScript due to some issues on the developer experience side, related to build performance and ergonomics, which took a few more weeks to&amp;nbsp;solve.&lt;/p&gt;&lt;p&gt;In terms of package management and third-party Melange dependencies, we followed a more gradual approach. Dune is quite flexible when it comes to &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#vendored-dirs&quot;&gt;vendoring&lt;/a&gt;, so in the initial phase, we downloaded Melange libraries with npm, and had Dune include them in the project as if they were local sources. Now we have started migrating some of these libraries so that we can consume them using opam, the OCaml package manager. This will involve first publishing them in our private opam mirror, but the plan is to have them published in the &lt;a href=&quot;https://ocaml.org/packages&quot;&gt;public opam repository&lt;/a&gt; in the future so that other Melange developers can also use&amp;nbsp;them.&lt;/p&gt;&lt;h4&gt;Timings&lt;/h4&gt;&lt;p&gt;You may be curious about the performance differences between the previous and current approaches. Measuring performance is tricky, but we attempted to measure a few different scenarios with both setups. The results can be seen&amp;nbsp;below.&lt;/p&gt;&lt;p&gt;Keep in mind that Ahrefs frontend setup has specific characteristics, which affect the performance measurements:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Before migration: Dune generated ml files from atd files, then ReScript build tool bsb built all hand-written source files plus the ones generated from atd&amp;nbsp;files.&lt;/li&gt;&lt;li&gt;After migration: everything is built with Dune and&amp;nbsp;Melange.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;All measurements were taken on a node with 2x AMD EPYC 7742 cpu @3.2 GHz (nproc=256), 1TB RAM, Debian 11 x86_64 GNU/Linux. The build target is always the entire Ahrefs frontend codebase.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Cold build:&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Before: real 0m28.232s, user 9m23.883s, sys 13m33.939s&lt;/li&gt;&lt;li&gt;After: real 1m14.208s, user 10m33.708s, sys 5m45.644s&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Warm build&lt;/strong&gt;, noop (no file is&amp;nbsp;built):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Before: real 0m14.687s, user 3m17.058s, sys 3m57.903s&lt;/li&gt;&lt;li&gt;After: real 0m21.895s, user 0m20.528s, sys&amp;nbsp;0m1.372s&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Watch mode, modifying an &amp;ldquo;edge&amp;rdquo; file&lt;/strong&gt; with almost no reverse dependencies:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Before: 1002ms&lt;/li&gt;&lt;li&gt;After: 1576ms&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Watch mode, modifying an &amp;ldquo;inner&amp;rdquo; file&lt;/strong&gt; belonging to a library, with many reverse dependencies:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Before: 7032ms&lt;/li&gt;&lt;li&gt;After: 15394ms&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In general, Melange and Dune are slower than ReScript for cold builds in our setup. However, the differences are smaller for warm builds. For watch mode, the difference gets reduced when modifying edge&amp;nbsp;files.&lt;/p&gt;&lt;p&gt;There is room for improvement in the way the Melange and Dune rules are arranged so that cold builds can get faster. For example, delaying some &lt;a href=&quot;https://github.com/melange-re/melange/issues/464&quot;&gt;optimizations in Melange&lt;/a&gt; might allow to parallelize more&amp;nbsp;work.&lt;/p&gt;&lt;h4&gt;Conclusions&lt;/h4&gt;&lt;p&gt;The results so far are quite encouraging. These are some of the things that are possible thanks to the deeper integration between Dune and Melange, and its application within the Ahrefs codebase:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The same OCaml compiler is used on both frontend and backend codebases.&lt;/li&gt;&lt;li&gt;Access to all the bug fixes, error improvements, and new features that the OCaml compiler team added between versions 4.06 and 4.14 of the compiler.&lt;/li&gt;&lt;li&gt;A shared developer environment across teams, including editor extensions, OCaml LSP server, etc. No more need to maintain a different set of tooling for backend and frontend.&lt;/li&gt;&lt;li&gt;Removal of hand-written CI checks that were ensuring different tools in the frontend codebase would not access components from other tools. This is now solved by Dune libraries, and the OCaml compiler will complain if logical units try to reach outside their&amp;nbsp;bounds.&lt;/li&gt;&lt;li&gt;Frontend and backend shared dependencies, such as &lt;a href=&quot;https://github.com/anuragsoni/routes/&quot;&gt;anuragsoni/routes&lt;/a&gt;, can now be defined in a single place: an opam&amp;nbsp;file.&lt;/li&gt;&lt;li&gt;Faster rebuilds and better watch mode, as Dune now controls all the build artifacts. Previously, Dune and ReScript were sharing responsibilities, which was leading to unnecessary rebuilds of some artifacts. Or alternatively, rebuilds were not starting when required due to the build system not tracking changes in some subsets of the&amp;nbsp;sources.&lt;/li&gt;&lt;li&gt;Easier &lt;a href=&quot;https://ocaml.org/docs/metaprogramming&quot;&gt;PPX&lt;/a&gt; maintenance, as there is no longer a need to publish pre-built versions of these&amp;nbsp;tools.&lt;/li&gt;&lt;li&gt;Melange allows to run all ppxs &lt;a href=&quot;https://github.com/melange-re/melange/pull/171&quot;&gt;from a single executable file&lt;/a&gt;, which has some nice performance benefits.&lt;/li&gt;&lt;li&gt;All the other advantages of using Dune: virtual libraries, watch mode, leverage integrations with tools like&amp;nbsp;odoc&amp;hellip;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;What&amp;rsquo;s next?&lt;/h4&gt;&lt;p&gt;We are excited about this project becoming a reality, and we believe that the deeper integration between OCaml and Melange through Dune, together with Melange&amp;rsquo;s ergonomic integration with the JavaScript ecosystem through its bindings, can enable projects that were previously impossible to imagine. For example, full-stack React by hydrating components that are rendered &lt;a href=&quot;https://github.com/ml-in-barcelona/server-reason-react/&quot;&gt;server-side using native&amp;nbsp;OCaml&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Now, we have to make it easier for other people who are willing to try and use Melange and Dune. So our focus is shifting to documenting how Melange&amp;nbsp;works.&lt;/p&gt;&lt;p&gt;There is a section for Melange in the Dune manual that will be included in the next stable release, and that can be consulted today in the latest branch: &lt;a href=&quot;https://dune.readthedocs.io/en/latest/melange.html&quot;&gt;https://dune.readthedocs.io/en/latest/melange.html&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The next step will be to design and create a site where everyone can read and learn about what is needed to create and maintain a project using Melange and Dune. This site will include a playground, in the spirit of the &lt;a href=&quot;https://reasonml.github.io/en/try&quot;&gt;ReasonML one&lt;/a&gt;, so that we can share snippets, see the resulting JavaScript compilation output, and iterate on ideas together.&lt;/p&gt;&lt;p&gt;Besides the above, we have plenty of other things we will be working on in the next months. We will share more information about the roadmap as soon as Dune 3.8 and its respective Melange version are published in the main public opam repository, which should happen in the next&amp;nbsp;weeks.&lt;/p&gt;&lt;h4&gt;How to contribute?&lt;/h4&gt;&lt;p&gt;If you want to be a part of this, or you want to write or port your libraries to Melange, the best way to do so is by reaching out on the &lt;a href=&quot;https://discord.gg/reasonml&quot;&gt;ReasonML Discord&lt;/a&gt;. There is a #melange dedicated channel where one can get help and advice on how to get&amp;nbsp;started.&lt;/p&gt;&lt;p&gt;Otherwise, if you are missing features, find bugs, or run into confusing errors, please open an issue &lt;a href=&quot;https://github.com/melange-re/melange&quot;&gt;in the Melange public&amp;nbsp;repo&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;We hope you share our excitement about this update. Our journey to integrate our frontend stack more naturally within the incredible language and ecosystem of OCaml will be well-documented. Stay tuned for further updates in the&amp;nbsp;future!&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=b14f5ec56df4&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/ahrefs-is-now-built-with-melange-b14f5ec56df4&quot;&gt;Ahrefs is now built with Melange&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/ahrefs-is-now-built-with-melange-b14f5ec56df4?source=rss----303662d88bae--ocaml</id><title type="text">Ahrefs is now built with Melange</title><updated>2023-05-03T19:06:58-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/how-to-get-started-with-ocaml-in-2022-2f22b578b984?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;h3&gt;Intro&lt;/h3&gt;&lt;p&gt;There has never been a better time to learn OCaml, one of the premier statically-typed functional programming languages used in industry. We at Ahrefs have used it on our backend since the early days of the company, and &lt;a href=&quot;https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b&quot;&gt;since 2018 have even used it extensively for our frontend code&lt;/a&gt;. Today we&amp;rsquo;re very excited to share with you our favorite recommendations for getting started with&amp;nbsp;OCaml!&lt;/p&gt;&lt;h3&gt;Best resources for learning&amp;nbsp;OCaml&lt;/h3&gt;&lt;p&gt;If you have little functional programming experience or are even a beginner to programming, the place to start is &lt;a href=&quot;https://ocaml-book.com/&quot;&gt;OCaml from the Very Beginning&lt;/a&gt;, a book that is now free thanks to generous funding from the &lt;a href=&quot;https://ocaml-sf.org/&quot;&gt;OCaml Software Foundation&lt;/a&gt; (which Ahrefs is a sponsor of). The book can be viewed directly from its website and can also be downloaded as a PDF. While advertised as being approachable even to new programmers, this doesn&amp;rsquo;t quite seem to be true, at least based on feedback we&amp;rsquo;ve received. The text itself introduces concepts in a structured way, but the exercises require a little background in programming to complete. Such background info can be obtained by watching the opening videos in &lt;a href=&quot;https://www.youtube.com/playlist?list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&quot;&gt;this series of lectures&lt;/a&gt; from Cornell&amp;rsquo;s OCaml programming course. Speaking of the Cornell course, their official online textbook &lt;a href=&quot;https://cs3110.github.io/textbook/cover.html&quot;&gt;OCaml Programming: Correct + Efficient + Beautiful&lt;/a&gt; is an excellent resource for learners with some programming experience under their belt (specifically, you should have written some code using a mainstream imperative language like Python or&amp;nbsp;Java).&lt;/p&gt;&lt;h3&gt;How to install&amp;nbsp;OCaml&lt;/h3&gt;&lt;p&gt;The &lt;a href=&quot;https://ocaml.org/docs/up-and-running&quot;&gt;official installation instructions&lt;/a&gt; are entirely adequate. It shows you how to install the compiler and some useful dev tools like dune (build system), utop (interactive read-eval-print loop), and ocaml-lsp-server (useful for editor integration).&lt;/p&gt;&lt;p&gt;Actually, if you are working through &lt;a href=&quot;https://ocaml-book.com/&quot;&gt;OCaml from the Very Beginning&lt;/a&gt;, you do not need to install OCaml during the first several chapters, as you can execute code snippets directly on the &lt;a href=&quot;https://try.ocamlpro.com/&quot;&gt;Try OCaml&lt;/a&gt; page, or create a notebook at &lt;a href=&quot;https://sketch.sh/&quot;&gt;Sketch.sh&lt;/a&gt;, an interactive OCaml notebook site maintained by Ahrefs through our monthly Open Source Friday&amp;nbsp;program.&lt;/p&gt;&lt;h3&gt;Editor support&lt;/h3&gt;&lt;p&gt;For most beginners to the language, we recommend the &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform&quot;&gt;official OCaml Platform Visual Studio Code extension&lt;/a&gt;. The official OCaml installation guide has a &lt;a href=&quot;https://ocaml.org/docs/up-and-running#editor-support-for-ocaml&quot;&gt;good section on setting it up&lt;/a&gt;. There is also great support for users of &lt;a href=&quot;https://github.com/ocaml/tuareg&quot;&gt;emacs&lt;/a&gt; and&amp;nbsp;&lt;a href=&quot;https://github.com/ocaml/vim-ocaml&quot;&gt;vim&lt;/a&gt;.&lt;/p&gt;&lt;h3&gt;Tips&lt;/h3&gt;&lt;p&gt;Even early on, it&amp;rsquo;s a good idea to start saving your code into&amp;nbsp;.ml files and learning how to run it. The easiest way to run a simple program is to start up utop and inside of it run #use &amp;quot;name_of_your_program.ml&amp;quot; as &lt;a href=&quot;https://ocaml.org/docs/first-hour#running-ocaml-programs&quot;&gt;described here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;When creating a new notebook in &lt;a href=&quot;https://sketch.sh/&quot;&gt;Sketch.sh&lt;/a&gt;, the default syntax is ReasonML (it&amp;rsquo;s not a different language, just &lt;a href=&quot;https://en.wikipedia.org/wiki/Reason_(programming_language)&quot;&gt;an alternate syntax that more resembles JavaScript&lt;/a&gt;). Click on ML in the top left corner to switch to the original OCaml&amp;nbsp;syntax.&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/0*EgPCQlLR4C54N3Ge&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;Conclusion&lt;/h3&gt;&lt;p&gt;OCaml originated from French academia more than 25 years ago, and from there spread to elite universities and forward-thinking companies around the world. Now the OCaml community has produced high quality learning material that is both free and easy to access. So take the initiative and learn you some&amp;nbsp;OCaml!&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=2f22b578b984&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/how-to-get-started-with-ocaml-in-2022-2f22b578b984&quot;&gt;How to get started with OCaml in 2022&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/how-to-get-started-with-ocaml-in-2022-2f22b578b984?source=rss----303662d88bae--ocaml</id><title type="text">How to get started with OCaml in 2022</title><updated>2022-10-31T16:13:10-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/monorobot-a-slack-bot-for-monorepos-374260e2ca43?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;h3&gt;Monorobot: a notification bot for monorepos&lt;/h3&gt;&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/1*BQNCNLNPxGV3eXajYe6y2g.png&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;Monorobot enables configurable directory tree notifications for your monorepo.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;A few years ago, we decided to move most of our code into a monorepo. Many &lt;a href=&quot;https://danluu.com/monorepo/&quot;&gt;advocates&lt;/a&gt; have highlighted its upsides, which include better cross-project coordination and simpler dependency management.&lt;/p&gt;&lt;p&gt;But one problem remained: &lt;strong&gt;none of the available GitHub integrations for Slack work nicely with monorepos&lt;/strong&gt;. Slack is vital for day to day communication among Ahrefs&amp;rsquo; globally distributed team, so a Slack integration was a must-have feature. We needed a service that could map activity from our various subprojects to their corresponding Slack channels&amp;#8202;&amp;mdash;&amp;#8202;something existing solutions didn&amp;rsquo;t&amp;nbsp;offer.&lt;/p&gt;&lt;p&gt;That&amp;rsquo;s why we built our own integration: &lt;strong&gt;Monorobot&lt;/strong&gt;, a notification bot for monorepos. We&amp;rsquo;ve improved it iteratively since the monorepo transition, incorporating real time feedback from our engineers over time. Today, Monorobot is an active member of Ahrefs&amp;rsquo; Slack workspace, dutifully routing GitHub activity notifications to different channels based on the relevance of each activity.&lt;/p&gt;&lt;p&gt;And now we&amp;rsquo;re &lt;a href=&quot;https://github.com/ahrefs/monorobot&quot;&gt;open-sourcing Monorobot&lt;/a&gt;, for anybody to use in their monorepo setup! The package is available via&amp;nbsp;&lt;a href=&quot;https://opam.ocaml.org/packages/monorobot/&quot;&gt;OPAM&lt;/a&gt;:&lt;/p&gt;&lt;pre&gt;opam install monorobot&lt;/pre&gt;&lt;p&gt;Read on for more details about the motivation, an overview of the main features, and what&amp;rsquo;s in the pipeline.&lt;/p&gt;&lt;h3&gt;Existing Slack integrations lack monorepo&amp;nbsp;support&lt;/h3&gt;&lt;p&gt;Within a monorepo, multiple projects have their code located in separate, nested directories. Correspondingly, each project&amp;rsquo;s Slack channel is only interested in activity from that part of the overall repository. The issue with most GitHub-to-Slack integrations is that once you subscribe a Slack channel to a GitHub repository, the channel receives &lt;em&gt;all&lt;/em&gt; activity from that repository.&lt;/p&gt;&lt;p&gt;Suppose we operate various camel-related services, and we&amp;rsquo;re planning to launch a new camel ride-sharing app called Camel Ride. The directory structure could look like&amp;nbsp;this:&lt;/p&gt;&lt;pre&gt;monorepo/&lt;br/&gt;| frontend/&lt;br/&gt;| | camelride_ui/&lt;br/&gt;| | | mobile/&lt;br/&gt;| | | web/&lt;br/&gt;| | cameldance/&lt;br/&gt;| backend/&lt;br/&gt;| | camelride/&lt;br/&gt;| | | routing/&lt;br/&gt;| | | pricing/&lt;br/&gt;| | camelfood/&lt;/pre&gt;&lt;p&gt;As you can see, both the frontend/ and backend/ directories contain code for our fictitious ride-sharing service, along with code from other projects.&lt;/p&gt;&lt;p&gt;If we were to connect the &lt;a href=&quot;https://slack.com/help/articles/232289568-GitHub-for-Slack&quot;&gt;GitHub for Slack&lt;/a&gt; integration to this repository, notifications for activity from all projects would be sent to the same channel. Even if I were only interested in activity from the Camel Ride project, I&amp;rsquo;d need to sift through notifications from the other, unrelated projects. Imagine the volume of notifications this would create for a larger monorepo with dozens of projects. What a&amp;nbsp;mess!&lt;/p&gt;&lt;h3&gt;Enter Monorobot&lt;/h3&gt;&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/1*ZHkBDdpNcMMw29BmHirM_A.png&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;Monorobot, hard at&amp;nbsp;work.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Monorobot enables more granular control over where notifications from the same repository get routed, depending on the type of activity. This routing behavior can be defined in a configuration file named&amp;nbsp;.monorobot.json, which should be committed to the root of the monorepo. Once you create a &lt;a href=&quot;https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks&quot;&gt;GitHub webhook&lt;/a&gt; from the repository to a running instance of Monorobot, it will use the configuration file to route notifications to relevant channels based on the webhook event&amp;nbsp;payload:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;For pushed commits, it checks the path prefixes of the files modified in the&amp;nbsp;commits.&lt;/li&gt;&lt;li&gt;For activity related to PRs and issues, it checks their&amp;nbsp;labels.&lt;/li&gt;&lt;li&gt;For status updates on pushed commits (e.g., CI builds), it uses the same path prefix logic as pushed&amp;nbsp;commits.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Additionally, Monorobot supports unfurling GitHub links shared in&amp;nbsp;Slack.&lt;/p&gt;&lt;h4&gt;Path prefix routing for commit push notifications&lt;/h4&gt;&lt;p&gt;Continuing with our example, suppose we want to route all commit activity related to the Camel Ride project to a Slack channel called &lt;em&gt;#camelride&lt;/em&gt;. Our configuration file might look like&amp;nbsp;this:&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  ...,&lt;br/&gt;  &amp;quot;prefix_rules&amp;quot;: {&lt;br/&gt;    &amp;quot;rules&amp;quot;: [&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;match&amp;quot;: [&lt;br/&gt;          &amp;quot;frontend/camelride_ui/&amp;quot;,&lt;br/&gt;          &amp;quot;backend/camelride/&amp;quot;&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;ignore&amp;quot;: [&lt;br/&gt;          &amp;quot;frontend/camelride_ui/images&amp;quot;,&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;channel&amp;quot;: &amp;quot;camelride&amp;quot;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  }&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;Each rule &amp;ldquo;matches&amp;rdquo; a file path to a channel. Whenever someone pushes a commit touching files with either of these prefixes, the &lt;em&gt;#camelride&lt;/em&gt; channel will be notified. All other commits will be&amp;nbsp;ignored.&lt;/p&gt;&lt;p&gt;If a file prefix appears in a rule&amp;rsquo;s optional ignore field, the rule won't be matched even if the prefix is is also in the match field. In the above snippet, the Camel Ride frontend team has decided to silence notifications for activity in the images/ subdirectory.&lt;/p&gt;&lt;p&gt;Now, let&amp;rsquo;s say the project&amp;rsquo;s price optimization team is growing, and they&amp;rsquo;ve decided to create their own separate Slack channel called &lt;em&gt;#camelride-pricing&lt;/em&gt;. We can simply commit an update to the&amp;nbsp;.monorobot.json file, and Monorobot will detect the configuration change:&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  ...,&lt;br/&gt;  &amp;quot;prefix_rules&amp;quot;: {&lt;br/&gt;    &amp;quot;rules&amp;quot;: [&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;match&amp;quot;: [&lt;br/&gt;          &amp;quot;frontend/camelride_ui/&amp;quot;,&lt;br/&gt;          &amp;quot;backend/camelride/&amp;quot;&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;ignore&amp;quot;: [&lt;br/&gt;          &amp;quot;frontend/camelride_ui/images&amp;quot;,&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;channel&amp;quot;: &amp;quot;camelride&amp;quot;&lt;br/&gt;      },&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;match&amp;quot;: [&lt;br/&gt;          &amp;quot;backend/camelride/pricing/&amp;quot;&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;channel&amp;quot;: &amp;quot;camelride-pricing&amp;quot;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  }&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;Since Monorobot will match the rule with the longest matched prefix, only commits related to the price optimization aspect of Camel Ride will notify &lt;em&gt;#camelride-pricing&lt;/em&gt;, and all other general Camel Ride commits will notify &lt;em&gt;#camelride&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;There are additional configuration options for prefix rules (and for label rules discussed in the next section) that aren&amp;rsquo;t mentioned here. Visit the &lt;a href=&quot;https://github.com/ahrefs/monorobot&quot;&gt;repository&lt;/a&gt; for the full&amp;nbsp;details.&lt;/p&gt;&lt;h4&gt;Label-based routing for PRs and issue notifications&lt;/h4&gt;&lt;p&gt;For activity related to pull requests and issues (opening, closing, merging, commenting, and reviewing), Monorobot uses labels to determine routing. The format is largely the same as for path prefix&amp;nbsp;routing:&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  ...,&lt;br/&gt;  &amp;quot;label_rules&amp;quot;: {&lt;br/&gt;    &amp;quot;default_channel&amp;quot;: &amp;quot;notifications&amp;quot;,&lt;br/&gt;    &amp;quot;rules&amp;quot;: [&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;match&amp;quot;: [&lt;br/&gt;          &amp;quot;Camel Ride&amp;quot;&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;channel&amp;quot;: &amp;quot;camelride&amp;quot;&lt;br/&gt;      },&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;match&amp;quot;: [&lt;br/&gt;          &amp;quot;Price Optimization&amp;quot;&lt;br/&gt;        ],&lt;br/&gt;        &amp;quot;channel&amp;quot;: &amp;quot;camelride-pricing&amp;quot;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  }&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;Here, all PRs and issues with the &amp;ldquo;Camel Ride&amp;rdquo; label will have activity sent to &lt;em&gt;#camelride&lt;/em&gt;; those with the &amp;ldquo;Price Optimization&amp;rdquo; label to &lt;em&gt;#camelride-pricing&lt;/em&gt;; and those with both labels to both channels.&lt;/p&gt;&lt;p&gt;The default_channel field provides an option to fall back on a channel if no rule is matched; this option is available for prefix rules as&amp;nbsp;well.&lt;/p&gt;&lt;h4&gt;Status notifications&lt;/h4&gt;&lt;p&gt;Monorobot also supports build status notifications for CI pipelines. When it receives a status update for a pushed commit, it routes it to the relevant channel(s) by applying the prefix rules to the commit associated with the build. Further filtering based on status (e.g., ignoring canceled builds, and only notifying for a successful build when preceded by a failed one) is also possible.&lt;/p&gt;&lt;h4&gt;Link unfurling&lt;/h4&gt;&lt;p&gt;Finally, Monorobot can unfurl links to GitHub repositories shared on Slack (including private ones, if a personal access token is provided). This applies to commit, issue, and pull request&amp;nbsp;URLs.&lt;/p&gt;&lt;h3&gt;What&amp;rsquo;s next&lt;/h3&gt;&lt;p&gt;Monorobot is actively used at Ahrefs today, but there are lots of promising future directions it could take. Here, we list a&amp;nbsp;few.&lt;/p&gt;&lt;h4&gt;Unifying GitHub and Slack identities&lt;/h4&gt;&lt;p&gt;It would be useful to allow GitHub user IDs to be mapped to Slack ones. This would enable more personalized features for Monorobot, such as direct messaging a user when their review is requested or when a CI build fails on a feature branch they authored.&lt;/p&gt;&lt;h4&gt;Consolidating notifications&lt;/h4&gt;&lt;p&gt;Sometimes, a collection of multiple GitHub webhook events makes sense to be grouped and delivered as a single Slack notification. For example, pull request reviews generate discrete webhook events for each review comment, but it would make more sense to pool them together, so as not to spam a channel with many notifications.&lt;/p&gt;&lt;h4&gt;Better status notifications&lt;/h4&gt;&lt;p&gt;A CI build failure can have multiple potential causes:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;A bad&amp;nbsp;commit&lt;/li&gt;&lt;li&gt;A previous bad commit that has yet to be&amp;nbsp;fixed&lt;/li&gt;&lt;li&gt;An issue with the pipeline itself (this is out of scope for Monorobot)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;It can be quite tricky to discern between the first two causes from the GitHub webhook event alone. Cause 1 is handled well by our current approach of using path prefix routing on the commit associated with the build. But with cause 2, that same approach doesn&amp;rsquo;t always send the build failure notification to the channel where it is actually relevant. In that case, the originator of the initial bad commit won&amp;rsquo;t be nagged about all subsequent failures, and Slack channels with no relevance to the cause of failure will get polluted with unnecessary notifications.&lt;/p&gt;&lt;p&gt;How can we best determine whether a status notification is &amp;ldquo;relevant&amp;rdquo; to a Slack channel? This is still an open question, but one possible direction is to track build state per &lt;em&gt;build step&lt;/em&gt; rather than per &lt;em&gt;status&lt;/em&gt;, and route notifications based on that. For example, if an overall build fails due to a backend build step failure, then it could be sent to a channel where the frontend team won&amp;rsquo;t be notified.&lt;/p&gt;&lt;h3&gt;Wrapping up&lt;/h3&gt;&lt;p&gt;The overall goal of Monorobot is to make Slack notifications more &lt;em&gt;relevant&lt;/em&gt; for all teams in a large &lt;em&gt;monorepo environment&lt;/em&gt;, using the information available from GitHub webhook events. We&amp;rsquo;ve had fairly positive results with our own internal usage, and now we hope others find it useful as&amp;nbsp;well.&lt;/p&gt;&lt;p&gt;Monorobot is written in OCaml. &lt;a href=&quot;https://github.com/ahrefs/monorobot&quot;&gt;We welcome your feedback and contributions on&amp;nbsp;GitHub!&lt;/a&gt;&lt;/p&gt;&lt;p&gt;P.S. If anyone does make an actual ride sharing service for camels, do let us&amp;nbsp;know&amp;hellip;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thanks to Feihong, Igor, and Louis for feedback on this&amp;nbsp;post.&lt;/em&gt;&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=374260e2ca43&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/monorobot-a-slack-bot-for-monorepos-374260e2ca43&quot;&gt;Monorobot: a Slack bot for monorepos&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/monorobot-a-slack-bot-for-monorepos-374260e2ca43?source=rss----303662d88bae--ocaml</id><title type="text">Monorobot: a Slack bot for monorepos</title><updated>2021-12-09T15:19:04-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/building-ahrefs-codebase-with-melange-9f881f6d022b?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/1*tYLUO4FDmJ6bzlsPp14LdQ.jpeg&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@madebyjens?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Jens Lelie&lt;/a&gt; on&amp;nbsp;&lt;a href=&quot;https://unsplash.com/s/photos/fork-road?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;At Ahrefs, we have been using BuckleScript and ReasonML in production &lt;a href=&quot;https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b&quot;&gt;for more than two years&lt;/a&gt;. We already have a codebase of tens of thousands of lines of code, with several web applications that are data intensive and communicate with backend services written in &lt;a href=&quot;http://ocaml.org/&quot;&gt;OCaml&lt;/a&gt;, using tools like&amp;nbsp;&lt;a href=&quot;https://github.com/ahrefs/atd&quot;&gt;atd&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Given our investment in these technologies, we have been following closely the recent changes in &lt;a href=&quot;https://rescript-lang.org/&quot;&gt;ReScript&lt;/a&gt;, with its rebrand and renaming, and the split with the ReasonML project, explained in the project &lt;a href=&quot;https://rescript-lang.org/blog/bucklescript-is-rebranding&quot;&gt;blog&amp;nbsp;post&lt;/a&gt;.&lt;/p&gt;&lt;h3&gt;ReScript: becoming its own&amp;nbsp;language&lt;/h3&gt;&lt;p&gt;We are excited about the way ReScript is unifying the experience and making it easier for developers who are getting started to find documentation in a single place, as well as continuing its strong focus on performance and readable JavaScript output.&lt;/p&gt;&lt;p&gt;On the other hand, we are trying to figure out the implications of this change in the mid- and long-term, especially regarding the integration with the OCaml ecosystem. And more importantly, what this evolution will mean for production users like us who rely on this integration.&lt;/p&gt;&lt;p&gt;ReScript integration with OCaml has historically been seamless, as BuckleScript started originally as a &lt;a href=&quot;https://www.reddit.com/r/ocaml/comments/4enok3/bloombergbucklescript_a_back_end_for_the_ocaml/&quot;&gt;new backend for the OCaml compiler&lt;/a&gt;. However, in recent months, there have been several hints that ReScript wants to evolve towards becoming its own language:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;It has now &lt;a href=&quot;https://github.com/rescript-lang/syntax&quot;&gt;its own parser&lt;/a&gt;, incompatible with OCaml native applications&lt;/li&gt;&lt;li&gt;Official repository guidelines for technical writing mentions explicitly that &lt;a href=&quot;https://github.com/rescript-association/rescript-lang.org/blob/master/CONTRIBUTING.md#technical-writing-documentation&quot;&gt;no reference to OCaml&lt;/a&gt; should appear in&amp;nbsp;docs&lt;/li&gt;&lt;li&gt;Upgrades to the latest version of OCaml compiler, which &lt;a href=&quot;https://web.archive.org/web/20210208054855if_/https://github.com/rescript-lang/rescript-compiler/wiki&quot;&gt;used to be part of the roadmap&lt;/a&gt;, have been &lt;a href=&quot;https://forum.rescript-lang.org/t/some-thoughts-on-community-building/1474&quot;&gt;deprioritized&lt;/a&gt; recently.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;So, even if officially ReScript has not announced that they will break backwards compatibility with OCaml, just the fact that it is sticking with an old version of the OCaml compiler poses some challenges for us in terms of tooling. The uncertainty about the future and the pace of changes add some risk to the high-level goals we have for our teams and codebase: we would like to share &lt;em&gt;more&lt;/em&gt; code between frontend and backend, not&amp;nbsp;less.&lt;/p&gt;&lt;h3&gt;Melange: a fork of ReScript, focused on OCaml compatibility&lt;/h3&gt;&lt;p&gt;When Ant&amp;oacute;nio Monteiro &lt;a href=&quot;https://anmonteiro.com/2021/03/on-ocaml-and-the-js-platform/&quot;&gt;announced Melange&lt;/a&gt;, a fork of ReScript but with a strong focus on keeping compatibility with OCaml, we decided to try it out and see how it could work for&amp;nbsp;us.&lt;/p&gt;&lt;p&gt;Ultimately, the experiment was successful. We managed to build all our frontend applications with Melange, while keeping the existing bundling setup, which currently uses&amp;nbsp;Webpack.&lt;/p&gt;&lt;p&gt;Throughout this process, we had to modify some parts of the code. We will now go through the most relevant parts of the&amp;nbsp;process:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Upgrade to OCaml 4.12: the most relevant part was the deprecation of Pervasives module to use&amp;nbsp;Stdlib.&lt;/li&gt;&lt;li&gt;Use ppxlib in our ppxs: we had to upgrade the two ppxs that we use in the frontend codebase to the latest compiler version, &lt;a href=&quot;https://github.com/ahrefs/bs-emotion/compare/master...jchavarri:ocaml4.12-ppxlib&quot;&gt;bs-emotion-ppx&lt;/a&gt; and an in-house &lt;a href=&quot;https://github.com/ahrefs/bs-react-intl-ppx&quot;&gt;ppx for internationalization&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Configure esy: we were already using esy to bring the editor tooling into scope of the developer environment, so we just had to make sure melange would also be included in the json configuration.&lt;/li&gt;&lt;li&gt;Upgrade to Reason 3.7.0: a quite simple change too, as the whole process is automated by using refmt. As a side note, we ran into &lt;a href=&quot;https://github.com/reasonml/reason/issues/2636&quot;&gt;a small bug&lt;/a&gt; with some type annotations, that we were able to work&amp;nbsp;around.&lt;/li&gt;&lt;li&gt;&amp;ldquo;Lift&amp;rdquo; dune workspace to the root of our monorepo: this is probably the most intrusive change. Because we have shared code between backend and frontend, and Dune needs to have access to all sources under its workspace, we had to &amp;ldquo;lift&amp;rdquo; the Dune workspace from the backend directory to the root of monorepo.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;The good&lt;/h3&gt;&lt;p&gt;This experiment allowed us to experience what a project like Melange could offer for our use case. Here are some of the things we might be able to leverage in a codebase built with&amp;nbsp;Melange:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Recent version of the OCaml compiler: at some point, we could pin compiler version between backend and frontend teams, making upgrades more straightforward as they would happen atomically.&lt;/li&gt;&lt;li&gt;Shared editor tooling: the official OCaml &lt;a href=&quot;https://github.com/ocamllabs/vscode-ocaml-platform&quot;&gt;vscode extension&lt;/a&gt; works great with Melange, as well as any other OCaml editor integration. Having backend and frontend teams use similar editor setup removes a lot of maintenance work for&amp;nbsp;us.&lt;/li&gt;&lt;li&gt;Consuming ppxs from source: Melange allows to consume ppxs from source, which also removes issues with pre-compiled ppxs (like this issue with the recent &lt;a href=&quot;https://github.com/ahrefs/bs-emotion/issues/53&quot;&gt;M1&amp;nbsp;Macs&lt;/a&gt;).&lt;/li&gt;&lt;li&gt;Melange allows to run all ppxs &lt;a href=&quot;https://github.com/melange-re/melange/pull/171&quot;&gt;from a single executable file&lt;/a&gt;, which has some nice performance benefits.&lt;/li&gt;&lt;li&gt;Use Dune for atd files generators: ReScript &amp;ldquo;generators&amp;rdquo; are unfortunately &lt;a href=&quot;https://web.archive.org/web/20200710044513if_/https://reasonml.org/docs/reason-compiler/latest/build-advanced&quot;&gt;not documented anymore&lt;/a&gt;, but we use them extensively for atd file generation. Being able to share Dune rules in backend and frontend would make our build setup&amp;nbsp;easier.&lt;/li&gt;&lt;li&gt;Access to OCaml documentation tooling: Melange allows to leverage existing tooling for generating documentation, like&amp;nbsp;&lt;a href=&quot;https://github.com/ocaml/odoc/&quot;&gt;odoc&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Async syntax: the latest Reason version &lt;a href=&quot;https://github.com/reasonml/reason/pull/2487&quot;&gt;supports &amp;ldquo;let op&amp;rdquo; syntax&lt;/a&gt;, which is handy for client-side code.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;The bad&lt;/h3&gt;&lt;p&gt;While there are many things that are exciting about Melange, there are some other parts that can be improved.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Build performance: We already knew that performance would be far worse than ReScript, as Melange uses Dune in a way that it was not designed for. In our tests, builds with Melange are roughly 1 order of magnitude slower than ReScript&amp;nbsp;ones.&lt;/li&gt;&lt;li&gt;First-class Dune support: if there was a deeper integration between Dune and Melange, we could explore features like shared libraries or shared rules between backend and frontend. As of today, Dune has no knowledge about Melange environment, so it can perform basic rules execution, but there is no access to high level stanzas like library in&amp;nbsp;Melange.&lt;/li&gt;&lt;li&gt;Two-headed goal: finally, we see a more strategic risk in Melange proposition. Right now it has two goals: keep compatibility with both ReScript and OCaml. But we don&amp;rsquo;t know how long these goals will be feasible. If at some point ReScript decides to move away from the OCaml compiler fully, then Melange users would not be able to consume any updates to the ReScript ecosystem anymore.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Alright, but are you migrating to Melange or ReScript?&lt;/h3&gt;&lt;p&gt;With all the information available, the answer is: we don&amp;rsquo;t know yet. &amp;#128516; We want to keep exploring all the available options and have as much information as possible before committing further. So for now, we are upgrading the codebase to recent versions of ReScript, but we are holding up on features that only work one way. For example, we have not migrated our codebase to the ReScript syntax yet, as &lt;a href=&quot;https://github.com/rescript-lang/syntax/issues/405&quot;&gt;there is no way to translate back to Reason&amp;nbsp;syntax&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;In the meantime, we will keep exploring how far the limitations of Melange can be mitigated. To be continued! &amp;#128640;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thanks to Igor and Feihong for reviewing and improving earlier versions of this&amp;nbsp;post.&lt;/em&gt;&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=9f881f6d022b&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/building-ahrefs-codebase-with-melange-9f881f6d022b&quot;&gt;Building Ahrefs codebase with Melange&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/building-ahrefs-codebase-with-melange-9f881f6d022b?source=rss----303662d88bae--ocaml</id><title type="text">Building Ahrefs codebase with Melange</title><updated>2021-05-18T15:24:20-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;figure&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1024/1*Nl5vYk_k-mC4j32XEjryHQ.jpeg&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@willianjusten&quot;&gt;https://unsplash.com/@willianjusten&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;The first &lt;a href=&quot;https://reasonml.org/&quot;&gt;Reason&lt;/a&gt; application at &lt;a href=&quot;https://ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; went online on January 31, 2019. Since then, many more applications have been either rewritten in Reason, are being slowly migrated from React to ReasonReact, or are conceived from the start as Reason projects. It is safe to say that the bet placed on Reason paid off big time. We will never go back to doing pure JavaScript again, with the possible exception of simple backend&amp;nbsp;scripts.&lt;/p&gt;&lt;p&gt;In the past few years, it&amp;rsquo;s come to light that there are a number of other &lt;a href=&quot;https://www.messenger.com/&quot;&gt;large&lt;/a&gt; &lt;a href=&quot;https://www.onegraph.com/&quot;&gt;Reason&lt;/a&gt;/&lt;a href=&quot;https://darklang.com/&quot;&gt;BuckleScript&lt;/a&gt; &lt;a href=&quot;https://onivim.io/&quot;&gt;codebases&lt;/a&gt; in the wild, but there still isn&amp;rsquo;t a ton of information out there about what it&amp;rsquo;s really like to work with Reason in production. To help remedy that, we thought it would be instructive to ask each of our frontend team members what their Reason journey has been like so&amp;nbsp;far.&lt;/p&gt;&lt;p&gt;We gave them the following questions as starting points (but they were free to talk about anything they&amp;nbsp;wanted):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;How does Reason compare to other languages you&amp;rsquo;ve used in the&amp;nbsp;past?&lt;/li&gt;&lt;li&gt;What&amp;rsquo;s your favorite thing about&amp;nbsp;Reason?&lt;/li&gt;&lt;li&gt;What&amp;rsquo;s your least favorite thing about&amp;nbsp;Reason?&lt;/li&gt;&lt;li&gt;How does ReasonReact compare to other frameworks you&amp;rsquo;ve&amp;nbsp;used?&lt;/li&gt;&lt;li&gt;Was it easy to pick up Reason? Why or why&amp;nbsp;not?&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Javi&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;How does Reason compare to other languages you&amp;rsquo;ve used in the&amp;nbsp;past?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In the past I worked with languages like Java, C, or less known like Pascal or Prolog. But the languages I&amp;rsquo;ve spent more time with are Objective-C and JavaScript. The main difference between all those languages and Reason is the exhaustiveness that you get from OCaml type checker. This is maybe awkward, but it feels like you stop coding alone and suddenly you have a sidekick always sitting next to you, that is helping you notice the things you forgot about, or found new code that is not consistent with code you or someone else wrote&amp;nbsp;before.&lt;/p&gt;&lt;p&gt;In a world that is moving towards remote work, where many of us spend hours every day coding physically far from our colleagues, it makes the experience much more delightful. Plus, it allows for teams working on different time zones to keep a healthier work-life balance, because there is less need to have synchronous communication than with more dynamic languages, as more assumptions and design decisions are &amp;ldquo;embedded&amp;rdquo; into the&amp;nbsp;code.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;What&amp;rsquo;s your favorite thing about&amp;nbsp;Reason?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Can I pick two things? It&amp;rsquo;s hard to choose only&amp;nbsp;one.&lt;/p&gt;&lt;p&gt;The first one is the exhaustiveness and quality of the type checker, as mentioned above. Sometimes it takes a bit longer to build a feature than what it would in other languages, until the types are figured out. But this is largely compensated by the confidence one has when shipping code to production, or diving into large refactors.&lt;/p&gt;&lt;p&gt;The second one is the speed of the BuckleScript build system, which is built on top of &lt;a href=&quot;https://ninja-build.org/&quot;&gt;ninja&lt;/a&gt;. I had never worked with such fast build system. As an example, we have recently started to use remote machines to develop at Ahrefs. In one of these machines that has 72 cores, BuckleScript takes roughly 3 seconds to clean build &lt;em&gt;all&lt;/em&gt; our Reason code: application, libs, decoders&amp;hellip; everything. Many tens of thousand lines of code! We thought there were something wrong, but we realized the compiler is just So Blazing&amp;nbsp;Fast&amp;trade;&amp;#65039;.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;What&amp;rsquo;s your least favorite thing about&amp;nbsp;Reason?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I guess we&amp;rsquo;re going through a necessary stage until things stabilize in the future, but there is a lot of fragmentation at the moment between &amp;ldquo;Reason native&amp;rdquo;, which tries to stay closer to OCaml, and &amp;ldquo;Reason web&amp;rdquo;, which has a goal to become friendlier for JavaScript developers.&lt;/p&gt;&lt;p&gt;I am excited to see what &lt;a href=&quot;https://reasonml.org/blog/bucklescript-8-1-new-syntax&quot;&gt;BuckleScript new syntax&lt;/a&gt; will lead to, but I would also love to see a &amp;ldquo;universal&amp;rdquo; solution that works for the main use cases out of the box, becoming sort of Rails for Ocaml or Reason. &lt;a href=&quot;https://github.com/oxidizing/sihl/&quot;&gt;sihl&lt;/a&gt; is a project that seems to go in that direction and looks very promising.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;How does ReasonReact compare to other frameworks you&amp;rsquo;ve&amp;nbsp;used?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I consider ReasonReact mostly like React + types on top, because the bindings layer is very thin. The thing that I like most about React is that it follows the Unix philosophy: it does one thing and it does it really well. Maybe we have forgotten already today, but having to maintain and mutate UI based on data updates was one of the main sources of bugs in the past. The other nice thing is that there is so much good content about it: blog posts, documentation, etc.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Was it easy to pick up Reason? Why or why&amp;nbsp;not?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;It took some time, as with any other language. We have things like syntax or semantics much more ingrained into our brains than we think, so there is always some &amp;ldquo;rewiring&amp;rdquo; time that is needed to learn a new language, even if Reason makes an effort to stay close to JavaScript syntax. The most challenging part was probably the bindings one, because coming from JavaScript, there are no previous knowledge that one can use as foundation to build upon, it&amp;rsquo;s all &amp;ldquo;new knowledge&amp;rdquo;. glennsl &lt;a href=&quot;https://github.com/glennsl/bucklescript-ffi-cheatsheet&quot;&gt;BuckleScript ffi cheatsheet&lt;/a&gt; was a huge help for&amp;nbsp;me.&lt;/p&gt;&lt;h4&gt;Ze&lt;/h4&gt;&lt;p&gt;I really like working with Reason, and have wanted to do so for a while. I was quite happy to see that working with it matched my expectations.&lt;/p&gt;&lt;p&gt;You get so much support from the type system, and still have a lot of flexibility to represent your domain model. Coming from other languages or paradigms, you don&amp;rsquo;t feel limited at all in what you can&amp;nbsp;achieve.&lt;/p&gt;&lt;p&gt;The language has such a strong type system that you feel much more comfortable with your&amp;nbsp;coding.&lt;/p&gt;&lt;p&gt;The OCaml type system is there to make sure you code with assurance. This is especially true when refactoring code. You can be sure that everything will work fine after it compiles. If it compiles, it works&amp;nbsp;:)&lt;/p&gt;&lt;p&gt;It&amp;rsquo;s also very helpful when working on a monorepo. You don&amp;rsquo;t have to keep reading the source code of everything you use to make sure you don&amp;rsquo;t have types mistakes. Changes in code in one lib reflect immediately in all the others. This makes the feedback loop much shorter and&amp;nbsp;safer.&lt;/p&gt;&lt;p&gt;The editors integrations with the type system are quite good and help a lot to write code better and&amp;nbsp;faster.&lt;/p&gt;&lt;p&gt;Also, compilation times are super&amp;nbsp;fast.&lt;/p&gt;&lt;p&gt;Last, but not least, ReasonReact is, for me, the hidden gem of ReasonML. The newcomers that have some difficulty with the language should start with it. IMHO, ReasonReact is simpler and has a better developer experience than React itself. It should be the gateway drug frontend developers need to get started with Reason/OCaml &amp;#128516;&lt;/p&gt;&lt;h4&gt;Liubomyr&lt;/h4&gt;&lt;p&gt;To me, all those language features boil down to one essential thing, and it&amp;rsquo;s the easiness of refactoring. New business requirements popups all the time, and often your initial code assumptions are no longer correct. It was such a pain to modify code in a large JS codebase, as you never know how many things you potentially break in the process. With Reason, it has never been easier. If you need to change your data shape or some component API, you just do it, and from there, the compiler will guide you through all the places you broke, and help to fix&amp;nbsp;those.&lt;/p&gt;&lt;p&gt;Coming from the JS world, it feels like the initial development is slower, because of the learning curve, missing bindings, less StackOverflow answers, but in the end, you are getting a stable software which is way easier to maintain and add features&amp;nbsp;to.&lt;/p&gt;&lt;h4&gt;Egor&lt;/h4&gt;&lt;p&gt;I switched to Reason when I joined Ahrefs team about a year ago, before that I worked mostly with Ruby language.&lt;/p&gt;&lt;p&gt;The first thing that impressed me in ReasonML was code refactoring. Refactoring in language with a strong type system, like ReasonML and OCaml, is much easier than what I am used to. If your program compiles after your refactoring&amp;#8202;&amp;mdash;&amp;#8202;most likely you did everything right, if it doesn&amp;rsquo;t compile&amp;#8202;&amp;mdash;&amp;#8202;you can immediately see what you forgot to change. This can be achieved in languages with a dynamic type system only with a huge amount of code tests (supporting big test suite is a time consuming process as well as code support).&lt;/p&gt;&lt;p&gt;The other thing that I really like about ReasonML codebase&amp;#8202;&amp;mdash;&amp;#8202;how readable it is. When you just enter into ReasonML world&amp;#8202;&amp;mdash;&amp;#8202;some things can be unfriendly from the first sight, for example, immutable let bindings, but in the end, you realize that these language decisions help you to write cleaner and simpler&amp;nbsp;code.&lt;/p&gt;&lt;h4&gt;Seif&lt;/h4&gt;&lt;p&gt;The programming language I used the most in the past is JavaScript. I switched to Reason when I joined Ahrefs a few months ago. From the start, I worked mainly on the code shared by the majority of the tools and I don&amp;rsquo;t think I would have had the same confidence making changes if I was doing it with JavaScript. I love JavaScript&amp;rsquo;s developer experience and accessibility. Reason provided me predictability without hurting these very same things I like about JavaScript.&lt;/p&gt;&lt;h4&gt;Bryan&lt;/h4&gt;&lt;p&gt;Reason (and OCaml) is, by far, one of the easiest languages to work with. Easy in the sense that the compiler helps eliminate an entire class of errors so you don&amp;rsquo;t have to worry about them. Additionally, in most other web-centric languages, it&amp;rsquo;s a pain to add features to existing code that you&amp;rsquo;ve not touched for a long time. With strong static typing, I can usually add the feature I want in either the backend or frontend, and then let the compiler tell me what needs to be&amp;nbsp;updated.&lt;/p&gt;&lt;p&gt;Pattern-matching is one of my favourite features in Reason. To me, it makes more sense to be able to explicitly specify conditions that I&amp;rsquo;m interested in a clear and concise manner, and let the compiler tell me if I missed out a particular condition. Records go hand-in-hand with this. As software programs are made up of data and instructions, records are the perfect data containers. They are quick to define and query, focusing on data rather than behaviour (think classes and instance methods).&lt;/p&gt;&lt;p&gt;It definitely took a while to pick up Reason mainly because it takes time to become familiar with idiomatic OCaml. But once I crested that learning curve, everything just made sense and all the features of the language that made Reason seemingly difficult to learn&amp;#8202;&amp;mdash;&amp;#8202;strong typing, the functional paradigm, etc, became assistants that helped me to write better&amp;nbsp;code.&lt;/p&gt;&lt;h4&gt;Feihong&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://reasonml.github.io/reason-react/en/&quot;&gt;ReasonReact&lt;/a&gt; is a great library for making complex UIs in a large codebase because you get the familiarity of React coupled with the type safety of OCaml. Having two well-established technologies in its foundation is a big advantage that ReasonReact has over other functional UI libraries/frameworks in the transpile-to-JS universe. I didn&amp;rsquo;t have any professional OCaml experience before joining, yet the ramp up was made much easier by my existing knowledge of React and the (somewhat superficial) similarity of the Reason syntax to JS. Oftentimes it was possible to correctly guess the intent of existing Reason code without knowing all the syntax, because most React concepts carry over pretty directly. And even though the documentation is incomplete and not perfect, it&amp;rsquo;s quite usable already and among conceptually-similar frameworks is second only to the Elm documentation.&lt;/p&gt;&lt;p&gt;The compiler errors were difficult to get used to at first. The compiler is fairly good at pointing out the location of the error, but not necessarily as good at explaining the nature or cause of the error. As such, having a REPL would be extremely useful. Actually, OCaml does have its own REPL, but BuckleScript (the compiler used by Reason to translate OCaml to JS) does not at the moment. Nonetheless, the &lt;a href=&quot;https://reasonml.github.io/en/try&quot;&gt;Try Reason&lt;/a&gt; page is a really good tool to try out small snippets of code and is extremely useful while learning the language (we will still occasionally post Try Reason links in our slack channel).&lt;/p&gt;&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;The reality is that Ahrefs has always been an OCaml shop, but in the past OCaml was only used to build the backend. Now that we are also using it on the frontend, we get the benefits that our backend colleagues have enjoyed for many years: the expressiveness afforded by pattern matching, the ease of refactoring in large codebases, the stability of a mature programming language, and the confidence of &amp;ldquo;if it compiles, it works&amp;rdquo;. To make a shoddy nautical analogy, it is as if we had built a wooden ship powered by a turbo engine. But now the wooden parts are being replaced with steel and plastic, bringing the exterior of the ship up to modern standards as well. As a result, the ship runs faster and more reliably, making the passengers (our users) more satisfied. Also, pirates (bugs) have a harder time hijacking the ship because it&amp;rsquo;s sturdier and defended by well-disciplined camels. Because the ship keeps getting more and more passengers who want to experience a delightful ride and take pictures with enigmatic camels, we require a constant influx of willing and able boat engineers (who aren&amp;rsquo;t allergic to camels) to extend and maintain the ship. (Yes, that means that &lt;a href=&quot;https://ahrefs.com/jobs&quot;&gt;we are hiring&lt;/a&gt;&amp;#65039;.)&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thanks to Raman and Louis for fact checking this&amp;nbsp;post.&lt;/em&gt;&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=2250cf5ba63b&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b&quot;&gt;One and a half years of ReasonML in production&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b?source=rss----303662d88bae--ocaml</id><title type="text">One and a half years of ReasonML in production</title><updated>2020-07-26T15:19:31-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/how-to-write-a-library-for-bucklescript-and-native-22f45e5e946d?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;p&gt;&lt;em&gt;Written with &lt;/em&gt;&lt;a href=&quot;https://twitter.com/javierwchavarri&quot;&gt;&lt;em&gt;Javier Ch&amp;aacute;varri&lt;/em&gt;&lt;/a&gt;&lt;em&gt; and &lt;/em&gt;&lt;a href=&quot;https://github.com/feihong/&quot;&gt;&lt;em&gt;Feihong&amp;nbsp;Hsu&lt;/em&gt;&lt;/a&gt;&lt;em&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;The first &lt;a href=&quot;https://www.reason-conf.us/&quot;&gt;Reason Conf US&lt;/a&gt; just ended. Many talks mentioned native compilation. Sharing code between BuckleScript and native artifacts is a use case which is more and more common. This blog post is an introduction on how to set up a library available for both worlds, sharing as much code as possible.&lt;/p&gt;&lt;h3&gt;The goal&lt;/h3&gt;&lt;p&gt;What we try to produce is a library with an identical interface for BuckleScript and native. But without duplicating code. It should also be possible to have some parts of the library that are a different implementation depending on the target, as we want to be able to leverage existing libraries that are working only in one of the&amp;nbsp;worlds.&lt;/p&gt;&lt;h3&gt;The build&amp;nbsp;systems&lt;/h3&gt;&lt;p&gt;For BuckleScript, there is only one build system: bsb. It is driven by a bsconfig.json file. And is installed as part of the bs-platform.&lt;/p&gt;&lt;p&gt;On the native side, there are a lot of different build systems that are available. But recently one of them became a de facto standard: dune. It works with a very minimal amount of configuration. And it supports the reason syntax by&amp;nbsp;default.&lt;/p&gt;&lt;p&gt;These two tools are working in a way which is pretty similar. They share a lot of concepts. And it is easy to set them up so that both are working in the same codebase.&lt;/p&gt;&lt;p&gt;The main similarities that interest us&amp;nbsp;are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The ability to work on specific source directories&lt;/li&gt;&lt;li&gt;Namespacing in bsb and wrapping in dune are both putting all the&lt;br/&gt;files of the library under a single module&amp;nbsp;name&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;The source code file&amp;nbsp;tree&lt;/h3&gt;&lt;p&gt;The code of the library is split into 3 directories.&lt;/p&gt;&lt;pre&gt;&amp;#9500;&amp;#9472;&amp;#9472; js/&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; native/&lt;br/&gt;&amp;#9492;&amp;#9472;&amp;#9472; shared/&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;shared is meant to host most of the code and all the code in this directory will be compiled in both&amp;nbsp;modes.&lt;/li&gt;&lt;li&gt;js contains the parts that are specific to BuckleScript.&lt;/li&gt;&lt;li&gt;native contains the parts that are specific to native&amp;nbsp;OCaml.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Set up the build&amp;nbsp;systems&lt;/h3&gt;&lt;p&gt;Once we have our basic skeleton for the library, it is time to set up the build systems. We want to have two configurations as similar as possible to make them easier to understand. Once we are done, the tree will look like&amp;nbsp;this:&lt;/p&gt;&lt;pre&gt;&amp;#9500;&amp;#9472;&amp;#9472; bsconfig.json&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; dune&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; dune-project&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; js/&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; native/&lt;br/&gt;&amp;#9492;&amp;#9472;&amp;#9472; shared/&lt;/pre&gt;&lt;h4&gt;BuckleScript&lt;/h4&gt;&lt;p&gt;At the root of the library we need a bsconfig.json file to drive&lt;br/&gt;bsb. The documentation is available at &lt;a href=&quot;https://bucklescript.github.io/docs/en/build-configuration%5D(https://bucklescript.github.io/docs/en/build-configuration).&quot;&gt;https://bucklescript.github.io/docs/en/build-configuration&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The main part for us is sources. We will use it to tell bsb to look at the js and shared folders. We also want to set namespace to true, which will wrap all your project&amp;rsquo;s files under a common module&amp;nbsp;name.&lt;/p&gt;&lt;pre&gt;  &amp;quot;namespace&amp;quot;: true,&lt;br/&gt;  &amp;quot;sources&amp;quot;: [&lt;br/&gt;    {&lt;br/&gt;      &amp;quot;dir&amp;quot;: &amp;quot;js&amp;quot;,&lt;br/&gt;      &amp;quot;subdirs&amp;quot;: true&lt;br/&gt;    }, {&lt;br/&gt;      &amp;quot;dir&amp;quot;: &amp;quot;shared&amp;quot;,&lt;br/&gt;      &amp;quot;subdirs&amp;quot;: true&lt;br/&gt;    }&lt;br/&gt;  ],&lt;/pre&gt;&lt;p&gt;The rest of the file is as&amp;nbsp;usual.&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  &amp;quot;name&amp;quot;: &amp;quot;sharedlib&amp;quot;,&lt;br/&gt;  &amp;quot;namespace&amp;quot;: true,&lt;br/&gt;  &amp;quot;sources&amp;quot;: [&lt;br/&gt;    {&lt;br/&gt;      &amp;quot;dir&amp;quot;: &amp;quot;js&amp;quot;,&lt;br/&gt;      &amp;quot;subdirs&amp;quot;: true&lt;br/&gt;    }, {&lt;br/&gt;      &amp;quot;dir&amp;quot;: &amp;quot;shared&amp;quot;,&lt;br/&gt;      &amp;quot;subdirs&amp;quot;: true&lt;br/&gt;    }&lt;br/&gt;  ],&lt;br/&gt;  &amp;quot;package-specs&amp;quot;: {&lt;br/&gt;    &amp;quot;module&amp;quot;: &amp;quot;es6&amp;quot;,&lt;br/&gt;    &amp;quot;in-source&amp;quot;: true&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;refmt&amp;quot;: 3,&lt;br/&gt;  &amp;quot;suffix&amp;quot;: &amp;quot;.bs.js&amp;quot;,&lt;br/&gt;  &amp;quot;generate-merlin&amp;quot;: true,&lt;br/&gt;}&lt;/pre&gt;&lt;h4&gt;Dune&lt;/h4&gt;&lt;p&gt;We must also add a dune file to the root of the library. For dune, we have different options&amp;#8202;&amp;mdash;&amp;#8202;it is possible to ignore the js directory but read everything else. Or to check only shared and native. To make the configuration similar to BuckleScript, we will go with the second solution.&lt;/p&gt;&lt;p&gt;The dune directive to do that is dirs. By defaults it tells dune to explore every directory except the ones hidden (starting with a dot) or starting with an underscore. &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#dirs-since-1-6&quot;&gt;More details in dune&amp;rsquo;s documentation&lt;/a&gt;. To make it do what we want, the configuration should&amp;nbsp;be:&lt;/p&gt;&lt;pre&gt;(dirs shared native)&lt;/pre&gt;&lt;p&gt;We also use another option of dune to tell it to include the content of those two directories as if it was at the root of the project. Without this stanza, dune would only use the source files at the root of the project and ignore everything in the sub directories.&lt;/p&gt;&lt;pre&gt;(include_subdirs unqualified)&lt;/pre&gt;&lt;p&gt;Then we need the usual library stanza to give a name to our library, state the dependencies, compilation flags, etc. In our simple case, the only information needed is the name. We can explicitly set wrapped to true, but this is already the default behavior. The &lt;a href=&quot;https://dune.readthedocs.io/en/stable/dune-files.html#library&quot;&gt;documentation for the whole library stanza&lt;/a&gt; describes how to specify more&amp;nbsp;details.&lt;/p&gt;&lt;p&gt;The final dune file looks like&amp;nbsp;this:&lt;/p&gt;&lt;pre&gt;(dirs shared native)&lt;br/&gt; (include_subdirs unqualified)&lt;br/&gt; (library&lt;br/&gt;  (name sharedlib))&lt;/pre&gt;&lt;p&gt;We also want a basic dune-project. If we don&amp;rsquo;t write it by hand, dune will generate it for us. I am using version 1.10 as an example. But it can be changed to whatever version suits your&amp;nbsp;project.&lt;/p&gt;&lt;pre&gt;(lang dune 1.10)&lt;/pre&gt;&lt;h3&gt;Compilation&lt;/h3&gt;&lt;p&gt;With the setup described above, the compilation for BuckleScript and native is the same as in a setup with only one or the&amp;nbsp;other.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;bsb -make-world for BuckleScript&lt;/li&gt;&lt;li&gt;dune build @all for&amp;nbsp;dune&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The call to bsb is usally put in package.json in the scripts part, so that the usual yarn build can be used. For native, it depends if you rely on esy or&amp;nbsp;opam.&lt;/p&gt;&lt;h3&gt;How to consume the&amp;nbsp;library&lt;/h3&gt;&lt;p&gt;This is exactly the same setup that would be used in a pure BuckleScript or pure native&amp;nbsp;library.&lt;/p&gt;&lt;p&gt;To use your library in BuckleScript:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Add the name and version to package.json&lt;/li&gt;&lt;li&gt;Add the name to bsbconfig.json of consuming library/app&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;To use your library in native OCaml, add the name of your library to the libraries part an executable or library stanza,&amp;nbsp;e.g.&lt;/p&gt;&lt;pre&gt;(executable&lt;br/&gt; (name main)&lt;br/&gt; (libraries sharedlib))&lt;/pre&gt;&lt;h3&gt;Module naming&lt;/h3&gt;&lt;p&gt;If you want your module name to contain capital letters in the middle (e.g. TeenageMutantNinjaTurtles), then be aware that &lt;a href=&quot;https://bucklescript.github.io/docs/en/build-configuration.html#name-namespace&quot;&gt;name munging&lt;/a&gt; works differently between bsbconfig.json and dune. For example, if you want to refer to your module as CoolSharedLib in your code, then the name in bsbconfig.json must be cool-shared-lib, and in dune it must be coolSharedLib.&lt;/p&gt;&lt;h3&gt;Platform specific&amp;nbsp;code&lt;/h3&gt;&lt;p&gt;The whole library does not have to be exactly the same in the two platform. It is possible to add modules that are available only in one mode. Or to have modules with a different interface.&lt;/p&gt;&lt;p&gt;For example, by adding a file Foo.re in js but not in native, the library now has a module Foo available when compiled to javascript. But only when compiled to javascript.&lt;/p&gt;&lt;h3&gt;Downsides&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Both bsb and dune generate&amp;nbsp;.merlin files when they compile our library. They override each other. It might be troublesome if the version of ocaml used for native code is not 4.02.3. Simply recompile the library for your platform to solve the&amp;nbsp;problem.&lt;/li&gt;&lt;li&gt;Out of the box, this approach doesn&amp;rsquo;t really allow us to share interface files between both platforms: native and BuckleScript. One workaround for that, if we wanted to share some module Foo, is to:&lt;br/&gt;1. add Foo.mli or Foo.rei file in shared&lt;br/&gt;2. add include FooImplementation in Foo.ml&lt;br/&gt;3. add FooImplementation in both native and js&amp;nbsp;folder&lt;/li&gt;&lt;li&gt;It&amp;rsquo;s not possible to be platform specific for just a few lines of code (e.g. if IS_NATIVE foo else bar), the minimal per-platform unit is a file/module.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Example project&lt;/h3&gt;&lt;p&gt;We have set up a simple library to showcase what a repository looks like once the whole configuration is in place. It is &lt;a href=&quot;https://github.com/ahrefs/hello-native-bucklescript&quot;&gt;available on&amp;nbsp;github&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;For now the repository contains only a library. But with this setup, it is actually possible to build an executable too. It is also possible to enrich it, for example by adding &lt;a href=&quot;https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081&quot;&gt;atdgen to communicate between both sides of the&amp;nbsp;library&lt;/a&gt;.&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=22f45e5e946d&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/how-to-write-a-library-for-bucklescript-and-native-22f45e5e946d&quot;&gt;How to write a library for BuckleScript and Native&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/how-to-write-a-library-for-bucklescript-and-native-22f45e5e946d?source=rss----303662d88bae--ocaml</id><title type="text">How to write a library for BuckleScript and Native</title><updated>2019-10-22T10:09:09-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/mjambon/atd&quot;&gt;atdgen&lt;/a&gt; is a project to create types and data structures that can be serialized to JSON. It is very convenient when communicating between multiple processes, creating a REST API or consuming JSON objects from other tools. It can be compared to &lt;a href=&quot;https://json-schema.org/&quot;&gt;JSON schema&lt;/a&gt; or &lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;Protocol Buffers&lt;/a&gt;, but with richer types and more features.&lt;/p&gt;&lt;p&gt;The idea is to write a list of types in a specification file, an&amp;nbsp;.atd file. Then running atdgen, it is possible to generate OCaml or Java code to serialize/deserialize values of those types to/from corresponding json.&lt;/p&gt;&lt;p&gt;Until very recently, atdgen could generate code only for native OCaml. But &lt;a href=&quot;https://github.com/mjambon/atd/pull/44&quot;&gt;the support of bucklescript has been merged&lt;/a&gt;! atdgen the cli tool is still a native OCaml binary. But it can output some OCaml code that can be compiled using &lt;a href=&quot;https://bucklescript.github.io/&quot;&gt;bucklescript&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The work to implement this new feature of atdgen has been funded by &lt;a href=&quot;https://ahrefs.com/&quot;&gt;Ahrefs&lt;/a&gt;. We highly appreciate open source tools. And as much as possible, we prefer to contribute to existing open source projects rather than to re-invent the wheel internally.&lt;/p&gt;&lt;h3&gt;Installation&lt;/h3&gt;&lt;p&gt;To install atdgen we first need to install &lt;a href=&quot;https://opam.ocaml.org&quot;&gt;opam&lt;/a&gt; (OCaml package manager), as atdgen doesn&amp;rsquo;t provide ready to use binaries and is only distributed as source package via opam. The procedure is simple and documented here: &lt;a href=&quot;https://opam.ocaml.org/doc/2.0/Install.html&quot;&gt;https://opam.ocaml.org/doc/2.0/Install.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Then we need to initialize opam and create a switch. Any version of ocaml greater or equal to 4.03.0 should be&amp;nbsp;fine.&lt;/p&gt;&lt;pre&gt;opam init -a&lt;br/&gt;opam switch create . 4.07.1 -y&lt;/pre&gt;&lt;p&gt;Once it is done, we have to install the development version of atdgen. The support of bucklescript is not officially released.&lt;/p&gt;&lt;pre&gt;opam pin add atd --dev-repo   &lt;br/&gt;opam pin add atdgen --dev-repo&lt;/pre&gt;&lt;p&gt;Make sure that atdgen is available.&lt;/p&gt;&lt;pre&gt;$ which atdgen                 &lt;br/&gt;(current $PWD)/_opam/bin/atdgen&lt;/pre&gt;&lt;p&gt;Of course, we need bucklescript.&lt;/p&gt;&lt;pre&gt;yarn init                 &lt;br/&gt;yarn add bs-platform --dev&lt;/pre&gt;&lt;p&gt;We also need the bucklescript runtime for atdgen, as it is not currently provided by atdgen itself. So we have written and open-sourced our version of the runtime&amp;nbsp;: &lt;a href=&quot;https://github.com/ahrefs/bs-atdgen-codec-runtime&quot;&gt;https://github.com/ahrefs/bs-atdgen-codec-runtime&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This runtime is responsible for the conversion between JSON values and OCaml values. The JSON values are based on the standard &lt;a href=&quot;https://bucklescript.github.io/bucklescript/api/Js.Json.html#TYPEt&quot;&gt;Js.Json.t type&lt;/a&gt; provided by bucklescript to be sure that it is easy to interoperate with the rest of the ecosystem.&lt;/p&gt;&lt;p&gt;It is published on npm for easy integration in bucklescript projects.&lt;/p&gt;&lt;pre&gt;yarn add @ahrefs/bs-atdgen-codec-runtime&lt;/pre&gt;&lt;h3&gt;Project configuration&lt;/h3&gt;&lt;p&gt;After the previous section, package.json should be almost ready. We can add a few scripts to make it more convenient to compile the project. Here is how it should look once completed.&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  &amp;quot;name&amp;quot;: &amp;quot;demo-bs-atdgen&amp;quot;,&lt;br/&gt;  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,&lt;br/&gt;  &amp;quot;description&amp;quot;: &amp;quot;demo of atdgen with bucklescript&amp;quot;,&lt;br/&gt;  &amp;quot;scripts&amp;quot;: {&lt;br/&gt;    &amp;quot;clean&amp;quot;: &amp;quot;bsb -clean-world&amp;quot;,&lt;br/&gt;    &amp;quot;build&amp;quot;: &amp;quot;bsb -make-world&amp;quot;,&lt;br/&gt;    &amp;quot;watch&amp;quot;: &amp;quot;bsb -make-world -w&amp;quot;,&lt;br/&gt;    &amp;quot;atdgen&amp;quot;: &amp;quot;atdgen -t meetup.atd &amp;amp;&amp;amp; atdgen -bs meetup.atd&amp;quot;&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;devDependencies&amp;quot;: {&lt;br/&gt;    &amp;quot;bs-platform&amp;quot;: &amp;quot;^4.0.5&amp;quot;&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;peerDependencies&amp;quot;: {&lt;br/&gt;    &amp;quot;bs-platform&amp;quot;: &amp;quot;^4.0.5&amp;quot;&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;dependencies&amp;quot;: {&lt;br/&gt;    &amp;quot;&lt;a href=&quot;http://twitter.com/ahrefs/bs-atdgen-codec-runtime&quot;&gt;@ahrefs/bs-atdgen-codec-runtime&lt;/a&gt;&amp;quot;: &amp;quot;^1.0.4&amp;quot;&lt;br/&gt;  }&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;The bucklescript configuration is very simple. We use the basic configuration that can be found in any bucklescript project. Except that we need to add one dependency to bsconfig.json:&lt;/p&gt;&lt;pre&gt;{&lt;br/&gt;  &amp;quot;name&amp;quot;: &amp;quot;demo-bs-atdgen&amp;quot;,&lt;br/&gt;  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,&lt;br/&gt;  &amp;quot;sources&amp;quot;: {&lt;br/&gt;    &amp;quot;dir&amp;quot;: &amp;quot;src&amp;quot;,&lt;br/&gt;    &amp;quot;subdirs&amp;quot;: true&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;package-specs&amp;quot;: {&lt;br/&gt;    &amp;quot;module&amp;quot;: &amp;quot;commonjs&amp;quot;,&lt;br/&gt;    &amp;quot;in-source&amp;quot;: true&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;suffix&amp;quot;: &amp;quot;.bs.js&amp;quot;,&lt;br/&gt;  &amp;quot;bs-dependencies&amp;quot;: [&lt;br/&gt;    &amp;quot;&lt;a href=&quot;http://twitter.com/ahrefs/bs-atdgen-codec-runtime&quot;&gt;@ahrefs/bs-atdgen-codec-runtime&lt;/a&gt;&amp;quot;&lt;br/&gt;  ],&lt;br/&gt;  &amp;quot;warnings&amp;quot;: {&lt;br/&gt;    &amp;quot;error&amp;quot;: &amp;quot;+101&amp;quot;&lt;br/&gt;  },&lt;br/&gt;  &amp;quot;generate-merlin&amp;quot;: true,&lt;br/&gt;  &amp;quot;namespace&amp;quot;: true,&lt;br/&gt;  &amp;quot;refmt&amp;quot;: 3&lt;br/&gt;}&lt;/pre&gt;&lt;h3&gt;First ATD definitions&lt;/h3&gt;&lt;p&gt;It is time to create a first&amp;nbsp;.atd file, containing our types. This part is also documented on &lt;a href=&quot;https://atd.readthedocs.io/en/latest/tutorial.html#getting-started&quot;&gt;https://atd.readthedocs.io/en/latest/tutorial.html#getting-started&lt;/a&gt;&lt;/p&gt;&lt;p&gt;For this example, I decided to go with a meetup event. Put the type definitions in src/meetup.atd.&lt;/p&gt;&lt;pre&gt;(* This is a comment. Same syntax as in ocaml. *)&lt;/pre&gt;&lt;pre&gt;type access = [ Private | Public ]&lt;/pre&gt;&lt;pre&gt;(* the date will be a float in the json and a Js.Date.t in ocaml *)&lt;br/&gt;type date = float wrap &amp;lt;ocaml module=&amp;quot;Js.Date&amp;quot; wrap=&amp;quot;Js.Date.fromFloat&amp;quot; unwrap=&amp;quot;Js.Date.valueOf&amp;quot;&amp;gt;&lt;/pre&gt;&lt;pre&gt;(* Some people don't want to provide a phone number, make it optional *)&lt;br/&gt;type person = {&lt;br/&gt;  name: string;&lt;br/&gt;  email: string;&lt;br/&gt;  ?phone: string nullable;&lt;br/&gt;}&lt;/pre&gt;&lt;pre&gt;type event = {&lt;br/&gt;  access: access;&lt;br/&gt;  name: string;&lt;br/&gt;  host: person;&lt;br/&gt;  date: date;&lt;br/&gt;  guests: person list;&lt;br/&gt;}&lt;/pre&gt;&lt;pre&gt;type events = event list&lt;/pre&gt;&lt;p&gt;We use the atdgen binary (compiled previously) to generate the ocaml types and the code to serialize/deserialize those&amp;nbsp;types.&lt;/p&gt;&lt;pre&gt;atdgen -t meetup.atd # generates an ocaml file containing the types&lt;br/&gt;atdgen -bs meetup.atd # generates the code to (de)serialize&lt;/pre&gt;&lt;p&gt;The generated files&amp;nbsp;are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;meetup_t.ml(i) which contain the ocaml types corresponding to our ATD definitions.&lt;/li&gt;&lt;li&gt;meetup_bs.ml(i) which contain the ocaml code to transform from and to json&amp;nbsp;values.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;At this point we can compile our&amp;nbsp;project.&lt;/p&gt;&lt;pre&gt;yarn build&lt;/pre&gt;&lt;p&gt;If everything worked properly, we now have two&amp;nbsp;.bs.js files in the src directory.&lt;/p&gt;&lt;pre&gt;$ tree src&lt;br/&gt;src&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup.atd&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup_bs.bs.js&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup_bs.ml&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup_bs.mli&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup_t.bs.js&lt;br/&gt;&amp;#9500;&amp;#9472;&amp;#9472; meetup_t.ml&lt;br/&gt;&amp;#9492;&amp;#9472;&amp;#9472; meetup_t.mli&lt;/pre&gt;&lt;pre&gt;0 directories, 7 files&lt;/pre&gt;&lt;p&gt;At this point, we can create new OCaml/Reason files in the src directory and use all the code atdgen generated for us. Two examples to illustrate that.&lt;/p&gt;&lt;h3&gt;Query a REST&amp;nbsp;API&lt;/h3&gt;&lt;p&gt;A common usage of atdgen is to decode the JSON returned by a REST API. Here is a short example, using the reason syntax and bs-fetch.&lt;/p&gt;&lt;pre&gt;let get = (url, decode) =&amp;gt;&lt;br/&gt;  Js.Promise.(&lt;br/&gt;    Fetch.fetchWithInit(&lt;br/&gt;      url,&lt;br/&gt;      Fetch.RequestInit.make(~method_=Get, ()),&lt;br/&gt;    )&lt;br/&gt;    |&amp;gt; then_(Fetch.Response.json)&lt;br/&gt;    |&amp;gt; then_(json =&amp;gt; json |&amp;gt; decode |&amp;gt; resolve)&lt;br/&gt;  );&lt;/pre&gt;&lt;pre&gt;let v: Meetup_t.events =&lt;br/&gt;  get(&lt;br/&gt;    &amp;quot;&lt;a href=&quot;http://localhost:8000/events&quot;&gt;http://localhost:8000/events&lt;/a&gt;&amp;quot;,&lt;br/&gt;    Atdgen_codec_runtime.Decode.decode(Meetup_bs.read_events),&lt;br/&gt;  );&lt;/pre&gt;&lt;h3&gt;Read and write a JSON&amp;nbsp;file&lt;/h3&gt;&lt;p&gt;Atdgen for bucklescript doesn&amp;rsquo;t take care of converting a string to a JSON object. Which allows us to use the performant json parser included in nodejs or the&amp;nbsp;browser.&lt;/p&gt;&lt;pre&gt;let read_events filename =&lt;br/&gt;  (* Read and parse the json file from disk, this doesn't involve atdgen. *)&lt;br/&gt;  let json =&lt;br/&gt;    Node_fs.readFileAsUtf8Sync filename&lt;br/&gt;    |&amp;gt; Js.Json.parseExn&lt;br/&gt;  in&lt;br/&gt;  (* Turn it into a proper record. The annotation is of course optional. *)&lt;br/&gt;  let events: Meetup_t.events =&lt;br/&gt;    Atdgen_codec_runtime.Decode.decode Meetup_bs.read_events json&lt;br/&gt;  in&lt;br/&gt;  events&lt;/pre&gt;&lt;p&gt;The reverse operation, converting a record to a JSON object and writing it in a file is also straightforward.&lt;/p&gt;&lt;pre&gt;let write_events filename events =&lt;br/&gt;  Atdgen_codec_runtime.Encode.encode Meetup_bs.write_events events (* turn a list of records into json *)&lt;br/&gt;  |. Js.Json.stringifyWithSpace 2   (* convert the json to a pretty string *)&lt;br/&gt;  |&amp;gt; Node_fs.writeFileAsUtf8Sync filename  (* write the json in our file *)&lt;/pre&gt;&lt;h3&gt;Full example&lt;/h3&gt;&lt;p&gt;Now that we have our functions to read and write events, we can build a small cli to pretty print the list of events and add new&amp;nbsp;events.&lt;/p&gt;&lt;p&gt;The source code of the full example is available &lt;a href=&quot;https://github.com/ahrefs/bs-atdgen-codec-runtime/tree/master/example&quot;&gt;on&amp;nbsp;github&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;You can run it like&amp;nbsp;this:&lt;/p&gt;&lt;pre&gt;$ echo &amp;quot;[]&amp;quot; &amp;gt; events.json&lt;br/&gt;$ nodejs src/cli.bs.js add louis &lt;a href=&quot;mailto:louis@nospam.com&quot;&gt;louis@nospam.com&lt;/a&gt;&lt;br/&gt;$ nodejs src/cli.bs.js add bob &lt;a href=&quot;mailto:bob@nospam.com&quot;&gt;bob@nospam.com&lt;/a&gt;&lt;br/&gt;$ nodejs src/cli.bs.js print&lt;br/&gt;=== OCaml/Reason Meetup! summary ===&lt;br/&gt;date: Tue, 11 Sep 2018 15:04:16 GMT&lt;br/&gt;access: public&lt;br/&gt;host: bob &amp;lt;&lt;a href=&quot;mailto:bob@nospam.com&quot;&gt;bob@nospam.com&lt;/a&gt;&amp;gt;&lt;br/&gt;guests: 1&lt;br/&gt;=== OCaml/Reason Meetup! summary ===&lt;br/&gt;date: Tue, 11 Sep 2018 15:04:13 GMT&lt;br/&gt;access: public&lt;br/&gt;host: louis &amp;lt;&lt;a href=&quot;mailto:louis@nospam.com&quot;&gt;louis@nospam.com&lt;/a&gt;&amp;gt;&lt;br/&gt;guests: 1&lt;br/&gt;$ cat events.json&lt;br/&gt;[&lt;br/&gt;  {&lt;br/&gt;    &amp;quot;guests&amp;quot;: [&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;email&amp;quot;: &amp;quot;&lt;a href=&quot;mailto:bob@nospam.com&quot;&gt;bob@nospam.com&lt;/a&gt;&amp;quot;,&lt;br/&gt;        &amp;quot;name&amp;quot;: &amp;quot;bob&amp;quot;&lt;br/&gt;      }&lt;br/&gt;    ],&lt;br/&gt;    &amp;quot;date&amp;quot;: 1536678256177,&lt;br/&gt;    &amp;quot;host&amp;quot;: {&lt;br/&gt;      &amp;quot;email&amp;quot;: &amp;quot;&lt;a href=&quot;mailto:bob@nospam.com&quot;&gt;bob@nospam.com&lt;/a&gt;&amp;quot;,&lt;br/&gt;      &amp;quot;name&amp;quot;: &amp;quot;bob&amp;quot;&lt;br/&gt;    },&lt;br/&gt;    &amp;quot;name&amp;quot;: &amp;quot;OCaml/Reason Meetup!&amp;quot;,&lt;br/&gt;    &amp;quot;access&amp;quot;: &amp;quot;Public&amp;quot;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &amp;quot;guests&amp;quot;: [&lt;br/&gt;      {&lt;br/&gt;        &amp;quot;email&amp;quot;: &amp;quot;&lt;a href=&quot;mailto:louis@nospam.com&quot;&gt;louis@nospam.com&lt;/a&gt;&amp;quot;,&lt;br/&gt;        &amp;quot;name&amp;quot;: &amp;quot;louis&amp;quot;&lt;br/&gt;      }&lt;br/&gt;    ],&lt;br/&gt;    &amp;quot;date&amp;quot;: 1536678253790,&lt;br/&gt;    &amp;quot;host&amp;quot;: {&lt;br/&gt;      &amp;quot;email&amp;quot;: &amp;quot;&lt;a href=&quot;mailto:louis@nospam.com&quot;&gt;louis@nospam.com&lt;/a&gt;&amp;quot;,&lt;br/&gt;      &amp;quot;name&amp;quot;: &amp;quot;louis&amp;quot;&lt;br/&gt;    },&lt;br/&gt;    &amp;quot;name&amp;quot;: &amp;quot;OCaml/Reason Meetup!&amp;quot;,&lt;br/&gt;    &amp;quot;access&amp;quot;: &amp;quot;Public&amp;quot;&lt;br/&gt;  }&lt;br/&gt;]&lt;/pre&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=1f3a14004081&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081&quot;&gt;Getting started with atdgen and bucklescript&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/getting-started-with-atdgen-and-bucklescript-1f3a14004081?source=rss----303662d88bae--ocaml</id><title type="text">Getting started with atdgen and bucklescript</title><updated>2018-09-12T02:53:58-00:00</updated><author><name>ahrefs</name></author></entry><entry><link href="https://tech.ahrefs.com/skylake-bug-a-detective-story-ab1ad2beddcd?source=rss----303662d88bae--ocaml" rel="alternate"/><contributor><uri>https://medium.com/feed/ahrefs/tagged/ocaml</uri><name>ahrefs</name></contributor><content type="html">&lt;blockquote&gt;It was a dark and stormy night; the skylake CPU buzzed with excitement, and then, suddenly, the hyperthreads started to lock&amp;nbsp;up..&lt;/blockquote&gt;&lt;p&gt;Or something like&amp;nbsp;that.&lt;/p&gt;&lt;p&gt;This week a new erratum for the Intel Skylake and Kabylake processors families was brought to public attention on &lt;a href=&quot;https://lists.debian.org/debian-devel/2017/06/msg00308.html&quot;&gt;the Debian mailing list&lt;/a&gt;, and then on &lt;a href=&quot;https://news.ycombinator.com/item?id=14630183&quot;&gt;various&lt;/a&gt; &lt;a href=&quot;https://www.reddit.com/r/programming/comments/6jfgfp/warning_intel_skylakekaby_lake_processors_broken/&quot;&gt;social media&lt;/a&gt; and &lt;a href=&quot;http://www.theregister.co.uk/2017/06/25/intel_skylake_kaby_lake_hyperthreading/&quot;&gt;news&amp;nbsp;outlets&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;We have been investigating this issue since January with the core &lt;a href=&quot;http://ocaml.org&quot;&gt;OCaml&lt;/a&gt; team, as we were struggling with a mysterious bug affecting our developers machines, and ultimately our production system, resulting in a corruption of important data in our databases.&lt;/p&gt;&lt;p&gt;At &lt;a href=&quot;https://ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt;, we operate a fleet of thousands of servers, running a wide variety of services (huge web crawler among others). At this scale, dealing with unexpected application behaviors is common. While we try to reduce the probability of the software not functioning as expected, bugs are sadly a real part of our everyday life. Even though we can assume the underlying hardware running any infrastructure can be thought of as more reliable and less prone to bugs than software components, issues can still arise in unexpected ways. When the number of servers increases, it is not unusual to observe faults in the hardware preventing the system from functioning as specified.&lt;/p&gt;&lt;p&gt;It is certainly not frequent to encounter such problems in CPUs but reading through &lt;a href=&quot;https://www3.intel.com/content/dam/www/public/us/en/documents/specification-updates/desktop-6th-gen-core-family-spec-update.pdf&quot;&gt;the list of errata published by any manufacturer,&lt;/a&gt; each CPU model contains a fair amount of bugs. This story is about the bug in the microcode of Skylake processor leading to incorrect code execution under certain conditions. This is certainly scary at first sight: how can we trust our system if we cannot trust its main component&amp;nbsp;? Yet, like software bugs, processor defects can be identified, contained, and we can take actions to prevent them from impacting the operation of the infrastructure.&lt;/p&gt;&lt;p&gt;We do not know the full implications of this particular bug, especially security implications in case of untrusted code execution. But we&amp;rsquo;d like to tell the story of this erratum from our point of view, to provide some context, and show that dealing with it was not much different than dealing with any usual software flaw. While this post aims to cover our own perspective on this adventure, we would like to thank Mark Shinwell, Xavier Leroy, Fr&amp;eacute;d&amp;eacute;ric Bour, everyone involved in the &lt;a href=&quot;https://caml.inria.fr/mantis/view.php?id=7452&quot;&gt;Mantis issue&lt;/a&gt; and the OCaml IRC channel for their help and time spent investigating with us. Update: Xavier Leroy told his own side of the story in another &lt;a href=&quot;http://gallium.inria.fr/blog/intel-skylake-bug/&quot;&gt;blog&amp;nbsp;post.&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Setting the&amp;nbsp;scene&lt;/h3&gt;&lt;p&gt;Our story starts in late 2016 after some of our backend developers received new laptops to work on. After a few days Enguerrand Decorne noticed unusual crashes during compilation of our OCaml codebase.&lt;/p&gt;&lt;p&gt;This issue, considered mildly annoying at first, seemed to affect only Enguerrand&amp;rsquo;s machine. For a few days no other machine would exhibit the same behavior, so we figured this was a fault specific to his system configuration.&lt;/p&gt;&lt;p&gt;However, concerns were subsequently raised after witnessing the generation of invalid machine code and later on, after the deployment of a service on one of our new clusters composed of Skylake Xeon processors, leading to the insertion of corrupted data into our storage system. The priority raised from the annoying level, to potentially critical. Other developers started working together to obtain more information and assess the impact on our infrastructure. Soon after we were able to reproduce the issue on several machines.&lt;/p&gt;&lt;p&gt;The remainder of this post is a technical description of the steps taken to ensure that our systems were operating safely. It is intended to show that such low level CPU issues is not necessarily fatal&amp;#8202;&amp;mdash;&amp;#8202;in less than two weeks, with the great help of core OCaml developers, we identified the conditions of the crash and set up a workaround.&lt;/p&gt;&lt;h3&gt;Tracking down crashes in&amp;nbsp;OCaml&lt;/h3&gt;&lt;p&gt;Most of our backend code is written in &lt;a href=&quot;https://ocaml.org&quot;&gt;OCaml&lt;/a&gt;, a high level and expressive language supporting functional programming style (among others), which allows us to develop robust systems with ease, thanks to its strong type system and mature&amp;nbsp;legacy.&lt;/p&gt;&lt;p&gt;The compiler segfaults were definitely a surprise, since this shouldn&amp;rsquo;t happen for any program written in OCaml, as type system and other features (such as automatic bounds-checking) usually guard us from such errors. However, stack overflows can be possible sources of segfault (when a non-optimal recursion is running too deep), so our first intuition was to increase the stack size when running the compiler. This didn&amp;rsquo;t change anything, and the reported fault address wasn&amp;rsquo;t anywhere near the stack address&amp;nbsp;bound.&lt;/p&gt;&lt;p&gt;Before witnessing the crash on other machines, we suspected a failure in the virtualization software used by our two developers that were able to reproduce the crash, who use VMware as a part of their development workflow. We tried early on to switch to Virtualbox, but the migration proved itself fruitless as the crashes kept appearing. After a short while we began encountering the same issue on physical machines, so we ruled out a possible virtualization software&amp;nbsp;bug.&lt;/p&gt;&lt;p&gt;The usual debugging process for crashing OCaml code didn&amp;rsquo;t prove effective&amp;#8202;&amp;mdash;&amp;#8202;we needed to narrow down our approach.&lt;/p&gt;&lt;p&gt;OCaml ships with &lt;a href=&quot;https://realworldocaml.org/v1/en/html/the-compiler-backend-byte-code-and-native-code.html&quot;&gt;two backend implementations&lt;/a&gt;: a bytecode interpreter and a native compiler. We were able to reproduce the issue using both a native compiler and a compiler running on the bytecode interpreter. Consequently, this ruled out a miscompilation coming from the code &lt;em&gt;emitted&lt;/em&gt; by the compiler, the OCaml runtime &lt;em&gt;itself&lt;/em&gt; was misbehaving.&lt;/p&gt;&lt;p&gt;The runtime code is written in C, and implements low level functionalities, including the garbage collector used by both backends. After rebuilding the runtime with debug symbols, we were able to retrieve a proper stack trace and core dump. The stack trace pointed to the garbage collector&amp;rsquo;s mark phase. OCaml&amp;rsquo;s GC is a classic generational mark and sweep collector. The mark phase walks the heap starting from pointers on the stack and other registered root values, and marks every reachable block of&amp;nbsp;memory.&lt;/p&gt;&lt;p&gt;Further inspection with &lt;strong&gt;&lt;em&gt;gdb&lt;/em&gt;&lt;/strong&gt; of the frame and address of crash revealed that the marking code encountered a corrupted block header with invalid size information, causing what looked like a buffer overrun error. Each memory block allocated in OCaml heap begins with a header word, storing metadata used by the GC, including a tag describing the kind of value present in this memory block. The header contains the size of the block, and the crash happened when the mark code was attempting to scan an array which was supposed to be more than 1TB&amp;nbsp;large.&lt;/p&gt;&lt;p&gt;This was obviously not the cause of the problem but rather the consequence: something corrupted the header word after this block had been properly allocated, postponing the crash until the next GC cycle. It was the right time to escalate &lt;a href=&quot;https://caml.inria.fr/mantis/view.php?id=7452&quot;&gt;the issue to the OCaml bugtracker&lt;/a&gt;, after isolating a proper test case to reproduce the&amp;nbsp;issue.&lt;/p&gt;&lt;h3&gt;A set of strange&amp;nbsp;leads&lt;/h3&gt;&lt;p&gt;Escalating the issue to Mantis made us to take a step back and gather our findings, and we quickly got great feedback from the OCaml core&amp;nbsp;team.&lt;/p&gt;&lt;p&gt;At this point, what does the problem look&amp;nbsp;like?&lt;/p&gt;&lt;p&gt;We only had sparse information, but &lt;strong&gt;&lt;em&gt;dmesg&lt;/em&gt;&lt;/strong&gt; gave us interesting data point. When a page fault occurs and the kernel detects an incorrect memory access, it logs a line in kernel log buffer containing the fault address, the instruction pointer and stack&amp;nbsp;pointer.&lt;/p&gt;&lt;p&gt;[22985.879907] ocamlopt.opt[48221]: segfault at af8 ip 00005564455169bd sp 00007ffc9f36b130 error 4 in ocamlopt.opt[556445006000+613000]&lt;/p&gt;&lt;p&gt;Next to the 3 addresses, already available in the coredumps, an error code is reported. This number in decimal form is actually a bitset, and the flags are documented in the Linux kernel sources in &lt;a href=&quot;https://github.com/torvalds/linux/blob/v4.11/arch/x86/mm/fault.c#L41&quot;&gt;arch/x86/mm/fault.c&lt;/a&gt;. Error 4 can thus be read as a read access page fault from user mode, trying to read memory which had not been previously mmap&amp;rsquo;ed.&lt;/p&gt;&lt;p&gt;Error codes reported following our crashes involved protection faults or access to unmapped addresses, which corroborated our earlier buffer overrun hypothesis. More interestingly we witnessed a crash with the PF_RSVD flag enabled. This left us puzzled, none of us had ever seen such fault before. Apparently it indicates that the the page table was somehow corrupted, with some entries having non-zero bits reserved by the x86 architecture specification.&lt;/p&gt;&lt;p&gt;It was scary that the corruption would escape the process address space, and to our limited knowledge, it could only have been caused by kernel issue or potentially hardware issues, like memory errors. Yet we were able to reproduce this on several machines with different kernel version, and different hardware. We blamed virtual machines earlier but this theory was debunked already. We still have no explanation at this time, and pursuit on this front would require intimate knowledge of virtual memory implementations that we didn&amp;rsquo;t&amp;nbsp;have.&lt;/p&gt;&lt;p&gt;One developer wasn&amp;rsquo;t able to reproduce the problem at all on his machine after hours of testing, but something was fishy: it didn&amp;rsquo;t sound right that an OCaml runtime bug would be able to modify the page table. Maybe it was some corner case with reserved addresses, but this something was beyond our reach here. Out of ideas, it was time to get some assistance from tools intended to track memory corruptions, like &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizer&quot;&gt;asan and&amp;nbsp;ubsan&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Running &lt;strong&gt;&lt;em&gt;Asan&lt;/em&gt;&lt;/strong&gt; didn&amp;rsquo;t yield any meaningful results. &lt;strong&gt;&lt;em&gt;Valgrind&lt;/em&gt;&lt;/strong&gt; was later tried, following advises from the OCaml team, but every tools were preventing the crash. Quickly reproducing the bug for testing required running code in a loop, keeping the CPU and memory fully&amp;nbsp;busy.&lt;/p&gt;&lt;p&gt;This was harder to do on developers machines, due to limited resources and other processes running, and Address Sanitizer would only increase the resources usage. Dedicating a powerful server would make further investigations more comfortable, and increase the likeliness of reproducing with instrumented code.&lt;/p&gt;&lt;p&gt;But with great surprise, it was not possible to reproduce the problem on a server machine, with and without instrumented code. This is when we realised that all the machines exhibiting the crashes were running a processor of the Intel Skylake processors family, while the server and other developer machines had CPUs from the Broadwell family.&lt;/p&gt;&lt;h3&gt;The hardware, an unusual&amp;nbsp;suspect&lt;/h3&gt;&lt;p&gt;In the meantime several core OCaml developers had been closely investigating the issue and started auditing recent changes in the runtime, and identified a few suspicious changes and known&amp;nbsp;bugs.&lt;/p&gt;&lt;p&gt;Certainly they were more qualified for this task, but it acted as an incentive to examine the history of this bug from our angle. At first, we had assumed that the bug was specific to the new laptop with virtual machines. This could not explain why the crash never manifested on older workstations equipped with Skylake processors. Several other developers had been using them for a few months, and only noticed the crash after awareness of the issue had been raised by Enguerrand.&lt;/p&gt;&lt;p&gt;What had changed, besides Skylake? Only a few week before, an internal migration from OCaml version 4.02.3 to 4.03.0 was rolled out in our codebase. Intrigued, we went ahead and tested OCaml 4.02.3 again, which showed no memory corruptions after several tests. It was time to browse the &lt;a href=&quot;https://raw.githubusercontent.com/ocaml/ocaml/trunk/Changes&quot;&gt;OCaml changelog&lt;/a&gt; for runtime related entries. The search stopped quickly on a promising item in the list: the OCaml C runtime build optimisation level had been increased to -O2 from&amp;nbsp;-O1.&lt;/p&gt;&lt;p&gt;Could the optimizations dig out an undefined behavior in C code, leading to bad assumptions in the GC code corrupting the heap&amp;nbsp;? Rebuilding the runtime with -O1did not corrupt memory, so the source of the corruption was in the runtime &lt;em&gt;and&lt;/em&gt; was triggered by some gcc specific optimization pass. This sounded like undefined behavior, although the information we had led us to some hardware&amp;nbsp;bug.&lt;/p&gt;&lt;p&gt;The next day, Xavier Leroy commented on the bugreport reporting that the crash had been observed in the past. Another industrial OCaml user was affected, and they had discovered HyperThreading was part of the necessary conditions. After running the test case for several hours on several machines with HT disabled in the UEFI setup, it was clear we were facing a similar situation. This led to the hypothesis of a hardware&amp;nbsp;bug:&lt;/p&gt;&lt;blockquote&gt;&lt;em&gt;Is it crazy to imagine that gcc -O2 on the OCaml 4.03 runtime produces a specific instruction sequence that causes hardware issues in (some steppings of) Skylake processors with hyperthreading? Perhaps it is&amp;nbsp;crazy.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;This possibility had struck us too, motivated by the HyperThreading, the page table corruption and the Skylake specific set of conditions.&lt;/p&gt;&lt;p&gt;This issue had certainly a strange profile. But nobody was ready to fully embrace the cpu bug hypothesis yet. We convinced ourselves that disabling HT could affect cache pressure and unfold some undefined behaviours.&lt;/p&gt;&lt;p&gt;HT could also explain the non-determinism, since cache pressure would depend on timings and scheduling. None of us had sufficient experience in this area to assess the strength of such hypothesis, and we did not quite buy it on a single threaded OCaml program. Our debugging motto claims that &amp;ldquo;assumptions are not&amp;nbsp;facts&amp;rdquo;.&lt;/p&gt;&lt;p&gt;It was time to browse Intel errata list and attempt to update the CPU microcode. Although, the errata descriptions are formulated in vague terms, none of the issues disclosed at this time were looking similar to the situation under investigation. Unfortunately, CPUs microcode had no fix waiting for us either. OCaml developers investigated the errata list from their side but the lack of detailed information turned this into a fruitless and complex&amp;nbsp;task.&lt;/p&gt;&lt;p&gt;In the absence of better alternative, we focused our work on pinpointing the exact source of the crash as if it was a software bug, in the hope of either finding a code issue or ruling out this hypothesis while getting more detailed data. We needed a way to identify the problematic code and find a workaround. From our side, it was not only a matter of finding whether or not there was a bug in OCaml code, but more crucially we needed a guarantee on the quality of our generated code running critical services in production.&lt;/p&gt;&lt;h3&gt;Identifying the offending code&lt;/h3&gt;&lt;p&gt;The other OCaml user affected by this issue reported that they had solved the problem by switching to another C compiler. Building the runtime with clang instead of GCC would prevent the GC from crashing. They also suggested to obtain a diff of the generated assembly. Indeed, once built with clang, the runtime would not crash. But clang generates widely different assembly from GCC and we did not have the resources to analyse several hundred thousand lines of&amp;nbsp;changes.&lt;/p&gt;&lt;p&gt;If we could isolate the problematic C code, comparing the generated code would be easier. The problem had the form of a well known&amp;nbsp;nail:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Around 50 C files composing the OCaml&amp;nbsp;runtime,&lt;/li&gt;&lt;li&gt;There is a good state (when built with gcc&amp;nbsp;-O1)&lt;/li&gt;&lt;li&gt;And a bad state (when built with gcc&amp;nbsp;-O2)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This nail comes with a precious hammer: bisection.&lt;/p&gt;&lt;p&gt;The bisection approach had a downside in this occasion. Any state can be labeled bad with certainty as soon as the test crashes, but we would need to wait several hours to be confident enough to trust a non crashing test as good data-point. The reproducibility was not always consistent and a non-crashing state could be a false negative still waiting to trigger the conditions leading to the crash. A reduction of search space was necessary.&lt;/p&gt;&lt;p&gt;All the coredumps we had showed that the fault was caused by a corrupted heap block header, and our testcase involved the compiler. The OCaml compiler is not 100% deterministic, and IO/s primitives and unix environment in the runtime can affect timings and allocation patterns. But it sounded sensible to assume that the code corrupting a heap header block was also the code reading and writing those blocks: the major&amp;nbsp;GC.&lt;/p&gt;&lt;p&gt;This hypothesis made bisecting fast: the first file we tried, &lt;strong&gt;&lt;em&gt;major_gc.c&lt;/em&gt;&lt;/strong&gt;, turned out to be the one. To make sure it was not a subtle issue in linker, reordering symbols or code blocks, we tried a few others files and confirmed changing the optimization level of some other files alone made no difference.&lt;/p&gt;&lt;p&gt;But the generated code difference was still way too large. Bringing this topic up on the &lt;a href=&quot;http://webchat.freenode.net/?channels=#ocaml&quot;&gt;OCaml IRC&lt;/a&gt; discussion channel led to some useful inputs. We were taught that gcc supports an attribute to enable specific optimizations at the function level, using __attribute__((optimize(&amp;quot;options,...&amp;quot;))). Following the same strategy, it was easy to trace the source of the malfunctioning code to the &lt;strong&gt;&lt;em&gt;sweep_slice&lt;/em&gt;&lt;/strong&gt; function, which implements the sweeping phase of the classic mark and sweep garbage collector for the old generation.&lt;/p&gt;&lt;p&gt;Ignoring the subtle details of incremental GC, the &lt;strong&gt;&lt;em&gt;sweep_slice&lt;/em&gt;&lt;/strong&gt; function is the last pass of a normal major collection cycle. It is responsible for scanning all blocks in the major heap, and reclaiming unreachable blocks to the list of unallocated space.&lt;/p&gt;&lt;p&gt;The bulk of this function is a switch taking action for each block depending on its status&amp;nbsp;:&lt;/p&gt;&lt;iframe src=&quot;&quot; width=&quot;0&quot; height=&quot;0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;a href=&quot;https://medium.com/media/cfbc19fddccc5f2c1a76fcc802fae049/href&quot;&gt;https://medium.com/media/cfbc19fddccc5f2c1a76fcc802fae049/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;This finding felt consistent with the information at hand. When the block is reachable, the color (describing the reachability status of the block) is reset. If the block became unreachable (&lt;em&gt;while color&lt;/em&gt;) - it is reclaimed. In both cases, the block header is modified.&lt;/p&gt;&lt;p&gt;Getting back to the assembly&amp;nbsp;diff.&lt;/p&gt;&lt;p&gt;Nobody in the team knows a great deal about assembly and we only have a really basic understanding of most of the instructions used in both versions. It quickly became obvious that the noise level in this diff, with thousands of lines of changed, was still too high for us to spot anything related to the problem. This problem was getting far beyond the common knowledge of everyone in the&amp;nbsp;team.&lt;/p&gt;&lt;p&gt;But this was still sounding like your day to day bug tracking process. The less you know, the more careful you need to be, tackling the problem step by step. We stuck to what approach had served us well until now: bisecting.&lt;/p&gt;&lt;p&gt;We went through the list of optimisation passes enabled by GCC at -O2. This is a fair amount of optimisation passes and it would have been too time consuming to try them one by one, given the time needed to trigger the crash. Yet we had a hint: a memory corruption was happening semi randomly in the garbage collector. We were also keeping the undefined behaviour bug as a potential explanation. It was likely a pass which would change the structure of the code, reordering blocks and changing conditions.&lt;/p&gt;&lt;p&gt;After reading the description of all switches in the detailed gcc manual, the -ftree-* pass family looked promising. This set of transformations works on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single_assignment_form&quot;&gt;SSA form&lt;/a&gt; internal representation, a widespread intermediate language representation which has the benefit of being easy to read. They seem to make a huge impact on the generated assembly code, moving code blocks around and making assumptions on code invariants in order to move around, simplify or eliminate conditional checks altogether.&lt;/p&gt;&lt;p&gt;By looking at output of those passes on the related source code, we narrowed down the list of transformations to a couple of interesting passes, one of them being -ftree-vrp, which stands for Value Range Propagation. This pass computes bounds for each name binding and propagates proofs that a value must lie in a given&amp;nbsp;range.&lt;/p&gt;&lt;p&gt;It turned out most of the other passes depended on it for further optimisations. Even though the issue ended up not being a bad assumptions in the range values, checking this pass proved to be worthwhile: enabling -ftree-vrp on &lt;strong&gt;&lt;em&gt;sweep_slice&lt;/em&gt;&lt;/strong&gt; function while every thing else was built with -O1 was enough to trigger a&amp;nbsp;crash.&lt;/p&gt;&lt;p&gt;GCC provides very good diagnostics output, and after reading the manual we found the -fdump-tree-* switch to dump the SSA form before and after specific pass. The output is designed to be read by a human and provides meaningful naming, with source code locations, alongside the ranges propagated by the VRP pass. We spent some time studying the output and matched the difference in SSA tree between the crashing and not crashing&amp;nbsp;code.&lt;/p&gt;&lt;p&gt;Examining the bounds and invariants derived by gcc, it was clear that no wrong hypothesis was&amp;nbsp;stated.&lt;/p&gt;&lt;iframe src=&quot;&quot; width=&quot;0&quot; height=&quot;0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;a href=&quot;https://medium.com/media/a5a311d0b5a4f890f9541f0aed91e73e/href&quot;&gt;https://medium.com/media/a5a311d0b5a4f890f9541f0aed91e73e/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;The only meaningful observable change involves the suppression of rechecking the loop condition in the else branch of the &lt;strong&gt;&lt;em&gt;sweep_slice&lt;/em&gt;&lt;/strong&gt; function, after Value Range Propagation proved that the condition was invariant in this&amp;nbsp;branch.&lt;/p&gt;&lt;p&gt;Often, reading the code carefully is the fastest way to find a bug. But after spending hours staring at the major GC code, it was clear enough that this check removal should not cause any semantic&amp;nbsp;changes.&lt;/p&gt;&lt;p&gt;In this process, we identified a suspicious bit of code, where a signed long variable was promoted to unsigned according to C standard rules, which was changing the bounds derived by gcc, assuming it was always positive. But after some thinking we realised it made no difference at assembly level and although wrong, this assumption was not used anywhere.&lt;/p&gt;&lt;p&gt;We were now ready to rule out the possibility of a bug in OCaml runtime. It was still possible that GCC backend had a bug and was miscompiling this particular shape of code. And we were back at the assembly level again. After writing some awk formatting script to cleanup assembly and minimise noise in the diff (by renaming labels, detecting spurious code move, etc), and preventing inlining, we found a minimal assembly patch causing the&amp;nbsp;crash.&lt;/p&gt;&lt;p&gt;There were only cosmetic differences. The test removal was propagated down to assembly and caused gcc to reorganise the layout of each switch case&amp;nbsp;block.&lt;/p&gt;&lt;iframe src=&quot;&quot; width=&quot;0&quot; height=&quot;0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;a href=&quot;https://medium.com/media/532ab4896b11177a96203fd0c81eaa58/href&quot;&gt;https://medium.com/media/532ab4896b11177a96203fd0c81eaa58/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;Among those minor differences and changes of layout, we noticed a particular change which impacted exactly the reachable block header updated which could have caused header corruption. In the unoptimised version, the updating code looked like&amp;nbsp;this:&lt;/p&gt;&lt;iframe src=&quot;&quot; width=&quot;0&quot; height=&quot;0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;a href=&quot;https://medium.com/media/38ca30a1decf86233084721c3803b1c4/href&quot;&gt;https://medium.com/media/38ca30a1decf86233084721c3803b1c4/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;For some reason, the block pointer was spilled to the&amp;nbsp;stack.&lt;/p&gt;&lt;p&gt;Perhaps naively, and because we had earlier emitted the hypothesis of HT impacting cache pressure, we spent a few hours staring at this code and check if we were missing something subtle which could affect the control flow of the whole function and the stack location from which it was reloaded could be corrupted.&lt;/p&gt;&lt;p&gt;Despite our lack of assembly knowledge, after spending several hours reading this tiny change, we got convinced that it made strictly no semantic difference. Reading the x86 manual carefully didn&amp;rsquo;t give any hint on any subtle behavior which would trigger. Executing any of those two sequence of instruction should give the exact same&amp;nbsp;output.&lt;/p&gt;&lt;h3&gt;Mitigating the&amp;nbsp;issue&lt;/h3&gt;&lt;p&gt;We were now quite certain it was a CPU&amp;nbsp;bug.&lt;/p&gt;&lt;p&gt;The OCaml developers had reached the same conclusion, and were working on escalating the issue to Intel. After internal discussions we decided to keep this bug as low profile as possible since we were unsure about potential security implications, especially for JIT implementations.&lt;/p&gt;&lt;p&gt;Even if we had no confirmation at this point nor any explanations of the cause of this bug, which was beyond our reach, we could take&amp;nbsp;actions.&lt;/p&gt;&lt;p&gt;The first step was to decide against getting any new Skylake based servers until further announcement. We were left with several Skylake machines but we refrained from deploying any OCaml code on them. OCaml comes with a great package manager, &lt;a href=&quot;https://opam.ocaml.org/&quot;&gt;opam&lt;/a&gt;, which supports compiler switches. Switches allow to set up a clean and distinct environment with specific packages and compiler configuration.&lt;/p&gt;&lt;p&gt;We patched our internal opam repository to distribute unoptimised runtime to all developers and moved forward, waiting for further announcements.&lt;/p&gt;&lt;p&gt;This situation made us realise that microcode requires constant updates, just like any other software in the stack. We raised awareness on this topic in our devops team, and they took measure to ensure we could roll out updates to prod&amp;nbsp;easily.&lt;/p&gt;&lt;h3&gt;Happy end&lt;/h3&gt;&lt;p&gt;In late May, devops team noticed a &lt;a href=&quot;http://metadata.ftp-master.debian.org/changelogs/non-free/i/intel-microcode/intel-microcode_3.20170511.1_changelog&quot;&gt;debian package update for intel-microcode&lt;/a&gt; containing the following change:&lt;/p&gt;&lt;pre&gt;Likely fix nightmare-level Skylake erratum SKL150. Fortunately,&lt;br/&gt;either this erratum is very-low-hitting, or gcc/clang/icc/msvc&lt;br/&gt;won&amp;rsquo;t usually issue the affected opcode pattern and it ends up&lt;br/&gt;being rare.&lt;br/&gt;SKL150 &amp;mdash; Short loops using both the AH/BH/CH/DH registers and&lt;br/&gt;the corresponding wide register *may* result in unpredictable&lt;br/&gt;system behavior. Requires both logical processors of the same&lt;br/&gt;core (i.e. sibling hyperthreads) to be active to trigger, as&lt;br/&gt;well as a &amp;ldquo;complex set of micro-architectural conditions&amp;rdquo;&lt;/pre&gt;&lt;p&gt;The erratum description immediately rang a bell as it matched the diff in the assembly we had observed. We tested the microcode update and confirmed it fixed the corruption.&lt;/p&gt;&lt;p&gt;Finally, our Skylake CPUs were feeling safe and OCaml compiler was&amp;nbsp;happy.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://ahrefs.com&quot;&gt;&lt;em&gt;Ahrefs&lt;/em&gt;&lt;/a&gt;&lt;em&gt; runs an internet-scale bot that crawls the whole Web 24/7. Our backend system is powered by a custom petabyte-scale distributed key-value storage implemented in OCaml (and some C++ and Rust). We are a small team and strongly believe in better technology leading to better solutions for real-world problems. We worship functional languages and static typing, extensively employ code generation and meta-programming, value code clarity and predictability, and are constantly seeking to automate repetitive tasks and eliminate boilerplate. And we are&amp;nbsp;&lt;/em&gt;&lt;a href=&quot;https://ahrefs.com/jobs&quot;&gt;&lt;em&gt;hiring&lt;/em&gt;&lt;/a&gt;&lt;em&gt;!&lt;/em&gt;&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=ab1ad2beddcd&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;/&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ahrefs.com/skylake-bug-a-detective-story-ab1ad2beddcd&quot;&gt;Skylake bug: a detective story&lt;/a&gt; was originally published in &lt;a href=&quot;https://tech.ahrefs.com&quot;&gt;Ahrefs&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><id>https://tech.ahrefs.com/skylake-bug-a-detective-story-ab1ad2beddcd?source=rss----303662d88bae--ocaml</id><title type="text">Skylake bug: a detective story</title><updated>2017-06-28T18:34:51-00:00</updated><author><name>ahrefs</name></author></entry></feed>