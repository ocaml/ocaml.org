---
title: Not-learning is a skill too
description: "To be successful in tech, it\u2019s well known that you must keep your
  skills up to date. The onus is on each individual to do this, no-one will do it
  for you, and companies that provide ongoing p\u2026"
url: https://gaius.tech/2018/07/29/not-learning-is-a-skill-too/
date: 2018-07-29T12:23:30-00:00
preview_image: https://gaiustech.files.wordpress.com/2018/07/cropped-lynx.jpg?w=180
authors:
- Gaius Hammond
source:
---

<p>To be successful in tech, it&rsquo;s well known that you must keep your skills up to date. The onus is on each individual to do this, no-one will do it for you, and companies that provide ongoing personal development are few and far between. Many companies would rather <a href="https://www.theregister.co.uk/2018/02/06/ibm_retracts_agreed_voluntary_redundancies/">&ldquo;remix our skills&rdquo;</a>, which means laying off workers with one skill (on statutory minimum terms) and hiring people with the new skill. Which is short-termist in the extreme; the new workers are no better than the old, they just happened to enter the workforce later, and the churn means there is no accumulation of institutional knowledge. If you were one of the newer workers, why would you voluntarily step onto this treadmill and if you were a client, why would you hire such a firm when it provides no value-add over just hiring the staff you need yourself? Anyway, I digress.</p>
<p>It is clear that C++11 was a enormous improvement over C++98. The list of <a href="https://smartbear.com/blog/develop/the-biggest-changes-in-c11-and-why-you-should-care/">new features</a> is vast and all-encompassing, yet at the same time, backwards compatibility is preserved. You can have all the benefits of the new while preserving investment in the old (&ldquo;legacy&rdquo;). Upgrading your skills to C++11 was a very obvious thing to do, and because of the smooth transition, you could make quick wins as you brought yourself up to speed. That is just one example of the sort of thing I am talking about. You still need to put the effort in to learn it and seek out opportunities to use it, but the path from the old to the new is straightforward and there are early and frequent rewards along the way, and from there to C++14, 17, 20&hellip;</p>
<p>But I look around the current technology landscape and I see things that are only incremental improvements on existing programming languages or technologies and yet require a clean break with the past, which in practice means not only learning the new thing, but also rebuilding the ecosystem and tooling around it, porting/re-writing all the code, encountering all new bugs and edge cases, rediscovering the design patterns or new idioms in the language. The extent to which the new technology is &ldquo;better&rdquo; is dwarfed by the effort taken to use it, so where is the improved productivity coming from? Every project consists of either learning the language as you go, or maintaining and extending something written by someone who was learning the language as they went, perhaps gambling on getting in on the ground floor of the next big thing. But things only get big if people stick with them is the paradox!</p>
<p>So I am pretty comfortable with my decision to mostly ignore lots of new things, including but not limited to Go, Rust, Julia, <a href="https://blogs.msdn.microsoft.com/devops/2018/07/18/protecting-our-users-from-the-npm-eslint-package-breach/">Node.js</a>, Perl6 in favour of deepening my skills in C++, R, Python and pushing into new problem domains (e.g. <a href="https://www.microsoft.com/en-us/cognitive-toolkit/">ML/AI</a>) with my tried and trusted tools. When something comes along that is a big enough leap forward over any of them, of course I&rsquo;ll jump &ndash; just like I did when I learnt Java in 1995 and was getting paid for it the same year! I had a lot of fun with OCaml and Haskell too, but neither gained significant traction in the end, also <a href="https://gaiustech.wordpress.com/2011/06/15/scala-quickstart-for-oracle-dbas/">Scala</a>. I don&rsquo;t see anything on the horizon, all the cutting edge stuff is appearing as <a href="https://devblogs.nvidia.com/seven-things-numba/">libraries</a> or <a href="https://en.wikipedia.org/wiki/C++20">features</a> for my &ldquo;big 3&rdquo; while the newer ecosystems are scrambling to backfill their capabilities and will probably never match the breadth and depth, before falling out of fashion and fading away. I&rsquo;ll be interested in any comments arguing why I&rsquo;m wrong to discount them, or any pointers to things that <i>are</i> sufficiently advanced to be worth taking a closer look at.</p>

