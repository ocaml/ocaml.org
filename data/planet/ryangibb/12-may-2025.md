---
title: 12 May 2025
description:
url: https://ryan.freumh.org/2025-05-12.html
date: 2025-05-12T00:00:00-00:00
preview_image:
authors:
- Ryan Gibb
source:
---

<article>
    <div class="container">
        <span>  Previous: <a href="https://ryan.freumh.org/2025-05-05.html"> 5 May 2025</a>  </span>
        <span>  </span>
    </div>
    
    <section>
        <h2><span class="done DONE">X</span> <a href="https://github.com/RyanGibb/uvx-ocaml">uvx OxCaml</a>
experiment</h2>
<p><span>Can we use <code class="verbatim">uv</code> to package python? Part of <a href="https://ryan.freumh.org/enki.html">Enki</a>.</span></p>
<h2><span class="done DONE">X</span>
Read <a href="https://spiffe.io/pdf/Solving-the-bottom-turtle-SPIFFE-SPIRE-Book.pdf">Solving
the Bottom Turtle</a></h2>
<p><span>They’re thinking
about a similar problem, but are much more focused on the corporate
side.</span></p>
<h2><span class="done DONE">X</span> Read <a href="https://www.usenix.org/sites/default/files/conference/protected-files/enigma_haken_slides.pdf">Secrets
at Scale: Automated Bootstrapping of Secrets &amp; Identity in the
Cloud</a></h2>
<p><span>They
just use AWS as their root of trust</span></p>
<h2>Identity as a Function</h2>
<figure>
<img src="https://ryan.freumh.org/images/2025-05-09-identity-dependencies.svg">
<figcaption>Identity Dependencies in the Network</figcaption>
</figure>
<ol>
<li><p><span>Problem</span></p>
<ul>
<li>Service managers have no purview over the lifetimes of the
identities networked services create, such as X.509 certificates, DNS
records, and protocol-specific keys.</li>
<li>Such identities are managed in an ad-hoc way that makes it difficult
to have insight as to what identities have been created and which might
have been compromised.</li>
<li>There is a complex web of dependencies that makes revoking and
rotating identities a manual and error-prone process.</li>
</ul></li>
<li><p><span>Cost</span></p>
<ul>
<li>Unused identities leave a larger attack surface for access to
critical systems, and failure to understand the implications of
compromises on downstream identities leaves us vulnerable.</li>
<li>For example, persisting an outdated SSH key in a server’s <code class="verbatim">authorized_keys</code> creates a unnecessary
backdoor.</li>
<li>If an attacker gains access to the system, say, running a
nameserver, they could move laterally use the ACME protocol to provision
TLS certificates for the domain.</li>
<li>On discovering this compromise all the dependent identities, such as
TLS certificates, will need to be revoked.</li>
</ul></li>
<li><p><span>SOTA</span></p>
<ul>
<li>Existing software deployment techniques layer complexity in order to
manage all these identities.</li>
<li>There’s many useful bits that are stitched together piecemeal with
fragile glue, but a lack of a unified interface to identity in the
network across disparate protocols.</li>
</ul></li>
<li><p><span>Solution</span></p>
<ul>
<li>We define a identity Domain Specific Language to describe the types
of identities in play in the TCP/IP networking stack, showing the roots
of trust in our systems and their transitive dependants.</li>
<li>By defining identities in this way, we can express identities as
<u>functions</u> that return an authentication token, and unclock the
programability of identities in the network.</li>
<li>We can understand the lifetime of identities and garbage collect
them when they’re no longer used.</li>
<li>We can create hundred of honey-pot keys that if used we know there’s
been a compromise in the network.</li>
<li>We can spin up a self-hosted digital island for the duration of a
project and manage the full lifetime of the identities involved; from
creation, to rotation, to expiry and revocation.</li>
<li>We can minimising the chain of trust by re-anchoring identities like
Matrix user IDs from HTTPS well-known paths to DNSSEC-verified
resource-records, using DNSSEC as the narrow waist of trust.</li>
<li>We can <a href="https://www.tunbury.org/bluesky-ssh-authentication-2/">authenticate
SSH keys with an AtProto Personal Data Service</a>.</li>
<li>We provide a framework to understand the roots of trusts of our
identities and any weak points in the chain of trust.</li>
</ul></li>
<li><p><span>Impl</span></p>
<ul>
<li>What if we had registry of identities?</li>
<li>What are the constituent parts?</li>
<li>How do we use this language?</li>
<li>What are we trying to prove?</li>
<li>Provide clarify to provide to an existing set of rules?</li>
<li>Are we trying to prove some properties of this system (identities in
the network)?</li>
<li>What is our stunt?</li>
<li>The service manager could talk to identity service and mount the
secrets in a namespace?</li>
<li>Do we wrap Docker compose?</li>
<li>Do we implement a service/registry with a Cap’N Proto API that
applications can talk to? Using Cap’N Proto as the system call
layer.</li>
<li>Or maybe we can change the mechanism by which the file gets
there?</li>
<li>This is exactly what I’ve done <a href="https://github.com/RyanGibb/eon/blob/main/acme.nix">here</a>.</li>
<li>This is a horrible hack though: the service needs to kill itself to
communicate that the downstream dependencies need to restart.</li>
<li>We’re in this liminal space between building (Nix) and running
(SystemD).</li>
</ul></li>
</ol>
<h2>Service Managers a la Carte</h2>
<p><span>They’re just build
systems that continue to run. The difference between docker run and
docker build is that docker run commands don’t terminate. They’re both
sandboxed. Service managers mange to manage dynamic processes: if a
service restarts maybe it’s downstream dependencies need to
restart.</span></p>
<p><span>Starting building
block: formalised framework for service managers. It’s within this that
we can define what identity is.</span></p>
<p><span>What do these systems
allow you to express? Restart policies? Are they static or dynamic? None
of them are triggered by the fileystem restarting.</span></p>
<p><span>It would be insightful
to know what the hell goes on on Windows.</span></p>
<p><span>A service is a process
execution environment and set of dependencies. We have a forest: disjunc
graphs with no cycles. Service can be long running or not (just mutate
something on the disk/network).</span></p>
<p><span>It becomes a build
system when the dependencies are run to set up the state of some
service. How can we depend on a resource, like a TLS certificate? We
could have the service that provides it, and a service that consumes
it.</span></p>
<p><span>Dune rules service
manager.</span></p>
<p><span>It is a reactive system
(see froc) – you need a notion of time.</span></p>
<h2><span class="todo TODO">O</span> update the package management paper for arxiv
publication</h2>
<ol>
<li><p><span><span class="done DONE">X</span> update formalism</span></p>
<p><span>It
turns out depopts aren’t a part of the resolution at all, they’re only
used to assemble the action graph and order installations from the
resolved set of packages. Purely a post-resolution processing step. No
depopt we add to any package will actually change the resolved package
set; they only change the order in which they’re installed, or whether a
package needs to be rebuild given a dependency change.</span></p>
<p><span>Some
other improvements:</span></p>
<ul>
<li>we don’t add conflicts to the core calculus since we can encode them
with a conflict package</li>
<li>we don’t jump through hoops to support multi-version solving as we
encode different cargo package major versions as different package
names, with a proxy package to depend on cross-major version bumps</li>
<li>this means we can resolve for a resolved set of packages and
reconstruct their installation order from their dependencies</li>
</ul></li>
<li><p><span><span class="todo TODO">O</span> Pak language</span></p>
<p><span>A
maximally expressive lingua franca for package
management</span></p></li>
<li><p><span><span class="todo TODO">O</span> algorithm discussion</span></p>
<p><span>We
already discuss SAT solving but we should describe Answer-set
programming solutions like PubGrub, and how CUDF fits in
here</span></p></li>
<li><p><span><span class="todo TODO">O</span> bidirectional translations - [[*<span class="math display">$$\[https://github.com/RyanGibb/uvx-ocaml$$</span><span class="math display"><em>u</em><em>v</em><em>x</em><em>O</em><em>x</em><em>C</em><em>a</em><em>m</em><em>l</em></span>\]
experiment][opam to uv]]</span></p></li>
<li><p><span><span class="todo TODO">O</span> what can we reason about with the package
calculus?</span></p>
<ul>
<li>diamond dependency problem?</li>
<li>how to extract it from an arbitrarily complex graph?</li>
</ul></li>
</ol>
<h2><span class="todo TODO">O</span> Read up
on GNU Shepard</h2>
<h2><span class="todo TODO">O</span> hook <a href="https://ryan.freumh.org/bigraphs-real-world.html">Roy</a>’s <a href="https://github.com/royangkr/bigraph-of-the-world">Bigraph of the
World</a> up to <a href="https://github.com/ryanGibb/eo">Eon</a> to form
the basis of the <a href="https://ryan.freumh.org/spatial-computing.html">Spatial Name
System</a></h2>
<h2><span class="todo TODO">O</span> Re-read the service management chapter of <a href="https://edolstra.github.io/pubs/phd-thesis.pdf">https://edolstra.github.io/pubs/phd-thesis.pdf</a></h2>
    </section>
</article>

