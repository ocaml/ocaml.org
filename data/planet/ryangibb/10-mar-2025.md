---
title: 10 Mar 2025
description:
url: https://ryan.freumh.org/2025-03-10.html
date: 2025-03-10T00:00:00-00:00
preview_image:
authors:
- Ryan Gibb
source:
---

<article>
    <div class="container">
        <span>  Previous: <a href="https://ryan.freumh.org/2025-03-03.html"> 3 Mar 2025</a>  </span>
        <span>  Next: <a href="https://ryan.freumh.org/2025-03-17.html">17 Mar 2025</a>  </span>
    </div>
    
    <section>
        <ol>
<li><p><span>Babel</span></p>
<ol>
<li><p><span><span class="done KILL">~</span> python
pubgrub</span></p>
<p><span>Using Uv’s <a href="https://github.com/astral-sh/uv/blob/c48af312aee48a000a23722ecfdddbe5a4037f78/crates/uv-resolver/src/dependency_provider.rs#L13">dependency
provider</a>.</span></p>
<p><span>This isn’t feasible at present, as Uv implements a
custom resolver.</span></p></li>
<li><p><span><span class="done DONE">X</span> cargo
pubgrub</span></p>
<p><span>Got a <a href="https://github.com/RyanGibb/babel/commit/dcdb92a6840b3d78e3737bb448bf0937d1c9964c">cargo
dependency provider</a> working modified from a repository used to
benchmark <code class="verbatim">pubgrub-rs</code> on solving the cargo
repository.</span></p>
<pre class="example"><code>(Root, ) -&gt; (Cargo Bucket:serde@1.x.y, SemverPubgrub { norml: 1.0.219, pre: ∅ } )
(Cargo Bucket:serde@1.x.y, 1.0.219) -&gt; (Cargo Bucket:serde_derive@1.x.y, SemverPubgrub { norml: &gt;=1.0.219, &lt;1.0.220, pre: ∅ } ), (Cargo Bucket:serde_derive@1.x.y/default=true, SemverPubgrub { norml: &gt;=1.0.219, &lt;1.0.220, pre: ∅ } )
(Cargo Bucket:serde_derive@1.x.y, 1.0.219) -&gt; (Cargo Bucket:quote@1.x.y/proc-macro, SemverPubgrub { norml: &gt;=1.0.35, &lt;2.0.0, pre: ∅ } ), (Cargo Bucket:syn@2.x.y/parsing, SemverPubgrub { norml: &gt;=2.0.81, &lt;3.0.0, pre: ∅ } ), (Cargo Bucket:syn@2.x.y, SemverPubgrub { norml: &gt;=2.0.81, &lt;3.0.0, pre: ∅ } ), (Cargo Bucket:syn@2.x.y/derive, SemverPubgrub { norml: &gt;=2.0.81, &lt;3.0.0, pre: ∅ } ), (Cargo Bucket:syn@2.x.y/clone-impls, SemverPubgrub { norml: &gt;=2.0.81, &lt;3.0.0, pre: ∅ } ), (Cargo Bucket:quote@1.x.y, SemverPubgrub { norml: &gt;=1.0.35, &lt;2.0.0, pre: ∅ } ), (Cargo Bucket:proc-macro2@1.x.y, SemverPubgrub { norml: &gt;=1.0.74, &lt;2.0.0, pre: ∅ } ), (Cargo Bucket:proc-macro2@1.x.y/proc-macro, SemverPubgrub { norml: &gt;=1.0.74, &lt;2.0.0, pre: ∅ } ), (Cargo Bucket:syn@2.x.y/proc-macro, SemverPubgrub { norml: &gt;=2.0.81, &lt;3.0.0, pre: ∅ } ), (Cargo Bucket:syn@2.x.y/printing, SemverPubgrub { norml: &gt;=2.0.81, &lt;3.0.0, pre: ∅ } )
(Cargo Bucket:serde_derive@1.x.y/default=true, 1.0.219) -&gt; (Cargo Bucket:serde_derive@1.x.y, SemverPubgrub { norml: 1.0.219, pre: ∅ } ), (Cargo Bucket:serde_derive@1.x.y/default, SemverPubgrub { norml: 1.0.219, pre: ∅ } )
(Cargo Bucket:quote@1.x.y/proc-macro, 1.0.40) -&gt; (Cargo Bucket:quote@1.x.y, SemverPubgrub { norml: 1.0.40, pre: ∅ } ), (Cargo Bucket:proc-macro2@1.x.y/proc-macro, SemverPubgrub { norml: &gt;=1.0.80, &lt;2.0.0, pre: ∅ } )
(Cargo Bucket:syn@2.x.y/parsing, 2.0.100) -&gt; (Cargo Bucket:syn@2.x.y, SemverPubgrub { norml: 2.0.100, pre: ∅ } )
(Cargo Bucket:syn@2.x.y, 2.0.100) -&gt; (Cargo Bucket:proc-macro2@1.x.y, SemverPubgrub { norml: &gt;=1.0.91, &lt;2.0.0, pre: ∅ } ), (Cargo Bucket:unicode-ident@1.x.y, SemverPubgrub { norml: &gt;=1.0.0, &lt;2.0.0, pre: ∅ } ), (Cargo Bucket:unicode-ident@1.x.y/default=true, SemverPubgrub { norml: &gt;=1.0.0, &lt;2.0.0, pre: ∅ } )
(Cargo Bucket:syn@2.x.y/derive, 2.0.100) -&gt; (Cargo Bucket:syn@2.x.y, SemverPubgrub { norml: 2.0.100, pre: ∅ } )
(Cargo Bucket:syn@2.x.y/clone-impls, 2.0.100) -&gt; (Cargo Bucket:syn@2.x.y, SemverPubgrub { norml: 2.0.100, pre: ∅ } )
(Cargo Bucket:quote@1.x.y, 1.0.40) -&gt; (Cargo Bucket:proc-macro2@1.x.y, SemverPubgrub { norml: &gt;=1.0.80, &lt;2.0.0, pre: ∅ } )
(Cargo Bucket:proc-macro2@1.x.y, 1.0.94) -&gt; (Cargo Bucket:unicode-ident@1.x.y, SemverPubgrub { norml: &gt;=1.0.0, &lt;2.0.0, pre: ∅ } ), (Cargo Bucket:unicode-ident@1.x.y/default=true, SemverPubgrub { norml: &gt;=1.0.0, &lt;2.0.0, pre: ∅ } )
(Cargo Bucket:proc-macro2@1.x.y/proc-macro, 1.0.94) -&gt; (Cargo Bucket:proc-macro2@1.x.y, SemverPubgrub { norml: 1.0.94, pre: ∅ } )
(Cargo Bucket:syn@2.x.y/proc-macro, 2.0.100) -&gt; (Cargo Bucket:quote@1.x.y/proc-macro, SemverPubgrub { norml: &gt;=1.0.35, &lt;2.0.0, pre: ∅ } ), (Cargo Bucket:syn@2.x.y/dep:quote, SemverPubgrub { norml: 2.0.100, pre: ∅ } ), (Cargo Bucket:proc-macro2@1.x.y/proc-macro, SemverPubgrub { norml: &gt;=1.0.91, &lt;2.0.0, pre: ∅ } ), (Cargo Bucket:syn@2.x.y, SemverPubgrub { norml: 2.0.100, pre: ∅ } )
(Cargo Bucket:syn@2.x.y/printing, 2.0.100) -&gt; (Cargo Bucket:syn@2.x.y, SemverPubgrub { norml: 2.0.100, pre: ∅ } ), (Cargo Bucket:syn@2.x.y/dep:quote, SemverPubgrub { norml: 2.0.100, pre: ∅ } )
(Cargo Bucket:serde_derive@1.x.y/default, 1.0.219) -&gt; (Cargo Bucket:serde_derive@1.x.y, SemverPubgrub { norml: 1.0.219, pre: ∅ } )
(Cargo Bucket:unicode-ident@1.x.y, 1.0.18)
(Cargo Bucket:unicode-ident@1.x.y/default=true, 1.0.18) -&gt; (Cargo Bucket:unicode-ident@1.x.y, SemverPubgrub { norml: 1.0.18, pre: ∅ } )
(Cargo Bucket:syn@2.x.y/dep:quote, 2.0.100) -&gt; (Cargo Bucket:syn@2.x.y, SemverPubgrub { norml: 2.0.100, pre: ∅ } ), (Cargo Bucket:quote@1.x.y, SemverPubgrub { norml: &gt;=1.0.35, &lt;2.0.0, pre: ∅ } )
</code></pre>
<p><span>You’ll notice the concept of version ranges in this
dependency provider has a ‘normal’ range, and a ‘pre’ range, so I had to
add an abstract <code class="verbatim">BabelVersionSet</code> to
interoperate with the other dependency providers.</span></p>
<p><span>At the moment this loads the whole index at once
which takes a long time, so I need to figure out how to make <code class="verbatim">pubgrub_cargo</code> dynamically load
packages.</span></p>
<p><span>Getting Claude code to attempt this failed quite
spectacularly, so I guess my job’s safe (for now);</span></p>
<blockquote>
<p><span>We’ve run into significant challenges with
implementing on-demand loading for the Cargo Index. The core issue is
that the API was designed around a pre-loaded data model where all
references have the same lifetime as the Index object.</span></p>
<p><span>Our efforts to update the code to use on-demand
loading led us to the following conclusions:</span></p>
<p><span>Lifetime issues: Dependencies loaded on-demand
don’t live long enough to satisfy the lifetime requirements of the API,
which expects references that live for the entire lifetime of the Index.
Ownership complexity: Even when cloning data to avoid borrowing issues,
we still run into problems with the DependencyProvider trait expecting
references with specific lifetimes. Deep architectural dependencies: The
design assumes references are valid throughout the library’s operation,
making it difficult to use dynamically loaded data without changing core
APIs.</span></p>
<p><span>Recommendation:</span></p>
<p><span>For now, we should document these findings and
revert to the pre-loaded approach while planning a more comprehensive
redesign of the API to better support on-demand loading. This would
involve:</span></p>
<p><span>Redesigning the DependencyProvider trait to work
with owned data rather than references Updating the Names and Package
types to avoid lifetime parameters Creating a proper caching layer for
dynamically loaded data</span></p>
<p><span>This is a valuable learning experience that
highlights the challenges of retrofitting on-demand loading into a
system designed around pre-loaded data with static lifetim</span></p>
</blockquote>
<blockquote>
<p><span>Redesigning pubgrub_cargo to use an owned data
approach like pubgrub_opam would be a substantial undertaking. Here’s a
breakdown of the work involved: Scope of Changes</span></p>
<p><span>Core Type Redesign (3-5 days) Remove lifetime
parameters from Names, Dependency, Index, and other key structs Redesign
these to be fully owned types that implement Clone Update method
signatures throughout the codebase</span></p>
<p><span>DependencyProvider Implementation (2-3 days)
Rewrite methods like get_versions, get_version, and get_dependencies to
return owned data Handle on-demand loading with proper
caching</span></p>
<p><span>Package Resolution Logic (3-5 days) Modify pubgrub
integration to work with owned data Update logic in from_dep,
check_cycles, etc. to work without lifetime references</span></p>
<p><span>Testing &amp; Debugging (3-5 days) Fix all the
test cases that would break Debug subtle issues with different data
ownership patterns Ensure performance remains acceptable</span></p>
<p><span>Challenges</span></p>
<p><span>Deep Architectural Change: The lifetime parameters
are embedded deeply in the API, affecting almost every function.
Interface Consistency: Need to ensure the redesign doesn’t break clients
of the library. Performance Tradeoffs: Switching to owned data means
more cloning, which could impact performance.</span></p>
<p><span>Total Estimate</span></p>
<p><span>A skilled Rust developer with good knowledge of
the codebase would likely need 2-3 weeks of focused work to complete
this redesign properly. The work would include refactoring, testing,
debugging, and performance optimization.</span></p>
<p><span>If you just need a minimal working solution for
now, reverting to the preloaded approach with selective loading of
common packages might be a better near-term solution while planning the
larger redesign.</span></p>
</blockquote>
<p><span>The AI (and myself) both have a lot of issues with
Rust lifetimes, and I really don’t care about optimising anything at
this point. I miss OCaml’s garbage collector and am tempted to implemnt
the Pubgrub algorithm in Oxidised OCaml.</span></p></li>
<li><p><span><span class="todo TODO">O</span> forking
resolving for portable lockfiles</span></p>
<p><span>See Uv’s resolver.</span></p></li>
<li><p><span>Evaluation</span></p>
<ul>
<li>stunt 1: cross-ecosystem solving
<ul>
<li>system dependency solving
<ul>
<li>debian and alpine</li>
</ul></li>
<li>ocaml polars</li>
</ul></li>
<li>stunt 2: portable lock files
<ul>
<li>portability metric</li>
<li>semantics from formalism</li>
<li>look at what uv does</li>
<li>add to table 1</li>
</ul></li>
<li>stunt 3: cross-compilation
<ul>
<li>solving architectures</li>
</ul></li>
</ul></li>
<li><p><span>Providing packages</span></p>
<ul>
<li>docker?</li>
<li>Nix?</li>
<li>namespaces?</li>
</ul></li>
</ol></li>
</ol>
    </section>
</article>

