---
title: 16 Sep 2024
description:
url: https://ryan.freumh.org/2024-09-16.html
date: 2024-09-16T00:00:00-00:00
preview_image:
authors:
- Ryan Gibb
source:
---

<article>
    <div class="container">
        <span>  Previous: <a href="https://ryan.freumh.org/2024-09-09.html"> 9 Sep 2024</a>  </span>
        <span>  Next: <a href="https://ryan.freumh.org/2024-09-23.html">23 Sep 2024</a>  </span>
    </div>
    
    <section>
        <ol>
<li><p><span>Mon</span></p>
<ol>
<li><p><span>cabal2opam</span></p>
<ol>
<li><p><span>it looks like we can use <a href="https://hackage.haskell.org/01-index.tar">https://hackage.haskell.org/01-index.tar</a>
similar to cargo’s package index!</span></p>
<ol>
<li><p><span>oh no, this is just a bundle of cabal
files</span></p></li>
<li><p><span>also, if we want to depend on projects outside
of the repository we’ll need to parse cargo files</span></p></li>
</ol></li>
</ol></li>
<li><p><span>package management abstract</span></p></li>
<li><p><span>second year report</span></p></li>
<li><p><span>met with anil</span></p>
<p><span>package management abstract</span></p>
<ul>
<li>However, inadequacies in software deployment technologies used for
spatial devices often leads to scenarios such as running software
vulnerable to exploits.</li>
<li>There is a proliferation of package managers with varying degrees of
expressivity and reproducibility using formats that aren’t
interoperable.</li>
<li>Multi-lingual projects can’t provide their dependencies in a unified
way, and dependencies from one package manager ecosystem can’t express a
dependency on a package from another.</li>
<li>Language package mangers implicitly, or explicitly in ad-hoc and
unversioned mechanisms, depend on system packages.</li>
<li>There are package managers that don’t support installing previous
versions of packages, which in the case of regressions forces a decision
between correctness and security.</li>
<li>Configuration solutions often involve invoking imperative scripts,
which are not idempotent, to mutate the state of a system into the
desired shape hindering the reliable operation of spatial services.</li>
<li>% By providing an interoperable and robust software supply chain to
our Spatial OS we can ensure the continued secure and reliable
deployment of spatial services and devices.</li>
</ul>
<p><span>solving</span></p>
<ol>
<li><p><span>area</span></p>
<p><span>Existing package managers are either language or
system specific and do not interoperate with each other.</span></p></li>
<li><p><span>problem</span></p>
<p><span>Multi-lingual projects are unable to express a
dependency on another language’s library, and system dependencies are
typically implicit and unversioned.</span></p></li>
<li><p><span>solution</span></p>
<p><span>We propose a common calculus for package
management which is expressive enough for all ecosystems. By writing
translations from existing package managers to this calculus we
demonstrate how dependency resolution can work across
ecosystems.</span></p></li>
<li><p><span>what this means</span></p>
<p><span>This enables a new generation of package mangers
using a common protocol that can be hyper-specialised to an operating
system or environment.</span></p></li>
<li><p><span>The lack of a common format hinders the
reproducibility and reliability of software supply chains;</span></p>
<p><span>Existing package managers are either language or
system specific and do not interoperate with each other. Multi-lingual
projects are unable to express a dependency on another language’s
library, and system dependencies are typically implicit and unversioned.
We propose a common calculus for package management which is expressive
enough for all ecosystems. By writing translations from existing package
managers to this calculus we demonstrate how dependency resolution can
work across ecosystems. This enables a new generation of package
managers using a common protocol that can be hyper-specialised to an
operating system or environment.</span></p>
<p><span>billions software supplychain securty other
ecosystems paper writing</span></p>
<p><span>OOPSLA submission</span></p>
<p><span>sigcomm dns capnproto on and off</span></p>
<p><span>timetable:</span></p>
<ul>
<li>loco</li>
<li>package management</li>
</ul>
<p><span>DSL over filesystems david jon 1pm
tomorrow</span></p>
<p><span>part II</span></p>
<p><span>bigrapher map</span></p></li>
<li><p><span>cabal is doing something weird with multiple
‘libraries’ per package</span></p></li>
</ol></li>
</ol></li>
<li><p><span>Tue</span></p>
<ol>
<li><p><span>roy bigraph</span></p>
<ol>
<li><p><span><a href="https://www.cl.cam.ac.uk/research/dtg/archived/files/publications/public/acr31/rice-openroommap.pdf">https://www.cl.cam.ac.uk/research/dtg/archived/files/publications/public/acr31/rice-openroommap.pdf</a></span></p>
<pre><code>ctrl Space = 0;
ctrl Building = 0;

atomic ctrl Person = 1;
atomic ctrl Computer = 1;
atomic ctrl Empty = 0;

big ryan = Person{ryan};
big crt = Computer{ryan};

big fn06 = Space.(ryan);
big fn07 = Space.(crt);

big fn = Space.(fn06 | fn07);

big fs01 = Space.(Empty);
big fs = Space.(fs01);

big ffloor = Space.(fn | fs);

big gn01 = Space.(Empty);
big gn = Space.(gn01);

big gfloor = Space.(gn);

big cl = Building.(ffloor | gfloor);

react leave =
  Space.Person{l}
  --&gt;
  Space.Empty | Person{l};

react enter =
  Space.Empty | Person{l}
  --&gt;
  Space.Person{l};

begin brs
  init cl;
  rules = [ {leave, enter} ];
end
</code></pre></li>
</ol></li>
<li><p><span>second year report</span></p></li>
<li><p><span>loco</span></p></li>
<li><p><span>go package management</span></p>
<ol>
<li><p><span>so for go, and node, I’m thinking that we need
to push the resolution logic into the solving runtime, PURL/VURL
style</span></p></li>
<li><p><span>we could scrape all the go modules and their
transitive dependencies, but we’ll probably hit rate
limits</span></p></li>
<li><p><span>as go projects might have dependencies that we
haven’t</span></p></li>
</ol></li>
<li><p><span>met anil, jon, david, and mark</span></p></li>
</ol></li>
<li><p><span>Wed</span></p>
<ul>
<li><p><span>CPAN</span></p></li>
<li><p><span>go</span></p></li>
<li><p><span>npm</span></p></li>
<li><p><span>idris</span></p></li>
<li><p><span>pacman</span></p></li>
<li><p><span>portage</span></p></li>
<li><p><span>package names</span></p></li>
<li><p><span>for each package name, a set of package
versions</span></p></li>
<li><p><span>for every package version,
dependencies</span></p></li>
<li><p><span>dependencies are a CNF of package
versions</span></p>
<ul>
<li>clauses are a set of valid package versions for a package name we
depend on</li>
<li>a clauses could contain packages versions from two packages names if
either can satisfy the dependency</li>
<li>negations of a package version denotes conflicts</li>
</ul></li>
<li><p><span>a set of package versions forms a dependency
graph</span></p></li>
<li><p><span>taking a view from a subset of this set of
package versions is a dependency cone</span></p></li>
<li><p><span>we can `resolve’ a dependency cone to a set of
package versions that satisfy the dependency
requirements</span></p></li>
<li><p><span>package names</span></p></li>
<li><p><span>for each package name, a set of package
versions</span></p></li>
<li><p><span>for every package version, a set of
dependencies.</span></p>
<ul>
<li>a dependency is a package name and a set of valid package versions
for that package
<ul>
<li>note: What about OR clauses? Aren’t these are just the same
dependency from different sources?</li>
</ul></li>
</ul></li>
<li><p><span>for every package version, a list of
conflicts</span></p>
<ul>
<li>the inverse of dependencies</li>
<li>note: do we need these?</li>
</ul></li>
<li><p><span>a set of package versions forms a directed
graph, the dependency graph, where the nodes are package names and edges
are dependency relations</span></p></li>
<li><p><span>we define a transformation from a dependency
graph and a set of desired package versions to a set of package versions
that satisfies the dependencies</span></p>
<ul>
<li>dependency solving or resolving</li>
</ul></li>
</ul></li>
<li><p><span>Thu</span></p>
<ol>
<li><p><span><a href="https://github.com/mt-caret/polars-ocaml/pull/94">https://github.com/mt-caret/polars-ocaml/pull/94</a></span></p></li>
<li><p><span>package management calculus</span></p></li>
<li><p><span>issue with deb provides mechanism: we can’t
depend on virtual packages if we don’t create them</span></p></li>
<li><p><span><span class="done KILL">~</span> get install
graph from 0install</span></p></li>
<li><p><span>getting</span></p></li>
</ol></li>
<li><p><span>Fri</span></p>
<ol>
<li><p><span>worked on core calculus</span></p></li>
<li><p><span><span class="done KILL">~</span> re-introduce
Debian virtual packages as cargo/opam might depend on
them</span></p></li>
</ol></li>
<li><p><span>Sat</span></p>
<ol>
<li><p><span>It’s a hypergraph!</span></p></li>
<li><p><span><a href="https://dl.acm.org/doi/10.1145/3494322.3494338">OPM: An
Ontology-Based Package Manager for Building Operating
Systems</a></span></p></li>
</ol></li>
<li><p><span>Sun</span></p>
<ol>
<li><p><span>Wrote up the dependancy calculus with a
hypergraph formalisaion and did an NP-complete proof.</span></p></li>
</ol></li>
</ol>
    </section>
</article>

