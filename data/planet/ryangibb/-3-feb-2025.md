---
title: ' 3 Feb 2025'
description:
url: https://ryan.freumh.org/2025-02-03.html
date: 2025-02-03T00:00:00-00:00
preview_image:
authors:
- Ryan Gibb
source:
---

<article>
    <div class="container">
        <span>  Previous: <a href="https://ryan.freumh.org/2025-01-27.html">27 Jan 2025</a>  </span>
        <span>  Next: <a href="https://ryan.freumh.org/2025-02-10.html">10 Feb 2025</a>  </span>
    </div>
    
    <section>
        <ol>
<li><p><span>Babel</span></p>
<p><span>I’ve been focusing on our new package manager to
rule them all, code name `Babel’, this week.</span></p>
<ol>
<li><p><span>PubGrub opam dependency provider</span></p>
<p><span>I’m making progress so supporting <a href="https://opam.ocaml.org/">Opam</a>’s full feature set with the <a href="https://pubgrub-rs-guide.pages.dev/">Rust implementation of the
PubGrub</a> version solving algorithm, which we’re aiming to use for a
cross-ecosystem solver.</span></p>
<p><span><a href="https://github.com/RyanGibb/opam-giga-repository">Previous
work</a> has used the Opam semantics for multiple ecosystems.</span></p>
<p><span>The PubGrub encoding is quite similar to the
`HyperRes’ formalism we defined for a minimal subset of functionality
between ecosystems..</span></p>
<ol>
<li><p><span><span class="done DONE">X</span> I’ve added
support for the complicated ordering of <a href="https://opam.ocaml.org/doc/Manual.html#Version-ordering">opam
versions</a> - <a href="https://github.com/RyanGibb/pubgrub-opam/commit/7f941e30f5b6ea11c201e667c2aee6984606bb26">here</a></span></p></li>
<li><p><span><span class="done DONE">X</span> I’ve added an
encoding of boolean logic in Opam’s <a href="https://opam.ocaml.org/doc/Manual.html#Package-Formulas">package
formula</a> - <a href="https://github.com/RyanGibb/pubgrub-opam/commit/63f12dd256fac440d0c69a079c324855cbee224c">here</a></span></p>
<ul>
<li>We support version formula with PubGrub’s Range operations (e.g.
union, intersection, etc)</li>
<li>We support package formula with a proxy package for a logical or;
the proxy package has two version - “lhs” and “rhs” with appropriate
dependencies, and we can extract the edges in the resolved dependency
graph from this. This is equivalent to our edges clauses in the SAT
encoding, but using packages themselves to encode it.</li>
</ul>
<p><span>An <a href="https://github.com/RyanGibb/pubgrub-opam/tree/main/package-formula-repo">example</a>;</span></p>
<pre class="example"><code>Created index with 5 packages:
(C, 1.0.0)
(C, 1.5.0) -&gt; (E: 1.0.0 &lt;= v)
(B, 1.0.0) -&gt; (E: 1.0.0)
(B, 1.2.0) -&gt; ((C: ∗) | (E: [ , 1.1.0 [  [ 1.1.0.1, ∞ [))
(B, 2.0.0) -&gt; (((A: v &lt; 3.0.0) &amp; (E: 1.0.0 &lt;= v)) | (C: ∗))
(E, 1.0.0)
(A, 1.0.0) -&gt; ((B: 1.0.0.1 &lt;= v) &amp; (C: v &lt; 1.4.0))
(A, 1.1.0) -&gt; ((B: 1.0.0.1 &lt;= v) | (C: v &lt; 1.4.0))
(A, 1.2.0) -&gt; ((B: 5.0.0.1 &lt;= v) | (C: v &lt; 1.4.0))
(A, 1.3.0) -&gt; ((C: v &lt; 1.4.0) | (B: 1.0.0.1 &lt;= v))
(A, 2.0.0) -&gt; ((B: 1.2.0.1 &lt;= v) &amp; ((C: ∗) | (D: [ 2.0.0, 2.0.0.1 [  [ 2.5.0, ∞ [)))
(A, 2.1.0) -&gt; ((B: 2.0.0 &lt;= v) &amp; ((C: v &lt; 2.0.0) | (E: 1.0.0 &lt;= v)))
(A, 3.0.0) -&gt; (((B: 2.0.0 &lt;= v) &amp; (C: 1.5.0 &lt;= v)) | ((D: 2.0.0 &lt;= v) &amp; (E: 1.0.0)))
(D, 2.0.0) -&gt; ((E: 2.0.0 &lt;= v) | (C: ∗))
Resolved Dependency Graph:
(A, 2.0.0) -&gt; (C, 1.5.0), (B, 2.0.0)
(B, 2.0.0) -&gt; (A, 2.0.0), (E, 1.0.0)
(E, 1.0.0)
(C, 1.5.0) -&gt; (E, 1.0.0)
</code></pre>
<p><span>where,</span></p>
<pre class="example"><code>name: "A"
version: "2.0.0"
depends: [
  "B" {&gt; "1.2.0"} &amp; ( "C" | ( "D" {= "2.0.0" &amp; ! (&lt; "2.5.0")} ) )
]
</code></pre></li>
<li><p><span><span class="todo TODO">O</span> support
variables as package with Opam <a href="https://opam.ocaml.org/doc/Manual.html#Filtered-package-formulas">filtered
formula</a></span></p></li>
</ol></li>
</ol></li>
<li><p><span>Next week</span></p>
<ol>
<li><p><span><span class="todo TODO">O</span> explore error
messages with exotic encoding, including opam’s package
formula</span></p>
<p><span>this might require a custom error
provider</span></p></li>
<li><p><span><span class="todo TODO">O</span> try <a href="https://crates.io/crates/pubgrub/0.3.0-alpha.1">PubGrub 0.3.0
prerelease</a></span></p>
<p><span>I think there’s probably a lot of improvements to
be had since the last release was 4 years ago.</span></p>
<ol>
<li><p><span><span class="todo TODO">O</span> it looks like
we might be able to manually add conflicts <a href="https://github.com/pubgrub-rs/pubgrub/blob/23357967c6473b358ffb7c0092e9c3fc4e4c972b/src/internal/core.rs#L94"><code class="verbatim">add_incompatibility</code></a></span></p></li>
</ol></li>
<li><p><span><span class="todo TODO">O</span> solve on the
opam repository</span></p>
<p><span>just strip out everything non essential (filtered
formulas, variables, conflicts, etc) to get something
working</span></p></li>
<li><p><span><span class="todo TODO">O</span> a
Debian/Alpine encoding in PubGrub, which I think should be much simpler
than Opam</span></p>
<p><span>and tie into opam with depexts for cross-ecosystem
resolutions</span></p>
<p><span><a href="https://github.com/astral-sh/uv">Uv</a>
is using the development branch of PubGrub.</span></p></li>
</ol></li>
<li><p><span>Could submit a theory paper to SPLASH and a
practice to SOSP <span class="tag" data-tag-name="idea"><span class="smallcaps">idea</span></span></span></p>
<ul>
<li>tool solve for these</li>
<li>tricky because of new problems</li>
<li>error reporting</li>
</ul></li>
<li><p><span>interactive solving with LLMS to NeurIPS <span class="tag" data-tag-name="idea"><span class="smallcaps">idea</span></span></span></p>
<ul>
<li>install a web server using jdgango</li>
<li>give environment</li>
<li>zero day attacks alpine</li>
<li>translate all ocaml packages to pip</li>
</ul></li>
<li><p><span>Eon</span></p>
<ol>
<li><p><span>Found a bug in Eon where NS records aren’t
being propigated to the secondary.</span></p>
<pre class="example"><code>$ dig ns freumh.org @freumh.org +short
ns1.freumh.org.
ns1.sirref.org.
$ dig ns freumh.org @sirref.org +short
ns1.sirref.org.
</code></pre>
<p><span>Which means we’re failing <a href="https://internet.nl/">https://internet.nl/</a> with nameservers
not reachable with IPv6.</span></p>
<p><span>This is probably in <a href="https://github.com/RyanGibb/eon/blob/5a56fd3173a3f123d99cb674cb28c133e0cfc263/lib/cap/primary.ml#L136">here</a>.</span></p></li>
<li><p><span>When an Eon server <u>statically</u> adds a
resource record it isn’t propigated to the secondary on a
restart.</span></p>
<p><span>Need to look at this.</span></p></li>
</ol></li>
<li><p><span>Eilean</span></p>
<p><span><a href="https://github.com/RyanGibb/eilean-nix/commit/5a8727fea2b7099eacfa9f275bf1ee915e0a1044">Fixed</a>
mailserver DKIM records resulting from a change in the Eon capability
update CLI</span></p></li>
<li><p><span>Spatial Name System</span></p>
<p><span>Agreed to prototype something to provision
resources from a nameserver on a Raspberry Pi that could be deployed to
ESP32 sensors while Josh continues to hack on the ESP32.</span></p></li>
</ol>
    </section>
</article>

