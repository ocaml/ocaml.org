---
title: 16 Oct 2023
description:
url: https://ryan.freumh.org/2023-10-16.html
date: 2023-10-16T00:00:00-00:00
preview_image:
authors:
- Ryan Gibb
source:
---

<article>
    <div class="container">
        <span>  Previous: <a href="https://ryan.freumh.org/2023-10-09.html"> 9 Oct 2023</a>  </span>
        <span>  Next: <a href="https://ryan.freumh.org/2023-10-23.html">23 Oct 2023</a>  </span>
    </div>
    
    <section>
        <h2>HotNets</h2>
<ul>
<li>Converted the SNS paper to the ACM final format. Spent way to long
figuring out how to make the paper open access. While trying to figure
this out I spoke to Jon, Chris, Ardwin, Justas, Sadiq, Helen, and Mort.
Mort explained the difference between the copyright, licensing
publishing rights, and open access. In the end, we had to use our
institutional email addresses to have the ACM’s open access policy kick
in.</li>
<li>Addressed Magnus’ comments on the paper, and fixed some
citations.</li>
<li>Pulled the discussion into the introduction.</li>
</ul>
<h2>Hibernia</h2>
<p><span>Had an idea regarding the <a href="https://ryan.freumh.org/2023-10-09.html#energy">energy</a> saving ‘wake-up’ device: the
network infrastructure has to be running anyway, so why not push this
functionality into the router, which are mostly running Linux now
anyway. We could implement this as a OCaml <a href="https://github.com/RyanGibb/aeon">AEON</a> amalgamation on top of
OpenWRT (or NixOS)… but could we go all the way and implement this as a
MirageOS unikernel (for maximum power savings). Could the <a href="https://github.com/mirage/mirage-tcpip">MirageOS TCP/IP stack</a>
be used as a router for this unikernel? The <a href="https://gitlab.developers.cam.ac.uk/cst/eeg/papers/pre-2019/-/blob/master/unikernel-router/unirouter.pdf">unikernel
router</a> from Magnus would seem to suggest so!</span></p>
<h2><code>shark</code> Reading Group</h2>
<p><span>On <a href="https://doi.org/10.1145/269005.266669">DIFC</a> and <a href="https://doi.org/10.1145/2018396.2018419">HiStar</a>.</span></p>
<p><img src="https://ryan.freumh.org/images/2023-10-20-reading-group.svg" style="width:100.0%" data-min-width="5cm" data-max-width="100%"></p>
<h2>Teaching</h2>
<ul>
<li>TA’d L50. One of my students was telling me about Fedora’s new
immutable operating systems that uses OSTree (like git for
binaries).</li>
<li>Marked and supervised all day for Distributed &amp; Current Systems
for Pembroke. I learnt how async/sync FSM semi-coupled/de-coupled
products worked in the first supervision, and in the second I did more
teaching than learning.</li>
</ul>
<h2>Self-hosting</h2>
<p><span>I mentioned that I didn’t set up a
PeerTube instance as my server doesn’t have enough storage, and Anil
mentioned that he as some SSD’s lying around that we could repurpose
with a USB/SATA interface host hosting on the Pi in my
office.</span></p>
<h2>Opam &amp; Nix</h2>
<p><span>I’ve implemented Spencer’s suggestion of
solving for a single instance of Nixpkgs for the Opam Nix backend for
use in the OCaml CI in a <a href="https://github.com/RyanGibb/opam-lang-repo-nix">prototype</a>.</span></p>
<p><span>I do so by creating a <code>nixpkgs</code>
package version for each Nixpkgs revision, that conflicts with other
versions of itself. When we don’t care about this (when we’re not
linking the provided libraries together), such as providing a rust
compiler and python interpreter with versions from different instance of
Nixpkgs, I think this could be made optional with a custom variable
&amp; filter.</span></p>
<p><span>The next step would be to generate this
from the Nixpkgs repository itself. Currently I’m just using a few
manually cherry picked examples in a prototype: <a href="https://github.com/RyanGibb/opam-lang-repo-nix">opam-lang-repo-nix</a>.</span></p>
    </section>
</article>

