---
title: Unix Module Considered Harmful
description: 'Recently I was working on a socket pool for a new scheduler for OCaml
  5 (multicore baby!) and I ran into a strange issue.


  This new socket pool works by spinning up a series of lightweight processes to accept
  connections. Every one of those will wait for a client to'
url: https://practicalocaml.com/unix-module-considered-harmful/
date: 2023-11-29T07:19:43-00:00
preview_image:
featured:
authors:
- Practical OCaml
source:
---

<p>Recently I was working on a socket pool for a <a href="https://github.com/leostera/riot?ref=practicalocaml.com">new scheduler</a> for OCaml 5 (multicore baby!) and I ran into a strange issue.</p><p>This new socket pool works by spinning up a series of lightweight processes to <em>accept connections</em>. Every one of those will wait for a client to connect, and create a new lightweight process to <em>handle a connection</em>. Eventually, the client will terminate the connection and the relevant processes are terminated.</p><p>All good so far.</p><p>All of this accepting and connecting is done via file descriptors (a <code>Unix.file_desc</code>). In some cases they correspond to <em>listening sockets</em>, when used to accept new connections, and when connected to a client they become <em>streaming sockets</em> (so a socket used to send/receive data). But really all you have is an integer that's behind the <code>Unix.file_desc</code> type: the Unix file descriptor.</p><p>Okay, so what went wrong?</p><p>In one of my load tests, I consistently could reproduce that <em>the entire application would just exit</em>. No error messages, no prints, no stack traces. It was running and then at some point, it just wasn't.</p><p>I can't emphasize enough how much I dug through the entire runtime, adding more logging, and more safety nets, just to see if I was doing something wrong. A good day of work was lost to this.</p><p>Then asking around, after exploring all the options I could think of, I asked on the #multicore channel of OCaml Labs, and I got an answer from Stephen Dolan.</p><p>Turns out that:</p><ul><li>if you have a streaming socket</li><li>and you <strong>write to it</strong></li><li>but the client <strong>has closed it</strong></li><li>your program will <strong>receive a Unix signal:</strong> <code>SIGPIPE</code> </li><li>which if you didn't know about, and didn't specifically set to ignore, will <strong>TERMINATE YOUR PROGRAM</strong>.</li></ul><p>&#129318;&zwj;&#9794;&#65039;</p><p>No return value, no exception, nothing of the sort. You have this entirely out-of-band input to your program that even in an impure functional language like OCaml feels like a sucker punch.</p><p>Why does this happen? Let's see.</p><h2>The Unix module</h2><p><a href="https://v2.ocaml.org/api/Unix.html?ref=practicalocaml.com" rel="noreferrer">The Unix module </a>is the default way to interact with your operating system in OCaml. You've probably used <code>Lwt_unix</code> before or the <code>-unix</code> flavor of your favorite lib if you aren't using promises yet. All of those rely on <code>Unix</code>.</p><p>But really, this module is just super low-level bindings to <em>syscalls</em>. </p><div class="kg-card kg-callout-card kg-callout-card-red"><div class="kg-callout-emoji">&#128009;</div><div class="kg-callout-text"><b><strong style="white-space: pre-wrap;">Here be Dragons</strong></b>. We're digging deeper than usual here, so here's a little sword in case we find something dangerous: &#128481;&#65039;</div></div><p><em>Syscalls,</em> or &quot;system calls&quot;, are little bridges between the boundaries of <em>User space </em>and <em>Kernel space</em> in your operating system:</p><ul><li>Kernel space is where your operating system implements all sorts of things to make your computer run, like how to write to disks, or read from the network. If something is buggy here it will BRICK your computer.</li><li>User space is where you and I write our buggy software. Buggy is cool here. It <s>keeps us employed</s> won't brick the computer.</li></ul><p>And our Unix module is full of bindings to syscalls like <code>write(2)</code> that lets User space programs actually write files by asking Kernel space code to do the writing. Neat, right?</p><p>The fact that were are using these syscalls isn't obvious, but as you can see here in this <a href="https://github.com/ocaml/ocaml/blob/trunk/otherlibs/unix/unix_unix.ml?ref=practicalocaml.com#L264-L283">snippet</a> for <code>Unix.write</code> we are making an <em>external</em> call to a function called <code>caml_unix_write</code>:</p><pre><code class="language-ocaml">(* lowest-level binding, directly calling C code *)
external unsafe_write : file_descr -&gt; bytes -&gt; int -&gt; int -&gt; int
                      = &quot;caml_unix_write&quot;

(* slightly-higher level binding, that checks the buffer offset is ok *)
let write fd buf ofs len =
  if ofs &lt; 0 || len &lt; 0 || ofs &gt; Bytes.length buf - len
  then invalid_arg &quot;Unix.write&quot;
  else unsafe_write fd buf ofs len</code></pre><p><code>caml_unix_write</code> will in turn call a C function called <code>write</code> which comes from <code>libc</code> on Unix-like operating systems that follow the POSIX standard, and will call <code>WriteFile</code> from the Windows APIs when compiling on Windows.</p><p><code>write</code> from libc, and <code>WriteFile</code> from the Windows APIS. Those are the syscalls.</p><div class="kg-card kg-callout-card kg-callout-card-purple"><div class="kg-callout-emoji">&#128584;</div><div class="kg-callout-text">If I've lost you already because you wanted to learn about OCaml and now we're talking about C, then you will understand why I'm frustrated about this whole thing.</div></div><p>The important thing to know is that when you are using this module, many of the functions you will call there are not OCaml code. They are C code, and they reach into the depths of your operating system to do dangerous, wonderful, weird things.</p><p>On Unix systems, one of those is<em> signals</em>.</p><h2>Unix Signals</h2><p>Unix has a way of <em>interrupting</em> a process with a mechanism called <em>signals</em>. A process in turn can tell Unix how it's going to react to those signals, by setting a <em>signal handler.</em></p><p>It's essentially a configurable, OS-triggered callback.</p><p>Some of these signals are very common. Like when you press <code>Ctr+C</code> to exit a long-running program, you're really sending a <code>SIGINT</code> signal, also known as an<em> interrupt signal.</em></p><p>You can of course override this, and you see many REPLs do it, so that if you accidentally press <code>Ctrl+C</code> you get a chance to confirm this and exit or return to the program.</p><p>Signals, however, are not a part of the Unix module. If we want to configure them (and their handlers) we need to use the <code>Sys</code> module.</p><div class="kg-card kg-callout-card kg-callout-card-yellow"><div class="kg-callout-emoji">&#8265;&#65039;</div><div class="kg-callout-text"><b><strong style="white-space: pre-wrap;">What is the Sys module?</strong></b> It's a bag of sort of random stuff, and a few things that probably deserve to be in a module called Sys like what OS you're on. If you ask me, I'd rather we didn't have a Sys/Unix module at all, and just had proper abstractions for File, Socket, OS, Env, Process, etc. But c'est la vie. In the meantime, we have </div></div><p>In particular, we need to use the <code>Sys.set_signal</code>. This function lets you set the behavior for a particular signal, which can be one of:</p><ul><li>Default &ndash; whatever POSIX decides is the default</li><li>Ignore &ndash; just do nothing with it</li><li>Set a custom handler &ndash; use this handler to do something that fits your program</li></ul><h2>Fixing The SIGPIPEs</h2><p>The error we had described before is fixed with a single line of OCaml at the top of our program:</p><figure class="kg-card kg-code-card"><pre><code class="language-ocaml">Sys.(set_signal sigpipe Signal_ignore);;</code></pre><figcaption><p dir="ltr"><span style="white-space: pre-wrap;">Mark the SIGPIPE signal to be ignored.</span></p></figcaption></figure><p>But the knowledge required to put that line there isn't trivial.</p><p>You need to know that the Unix module is just a wrapper around OS syscalls. And in here you'll want to know exactly which one, which may involve <a href="https://github.com/ocaml/ocaml/blob/20336d050ca9787c347f78608ed4decf3b5a21d9/otherlibs/unix/write_unix.c?ref=practicalocaml.com#L31-L56">digging</a> through some of the OCaml C libraries.</p><p>You need to know where to find the right doc for that syscall (<a href="https://man.openbsd.org/write.2?ref=practicalocaml.com">is it BSD</a> since macOS inherited a lot from it? That doesn't mention anything about SIGPIPEs, maybe <a href="https://www.man7.org/linux/man-pages/man2/write.2.html?ref=practicalocaml.com">the Linux syscall manual</a> is relevant here?</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://practicalocaml.com/content/images/2023/11/Screenshot-2023-11-29-at-07.30.12.png" class="kg-image" alt="alt" loading="lazy" width="1378" height="256" srcset="https://practicalocaml.com/content/images/size/w600/2023/11/Screenshot-2023-11-29-at-07.30.12.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/11/Screenshot-2023-11-29-at-07.30.12.png 1000w, https://practicalocaml.com/content/images/2023/11/Screenshot-2023-11-29-at-07.30.12.png 1378w" sizes="(min-width: 720px) 720px"/><figcaption><span style="white-space: pre-wrap;">Linux system manual saving the day</span></figcaption></figure><p>And then you have to learn about Signals, how to catch them, and how to use the <code>Sys</code> module to do that. Granted this last part is the easiest since it's more actionable, but that second step?! Not as easy a leap to make.</p><h2>Conclusion</h2><p>This is most definitely not the kind of surprise you want to find when writing a type-safe, high-level functional programming language like OCaml.</p><p>Hell, I think <em>Python does this better</em> by throwing an <code>IOError</code> instead. That would've saved me hours of self-doubt.</p><p><strong>If you really need this level of control, </strong>you may find it useful to mentally frame it as writing <em>garbage-collected C</em>, and behave accordingly. And please shield your users from all the gory details.</p><p>Otherwise<strong>,</strong> <strong>stay happy and away from the Unix module</strong> and look for alternatives. Use <a href="https://ocaml.org/p/bos/latest?ref=practicalocaml.com">Bos</a> for your OS interactions, stick to a higher-level library for sockets, and if it comes to it, isolate that part of your system.</p><p>I hope this gotcha won't get you the next time you're writing network code, and if you have any stories like this one, I'd be happy to share them on Practical OCaml too.</p>
