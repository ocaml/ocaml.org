---
title: 'How I explore domain problems cheaply and fast with OCaml: modeling a web
  router'
description: "You've heard of Domain-Driven Design, now buckle up for Type-Driven
  Domain..wait. Typed Domains Driving...nevermind. We're gonna use Only Types to Understand
  our Domain Problems Very Fast! \U0001F680"
url: https://practicalocaml.com/how-i-explore-domain-problems-faster-and-cheaply-in-ocaml/
date: 2023-08-24T13:29:21-00:00
preview_image:
authors:
- Practical OCaml
source:
---

<p>Hello folks! Starting out the blog with a topic that I love: domain modeling.</p><p>Domain modeling is the art and science of figuring out how to map some messy, fuzzy, real-life ideas and things, into a computer program that we can execute.</p><p>It is usually easier to say than it is to do, so I figured I'd give you an example of how I've done domain modeling in the past and how I like to explore domain problems through it.</p><h2>Shapes of Things</h2><p>There's only so many kinds of data we can have in our programs. You have single things, you have collections of the same things. You have collections of different things that also happen to be a thing, and they can either be one of many things that are the same thing, or many things together making a thing!</p><p>Where I'm going with this is that the shapes of data that you normally work with come in a few packages.</p><p>We have many things that belong together but are distinct on their own. In OCaml we call these <em>variants</em>.</p><p>We have many things that belong together and form a single unit, where every piece has its own place, and the place doesn't have a name. In OCaml we call these <em>tuples. </em>But when these pieces don't have a place and instead have a name, in OCaml we call these <em>records</em>.</p><p>We have things that exist on their own and we don't know much about them. In OCaml we call these <em>abstract types</em>.</p><p>We have things that don't tell us everything that they are, but that can hide information from us. In OCaml we call these <em>generalized abstract data types</em> (GADTs, and I pronounce it like &quot;cats&quot; but with a G, try it out loud, its cool, no-one can hear you).</p><p>We have things that are collections of other things. Lists, arrays, hash tables, sets, queues, heaps, tuples. </p><p>And in fact, we can create most of these different shapes of data with some of the simpler ones. Records can made with tuples. Lists can be made with variants. And so on.</p><p>Okay, enough of this. Let's start using these shapes for some specific domain problems.</p><h2>Modeling a Web Router</h2><p>We'll start with one that most of you will likely be familiar with: a web router. That is a router that helps a web framework figure out where to send each request. There are many out there, and I'm not pitching you to write your own (but you should, because it's a good way to learn!).</p><p>But what really <em>is</em> a web router? It's a collection of patterns and handler functions. Not unlike a <code>match</code> expression really. It matches the <code>pattern</code> against a web request object, and if it succeeds it will execute the function that corresponds to it.</p><p>So we can start by defining what we know:</p><ul><li>there are patterns, and</li><li>there are handler functions,</li><li>a route is a pair of a pattern and a handler</li><li>a router has routes</li></ul><figure class="kg-card kg-image-card"><img src="https://practicalocaml.com/content/images/2023/08/image-1.png" class="kg-image" alt="alt" loading="lazy" width="1040" height="386" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-1.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-1.png 1000w, https://practicalocaml.com/content/images/2023/08/image-1.png 1040w" sizes="(min-width: 720px) 720px"/></figure><p>Brilliant! Now we have our types in place, we can start exploring how they interact with each other.</p><p>A router typically will receive some form of <code>request</code> and turn it into a <code>response</code>. After all, we expect to reply to our users with something. </p><p>So then, to make a response, we need &nbsp;to find a <code>handler</code>. We can do that by matching against every <code>route</code> until a <code>pattern</code> matches. When that happens it expects to receive a <code>response</code>.</p><p>Now slowly we are building up the right <em>vocabulary</em> not just around the problem, but also in the code that deals with it.</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://practicalocaml.com/content/images/2023/08/image-3.png" class="kg-image" alt="alt" loading="lazy" width="1040" height="746" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-3.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-3.png 1000w, https://practicalocaml.com/content/images/2023/08/image-3.png 1040w"/></figure><p> Notice how we create a few new types for <code>request</code> and <code>response</code>, which are new Things we are working with.</p><p>We also created two new functions, one for matching a <code>pattern</code> against a <code>request</code> called <code>matches</code>; and a second one called <code>route</code> to create a <code>response</code> from a <code>router</code> and <code>request</code>.</p><p>And that's it. We have our first model for a router. We have a clearer understanding of what the moving pieces are, and how they connect together.</p><p>From here we can take it in many directions, but what I like to do is to do a second pass and <em>challenge the model</em>.</p><h3>Challenging the model</h3><p>In the process of challenging, we want to grab individual pieces and ask what's important about them, and how are they different than other things, and why are they really needed.</p><p>For example, why is a <code>pattern</code> a separate entity and not just a behavior of a <code>handler</code>? A handler could well <em>ignore</em> a request and just let the next handler handle it.</p><p>This would lead to a slightly different model, where a handler either tells us it has handled or ignored something, or the handler itself calls the next thing.</p><p>In the first case, we can model it by making a new type of that can be either an ignored handler result, or a handled handler result:</p><figure class="kg-card kg-image-card"><img src="https://practicalocaml.com/content/images/2023/08/image-4.png" class="kg-image" alt="alt" loading="lazy" width="1040" height="746" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-4.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-4.png 1000w, https://practicalocaml.com/content/images/2023/08/image-4.png 1040w" sizes="(min-width: 720px) 720px"/></figure><p>This leads naturally to some implementations, such as folding over the list of routes, and bailing as soon as we find a route that returned <code>Handled(res)</code>. This is super flexible when it comes letting the route itself decide how or if it will process a request.</p><p>But in the second case, we can see we have an even more powerful model. In this one we are making sure every handler receives <em>the next handler</em>, which it can call at any point, any number of times. This is what this second model looks like:</p><figure class="kg-card kg-image-card"><img src="https://practicalocaml.com/content/images/2023/08/image-5.png" class="kg-image" alt="alt" loading="lazy" width="1056" height="656" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-5.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-5.png 1000w, https://practicalocaml.com/content/images/2023/08/image-5.png 1056w" sizes="(min-width: 720px) 720px"/></figure><p>This model leads to a recursive implementation, where we have to build our handlers in advance, so that the calls to <code>next</code> go in the right order. This can be much trickier than the prior models we saw.</p><h3>Refining the Model</h3><p>Once we find a model that we like, and in this case we'd like to stick with the first one, we can start doing some <em>refinements</em>.</p><p>Refining is the process of adding detail to the model, and it helps us see how it can materialize as a working application.</p><p>For example, we can take our <code>pattern</code> type and start looking into what shapes it can actually take. Usually, a domain expert here is the best person to ask: &quot;what really is a pattern?&quot;</p><p>In our case, we want to be able to match on the route URL or <em>path;</em> the kind of HTTP method they are using, or <em><em>verb</em></em>; and we'd like to know what is in the body. </p><p>To do this we expand our <code>pattern</code> type once to include some data, and in the process we define a new type for the HTTP method, since we knew we needed that and we roughly understand upfront the shape it has: it can be one of some options. The new pattern now looks like this: </p><figure class="kg-card kg-image-card"><img src="https://practicalocaml.com/content/images/2023/08/image-6.png" class="kg-image" alt="alt" loading="lazy" width="1040" height="522" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-6.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-6.png 1000w, https://practicalocaml.com/content/images/2023/08/image-6.png 1040w" sizes="(min-width: 720px) 720px"/></figure><p>Excellent, but now what exactly happens in the body? </p><p>As it is above, it can either be present and be a string, or be not present. If it is <code>Some(string)</code> then either an empty string <code>&quot;&quot;</code> and the entire works of Shakespeare in Korean would be valid bodies. Is this really what we mean to say?</p><p>Here's where our refining doubles down, and asks if there's anything special about the body in this specific pattern, or in this specific route. So we're relating the current refining learnings with our past learnings.</p><p>Turns out the body should actually be something that the handler can in fact handle, so we need somehow to make it fit into what the handler expects.</p><p>So does the handler really expect a <code>request</code>? Or does it expect a specific kind of request? Let's see if we can be more specific in a few steps:</p><ol><li>Let our <code>pattern</code> be more specific about a request payload</li><li>Make our <code>handler</code> be specific about the request payload</li><li>Make our <code>router</code> work with our new <code>handler</code></li></ol><p>We will start by making our <code>pattern</code> take <em>type parameter</em>. At this point a <em>type parameter</em> usually means &quot;here's a kind of data that is really a much larger group of data, where there are subgroups of it that can't be mixed&quot;.</p><figure class="kg-card kg-image-card"><img src="https://practicalocaml.com/content/images/2023/08/image-9.png" class="kg-image" alt="alt" loading="lazy" width="1040" height="432" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-9.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-9.png 1000w, https://practicalocaml.com/content/images/2023/08/image-9.png 1040w" sizes="(min-width: 720px) 720px"/></figure><p>BUT there's a big problem here. We can't really create the <em>pattern</em> ahead of time, knowing what the payload will be like. </p><p>A pattern really is a <em>specification</em> for how to match against requests. So instead, we need to provide a <em>way</em> of reading the body into the <code>'payload</code> type. Thankfully, we have first-class functions in OCaml, so this is an easy fix.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://practicalocaml.com/content/images/2023/08/image-10.png" class="kg-image" alt="alt" loading="lazy" width="1040" height="432" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-10.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-10.png 1000w, https://practicalocaml.com/content/images/2023/08/image-10.png 1040w" sizes="(min-width: 720px) 720px"/><figcaption>Notice how our <code>body</code> now becomes a function that will receive a <code>string</code> and try to return a <code>'payload</code>. If it can't, the it can always return an <code>option</code>. In practice we would probably use a <code>result</code> type here, but for the sake of this post an <code>option</code> is good enough.</figcaption></figure><p>Next up, we have our handler, which now should receive a type parameter for our payload and look a bit more like this:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://practicalocaml.com/content/images/2023/08/image-19.png" class="kg-image" alt="alt" loading="lazy" width="1130" height="304" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-19.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-19.png 1000w, https://practicalocaml.com/content/images/2023/08/image-19.png 1130w" sizes="(min-width: 720px) 720px"/><figcaption>Our handler function type now receives a payload before a request.</figcaption></figure><p>And finally, it seems that our <code>route</code> and <code>router</code> type doesn't need much amending. Because we really just need a list of patterns and handlers, and that's exactly what they are, right? </p><p>Right?! &#128584;</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://practicalocaml.com/content/images/2023/08/image-17.png" class="kg-image" alt="alt" loading="lazy" width="2000" height="394" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-17.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-17.png 1000w, https://practicalocaml.com/content/images/size/w1600/2023/08/image-17.png 1600w, https://practicalocaml.com/content/images/size/w2400/2023/08/image-17.png 2400w" sizes="(min-width: 1200px) 1200px"/></figure><p>Oh no. If we follow this current refinement and thread in a <code>'payload</code> parameter to our <code>route</code> type, we will end up with a single type of payload in the list of routes. This is because the list type can only hold one type of elements, and every <code>'payload route</code> is essentially a new type!</p><ul><li><code>unit route</code> is a type of routes that have no payloads</li><li><code>user route</code> is a type of routes that have payloads of type <code>user</code></li><li>and every one of these is not mixable with the rest :(</li></ul><p>So we can either backtrack, and <em>move</em> this body parsing function inside the handler, to let the handlers figure out how to work with it. Or we can find another way of putting all these handlers together in a list, while maintaining the model as close to the domain. &nbsp; </p><p>For this, we can use a special type of type OCaml has, that lets us <em>hide information</em>. The gist is this:</p><ul><li>We will refactor our <code>route</code> type to include a constructor named <code>Route</code></li><li>this constructor will take a <code>'payload pattern</code> and a <code>'payload handler</code></li><li>and it will return a <code>route</code> that hides the <code>'payload</code> information</li><li>so we can put all our routes in a single list!</li></ul><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://practicalocaml.com/content/images/2023/08/image-20.png" class="kg-image" alt="alt" loading="lazy" width="1330" height="432" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-20.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-20.png 1000w, https://practicalocaml.com/content/images/2023/08/image-20.png 1330w" sizes="(min-width: 1200px) 1200px"/><figcaption>Using a GADT to capture a route with a pattern and a handler, but hiding their payload parameter. {</figcaption></figure><p>Damn, there we go! &#128293; Now we have all the information we want and it seems to be nicely encapsulated in this <code>route</code> type.</p><p>This model actually leads to a rather complex implementation, because every time we unpack the <code>Route</code>, we must make use of both the pattern and the handler at the same time. That's the only requirement for using this information-hiding pattern: you can peak, but you can't leak the information.</p><p>For completeness sake, here's a small implementation that follows our model:</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://practicalocaml.com/content/images/2023/08/image-21.png" class="kg-image" alt="alt" loading="lazy" width="1348" height="1466" srcset="https://practicalocaml.com/content/images/size/w600/2023/08/image-21.png 600w, https://practicalocaml.com/content/images/size/w1000/2023/08/image-21.png 1000w, https://practicalocaml.com/content/images/2023/08/image-21.png 1348w" sizes="(min-width: 1200px) 1200px"/></figure><h2>Conclusions from Modeling a Router</h2><p>Like this, we've quickly gone through several iterations of our model, tried to understand better what problem we are trying to solve, what are some of the constraints it has, and how our model leads to different implementations.</p><p>It is very important to understand that this first implementation is meant to be <em>correct</em>, and not necessarily optimal. But it can make a great first implementation to test things against, and eventually, help you optimize making sure you are not breaking good behavior!</p><p>I'd love to go on with some more examples, like:</p><ol><li>modeling regulatory compliance for betting companies</li><li>modeling the publishability window of content in the music industry following geographic restrictions</li><li>modeling the optimal publishing of photography content to a social network</li><li>modeling an offline-first graph database for the edge</li><li>and more!</li></ol><p>But we're already over 2,000 words and I'd like you to get a glass of water and maybe stretch your legs. So let me know which modeling example you'd like to see in a next post.</p><p>If you liked this, please subscribe so you get the next issue of Practical OCaml right in your inbox, and share it with your camel friends on lobste.rs, hackernews, x.com, and so on.</p><p>Have you implemented typed state machines in some other ways? Have anything to add or challenge? I'd love to hear it! <a href="https://twitter.com/leostera/status/1695703044409676029?ref=practicalocaml.com">Join the x.com thread</a>.</p><p>Happy Cameling! &#128043;</p><p></p>
